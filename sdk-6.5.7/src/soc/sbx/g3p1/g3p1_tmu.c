
/*
 * $Id: tmu_c.stg,v 1.85 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * g3p1_tmu.c: Guadalupe2k V1.3 TMU table manager & wrappers
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from sdk/caladan_ucode/g3p1/src/g3p1_tmu_cfg.lrp.
 * Edits to this file will be lost when it is regenerated.
 *
 */

#include <shared/bsl.h>

#include <soc/types.h>
#include <soc/drv.h>
#include <soc/mem.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT) 
#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_tmu.h>
#include <soc/sbx/g3p1/g3p1_tmu_sim.h>
#include <sal/core/boot.h>
#include <soc/sbx/caladan3/tmu/hash.h>
#include <soc/sbx/caladan3/tmu/dm.h>
#include <soc/sbx/caladan3/tmu/taps/taps.h>

extern int soc_sbx_g3p1_hash_add_ext(int unit, 
                                    soc_sbx_tmu_hash_handle_t handle,
                                    uint32 *key, uint32 *value);
extern int soc_sbx_g3p1_hash_update_ext(int unit,
                                        soc_sbx_tmu_hash_handle_t handle, 
                                        uint32 *key, uint32 *value);
extern int soc_sbx_g3p1_hash_delete_ext(int unit,
                                        soc_sbx_tmu_hash_handle_t handle,
                                        uint32 *key);
extern int soc_sbx_g3p1_hash_get_ext(int unit, 
                                     soc_sbx_tmu_hash_handle_t handle, 
                                     uint32 *key, uint32 *value);

extern int soc_sbx_g3p1_hash_hw_get_ext(int unit, 
                                     soc_sbx_tmu_hash_handle_t handle, 
                                     uint32 *key, uint32 *value);                                           
                                                                               
/*
 * Utility functions for LPM table key packing
 *
 */

/* Bits are numbered left to right in the array.
 *      - Bit 0 is the most significant bit of key_array[0]
 *      - Bit 2 is the 5th bit in key_array[0]
 *      - Bit 8 is the most significant bit of key_array[1]
 */
static uint8 lpm_key_get_bit(uint8* key_array, int array_size, int bit_num) {
    int byte_index;
    int shift_by;
    
    byte_index = bit_num/8;
    if (byte_index >= array_size)
        return 0;
    
    shift_by = 7 - (bit_num % 8);    
    return (key_array[byte_index] >> shift_by) & 1;
}

static void lpm_key_insert_bit(uint8* key_array, int array_size, int bit_num, int bit_value) {
    int byte_index;
    int shift_by;
    int bit;
    
    byte_index = bit_num/8;
    if (byte_index >= array_size)
        return;
    
    bit = bit_value & 1;
    shift_by = 7 - (bit_num % 8); 
    bit = bit << shift_by;
       
    key_array[byte_index] |= bit;
}    
    
       
static void shift_right(uint8* key_array, int array_size_bytes, int num_bits) {
    uint8 key[32];
    int i;
    int target_bit_pos;
    int curr_bit_pos;
    int bit;
    
    for (i=0; i<32; i++)
        key[i] = 0;
    
    target_bit_pos = (array_size_bytes * 8) - 1;
    curr_bit_pos = target_bit_pos - num_bits;
    while (curr_bit_pos >= 0) {
        bit = lpm_key_get_bit(key_array, array_size_bytes, curr_bit_pos);
        lpm_key_insert_bit(key, array_size_bytes, target_bit_pos, bit);
        
        curr_bit_pos--;
        target_bit_pos--;
    }  
    
    for (i=0; i<array_size_bytes; i++)
        key_array[i] = key[i];       
}
                                             
static int align_right(int key) {    
    char *ptr = (char *)&key;
    int a, b, c, d;
    int v = 0x1;            
    int behost = !*((uint8 *) &v);
    if (behost)       
        return key;
    
    a = ptr[0];
    b = ptr[1];
    c = ptr[2];
    d = ptr[3];
    
    return ((d << 24) | (c << 16) | (b << 8) | (a));
}    
                


static void create_program_mac(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_MAC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 8; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 6;
      prog_info->key_info[0].shift[1] = 6; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 2;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 2; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 6;
      prog_info->key_info[1].shift[1] = 6; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 2;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = TRUE;
      prog_info->key_shift[1] = 2; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 0;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 0, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_pvv2e(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_PVV2E_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 4;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 4;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 1;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 1, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_labels(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_LABELS_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 4;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 7;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = TRUE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 2;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 2, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_v4lpm(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {   
     
      soc_sbx_g3p1_tmu_table_desc_t* table_desc;      
      soc_sbx_caladan3_tmu_program_info_t *prog_info;
      unsigned int update = 0;
      
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V4LPM_PROG_ID];         
     
              
      table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID]);
       
      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV4_SUB_KEY;
      prog_info->key_info[0].shift[0] = 8; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 4;      
      prog_info->key_info[0].taps_seg = table_desc->taps->segment;
      prog_info->key_info[0].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[0].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[0] = 4;                         
     
              
      table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID]);
       
      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV4_SUB_KEY;
      prog_info->key_info[1].shift[0] = 8; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 2;
      prog_info->key_info[1].shift[1] = 4; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 4;      
      prog_info->key_info[1].taps_seg = table_desc->taps->segment;
      prog_info->key_info[1].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[1].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[1] = 4; 
     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 3;
     
      soc_sbx_lrp_setup_tmu_program(unit, 3, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);
}  
static void create_program_v4mc(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V4MC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[0].shift[0] = 8; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 8;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 8; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 4;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 4, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_v4mc_gv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V4MC_GV_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 4; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 4;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 4; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 5;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 12, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_v6lpm(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {   
     
      soc_sbx_g3p1_tmu_table_desc_t* table_desc;      
      soc_sbx_caladan3_tmu_program_info_t *prog_info;
      unsigned int update = 0;
      
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V6LPM_PROG_ID];         
     
              
      table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID]);
       
      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV6_SUB_KEY;
      prog_info->key_info[0].shift[0] = 32; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 16;      
      prog_info->key_info[0].taps_seg = table_desc->taps->segment;
      prog_info->key_info[0].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[0].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[0] = 16;                         
     
              
      table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID]);
       
      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV6_SUB_KEY;
      prog_info->key_info[1].shift[0] = 32; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 2;
      prog_info->key_info[1].shift[1] = 16; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 16;      
      prog_info->key_info[1].taps_seg = table_desc->taps->segment;
      prog_info->key_info[1].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[1].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[1] = 16; 
     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 6;
     
      soc_sbx_lrp_setup_tmu_program(unit, 5, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);
}  
static void create_program_v6mc(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V6MC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_304; 
      prog_info->key_info[0].shift[0] = 32; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 32;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 32; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_304; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 7;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 6, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_v6mc_gv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_V6MC_GV_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[0].shift[0] = 16; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 16;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 16; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 8;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 13, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_lpm_mac(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_g3p1_tmu_table_desc_t* table_desc;   
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_LPM_MAC_PROG_ID];
      
              
      table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID]);
       
      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV4_SUB_KEY;
      prog_info->key_info[0].shift[0] = 4; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 4;      
      prog_info->key_info[0].taps_seg = table_desc->taps->segment;
      prog_info->key_info[0].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[0].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[0] = 4; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 8; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 6;
      prog_info->key_info[1].shift[1] = 6; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 2;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = TRUE;
      prog_info->key_shift[1] = 2; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 9;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 14, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_egr_smac(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_EGR_SMAC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 6;
      prog_info->key_info[0].shift[1] = 6; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 2;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 2; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 6;
      prog_info->key_info[1].shift[1] = 6; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 2;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 2; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 10;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 15, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_oamrx(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_OAMRX_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 8;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 8;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 11;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 9, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_maidmep(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_MAIDMEP_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 8;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 8;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 12;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 10, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_emlfilter(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_EMLFILTER_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_INSERT_DELETE; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 63;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_INSERT_DELETE; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 63;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 13;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 11, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_labels3(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_LABELS3_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[0].shift[0] = 54; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 10;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_176; 
      prog_info->key_info[1].shift[0] = 56; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 14;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 16, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_bfd_ld2e(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_G3P1_TMU_BFD_LD2E_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 4;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 0;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 15;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 17, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}



/*
 * Entry accessor implementations for mac
 */

void soc_sbx_g3p1_mac_t_init(
    soc_sbx_g3p1_mac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_mac_t));
    e->smac_hit = 1;
    e->dmac_hit = 1;
}

/* entry pack accessor implementation for mac */
static int soc_sbx_g3p1_mac_pack(int unit,
    soc_sbx_g3p1_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->ageid; break;
          case 1: p = (uint8 *) &e->smac_hit; break;
          case 2: p = (uint8 *) &e->sdrop; break;
          case 3: p = (uint8 *) &e->dontage; break;
          case 4: p = (uint8 *) &e->sreserved; break;
          case 5: p = (uint8 *) &e->pending; break;
          case 6: p = (uint8 *) &e->poe; break;

          case 7: p = (uint8 *) &e->dmac_hit; break;
          case 8: p = (uint8 *) &e->dcopy; break;
          case 9: p = (uint8 *) &e->ddrop; break;
          case 10: p = (uint8 *) &e->dreserved; break;
          case 11: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mac */
static int soc_sbx_g3p1_mac_unpack(int unit,
                soc_sbx_g3p1_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->ageid; break;
          case 1: p = (uint8 *) &e->smac_hit; break;
          case 2: p = (uint8 *) &e->sdrop; break;
          case 3: p = (uint8 *) &e->dontage; break;
          case 4: p = (uint8 *) &e->sreserved; break;
          case 5: p = (uint8 *) &e->pending; break;
          case 6: p = (uint8 *) &e->poe; break;

          case 7: p = (uint8 *) &e->dmac_hit; break;
          case 8: p = (uint8 *) &e->dcopy; break;
          case 9: p = (uint8 *) &e->ddrop; break;
          case 10: p = (uint8 *) &e->dreserved; break;
          case 11: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mac */
static int soc_sbx_g3p1_mac_index_check(int unit, uint32 *vindex, soc_sbx_g3p1_6_byte_t imac, int ivsi )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) imac; break;
          case 1: p = (uint8 *) &ivsi; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for mac */
static int soc_sbx_g3p1_mac_index_unpack(int unit, int *vindex, soc_sbx_g3p1_6_byte_t nimac, int *nivsi)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nimac; break;
          case 1: p = (uint8 *) nivsi; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for mac */
int soc_sbx_g3p1_mac_entry_check(int unit,
                                 soc_sbx_g3p1_mac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->ageid; break;
          case 1: ev = e->smac_hit; break;
          case 2: ev = e->sdrop; break;
          case 3: ev = e->dontage; break;
          case 4: ev = e->sreserved; break;
          case 5: ev = e->pending; break;
          case 6: ev = e->poe; break;
          case 7: ev = e->dmac_hit; break;
          case 8: ev = e->dcopy; break;
          case 9: ev = e->ddrop; break;
          case 10: ev = e->dreserved; break;
          case 11: ev = e->ftidx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for mac */
int soc_sbx_g3p1_mac_set(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_mac_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_mac_update(unit, imac, ivsi, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_mac_add(unit, imac, ivsi, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for mac */
int soc_sbx_g3p1_mac_add(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_mac_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_mac_add_ext_sim(unit, imac, ivsi, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for mac */
int soc_sbx_g3p1_mac_get(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_mac_get_ext_sim(unit, imac, ivsi, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for mac */
int soc_sbx_g3p1_mac_hw_get(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_mac_get_ext_sim(unit, imac, ivsi, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for mac */
int soc_sbx_g3p1_mac_update(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_mac_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_mac_add_ext_sim(unit, imac, ivsi, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for mac */
int soc_sbx_g3p1_mac_delete(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_mac_delete_ext_sim(unit, imac, ivsi);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for mac */
int soc_sbx_g3p1_mac_remove(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi)
{
    return soc_sbx_g3p1_mac_delete(unit, imac, ivsi);
}

/* Get the first element of mac */
int soc_sbx_g3p1_mac_first(int unit, soc_sbx_g3p1_6_byte_t nimac, int *nivsi)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_mac_index_unpack(unit, (int *)key, nimac, nivsi);    
}

/* Get the next element of mac */
int soc_sbx_g3p1_mac_next(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, soc_sbx_g3p1_6_byte_t nimac, int *nivsi)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_mac_index_check(unit, key, imac, ivsi);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_mac_index_unpack(unit, (int *)next_key, nimac, nivsi);  
}

/**
New entry set accessor implementation for mac
*/
int soc_sbx_g3p1_mac_data_set(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mac_t entry;

    soc_sbx_g3p1_mac_t_init(&entry);
    s = soc_sbx_g3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mac_set(unit, imac, ivsi, &entry);

    return s;
}

/**
New entry add accessor implementation for mac
*/
int soc_sbx_g3p1_mac_data_add(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mac_t entry;

    soc_sbx_g3p1_mac_t_init(&entry);
    s = soc_sbx_g3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mac_add(unit, imac, ivsi, &entry);

    return s;
}

/**
New entry get accessor implementation for mac
*/
int soc_sbx_g3p1_mac_data_get(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mac_t entry;

    soc_sbx_g3p1_mac_t_init(&entry);
    s = soc_sbx_g3p1_mac_get(unit, imac, ivsi, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mac_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for mac
*/
int soc_sbx_g3p1_mac_data_update(int unit, soc_sbx_g3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mac_t entry;

    soc_sbx_g3p1_mac_t_init(&entry);
    s = soc_sbx_g3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mac_update(unit, imac, ivsi, &entry);

    return s;
}


/*
 * Entry accessor implementations for pvv2e
 */

void soc_sbx_g3p1_pvv2e_t_init(
    soc_sbx_g3p1_pvv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_pvv2e_t));
    e->hit = 1;
}

/* entry pack accessor implementation for pvv2e */
static int soc_sbx_g3p1_pvv2e_pack(int unit,
    soc_sbx_g3p1_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->vpws; break;


          case 2: p = (uint8 *) &e->stpstate; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->lpi; break;
          case 5: p = (uint8 *) &e->hit; break;
          case 6: p = (uint8 *) &e->keeporstrip; break;
          case 7: p = (uint8 *) &e->replace; break;
          case 8: p = (uint8 *) &e->vid; break;


          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pvv2e */
static int soc_sbx_g3p1_pvv2e_unpack(int unit,
                soc_sbx_g3p1_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->vpws; break;


          case 2: p = (uint8 *) &e->stpstate; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->lpi; break;
          case 5: p = (uint8 *) &e->hit; break;
          case 6: p = (uint8 *) &e->keeporstrip; break;
          case 7: p = (uint8 *) &e->replace; break;
          case 8: p = (uint8 *) &e->vid; break;


          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pvv2e */
static int soc_sbx_g3p1_pvv2e_index_check(int unit, uint32 *vindex, int iivid, int iovid, int iport )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iivid; break;
          case 1: p = (uint8 *) &iovid; break;
          case 2: p = (uint8 *) &iport; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for pvv2e */
static int soc_sbx_g3p1_pvv2e_index_unpack(int unit, int *vindex, int *niivid, int *niovid, int *niport)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) niivid; break;
          case 1: p = (uint8 *) niovid; break;
          case 2: p = (uint8 *) niport; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for pvv2e */
int soc_sbx_g3p1_pvv2e_entry_check(int unit,
                                 soc_sbx_g3p1_pvv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pad; break;
          case 1: ev = e->vpws; break;
          case 2: ev = e->stpstate; break;
          case 3: ev = e->vlan; break;
          case 4: ev = e->lpi; break;
          case 5: ev = e->hit; break;
          case 6: ev = e->keeporstrip; break;
          case 7: ev = e->replace; break;
          case 8: ev = e->vid; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_set(int unit, int iivid, int iovid, int iport, soc_sbx_g3p1_pvv2e_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pvv2e_update(unit, iivid, iovid, iport, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_pvv2e_add(unit, iivid, iovid, iport, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_add(int unit, int iivid, int iovid, int iport, soc_sbx_g3p1_pvv2e_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pvv2e_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_pvv2e_add_ext_sim(unit, iivid, iovid, iport, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_get(int unit, int iivid, int iovid, int iport, soc_sbx_g3p1_pvv2e_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_pvv2e_get_ext_sim(unit, iivid, iovid, iport, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pvv2e_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_hw_get(int unit, int iivid, int iovid, int iport, soc_sbx_g3p1_pvv2e_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_pvv2e_get_ext_sim(unit, iivid, iovid, iport, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pvv2e_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_update(int unit, int iivid, int iovid, int iport, soc_sbx_g3p1_pvv2e_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pvv2e_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_pvv2e_add_ext_sim(unit, iivid, iovid, iport, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_delete(int unit, int iivid, int iovid, int iport)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_pvv2e_delete_ext_sim(unit, iivid, iovid, iport);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for pvv2e */
int soc_sbx_g3p1_pvv2e_remove(int unit, int iivid, int iovid, int iport)
{
    return soc_sbx_g3p1_pvv2e_delete(unit, iivid, iovid, iport);
}

/* Get the first element of pvv2e */
int soc_sbx_g3p1_pvv2e_first(int unit, int *niivid, int *niovid, int *niport)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_pvv2e_index_unpack(unit, (int *)key, niivid, niovid, niport);    
}

/* Get the next element of pvv2e */
int soc_sbx_g3p1_pvv2e_next(int unit, int iivid, int iovid, int iport, int *niivid, int *niovid, int *niport)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_pvv2e_index_check(unit, key, iivid, iovid, iport);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_pvv2e_index_unpack(unit, (int *)next_key, niivid, niovid, niport);  
}

/**
New entry set accessor implementation for pvv2e
*/
int soc_sbx_g3p1_pvv2e_data_set(int unit, int iivid, int iovid, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2e_t entry;

    soc_sbx_g3p1_pvv2e_t_init(&entry);
    s = soc_sbx_g3p1_pvv2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2e_set(unit, iivid, iovid, iport, &entry);

    return s;
}

/**
New entry add accessor implementation for pvv2e
*/
int soc_sbx_g3p1_pvv2e_data_add(int unit, int iivid, int iovid, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2e_t entry;

    soc_sbx_g3p1_pvv2e_t_init(&entry);
    s = soc_sbx_g3p1_pvv2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2e_add(unit, iivid, iovid, iport, &entry);

    return s;
}

/**
New entry get accessor implementation for pvv2e
*/
int soc_sbx_g3p1_pvv2e_data_get(int unit, int iivid, int iovid, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2e_t entry;

    soc_sbx_g3p1_pvv2e_t_init(&entry);
    s = soc_sbx_g3p1_pvv2e_get(unit, iivid, iovid, iport, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2e_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for pvv2e
*/
int soc_sbx_g3p1_pvv2e_data_update(int unit, int iivid, int iovid, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2e_t entry;

    soc_sbx_g3p1_pvv2e_t_init(&entry);
    s = soc_sbx_g3p1_pvv2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2e_update(unit, iivid, iovid, iport, &entry);

    return s;
}


/*
 * Entry accessor implementations for labels
 */

void soc_sbx_g3p1_labels_t_init(
    soc_sbx_g3p1_labels_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_labels_t));
    e->hit = 1;
}

/* entry pack accessor implementation for labels */
static int soc_sbx_g3p1_labels_pack(int unit,
    soc_sbx_g3p1_labels_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->opcode; break;
          case 2: p = (uint8 *) &e->ftidx; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->hit; break;
          case 5: p = (uint8 *) &e->lock; break;
          case 6: p = (uint8 *) &e->keep_sdtag; break;
          case 7: p = (uint8 *) &e->pipe; break;
          case 8: p = (uint8 *) &e->elsp; break;
          case 9: p = (uint8 *) &e->stpstate; break;


          case 10: p = (uint8 *) &e->vpws; break;
          case 11: p = (uint8 *) &e->loop; break;
          case 12: p = (uint8 *) &e->cos; break;
          case 13: p = (uint8 *) &e->lpi; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for labels */
static int soc_sbx_g3p1_labels_unpack(int unit,
                soc_sbx_g3p1_labels_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->opcode; break;
          case 2: p = (uint8 *) &e->ftidx; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->hit; break;
          case 5: p = (uint8 *) &e->lock; break;
          case 6: p = (uint8 *) &e->keep_sdtag; break;
          case 7: p = (uint8 *) &e->pipe; break;
          case 8: p = (uint8 *) &e->elsp; break;
          case 9: p = (uint8 *) &e->stpstate; break;


          case 10: p = (uint8 *) &e->vpws; break;
          case 11: p = (uint8 *) &e->loop; break;
          case 12: p = (uint8 *) &e->cos; break;
          case 13: p = (uint8 *) &e->lpi; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for labels */
static int soc_sbx_g3p1_labels_index_check(int unit, uint32 *vindex, int ilabel2, int iresv, int iport, int ilabel1 )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ilabel2; break;
          case 1: p = (uint8 *) &iresv; break;
          case 2: p = (uint8 *) &iport; break;
          case 3: p = (uint8 *) &ilabel1; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for labels */
static int soc_sbx_g3p1_labels_index_unpack(int unit, int *vindex, int *nilabel2, int *niresv, int *niport, int *nilabel1)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nilabel2; break;
          case 1: p = (uint8 *) niresv; break;
          case 2: p = (uint8 *) niport; break;
          case 3: p = (uint8 *) nilabel1; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for labels */
int soc_sbx_g3p1_labels_entry_check(int unit,
                                 soc_sbx_g3p1_labels_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pad; break;
          case 1: ev = e->opcode; break;
          case 2: ev = e->ftidx; break;
          case 3: ev = e->vlan; break;
          case 4: ev = e->hit; break;
          case 5: ev = e->lock; break;
          case 6: ev = e->keep_sdtag; break;
          case 7: ev = e->pipe; break;
          case 8: ev = e->elsp; break;
          case 9: ev = e->stpstate; break;
          case 10: ev = e->vpws; break;
          case 11: ev = e->loop; break;
          case 12: ev = e->cos; break;
          case 13: ev = e->lpi; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for labels */
int soc_sbx_g3p1_labels_set(int unit, int ilabel2, int iresv, int iport, int ilabel1, soc_sbx_g3p1_labels_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels_update(unit, ilabel2, iresv, iport, ilabel1, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_labels_add(unit, ilabel2, iresv, iport, ilabel1, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for labels */
int soc_sbx_g3p1_labels_add(int unit, int ilabel2, int iresv, int iport, int ilabel1, soc_sbx_g3p1_labels_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels_add_ext_sim(unit, ilabel2, iresv, iport, ilabel1, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for labels */
int soc_sbx_g3p1_labels_get(int unit, int ilabel2, int iresv, int iport, int ilabel1, soc_sbx_g3p1_labels_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels_get_ext_sim(unit, ilabel2, iresv, iport, ilabel1, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for labels */
int soc_sbx_g3p1_labels_hw_get(int unit, int ilabel2, int iresv, int iport, int ilabel1, soc_sbx_g3p1_labels_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels_get_ext_sim(unit, ilabel2, iresv, iport, ilabel1, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for labels */
int soc_sbx_g3p1_labels_update(int unit, int ilabel2, int iresv, int iport, int ilabel1, soc_sbx_g3p1_labels_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels_add_ext_sim(unit, ilabel2, iresv, iport, ilabel1, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for labels */
int soc_sbx_g3p1_labels_delete(int unit, int ilabel2, int iresv, int iport, int ilabel1)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels_delete_ext_sim(unit, ilabel2, iresv, iport, ilabel1);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for labels */
int soc_sbx_g3p1_labels_remove(int unit, int ilabel2, int iresv, int iport, int ilabel1)
{
    return soc_sbx_g3p1_labels_delete(unit, ilabel2, iresv, iport, ilabel1);
}

/* Get the first element of labels */
int soc_sbx_g3p1_labels_first(int unit, int *nilabel2, int *niresv, int *niport, int *nilabel1)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_labels_index_unpack(unit, (int *)key, nilabel2, niresv, niport, nilabel1);    
}

/* Get the next element of labels */
int soc_sbx_g3p1_labels_next(int unit, int ilabel2, int iresv, int iport, int ilabel1, int *nilabel2, int *niresv, int *niport, int *nilabel1)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_labels_index_check(unit, key, ilabel2, iresv, iport, ilabel1);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_labels_index_unpack(unit, (int *)next_key, nilabel2, niresv, niport, nilabel1);  
}

/**
New entry set accessor implementation for labels
*/
int soc_sbx_g3p1_labels_data_set(int unit, int ilabel2, int iresv, int iport, int ilabel1, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels_t entry;

    soc_sbx_g3p1_labels_t_init(&entry);
    s = soc_sbx_g3p1_labels_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels_set(unit, ilabel2, iresv, iport, ilabel1, &entry);

    return s;
}

/**
New entry add accessor implementation for labels
*/
int soc_sbx_g3p1_labels_data_add(int unit, int ilabel2, int iresv, int iport, int ilabel1, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels_t entry;

    soc_sbx_g3p1_labels_t_init(&entry);
    s = soc_sbx_g3p1_labels_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels_add(unit, ilabel2, iresv, iport, ilabel1, &entry);

    return s;
}

/**
New entry get accessor implementation for labels
*/
int soc_sbx_g3p1_labels_data_get(int unit, int ilabel2, int iresv, int iport, int ilabel1, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels_t entry;

    soc_sbx_g3p1_labels_t_init(&entry);
    s = soc_sbx_g3p1_labels_get(unit, ilabel2, iresv, iport, ilabel1, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for labels
*/
int soc_sbx_g3p1_labels_data_update(int unit, int ilabel2, int iresv, int iport, int ilabel1, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels_t entry;

    soc_sbx_g3p1_labels_t_init(&entry);
    s = soc_sbx_g3p1_labels_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels_update(unit, ilabel2, iresv, iport, ilabel1, &entry);

    return s;
}


/*
 * Entry accessor implementations for v4da
 */

void soc_sbx_g3p1_v4da_t_init(
    soc_sbx_g3p1_v4da_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v4da_t));
}

/* entry pack accessor implementation for v4da */
static int soc_sbx_g3p1_v4da_pack(int unit,
    soc_sbx_g3p1_v4da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->vid; break;
          case 1: p = (uint8 *) &e->ecmpmask; break;
          case 2: p = (uint8 *) &e->ftidx; break;
        
          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4da */
static int soc_sbx_g3p1_v4da_unpack(int unit,
                soc_sbx_g3p1_v4da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->vid; break;
          case 1: p = (uint8 *) &e->ecmpmask; break;
          case 2: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4da */
int soc_sbx_g3p1_v4da_index_check(int unit, uint32 *vindex, int ivrf, int ida )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivrf; break;
          case 1: p = (uint8 *) &ida; break;
          case 2: continue;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v4da */
int soc_sbx_g3p1_v4da_entry_check(int unit,
                                 soc_sbx_g3p1_v4da_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->vid; break;
          case 1: ev = e->ecmpmask; break;
          case 2: ev = e->ftidx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for v4da */
int soc_sbx_g3p1_v4da_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for v4da */
int soc_sbx_g3p1_v4da_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");

    return s;
}

/* unpack index for v4da */
static int soc_sbx_g3p1_v4da_index_unpack(int unit, int *vindex, int *nivrf, int *nida)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;

    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivrf; break;
          case 1: p = (uint8 *) nida; break;
          case 2: continue;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* get firt entry for v4da */
int soc_sbx_g3p1_v4da_first(int unit, int *nivrf, int *nida, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = taps_iterator_first(unit, &arg, key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v4da_index_unpack(unit, (int *)key,nivrf, nida);
}

/* get next entry for v4da */
int soc_sbx_g3p1_v4da_next(int unit, int ivrf, int ida, int inetmask_num_bits, int *nivrf, int *nida, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = soc_sbx_g3p1_v4da_index_check(unit, key, ivrf, ida);
    if (rv) {
        return rv;
    }

	key[0] = align_right(ivrf);

	shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);

    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;

    rv = taps_iterator_next(unit, &arg, next_key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v4da_index_unpack(unit, (int *)next_key, nivrf, nida);
}

/* entry set accessor implementation for v4da */
int soc_sbx_g3p1_v4da_set(int unit, int ivrf, int ida, int inetmask_num_bits, soc_sbx_g3p1_v4da_t *e)
{
    int s;
    uint32 key[32];

    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];

    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_v4da_index_check(unit, key, ivrf, ida);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4da_entry_check(unit, e);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4da_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_v4da_add_ext_sim(unit, ivrf, ida, e);   
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;          
}

/* entry get accessor implementation for v4da */
int soc_sbx_g3p1_v4da_get(int unit, int ivrf, int ida, int inetmask_num_bits, soc_sbx_g3p1_v4da_t *e)
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4da_index_check(unit, key, ivrf, ida);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v4da_get_ext_sim(unit, ivrf, ida,  e);
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_get_route(unit, &arg);
    if (s) {
        return s;
    }  

    s = soc_sbx_g3p1_v4da_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}


int soc_sbx_g3p1_v4da_lpm_raw_get(int unit, int ivrf, int ida, int *nivrf, int *nida, int *onetmask_num_bits, unsigned char *obuf, int *osize)
{
    int s;
    int inetmask_num_bits = 32;
    uint32 key[32];   
    uint32 bpm_key[32];
    uint32 bpm_length;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    sal_memset(bpm_key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4da_index_check(unit, key, ivrf, ida);
    if (s) {
        return s;
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + 32;
    arg.payload = epacked;
    s = taps_get_lpm_route(unit, &arg, bpm_key, &bpm_length);
    if (s) {
        return s;
    }  
    
    s = soc_sbx_g3p1_v4da_index_unpack(unit, (int *)key, nivrf, nida);
    if (s) {
        return s;
    } 
    
    *onetmask_num_bits = bpm_length - 16;
    *osize = ed->width_in_words * 32;
    sal_memcpy(obuf, epacked, sizeof(uint32) * BITS2WORDS(*osize));
    
    return s;
}

int soc_sbx_g3p1_v4da_lpm_get(int unit, int ivrf, int ida, int *nivrf, int *nida, int *onetmask_num_bits, soc_sbx_g3p1_v4da_t *e)
{
    int s;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    int size = 0;
    s = soc_sbx_g3p1_v4da_lpm_raw_get(unit, ivrf, ida, nivrf, nida, onetmask_num_bits, (unsigned char *)epacked, (int *)size);
    if (s) {
        return s;
    }
    
    s = soc_sbx_g3p1_v4da_unpack(unit, e, (unsigned char *)epacked, size);
    
    return s; 
}

int soc_sbx_g3p1_v4da_delete(int unit, int ivrf, int ida, int inetmask_num_bits) 
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];   
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4da_index_check(unit, key, ivrf, ida);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v4da_delete_ext_sim(unit, ivrf, ida);
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    
    s = taps_delete_route(unit, &arg);
    
    return s;
}    

int soc_sbx_g3p1_v4da_remove(int unit, int ivrf, int ida, int inetmask_num_bits)
{
    return soc_sbx_g3p1_v4da_delete(unit, ivrf, ida, inetmask_num_bits);
}

/* 
 * Raw entry set accessor implementation for v4da
 */
int soc_sbx_g3p1_v4da_raw_set(int unit, uint32 * key, int key_length, uint32 *payload)
{
    int s;
    taps_arg_t arg;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = key_length;
    arg.payload = payload;
	/* coverity[ stack_use_overflow ] */
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;   
}

/**
New entry set accessor implementation for v4da
*/
int soc_sbx_g3p1_v4da_data_set(int unit, int ivrf, int ida, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4da_t entry;

    soc_sbx_g3p1_v4da_t_init(&entry);
    s = soc_sbx_g3p1_v4da_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4da_set(unit, ivrf, ida, inetmask_num_bits, &entry);

    return s;
}

/**
New entry get accessor implementation for v4da
*/
int soc_sbx_g3p1_v4da_data_get(int unit, int ivrf, int ida, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4da_t entry;

    soc_sbx_g3p1_v4da_t_init(&entry);
    s = soc_sbx_g3p1_v4da_get(unit, ivrf, ida, inetmask_num_bits, &entry);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4da_pack(unit, &entry, buf, size*8);

    return s;
}


/*
 * Entry accessor implementations for v4sa
 */

void soc_sbx_g3p1_v4sa_t_init(
    soc_sbx_g3p1_v4sa_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v4sa_t));
}

/* entry pack accessor implementation for v4sa */
static int soc_sbx_g3p1_v4sa_pack(int unit,
    soc_sbx_g3p1_v4sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->srccnt; break;
          case 2: p = (uint8 *) &e->srcdrop; break;
          case 3: p = (uint8 *) &e->rpfmode; break;
          case 4: p = (uint8 *) &e->poe; break;
        
          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4sa */
static int soc_sbx_g3p1_v4sa_unpack(int unit,
                soc_sbx_g3p1_v4sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->srccnt; break;
          case 2: p = (uint8 *) &e->srcdrop; break;
          case 3: p = (uint8 *) &e->rpfmode; break;
          case 4: p = (uint8 *) &e->poe; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4sa */
int soc_sbx_g3p1_v4sa_index_check(int unit, uint32 *vindex, int ivrf, int isa )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivrf; break;
          case 1: p = (uint8 *) &isa; break;
          case 2: continue;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v4sa */
int soc_sbx_g3p1_v4sa_entry_check(int unit,
                                 soc_sbx_g3p1_v4sa_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pad; break;
          case 1: ev = e->srccnt; break;
          case 2: ev = e->srcdrop; break;
          case 3: ev = e->rpfmode; break;
          case 4: ev = e->poe; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for v4sa */
int soc_sbx_g3p1_v4sa_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for v4sa */
int soc_sbx_g3p1_v4sa_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");

    return s;
}

/* unpack index for v4sa */
static int soc_sbx_g3p1_v4sa_index_unpack(int unit, int *vindex, int *nivrf, int *nisa)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;

    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivrf; break;
          case 1: p = (uint8 *) nisa; break;
          case 2: continue;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* get firt entry for v4sa */
int soc_sbx_g3p1_v4sa_first(int unit, int *nivrf, int *nisa, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = taps_iterator_first(unit, &arg, key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v4sa_index_unpack(unit, (int *)key,nivrf, nisa);
}

/* get next entry for v4sa */
int soc_sbx_g3p1_v4sa_next(int unit, int ivrf, int isa, int inetmask_num_bits, int *nivrf, int *nisa, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = soc_sbx_g3p1_v4sa_index_check(unit, key, ivrf, isa);
    if (rv) {
        return rv;
    }

	key[0] = align_right(ivrf);

	shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);

    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;

    rv = taps_iterator_next(unit, &arg, next_key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v4sa_index_unpack(unit, (int *)next_key, nivrf, nisa);
}

/* entry set accessor implementation for v4sa */
int soc_sbx_g3p1_v4sa_set(int unit, int ivrf, int isa, int inetmask_num_bits, soc_sbx_g3p1_v4sa_t *e)
{
    int s;
    uint32 key[32];

    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];

    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_v4sa_index_check(unit, key, ivrf, isa);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4sa_entry_check(unit, e);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4sa_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_v4sa_add_ext_sim(unit, ivrf, isa, e);   
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;          
}

/* entry get accessor implementation for v4sa */
int soc_sbx_g3p1_v4sa_get(int unit, int ivrf, int isa, int inetmask_num_bits, soc_sbx_g3p1_v4sa_t *e)
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4sa_index_check(unit, key, ivrf, isa);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v4sa_get_ext_sim(unit, ivrf, isa,  e);
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_get_route(unit, &arg);
    if (s) {
        return s;
    }  

    s = soc_sbx_g3p1_v4sa_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}


int soc_sbx_g3p1_v4sa_lpm_raw_get(int unit, int ivrf, int isa, int *nivrf, int *nisa, int *onetmask_num_bits, unsigned char *obuf, int *osize)
{
    int s;
    int inetmask_num_bits = 32;
    uint32 key[32];   
    uint32 bpm_key[32];
    uint32 bpm_length;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    sal_memset(bpm_key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4sa_index_check(unit, key, ivrf, isa);
    if (s) {
        return s;
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + 32;
    arg.payload = epacked;
    s = taps_get_lpm_route(unit, &arg, bpm_key, &bpm_length);
    if (s) {
        return s;
    }  
    
    s = soc_sbx_g3p1_v4sa_index_unpack(unit, (int *)key, nivrf, nisa);
    if (s) {
        return s;
    } 
    
    *onetmask_num_bits = bpm_length - 16;
    *osize = ed->width_in_words * 32;
    sal_memcpy(obuf, epacked, sizeof(uint32) * BITS2WORDS(*osize));
    
    return s;
}

int soc_sbx_g3p1_v4sa_lpm_get(int unit, int ivrf, int isa, int *nivrf, int *nisa, int *onetmask_num_bits, soc_sbx_g3p1_v4sa_t *e)
{
    int s;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    int size = 0;
    s = soc_sbx_g3p1_v4sa_lpm_raw_get(unit, ivrf, isa, nivrf, nisa, onetmask_num_bits, (unsigned char *)epacked, (int *)size);
    if (s) {
        return s;
    }
    
    s = soc_sbx_g3p1_v4sa_unpack(unit, e, (unsigned char *)epacked, size);
    
    return s; 
}

int soc_sbx_g3p1_v4sa_delete(int unit, int ivrf, int isa, int inetmask_num_bits) 
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];   
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v4sa_index_check(unit, key, ivrf, isa);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v4sa_delete_ext_sim(unit, ivrf, isa);
    }
    
    key[0] = align_right(ivrf);

    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    
    s = taps_delete_route(unit, &arg);
    
    return s;
}    

int soc_sbx_g3p1_v4sa_remove(int unit, int ivrf, int isa, int inetmask_num_bits)
{
    return soc_sbx_g3p1_v4sa_delete(unit, ivrf, isa, inetmask_num_bits);
}

/* 
 * Raw entry set accessor implementation for v4sa
 */
int soc_sbx_g3p1_v4sa_raw_set(int unit, uint32 * key, int key_length, uint32 *payload)
{
    int s;
    taps_arg_t arg;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = key_length;
    arg.payload = payload;
	/* coverity[ stack_use_overflow ] */
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;   
}

/**
New entry set accessor implementation for v4sa
*/
int soc_sbx_g3p1_v4sa_data_set(int unit, int ivrf, int isa, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4sa_t entry;

    soc_sbx_g3p1_v4sa_t_init(&entry);
    s = soc_sbx_g3p1_v4sa_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4sa_set(unit, ivrf, isa, inetmask_num_bits, &entry);

    return s;
}

/**
New entry get accessor implementation for v4sa
*/
int soc_sbx_g3p1_v4sa_data_get(int unit, int ivrf, int isa, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4sa_t entry;

    soc_sbx_g3p1_v4sa_t_init(&entry);
    s = soc_sbx_g3p1_v4sa_get(unit, ivrf, isa, inetmask_num_bits, &entry);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4sa_pack(unit, &entry, buf, size*8);

    return s;
}


/*
 * Entry accessor implementations for v4mc_sgv
 */

void soc_sbx_g3p1_v4mc_sgv_t_init(
    soc_sbx_g3p1_v4mc_sgv_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v4mc_sgv_t));
    e->hit = 1;
}

/* entry pack accessor implementation for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_pack(int unit,
    soc_sbx_g3p1_v4mc_sgv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_unpack(int unit,
                soc_sbx_g3p1_v4mc_sgv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_index_check(int unit, uint32 *vindex, int ivsi, int isa, int iga )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivsi; break;
          case 1: p = (uint8 *) &isa; break;
          case 2: p = (uint8 *) &iga; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_index_unpack(int unit, int *vindex, int *nivsi, int *nisa, int *niga)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivsi; break;
          case 1: p = (uint8 *) nisa; break;
          case 2: p = (uint8 *) niga; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_entry_check(int unit,
                                 soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->rpfunion; break;
          case 1: ev = e->ftidx; break;
          case 2: ev = e->hit; break;
          case 3: ev = e->rsvd; break;
          case 4: ev = e->proccopy; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_set(int unit, int ivsi, int isa, int iga, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_sgv_update(unit, ivsi, isa, iga, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_v4mc_sgv_add(unit, ivsi, isa, iga, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_add(int unit, int ivsi, int isa, int iga, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_sgv_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_sgv_add_ext_sim(unit, ivsi, isa, iga, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_get(int unit, int ivsi, int isa, int iga, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_sgv_get_ext_sim(unit, ivsi, isa, iga, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_sgv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_hw_get(int unit, int ivsi, int isa, int iga, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_sgv_get_ext_sim(unit, ivsi, isa, iga, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_sgv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_update(int unit, int ivsi, int isa, int iga, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_sgv_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_sgv_add_ext_sim(unit, ivsi, isa, iga, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_delete(int unit, int ivsi, int isa, int iga)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_sgv_delete_ext_sim(unit, ivsi, isa, iga);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_remove(int unit, int ivsi, int isa, int iga)
{
    return soc_sbx_g3p1_v4mc_sgv_delete(unit, ivsi, isa, iga);
}

/* Get the first element of v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_first(int unit, int *nivsi, int *nisa, int *niga)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_v4mc_sgv_index_unpack(unit, (int *)key, nivsi, nisa, niga);    
}

/* Get the next element of v4mc_sgv */
int soc_sbx_g3p1_v4mc_sgv_next(int unit, int ivsi, int isa, int iga, int *nivsi, int *nisa, int *niga)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_v4mc_sgv_index_check(unit, key, ivsi, isa, iga);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_v4mc_sgv_index_unpack(unit, (int *)next_key, nivsi, nisa, niga);  
}

/**
New entry set accessor implementation for v4mc_sgv
*/
int soc_sbx_g3p1_v4mc_sgv_data_set(int unit, int ivsi, int isa, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_sgv_t entry;

    soc_sbx_g3p1_v4mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_sgv_set(unit, ivsi, isa, iga, &entry);

    return s;
}

/**
New entry add accessor implementation for v4mc_sgv
*/
int soc_sbx_g3p1_v4mc_sgv_data_add(int unit, int ivsi, int isa, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_sgv_t entry;

    soc_sbx_g3p1_v4mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_sgv_add(unit, ivsi, isa, iga, &entry);

    return s;
}

/**
New entry get accessor implementation for v4mc_sgv
*/
int soc_sbx_g3p1_v4mc_sgv_data_get(int unit, int ivsi, int isa, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_sgv_t entry;

    soc_sbx_g3p1_v4mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_sgv_get(unit, ivsi, isa, iga, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_sgv_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for v4mc_sgv
*/
int soc_sbx_g3p1_v4mc_sgv_data_update(int unit, int ivsi, int isa, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_sgv_t entry;

    soc_sbx_g3p1_v4mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_sgv_update(unit, ivsi, isa, iga, &entry);

    return s;
}


/*
 * Entry accessor implementations for v4mc_gv
 */

void soc_sbx_g3p1_v4mc_gv_t_init(
    soc_sbx_g3p1_v4mc_gv_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v4mc_gv_t));
    e->hit = 1;
}

/* entry pack accessor implementation for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_pack(int unit,
    soc_sbx_g3p1_v4mc_gv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_unpack(int unit,
                soc_sbx_g3p1_v4mc_gv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_index_check(int unit, uint32 *vindex, int ivsi, int iga )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivsi; break;
          case 1: p = (uint8 *) &iga; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_index_unpack(int unit, int *vindex, int *nivsi, int *niga)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivsi; break;
          case 1: p = (uint8 *) niga; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_entry_check(int unit,
                                 soc_sbx_g3p1_v4mc_gv_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->rpfunion; break;
          case 1: ev = e->ftidx; break;
          case 2: ev = e->hit; break;
          case 3: ev = e->rsvd; break;
          case 4: ev = e->proccopy; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_set(int unit, int ivsi, int iga, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_gv_update(unit, ivsi, iga, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_v4mc_gv_add(unit, ivsi, iga, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_add(int unit, int ivsi, int iga, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_gv_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_gv_add_ext_sim(unit, ivsi, iga, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_get(int unit, int ivsi, int iga, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_gv_get_ext_sim(unit, ivsi, iga, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_gv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_hw_get(int unit, int ivsi, int iga, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_gv_get_ext_sim(unit, ivsi, iga, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_gv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_update(int unit, int ivsi, int iga, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v4mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v4mc_gv_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_gv_add_ext_sim(unit, ivsi, iga, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_delete(int unit, int ivsi, int iga)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v4mc_gv_delete_ext_sim(unit, ivsi, iga);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_remove(int unit, int ivsi, int iga)
{
    return soc_sbx_g3p1_v4mc_gv_delete(unit, ivsi, iga);
}

/* Get the first element of v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_first(int unit, int *nivsi, int *niga)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_v4mc_gv_index_unpack(unit, (int *)key, nivsi, niga);    
}

/* Get the next element of v4mc_gv */
int soc_sbx_g3p1_v4mc_gv_next(int unit, int ivsi, int iga, int *nivsi, int *niga)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_v4mc_gv_index_check(unit, key, ivsi, iga);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_v4mc_gv_index_unpack(unit, (int *)next_key, nivsi, niga);  
}

/**
New entry set accessor implementation for v4mc_gv
*/
int soc_sbx_g3p1_v4mc_gv_data_set(int unit, int ivsi, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_gv_t entry;

    soc_sbx_g3p1_v4mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_gv_set(unit, ivsi, iga, &entry);

    return s;
}

/**
New entry add accessor implementation for v4mc_gv
*/
int soc_sbx_g3p1_v4mc_gv_data_add(int unit, int ivsi, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_gv_t entry;

    soc_sbx_g3p1_v4mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_gv_add(unit, ivsi, iga, &entry);

    return s;
}

/**
New entry get accessor implementation for v4mc_gv
*/
int soc_sbx_g3p1_v4mc_gv_data_get(int unit, int ivsi, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_gv_t entry;

    soc_sbx_g3p1_v4mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_gv_get(unit, ivsi, iga, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_gv_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for v4mc_gv
*/
int soc_sbx_g3p1_v4mc_gv_data_update(int unit, int ivsi, int iga, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v4mc_gv_t entry;

    soc_sbx_g3p1_v4mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v4mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v4mc_gv_update(unit, ivsi, iga, &entry);

    return s;
}


/*
 * Entry accessor implementations for v6da
 */

void soc_sbx_g3p1_v6da_t_init(
    soc_sbx_g3p1_v6da_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v6da_t));
}

/* entry pack accessor implementation for v6da */
static int soc_sbx_g3p1_v6da_pack(int unit,
    soc_sbx_g3p1_v6da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->vid; break;
          case 1: p = (uint8 *) &e->ecmpmask; break;
          case 2: p = (uint8 *) &e->ftidx; break;
        
          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v6da */
static int soc_sbx_g3p1_v6da_unpack(int unit,
                soc_sbx_g3p1_v6da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->vid; break;
          case 1: p = (uint8 *) &e->ecmpmask; break;
          case 2: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v6da */
int soc_sbx_g3p1_v6da_index_check(int unit, uint32 *vindex, int ivrf, int ida0, int ida1, int ida2, int ida3 )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivrf; break;
          case 1: p = (uint8 *) &ida0; break;
          case 2: p = (uint8 *) &ida1; break;
          case 3: p = (uint8 *) &ida2; break;
          case 4: p = (uint8 *) &ida3; break;
          case 5: continue;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v6da */
int soc_sbx_g3p1_v6da_entry_check(int unit,
                                 soc_sbx_g3p1_v6da_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->vid; break;
          case 1: ev = e->ecmpmask; break;
          case 2: ev = e->ftidx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for v6da */
int soc_sbx_g3p1_v6da_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for v6da */
int soc_sbx_g3p1_v6da_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");

    return s;
}

/* unpack index for v6da */
static int soc_sbx_g3p1_v6da_index_unpack(int unit, int *vindex, int *nivrf, int *nida0, int *nida1, int *nida2, int *nida3)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;

    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivrf; break;
          case 1: p = (uint8 *) nida0; break;
          case 2: p = (uint8 *) nida1; break;
          case 3: p = (uint8 *) nida2; break;
          case 4: p = (uint8 *) nida3; break;
          case 5: continue;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* get firt entry for v6da */
int soc_sbx_g3p1_v6da_first(int unit, int *nivrf, int *nida0, int *nida1, int *nida2, int *nida3, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = taps_iterator_first(unit, &arg, key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v6da_index_unpack(unit, (int *)key,nivrf, nida0, nida1, nida2, nida3);
}

/* get next entry for v6da */
int soc_sbx_g3p1_v6da_next(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits, int *nivrf, int *nida0, int *nida1, int *nida2, int *nida3, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = soc_sbx_g3p1_v6da_index_check(unit, key, ivrf, ida0, ida1, ida2, ida3);
    if (rv) {
        return rv;
    }

	key[0] = align_right(ivrf);




	shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);

    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;

    rv = taps_iterator_next(unit, &arg, next_key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v6da_index_unpack(unit, (int *)next_key, nivrf, nida0, nida1, nida2, nida3);
}

/* entry set accessor implementation for v6da */
int soc_sbx_g3p1_v6da_set(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits, soc_sbx_g3p1_v6da_t *e)
{
    int s;
    uint32 key[32];

    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];

    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_v6da_index_check(unit, key, ivrf, ida0, ida1, ida2, ida3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6da_entry_check(unit, e);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6da_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_v6da_add_ext_sim(unit, ivrf, ida0, ida1, ida2, ida3, e);   
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;          
}

/* entry get accessor implementation for v6da */
int soc_sbx_g3p1_v6da_get(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits, soc_sbx_g3p1_v6da_t *e)
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6da_index_check(unit, key, ivrf, ida0, ida1, ida2, ida3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v6da_get_ext_sim(unit, ivrf, ida0, ida1, ida2, ida3,  e);
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_get_route(unit, &arg);
    if (s) {
        return s;
    }  

    s = soc_sbx_g3p1_v6da_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}


int soc_sbx_g3p1_v6da_lpm_raw_get(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int *nivrf, int *nida0, int *nida1, int *nida2, int *nida3, int *onetmask_num_bits, unsigned char *obuf, int *osize)
{
    int s;
    int inetmask_num_bits = 32;
    uint32 key[32];   
    uint32 bpm_key[32];
    uint32 bpm_length;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    sal_memset(bpm_key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6da_index_check(unit, key, ivrf, ida0, ida1, ida2, ida3);
    if (s) {
        return s;
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + 32;
    arg.payload = epacked;
    s = taps_get_lpm_route(unit, &arg, bpm_key, &bpm_length);
    if (s) {
        return s;
    }  
    
    s = soc_sbx_g3p1_v6da_index_unpack(unit, (int *)key, nivrf, nida0, nida1, nida2, nida3);
    if (s) {
        return s;
    } 
    
    *onetmask_num_bits = bpm_length - 16;
    *osize = ed->width_in_words * 32;
    sal_memcpy(obuf, epacked, sizeof(uint32) * BITS2WORDS(*osize));
    
    return s;
}

int soc_sbx_g3p1_v6da_lpm_get(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int *nivrf, int *nida0, int *nida1, int *nida2, int *nida3, int *onetmask_num_bits, soc_sbx_g3p1_v6da_t *e)
{
    int s;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    int size = 0;
    s = soc_sbx_g3p1_v6da_lpm_raw_get(unit, ivrf, ida0, ida1, ida2, ida3, nivrf, nida0, nida1, nida2, nida3, onetmask_num_bits, (unsigned char *)epacked, (int *)size);
    if (s) {
        return s;
    }
    
    s = soc_sbx_g3p1_v6da_unpack(unit, e, (unsigned char *)epacked, size);
    
    return s; 
}

int soc_sbx_g3p1_v6da_delete(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits) 
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];   
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6da_index_check(unit, key, ivrf, ida0, ida1, ida2, ida3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v6da_delete_ext_sim(unit, ivrf, ida0, ida1, ida2, ida3);
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    
    s = taps_delete_route(unit, &arg);
    
    return s;
}    

int soc_sbx_g3p1_v6da_remove(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits)
{
    return soc_sbx_g3p1_v6da_delete(unit, ivrf, ida0, ida1, ida2, ida3, inetmask_num_bits);
}

/* 
 * Raw entry set accessor implementation for v6da
 */
int soc_sbx_g3p1_v6da_raw_set(int unit, uint32 * key, int key_length, uint32 *payload)
{
    int s;
    taps_arg_t arg;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = key_length;
    arg.payload = payload;
	/* coverity[ stack_use_overflow ] */
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;   
}

/**
New entry set accessor implementation for v6da
*/
int soc_sbx_g3p1_v6da_data_set(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6da_t entry;

    soc_sbx_g3p1_v6da_t_init(&entry);
    s = soc_sbx_g3p1_v6da_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6da_set(unit, ivrf, ida0, ida1, ida2, ida3, inetmask_num_bits, &entry);

    return s;
}

/**
New entry get accessor implementation for v6da
*/
int soc_sbx_g3p1_v6da_data_get(int unit, int ivrf, int ida0, int ida1, int ida2, int ida3, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6da_t entry;

    soc_sbx_g3p1_v6da_t_init(&entry);
    s = soc_sbx_g3p1_v6da_get(unit, ivrf, ida0, ida1, ida2, ida3, inetmask_num_bits, &entry);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6da_pack(unit, &entry, buf, size*8);

    return s;
}


/*
 * Entry accessor implementations for v6sa
 */

void soc_sbx_g3p1_v6sa_t_init(
    soc_sbx_g3p1_v6sa_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v6sa_t));
}

/* entry pack accessor implementation for v6sa */
static int soc_sbx_g3p1_v6sa_pack(int unit,
    soc_sbx_g3p1_v6sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->srccnt; break;
          case 2: p = (uint8 *) &e->srcdrop; break;
          case 3: p = (uint8 *) &e->rpfmode; break;
          case 4: p = (uint8 *) &e->poe; break;
        
          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v6sa */
static int soc_sbx_g3p1_v6sa_unpack(int unit,
                soc_sbx_g3p1_v6sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {







          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->srccnt; break;
          case 2: p = (uint8 *) &e->srcdrop; break;
          case 3: p = (uint8 *) &e->rpfmode; break;
          case 4: p = (uint8 *) &e->poe; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v6sa */
int soc_sbx_g3p1_v6sa_index_check(int unit, uint32 *vindex, int ivrf, int isa0, int isa1, int isa2, int isa3 )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivrf; break;
          case 1: p = (uint8 *) &isa0; break;
          case 2: p = (uint8 *) &isa1; break;
          case 3: p = (uint8 *) &isa2; break;
          case 4: p = (uint8 *) &isa3; break;
          case 5: continue;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v6sa */
int soc_sbx_g3p1_v6sa_entry_check(int unit,
                                 soc_sbx_g3p1_v6sa_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pad; break;
          case 1: ev = e->srccnt; break;
          case 2: ev = e->srcdrop; break;
          case 3: ev = e->rpfmode; break;
          case 4: ev = e->poe; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for v6sa */
int soc_sbx_g3p1_v6sa_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for v6sa */
int soc_sbx_g3p1_v6sa_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");

    return s;
}

/* unpack index for v6sa */
static int soc_sbx_g3p1_v6sa_index_unpack(int unit, int *vindex, int *nivrf, int *nisa0, int *nisa1, int *nisa2, int *nisa3)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;

    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivrf; break;
          case 1: p = (uint8 *) nisa0; break;
          case 2: p = (uint8 *) nisa1; break;
          case 3: p = (uint8 *) nisa2; break;
          case 4: p = (uint8 *) nisa3; break;
          case 5: continue;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* get firt entry for v6sa */
int soc_sbx_g3p1_v6sa_first(int unit, int *nivrf, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = taps_iterator_first(unit, &arg, key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v6sa_index_unpack(unit, (int *)key,nivrf, nisa0, nisa1, nisa2, nisa3);
}

/* get next entry for v6sa */
int soc_sbx_g3p1_v6sa_next(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits, int *nivrf, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = soc_sbx_g3p1_v6sa_index_check(unit, key, ivrf, isa0, isa1, isa2, isa3);
    if (rv) {
        return rv;
    }

	key[0] = align_right(ivrf);




	shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);

    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;

    rv = taps_iterator_next(unit, &arg, next_key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_g3p1_v6sa_index_unpack(unit, (int *)next_key, nivrf, nisa0, nisa1, nisa2, nisa3);
}

/* entry set accessor implementation for v6sa */
int soc_sbx_g3p1_v6sa_set(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits, soc_sbx_g3p1_v6sa_t *e)
{
    int s;
    uint32 key[32];

    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    taps_arg_t arg;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];

    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_v6sa_index_check(unit, key, ivrf, isa0, isa1, isa2, isa3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6sa_entry_check(unit, e);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6sa_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_v6sa_add_ext_sim(unit, ivrf, isa0, isa1, isa2, isa3, e);   
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;          
}

/* entry get accessor implementation for v6sa */
int soc_sbx_g3p1_v6sa_get(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits, soc_sbx_g3p1_v6sa_t *e)
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6sa_index_check(unit, key, ivrf, isa0, isa1, isa2, isa3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v6sa_get_ext_sim(unit, ivrf, isa0, isa1, isa2, isa3,  e);
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_get_route(unit, &arg);
    if (s) {
        return s;
    }  

    s = soc_sbx_g3p1_v6sa_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}


int soc_sbx_g3p1_v6sa_lpm_raw_get(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int *nivrf, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *onetmask_num_bits, unsigned char *obuf, int *osize)
{
    int s;
    int inetmask_num_bits = 32;
    uint32 key[32];   
    uint32 bpm_key[32];
    uint32 bpm_length;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    sal_memset(bpm_key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6sa_index_check(unit, key, ivrf, isa0, isa1, isa2, isa3);
    if (s) {
        return s;
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + 32;
    arg.payload = epacked;
    s = taps_get_lpm_route(unit, &arg, bpm_key, &bpm_length);
    if (s) {
        return s;
    }  
    
    s = soc_sbx_g3p1_v6sa_index_unpack(unit, (int *)key, nivrf, nisa0, nisa1, nisa2, nisa3);
    if (s) {
        return s;
    } 
    
    *onetmask_num_bits = bpm_length - 16;
    *osize = ed->width_in_words * 32;
    sal_memcpy(obuf, epacked, sizeof(uint32) * BITS2WORDS(*osize));
    
    return s;
}

int soc_sbx_g3p1_v6sa_lpm_get(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int *nivrf, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *onetmask_num_bits, soc_sbx_g3p1_v6sa_t *e)
{
    int s;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    int size = 0;
    s = soc_sbx_g3p1_v6sa_lpm_raw_get(unit, ivrf, isa0, isa1, isa2, isa3, nivrf, nisa0, nisa1, nisa2, nisa3, onetmask_num_bits, (unsigned char *)epacked, (int *)size);
    if (s) {
        return s;
    }
    
    s = soc_sbx_g3p1_v6sa_unpack(unit, e, (unsigned char *)epacked, size);
    
    return s; 
}

int soc_sbx_g3p1_v6sa_delete(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits) 
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];   
    taps_arg_t arg; 
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_v6sa_index_check(unit, key, ivrf, isa0, isa1, isa2, isa3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_v6sa_delete_ext_sim(unit, ivrf, isa0, isa1, isa2, isa3);
    }
    
    key[0] = align_right(ivrf);




    shift_right((uint8 *)key, WORDS2BYTES((144 + 31)/32), 144 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    
    s = taps_delete_route(unit, &arg);
    
    return s;
}    

int soc_sbx_g3p1_v6sa_remove(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits)
{
    return soc_sbx_g3p1_v6sa_delete(unit, ivrf, isa0, isa1, isa2, isa3, inetmask_num_bits);
}

/* 
 * Raw entry set accessor implementation for v6sa
 */
int soc_sbx_g3p1_v6sa_raw_set(int unit, uint32 * key, int key_length, uint32 *payload)
{
    int s;
    taps_arg_t arg;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

        
    arg.taps = tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = key_length;
    arg.payload = payload;
	/* coverity[ stack_use_overflow ] */
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;   
}

/**
New entry set accessor implementation for v6sa
*/
int soc_sbx_g3p1_v6sa_data_set(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6sa_t entry;

    soc_sbx_g3p1_v6sa_t_init(&entry);
    s = soc_sbx_g3p1_v6sa_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6sa_set(unit, ivrf, isa0, isa1, isa2, isa3, inetmask_num_bits, &entry);

    return s;
}

/**
New entry get accessor implementation for v6sa
*/
int soc_sbx_g3p1_v6sa_data_get(int unit, int ivrf, int isa0, int isa1, int isa2, int isa3, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6sa_t entry;

    soc_sbx_g3p1_v6sa_t_init(&entry);
    s = soc_sbx_g3p1_v6sa_get(unit, ivrf, isa0, isa1, isa2, isa3, inetmask_num_bits, &entry);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6sa_pack(unit, &entry, buf, size*8);

    return s;
}


/*
 * Entry accessor implementations for v6mc_gv
 */

void soc_sbx_g3p1_v6mc_gv_t_init(
    soc_sbx_g3p1_v6mc_gv_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v6mc_gv_t));
    e->hit = 1;
}

/* entry pack accessor implementation for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_pack(int unit,
    soc_sbx_g3p1_v6mc_gv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_unpack(int unit,
                soc_sbx_g3p1_v6mc_gv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_index_check(int unit, uint32 *vindex, int ivsi, int iga0, int iga1, int iga2, int iga3 )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivsi; break;
          case 1: p = (uint8 *) &iga0; break;
          case 2: p = (uint8 *) &iga1; break;
          case 3: p = (uint8 *) &iga2; break;
          case 4: p = (uint8 *) &iga3; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_index_unpack(int unit, int *vindex, int *nivsi, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivsi; break;
          case 1: p = (uint8 *) niga0; break;
          case 2: p = (uint8 *) niga1; break;
          case 3: p = (uint8 *) niga2; break;
          case 4: p = (uint8 *) niga3; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_entry_check(int unit,
                                 soc_sbx_g3p1_v6mc_gv_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->rpfunion; break;
          case 1: ev = e->ftidx; break;
          case 2: ev = e->hit; break;
          case 3: ev = e->rsvd; break;
          case 4: ev = e->proccopy; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_set(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_gv_update(unit, ivsi, iga0, iga1, iga2, iga3, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_v6mc_gv_add(unit, ivsi, iga0, iga1, iga2, iga3, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_add(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_gv_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_gv_add_ext_sim(unit, ivsi, iga0, iga1, iga2, iga3, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_get(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_gv_get_ext_sim(unit, ivsi, iga0, iga1, iga2, iga3, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_gv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_hw_get(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_gv_get_ext_sim(unit, ivsi, iga0, iga1, iga2, iga3, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_gv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_update(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_gv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_gv_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_gv_add_ext_sim(unit, ivsi, iga0, iga1, iga2, iga3, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_delete(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_gv_delete_ext_sim(unit, ivsi, iga0, iga1, iga2, iga3);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_remove(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3)
{
    return soc_sbx_g3p1_v6mc_gv_delete(unit, ivsi, iga0, iga1, iga2, iga3);
}

/* Get the first element of v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_first(int unit, int *nivsi, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_v6mc_gv_index_unpack(unit, (int *)key, nivsi, niga0, niga1, niga2, niga3);    
}

/* Get the next element of v6mc_gv */
int soc_sbx_g3p1_v6mc_gv_next(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, int *nivsi, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_v6mc_gv_index_check(unit, key, ivsi, iga0, iga1, iga2, iga3);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_v6mc_gv_index_unpack(unit, (int *)next_key, nivsi, niga0, niga1, niga2, niga3);  
}

/**
New entry set accessor implementation for v6mc_gv
*/
int soc_sbx_g3p1_v6mc_gv_data_set(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_gv_t entry;

    soc_sbx_g3p1_v6mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_gv_set(unit, ivsi, iga0, iga1, iga2, iga3, &entry);

    return s;
}

/**
New entry add accessor implementation for v6mc_gv
*/
int soc_sbx_g3p1_v6mc_gv_data_add(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_gv_t entry;

    soc_sbx_g3p1_v6mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_gv_add(unit, ivsi, iga0, iga1, iga2, iga3, &entry);

    return s;
}

/**
New entry get accessor implementation for v6mc_gv
*/
int soc_sbx_g3p1_v6mc_gv_data_get(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_gv_t entry;

    soc_sbx_g3p1_v6mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_gv_get(unit, ivsi, iga0, iga1, iga2, iga3, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_gv_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for v6mc_gv
*/
int soc_sbx_g3p1_v6mc_gv_data_update(int unit, int ivsi, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_gv_t entry;

    soc_sbx_g3p1_v6mc_gv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_gv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_gv_update(unit, ivsi, iga0, iga1, iga2, iga3, &entry);

    return s;
}


/*
 * Entry accessor implementations for v6mc_sgv
 */

void soc_sbx_g3p1_v6mc_sgv_t_init(
    soc_sbx_g3p1_v6mc_sgv_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v6mc_sgv_t));
    e->hit = 1;
}

/* entry pack accessor implementation for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_pack(int unit,
    soc_sbx_g3p1_v6mc_sgv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_unpack(int unit,
                soc_sbx_g3p1_v6mc_sgv_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->rpfunion; break;
          case 1: p = (uint8 *) &e->ftidx; break;
          case 2: p = (uint8 *) &e->hit; break;
          case 3: p = (uint8 *) &e->rsvd; break;
          case 4: p = (uint8 *) &e->proccopy; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_index_check(int unit, uint32 *vindex, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3 )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivsi; break;
          case 1: p = (uint8 *) &isa0; break;
          case 2: p = (uint8 *) &isa1; break;
          case 3: p = (uint8 *) &isa2; break;
          case 4: p = (uint8 *) &isa3; break;
          case 5: p = (uint8 *) &iga0; break;
          case 6: p = (uint8 *) &iga1; break;
          case 7: p = (uint8 *) &iga2; break;
          case 8: p = (uint8 *) &iga3; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_index_unpack(int unit, int *vindex, int *nivsi, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivsi; break;
          case 1: p = (uint8 *) nisa0; break;
          case 2: p = (uint8 *) nisa1; break;
          case 3: p = (uint8 *) nisa2; break;
          case 4: p = (uint8 *) nisa3; break;
          case 5: p = (uint8 *) niga0; break;
          case 6: p = (uint8 *) niga1; break;
          case 7: p = (uint8 *) niga2; break;
          case 8: p = (uint8 *) niga3; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_entry_check(int unit,
                                 soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->rpfunion; break;
          case 1: ev = e->ftidx; break;
          case 2: ev = e->hit; break;
          case 3: ev = e->rsvd; break;
          case 4: ev = e->proccopy; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_set(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_sgv_update(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_v6mc_sgv_add(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_add(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_sgv_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_sgv_add_ext_sim(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_get(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_sgv_get_ext_sim(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_sgv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_hw_get(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_sgv_get_ext_sim(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_sgv_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_update(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v6mc_sgv_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v6mc_sgv_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_sgv_add_ext_sim(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_delete(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_v6mc_sgv_delete_ext_sim(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_remove(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3)
{
    return soc_sbx_g3p1_v6mc_sgv_delete(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
}

/* Get the first element of v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_first(int unit, int *nivsi, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_v6mc_sgv_index_unpack(unit, (int *)key, nivsi, nisa0, nisa1, nisa2, nisa3, niga0, niga1, niga2, niga3);    
}

/* Get the next element of v6mc_sgv */
int soc_sbx_g3p1_v6mc_sgv_next(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, int *nivsi, int *nisa0, int *nisa1, int *nisa2, int *nisa3, int *niga0, int *niga1, int *niga2, int *niga3)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_v6mc_sgv_index_check(unit, key, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_v6mc_sgv_index_unpack(unit, (int *)next_key, nivsi, nisa0, nisa1, nisa2, nisa3, niga0, niga1, niga2, niga3);  
}

/**
New entry set accessor implementation for v6mc_sgv
*/
int soc_sbx_g3p1_v6mc_sgv_data_set(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_sgv_t entry;

    soc_sbx_g3p1_v6mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_sgv_set(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, &entry);

    return s;
}

/**
New entry add accessor implementation for v6mc_sgv
*/
int soc_sbx_g3p1_v6mc_sgv_data_add(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_sgv_t entry;

    soc_sbx_g3p1_v6mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_sgv_add(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, &entry);

    return s;
}

/**
New entry get accessor implementation for v6mc_sgv
*/
int soc_sbx_g3p1_v6mc_sgv_data_get(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_sgv_t entry;

    soc_sbx_g3p1_v6mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_sgv_get(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_sgv_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for v6mc_sgv
*/
int soc_sbx_g3p1_v6mc_sgv_data_update(int unit, int ivsi, int isa0, int isa1, int isa2, int isa3, int iga0, int iga1, int iga2, int iga3, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v6mc_sgv_t entry;

    soc_sbx_g3p1_v6mc_sgv_t_init(&entry);
    s = soc_sbx_g3p1_v6mc_sgv_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v6mc_sgv_update(unit, ivsi, isa0, isa1, isa2, isa3, iga0, iga1, iga2, iga3, &entry);

    return s;
}


/*
 * Entry accessor implementations for oamrx
 */

void soc_sbx_g3p1_oamrx_t_init(
    soc_sbx_g3p1_oamrx_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oamrx_t));
    e->hit = 1;
}

/* entry pack accessor implementation for oamrx */
static int soc_sbx_g3p1_oamrx_pack(int unit,
    soc_sbx_g3p1_oamrx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->hit; break;
          case 1: p = (uint8 *) &e->svc_hdl; break;


          case 2: p = (uint8 *) &e->mdlvl_7_f; break;
          case 3: p = (uint8 *) &e->mdlvl_7_d; break;
          case 4: p = (uint8 *) &e->mdlvl_7_p; break;
          case 5: p = (uint8 *) &e->mdlvl_7_m; break;
          case 6: p = (uint8 *) &e->mdlvl_6_f; break;
          case 7: p = (uint8 *) &e->mdlvl_6_d; break;
          case 8: p = (uint8 *) &e->mdlvl_6_p; break;
          case 9: p = (uint8 *) &e->mdlvl_6_m; break;
          case 10: p = (uint8 *) &e->mdlvl_5_f; break;
          case 11: p = (uint8 *) &e->mdlvl_5_d; break;
          case 12: p = (uint8 *) &e->mdlvl_5_p; break;
          case 13: p = (uint8 *) &e->mdlvl_5_m; break;
          case 14: p = (uint8 *) &e->mdlvl_4_f; break;
          case 15: p = (uint8 *) &e->mdlvl_4_d; break;
          case 16: p = (uint8 *) &e->mdlvl_4_p; break;
          case 17: p = (uint8 *) &e->mdlvl_4_m; break;
          case 18: p = (uint8 *) &e->mdlvl_3_f; break;
          case 19: p = (uint8 *) &e->mdlvl_3_d; break;
          case 20: p = (uint8 *) &e->mdlvl_3_p; break;
          case 21: p = (uint8 *) &e->mdlvl_3_m; break;
          case 22: p = (uint8 *) &e->mdlvl_2_f; break;
          case 23: p = (uint8 *) &e->mdlvl_2_d; break;
          case 24: p = (uint8 *) &e->mdlvl_2_p; break;
          case 25: p = (uint8 *) &e->mdlvl_2_m; break;
          case 26: p = (uint8 *) &e->mdlvl_1_f; break;
          case 27: p = (uint8 *) &e->mdlvl_1_d; break;
          case 28: p = (uint8 *) &e->mdlvl_1_p; break;
          case 29: p = (uint8 *) &e->mdlvl_1_m; break;
          case 30: p = (uint8 *) &e->mdlvl_0_f; break;
          case 31: p = (uint8 *) &e->mdlvl_0_d; break;
          case 32: p = (uint8 *) &e->mdlvl_0_p; break;
          case 33: p = (uint8 *) &e->mdlvl_0_m; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamrx */
static int soc_sbx_g3p1_oamrx_unpack(int unit,
                soc_sbx_g3p1_oamrx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->hit; break;
          case 1: p = (uint8 *) &e->svc_hdl; break;


          case 2: p = (uint8 *) &e->mdlvl_7_f; break;
          case 3: p = (uint8 *) &e->mdlvl_7_d; break;
          case 4: p = (uint8 *) &e->mdlvl_7_p; break;
          case 5: p = (uint8 *) &e->mdlvl_7_m; break;
          case 6: p = (uint8 *) &e->mdlvl_6_f; break;
          case 7: p = (uint8 *) &e->mdlvl_6_d; break;
          case 8: p = (uint8 *) &e->mdlvl_6_p; break;
          case 9: p = (uint8 *) &e->mdlvl_6_m; break;
          case 10: p = (uint8 *) &e->mdlvl_5_f; break;
          case 11: p = (uint8 *) &e->mdlvl_5_d; break;
          case 12: p = (uint8 *) &e->mdlvl_5_p; break;
          case 13: p = (uint8 *) &e->mdlvl_5_m; break;
          case 14: p = (uint8 *) &e->mdlvl_4_f; break;
          case 15: p = (uint8 *) &e->mdlvl_4_d; break;
          case 16: p = (uint8 *) &e->mdlvl_4_p; break;
          case 17: p = (uint8 *) &e->mdlvl_4_m; break;
          case 18: p = (uint8 *) &e->mdlvl_3_f; break;
          case 19: p = (uint8 *) &e->mdlvl_3_d; break;
          case 20: p = (uint8 *) &e->mdlvl_3_p; break;
          case 21: p = (uint8 *) &e->mdlvl_3_m; break;
          case 22: p = (uint8 *) &e->mdlvl_2_f; break;
          case 23: p = (uint8 *) &e->mdlvl_2_d; break;
          case 24: p = (uint8 *) &e->mdlvl_2_p; break;
          case 25: p = (uint8 *) &e->mdlvl_2_m; break;
          case 26: p = (uint8 *) &e->mdlvl_1_f; break;
          case 27: p = (uint8 *) &e->mdlvl_1_d; break;
          case 28: p = (uint8 *) &e->mdlvl_1_p; break;
          case 29: p = (uint8 *) &e->mdlvl_1_m; break;
          case 30: p = (uint8 *) &e->mdlvl_0_f; break;
          case 31: p = (uint8 *) &e->mdlvl_0_d; break;
          case 32: p = (uint8 *) &e->mdlvl_0_p; break;
          case 33: p = (uint8 *) &e->mdlvl_0_m; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamrx */
static int soc_sbx_g3p1_oamrx_index_check(int unit, uint32 *vindex, int iivid, int iovid, int idir, int iport, int ivid_mode )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iivid; break;
          case 1: p = (uint8 *) &iovid; break;
          case 2: p = (uint8 *) &idir; break;
          case 3: p = (uint8 *) &iport; break;
          case 4: p = (uint8 *) &ivid_mode; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for oamrx */
static int soc_sbx_g3p1_oamrx_index_unpack(int unit, int *vindex, int *niivid, int *niovid, int *nidir, int *niport, int *nivid_mode)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) niivid; break;
          case 1: p = (uint8 *) niovid; break;
          case 2: p = (uint8 *) nidir; break;
          case 3: p = (uint8 *) niport; break;
          case 4: p = (uint8 *) nivid_mode; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for oamrx */
int soc_sbx_g3p1_oamrx_entry_check(int unit,
                                 soc_sbx_g3p1_oamrx_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->hit; break;
          case 1: ev = e->svc_hdl; break;
          case 2: ev = e->mdlvl_7_f; break;
          case 3: ev = e->mdlvl_7_d; break;
          case 4: ev = e->mdlvl_7_p; break;
          case 5: ev = e->mdlvl_7_m; break;
          case 6: ev = e->mdlvl_6_f; break;
          case 7: ev = e->mdlvl_6_d; break;
          case 8: ev = e->mdlvl_6_p; break;
          case 9: ev = e->mdlvl_6_m; break;
          case 10: ev = e->mdlvl_5_f; break;
          case 11: ev = e->mdlvl_5_d; break;
          case 12: ev = e->mdlvl_5_p; break;
          case 13: ev = e->mdlvl_5_m; break;
          case 14: ev = e->mdlvl_4_f; break;
          case 15: ev = e->mdlvl_4_d; break;
          case 16: ev = e->mdlvl_4_p; break;
          case 17: ev = e->mdlvl_4_m; break;
          case 18: ev = e->mdlvl_3_f; break;
          case 19: ev = e->mdlvl_3_d; break;
          case 20: ev = e->mdlvl_3_p; break;
          case 21: ev = e->mdlvl_3_m; break;
          case 22: ev = e->mdlvl_2_f; break;
          case 23: ev = e->mdlvl_2_d; break;
          case 24: ev = e->mdlvl_2_p; break;
          case 25: ev = e->mdlvl_2_m; break;
          case 26: ev = e->mdlvl_1_f; break;
          case 27: ev = e->mdlvl_1_d; break;
          case 28: ev = e->mdlvl_1_p; break;
          case 29: ev = e->mdlvl_1_m; break;
          case 30: ev = e->mdlvl_0_f; break;
          case 31: ev = e->mdlvl_0_d; break;
          case 32: ev = e->mdlvl_0_p; break;
          case 33: ev = e->mdlvl_0_m; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_set(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, soc_sbx_g3p1_oamrx_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oamrx_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oamrx_update(unit, iivid, iovid, idir, iport, ivid_mode, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_oamrx_add(unit, iivid, iovid, idir, iport, ivid_mode, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_add(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, soc_sbx_g3p1_oamrx_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oamrx_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oamrx_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_oamrx_add_ext_sim(unit, iivid, iovid, idir, iport, ivid_mode, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_get(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, soc_sbx_g3p1_oamrx_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_oamrx_get_ext_sim(unit, iivid, iovid, idir, iport, ivid_mode, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oamrx_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_hw_get(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, soc_sbx_g3p1_oamrx_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_oamrx_get_ext_sim(unit, iivid, iovid, idir, iport, ivid_mode, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oamrx_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_update(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, soc_sbx_g3p1_oamrx_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oamrx_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oamrx_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_oamrx_add_ext_sim(unit, iivid, iovid, idir, iport, ivid_mode, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_delete(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_oamrx_delete_ext_sim(unit, iivid, iovid, idir, iport, ivid_mode);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for oamrx */
int soc_sbx_g3p1_oamrx_remove(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode)
{
    return soc_sbx_g3p1_oamrx_delete(unit, iivid, iovid, idir, iport, ivid_mode);
}

/* Get the first element of oamrx */
int soc_sbx_g3p1_oamrx_first(int unit, int *niivid, int *niovid, int *nidir, int *niport, int *nivid_mode)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_oamrx_index_unpack(unit, (int *)key, niivid, niovid, nidir, niport, nivid_mode);    
}

/* Get the next element of oamrx */
int soc_sbx_g3p1_oamrx_next(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, int *niivid, int *niovid, int *nidir, int *niport, int *nivid_mode)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_oamrx_index_check(unit, key, iivid, iovid, idir, iport, ivid_mode);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_oamrx_index_unpack(unit, (int *)next_key, niivid, niovid, nidir, niport, nivid_mode);  
}

/**
New entry set accessor implementation for oamrx
*/
int soc_sbx_g3p1_oamrx_data_set(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_t entry;

    soc_sbx_g3p1_oamrx_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_set(unit, iivid, iovid, idir, iport, ivid_mode, &entry);

    return s;
}

/**
New entry add accessor implementation for oamrx
*/
int soc_sbx_g3p1_oamrx_data_add(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_t entry;

    soc_sbx_g3p1_oamrx_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_add(unit, iivid, iovid, idir, iport, ivid_mode, &entry);

    return s;
}

/**
New entry get accessor implementation for oamrx
*/
int soc_sbx_g3p1_oamrx_data_get(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_t entry;

    soc_sbx_g3p1_oamrx_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_get(unit, iivid, iovid, idir, iport, ivid_mode, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for oamrx
*/
int soc_sbx_g3p1_oamrx_data_update(int unit, int iivid, int iovid, int idir, int iport, int ivid_mode, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_t entry;

    soc_sbx_g3p1_oamrx_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_update(unit, iivid, iovid, idir, iport, ivid_mode, &entry);

    return s;
}


/*
 * Entry accessor implementations for maidmep
 */

void soc_sbx_g3p1_maidmep_t_init(
    soc_sbx_g3p1_maidmep_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_maidmep_t));
    e->hit = 1;
}

/* entry pack accessor implementation for maidmep */
static int soc_sbx_g3p1_maidmep_pack(int unit,
    soc_sbx_g3p1_maidmep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->hit; break;
          case 1: p = (uint8 *) &e->peer_idx; break;




          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for maidmep */
static int soc_sbx_g3p1_maidmep_unpack(int unit,
                soc_sbx_g3p1_maidmep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->hit; break;
          case 1: p = (uint8 *) &e->peer_idx; break;




          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for maidmep */
static int soc_sbx_g3p1_maidmep_index_check(int unit, uint32 *vindex, int isvc_hdl, int imepid, int imsg_type, int imdlvl )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &isvc_hdl; break;
          case 1: p = (uint8 *) &imepid; break;
          case 2: p = (uint8 *) &imsg_type; break;
          case 3: p = (uint8 *) &imdlvl; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for maidmep */
static int soc_sbx_g3p1_maidmep_index_unpack(int unit, int *vindex, int *nisvc_hdl, int *nimepid, int *nimsg_type, int *nimdlvl)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nisvc_hdl; break;
          case 1: p = (uint8 *) nimepid; break;
          case 2: p = (uint8 *) nimsg_type; break;
          case 3: p = (uint8 *) nimdlvl; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for maidmep */
int soc_sbx_g3p1_maidmep_entry_check(int unit,
                                 soc_sbx_g3p1_maidmep_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->hit; break;
          case 1: ev = e->peer_idx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_set(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, soc_sbx_g3p1_maidmep_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_maidmep_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_maidmep_update(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_maidmep_add(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_add(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, soc_sbx_g3p1_maidmep_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_maidmep_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_maidmep_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_maidmep_add_ext_sim(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_get(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, soc_sbx_g3p1_maidmep_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_maidmep_get_ext_sim(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_maidmep_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_hw_get(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, soc_sbx_g3p1_maidmep_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_maidmep_get_ext_sim(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_maidmep_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_update(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, soc_sbx_g3p1_maidmep_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_maidmep_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_maidmep_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_maidmep_add_ext_sim(unit, isvc_hdl, imepid, imsg_type, imdlvl, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_delete(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_maidmep_delete_ext_sim(unit, isvc_hdl, imepid, imsg_type, imdlvl);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for maidmep */
int soc_sbx_g3p1_maidmep_remove(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl)
{
    return soc_sbx_g3p1_maidmep_delete(unit, isvc_hdl, imepid, imsg_type, imdlvl);
}

/* Get the first element of maidmep */
int soc_sbx_g3p1_maidmep_first(int unit, int *nisvc_hdl, int *nimepid, int *nimsg_type, int *nimdlvl)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_maidmep_index_unpack(unit, (int *)key, nisvc_hdl, nimepid, nimsg_type, nimdlvl);    
}

/* Get the next element of maidmep */
int soc_sbx_g3p1_maidmep_next(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, int *nisvc_hdl, int *nimepid, int *nimsg_type, int *nimdlvl)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_maidmep_index_check(unit, key, isvc_hdl, imepid, imsg_type, imdlvl);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_maidmep_index_unpack(unit, (int *)next_key, nisvc_hdl, nimepid, nimsg_type, nimdlvl);  
}

/**
New entry set accessor implementation for maidmep
*/
int soc_sbx_g3p1_maidmep_data_set(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_maidmep_t entry;

    soc_sbx_g3p1_maidmep_t_init(&entry);
    s = soc_sbx_g3p1_maidmep_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_maidmep_set(unit, isvc_hdl, imepid, imsg_type, imdlvl, &entry);

    return s;
}

/**
New entry add accessor implementation for maidmep
*/
int soc_sbx_g3p1_maidmep_data_add(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_maidmep_t entry;

    soc_sbx_g3p1_maidmep_t_init(&entry);
    s = soc_sbx_g3p1_maidmep_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_maidmep_add(unit, isvc_hdl, imepid, imsg_type, imdlvl, &entry);

    return s;
}

/**
New entry get accessor implementation for maidmep
*/
int soc_sbx_g3p1_maidmep_data_get(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_maidmep_t entry;

    soc_sbx_g3p1_maidmep_t_init(&entry);
    s = soc_sbx_g3p1_maidmep_get(unit, isvc_hdl, imepid, imsg_type, imdlvl, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_maidmep_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for maidmep
*/
int soc_sbx_g3p1_maidmep_data_update(int unit, int isvc_hdl, int imepid, int imsg_type, int imdlvl, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_maidmep_t entry;

    soc_sbx_g3p1_maidmep_t_init(&entry);
    s = soc_sbx_g3p1_maidmep_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_maidmep_update(unit, isvc_hdl, imepid, imsg_type, imdlvl, &entry);

    return s;
}


/*
 * Entry accessor implementations for emlfilter
 */

void soc_sbx_g3p1_emlfilter_t_init(
    soc_sbx_g3p1_emlfilter_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_emlfilter_t));
}

/* entry pack accessor implementation for emlfilter */
static int soc_sbx_g3p1_emlfilter_pack(int unit,
    soc_sbx_g3p1_emlfilter_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->reserved_0; break;
          case 1: p = (uint8 *) &e->reserved_1; break;
          case 2: p = (uint8 *) &e->reserved_2; break;
          case 3: p = (uint8 *) &e->reserved_3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emlfilter */
static int soc_sbx_g3p1_emlfilter_unpack(int unit,
                soc_sbx_g3p1_emlfilter_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->reserved_0; break;
          case 1: p = (uint8 *) &e->reserved_1; break;
          case 2: p = (uint8 *) &e->reserved_2; break;
          case 3: p = (uint8 *) &e->reserved_3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emlfilter */
static int soc_sbx_g3p1_emlfilter_index_check(int unit, uint32 *vindex, int iemlindex )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iemlindex; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for emlfilter */
static int soc_sbx_g3p1_emlfilter_index_unpack(int unit, int *vindex, int *niemlindex)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) niemlindex; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for emlfilter */
int soc_sbx_g3p1_emlfilter_entry_check(int unit,
                                 soc_sbx_g3p1_emlfilter_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->reserved_0; break;
          case 1: ev = e->reserved_1; break;
          case 2: ev = e->reserved_2; break;
          case 3: ev = e->reserved_3; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_set(int unit, int iemlindex, soc_sbx_g3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_emlfilter_update(unit, iemlindex, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_emlfilter_add(unit, iemlindex, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_add(int unit, int iemlindex, soc_sbx_g3p1_emlfilter_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_emlfilter_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_emlfilter_add_ext_sim(unit, iemlindex, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_get(int unit, int iemlindex, soc_sbx_g3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_emlfilter_get_ext_sim(unit, iemlindex, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_emlfilter_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_hw_get(int unit, int iemlindex, soc_sbx_g3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_emlfilter_get_ext_sim(unit, iemlindex, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_emlfilter_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_update(int unit, int iemlindex, soc_sbx_g3p1_emlfilter_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_emlfilter_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_emlfilter_add_ext_sim(unit, iemlindex, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_delete(int unit, int iemlindex)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_emlfilter_delete_ext_sim(unit, iemlindex);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for emlfilter */
int soc_sbx_g3p1_emlfilter_remove(int unit, int iemlindex)
{
    return soc_sbx_g3p1_emlfilter_delete(unit, iemlindex);
}

/* Get the first element of emlfilter */
int soc_sbx_g3p1_emlfilter_first(int unit, int *niemlindex)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_emlfilter_index_unpack(unit, (int *)key, niemlindex);    
}

/* Get the next element of emlfilter */
int soc_sbx_g3p1_emlfilter_next(int unit, int iemlindex, int *niemlindex)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_emlfilter_index_check(unit, key, iemlindex);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_emlfilter_index_unpack(unit, (int *)next_key, niemlindex);  
}

/**
New entry set accessor implementation for emlfilter
*/
int soc_sbx_g3p1_emlfilter_data_set(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emlfilter_t entry;

    soc_sbx_g3p1_emlfilter_t_init(&entry);
    s = soc_sbx_g3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emlfilter_set(unit, iemlindex, &entry);

    return s;
}

/**
New entry add accessor implementation for emlfilter
*/
int soc_sbx_g3p1_emlfilter_data_add(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emlfilter_t entry;

    soc_sbx_g3p1_emlfilter_t_init(&entry);
    s = soc_sbx_g3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emlfilter_add(unit, iemlindex, &entry);

    return s;
}

/**
New entry get accessor implementation for emlfilter
*/
int soc_sbx_g3p1_emlfilter_data_get(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emlfilter_t entry;

    soc_sbx_g3p1_emlfilter_t_init(&entry);
    s = soc_sbx_g3p1_emlfilter_get(unit, iemlindex, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emlfilter_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for emlfilter
*/
int soc_sbx_g3p1_emlfilter_data_update(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emlfilter_t entry;

    soc_sbx_g3p1_emlfilter_t_init(&entry);
    s = soc_sbx_g3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emlfilter_update(unit, iemlindex, &entry);

    return s;
}


/*
 * Entry accessor implementations for ete
 */

void soc_sbx_g3p1_ete_t_init(
    soc_sbx_g3p1_ete_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_ete_t));
    e->stpcheck = 1;
}

/* entry pack accessor implementation for ete */
static int soc_sbx_g3p1_ete_pack(int unit,
    soc_sbx_g3p1_ete_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->dmacset; break;
          case 1: p = (uint8 *) &e->dmacsetlsb; break;
          case 2: p = (uint8 *) &e->dscpremark; break;
          case 3: p = (uint8 *) &e->remark; break;
          case 4: p = (uint8 *) &e->mplsttldec; break;
          case 5: p = (uint8 *) &e->encaplen; break;
          case 6: p = (uint8 *) &e->encapmac; break;
          case 7: p = (uint8 *) &e->nostrip; break;
          case 8: p = (uint8 *) &e->noclass; break;
          case 9: p = (uint8 *) &e->etepid; break;
          case 10: p = (uint8 *) &e->tunnelenter; break;
          case 11: p = (uint8 *) &e->exp0remark; break;
          case 12: p = (uint8 *) &e->exp1remark; break;
          case 13: p = (uint8 *) &e->exp2remark; break;
          case 14: p = (uint8 *) &e->ttl0dec; break;
          case 15: p = (uint8 *) &e->ttl1dec; break;
          case 16: p = (uint8 *) &e->ttl2dec; break;
          case 17: p = (uint8 *) &e->smacset; break;
          case 18: p = (uint8 *) &e->nosplitcheck; break;
          case 19: p = (uint8 *) &e->ttlcheck; break;
          case 20: p = (uint8 *) &e->ipttldec; break;
          case 21: p = (uint8 *) &e->add_pwcw; break;
          case 22: p = (uint8 *) &e->comp_encaplen; break;
          case 23: p = (uint8 *) &e->etype2; break;
          case 24: p = (uint8 *) &e->ttl2; break;
          case 25: p = (uint8 *) &e->s2; break;
          case 26: p = (uint8 *) &e->exp2; break;
          case 27: p = (uint8 *) &e->label2; break;
          case 28: p = (uint8 *) &e->encap_vid; break;
          case 29: p = (uint8 *) &e->pricfi; break;
          case 30: p = (uint8 *) &e->etype; break;
          case 31: p = (uint8 *) &e->tpid; break;
          case 32: p = (uint8 *) &e->pid; break;
          case 33: p = (uint8 *) &e->dmac5; break;
          case 34: p = (uint8 *) &e->dmac4; break;
          case 35: p = (uint8 *) &e->dmac3; break;
          case 36: p = (uint8 *) &e->dmac2; break;
          case 37: p = (uint8 *) &e->dmac1; break;
          case 38: p = (uint8 *) &e->dmac0; break;
          case 39: p = (uint8 *) &e->vlan; break;
          case 40: p = (uint8 *) &e->defpricfi; break;
          case 41: p = (uint8 *) &e->usetag; break;
          case 42: p = (uint8 *) &e->l2_reserved; break;
          case 43: p = (uint8 *) &e->dropuntagged; break;
          case 44: p = (uint8 *) &e->droptagged; break;
          case 45: p = (uint8 *) &e->smacindex; break;
          case 46: p = (uint8 *) &e->stpcheck; break;
          case 47: p = (uint8 *) &e->vid; break;




          case 48: p = (uint8 *) &e->ttl0; break;
          case 49: p = (uint8 *) &e->s0; break;
          case 50: p = (uint8 *) &e->exp0; break;
          case 51: p = (uint8 *) &e->label0; break;
          case 52: p = (uint8 *) &e->ttl1; break;
          case 53: p = (uint8 *) &e->s1; break;
          case 54: p = (uint8 *) &e->exp1; break;
          case 55: p = (uint8 *) &e->label1; break;
          case 56: p = (uint8 *) &e->smac5; break;
          case 57: p = (uint8 *) &e->smac4; break;
          case 58: p = (uint8 *) &e->smac3; break;
          case 59: p = (uint8 *) &e->smac2; break;
          case 60: p = (uint8 *) &e->smac1; break;
          case 61: p = (uint8 *) &e->smac0; break;
          case 62: p = (uint8 *) &e->mtu; break;
          case 63: p = (uint8 *) &e->usevid; break;








          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ete */
static int soc_sbx_g3p1_ete_unpack(int unit,
                soc_sbx_g3p1_ete_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->dmacset; break;
        case 1: p = (uint8 *) &e->dmacsetlsb; break;
        case 2: p = (uint8 *) &e->dscpremark; break;
        case 3: p = (uint8 *) &e->remark; break;
        case 4: p = (uint8 *) &e->mplsttldec; break;
        case 5: p = (uint8 *) &e->encaplen; break;
        case 6: p = (uint8 *) &e->encapmac; break;
        case 7: p = (uint8 *) &e->nostrip; break;
        case 8: p = (uint8 *) &e->noclass; break;
        case 9: p = (uint8 *) &e->etepid; break;
        case 10: p = (uint8 *) &e->tunnelenter; break;
        case 11: p = (uint8 *) &e->exp0remark; break;
        case 12: p = (uint8 *) &e->exp1remark; break;
        case 13: p = (uint8 *) &e->exp2remark; break;
        case 14: p = (uint8 *) &e->ttl0dec; break;
        case 15: p = (uint8 *) &e->ttl1dec; break;
        case 16: p = (uint8 *) &e->ttl2dec; break;
        case 17: p = (uint8 *) &e->smacset; break;
        case 18: p = (uint8 *) &e->nosplitcheck; break;
        case 19: p = (uint8 *) &e->ttlcheck; break;
        case 20: p = (uint8 *) &e->ipttldec; break;
        case 21: p = (uint8 *) &e->add_pwcw; break;
        case 22: p = (uint8 *) &e->comp_encaplen; break;
        case 23: p = (uint8 *) &e->etype2; break;
        case 24: p = (uint8 *) &e->ttl2; break;
        case 25: p = (uint8 *) &e->s2; break;
        case 26: p = (uint8 *) &e->exp2; break;
        case 27: p = (uint8 *) &e->label2; break;
        case 28: p = (uint8 *) &e->encap_vid; break;
        case 29: p = (uint8 *) &e->pricfi; break;
        case 30: p = (uint8 *) &e->etype; break;
        case 31: p = (uint8 *) &e->tpid; break;
        case 32: p = (uint8 *) &e->pid; break;
        case 33: p = (uint8 *) &e->dmac5; break;
        case 34: p = (uint8 *) &e->dmac4; break;
        case 35: p = (uint8 *) &e->dmac3; break;
        case 36: p = (uint8 *) &e->dmac2; break;
        case 37: p = (uint8 *) &e->dmac1; break;
        case 38: p = (uint8 *) &e->dmac0; break;
        case 39: p = (uint8 *) &e->vlan; break;
        case 40: p = (uint8 *) &e->defpricfi; break;
        case 41: p = (uint8 *) &e->usetag; break;
        case 42: p = (uint8 *) &e->l2_reserved; break;
        case 43: p = (uint8 *) &e->dropuntagged; break;
        case 44: p = (uint8 *) &e->droptagged; break;
        case 45: p = (uint8 *) &e->smacindex; break;
        case 46: p = (uint8 *) &e->stpcheck; break;
        case 47: p = (uint8 *) &e->vid; break;




        case 48: p = (uint8 *) &e->ttl0; break;
        case 49: p = (uint8 *) &e->s0; break;
        case 50: p = (uint8 *) &e->exp0; break;
        case 51: p = (uint8 *) &e->label0; break;
        case 52: p = (uint8 *) &e->ttl1; break;
        case 53: p = (uint8 *) &e->s1; break;
        case 54: p = (uint8 *) &e->exp1; break;
        case 55: p = (uint8 *) &e->label1; break;
        case 56: p = (uint8 *) &e->smac5; break;
        case 57: p = (uint8 *) &e->smac4; break;
        case 58: p = (uint8 *) &e->smac3; break;
        case 59: p = (uint8 *) &e->smac2; break;
        case 60: p = (uint8 *) &e->smac1; break;
        case 61: p = (uint8 *) &e->smac0; break;
        case 62: p = (uint8 *) &e->mtu; break;
        case 63: p = (uint8 *) &e->usevid; break;







               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ete */
int soc_sbx_g3p1_ete_index_check(int unit, uint32 *vindex, int ietei )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ietei; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ete */
int soc_sbx_g3p1_ete_entry_check(int unit,
                                 soc_sbx_g3p1_ete_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->dmacset; break;
          case 1: ev = e->dmacsetlsb; break;
          case 2: ev = e->dscpremark; break;
          case 3: ev = e->remark; break;
          case 4: ev = e->mplsttldec; break;
          case 5: ev = e->encaplen; break;
          case 6: ev = e->encapmac; break;
          case 7: ev = e->nostrip; break;
          case 8: ev = e->noclass; break;
          case 9: ev = e->etepid; break;
          case 10: ev = e->tunnelenter; break;
          case 11: ev = e->exp0remark; break;
          case 12: ev = e->exp1remark; break;
          case 13: ev = e->exp2remark; break;
          case 14: ev = e->ttl0dec; break;
          case 15: ev = e->ttl1dec; break;
          case 16: ev = e->ttl2dec; break;
          case 17: ev = e->smacset; break;
          case 18: ev = e->nosplitcheck; break;
          case 19: ev = e->ttlcheck; break;
          case 20: ev = e->ipttldec; break;
          case 21: ev = e->add_pwcw; break;
          case 22: ev = e->comp_encaplen; break;
          case 23: ev = e->etype2; break;
          case 24: ev = e->ttl2; break;
          case 25: ev = e->s2; break;
          case 26: ev = e->exp2; break;
          case 27: ev = e->label2; break;
          case 28: ev = e->encap_vid; break;
          case 29: ev = e->pricfi; break;
          case 30: ev = e->etype; break;
          case 31: ev = e->tpid; break;
          case 32: ev = e->pid; break;
          case 33: ev = e->dmac5; break;
          case 34: ev = e->dmac4; break;
          case 35: ev = e->dmac3; break;
          case 36: ev = e->dmac2; break;
          case 37: ev = e->dmac1; break;
          case 38: ev = e->dmac0; break;
          case 39: ev = e->vlan; break;
          case 40: ev = e->defpricfi; break;
          case 41: ev = e->usetag; break;
          case 42: ev = e->l2_reserved; break;
          case 43: ev = e->dropuntagged; break;
          case 44: ev = e->droptagged; break;
          case 45: ev = e->smacindex; break;
          case 46: ev = e->stpcheck; break;
          case 47: ev = e->vid; break;
          case 48: ev = e->ttl0; break;
          case 49: ev = e->s0; break;
          case 50: ev = e->exp0; break;
          case 51: ev = e->label0; break;
          case 52: ev = e->ttl1; break;
          case 53: ev = e->s1; break;
          case 54: ev = e->exp1; break;
          case 55: ev = e->label1; break;
          case 56: ev = e->smac5; break;
          case 57: ev = e->smac4; break;
          case 58: ev = e->smac3; break;
          case 59: ev = e->smac2; break;
          case 60: ev = e->smac1; break;
          case 61: ev = e->smac0; break;
          case 62: ev = e->mtu; break;
          case 63: ev = e->usevid; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for ete */
int soc_sbx_g3p1_ete_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for ete */
int soc_sbx_g3p1_ete_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for ete */
int soc_sbx_g3p1_ete_set(int unit, int ietei, soc_sbx_g3p1_ete_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_ete_index_check(unit, key, ietei);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_ete_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_g3p1_ete_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_ete_add_ext_sim(unit, ietei, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for ete */
int soc_sbx_g3p1_ete_get(int unit, int ietei, soc_sbx_g3p1_ete_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_ete_index_check(unit, key, ietei);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_ete_get_ext_sim(unit, ietei,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(501));
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_ete_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for ete
*/
int soc_sbx_g3p1_ete_data_set(int unit, int ietei, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ete_t entry;

    soc_sbx_g3p1_ete_t_init(&entry);
    s = soc_sbx_g3p1_ete_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_ete_set(unit, ietei, &entry);

    return s;
}

/**
New entry get accessor implementation for ete
*/
int soc_sbx_g3p1_ete_data_get(int unit, int ietei, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ete_t entry;

    soc_sbx_g3p1_ete_t_init(&entry);
    s = soc_sbx_g3p1_ete_get(unit, ietei, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_g3p1_ete_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_ep
 */

void soc_sbx_g3p1_oam_ep_t_init(
    soc_sbx_g3p1_oam_ep_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oam_ep_t));
}

/* entry pack accessor implementation for oam_ep */
static int soc_sbx_g3p1_oam_ep_pack(int unit,
    soc_sbx_g3p1_oam_ep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->smac1; break;
          case 1: p = (uint8 *) &e->smac0; break;
          case 2: p = (uint8 *) &e->dmac5; break;
          case 3: p = (uint8 *) &e->dmac4; break;
          case 4: p = (uint8 *) &e->dmac3; break;
          case 5: p = (uint8 *) &e->dmac2; break;
          case 6: p = (uint8 *) &e->dmac1; break;
          case 7: p = (uint8 *) &e->dmac0; break;
          case 8: p = (uint8 *) &e->smac5; break;
          case 9: p = (uint8 *) &e->smac4; break;
          case 10: p = (uint8 *) &e->smac3; break;
          case 11: p = (uint8 *) &e->smac2; break;

          case 12: p = (uint8 *) &e->vid; break;
          case 13: p = (uint8 *) &e->num_vlan_tags; break;
          case 14: p = (uint8 *) &e->dir; break;
          case 15: p = (uint8 *) &e->reqMinEchoRxInterval; break;

          case 16: p = (uint8 *) &e->localDiscr; break;









          case 17: p = (uint8 *) &e->ftidx; break;
          case 18: p = (uint8 *) &e->dport; break;
          case 19: p = (uint8 *) &e->dqueue; break;
          case 20: p = (uint8 *) &e->tlv_offset; break;
          case 21: p = (uint8 *) &e->period; break;
          case 22: p = (uint8 *) &e->flags_rsvd; break;
          case 23: p = (uint8 *) &e->rdi; break;
          case 24: p = (uint8 *) &e->opcode; break;
          case 25: p = (uint8 *) &e->version; break;
          case 26: p = (uint8 *) &e->mdlvl; break;

          case 27: p = (uint8 *) &e->mepid; break;
          case 28: p = (uint8 *) &e->func; break;
          case 29: p = (uint8 *) &e->type; break;
          case 30: p = (uint8 *) &e->unused; break;




          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_ep */
static int soc_sbx_g3p1_oam_ep_unpack(int unit,
                soc_sbx_g3p1_oam_ep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->smac1; break;
        case 1: p = (uint8 *) &e->smac0; break;
        case 2: p = (uint8 *) &e->dmac5; break;
        case 3: p = (uint8 *) &e->dmac4; break;
        case 4: p = (uint8 *) &e->dmac3; break;
        case 5: p = (uint8 *) &e->dmac2; break;
        case 6: p = (uint8 *) &e->dmac1; break;
        case 7: p = (uint8 *) &e->dmac0; break;
        case 8: p = (uint8 *) &e->smac5; break;
        case 9: p = (uint8 *) &e->smac4; break;
        case 10: p = (uint8 *) &e->smac3; break;
        case 11: p = (uint8 *) &e->smac2; break;

        case 12: p = (uint8 *) &e->vid; break;
        case 13: p = (uint8 *) &e->num_vlan_tags; break;
        case 14: p = (uint8 *) &e->dir; break;
        case 15: p = (uint8 *) &e->reqMinEchoRxInterval; break;

        case 16: p = (uint8 *) &e->localDiscr; break;









        case 17: p = (uint8 *) &e->ftidx; break;
        case 18: p = (uint8 *) &e->dport; break;
        case 19: p = (uint8 *) &e->dqueue; break;
        case 20: p = (uint8 *) &e->tlv_offset; break;
        case 21: p = (uint8 *) &e->period; break;
        case 22: p = (uint8 *) &e->flags_rsvd; break;
        case 23: p = (uint8 *) &e->rdi; break;
        case 24: p = (uint8 *) &e->opcode; break;
        case 25: p = (uint8 *) &e->version; break;
        case 26: p = (uint8 *) &e->mdlvl; break;

        case 27: p = (uint8 *) &e->mepid; break;
        case 28: p = (uint8 *) &e->func; break;
        case 29: p = (uint8 *) &e->type; break;
        case 30: p = (uint8 *) &e->unused; break;



               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_ep */
int soc_sbx_g3p1_oam_ep_index_check(int unit, uint32 *vindex, int ioam_epi )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ioam_epi; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_ep */
int soc_sbx_g3p1_oam_ep_entry_check(int unit,
                                 soc_sbx_g3p1_oam_ep_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->smac1; break;
          case 1: ev = e->smac0; break;
          case 2: ev = e->dmac5; break;
          case 3: ev = e->dmac4; break;
          case 4: ev = e->dmac3; break;
          case 5: ev = e->dmac2; break;
          case 6: ev = e->dmac1; break;
          case 7: ev = e->dmac0; break;
          case 8: ev = e->smac5; break;
          case 9: ev = e->smac4; break;
          case 10: ev = e->smac3; break;
          case 11: ev = e->smac2; break;
          case 12: ev = e->vid; break;
          case 13: ev = e->num_vlan_tags; break;
          case 14: ev = e->dir; break;
          case 15: ev = e->reqMinEchoRxInterval; break;
          case 16: ev = e->localDiscr; break;
          case 17: ev = e->ftidx; break;
          case 18: ev = e->dport; break;
          case 19: ev = e->dqueue; break;
          case 20: ev = e->tlv_offset; break;
          case 21: ev = e->period; break;
          case 22: ev = e->flags_rsvd; break;
          case 23: ev = e->rdi; break;
          case 24: ev = e->opcode; break;
          case 25: ev = e->version; break;
          case 26: ev = e->mdlvl; break;
          case 27: ev = e->mepid; break;
          case 28: ev = e->func; break;
          case 29: ev = e->type; break;
          case 30: ev = e->unused; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for oam_ep */
int soc_sbx_g3p1_oam_ep_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for oam_ep */
int soc_sbx_g3p1_oam_ep_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for oam_ep */
int soc_sbx_g3p1_oam_ep_set(int unit, int ioam_epi, soc_sbx_g3p1_oam_ep_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_oam_ep_index_check(unit, key, ioam_epi);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oam_ep_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_g3p1_oam_ep_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_oam_ep_add_ext_sim(unit, ioam_epi, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for oam_ep */
int soc_sbx_g3p1_oam_ep_get(int unit, int ioam_epi, soc_sbx_g3p1_oam_ep_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_oam_ep_index_check(unit, key, ioam_epi);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_oam_ep_get_ext_sim(unit, ioam_epi,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(512));
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_ep_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for oam_ep
*/
int soc_sbx_g3p1_oam_ep_data_set(int unit, int ioam_epi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_ep_t entry;

    soc_sbx_g3p1_oam_ep_t_init(&entry);
    s = soc_sbx_g3p1_oam_ep_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_ep_set(unit, ioam_epi, &entry);

    return s;
}

/**
New entry get accessor implementation for oam_ep
*/
int soc_sbx_g3p1_oam_ep_data_get(int unit, int ioam_epi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_ep_t entry;

    soc_sbx_g3p1_oam_ep_t_init(&entry);
    s = soc_sbx_g3p1_oam_ep_get(unit, ioam_epi, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_g3p1_oam_ep_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_local
 */

void soc_sbx_g3p1_oam_local_t_init(
    soc_sbx_g3p1_oam_local_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oam_local_t));
}

/* entry pack accessor implementation for oam_local */
static int soc_sbx_g3p1_oam_local_pack(int unit,
    soc_sbx_g3p1_oam_local_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->maid_w1; break;
          case 1: p = (uint8 *) &e->maid_w0; break;
          case 2: p = (uint8 *) &e->maid_w3; break;
          case 3: p = (uint8 *) &e->maid_w2; break;
          case 4: p = (uint8 *) &e->maid_w5; break;
          case 5: p = (uint8 *) &e->maid_w4; break;
          case 6: p = (uint8 *) &e->unused_w6; break;




          case 7: p = (uint8 *) &e->maid_w7; break;
          case 8: p = (uint8 *) &e->maid_w6; break;
          case 9: p = (uint8 *) &e->maid_w9; break;
          case 10: p = (uint8 *) &e->maid_w8; break;
          case 11: p = (uint8 *) &e->maid_w11; break;
          case 12: p = (uint8 *) &e->maid_w10; break;






          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_local */
static int soc_sbx_g3p1_oam_local_unpack(int unit,
                soc_sbx_g3p1_oam_local_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->maid_w1; break;
        case 1: p = (uint8 *) &e->maid_w0; break;
        case 2: p = (uint8 *) &e->maid_w3; break;
        case 3: p = (uint8 *) &e->maid_w2; break;
        case 4: p = (uint8 *) &e->maid_w5; break;
        case 5: p = (uint8 *) &e->maid_w4; break;
        case 6: p = (uint8 *) &e->unused_w6; break;




        case 7: p = (uint8 *) &e->maid_w7; break;
        case 8: p = (uint8 *) &e->maid_w6; break;
        case 9: p = (uint8 *) &e->maid_w9; break;
        case 10: p = (uint8 *) &e->maid_w8; break;
        case 11: p = (uint8 *) &e->maid_w11; break;
        case 12: p = (uint8 *) &e->maid_w10; break;





               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_local */
int soc_sbx_g3p1_oam_local_index_check(int unit, uint32 *vindex, int ioam_locali )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ioam_locali; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_local */
int soc_sbx_g3p1_oam_local_entry_check(int unit,
                                 soc_sbx_g3p1_oam_local_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->maid_w1; break;
          case 1: ev = e->maid_w0; break;
          case 2: ev = e->maid_w3; break;
          case 3: ev = e->maid_w2; break;
          case 4: ev = e->maid_w5; break;
          case 5: ev = e->maid_w4; break;
          case 6: ev = e->unused_w6; break;
          case 7: ev = e->maid_w7; break;
          case 8: ev = e->maid_w6; break;
          case 9: ev = e->maid_w9; break;
          case 10: ev = e->maid_w8; break;
          case 11: ev = e->maid_w11; break;
          case 12: ev = e->maid_w10; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for oam_local */
int soc_sbx_g3p1_oam_local_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for oam_local */
int soc_sbx_g3p1_oam_local_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for oam_local */
int soc_sbx_g3p1_oam_local_set(int unit, int ioam_locali, soc_sbx_g3p1_oam_local_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_oam_local_index_check(unit, key, ioam_locali);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oam_local_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_g3p1_oam_local_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_oam_local_add_ext_sim(unit, ioam_locali, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for oam_local */
int soc_sbx_g3p1_oam_local_get(int unit, int ioam_locali, soc_sbx_g3p1_oam_local_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_oam_local_index_check(unit, key, ioam_locali);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_oam_local_get_ext_sim(unit, ioam_locali,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(512));
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_local_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for oam_local
*/
int soc_sbx_g3p1_oam_local_data_set(int unit, int ioam_locali, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_local_t entry;

    soc_sbx_g3p1_oam_local_t_init(&entry);
    s = soc_sbx_g3p1_oam_local_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_local_set(unit, ioam_locali, &entry);

    return s;
}

/**
New entry get accessor implementation for oam_local
*/
int soc_sbx_g3p1_oam_local_data_get(int unit, int ioam_locali, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_local_t entry;

    soc_sbx_g3p1_oam_local_t_init(&entry);
    s = soc_sbx_g3p1_oam_local_get(unit, ioam_locali, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_g3p1_oam_local_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_peer
 */

void soc_sbx_g3p1_oam_peer_t_init(
    soc_sbx_g3p1_oam_peer_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oam_peer_t));
}

/* entry pack accessor implementation for oam_peer */
static int soc_sbx_g3p1_oam_peer_pack(int unit,
    soc_sbx_g3p1_oam_peer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->maid_crc; break;
          case 1: p = (uint8 *) &e->pol_id_wdg; break;
          case 2: p = (uint8 *) &e->fwd_to_host; break;
          case 3: p = (uint8 *) &e->period; break;
          case 4: p = (uint8 *) &e->pad1; break;
          case 5: p = (uint8 *) &e->w2; break;
          case 6: p = (uint8 *) &e->w3; break;
          case 7: p = (uint8 *) &e->w4; break;
          case 8: p = (uint8 *) &e->w5; break;
          case 9: p = (uint8 *) &e->w6; break;
          case 10: p = (uint8 *) &e->w7; break;
          case 11: p = (uint8 *) &e->e_w7; break;
          case 12: p = (uint8 *) &e->code_w7; break;
          case 13: p = (uint8 *) &e->reserved_w7; break;
          case 14: p = (uint8 *) &e->w8; break;
          case 15: p = (uint8 *) &e->w9; break;
          case 16: p = (uint8 *) &e->w10; break;
          case 17: p = (uint8 *) &e->w11; break;
          case 18: p = (uint8 *) &e->w12; break;
          case 19: p = (uint8 *) &e->w13; break;
          case 20: p = (uint8 *) &e->w14; break;
          case 21: p = (uint8 *) &e->w15; break;
          case 22: p = (uint8 *) &e->e_w15; break;
          case 23: p = (uint8 *) &e->code_w15; break;
          case 24: p = (uint8 *) &e->reserved_w15; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_peer */
static int soc_sbx_g3p1_oam_peer_unpack(int unit,
                soc_sbx_g3p1_oam_peer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->maid_crc; break;
        case 1: p = (uint8 *) &e->pol_id_wdg; break;
        case 2: p = (uint8 *) &e->fwd_to_host; break;
        case 3: p = (uint8 *) &e->period; break;
        case 4: p = (uint8 *) &e->pad1; break;
        case 5: p = (uint8 *) &e->w2; break;
        case 6: p = (uint8 *) &e->w3; break;
        case 7: p = (uint8 *) &e->w4; break;
        case 8: p = (uint8 *) &e->w5; break;
        case 9: p = (uint8 *) &e->w6; break;
        case 10: p = (uint8 *) &e->w7; break;
        case 11: p = (uint8 *) &e->e_w7; break;
        case 12: p = (uint8 *) &e->code_w7; break;
        case 13: p = (uint8 *) &e->reserved_w7; break;
        case 14: p = (uint8 *) &e->w8; break;
        case 15: p = (uint8 *) &e->w9; break;
        case 16: p = (uint8 *) &e->w10; break;
        case 17: p = (uint8 *) &e->w11; break;
        case 18: p = (uint8 *) &e->w12; break;
        case 19: p = (uint8 *) &e->w13; break;
        case 20: p = (uint8 *) &e->w14; break;
        case 21: p = (uint8 *) &e->w15; break;
        case 22: p = (uint8 *) &e->e_w15; break;
        case 23: p = (uint8 *) &e->code_w15; break;
        case 24: p = (uint8 *) &e->reserved_w15; break;
               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_peer */
int soc_sbx_g3p1_oam_peer_index_check(int unit, uint32 *vindex, int ioam_peer_idx )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ioam_peer_idx; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_peer */
int soc_sbx_g3p1_oam_peer_entry_check(int unit,
                                 soc_sbx_g3p1_oam_peer_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->maid_crc; break;
          case 1: ev = e->pol_id_wdg; break;
          case 2: ev = e->fwd_to_host; break;
          case 3: ev = e->period; break;
          case 4: ev = e->pad1; break;
          case 5: ev = e->w2; break;
          case 6: ev = e->w3; break;
          case 7: ev = e->w4; break;
          case 8: ev = e->w5; break;
          case 9: ev = e->w6; break;
          case 10: ev = e->w7; break;
          case 11: ev = e->e_w7; break;
          case 12: ev = e->code_w7; break;
          case 13: ev = e->reserved_w7; break;
          case 14: ev = e->w8; break;
          case 15: ev = e->w9; break;
          case 16: ev = e->w10; break;
          case 17: ev = e->w11; break;
          case 18: ev = e->w12; break;
          case 19: ev = e->w13; break;
          case 20: ev = e->w14; break;
          case 21: ev = e->w15; break;
          case 22: ev = e->e_w15; break;
          case 23: ev = e->code_w15; break;
          case 24: ev = e->reserved_w15; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for oam_peer */
int soc_sbx_g3p1_oam_peer_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for oam_peer */
int soc_sbx_g3p1_oam_peer_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for oam_peer */
int soc_sbx_g3p1_oam_peer_set(int unit, int ioam_peer_idx, soc_sbx_g3p1_oam_peer_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_oam_peer_index_check(unit, key, ioam_peer_idx);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oam_peer_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_g3p1_oam_peer_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_oam_peer_add_ext_sim(unit, ioam_peer_idx, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for oam_peer */
int soc_sbx_g3p1_oam_peer_get(int unit, int ioam_peer_idx, soc_sbx_g3p1_oam_peer_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_oam_peer_index_check(unit, key, ioam_peer_idx);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_oam_peer_get_ext_sim(unit, ioam_peer_idx,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(512));
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_peer_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for oam_peer
*/
int soc_sbx_g3p1_oam_peer_data_set(int unit, int ioam_peer_idx, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_peer_t entry;

    soc_sbx_g3p1_oam_peer_t_init(&entry);
    s = soc_sbx_g3p1_oam_peer_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_oam_peer_set(unit, ioam_peer_idx, &entry);

    return s;
}

/**
New entry get accessor implementation for oam_peer
*/
int soc_sbx_g3p1_oam_peer_data_get(int unit, int ioam_peer_idx, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_peer_t entry;

    soc_sbx_g3p1_oam_peer_t_init(&entry);
    s = soc_sbx_g3p1_oam_peer_get(unit, ioam_peer_idx, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_g3p1_oam_peer_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for labels3
 */

void soc_sbx_g3p1_labels3_t_init(
    soc_sbx_g3p1_labels3_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_labels3_t));
    e->hit = 1;
}

/* entry pack accessor implementation for labels3 */
static int soc_sbx_g3p1_labels3_pack(int unit,
    soc_sbx_g3p1_labels3_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->opcode; break;
          case 2: p = (uint8 *) &e->ftidx; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->hit; break;
          case 5: p = (uint8 *) &e->lock; break;
          case 6: p = (uint8 *) &e->keep_sdtag; break;
          case 7: p = (uint8 *) &e->pipe; break;
          case 8: p = (uint8 *) &e->elsp; break;
          case 9: p = (uint8 *) &e->stpstate; break;


          case 10: p = (uint8 *) &e->vpws; break;
          case 11: p = (uint8 *) &e->loop; break;
          case 12: p = (uint8 *) &e->cos; break;
          case 13: p = (uint8 *) &e->lpi; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for labels3 */
static int soc_sbx_g3p1_labels3_unpack(int unit,
                soc_sbx_g3p1_labels3_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {






          case 0: p = (uint8 *) &e->pad; break;
          case 1: p = (uint8 *) &e->opcode; break;
          case 2: p = (uint8 *) &e->ftidx; break;
          case 3: p = (uint8 *) &e->vlan; break;
          case 4: p = (uint8 *) &e->hit; break;
          case 5: p = (uint8 *) &e->lock; break;
          case 6: p = (uint8 *) &e->keep_sdtag; break;
          case 7: p = (uint8 *) &e->pipe; break;
          case 8: p = (uint8 *) &e->elsp; break;
          case 9: p = (uint8 *) &e->stpstate; break;


          case 10: p = (uint8 *) &e->vpws; break;
          case 11: p = (uint8 *) &e->loop; break;
          case 12: p = (uint8 *) &e->cos; break;
          case 13: p = (uint8 *) &e->lpi; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for labels3 */
static int soc_sbx_g3p1_labels3_index_check(int unit, uint32 *vindex, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ilabel3; break;
          case 1: p = (uint8 *) &ilabel2; break;
          case 2: p = (uint8 *) &ilabel1; break;
          case 3: p = (uint8 *) &iresv1; break;
          case 4: p = (uint8 *) &iport; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for labels3 */
static int soc_sbx_g3p1_labels3_index_unpack(int unit, int *vindex, int *nilabel3, int *nilabel2, int *nilabel1, int *niresv1, int *niport)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nilabel3; break;
          case 1: p = (uint8 *) nilabel2; break;
          case 2: p = (uint8 *) nilabel1; break;
          case 3: p = (uint8 *) niresv1; break;
          case 4: p = (uint8 *) niport; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for labels3 */
int soc_sbx_g3p1_labels3_entry_check(int unit,
                                 soc_sbx_g3p1_labels3_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pad; break;
          case 1: ev = e->opcode; break;
          case 2: ev = e->ftidx; break;
          case 3: ev = e->vlan; break;
          case 4: ev = e->hit; break;
          case 5: ev = e->lock; break;
          case 6: ev = e->keep_sdtag; break;
          case 7: ev = e->pipe; break;
          case 8: ev = e->elsp; break;
          case 9: ev = e->stpstate; break;
          case 10: ev = e->vpws; break;
          case 11: ev = e->loop; break;
          case 12: ev = e->cos; break;
          case 13: ev = e->lpi; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_set(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, soc_sbx_g3p1_labels3_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels3_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels3_update(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_labels3_add(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_add(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, soc_sbx_g3p1_labels3_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels3_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels3_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels3_add_ext_sim(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_get(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, soc_sbx_g3p1_labels3_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels3_get_ext_sim(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels3_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_hw_get(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, soc_sbx_g3p1_labels3_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels3_get_ext_sim(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels3_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_update(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, soc_sbx_g3p1_labels3_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_labels3_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_labels3_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels3_add_ext_sim(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_delete(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_labels3_delete_ext_sim(unit, ilabel3, ilabel2, ilabel1, iresv1, iport);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for labels3 */
int soc_sbx_g3p1_labels3_remove(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport)
{
    return soc_sbx_g3p1_labels3_delete(unit, ilabel3, ilabel2, ilabel1, iresv1, iport);
}

/* Get the first element of labels3 */
int soc_sbx_g3p1_labels3_first(int unit, int *nilabel3, int *nilabel2, int *nilabel1, int *niresv1, int *niport)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_labels3_index_unpack(unit, (int *)key, nilabel3, nilabel2, nilabel1, niresv1, niport);    
}

/* Get the next element of labels3 */
int soc_sbx_g3p1_labels3_next(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, int *nilabel3, int *nilabel2, int *nilabel1, int *niresv1, int *niport)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_labels3_index_check(unit, key, ilabel3, ilabel2, ilabel1, iresv1, iport);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_labels3_index_unpack(unit, (int *)next_key, nilabel3, nilabel2, nilabel1, niresv1, niport);  
}

/**
New entry set accessor implementation for labels3
*/
int soc_sbx_g3p1_labels3_data_set(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels3_t entry;

    soc_sbx_g3p1_labels3_t_init(&entry);
    s = soc_sbx_g3p1_labels3_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels3_set(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, &entry);

    return s;
}

/**
New entry add accessor implementation for labels3
*/
int soc_sbx_g3p1_labels3_data_add(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels3_t entry;

    soc_sbx_g3p1_labels3_t_init(&entry);
    s = soc_sbx_g3p1_labels3_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels3_add(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, &entry);

    return s;
}

/**
New entry get accessor implementation for labels3
*/
int soc_sbx_g3p1_labels3_data_get(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels3_t entry;

    soc_sbx_g3p1_labels3_t_init(&entry);
    s = soc_sbx_g3p1_labels3_get(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels3_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for labels3
*/
int soc_sbx_g3p1_labels3_data_update(int unit, int ilabel3, int ilabel2, int ilabel1, int iresv1, int iport, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_labels3_t entry;

    soc_sbx_g3p1_labels3_t_init(&entry);
    s = soc_sbx_g3p1_labels3_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_labels3_update(unit, ilabel3, ilabel2, ilabel1, iresv1, iport, &entry);

    return s;
}


/*
 * Entry accessor implementations for bfd_ld2e
 */

void soc_sbx_g3p1_bfd_ld2e_t_init(
    soc_sbx_g3p1_bfd_ld2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_bfd_ld2e_t));
    e->hit = 1;
}

/* entry pack accessor implementation for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_pack(int unit,
    soc_sbx_g3p1_bfd_ld2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->bubble_id; break;
          case 1: p = (uint8 *) &e->hit; break;
          case 2: p = (uint8 *) &e->c; break;
          case 3: p = (uint8 *) &e->a; break;
          case 4: p = (uint8 *) &e->d; break;
          case 5: p = (uint8 *) &e->m; break;
          case 6: p = (uint8 *) &e->detectMulti; break;
          case 7: p = (uint8 *) &e->length; break;
          case 8: p = (uint8 *) &e->desiredMinTxInterval; break;
          case 9: p = (uint8 *) &e->reqMinRxInterval; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_unpack(int unit,
                soc_sbx_g3p1_bfd_ld2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->bubble_id; break;
          case 1: p = (uint8 *) &e->hit; break;
          case 2: p = (uint8 *) &e->c; break;
          case 3: p = (uint8 *) &e->a; break;
          case 4: p = (uint8 *) &e->d; break;
          case 5: p = (uint8 *) &e->m; break;
          case 6: p = (uint8 *) &e->detectMulti; break;
          case 7: p = (uint8 *) &e->length; break;
          case 8: p = (uint8 *) &e->desiredMinTxInterval; break;
          case 9: p = (uint8 *) &e->reqMinRxInterval; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_index_check(int unit, uint32 *vindex, int ilocalDiscri )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ilocalDiscri; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_index_unpack(int unit, int *vindex, int *nilocalDiscri)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nilocalDiscri; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_entry_check(int unit,
                                 soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->bubble_id; break;
          case 1: ev = e->hit; break;
          case 2: ev = e->c; break;
          case 3: ev = e->a; break;
          case 4: ev = e->d; break;
          case 5: ev = e->m; break;
          case 6: ev = e->detectMulti; break;
          case 7: ev = e->length; break;
          case 8: ev = e->desiredMinTxInterval; break;
          case 9: ev = e->reqMinRxInterval; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_set(int unit, int ilocalDiscri, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_bfd_ld2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_bfd_ld2e_update(unit, ilocalDiscri, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g3p1_bfd_ld2e_add(unit, ilocalDiscri, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_add(int unit, int ilocalDiscri, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_bfd_ld2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_bfd_ld2e_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_bfd_ld2e_add_ext_sim(unit, ilocalDiscri, e);        
    }   
    
    rv = soc_sbx_g3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_get(int unit, int ilocalDiscri, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_bfd_ld2e_get_ext_sim(unit, ilocalDiscri, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_bfd_ld2e_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_hw_get(int unit, int ilocalDiscri, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_bfd_ld2e_get_ext_sim(unit, ilocalDiscri, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_g3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_bfd_ld2e_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_update(int unit, int ilocalDiscri, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_bfd_ld2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_bfd_ld2e_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_bfd_ld2e_add_ext_sim(unit, ilocalDiscri, e);
    }
        
    rv = soc_sbx_g3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_delete(int unit, int ilocalDiscri)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_g3p1_bfd_ld2e_delete_ext_sim(unit, ilocalDiscri);
    }
        
    rv = soc_sbx_g3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_remove(int unit, int ilocalDiscri)
{
    return soc_sbx_g3p1_bfd_ld2e_delete(unit, ilocalDiscri);
}

/* Get the first element of bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_first(int unit, int *nilocalDiscri)
{
    int rv;
    uint32 key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_g3p1_bfd_ld2e_index_unpack(unit, (int *)key, nilocalDiscri);    
}

/* Get the next element of bfd_ld2e */
int soc_sbx_g3p1_bfd_ld2e_next(int unit, int ilocalDiscri, int *nilocalDiscri)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_g3p1_bfd_ld2e_index_check(unit, key, ilocalDiscri);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_g3p1_bfd_ld2e_index_unpack(unit, (int *)next_key, nilocalDiscri);  
}

/**
New entry set accessor implementation for bfd_ld2e
*/
int soc_sbx_g3p1_bfd_ld2e_data_set(int unit, int ilocalDiscri, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2e_t entry;

    soc_sbx_g3p1_bfd_ld2e_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2e_set(unit, ilocalDiscri, &entry);

    return s;
}

/**
New entry add accessor implementation for bfd_ld2e
*/
int soc_sbx_g3p1_bfd_ld2e_data_add(int unit, int ilocalDiscri, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2e_t entry;

    soc_sbx_g3p1_bfd_ld2e_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2e_add(unit, ilocalDiscri, &entry);

    return s;
}

/**
New entry get accessor implementation for bfd_ld2e
*/
int soc_sbx_g3p1_bfd_ld2e_data_get(int unit, int ilocalDiscri, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2e_t entry;

    soc_sbx_g3p1_bfd_ld2e_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2e_get(unit, ilocalDiscri, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2e_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for bfd_ld2e
*/
int soc_sbx_g3p1_bfd_ld2e_data_update(int unit, int ilocalDiscri, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2e_t entry;

    soc_sbx_g3p1_bfd_ld2e_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2e_update(unit, ilocalDiscri, &entry);

    return s;
}


/*
 * Entry accessor implementations for sample_dm1
 */

void soc_sbx_g3p1_sample_dm1_t_init(
    soc_sbx_g3p1_sample_dm1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_sample_dm1_t));
}

/* entry pack accessor implementation for sample_dm1 */
static int soc_sbx_g3p1_sample_dm1_pack(int unit,
    soc_sbx_g3p1_sample_dm1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->w0; break;
          case 1: p = (uint8 *) &e->w1; break;
          case 2: p = (uint8 *) &e->w2; break;
          case 3: p = (uint8 *) &e->w3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sample_dm1 */
static int soc_sbx_g3p1_sample_dm1_unpack(int unit,
                soc_sbx_g3p1_sample_dm1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->w0; break;
        case 1: p = (uint8 *) &e->w1; break;
        case 2: p = (uint8 *) &e->w2; break;
        case 3: p = (uint8 *) &e->w3; break;
               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_index_check(int unit, uint32 *vindex, int iindex_1, int iindex_2 )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iindex_1; break;
          case 1: p = (uint8 *) &iindex_2; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_entry_check(int unit,
                                 soc_sbx_g3p1_sample_dm1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->w0; break;
          case 1: ev = e->w1; break;
          case 2: ev = e->w2; break;
          case 3: ev = e->w3; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_set(int unit, int iindex_1, int iindex_2, soc_sbx_g3p1_sample_dm1_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_g3p1_sample_dm1_index_check(unit, key, iindex_1, iindex_2);
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_sample_dm1_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_g3p1_sample_dm1_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_g3p1_sample_dm1_add_ext_sim(unit, iindex_1, iindex_2, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for sample_dm1 */
int soc_sbx_g3p1_sample_dm1_get(int unit, int iindex_1, int iindex_2, soc_sbx_g3p1_sample_dm1_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_g3p1_sample_dm1_index_check(unit, key, iindex_1, iindex_2);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_g3p1_sample_dm1_get_ext_sim(unit, iindex_1, iindex_2,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(119));
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_sample_dm1_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for sample_dm1
*/
int soc_sbx_g3p1_sample_dm1_data_set(int unit, int iindex_1, int iindex_2, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample_dm1_t entry;

    soc_sbx_g3p1_sample_dm1_t_init(&entry);
    s = soc_sbx_g3p1_sample_dm1_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_sample_dm1_set(unit, iindex_1, iindex_2, &entry);

    return s;
}

/**
New entry get accessor implementation for sample_dm1
*/
int soc_sbx_g3p1_sample_dm1_data_get(int unit, int iindex_1, int iindex_2, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample_dm1_t entry;

    soc_sbx_g3p1_sample_dm1_t_init(&entry);
    s = soc_sbx_g3p1_sample_dm1_get(unit, iindex_1, iindex_2, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_g3p1_sample_dm1_pack(unit, &entry, buf, size*8);

    return s;
}

static int create_table_mac(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 1048576;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 4194304;
    hash_param.num_chain_table_entries = 262144;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate MAC table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name ="mac";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].table = SOC_SBX_G3P1_TMU_MAC_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_mac_pack;
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_mac_t);
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nfields = 12;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_MAC_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }





    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[0].name = "ageid";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[1].name = "smac_hit";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[2].name = "sdrop";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[3].name = "dontage";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[4].name = "sreserved";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[5].name = "pending";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[6].name = "poe";

    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[7].name = "dmac_hit";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[8].name = "dcopy";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[9].name = "ddrop";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[10].name = "dreserved";
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[11].name = "ftidx";
        
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_MAC_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[0].name = "mac"; 
    tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[1].name = "vsi"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_pvv2e(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 8192;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate PVV2E table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name ="pvv2e";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].table = SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_pvv2e_pack;
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_pvv2e_t);
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nindexes = 3;
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nfields = 9;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[0].name = "pad";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[1].name = "vpws";


    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[2].name = "stpstate";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[3].name = "vlan";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[4].name = "lpi";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[5].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[6].name = "keeporstrip";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[7].name = "replace";
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[8].name = "vid";

        
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[0].name = "ivid"; 
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[1].name = "ovid"; 
    tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[2].name = "port"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_labels(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 16384;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate LABELS table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name ="labels";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].table = SOC_SBX_G3P1_TMU_LABELS_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_labels_pack;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_labels_t);
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nindexes = 4;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nfields = 14;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_LABELS_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[0].name = "pad";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[1].name = "opcode";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[2].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[3].name = "vlan";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[4].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[5].name = "lock";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[6].name = "keep_sdtag";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[7].name = "pipe";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[8].name = "elsp";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[9].name = "stpstate";


    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[10].name = "vpws";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[11].name = "loop";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[12].name = "cos";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[13].name = "lpi";
        
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_LABELS_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[0].name = "label2"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[1].name = "resv"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[2].name = "port"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[3].name = "label1"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_v4da(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {

    taps_init_params_t init_params;
    int i, j, rv;
    unsigned int defentry[_TAPS_PAYLOAD_WORDS_];
    soc_sbx_g3p1_tmu_table_desc_t* table_desc;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID]);

    sal_memset(&init_params, 0, sizeof(taps_init_params_t));
    init_params.instance = 0;
    init_params.divide_ratio = 5;
    init_params.host_share_table = 0;
    init_params.key_attr.type = 0;
    init_params.key_attr.length = 48;
    init_params.key_attr.vrf_length = 16;

    init_params.tcam_layout = 0;

    init_params.sbucket_attr.format = SOC_SBX_TMU_TAPS_BB_FORMAT_3ENTRIES;
    init_params.dbucket_attr.num_dbucket_pfx = 21; 
    for (i=0; i < TAPS_DDR_TABLE_MAX; i++) {
        init_params.dbucket_attr.flags[i] = 0;
        init_params.dbucket_attr.table_id[i] = 0;
    }

    init_params.mode = 2;
    init_params.max_capacity_limit = 500000; 

    for (i=0; i<_TAPS_PAYLOAD_WORDS_; i++) 
        defentry[i] = 0;
    init_params.defpayload = &defentry[0];

    rv = taps_create(unit, &init_params, &(table_desc->taps));
    if (SOC_FAILURE(rv)) {
        soc_sbx_g3p1_tmu_uninit(unit);
        return rv;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].type = SOC_SBX_G3P1_TMU_TAPS_TABLE_TYPE;
            
                    
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name ="v4da";
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].table = SOC_SBX_G3P1_TMU_V4DA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v4da_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v4da_t);
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nindexes = 2 + 1;
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nfields = 3;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V4DA_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }







    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[0].name = "vid";
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[1].name = "ecmpmask";
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[2].name = "ftidx";
          
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V4DA_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[0].name = "vrf"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[1].name = "da"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[2].name = "netmask"; 
        
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].nindexes - 1; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID].indexes[j].range = 256;
         
    return SOC_E_NONE;
}
static int create_table_v4sa(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {

    taps_init_params_t init_params;
    int i, j, rv;
    unsigned int defentry[_TAPS_PAYLOAD_WORDS_];
    soc_sbx_g3p1_tmu_table_desc_t* table_desc;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID]);

    sal_memset(&init_params, 0, sizeof(taps_init_params_t));
    init_params.instance = 1;
    init_params.divide_ratio = 5;
    init_params.host_share_table = 0;
    init_params.key_attr.type = 0;
    init_params.key_attr.length = 48;
    init_params.key_attr.vrf_length = 16;

    init_params.tcam_layout = 0;

    init_params.sbucket_attr.format = SOC_SBX_TMU_TAPS_BB_FORMAT_3ENTRIES;
    init_params.dbucket_attr.num_dbucket_pfx = 21; 
    for (i=0; i < TAPS_DDR_TABLE_MAX; i++) {
        init_params.dbucket_attr.flags[i] = 0;
        init_params.dbucket_attr.table_id[i] = 0;
    }

    init_params.mode = 2;
    init_params.max_capacity_limit = 500000; 

    for (i=0; i<_TAPS_PAYLOAD_WORDS_; i++) 
        defentry[i] = 0;
    init_params.defpayload = &defentry[0];

    rv = taps_create(unit, &init_params, &(table_desc->taps));
    if (SOC_FAILURE(rv)) {
        soc_sbx_g3p1_tmu_uninit(unit);
        return rv;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].type = SOC_SBX_G3P1_TMU_TAPS_TABLE_TYPE;
            
                    
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name ="v4sa";
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].table = SOC_SBX_G3P1_TMU_V4SA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v4sa_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v4sa_t);
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nindexes = 2 + 1;
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V4SA_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }







    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[0].name = "pad";
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[1].name = "srccnt";
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[2].name = "srcdrop";
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[3].name = "rpfmode";
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[4].name = "poe";
          
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V4SA_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[0].name = "vrf"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[1].name = "sa"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[2].name = "netmask"; 
        
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].nindexes - 1; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID].indexes[j].range = 256;
         
    return SOC_E_NONE;
}
static int create_table_v4mc_sgv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_176_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate V4MC_SGV table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name ="v4mc_sgv";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].table = SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v4mc_sgv_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v4mc_sgv_t);
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nindexes = 3;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[0].name = "rpfunion";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[1].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[2].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[3].name = "rsvd";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[4].name = "proccopy";
        
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[0].name = "vsi"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[1].name = "sa"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[2].name = "ga"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_v4mc_gv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate V4MC_GV table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name ="v4mc_gv";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].table = SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v4mc_gv_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v4mc_gv_t);
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[0].name = "rpfunion";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[1].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[2].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[3].name = "rsvd";
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[4].name = "proccopy";
        
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[0].name = "vsi"; 
    tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[1].name = "ga"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_v6da(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {

    taps_init_params_t init_params;
    int i, j, rv;
    unsigned int defentry[_TAPS_PAYLOAD_WORDS_];
    soc_sbx_g3p1_tmu_table_desc_t* table_desc;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID]);

    sal_memset(&init_params, 0, sizeof(taps_init_params_t));
    init_params.instance = 0;
    init_params.divide_ratio = 5;
    init_params.host_share_table = 0;
    init_params.key_attr.type = 1;
    init_params.key_attr.length = 144;
    init_params.key_attr.vrf_length = 16;

    init_params.tcam_layout = 2;

    init_params.sbucket_attr.format = SOC_SBX_TMU_TAPS_BB_FORMAT_3ENTRIES;
    init_params.dbucket_attr.num_dbucket_pfx = 15; 
    for (i=0; i < TAPS_DDR_TABLE_MAX; i++) {
        init_params.dbucket_attr.flags[i] = 0;
        init_params.dbucket_attr.table_id[i] = 0;
    }

    init_params.mode = 2;
    init_params.max_capacity_limit = 100000; 

    for (i=0; i<_TAPS_PAYLOAD_WORDS_; i++) 
        defentry[i] = 0;
    init_params.defpayload = &defentry[0];

    rv = taps_create(unit, &init_params, &(table_desc->taps));
    if (SOC_FAILURE(rv)) {
        soc_sbx_g3p1_tmu_uninit(unit);
        return rv;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].type = SOC_SBX_G3P1_TMU_TAPS_TABLE_TYPE;
            
                    
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name ="v6da";
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].table = SOC_SBX_G3P1_TMU_V6DA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v6da_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v6da_t);
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nindexes = 5 + 1;
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nfields = 3;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V6DA_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }







    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[0].name = "vid";
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[1].name = "ecmpmask";
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[2].name = "ftidx";
          
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V6DA_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[0].name = "vrf"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[1].name = "da0"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[2].name = "da1"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[3].name = "da2"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[4].name = "da3"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[5].name = "netmask"; 
        
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].nindexes - 1; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID].indexes[j].range = 256;
         
    return SOC_E_NONE;
}
static int create_table_v6sa(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {

    taps_init_params_t init_params;
    int i, j, rv;
    unsigned int defentry[_TAPS_PAYLOAD_WORDS_];
    soc_sbx_g3p1_tmu_table_desc_t* table_desc;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    table_desc = &(tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID]);

    sal_memset(&init_params, 0, sizeof(taps_init_params_t));
    init_params.instance = 1;
    init_params.divide_ratio = 5;
    init_params.host_share_table = 0;
    init_params.key_attr.type = 1;
    init_params.key_attr.length = 144;
    init_params.key_attr.vrf_length = 16;

    init_params.tcam_layout = 2;

    init_params.sbucket_attr.format = SOC_SBX_TMU_TAPS_BB_FORMAT_3ENTRIES;
    init_params.dbucket_attr.num_dbucket_pfx = 15; 
    for (i=0; i < TAPS_DDR_TABLE_MAX; i++) {
        init_params.dbucket_attr.flags[i] = 0;
        init_params.dbucket_attr.table_id[i] = 0;
    }

    init_params.mode = 2;
    init_params.max_capacity_limit = 100000; 

    for (i=0; i<_TAPS_PAYLOAD_WORDS_; i++) 
        defentry[i] = 0;
    init_params.defpayload = &defentry[0];

    rv = taps_create(unit, &init_params, &(table_desc->taps));
    if (SOC_FAILURE(rv)) {
        soc_sbx_g3p1_tmu_uninit(unit);
        return rv;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].type = SOC_SBX_G3P1_TMU_TAPS_TABLE_TYPE;
            
                    
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name ="v6sa";
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].table = SOC_SBX_G3P1_TMU_V6SA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v6sa_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v6sa_t);
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nindexes = 5 + 1;
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V6SA_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }







    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[0].name = "pad";
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[1].name = "srccnt";
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[2].name = "srcdrop";
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[3].name = "rpfmode";
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[4].name = "poe";
          
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V6SA_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[0].name = "vrf"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[1].name = "sa0"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[2].name = "sa1"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[3].name = "sa2"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[4].name = "sa3"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[5].name = "netmask"; 
        
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].nindexes - 1; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID].indexes[j].range = 256;
         
    return SOC_E_NONE;
}
static int create_table_v6mc_gv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_176_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate V6MC_GV table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name ="v6mc_gv";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].table = SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v6mc_gv_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v6mc_gv_t);
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nindexes = 5;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[0].name = "rpfunion";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[1].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[2].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[3].name = "rsvd";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[4].name = "proccopy";
        
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[0].name = "vsi"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[1].name = "ga0"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[2].name = "ga1"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[3].name = "ga2"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[4].name = "ga3"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_v6mc_sgv(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_304_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate V6MC_SGV table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name ="v6mc_sgv";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].table = SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v6mc_sgv_pack;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_v6mc_sgv_t);
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nindexes = 9;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nfields = 5;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[0].name = "rpfunion";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[1].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[2].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[3].name = "rsvd";
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[4].name = "proccopy";
        
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[0].name = "vsi"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[1].name = "sa0"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[2].name = "sa1"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[3].name = "sa2"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[4].name = "sa3"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[5].name = "ga0"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[6].name = "ga1"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[7].name = "ga2"; 
    tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[8].name = "ga3"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_oamrx(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 16384;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate OAMRX table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name ="oamrx";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].table = SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oamrx_pack;
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_oamrx_t);
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nindexes = 5;
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nfields = 34;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }




    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[0].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[1].name = "svc_hdl";


    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[2].name = "mdlvl_7_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[3].name = "mdlvl_7_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[4].name = "mdlvl_7_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[5].name = "mdlvl_7_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[6].name = "mdlvl_6_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[7].name = "mdlvl_6_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[8].name = "mdlvl_6_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[9].name = "mdlvl_6_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[10].name = "mdlvl_5_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[11].name = "mdlvl_5_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[12].name = "mdlvl_5_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[13].name = "mdlvl_5_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[14].name = "mdlvl_4_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[15].name = "mdlvl_4_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[16].name = "mdlvl_4_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[17].name = "mdlvl_4_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[18].name = "mdlvl_3_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[19].name = "mdlvl_3_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[20].name = "mdlvl_3_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[21].name = "mdlvl_3_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[22].name = "mdlvl_2_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[23].name = "mdlvl_2_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[24].name = "mdlvl_2_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[25].name = "mdlvl_2_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[26].name = "mdlvl_1_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[27].name = "mdlvl_1_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[28].name = "mdlvl_1_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[29].name = "mdlvl_1_m";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[30].name = "mdlvl_0_f";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[31].name = "mdlvl_0_d";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[32].name = "mdlvl_0_p";
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[33].name = "mdlvl_0_m";
        
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[0].name = "ivid"; 
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[1].name = "ovid"; 
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[2].name = "dir"; 
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[3].name = "port"; 
    tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[4].name = "vid_mode"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_maidmep(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 16384;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate MAIDMEP table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name ="maidmep";
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].table = SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_maidmep_pack;
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_maidmep_t);
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nindexes = 4;
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nfields = 2;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }




    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[0].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[1].name = "peer_idx";



        
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[0].name = "svc_hdl"; 
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[1].name = "mepid"; 
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[2].name = "msg_type"; 
    tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[3].name = "mdlvl"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_emlfilter(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate EMLFILTER table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name ="emlfilter";
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].table = SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_emlfilter_pack;
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_emlfilter_t);
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nfields = 4;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }




    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[0].name = "reserved_0";
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[1].name = "reserved_1";
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[2].name = "reserved_2";
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[3].name = "reserved_3";
        
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[0].name = "emlindex"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_ete(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int num_entries = 2097152;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (501 + 31)/32;

    /* int segment_num; */

    if (501 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (501 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (501 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (501 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate ETE table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_g3p1_ete_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol ete_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name = "ete";
    tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].type = SOC_SBX_G3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name ="ete";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].table = SOC_SBX_G3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_ete_pack;
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_ete_t);
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nfields = 64;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_ETE_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[0].name = "dmacset";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[1].name = "dmacsetlsb";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[2].name = "dscpremark";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[3].name = "remark";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[4].name = "mplsttldec";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[5].name = "encaplen";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[6].name = "encapmac";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[7].name = "nostrip";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[8].name = "noclass";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[9].name = "etepid";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[10].name = "tunnelenter";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[11].name = "exp0remark";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[12].name = "exp1remark";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[13].name = "exp2remark";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[14].name = "ttl0dec";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[15].name = "ttl1dec";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[16].name = "ttl2dec";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[17].name = "smacset";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[18].name = "nosplitcheck";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[19].name = "ttlcheck";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[20].name = "ipttldec";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[21].name = "add_pwcw";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[22].name = "comp_encaplen";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[23].name = "etype2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[24].name = "ttl2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[25].name = "s2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[26].name = "exp2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[27].name = "label2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[28].name = "encap_vid";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[29].name = "pricfi";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[30].name = "etype";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[31].name = "tpid";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[32].name = "pid";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[33].name = "dmac5";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[34].name = "dmac4";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[35].name = "dmac3";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[36].name = "dmac2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[37].name = "dmac1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[38].name = "dmac0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[39].name = "vlan";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[40].name = "defpricfi";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[41].name = "usetag";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[42].name = "l2_reserved";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[43].name = "dropuntagged";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[44].name = "droptagged";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[45].name = "smacindex";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[46].name = "stpcheck";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[47].name = "vid";




    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[48].name = "ttl0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[49].name = "s0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[50].name = "exp0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[51].name = "label0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[52].name = "ttl1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[53].name = "s1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[54].name = "exp1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[55].name = "label1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[56].name = "smac5";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[57].name = "smac4";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[58].name = "smac3";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[59].name = "smac2";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[60].name = "smac1";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[61].name = "smac0";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[62].name = "mtu";
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[63].name = "usevid";






    
        
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_ETE_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[0].name = "etei"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_g3p1_ete_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set ETE size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}
static int create_table_oam_ep(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int num_entries = 65536;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (512 + 31)/32;

    /* int segment_num; */

    if (512 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate OAM_EP table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_g3p1_oam_ep_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol oam_ep_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name = "oam_ep";
    tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].type = SOC_SBX_G3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name ="oam_ep";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].table = SOC_SBX_G3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oam_ep_pack;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_oam_ep_t);
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nfields = 31;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[0].name = "smac1";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[1].name = "smac0";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[2].name = "dmac5";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[3].name = "dmac4";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[4].name = "dmac3";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[5].name = "dmac2";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[6].name = "dmac1";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[7].name = "dmac0";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[8].name = "smac5";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[9].name = "smac4";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[10].name = "smac3";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[11].name = "smac2";

    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[12].name = "vid";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[13].name = "num_vlan_tags";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[14].name = "dir";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[15].name = "reqMinEchoRxInterval";

    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[16].name = "localDiscr";









    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[17].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[18].name = "dport";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[19].name = "dqueue";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[20].name = "tlv_offset";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[21].name = "period";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[22].name = "flags_rsvd";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[23].name = "rdi";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[24].name = "opcode";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[25].name = "version";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[26].name = "mdlvl";

    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[27].name = "mepid";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[28].name = "func";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[29].name = "type";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[30].name = "unused";


    
        
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[0].name = "oam_epi"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_g3p1_oam_ep_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set OAM_EP size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}
static int create_table_oam_local(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int num_entries = 65536;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (512 + 31)/32;

    /* int segment_num; */

    if (512 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate OAM_LOCAL table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_g3p1_oam_local_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol oam_local_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name = "oam_local";
    tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].type = SOC_SBX_G3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name ="oam_local";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].table = SOC_SBX_G3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oam_local_pack;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_oam_local_t);
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nfields = 13;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[0].name = "maid_w1";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[1].name = "maid_w0";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[2].name = "maid_w3";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[3].name = "maid_w2";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[4].name = "maid_w5";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[5].name = "maid_w4";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[6].name = "unused_w6";




    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[7].name = "maid_w7";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[8].name = "maid_w6";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[9].name = "maid_w9";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[10].name = "maid_w8";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[11].name = "maid_w11";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[12].name = "maid_w10";




    
        
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[0].name = "oam_locali"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_g3p1_oam_local_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set OAM_LOCAL size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}
static int create_table_oam_peer(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int num_entries = 65536;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (512 + 31)/32;

    /* int segment_num; */

    if (512 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (512 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate OAM_PEER table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_g3p1_oam_peer_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol oam_peer_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name = "oam_peer";
    tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].type = SOC_SBX_G3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name ="oam_peer";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].table = SOC_SBX_G3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oam_peer_pack;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_oam_peer_t);
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nfields = 25;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[0].name = "maid_crc";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[1].name = "pol_id_wdg";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[2].name = "fwd_to_host";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[3].name = "period";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[4].name = "pad1";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[5].name = "w2";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[6].name = "w3";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[7].name = "w4";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[8].name = "w5";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[9].name = "w6";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[10].name = "w7";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[11].name = "e_w7";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[12].name = "code_w7";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[13].name = "reserved_w7";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[14].name = "w8";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[15].name = "w9";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[16].name = "w10";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[17].name = "w11";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[18].name = "w12";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[19].name = "w13";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[20].name = "w14";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[21].name = "w15";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[22].name = "e_w15";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[23].name = "code_w15";
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[24].name = "reserved_w15";    
        
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[0].name = "oam_peer_idx"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_g3p1_oam_peer_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set OAM_PEER size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}
static int create_table_labels3(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_176_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 16384;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate LABELS3 table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name ="labels3";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].table = SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_labels3_pack;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_labels3_t);
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nindexes = 5;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nfields = 14;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }






    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[0].name = "pad";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[1].name = "opcode";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[2].name = "ftidx";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[3].name = "vlan";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[4].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[5].name = "lock";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[6].name = "keep_sdtag";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[7].name = "pipe";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[8].name = "elsp";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[9].name = "stpstate";


    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[10].name = "vpws";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[11].name = "loop";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[12].name = "cos";
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[13].name = "lpi";
        
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[0].name = "label3"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[1].name = "label2"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[2].name = "label1"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[3].name = "resv1"; 
    tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[4].name = "port"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_bfd_ld2e(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 65536;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 262144;
    hash_param.num_chain_table_entries = 16384;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate BFD_LD2E table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].type = SOC_SBX_G3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name ="bfd_ld2e";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].table = SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_bfd_ld2e_pack;
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_bfd_ld2e_t);
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nfields = 10;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }





    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[0].name = "bubble_id";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[1].name = "hit";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[2].name = "c";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[3].name = "a";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[4].name = "d";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[5].name = "m";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[6].name = "detectMulti";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[7].name = "length";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[8].name = "desiredMinTxInterval";
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[9].name = "reqMinRxInterval";
        
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[0].name = "localDiscri"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_sample_dm1(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_g3p1_sym[128];
    char *e = "";
    int num_entries = 1024;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (119 + 31)/32;

    /* int segment_num; */

    if (119 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate SAMPLE_DM1 table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_g3p1_sample_dm1_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol sample_dm1_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name = "sample_dm1";
    tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].type = SOC_SBX_G3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name ="sample_dm1";
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].table = SOC_SBX_G3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_sample_dm1_pack;
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].esize =
        sizeof(soc_sbx_g3p1_sample_dm1_t);
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields = 4;
    
    if (tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_g3p1_field_desc_t)
                    * tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields,
                        "SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[0].name = "w0";
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[1].name = "w1";
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[2].name = "w2";
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[3].name = "w3";    
        
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_g3p1_ucode_get(unit,
                soc_sbx_g3p1_sym,
                128,
                &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t)
                   * tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes,
                    "SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[0].name = "index_1"; 
    tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[1].name = "index_2"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_g3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_g3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_g3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_g3p1_sample_dm1_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set SAMPLE_DM1 size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}


static void create_tmu_programs(int unit, soc_sbx_g3p1_tmu_table_manager_t *tm) {   
     create_program_mac(unit, tm);
     create_program_pvv2e(unit, tm);
     create_program_labels(unit, tm);
     create_program_v4lpm(unit, tm);
     create_program_v4mc(unit, tm);
     create_program_v4mc_gv(unit, tm);
     create_program_v6lpm(unit, tm);
     create_program_v6mc(unit, tm);
     create_program_v6mc_gv(unit, tm);
     create_program_lpm_mac(unit, tm);
     create_program_egr_smac(unit, tm);
     create_program_oamrx(unit, tm);
     create_program_maidmep(unit, tm);
     create_program_emlfilter(unit, tm);
     create_program_labels3(unit, tm);
     create_program_bfd_ld2e(unit, tm);
}

/*
 * TMU Table Manager initializer
 */
int soc_sbx_g3p1_tmu_init(int unit)
{
    soc_sbx_g3p1_tmu_table_manager_t *tm;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    uint32 v;

    if (!fe) {
        return SOC_E_INIT;
    }

    if (fe->tmu_mgr) {
        /* Free old info */
        soc_sbx_g3p1_tmu_uninit(unit);
    }

    tm = sal_alloc(sizeof(soc_sbx_g3p1_tmu_table_manager_t), "tmu_tbl_mgr");
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_g3p1_tmu_table_manager_t));
    fe->tmu_mgr = tm;

    tm->tables = sal_alloc(sizeof(soc_sbx_g3p1_tmu_table_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID,
                           "tmu_mgr_tables");
    sal_memset(tm->tables, 0, sizeof(soc_sbx_g3p1_tmu_table_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID);       

    tm->indexes =  sal_alloc(sizeof(soc_sbx_g3p1_index_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID,
                           "tmu_mgr_idx");
    sal_memset(tm->indexes, 0, sizeof(soc_sbx_g3p1_index_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID);

    tm->entries =  sal_alloc(sizeof(soc_sbx_g3p1_entry_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID,
                             "tmu_mgr_entries");
    sal_memset(tm->entries, 0, sizeof(soc_sbx_g3p1_entry_desc_t) * SOC_SBX_G3P1_TMU_MAX_TABLE_ID);

    tm->prog_info =  sal_alloc(sizeof(soc_sbx_caladan3_tmu_program_info_t) * SOC_SBX_G3P1_TMU_MAX_PROG_ID,
                             "tmu_prog_info");
    sal_memset(tm->prog_info, 0, sizeof(soc_sbx_caladan3_tmu_program_info_t) * SOC_SBX_G3P1_TMU_MAX_PROG_ID);

    v = 0x1;
    tm->behost = !*((uint8 *) &v);   
    
         SOC_IF_ERROR_RETURN(create_table_mac(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_pvv2e(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_labels(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v4da(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v4sa(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v4mc_sgv(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v4mc_gv(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v6da(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v6sa(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v6mc_gv(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_v6mc_sgv(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_oamrx(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_maidmep(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_emlfilter(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_ete(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_oam_ep(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_oam_local(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_oam_peer(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_labels3(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_bfd_ld2e(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_sample_dm1(unit, tm));     

    create_tmu_programs(unit, tm);
    
    return SOC_E_NONE;
}

/* Uninitialization function implementation */
int soc_sbx_g3p1_tmu_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm;

    if (!fe->tmu_mgr) return s;
    tm = fe->tmu_mgr;
    
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_G3P1_TMU_MAX_TABLE_ID; i++) {
            if (tm->entries[i].fields) {
                sal_free(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                sal_free(tm->entries[i].indexes);
            }
        }
        sal_free(tm->entries);
    }
    
    if (tm->tables) {
        sal_free(tm->tables);
    }
   
    if (tm->prog_info) {
        sal_free(tm->prog_info);
    }
    
    sal_free(tm);
    fe->tmu_mgr = NULL;

    return s;
}



#endif
