
/*
 * $Id: tmu_c.stg,v 1.85 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * t3p1_tmu.c: Guadalupe2k V1.3 TMU table manager & wrappers
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from sdk/caladan_ucode/t3p1/src/t3p1_tmu_cfg.lrp.
 * Edits to this file will be lost when it is regenerated.
 *
 */

#include <shared/bsl.h>

#include <soc/types.h>
#include <soc/drv.h>
#include <soc/mem.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT) 
#include <soc/sbx/t3p1/t3p1_int.h>
#include <soc/sbx/t3p1/t3p1_tmu.h>
#include <soc/sbx/t3p1/t3p1_tmu_sim.h>
#include <sal/core/boot.h>
#include <soc/sbx/caladan3/tmu/hash.h>
#include <soc/sbx/caladan3/tmu/dm.h>
#include <soc/sbx/caladan3/tmu/taps/taps.h>

extern int soc_sbx_t3p1_hash_add_ext(int unit, 
                                    soc_sbx_tmu_hash_handle_t handle,
                                    uint32 *key, uint32 *value);
extern int soc_sbx_t3p1_hash_update_ext(int unit,
                                        soc_sbx_tmu_hash_handle_t handle, 
                                        uint32 *key, uint32 *value);
extern int soc_sbx_t3p1_hash_delete_ext(int unit,
                                        soc_sbx_tmu_hash_handle_t handle,
                                        uint32 *key);
extern int soc_sbx_t3p1_hash_get_ext(int unit, 
                                     soc_sbx_tmu_hash_handle_t handle, 
                                     uint32 *key, uint32 *value);

extern int soc_sbx_t3p1_hash_hw_get_ext(int unit, 
                                     soc_sbx_tmu_hash_handle_t handle, 
                                     uint32 *key, uint32 *value);                                           
                                                                               
/*
 * Utility functions for LPM table key packing
 *
 */

/* Bits are numbered left to right in the array.
 *      - Bit 0 is the most significant bit of key_array[0]
 *      - Bit 2 is the 5th bit in key_array[0]
 *      - Bit 8 is the most significant bit of key_array[1]
 */
static uint8 lpm_key_get_bit(uint8* key_array, int array_size, int bit_num) {
    int byte_index;
    int shift_by;
    
    byte_index = bit_num/8;
    if (byte_index >= array_size)
        return 0;
    
    shift_by = 7 - (bit_num % 8);    
    return (key_array[byte_index] >> shift_by) & 1;
}

static void lpm_key_insert_bit(uint8* key_array, int array_size, int bit_num, int bit_value) {
    int byte_index;
    int shift_by;
    int bit;
    
    byte_index = bit_num/8;
    if (byte_index >= array_size)
        return;
    
    bit = bit_value & 1;
    shift_by = 7 - (bit_num % 8); 
    bit = bit << shift_by;
       
    key_array[byte_index] |= bit;
}    
    
       
static void shift_right(uint8* key_array, int array_size_bytes, int num_bits) {
    uint8 key[32];
    int i;
    int target_bit_pos;
    int curr_bit_pos;
    int bit;
    
    for (i=0; i<32; i++)
        key[i] = 0;
    
    target_bit_pos = (array_size_bytes * 8) - 1;
    curr_bit_pos = target_bit_pos - num_bits;
    while (curr_bit_pos >= 0) {
        bit = lpm_key_get_bit(key_array, array_size_bytes, curr_bit_pos);
        lpm_key_insert_bit(key, array_size_bytes, target_bit_pos, bit);
        
        curr_bit_pos--;
        target_bit_pos--;
    }  
    
    for (i=0; i<array_size_bytes; i++)
        key_array[i] = key[i];       
}
                                             
static int align_right(int key) {    
    char *ptr = (char *)&key;
    int a, b, c, d;
    int v = 0x1;            
    int behost = !*((uint8 *) &v);
    if (behost)       
        return key;
    
    a = ptr[0];
    b = ptr[1];
    c = ptr[2];
    d = ptr[3];
    
    return ((d << 24) | (c << 16) | (b << 8) | (a));
}    
                


static void create_program_mac(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_T3P1_TMU_MAC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 8; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 6;
      prog_info->key_info[0].shift[1] = 6; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 2;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 2; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 6;
      prog_info->key_info[1].shift[1] = 6; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 2;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = TRUE;
      prog_info->key_shift[1] = 2; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 0;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 0, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_age2mac(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_T3P1_TMU_AGE2MAC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 4;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 4;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 4;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 4;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 1;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 8, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_pvv2e(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {   
     
      soc_sbx_t3p1_tmu_table_desc_t* table_desc;      
      soc_sbx_caladan3_tmu_program_info_t *prog_info;
      unsigned int update = 0;
      
      prog_info = &tm->prog_info[SOC_SBX_T3P1_TMU_PVV2E_PROG_ID];         
     
              
      table_desc = &(tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID]);
       
      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV4_SUB_KEY;
      prog_info->key_info[0].shift[0] = 4; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 2;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 4;      
      prog_info->key_info[0].taps_seg = table_desc->taps->segment;
      prog_info->key_info[0].valid = TRUE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[0].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[0].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[0] = 4;                         
     
              
      table_desc = &(tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID]);
       
      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_TAPS_IPV4_SUB_KEY;
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 4;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].taps_seg = table_desc->taps->segment;
      prog_info->key_info[1].valid = FALSE;
      if (table_desc->taps->param.mode == TAPS_ONCHIP_ALL) {
          prog_info->key_info[1].tableid = 0;
      } else if (table_desc->taps->param.mode == TAPS_ONCHIP_SEARCH_OFFCHIP_ADS) {
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PAYLOAD_TABLE];
      } else { 
          prog_info->key_info[1].tableid = table_desc->taps->param.dbucket_attr.table_id[TAPS_DDR_PREFIX_TABLE];
      }

      prog_info->key_shift[1] = 0; 
     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 2;
     
      soc_sbx_lrp_setup_tmu_program(unit, 1, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);
}  
static void create_program_egr_smac(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_T3P1_TMU_EGR_SMAC_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 6;
      prog_info->key_info[0].shift[1] = 6; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 2;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 2; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_64; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 6;
      prog_info->key_info[1].shift[1] = 6; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 2;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 2; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 3;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 15, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}
static void create_program_emlfilter(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {    
      soc_sbx_caladan3_tmu_program_info_t *prog_info;    
      unsigned int tableid;
      unsigned int update;
      soc_sbx_tmu_hash_handle_t handle;        
                  
      prog_info = &tm->prog_info[SOC_SBX_T3P1_TMU_EMLFILTER_PROG_ID];
      
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[0].lookup = SOC_SBX_TMU_LKUP_EML_INSERT_DELETE; 
      prog_info->key_info[0].shift[0] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[0] = 63;
      prog_info->key_info[0].shift[1] = 0; /* bytes */
      prog_info->key_info[0].bytes_to_mask[1] = 0;      
      prog_info->key_info[0].tableid = tableid;
      prog_info->key_info[0].valid = TRUE;
      prog_info->key_shift[0] = 0; 
       
          
      handle = (soc_sbx_tmu_hash_handle_t)
                tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;  
      soc_sbx_caladan3_tmu_hash_table_id_get(unit, handle, &tableid);

      prog_info->key_info[1].lookup = SOC_SBX_TMU_LKUP_EML_INSERT_DELETE; 
      prog_info->key_info[1].shift[0] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[0] = 63;
      prog_info->key_info[1].shift[1] = 0; /* bytes */
      prog_info->key_info[1].bytes_to_mask[1] = 0;      
      prog_info->key_info[1].tableid = tableid;
      prog_info->key_info[1].valid = FALSE;
      prog_info->key_shift[1] = 0; 
                     
      prog_info->flag = SOC_SBX_TMU_PRG_FLAG_WITH_ID;
      prog_info->program_num = 4;

      if (prog_info->key_info[0].lookup == SOC_SBX_TMU_LKUP_EML_INSERT_DELETE) {
          update = 1;
      } else {
          update = 0;
      }
      
      soc_sbx_lrp_setup_tmu_program(unit, 11, prog_info->program_num, update,
          prog_info->key_info[0].valid, prog_info->key_info[1].valid);
            
      soc_sbx_caladan3_tmu_program_alloc(unit, prog_info);    
}



/*
 * Entry accessor implementations for mac
 */

void soc_sbx_t3p1_mac_t_init(
    soc_sbx_t3p1_mac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_mac_t));
    e->smac_hit = 1;
    e->dmac_hit = 1;
}

/* entry pack accessor implementation for mac */
static int soc_sbx_t3p1_mac_pack(int unit,
    soc_sbx_t3p1_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->ageid; break;
          case 1: p = (uint8 *) &e->smac_hit; break;
          case 2: p = (uint8 *) &e->sdrop; break;
          case 3: p = (uint8 *) &e->dontage; break;
          case 4: p = (uint8 *) &e->sreserved; break;
          case 5: p = (uint8 *) &e->pending; break;
          case 6: p = (uint8 *) &e->poe; break;
          case 7: p = (uint8 *) &e->dmac_hit; break;
          case 8: p = (uint8 *) &e->dcopy; break;
          case 9: p = (uint8 *) &e->ddrop; break;
          case 10: p = (uint8 *) &e->dreserved; break;
          case 11: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mac */
static int soc_sbx_t3p1_mac_unpack(int unit,
                soc_sbx_t3p1_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->ageid; break;
          case 1: p = (uint8 *) &e->smac_hit; break;
          case 2: p = (uint8 *) &e->sdrop; break;
          case 3: p = (uint8 *) &e->dontage; break;
          case 4: p = (uint8 *) &e->sreserved; break;
          case 5: p = (uint8 *) &e->pending; break;
          case 6: p = (uint8 *) &e->poe; break;
          case 7: p = (uint8 *) &e->dmac_hit; break;
          case 8: p = (uint8 *) &e->dcopy; break;
          case 9: p = (uint8 *) &e->ddrop; break;
          case 10: p = (uint8 *) &e->dreserved; break;
          case 11: p = (uint8 *) &e->ftidx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mac */
static int soc_sbx_t3p1_mac_index_check(int unit, uint32 *vindex, soc_sbx_t3p1_6_byte_t imac, int ivsi )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) imac; break;
          case 1: p = (uint8 *) &ivsi; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for mac */
static int soc_sbx_t3p1_mac_index_unpack(int unit, int *vindex, soc_sbx_t3p1_6_byte_t nimac, int *nivsi)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nimac; break;
          case 1: p = (uint8 *) nivsi; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for mac */
int soc_sbx_t3p1_mac_entry_check(int unit,
                                 soc_sbx_t3p1_mac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->ageid; break;
          case 1: ev = e->smac_hit; break;
          case 2: ev = e->sdrop; break;
          case 3: ev = e->dontage; break;
          case 4: ev = e->sreserved; break;
          case 5: ev = e->pending; break;
          case 6: ev = e->poe; break;
          case 7: ev = e->dmac_hit; break;
          case 8: ev = e->dcopy; break;
          case 9: ev = e->ddrop; break;
          case 10: ev = e->dreserved; break;
          case 11: ev = e->ftidx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for mac */
int soc_sbx_t3p1_mac_set(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_mac_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_mac_update(unit, imac, ivsi, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_t3p1_mac_add(unit, imac, ivsi, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for mac */
int soc_sbx_t3p1_mac_add(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_mac_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_mac_add_ext_sim(unit, imac, ivsi, e);        
    }   
    
    rv = soc_sbx_t3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for mac */
int soc_sbx_t3p1_mac_get(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_mac_get_ext_sim(unit, imac, ivsi, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for mac */
int soc_sbx_t3p1_mac_hw_get(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_mac_get_ext_sim(unit, imac, ivsi, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for mac */
int soc_sbx_t3p1_mac_update(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_mac_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_mac_add_ext_sim(unit, imac, ivsi, e);
    }
        
    rv = soc_sbx_t3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for mac */
int soc_sbx_t3p1_mac_delete(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_mac_delete_ext_sim(unit, imac, ivsi);
    }
        
    rv = soc_sbx_t3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for mac */
int soc_sbx_t3p1_mac_remove(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi)
{
    return soc_sbx_t3p1_mac_delete(unit, imac, ivsi);
}

/* Get the first element of mac */
int soc_sbx_t3p1_mac_first(int unit, soc_sbx_t3p1_6_byte_t nimac, int *nivsi)
{
    int rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_t3p1_mac_index_unpack(unit, (int *)key, nimac, nivsi);    
}

/* Get the next element of mac */
int soc_sbx_t3p1_mac_next(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, soc_sbx_t3p1_6_byte_t nimac, int *nivsi)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_t3p1_mac_index_check(unit, key, imac, ivsi);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_t3p1_mac_index_unpack(unit, (int *)next_key, nimac, nivsi);  
}

/**
New entry set accessor implementation for mac
*/
int soc_sbx_t3p1_mac_data_set(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_mac_t entry;

    soc_sbx_t3p1_mac_t_init(&entry);
    s = soc_sbx_t3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_mac_set(unit, imac, ivsi, &entry);

    return s;
}

/**
New entry add accessor implementation for mac
*/
int soc_sbx_t3p1_mac_data_add(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_mac_t entry;

    soc_sbx_t3p1_mac_t_init(&entry);
    s = soc_sbx_t3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_mac_add(unit, imac, ivsi, &entry);

    return s;
}

/**
New entry get accessor implementation for mac
*/
int soc_sbx_t3p1_mac_data_get(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_mac_t entry;

    soc_sbx_t3p1_mac_t_init(&entry);
    s = soc_sbx_t3p1_mac_get(unit, imac, ivsi, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_mac_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for mac
*/
int soc_sbx_t3p1_mac_data_update(int unit, soc_sbx_t3p1_6_byte_t imac, int ivsi, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_mac_t entry;

    soc_sbx_t3p1_mac_t_init(&entry);
    s = soc_sbx_t3p1_mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_mac_update(unit, imac, ivsi, &entry);

    return s;
}


/*
 * Entry accessor implementations for age2mac
 */

void soc_sbx_t3p1_age2mac_t_init(
    soc_sbx_t3p1_age2mac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_age2mac_t));
}

/* entry pack accessor implementation for age2mac */
static int soc_sbx_t3p1_age2mac_pack(int unit,
    soc_sbx_t3p1_age2mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->reserved1; break;
          case 1: p = (uint8 *) &e->smac2; break;
          case 2: p = (uint8 *) &e->vsi; break;
          case 3: p = (uint8 *) &e->smac1; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for age2mac */
static int soc_sbx_t3p1_age2mac_unpack(int unit,
                soc_sbx_t3p1_age2mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {





          case 0: p = (uint8 *) &e->reserved1; break;
          case 1: p = (uint8 *) &e->smac2; break;
          case 2: p = (uint8 *) &e->vsi; break;
          case 3: p = (uint8 *) &e->smac1; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for age2mac */
static int soc_sbx_t3p1_age2mac_index_check(int unit, uint32 *vindex, int iageid )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iageid; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for age2mac */
static int soc_sbx_t3p1_age2mac_index_unpack(int unit, int *vindex, int *niageid)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) niageid; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for age2mac */
int soc_sbx_t3p1_age2mac_entry_check(int unit,
                                 soc_sbx_t3p1_age2mac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->reserved1; break;
          case 1: ev = e->smac2; break;
          case 2: ev = e->vsi; break;
          case 3: ev = e->smac1; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_set(int unit, int iageid, soc_sbx_t3p1_age2mac_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_age2mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_age2mac_update(unit, iageid, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_t3p1_age2mac_add(unit, iageid, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_add(int unit, int iageid, soc_sbx_t3p1_age2mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_age2mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_age2mac_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_age2mac_add_ext_sim(unit, iageid, e);        
    }   
    
    rv = soc_sbx_t3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_get(int unit, int iageid, soc_sbx_t3p1_age2mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_age2mac_get_ext_sim(unit, iageid, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_age2mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_hw_get(int unit, int iageid, soc_sbx_t3p1_age2mac_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_age2mac_get_ext_sim(unit, iageid, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_age2mac_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_update(int unit, int iageid, soc_sbx_t3p1_age2mac_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_age2mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_age2mac_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_age2mac_add_ext_sim(unit, iageid, e);
    }
        
    rv = soc_sbx_t3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_delete(int unit, int iageid)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_age2mac_delete_ext_sim(unit, iageid);
    }
        
    rv = soc_sbx_t3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for age2mac */
int soc_sbx_t3p1_age2mac_remove(int unit, int iageid)
{
    return soc_sbx_t3p1_age2mac_delete(unit, iageid);
}

/* Get the first element of age2mac */
int soc_sbx_t3p1_age2mac_first(int unit, int *niageid)
{
    int rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_t3p1_age2mac_index_unpack(unit, (int *)key, niageid);    
}

/* Get the next element of age2mac */
int soc_sbx_t3p1_age2mac_next(int unit, int iageid, int *niageid)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_t3p1_age2mac_index_check(unit, key, iageid);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_t3p1_age2mac_index_unpack(unit, (int *)next_key, niageid);  
}

/**
New entry set accessor implementation for age2mac
*/
int soc_sbx_t3p1_age2mac_data_set(int unit, int iageid, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_age2mac_t entry;

    soc_sbx_t3p1_age2mac_t_init(&entry);
    s = soc_sbx_t3p1_age2mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_age2mac_set(unit, iageid, &entry);

    return s;
}

/**
New entry add accessor implementation for age2mac
*/
int soc_sbx_t3p1_age2mac_data_add(int unit, int iageid, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_age2mac_t entry;

    soc_sbx_t3p1_age2mac_t_init(&entry);
    s = soc_sbx_t3p1_age2mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_age2mac_add(unit, iageid, &entry);

    return s;
}

/**
New entry get accessor implementation for age2mac
*/
int soc_sbx_t3p1_age2mac_data_get(int unit, int iageid, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_age2mac_t entry;

    soc_sbx_t3p1_age2mac_t_init(&entry);
    s = soc_sbx_t3p1_age2mac_get(unit, iageid, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_age2mac_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for age2mac
*/
int soc_sbx_t3p1_age2mac_data_update(int unit, int iageid, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_age2mac_t entry;

    soc_sbx_t3p1_age2mac_t_init(&entry);
    s = soc_sbx_t3p1_age2mac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_age2mac_update(unit, iageid, &entry);

    return s;
}


/*
 * Entry accessor implementations for pvv2e
 */

void soc_sbx_t3p1_pvv2e_t_init(
    soc_sbx_t3p1_pvv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_pvv2e_t));
}

/* entry pack accessor implementation for pvv2e */
static int soc_sbx_t3p1_pvv2e_pack(int unit,
    soc_sbx_t3p1_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {


          case 0: p = (uint8 *) &e->pvv2e_idx; break;
        
          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pvv2e */
static int soc_sbx_t3p1_pvv2e_unpack(int unit,
                soc_sbx_t3p1_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {


          case 0: p = (uint8 *) &e->pvv2e_idx; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pvv2e */
int soc_sbx_t3p1_pvv2e_index_check(int unit, uint32 *vindex, int ivrf, int iport, int iovid, int iivid )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &ivrf; break;
          case 1: p = (uint8 *) &iport; break;
          case 2: p = (uint8 *) &iovid; break;
          case 3: p = (uint8 *) &iivid; break;
          case 4: continue;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pvv2e */
int soc_sbx_t3p1_pvv2e_entry_check(int unit,
                                 soc_sbx_t3p1_pvv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->pvv2e_idx; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for pvv2e */
int soc_sbx_t3p1_pvv2e_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for pvv2e */
int soc_sbx_t3p1_pvv2e_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_t3p1_ucode_set(unit,
                    soc_sbx_t3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");

    return s;
}

/* unpack index for pvv2e */
static int soc_sbx_t3p1_pvv2e_index_unpack(int unit, int *vindex, int *nivrf, int *niport, int *niovid, int *niivid)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;

    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) nivrf; break;
          case 1: p = (uint8 *) niport; break;
          case 2: p = (uint8 *) niovid; break;
          case 3: p = (uint8 *) niivid; break;
          case 4: continue;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* get firt entry for pvv2e */
int soc_sbx_t3p1_pvv2e_first(int unit, int *nivrf, int *niport, int *niovid, int *niivid, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = taps_iterator_first(unit, &arg, key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_t3p1_pvv2e_index_unpack(unit, (int *)key,nivrf, niport, niovid, niivid);
}

/* get next entry for pvv2e */
int soc_sbx_t3p1_pvv2e_next(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits, int *nivrf, int *niport, int *niovid, int *niivid, int *ninetmask_num_bits)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    uint32 key_length;
    taps_arg_t arg;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    sal_memset(key, 0, 32*sizeof(uint32));

    rv = soc_sbx_t3p1_pvv2e_index_check(unit, key, ivrf, iport, iovid, iivid);
    if (rv) {
        return rv;
    }

	key[0] = align_right(ivrf);



	shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);

    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;

    rv = taps_iterator_next(unit, &arg, next_key, &key_length);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }

    *ninetmask_num_bits = key_length - 16;
    return soc_sbx_t3p1_pvv2e_index_unpack(unit, (int *)next_key, nivrf, niport, niovid, niivid);
}

/* entry set accessor implementation for pvv2e */
int soc_sbx_t3p1_pvv2e_set(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits, soc_sbx_t3p1_pvv2e_t *e)
{
    int s;
    uint32 key[32];

    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    taps_arg_t arg;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];

    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_t3p1_pvv2e_index_check(unit, key, ivrf, iport, iovid, iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_pvv2e_entry_check(unit, e);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_pvv2e_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_t3p1_pvv2e_add_ext_sim(unit, ivrf, iport, iovid, iivid, e);   
    }
    
    key[0] = align_right(ivrf);



    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
        
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;          
}

/* entry get accessor implementation for pvv2e */
int soc_sbx_t3p1_pvv2e_get(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits, soc_sbx_t3p1_pvv2e_t *e)
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_t3p1_pvv2e_index_check(unit, key, ivrf, iport, iovid, iivid);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_t3p1_pvv2e_get_ext_sim(unit, ivrf, iport, iovid, iivid,  e);
    }
    
    key[0] = align_right(ivrf);



    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    s = taps_get_route(unit, &arg);
    if (s) {
        return s;
    }  

    s = soc_sbx_t3p1_pvv2e_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}


int soc_sbx_t3p1_pvv2e_lpm_raw_get(int unit, int ivrf, int iport, int iovid, int iivid, int *nivrf, int *niport, int *niovid, int *niivid, int *onetmask_num_bits, unsigned char *obuf, int *osize)
{
    int s;
    int inetmask_num_bits = 32;
    uint32 key[32];   
    uint32 bpm_key[32];
    uint32 bpm_length;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];     
    taps_arg_t arg; 
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];        
            
    sal_memset(key, 0, 32*sizeof(uint32));
    sal_memset(bpm_key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_t3p1_pvv2e_index_check(unit, key, ivrf, iport, iovid, iivid);
    if (s) {
        return s;
    }
    
    key[0] = align_right(ivrf);



    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + 32;
    arg.payload = epacked;
    s = taps_get_lpm_route(unit, &arg, bpm_key, &bpm_length);
    if (s) {
        return s;
    }  
    
    s = soc_sbx_t3p1_pvv2e_index_unpack(unit, (int *)key, nivrf, niport, niovid, niivid);
    if (s) {
        return s;
    } 
    
    *onetmask_num_bits = bpm_length - 16;
    *osize = ed->width_in_words * 32;
    sal_memcpy(obuf, epacked, sizeof(uint32) * BITS2WORDS(*osize));
    
    return s;
}

int soc_sbx_t3p1_pvv2e_lpm_get(int unit, int ivrf, int iport, int iovid, int iivid, int *nivrf, int *niport, int *niovid, int *niivid, int *onetmask_num_bits, soc_sbx_t3p1_pvv2e_t *e)
{
    int s;
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];
    int size = 0;
    s = soc_sbx_t3p1_pvv2e_lpm_raw_get(unit, ivrf, iport, iovid, iivid, nivrf, niport, niovid, niivid, onetmask_num_bits, (unsigned char *)epacked, (int *)size);
    if (s) {
        return s;
    }
    
    s = soc_sbx_t3p1_pvv2e_unpack(unit, e, (unsigned char *)epacked, size);
    
    return s; 
}

int soc_sbx_t3p1_pvv2e_delete(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits) 
{
    int s;
    uint32 key[32];   
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];   
    taps_arg_t arg; 
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;    
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_t3p1_pvv2e_index_check(unit, key, ivrf, iport, iovid, iivid);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_t3p1_pvv2e_delete_ext_sim(unit, ivrf, iport, iovid, iivid);
    }
    
    key[0] = align_right(ivrf);



    shift_right((uint8 *)key, WORDS2BYTES((48 + 31)/32), 48 - 16 - inetmask_num_bits);
    
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = 16 + inetmask_num_bits;
    arg.payload = epacked;
    
    s = taps_delete_route(unit, &arg);
    
    return s;
}    

int soc_sbx_t3p1_pvv2e_remove(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits)
{
    return soc_sbx_t3p1_pvv2e_delete(unit, ivrf, iport, iovid, iivid, inetmask_num_bits);
}

/* 
 * Raw entry set accessor implementation for pvv2e
 */
int soc_sbx_t3p1_pvv2e_raw_set(int unit, uint32 * key, int key_length, uint32 *payload)
{
    int s;
    taps_arg_t arg;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

        
    arg.taps = tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].taps;
    arg.key = &key[0];
    arg.length = key_length;
    arg.payload = payload;
	/* coverity[ stack_use_overflow ] */
    s = taps_insert_route(unit, &arg);
    if (s == SOC_E_EXISTS) {
      s = taps_update_route(unit, &arg);
    }  
    if (s) {
        return s;
    }  

    return SOC_E_NONE;   
}

/**
New entry set accessor implementation for pvv2e
*/
int soc_sbx_t3p1_pvv2e_data_set(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_pvv2e_t entry;

    soc_sbx_t3p1_pvv2e_t_init(&entry);
    s = soc_sbx_t3p1_pvv2e_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_pvv2e_set(unit, ivrf, iport, iovid, iivid, inetmask_num_bits, &entry);

    return s;
}

/**
New entry get accessor implementation for pvv2e
*/
int soc_sbx_t3p1_pvv2e_data_get(int unit, int ivrf, int iport, int iovid, int iivid, int inetmask_num_bits, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_pvv2e_t entry;

    soc_sbx_t3p1_pvv2e_t_init(&entry);
    s = soc_sbx_t3p1_pvv2e_get(unit, ivrf, iport, iovid, iivid, inetmask_num_bits, &entry);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_pvv2e_pack(unit, &entry, buf, size*8);

    return s;
}


/*
 * Entry accessor implementations for emlfilter
 */

void soc_sbx_t3p1_emlfilter_t_init(
    soc_sbx_t3p1_emlfilter_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_emlfilter_t));
}

/* entry pack accessor implementation for emlfilter */
static int soc_sbx_t3p1_emlfilter_pack(int unit,
    soc_sbx_t3p1_emlfilter_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    int sz = (bsz+7)/8;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    int be = tm->behost;

    base = b;
    sal_memset(b, 0, sz);

    if (be)
        b+= sz - 1;

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->reserved_0; break;
          case 1: p = (uint8 *) &e->reserved_1; break;
          case 2: p = (uint8 *) &e->reserved_2; break;
          case 3: p = (uint8 *) &e->reserved_3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, sz);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emlfilter */
static int soc_sbx_t3p1_emlfilter_unpack(int unit,
                soc_sbx_t3p1_emlfilter_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    int sz = (bsz + 7 ) /8;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, sz);
        b+=sz-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {




          case 0: p = (uint8 *) &e->reserved_0; break;
          case 1: p = (uint8 *) &e->reserved_1; break;
          case 2: p = (uint8 *) &e->reserved_2; break;
          case 3: p = (uint8 *) &e->reserved_3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emlfilter */
static int soc_sbx_t3p1_emlfilter_index_check(int unit, uint32 *vindex, int iemlindex )
{
    int i, j, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;
    int total_width = 0;
    int width_in_words = 0;
    uint32 reverser[32];
    
    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iemlindex; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
        
        pibe = (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0, pkbe, pos, width, p, ibe, pibe != pkbe);
        
        total_width += width;
    }

    width_in_words = (total_width + 31)/32;
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
        reverser[j] = vindex[i];    
    }
    
    for (i=0; i<width_in_words; i++) {
        vindex[i] = reverser[i];
    }
    
    return SOC_E_NONE;
}

/* entry index unpack for emlfilter */
static int soc_sbx_t3p1_emlfilter_index_unpack(int unit, int *vindex, int *niemlindex)
{
    int i, j, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    uint32 rvindex[32];
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int width_in_words = ed->indexeswidth/32;
    
    for (i=width_in_words-1, j=0; i>=0; i--, j++) {
           rvindex[j] = vindex[i];    
    }
           
    p0 = ((uint8 *) rvindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) niemlindex; break;
          default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe =
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT 
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;

}

/* entry argument checker for emlfilter */
int soc_sbx_t3p1_emlfilter_entry_check(int unit,
                                 soc_sbx_t3p1_emlfilter_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->reserved_0; break;
          case 1: ev = e->reserved_1; break;
          case 2: ev = e->reserved_2; break;
          case 3: ev = e->reserved_3; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_set(int unit, int iemlindex, soc_sbx_t3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];

    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_emlfilter_update(unit, iemlindex, e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_t3p1_emlfilter_add(unit, iemlindex, e);
        if (s) {
            return s;
        }
    }

    return s;
}

/* entry add accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_add(int unit, int iemlindex, soc_sbx_t3p1_emlfilter_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_emlfilter_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_emlfilter_add_ext_sim(unit, iemlindex, e);        
    }   
    
    rv = soc_sbx_t3p1_hash_add_ext(unit, handle, key, epacked); 
    
    if (rv != SOC_E_NONE) {
        return rv;
    }
    
    if (s != SOC_E_NONE) {
        return s;
    }
    
    return SOC_E_NONE;
}

/* entry get accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_get(int unit, int iemlindex, soc_sbx_t3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_emlfilter_get_ext_sim(unit, iemlindex, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_emlfilter_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry get accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_hw_get(int unit, int iemlindex, soc_sbx_t3p1_emlfilter_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_emlfilter_get_ext_sim(unit, iemlindex, e);
        if ( s == SOC_E_NONE) {
          return s;
        }
    }
        
    s = soc_sbx_t3p1_hash_hw_get_ext(unit, handle,
                                 key, epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_emlfilter_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/* entry update accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_update(int unit, int iemlindex, soc_sbx_t3p1_emlfilter_t *e)
{
    int s, rv;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_CALADAN3_TMU_HASH_VALUE_SIZE_BITS)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_emlfilter_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_emlfilter_pack(unit,
                  e, (uint8*)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_emlfilter_add_ext_sim(unit, iemlindex, e);
    }
        
    rv = soc_sbx_t3p1_hash_update_ext(unit, handle,
                                    key, epacked);

    if (s != SOC_E_NONE) {
       return s;
    }
    
    if (rv != SOC_E_NONE) {
       return rv;
    }
                                            
    return SOC_E_NONE;
}

/* entry delete accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_delete(int unit, int iemlindex)
{
    int s, rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
    s = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (s) {
        return s;
    }

    if (SAL_BOOT_BCMSIM) {
        s = soc_sbx_t3p1_emlfilter_delete_ext_sim(unit, iemlindex);
    }
        
    rv = soc_sbx_t3p1_hash_delete_ext(unit, handle, key);
    
    if (s) {
        return s;
    }
    if (rv) {
        return rv;
    }
    
    return SOC_E_NONE;
}

/* entry remove accessor implementation for emlfilter */
int soc_sbx_t3p1_emlfilter_remove(int unit, int iemlindex)
{
    return soc_sbx_t3p1_emlfilter_delete(unit, iemlindex);
}

/* Get the first element of emlfilter */
int soc_sbx_t3p1_emlfilter_first(int unit, int *niemlindex)
{
    int rv;
    uint32 key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
      
    rv = soc_sbx_caladan3_tmu_hash_iterator_first(unit, handle, key);
    if (rv) {
        return SOC_E_NOT_FOUND;
    }
    
    return soc_sbx_t3p1_emlfilter_index_unpack(unit, (int *)key, niemlindex);    
}

/* Get the next element of emlfilter */
int soc_sbx_t3p1_emlfilter_next(int unit, int iemlindex, int *niemlindex)
{
    int rv;
    uint32 key[32];
    uint32 next_key[32];
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_tmu_hash_handle_t handle = (soc_sbx_tmu_hash_handle_t)
        tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle;
    
    sal_memset(key, 0, 32*sizeof(uint32));
   
    rv = soc_sbx_t3p1_emlfilter_index_check(unit, key, iemlindex);
    if (rv) 
        return SOC_E_NOT_FOUND;

    rv = soc_sbx_caladan3_tmu_hash_iterator_next(unit, handle, key, next_key);
    if (rv) 
        return SOC_E_NOT_FOUND;

    return soc_sbx_t3p1_emlfilter_index_unpack(unit, (int *)next_key, niemlindex);  
}

/**
New entry set accessor implementation for emlfilter
*/
int soc_sbx_t3p1_emlfilter_data_set(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_emlfilter_t entry;

    soc_sbx_t3p1_emlfilter_t_init(&entry);
    s = soc_sbx_t3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_emlfilter_set(unit, iemlindex, &entry);

    return s;
}

/**
New entry add accessor implementation for emlfilter
*/
int soc_sbx_t3p1_emlfilter_data_add(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_emlfilter_t entry;

    soc_sbx_t3p1_emlfilter_t_init(&entry);
    s = soc_sbx_t3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_emlfilter_add(unit, iemlindex, &entry);

    return s;
}

/**
New entry get accessor implementation for emlfilter
*/
int soc_sbx_t3p1_emlfilter_data_get(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_emlfilter_t entry;

    soc_sbx_t3p1_emlfilter_t_init(&entry);
    s = soc_sbx_t3p1_emlfilter_get(unit, iemlindex, &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_emlfilter_pack(unit, &entry, buf, size*8);

    return s;
}

/**
New entry update accessor implementation for emlfilter
*/
int soc_sbx_t3p1_emlfilter_data_update(int unit, int iemlindex, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_emlfilter_t entry;

    soc_sbx_t3p1_emlfilter_t_init(&entry);
    s = soc_sbx_t3p1_emlfilter_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_emlfilter_update(unit, iemlindex, &entry);

    return s;
}


/*
 * Entry accessor implementations for sample_dm1
 */

void soc_sbx_t3p1_sample_dm1_t_init(
    soc_sbx_t3p1_sample_dm1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_sample_dm1_t));
}

/* entry pack accessor implementation for sample_dm1 */
static int soc_sbx_t3p1_sample_dm1_pack(int unit,
    soc_sbx_t3p1_sample_dm1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int be = tm->behost;

    sal_memset(b, 0, (bsz+7)/8);
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

          case 0: p = (uint8 *) &e->w0; break;
          case 1: p = (uint8 *) &e->w1; break;
          case 2: p = (uint8 *) &e->w2; break;
          case 3: p = (uint8 *) &e->w3; break;

          default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sample_dm1 */
static int soc_sbx_t3p1_sample_dm1_unpack(int unit,
                soc_sbx_t3p1_sample_dm1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+= bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {

        case 0: p = (uint8 *) &e->w0; break;
        case 1: p = (uint8 *) &e->w1; break;
        case 2: p = (uint8 *) &e->w2; break;
        case 3: p = (uint8 *) &e->w3; break;
               
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_index_check(int unit, uint32 *vindex, int iindex_1, int iindex_2 )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
          case 0: p = (uint8 *) &iindex_1; break;
          case 1: p = (uint8 *) &iindex_2; break;
          default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_entry_check(int unit,
                                 soc_sbx_t3p1_sample_dm1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {        
          case 0: ev = e->w0; break;
          case 1: ev = e->w1; break;
          case 2: ev = e->w2; break;
          case 3: ev = e->w3; break;               
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* get table size for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_table_size_get(int unit)
{
    int s, num_entries;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &num_entries,
                e,
                td->name,
                -1,
                e,
                "SIZE");
    if (s) {
        return 0;
    }

    return num_entries * (td->entry_size_bits / 8);
        
}

/* set table size for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_table_size_set(int unit, int size)
{
    int s, num_entries;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_tmu_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    
    num_entries = size/(td->entry_size_bits / 8);
    
    s = soc_sbx_t3p1_ucode_set(unit,
                    soc_sbx_t3p1_sym, 128,
                    num_entries, e, td->name, -1, e,
                    "SIZE");
                    
    return s;
}

/* entry set accessor implementation for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_set(int unit, int iindex_1, int iindex_2, soc_sbx_t3p1_sample_dm1_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].handle;
    int entry_size_bits =
        tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_size_bits;
        
    sal_memset(key, 0, 32*sizeof(uint32));

    s = soc_sbx_t3p1_sample_dm1_index_check(unit, key, iindex_1, iindex_2);
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_sample_dm1_entry_check(unit, e);
    if (s) {
        return s;
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_t3p1_sample_dm1_pack(unit,
                              e, (uint8 *)epacked, (ed->width_in_words * 32));
    if (s) {
        return s;
    }
     
    if (SAL_BOOT_BCMSIM) {
       return soc_sbx_t3p1_sample_dm1_add_ext_sim(unit, iindex_1, iindex_2, e);   
    }
    else {
       return soc_sbx_caladan3_tmu_dm_set(unit, handle, key[0], epacked, BITS2WORDS(entry_size_bits));  
    }          
}

/* entry get accessor implementation for sample_dm1 */
int soc_sbx_t3p1_sample_dm1_get(int unit, int iindex_1, int iindex_2, soc_sbx_t3p1_sample_dm1_t *e)
{
    int s;
    uint32 key[32];
    uint32 epacked[BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];
    int handle = (int)
        tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].handle;
        
    sal_memset(key, 0, 32*sizeof(uint32));
    
    s = soc_sbx_t3p1_sample_dm1_index_check(unit, key, iindex_1, iindex_2);
    if (s) {
        return s;
    }
    
    if (SAL_BOOT_BCMSIM) {
        return soc_sbx_t3p1_sample_dm1_get_ext_sim(unit, iindex_1, iindex_2,  e);
    }
    sal_memset(epacked, 0, BITS2WORDS(SOC_SBX_TMU_DM_494b_SIZE)*sizeof(uint32));
    s = soc_sbx_caladan3_tmu_dm_get(unit, handle, key[0],
                                 epacked, BITS2WORDS(119));
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_sample_dm1_unpack(unit,
                                e, (uint8 *)epacked, (ed->width_in_words * 32));

    return s;
}

/**
New entry set accessor implementation for sample_dm1
*/
int soc_sbx_t3p1_sample_dm1_data_set(int unit, int iindex_1, int iindex_2, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_sample_dm1_t entry;

    soc_sbx_t3p1_sample_dm1_t_init(&entry);
    s = soc_sbx_t3p1_sample_dm1_unpack(unit, &entry, buf, size*8);
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_sample_dm1_set(unit, iindex_1, iindex_2, &entry);

    return s;
}

/**
New entry get accessor implementation for sample_dm1
*/
int soc_sbx_t3p1_sample_dm1_data_get(int unit, int iindex_1, int iindex_2, unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_sample_dm1_t entry;

    soc_sbx_t3p1_sample_dm1_t_init(&entry);
    s = soc_sbx_t3p1_sample_dm1_get(unit, iindex_1, iindex_2, &entry);
    if (s) {
      return s;
    }
    s = soc_sbx_t3p1_sample_dm1_pack(unit, &entry, buf, size*8);

    return s;
}

static int create_table_mac(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 524288;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 4194304;
    hash_param.num_chain_table_entries = 262144;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate MAC table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].type = SOC_SBX_T3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name ="mac";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].table = SOC_SBX_T3P1_TMU_MAC_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_mac_pack;
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].esize =
        sizeof(soc_sbx_t3p1_mac_t);
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nindexes = 2;
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nfields = 12;
    
    if (tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                    * tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nfields,
                        "SOC_SBX_T3P1_TMU_MAC_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }





    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[0].name = "ageid";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[1].name = "smac_hit";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[2].name = "sdrop";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[3].name = "dontage";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[4].name = "sreserved";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[5].name = "pending";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[6].name = "poe";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[7].name = "dmac_hit";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[8].name = "dcopy";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[9].name = "ddrop";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[10].name = "dreserved";
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[11].name = "ftidx";
        
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nfields; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nindexes,
                    "SOC_SBX_T3P1_TMU_MAC_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[0].name = "mac"; 
    tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[1].name = "vsi"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_age2mac(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 2097152;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 16777216;
    hash_param.num_chain_table_entries = 528288;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate AGE2MAC table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].type = SOC_SBX_T3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name ="age2mac";
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].table = SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_age2mac_pack;
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].esize =
        sizeof(soc_sbx_t3p1_age2mac_t);
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nfields = 4;
    
    if (tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                    * tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nfields,
                        "SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }





    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[0].name = "reserved1";
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[1].name = "smac2";
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[2].name = "vsi";
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[3].name = "smac1";
        
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nfields; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nindexes,
                    "SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[0].name = "ageid"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_pvv2e(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {

    taps_init_params_t init_params;
    int i, j, rv;
    unsigned int defentry[_TAPS_PAYLOAD_WORDS_];
    soc_sbx_t3p1_tmu_table_desc_t* table_desc;
    int index_width, entry_width;
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    table_desc = &(tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID]);

    sal_memset(&init_params, 0, sizeof(taps_init_params_t));
    init_params.instance = 0;
    init_params.divide_ratio = 5;
    init_params.host_share_table = 0;
    init_params.key_attr.type = 0;
    init_params.key_attr.length = 48;
    init_params.key_attr.vrf_length = 16;

    init_params.tcam_layout = 0;

    init_params.sbucket_attr.format = SOC_SBX_TMU_TAPS_BB_FORMAT_3ENTRIES;
    init_params.dbucket_attr.num_dbucket_pfx = 0; 
    for (i=0; i < TAPS_DDR_TABLE_MAX; i++) {
        init_params.dbucket_attr.flags[i] = 0;
        init_params.dbucket_attr.table_id[i] = 0;
    }

    init_params.mode = 0;
    init_params.max_capacity_limit = 65536; 

    for (i=0; i<_TAPS_PAYLOAD_WORDS_; i++) 
        defentry[i] = 0;
    init_params.defpayload = &defentry[0];

    rv = taps_create(unit, &init_params, &(table_desc->taps));
    if (SOC_FAILURE(rv)) {
        soc_sbx_t3p1_tmu_uninit(unit);
        return rv;
    }

    tm->tables[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].type = SOC_SBX_T3P1_TMU_TAPS_TABLE_TYPE;
            
                    
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name ="pvv2e";
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].table = SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_pvv2e_pack;
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].esize =
        sizeof(soc_sbx_t3p1_pvv2e_t);
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nindexes = 4 + 1;
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nfields = 1;
    
    if (tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                    * tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nfields,
                        "SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }


    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[0].name = "pvv2e_idx";
          
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nfields; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nindexes,
                    "SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[0].name = "vrf"; 
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[1].name = "port"; 
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[2].name = "ovid"; 
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[3].name = "ivid"; 
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[4].name = "netmask"; 
        
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].nindexes - 1; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID].indexes[j].range = 256;
         
    return SOC_E_NONE;
}
static int create_table_emlfilter(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {        
    soc_sbx_tmu_hash_param_t hash_param;    
    soc_sbx_tmu_hash_handle_t hash_handle;
    int rv = SOC_E_NONE;    
    int j;
    int index_width, entry_width;
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    int width_in_words = (128 + 31)/32;

    sal_memset(&hash_param, 0, sizeof(hash_param));
    hash_param.capacity = 8192;
    hash_param.key_type = SOC_SBX_CALADAN3_TMU_HASH_KEY_64_BITS;
    hash_param.chain_length = 6;
    hash_param.num_hash_table_entries = 32768;
    hash_param.num_chain_table_entries = 2048;

    rv = soc_sbx_caladan3_tmu_hash_table_alloc(unit, &hash_param, &hash_handle);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "%d Failed to allocate EMLFILTER table: %d\n"),unit,rv));
        return SOC_E_FAIL;
    }

    tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].handle = (void *)hash_handle;
    tm->tables[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].type = SOC_SBX_T3P1_TMU_HASH_TABLE_TYPE;
       
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name ="emlfilter";
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].table = SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_emlfilter_pack;
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].esize =
        sizeof(soc_sbx_t3p1_emlfilter_t);
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].width_in_words = width_in_words;    
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nfields = 4;
    
    if (tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                    * tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nfields,
                        "SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }




    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[0].name = "reserved_0";
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[1].name = "reserved_1";
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[2].name = "reserved_2";
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[3].name = "reserved_3";
        
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nfields; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nindexes,
                    "SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[0].name = "emlindex"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         index_width = ((tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;
         
         if (tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID].indexeswidth = index_width;
         }
    }
    
    
    return SOC_E_NONE;
}
static int create_table_sample_dm1(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {        
    int dm_handle;
    int rv = SOC_E_NONE;
    int j;
    int index_width, entry_width;
    char soc_sbx_t3p1_sym[128];
    char *e = "";
    int num_entries = 1024;
    uint32 field=0;
    lrb_dm_segment_table_entry_t entry;    
    int entry_size_bits;
    int nField;
    int width_in_words = (119 + 31)/32;

    /* int segment_num; */

    if (119 <= SOC_SBX_TMU_DM_119b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_119b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_247b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_247b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_366b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_366b_SIZE;
    else if (119 <= SOC_SBX_TMU_DM_494b_SIZE)
        entry_size_bits = SOC_SBX_TMU_DM_494b_SIZE;
    else {
        LOG_CLI((BSL_META_U(unit,
                            "%d Invalid DM table size. Table size must not exceed: %d\n"),unit, SOC_SBX_TMU_DM_494b_SIZE));
    /*    rv = SOC_E_PARAM; */
        return SOC_E_PARAM;

    }

    rv = soc_sbx_caladan3_tmu_dm_table_alloc(unit, num_entries, entry_size_bits, &dm_handle);    
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to allocate SAMPLE_DM1 table: %d\n"),unit,rv));
    /*    rv = SOC_E_FAIL;  */
          return rv;
    }

    nField = DM0f;

    /*
    segment_num = dm_handle;
    rv = soc_sbx_t3p1_sample_dm1_segment_num_set(unit, segment_num);
    if (SOC_FAILURE(rv)) {
    	 LOG_CLI((BSL_META_U(unit,
                             "%d Failed to set symbol sample_dm1_segment_num \n"), unit));
    }
    */

    tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].handle = (void *)dm_handle;
    tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name = "sample_dm1";
    tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].type = SOC_SBX_T3P1_TMU_DM_TABLE_TYPE;
    tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_size_bits = entry_size_bits;
    tm->tables[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].entry_port = 4;            
       
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name ="sample_dm1";
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].table = SOC_SBX_T3P1_TABLE_MAX_ID;
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_sample_dm1_pack;
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].esize =
        sizeof(soc_sbx_t3p1_sample_dm1_t);
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].width_in_words = width_in_words;
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes = 2;
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields = 4;
    
    if (tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields) {
         tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields =
             sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                    * tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields,
                        "SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID_ENTRIES");
         if (!tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return SOC_E_MEMORY;
         }
    }

    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[0].name = "w0";
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[1].name = "w1";
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[2].name = "w2";
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[3].name = "w3";    
        
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize = 0;
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].totalwidth = 0;
    
    for (j=0; j<tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nfields; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].pos,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].range,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "RANGE");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
    
        rv = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].width,
                e,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                -1,
                tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].name,
                "WIDTH");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        entry_width = tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].pos + tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].fields[j].width;
        if (entry_width > tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize) {
            tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].epsize = entry_width;
            tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].totalwidth = entry_width;  
        }  
    }
    
    if (tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes,
                    "SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID_INDEXES");
        if (!tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[0].name = "index_1"; 
    tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[1].name = "index_2"; 
       
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].nindexes; j++) {
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].pos,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_POSITION");
        if (rv) {
            soc_sbx_t3p1_tmu_uninit(unit);
            return rv;
        }
        
        rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].orange,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_RANGE");
         if (rv) {
             soc_sbx_t3p1_tmu_uninit(unit);
             return rv;
         }
         
         tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].range = tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].orange;
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].width,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "INDEX_WIDTH");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }
         
         rv = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].format,
                        e,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].name,
                        -1,
                        tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].name,
                        "FORMAT");
         if (rv) {
                soc_sbx_t3p1_tmu_uninit(unit);
                return rv;
         }

         index_width = ((tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].pos
                  + tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexes[j].width
                  + 7) / 8) * 8;

         if (tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexeswidth < index_width) {
               tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID].indexeswidth = index_width;
         }
    }

    rv = soc_sbx_t3p1_sample_dm1_table_size_set(unit, num_entries);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "%d Failed to set SAMPLE_DM1 size: %d\n"),unit,rv));
        rv = SOC_E_FAIL;
    }

    /* setup result register mapping */
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));

    if (entry_size_bits == SOC_SBX_TMU_DM_119b_SIZE) {
        field = 0;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_247b_SIZE) {
        field = 1;
    } else if (entry_size_bits == SOC_SBX_TMU_DM_366b_SIZE) {
        field = 2;
    } else {
        field = 3;
    }

    soc_mem_field_set(unit, LRB_DM_SEGMENT_TABLEm, &entry.entry_data[0], nField, &field);

    SOC_IF_ERROR_RETURN(soc_mem_write(unit, LRB_DM_SEGMENT_TABLEm,
                                     MEM_BLOCK_ANY, dm_handle, &entry));
    return SOC_E_NONE;
}


static void create_tmu_programs(int unit, soc_sbx_t3p1_tmu_table_manager_t *tm) {   
     create_program_mac(unit, tm);
     create_program_age2mac(unit, tm);
     create_program_pvv2e(unit, tm);
     create_program_egr_smac(unit, tm);
     create_program_emlfilter(unit, tm);
}

/*
 * TMU Table Manager initializer
 */
int soc_sbx_t3p1_tmu_init(int unit)
{
    soc_sbx_t3p1_tmu_table_manager_t *tm;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    uint32 v;

    if (!fe) {
        return SOC_E_INIT;
    }

    if (fe->tmu_mgr) {
        /* Free old info */
        soc_sbx_t3p1_tmu_uninit(unit);
    }

    tm = sal_alloc(sizeof(soc_sbx_t3p1_tmu_table_manager_t), "tmu_tbl_mgr");
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_t3p1_tmu_table_manager_t));
    fe->tmu_mgr = tm;

    tm->tables = sal_alloc(sizeof(soc_sbx_t3p1_tmu_table_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID,
                           "tmu_mgr_tables");
    sal_memset(tm->tables, 0, sizeof(soc_sbx_t3p1_tmu_table_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID);       

    tm->indexes =  sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID,
                           "tmu_mgr_idx");
    sal_memset(tm->indexes, 0, sizeof(soc_sbx_t3p1_index_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID);

    tm->entries =  sal_alloc(sizeof(soc_sbx_t3p1_entry_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID,
                             "tmu_mgr_entries");
    sal_memset(tm->entries, 0, sizeof(soc_sbx_t3p1_entry_desc_t) * SOC_SBX_T3P1_TMU_MAX_TABLE_ID);

    tm->prog_info =  sal_alloc(sizeof(soc_sbx_caladan3_tmu_program_info_t) * SOC_SBX_T3P1_TMU_MAX_PROG_ID,
                             "tmu_prog_info");
    sal_memset(tm->prog_info, 0, sizeof(soc_sbx_caladan3_tmu_program_info_t) * SOC_SBX_T3P1_TMU_MAX_PROG_ID);

    v = 0x1;
    tm->behost = !*((uint8 *) &v);   
    
         SOC_IF_ERROR_RETURN(create_table_mac(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_age2mac(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_pvv2e(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_emlfilter(unit, tm));     
         SOC_IF_ERROR_RETURN(create_table_sample_dm1(unit, tm));     

    create_tmu_programs(unit, tm);
    
    return SOC_E_NONE;
}

/* Uninitialization function implementation */
int soc_sbx_t3p1_tmu_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm;

    if (!fe->tmu_mgr) return s;
    tm = fe->tmu_mgr;
    
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_T3P1_TMU_MAX_TABLE_ID; i++) {
            if (tm->entries[i].fields) {
                sal_free(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                sal_free(tm->entries[i].indexes);
            }
        }
        sal_free(tm->entries);
    }
    
    if (tm->tables) {
        sal_free(tm->tables);
    }
   
    if (tm->prog_info) {
        sal_free(tm->prog_info);
    }
    
    sal_free(tm);
    fe->tmu_mgr = NULL;

    return s;
}



#endif
