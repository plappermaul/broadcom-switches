
/**
 *
 * $Id: ocm_c.stg,v 1.65 Broadcom SDK $ 	 
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
 

#include <shared/bsl.h>

#include <soc/types.h>
#include <soc/drv.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT)

#include <soc/sbx/t3p1/t3p1_int.h>
#include <soc/sbx/t3p1/t3p1_defs.h>

#define UTG_MALLOC(x) sal_alloc((x), "asm");
#define UTG_FREE(x) sal_free(x);

/* Static symbol name for initialization */
char soc_sbx_t3p1_sym[128];

/* Only for debugging */
char *soc_sbx_t3p1_errsym;
/* Parse an integer */
int soc_sbx_t3p1_read(char *a, int range, uint32 *vp)
{
    uint32 v;

    if (a[0] < '0' || '9' < a[0]) {
        return SOC_E_PARAM;
    }
    v = sal_ctoi(a, 0);
    if (0 < range && ((uint32) range) <= v) {
        return SOC_E_PARAM;
    }
    *vp = v;
    return SOC_E_NONE;
}

/* Read an arbitrarily large value from shell command arguments */
int soc_sbx_t3p1_big_value_read(uint8 *v,
        int width, int noarg0, int argc, char **argv)
{
    int i, rv, vwidth, n = 0;
    int bytes = (width + 7) / 8;
    char *s, *s0;
    uint8 c;
    uint8 b[6];
    uint32 v0, v1;
    int ishexmac=0;
    char  mac_data[13];
    char *mac;
    int j=1;
    int hexmac_size;

    mac = mac_data;
    sal_memset(v, 0, bytes);

    s = *argv;
    if (( s && (*s =='m'|| *s=='M') &&
            ((s+1)!= NULL) && (*(s+1)=='a'|| *(s+1)=='A') &&
            ((s+2)!= NULL) && (*(s+2)=='c'|| *(s+2)=='C') &&
            ((s+3)!= NULL) && (*(s+3)=='=') &&
            ((s+4)!= NULL) && (*(s+4)=='0') &&
            ((s+5)!= NULL) && (*(s+5)=='x'|| *(s+4)=='X' ))) {
        ishexmac=1;
        for(i=0;i<12;i++){
            c = (uint8) *(s+6+i);
            /* LOG_CLI((BSL_META("c=%d\n"),c)); */
            if(!('0'<= c && c <='9')) break;
        }
        hexmac_size=i;
        /* LOG_CLI((BSL_META("hexmac_size=%d\n"),hexmac_size)); */

        sal_memset(mac,0,12);

        for(i=12-hexmac_size;i<12;i++) {
            *(mac+i)=*(s+5+j);
            j++;
        }
    }

    if (noarg0) {
        s = *argv;
    } else {
        for(s = *argv; *s && *s != '='; s++);
        if (!*s) {
            if (argc < 2) {
                LOG_CLI((BSL_META("no value given for %s\n"), *argv));
                return -1;
            }
            argv++;
            argc--;
            s = *argv;
            n++;
        } else if (*s == '=') {
            s++;
        }
    }

    for(s0 = s; *s0 && *s0 != '.' && *s0 != '-' && *s0 != ':'; s0++);

    if (*s0 == '.') {
        v1 = 0;
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 4; i++) {
            if (!('0' <= c && c <= '9')) {
                LOG_CLI((BSL_META("illegal octet in IP address %s\n"), *argv));
                return -1;
            }
            v0 = 0;
            for (; '0' <= c && c <= '9'; c = (uint8) *s++) {
                v0 = v0 * 10 + (c - '0');
                if (v0 > 255) {
                    LOG_CLI((BSL_META("octet too large in IP address %s\n"), *argv));
                    return -1;
                }
            }
            v1 = (v1 << 8) + v0;
            if (c && (i == 3 || c != '.')) {
                LOG_CLI((BSL_META("illegal number %s\n"), *argv));
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                LOG_CLI((BSL_META("number is too large %s\n"), *argv));
                return -1;
            }
        }

        for (i = 0; v1 && i < bytes; i++) {
            v[i] = v1;
            v1 >>= 8;
        }
        return n + 1;
    } else if (*s0 == '-' || *s0 == ':' ) {

        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 6; i++) {
            if(i==5) {
                LOG_CLI((BSL_META("\n")));
            }
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s\n"), *argv));
                return -1;
            }
            v0 = 0;
            for (;('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f');
                    c = (uint8) *s++) {
                if ('0' <= c && c <= '9') {
                    c -= '0';
                } else if ('A' <= c && c <= 'F') {
                    c -= 'A' - 10;
                } else if ('a' <= c && c <= 'f') {
                    c -= 'a' - 10;
                }
                v0 = v0 * 16 + c;
                if (v0 > 255) {
                    LOG_CLI((BSL_META("octet too large in MAC address %s\n"), *argv));
                    return -1;
                }
            }
            if (c && (i == 5 || (c != ':' && c != '-'))) {
                LOG_CLI((BSL_META("illegal number %s\n"), *argv));
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                LOG_CLI((BSL_META("number is too large %s\n"), *argv));
                return -1;
            }
            b[i] = v0;
        }
        for (i = 0; i < bytes; i++) {
            v[i] = b[i];
        }
        return n + 1;
    } else if (ishexmac){
        s=mac;
        /* LOG_CLI((BSL_META("%s: handle mac add\n"),__FUNCTION__)); */
        j=0;

        for (i = 0; i < 6; i++) {
            c = (uint8) *s++;
            v0 = 0;
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s, c=%x\n"), *argv, c));
                return -1;
            }

            if ('0' <= c && c <= '9') {
                c -= '0';
            } else if ('A' <= c && c <= 'F') {
                c -= 'A' - 10;
            } else if ('a' <= c && c <= 'f') {
                c -= 'a' - 10;
            }
            v0=c;
            c = (uint8) *s++;
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s, c=%x\n"), *argv, c));
                return -1;
            }

            if ('0' <= c && c <= '9') {
                c -= '0';
            } else if ('A' <= c && c <= 'F') {
                c -= 'A' - 10;
            } else if ('a' <= c && c <= 'f') {
                c -= 'a' - 10;
            }
            v0 = v0 * 16 + c;
            b[i] = v0;
        }

        for (i = 0; i < 6; i++) {
            v[i] = b[i];
        }
        return n + 1;
    }

    rv = soc_sbx_t3p1_read(s, -1, &v0);
    if (rv) {
        if (noarg0) {
            return 0;
        }
        LOG_CLI((BSL_META("illegal number %s\n"), *argv));
        return -1;
    }
    /* coverity[large_shift] */
    for (vwidth = 0;
            ((uint32) (1 << vwidth)) <= v0 && vwidth < 32;
            vwidth++);
    if (vwidth > width) {
        LOG_CLI((BSL_META("number is too large %s\n"), *argv));
        return -1;
    }
    if (vwidth > 8) {
        for (i = 0; v0; i++) {
            v[i] = v0;
            v0 >>= 8;
        }
        return n + 1;
    }

    for (i = 0; i < bytes; i++) {
        rv = soc_sbx_t3p1_read(s, 256, &v0);
        if (rv) {
            break;
        }
        if (v0) {
            for (vwidth = 0; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            vwidth += i * 8;
        }
        if (vwidth > width) {
            LOG_CLI((BSL_META("number is too large %s\n"), *argv));
            return -1;
        }
        v[i] = v0;
        n++;
        argv++;
        argc--;
        if (!argc) {
            break;
        }
        s = *argv;
    }
    return n; 
}

/* Read a 32 bit value from shell command arguments */
int soc_sbx_t3p1_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv)
{
    uint8 b[6];
    uint32 v0;
    int rv;

    rv = soc_sbx_t3p1_big_value_read(b, 32, noarg0, argc, argv);
    if (rv > 0) {
        v0 = b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
        if (0 < range && ((uint32) range) <= v0) {
            LOG_CLI((BSL_META("value 0x%x too large in %s\n"), v0, *argv));
            return -1;
        }
        *v = v0;
    }
    return rv;
}

/* Print an integer */

int soc_sbx_t3p1_print(int range, uint32 v)
{
    int d = 8;

    if (0 < range) {
      for (d = 0; d < 8; d++) {
        if (range <= (1 << (d * 4))) break;
      }
    }
    LOG_CLI((BSL_META("0x%0*x"), d, v));
    return 2 + d;
}

/* Get a constant value */
int soc_sbx_t3p1_constant_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_GET(fe->unit, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a global value into the running microcode */
int soc_sbx_t3p1_global_set(int unit, char *sym, uint32 v)
{
    int s;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_SET(fe->unit, fe->ucode, sym, v);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Get a global value */
int soc_sbx_t3p1_global_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_GET(fe->unit, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Insert a bit string into a buffer */
void soc_sbx_t3p1_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc, width -= 8) {
        *b = (*b & (0xff >> (8 - pos))) | (c << pos);
        if (pos != 0)
            *(b + binc) = (*(b + binc) & (0xff << pos)) | (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b = (*b & m) | ((c << pos) & ~m);
    width -= 8 - pos;
    if (width > 0)
        *(b + binc) = (*(b + binc) & (0xff << width)) 
            | ((c >> (8 - pos)) & (0xff >> (8 - width)));
}

/* OR a bit string into a buffer */
void soc_sbx_t3p1_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc , width -= 8) {
        *b |= (c << pos);
        if (pos) *(b + binc) |= (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b |= (c << pos) & ~m;
    width -= 8 - pos;
    if (width > 0) *(b + binc) |= (c >> (8 - pos)) & (0xff >> (8 - width));
}

/*
 * Extract a bit string into a buffer 
 *
 * b (source) and b0 (destination) can overlap as long as b >= b0 and
 * swab == 0.  This behavior is exploited by the entry_read_write function
 */
void soc_sbx_t3p1_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (;;b0 += b0inc, b += binc, width -= 8) {
        c = (((*b >> pos) & 0xff)
             | (pos != 0 && width > (8 - pos) ? *(b + binc) << (8 - pos) : 0));
        if (width <= 8) break;
        *b0 = c;
    }

    *b0 = c & ~(0xff << width);
}
/* Read or write an entry */
int soc_sbx_t3p1_entry_read_write(int unit, int read, int idx,
                 soc_sbx_t3p1_entry_desc_t *ed)
{
    int i, s, width, bytes, offset, rmw, opcode;
    int mwidth  COMPILER_ATTRIBUTE((unused));
    /* int pos = 0; */
    int skipsize = 0, size = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_entry_bank_t *eb = NULL;
    soc_sbx_t3p1_table_bank_t *tb;
    soc_sbx_t3p1_memory_desc_t *md;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
#ifdef PACKED_WORD_FEATURE
    uint8 buf[4] = {0, 0, 0, 0};
#endif
    char entry[32];
    uint8 *dp;
    char *buffer;
    int interleaved_offset = 0;
    
    mwidth = 0;
    bytes = 0;
    i = 0;
    rmw = 0;
    opcode = read ? OPCODE_READ : OPCODE_WRITE;
    while (i < ed->nbanks) {
        eb = &ed->banks[i];
        width = eb->width;
        tb = &td->banks[eb->tablebank];
        md = &tm->memories[tb->memory];
        mwidth = md->width;

        dp = tm->entrydmabuf + bytes;
#ifdef PACKED_WORD_FEATURE
        if (eb->width < mwidth) {
            if (ed->nbanks > 1) {
                return SOC_E_INTERNAL;
            }
            if (opcode == OPCODE_WRITE) {
                buf[0] = dp[0];
                buf[1] = dp[1];
                buf[2] = dp[2];
                buf[3] = dp[3];
                opcode = OPCODE_READ;
                rmw = 1;
            } else if (rmw) {
                pos = eb->width * (idx % (mwidth / eb->width));
                soc_sbx_t3p1_insert(tm->entrydmabuf,
                       0, pos, eb->width, buf, 0, 0);
                opcode = OPCODE_WRITE;
                rmw = 0;
            }
            width = mwidth;
        }
#endif
         if (tb->segflags & 2) {
            LOG_INFO(BSL_LS_SOC_MEM,
                     (BSL_META_U(unit,
                                 "\n-- Interleaved 0x%08x stride:%d interleaved_offset:%d --\n"),
                      tb->segflags, eb->stridebits, interleaved_offset));
            offset = (uint32) 
                (tb->base + (((idx * eb->stridebits * ed->nbanks) + interleaved_offset) / width));
            interleaved_offset += eb->stridebits;
        } else {
            offset = (uint32) 
                (tb->base + ((idx * eb->stridebits) / width));
        }

        ocmport = tb->memory;
        segment = tb->segment;
        if (SAL_BOOT_BCMSIM) {
            buffer = tm->simbuffer;
            if (width < 8) {
                /* Pad up for sim */
                width = 8;
            }
            memset(buffer, 0, tm->simbuffersize);
            if (ed->nbanks > 1) {
               sal_snprintf(entry, 32, "%s%d", ed->name, i);
            } else {
               sal_snprintf(entry, 32, "%s", ed->name);
            }
            size = soc_sbx_caladan3_sim_block_encode(buffer, "ocm", entry,
                                 opcode == OPCODE_WRITE ? "set" : "get",
                                 offset);
            if (opcode == OPCODE_WRITE) {
                size += soc_sbx_caladan3_sim_field_encode(buffer+size, "data", dp, width/8);
            }
            s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
            if (SOC_FAILURE(s)) {
                   LOG_ERROR(BSL_LS_SOC_COMMON,
                             (BSL_META_U(unit,
                                         "sim sendrcv failed (%d)\n"), s));
                   return s;
            }
            s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
            if (SOC_SUCCESS(s)) {
                if (opcode == OPCODE_READ) {
                    size -= skipsize;
                    buffer += skipsize;
                    soc_sbx_caladan3_sim_field_decode(buffer, size, "data", dp, width/8);
                }
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "sim %s failed (%d)\n"), 
                           opcode == OPCODE_WRITE ? "set" : "get", s));
                return s;
            }
        } else {
            if (opcode == OPCODE_WRITE) {
                s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                               offset, offset, (uint32 *)dp);
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nOCM Write port %d segment %d index %d data %x"),
                          ocmport, segment, offset, *(uint32*)dp));
            } else {
                s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                              offset, offset, (uint32 *)dp);
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nOCM Read port %d segment %d index %d data %x"),
                          ocmport, segment, offset, *(uint32*)dp));
            }
            if (SOC_FAILURE(s)) {
                  return s;
            }
        }
        if (!rmw) {
            bytes += width / 8;
            i++;
        }
    }

	/*
    if (eb->width < mwidth && read) {
        pos = eb->width * (idx % (mwidth / eb->width));
        soc_sbx_t3p1_extract(tm->entrydmabuf,
               0, pos, eb->width, tm->entrydmabuf, 0, 0);
    }
    */
    return SOC_E_NONE;
}

int soc_sbx_t3p1_entry_generic_fast_word_set(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, /* addrshift, mwidth, offset, */
        v, v0, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb;
    soc_sbx_t3p1_entry_bank_t *eb = NULL;
    soc_sbx_t3p1_memory_desc_t *md __attribute__((unused));
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
/*    mwidth = md->width;   */

/*    addrshift = md->width > 32 ? 1 : 0; */
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);
    mask = ~(mask << shift);

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
/*    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth)); */
    words = (endvindex - startvindex + 1) * wordsperentry;
    ocmport = tb->memory;
    segment = tb->segment;

    while (words) {
        if (words > tm->bufsize) {
                     /* Since OCM Read is range inclusive semantics we need -1*/
             endvindex = (startvindex + tm->bufsize / wordsperentry) - 1;
         } else {
             endvindex = startvindex + (words / wordsperentry) - 1;
         }
        
 
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        wp = (((uint32 *) tm->entrydmabuf) + wordoff);
        /* Assumption here: OCM dma never returns less than requested */
        entries = (endvindex - startvindex + 1);
        while (entries) {
              v = *wp;
            if (!sets || *sets++) {
                  v0 = *vs << shift;
 
                  v = ((v & mask) | v0);
                  *wp = v;
              } 
              wp += wordsperentry;
              vs++;
              entries--;
        }
        s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                       startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        
        words -= (endvindex - startvindex + 1) * wordsperentry;
        startvindex = endvindex + 1;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_t3p1_entry_generic_fast_small_set(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, /* offset, */ fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, mask, word;
    uint32 *wp, *lastvs;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_t3p1_memory_desc_t *md = &tm->memories[tb->memory];

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
 /*   offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth));  */
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];
    ocmport = tb->memory;
    segment = tb->segment;

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
            endvindex = startvindex + burstwords / eb->stridebits;
        }
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
                startfringe++;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
            windex++;
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {
            word = 0;
            mask = 0;
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                word = _shr_swap32(word);
                mask = _shr_swap32(mask);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        if (endfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift;
            while (vs != lastvs) {
                if (!sets || *sets++) {
                    mask |= fieldmask << shift;
                    word |= (*vs << shift);
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                       startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        startvindex = endvindex;
        dmawords -= burstwords;
        windex = 0;
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}
int soc_sbx_t3p1_entry_generic_fast_set(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_t3p1_entry_generic_fast_small_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    } else {
        s = soc_sbx_t3p1_entry_generic_fast_word_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    }

    return s;
}

int soc_sbx_t3p1_entry_generic_fast_word_get(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, /* addrshift,  mwidth, offset, */
        v, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb;
    soc_sbx_t3p1_entry_bank_t *eb = NULL;
    soc_sbx_t3p1_memory_desc_t *md __attribute__((unused));
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
/*    mwidth = md->width;  */
    ocmport = tb->memory;
    segment = tb->segment;

/*    addrshift = md->width > 32 ? 1 : 0;  */
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
/*    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth)); */
    words = (endvindex - startvindex + 1) * wordsperentry;

    while (words) {
        if (words > tm->bufsize) {
            endvindex = (startvindex + tm->bufsize / wordsperentry ) - 1;
        } else {
             endvindex = startvindex + (words / wordsperentry) - 1;
        }
        
         
 
         /* This function works on inclusive range for indices.
          *
          * That is, last item retrieved should be startvindex == endvindex and every
          * iteration needs to get 1 less than current computation for endvindex!
          */
        
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        wp = (((uint32 *) tm->entrydmabuf) + wordoff);
        /* Assumption here: OCM dma never returns less than requested */
        entries = (endvindex - startvindex + 1);

        while (entries) {
            v = *wp;       
            *vs = (v >> shift) & mask;
            wp += wordsperentry;
            vs++;
            entries--;
        }
        
        words -= (endvindex - startvindex + 1) * wordsperentry;
        startvindex = endvindex + 1;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_t3p1_entry_generic_fast_small_get(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, /*  offset, */ fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, word;
    uint32 *wp, *lastvs, tmp;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_t3p1_memory_desc_t *md = &tm->memories[tb->memory];

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;
    ocmport = tb->memory;
    segment = tb->segment;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
/*    offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth)); */
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
            endvindex = startvindex + burstwords / eb->stridebits;
        }
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            word = wp[windex];
            windex++;
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                /* coverity[large_shift] */
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
                startfringe++;
            }
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {

            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                if (entryshift <=8){
                  *vs = (word >> (( ( ((shift/8)*2)+1)*8)- entryshift -shift)) & fieldmask;
                } else {
                  tmp= (word >> shift) & fieldmask;
                  *vs = ((tmp&0xff00)>>8) + ((tmp&0xff)<<8) ;
                }
                vs++;
                shift += entryshift;
            }
        }

        if (endfringe) {
            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            while (vs != lastvs) {
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
            }
        }
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}

int soc_sbx_t3p1_entry_generic_fast_get(int unit,
                soc_sbx_t3p1_field_desc_t *fd,
                soc_sbx_t3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_t3p1_entry_generic_fast_small_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    } else {
        s = soc_sbx_t3p1_entry_generic_fast_word_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    }

    return s;
}
void soc_sbx_t3p1_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    char *s;
    char c;

    if (d >= 0) {
        sal_snprintf(sym, symlen, "%s%s%s%d%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     d,
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    } else {
        sal_snprintf(sym, symlen, "%s%s%s%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    }

    for (s = sym; (c = *s); s++) {
        if ('a' <= c && c <= 'z') {
            *s = c - ('a' - 'A');
        }
    }
}
int soc_sbx_t3p1_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    rv = UTG_SYM_GET(fe->unit, fe->ucode, sym, (uint32 *) v);
    if (rv != 0 && rv != 6) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: Cannot locate %s\n"), "soc_sbx_t3p1_ucode_get", sym));
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a symbol from the microcode package */
int soc_sbx_t3p1_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (UTG_SYM_SET(fe->unit, fe->ucode, sym, v)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: Cannot locate %s\n"), "", sym));
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}
int soc_sbx_t3p1_index_find(
                soc_sbx_t3p1_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nindexes; i++) {
        if (!sal_strcasecmp(a, ed->indexes[i].name)) {
          return i;
        }
        l = sal_strlen(ed->indexes[i].name);
        if (!sal_strncasecmp(a, ed->indexes[i].name, l)
            && a[l] == '=') {
          return i;
      }
    }
    return -1;
}
/* Read a sequence of index arguments */
int soc_sbx_t3p1_indexes_read(void **idxs,
                soc_sbx_t3p1_entry_desc_t *ed, int argc, char **argv)
{
    int rv, i, noarg0, bytes, n = 0;
    
    for (i = 0; i < ed->nindexes; i++) {
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes < 4) { bytes = 4; }
        sal_memset(idxs[i], 0, bytes);
    }

    while (argc) {
        i = soc_sbx_t3p1_index_find(ed, *argv);
        noarg0 = i < 0;
        if (noarg0) {
            i = 0;
            if (n != 0 || ed->nindexes != 1) {
                break;
            }
        }

        if (ed->indexes[i].width > 32) {
            rv = soc_sbx_t3p1_big_value_read(idxs[i],
                           ed->indexes[i].width, noarg0, argc, argv);
        } else {
            rv = soc_sbx_t3p1_value_read(idxs[i],
                          ed->indexes[i].range, noarg0, argc, argv);
        }
        if (rv < 0) {
            return -1;
        }
        if (rv == 0) {
            break;
        }
        n += rv;
        argc -= rv;
        argv += rv;
    }
    return n;
}
/* Print a sequence of indexes */
void soc_sbx_t3p1_indexes_print(void **indexpointers,
                soc_sbx_t3p1_entry_desc_t *ed)
{
    int i, j;
    int bytes;

    LOG_CLI((BSL_META("%s["), ed->name));
    for (i = 0; i < ed->nindexes; i++) {
        LOG_CLI((BSL_META("%s="), ed->indexes[i].name));
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes > 4) {
            for (j = 0; j < bytes; j++) {
                LOG_CLI((BSL_META("0x%02x%s"),
                         ((uint8 *) indexpointers[i])[j],
                         j < bytes - 1 ? " " : ""));
            }
        } else {
            soc_sbx_t3p1_print(ed->indexes[i].range,
                   *((uint32 *) indexpointers[i]));
        }
        if (i + 1 < ed->nindexes) {
            LOG_CLI((BSL_META(" ")));
        }
    }
    LOG_CLI((BSL_META("]:\n")));
}
/* Parse range arguments with optional flags */
int soc_sbx_t3p1_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name)
{
    int max, rv;
    int num = 0;
    char *s;

    max = *upper + 1;
    while (argc) {
        s = argv[0];
        if (f0name && !sal_strcasecmp(s, f0name)) {
            *f0 = 1;
        } else if (f0name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f0name)) {
            *f0 = 0;
        } else if (f1name && !sal_strcasecmp(s, f1name)) {
            *f1 = 1;
        } else if (f1name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f1name)) {
            *f1 = 0;
        } else if (f2name && !sal_strcasecmp(s, f2name)) {
            *f2 = 1;
        } else if (f2name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f2name)) {
            *f2 = 0;
        } else {
            rv = soc_sbx_t3p1_read(s, max, (uint32 *) lower);
            if (rv == SOC_E_NONE) {
                for(s = *argv; *s && *s != '-'; s++);
                if (*s) {
                    s++;
                    rv = soc_sbx_t3p1_read(s, max, (uint32 *) upper);
                    if (rv) {
                        LOG_CLI((BSL_META("illegal upper bound in range %s\n"), s));
                        return SOC_E_FAIL;
                    }
                } else if (argc > 1) {
                    rv = soc_sbx_t3p1_read(argv[1], max, (uint32 *) &num);
                    if (rv == SOC_E_NONE) {
                        *upper = *lower + num - 1;
                        if (*upper >= max) {
                            LOG_CLI((BSL_META("%s overflows the legal range\n"),
                                     argv[1]));
                            return SOC_E_NONE;
                        }
                        argv++;
                        argc--;
                    } else {
                        *upper = *lower;
                    }
                } else {
                    *upper = *lower;
                }
            } else {
                LOG_CLI((BSL_META("unexpected argument: %s\n"), s));
                return SOC_E_PARAM;
            }
        }
        argv++;
        argc--;
    }
    return SOC_E_NONE;
}
/* Find an entry field from a name */
int soc_sbx_t3p1_field_find(
                soc_sbx_t3p1_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nfields; i++) {
        if (!sal_strcasecmp(a, ed->fields[i].name)) {
          return i;
        }
        l = sal_strlen(ed->fields[i].name);
        if (!sal_strncasecmp(a, ed->fields[i].name, l)
            && a[l] == '=') {
          return i;
      }
      
    }
    return -1;
}

/* Update the base of a table bank */
int soc_sbx_t3p1_table_bank_base_set(int unit,
                int tid, int bank, int base)
{
    int s;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[tid];
    char *e = "";

    td->banks[bank].base = base;
     
    s = soc_sbx_t3p1_ucode_set(unit, soc_sbx_t3p1_sym, 128,
                base, e, td->name, bank == 0 ? -1 : bank, e, "BASE");
    return s;
}

/* Get the table bank given a segment and address */
int soc_sbx_t3p1_table_bank_get(soc_sbx_t3p1_table_manager_t *tm, 
                   sbx_caladan3_ocm_port_e_t port, int segment, int addr,
                   soc_sbx_t3p1_table_bank_t **bank)

{
    int i, j;
    soc_sbx_t3p1_table_desc_t *td;
    soc_sbx_t3p1_table_bank_t *tb;

    if (bank) {
        for (i = 0; i < SOC_SBX_T3P1_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            for (j = 0; j < td->nbanks; j++) {
                tb = &td->banks[j];
                if (tb->segment == segment && tb->memory == port) {
                    if ((addr >= tb->base) && (addr <= (tb->base + tb->size * tb->width))) {
                        /* table bank found */
                        *bank = tb;
                        return SOC_E_NONE;
                    }
                }
            }
        }
        *bank = NULL;
    }
    return SOC_E_NOT_FOUND;
}

/* Get the ocm port given a memory  */
void soc_sbx_t3p1_ocm_port_get(int mid, sbx_caladan3_ocm_port_e_t *ocmport)
{
    if (ocmport) {
        switch (mid) {
        case SOC_SBX_T3P1_LRP_PORT0_ID:
            *ocmport = 0;
        case SOC_SBX_T3P1_LRP_PORT1_ID:
            *ocmport = 1;
        case SOC_SBX_T3P1_LRP_PORT8_ID:
            *ocmport = 11;
        case SOC_SBX_T3P1_LRP_PORT2_ID:
            *ocmport = 2;
        case SOC_SBX_T3P1_LRP_PORT3_ID:
            *ocmport = 3;
        case SOC_SBX_T3P1_LRP_PORT4_ID:
            *ocmport = 4;
        case SOC_SBX_T3P1_CMU0_PORT_ID:
            *ocmport = 6;
        case SOC_SBX_T3P1_COP0_PORT_ID:
            *ocmport = 7;
        case SOC_SBX_T3P1_BUBBLE_PORT_ID:
            *ocmport = 8;
        case SOC_SBX_T3P1_LRP_PORT5_ID:
            *ocmport = 5;
        case SOC_SBX_T3P1_LRP_PORT9_ID:
            *ocmport = 12;
        case SOC_SBX_T3P1_LRP_PORT6_ID:
            *ocmport = 9;
        case SOC_SBX_T3P1_LRP_PORT7_ID:
            *ocmport = 10;
        case SOC_SBX_T3P1_CMU1_PORT_ID:
            *ocmport = 13;
        case SOC_SBX_T3P1_COP1_PORT_ID:
            *ocmport = 14;
        default:
            LOG_CLI((BSL_META("Invalid port or incomplete mapping, abort!")));
            assert(0);
        }
    }
}

/* Sets a memory bank base */
int soc_sbx_t3p1_memory_bank_base_set(int unit,
                soc_sbx_t3p1_memory_bank_desc_t *mb, int base)
{
    int s = SOC_E_INTERNAL;

    switch (mb->type) {
    case SOC_SBX_T3P1_TABLE_BANK_TYPE:
        s = soc_sbx_t3p1_table_bank_base_set(unit,
                      mb->number, mb->bank, base);
        break;
      default:
         break;
    }

    return s;
}

/* Get the base & size of a bank in a memory */
void soc_sbx_t3p1_memory_bank_params_get(int *base, int *size,
                soc_sbx_t3p1_memory_bank_desc_t *mb,
                soc_sbx_t3p1_table_manager_t *tm)
{
    soc_sbx_t3p1_table_bank_t *tb;

    switch (mb->type) {
    case SOC_SBX_T3P1_TABLE_BANK_TYPE:
        tb = &tm->tables[mb->number].banks[mb->bank];
        *base = tb->base;
        *size = tb->limit - tb->base;
        break;
      default:
        *base=0;
        *size=0;     
        break;

    }
}

/* Pack all memory banks based on current sizes */
int soc_sbx_t3p1_memory_banks_pack(int unit)
{
    int s = SOC_E_NONE;
    int i, j, base, size;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_memory_desc_t *md;
    soc_sbx_t3p1_memory_bank_desc_t *mb;

    for (i = 0; !s && i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; !s && j < md->nbanks; j++) {
            mb = &md->banks[j];
            if (j) {
                soc_sbx_t3p1_memory_bank_params_get(&base, &size,
                          &md->banks[j - 1], tm);
            } else {
                base = 0;
                size = 0;
            }
            base = base + size;
            s = soc_sbx_t3p1_memory_bank_base_set(unit, mb, base);
        }
    }

    return s;
}

/* Slide the base of all banks from a starting bank in a memory */
int soc_sbx_t3p1_bank_slide(int unit,
                soc_sbx_t3p1_memory_desc_t *md,
                int mbank, int offset)
{
    int s = SOC_E_NONE;
    int i, base, size;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_memory_bank_desc_t *mb;

    for (i = mbank; !s && i < md->nbanks; i++) {
        mb = &md->banks[i];
        soc_sbx_t3p1_memory_bank_params_get(&base, &size, mb, tm);
        s = soc_sbx_t3p1_memory_bank_base_set(unit, mb, base + offset);
    }

    return SOC_E_NONE;
}

/* Realign aligned table banks */
int soc_sbx_t3p1_tables_realign(int unit)
{
    int s, tid, first, i, maxbase, mbank, base, size, offset;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td;
    soc_sbx_t3p1_table_bank_t *tb;
    soc_sbx_t3p1_memory_desc_t *md;

    for (tid = tm->alignedlist; tid != -1; tid = td->nextaligned) {
        td = &tm->tables[tid];
        if (td->banks[0].size == 0) continue;
        maxbase = 0;
        first = (td->type == SOC_SBX_T3P1_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_T3P1_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            mbank = tb->mbank;
            md = &tm->memories[tb->memory];
            if (mbank > 0) {
                soc_sbx_t3p1_memory_bank_params_get(&base, &size,
                          &md->banks[mbank - 1], tm);
                if (maxbase < base + size) {
                    maxbase = base + size;
                }
            }
        }
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            offset = maxbase - tb->base;
            md = &tm->memories[tb->memory];
            s = soc_sbx_t3p1_bank_slide(unit, md, tb->mbank, offset);
            if (s) {
                return s;
            }
        }
    }

    return SOC_E_NONE;
}

/* Set an entry index range from a table size */
void soc_sbx_t3p1_entry_index_ranges_set(int unit,
                soc_sbx_t3p1_entry_id_t eid)
{
    int i, j, isize, max;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[eid];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    
    i = ed->nindexes - 1;
    if (ed->table != SOC_SBX_T3P1_TABLE_MAX_ID
        && ed->type != SOC_SBX_T3P1_EXT_ENTRY_TYPE
        && ed->type != SOC_SBX_T3P1_LPM_ENTRY_TYPE
        && ed->type != SOC_SBX_T3P1_EML_ENTRY_TYPE
        && ed->type != SOC_SBX_T3P1_EM32_ENTRY_TYPE) {

        isize = (tb->size * tb->width / eb->stridebits) - 1;
        for (; 0 <= i; i--) {
            max = isize >> ed->indexes[i].pos;
            if (max) {
                ed->indexes[i].range = max + 1;
                if (i == ed->nindexes - 1) {
                    for (j = 1; 1 << j < max; j++);
                    ed->indexes[i].width = j;
                    ed->indexeswidth =
                        ed->indexes[i].pos + ed->indexes[i].width;
                }
                i--;
                break;
            } else {
                ed->indexes[i].range = 1;
            }
        }
    }
    for (; 0 <= i; i--) {
        ed->indexes[i].range = ed->indexes[i].orange;
    }
}

/* Set the size of a table */
int soc_sbx_t3p1_generic_table_size_set(int unit,
                soc_sbx_t3p1_table_id_t tid, int size, int pack)
{
    int s, i, size0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[tid];
    soc_sbx_t3p1_table_bank_t *tb;
    soc_sbx_t3p1_entry_desc_t *ed;
    char *e = "";


    for (i = 0; i < td->nbanks; i++) {
        tb = &td->banks[i];
        size0 = (size && !i && td->b0size) ? td->b0size : size;
        tb->size = size0;
        s = soc_sbx_t3p1_ucode_set(unit,
                    soc_sbx_t3p1_sym, 128,
                    size0, e, td->name, i == 0 ? -1 : i, e,
                    "SIZE");
        if (s) {
            return s;
        }
    }

    if (pack) {
        s = soc_sbx_t3p1_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_t3p1_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
        ed = &tm->entries[i];
        if (ed->table == tid) {
            soc_sbx_t3p1_entry_index_ranges_set(unit, i);
        }
    }

    return SOC_E_NONE;
}

void soc_sbx_t3p1_memory_bank_sort(int size,
                soc_sbx_t3p1_memory_bank_desc_t *mb,
                soc_sbx_t3p1_table_manager_t *tm)
{
    int i, j;
    int basea, sizea, baseb, sizeb;
    int t;

    for (i = 0; i < size; i++) {
        soc_sbx_t3p1_memory_bank_params_get(&basea, &sizea, &mb[i], tm);
        for (j = i + 1; j < size; j++) {
            soc_sbx_t3p1_memory_bank_params_get(&baseb, &sizeb, &mb[j], tm);
            if (baseb < basea) {
                t = mb[i].type;
                mb[i].type = mb[j].type;
                mb[j].type = t;
                t = mb[i].number;
                mb[i].number = mb[j].number;
                mb[j].number = t;
                t = mb[i].bank;
                mb[i].bank = mb[j].bank;
                mb[j].bank = t;
                basea = baseb;
                sizea = sizeb;
            }
        }
    }
}
void soc_sbx_t3p1_memory_banks_init(soc_sbx_t3p1_table_manager_t *tm)
{
    int i, j, k;
    int p = 0;
    soc_sbx_t3p1_memory_desc_t *md;
    soc_sbx_t3p1_memory_bank_desc_t *mb;

    for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        md->banks = &tm->memorybanks[p];
        md->nbanks = 0;
        for (j = 0; j < SOC_SBX_T3P1_TABLE_MAX_ID; j++) {
            for (k = 0; k < tm->tables[j].nbanks; k++) {
                  /* coverity[mixed_enums] */
                if (tm->tables[j].banks[k].memory == i) {
                    tm->memorybanks[p].type =
                        SOC_SBX_T3P1_TABLE_BANK_TYPE;
                    tm->memorybanks[p].number = j;
                    tm->memorybanks[p].bank = k;
                    p++;
                    md->nbanks++;
                }
            }
        }
    }

    for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        soc_sbx_t3p1_memory_bank_sort(md->nbanks, md->banks, tm);
        for (j = md->nbanks - 1; 0 <= j; j--) {
            mb = &md->banks[j];
            switch (mb->type) {
            case SOC_SBX_T3P1_TABLE_BANK_TYPE:
                tm->tables[mb->number].banks[mb->bank].mbank = j;
                if (tm->tables[mb->number].nextaligned) {
                    mb->nextaligned = md->alignedlist;
                    md->alignedlist = j;
                }
                break;
             default:
                 break;
            }
        }
    }
}

/* Find a memory bank member by address */
int soc_sbx_t3p1_memory_bank_find(
                soc_sbx_t3p1_table_manager_t *tm,
                soc_sbx_t3p1_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt)
{
    /* no counters */
    return SOC_E_PARAM;
}




static int soc_sbx_t3p1_consts_init(int unit, soc_sbx_t3p1_table_manager_t *tm) {  
	
 	/*
     * Per-constant state initialization
     */
    tm->constants = UTG_MALLOC(sizeof(soc_sbx_t3p1_constant_desc_t)
                           * SOC_SBX_T3P1_CONSTANT_MAX_ID);
    if (!tm->constants) {
      	return SOC_E_MEMORY;
    }

	tm->constants[SOC_SBX_T3P1_HTYPE_NULL_ID].name =
	        "htype_null";
	tm->constants[SOC_SBX_T3P1_HLEN_NULL_ID].name =
	        "hlen_null";
	tm->constants[SOC_SBX_T3P1_HTYPE_ETYPE_ID].name =
	        "htype_etype";
	tm->constants[SOC_SBX_T3P1_HLEN_ETYPE_ID].name =
	        "hlen_etype";
	tm->constants[SOC_SBX_T3P1_HTYPE_ETH_ID].name =
	        "htype_eth";
	tm->constants[SOC_SBX_T3P1_HLEN_ETH_ID].name =
	        "hlen_eth";
	tm->constants[SOC_SBX_T3P1_HTYPE_IETH_ID].name =
	        "htype_ieth";
	tm->constants[SOC_SBX_T3P1_HTYPE_LLC_ID].name =
	        "htype_llc";
	tm->constants[SOC_SBX_T3P1_HLEN_LLC_ID].name =
	        "hlen_llc";
	tm->constants[SOC_SBX_T3P1_HTYPE_SNAP_ID].name =
	        "htype_snap";
	tm->constants[SOC_SBX_T3P1_HLEN_SNAP_ID].name =
	        "hlen_snap";
	tm->constants[SOC_SBX_T3P1_HTYPE_VTAG_ID].name =
	        "htype_vtag";
	tm->constants[SOC_SBX_T3P1_HLEN_VTAG_ID].name =
	        "hlen_vtag";
	tm->constants[SOC_SBX_T3P1_HTYPE_DVTAG_ID].name =
	        "htype_dvtag";
	tm->constants[SOC_SBX_T3P1_HTYPE_MPLS_ID].name =
	        "htype_mpls";
	tm->constants[SOC_SBX_T3P1_HLEN_MPLS_ID].name =
	        "hlen_mpls";
	tm->constants[SOC_SBX_T3P1_HTYPE_IPV4_ID].name =
	        "htype_ipv4";
	tm->constants[SOC_SBX_T3P1_HLEN_IPV4_ID].name =
	        "hlen_ipv4";
	tm->constants[SOC_SBX_T3P1_HTYPE_IPV6_ID].name =
	        "htype_ipv6";
	tm->constants[SOC_SBX_T3P1_HLEN_IPV6_ID].name =
	        "hlen_ipv6";
	tm->constants[SOC_SBX_T3P1_HTYPE_UDP_ID].name =
	        "htype_udp";
	tm->constants[SOC_SBX_T3P1_HLEN_UDP_ID].name =
	        "hlen_udp";
	tm->constants[SOC_SBX_T3P1_HTYPE_TCP_ID].name =
	        "htype_tcp";
	tm->constants[SOC_SBX_T3P1_HLEN_TCP_ID].name =
	        "hlen_tcp";
	tm->constants[SOC_SBX_T3P1_HTYPE_ACH_ID].name =
	        "htype_ach";
	tm->constants[SOC_SBX_T3P1_HLEN_ACH_ID].name =
	        "hlen_ach";
	tm->constants[SOC_SBX_T3P1_HTYPE_PTP_ID].name =
	        "htype_ptp";
	tm->constants[SOC_SBX_T3P1_HLEN_PTP_ID].name =
	        "hlen_ptp";
	tm->constants[SOC_SBX_T3P1_HTYPE_MIM_ID].name =
	        "htype_mim";
	tm->constants[SOC_SBX_T3P1_HLEN_MIM_ID].name =
	        "hlen_mim";
	tm->constants[SOC_SBX_T3P1_HTYPE_ELEN_ID].name =
	        "htype_elen";
	tm->constants[SOC_SBX_T3P1_HLEN_ELEN_ID].name =
	        "hlen_elen";
	tm->constants[SOC_SBX_T3P1_HTYPE_ERH_ID].name =
	        "htype_erh";
	tm->constants[SOC_SBX_T3P1_HLEN_ERH_ID].name =
	        "hlen_erh";
	tm->constants[SOC_SBX_T3P1_HTYPE_TMH_ID].name =
	        "htype_tmh";
	tm->constants[SOC_SBX_T3P1_HLEN_TMH_ID].name =
	        "hlen_tmh";
	tm->constants[SOC_SBX_T3P1_HTYPE_KSOP_ID].name =
	        "htype_ksop";
	tm->constants[SOC_SBX_T3P1_HLEN_KSOP_ID].name =
	        "hlen_ksop";
	tm->constants[SOC_SBX_T3P1_HTYPE_CUSTOM_ID].name =
	        "htype_custom";
	tm->constants[SOC_SBX_T3P1_HLEN_CUSTOM_ID].name =
	        "hlen_custom";
	tm->constants[SOC_SBX_T3P1_HTYPE_UNKN_ID].name =
	        "htype_unkn";
	
	return SOC_E_NONE;
}
	


static int soc_sbx_t3p1_globals_init(int unit, soc_sbx_t3p1_table_manager_t *tm) {  

	int i, s;
	char *e = "";
	
 	/*
     * Global value initialization
     */
    tm->globals = UTG_MALLOC(sizeof(soc_sbx_t3p1_memory_desc_t)
                         * SOC_SBX_T3P1_GLOBAL_MAX_ID);
    if (!tm->globals) {
        return SOC_E_MEMORY;
    }

	tm->globals[SOC_SBX_T3P1_CONTEXTS_ID].name =
	        "contexts";
	tm->globals[SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID].name =
	        "debug_stream_elen";
	tm->globals[SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID].name =
	        "c3_sws_static_page";
	tm->globals[SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].name =
	        "c3_sws_ingress_bubble_squeue";
	tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].name =
	        "c3_sws_fab_to_line_redirect_qid0";
	tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].name =
	        "c3_sws_fab_to_line_redirect_qid1";
	tm->globals[SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].name =
	        "c3_sws_egress_bubble_squeue";
	tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].name =
	        "c3_sws_line_to_fab_redirect_qid0";
	tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].name =
	        "c3_sws_line_to_fab_redirect_qid1";
	tm->globals[SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID].name =
	        "ingress_replication_count";
	tm->globals[SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID].name =
	        "egress_replication_count";
	tm->globals[SOC_SBX_T3P1_FLUSH_PORT_ID].name =
	        "flush_port";
	tm->globals[SOC_SBX_T3P1_MAC_LIMIT_ID].name =
	        "mac_limit";
	
	for (i = 0; i < SOC_SBX_T3P1_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->globals[i].range,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  "RANGE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->globals[i].value,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }
    
    return SOC_E_NONE;
}

int soc_sbx_t3p1_globals_reinit(int unit) {  
    int i, s COMPILER_ATTRIBUTE((unused));
    char *e = "";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->globals[i].value,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
    }
    
    return SOC_E_NONE;
}


/*
 * Shared constant accessors implementation
 */
int soc_sbx_t3p1_htype_null_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_NULL";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_null_get(int unit, uint32 *vp)
{
    char *s = "HLEN_NULL";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_etype_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETYPE";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_etype_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ETYPE";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_eth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_eth_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ETH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ieth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IETH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_llc_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_LLC";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_llc_get(int unit, uint32 *vp)
{
    char *s = "HLEN_LLC";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_snap_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_SNAP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_snap_get(int unit, uint32 *vp)
{
    char *s = "HLEN_SNAP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_vtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_VTAG";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_vtag_get(int unit, uint32 *vp)
{
    char *s = "HLEN_VTAG";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_dvtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_DVTAG";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_mpls_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MPLS";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_mpls_get(int unit, uint32 *vp)
{
    char *s = "HLEN_MPLS";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV4";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HLEN_IPV4";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ipv6_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV6";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_ipv6_get(int unit, uint32 *vp)
{
    char *s = "HLEN_IPV6";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_udp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UDP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_udp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_UDP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_tcp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_TCP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_tcp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_TCP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ach_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ACH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_ach_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ACH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ptp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_PTP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_ptp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_PTP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_mim_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MIM";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_mim_get(int unit, uint32 *vp)
{
    char *s = "HLEN_MIM";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_elen_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ELEN";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_elen_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ELEN";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_erh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ERH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_erh_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ERH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_tmh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_TMH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_tmh_get(int unit, uint32 *vp)
{
    char *s = "HLEN_TMH";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_ksop_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_KSOP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_ksop_get(int unit, uint32 *vp)
{
    char *s = "HLEN_KSOP";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_custom_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_CUSTOM";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_hlen_custom_get(int unit, uint32 *vp)
{
    char *s = "HLEN_CUSTOM";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}


int soc_sbx_t3p1_htype_unkn_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UNKN";
    soc_sbx_t3p1_errsym = s;
    return soc_sbx_t3p1_constant_get(unit, s, vp);
}





int soc_sbx_t3p1_contexts_set(int unit, uint32 v)
{
    int s;
    char *sym = "CONTEXTS";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_CONTEXTS_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_CONTEXTS_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_contexts_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_CONTEXTS_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_debug_stream_elen_set(int unit, uint32 v)
{
    int s;
    char *sym = "DEBUG_STREAM_ELEN";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_debug_stream_elen_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_static_page_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_STATIC_PAGE";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_static_page_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_ingress_bubble_squeue_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_INGRESS_BUBBLE_SQUEUE";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_ingress_bubble_squeue_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_FAB_TO_LINE_REDIRECT_QID0";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid0_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_FAB_TO_LINE_REDIRECT_QID1";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid1_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_egress_bubble_squeue_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_EGRESS_BUBBLE_SQUEUE";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_egress_bubble_squeue_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_LINE_TO_FAB_REDIRECT_QID0";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid0_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_LINE_TO_FAB_REDIRECT_QID1";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid1_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_ingress_replication_count_set(int unit, uint32 v)
{
    int s;
    char *sym = "INGRESS_REPLICATION_COUNT";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_ingress_replication_count_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_egress_replication_count_set(int unit, uint32 v)
{
    int s;
    char *sym = "EGRESS_REPLICATION_COUNT";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_egress_replication_count_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_flush_port_set(int unit, uint32 v)
{
    int s;
    char *sym = "FLUSH_PORT";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_FLUSH_PORT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_FLUSH_PORT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_flush_port_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_FLUSH_PORT_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_t3p1_mac_limit_set(int unit, uint32 v)
{
    int s;
    char *sym = "MAC_LIMIT";
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_T3P1_MAC_LIMIT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_t3p1_errsym = sym;
    s = soc_sbx_t3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_T3P1_MAC_LIMIT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_mac_limit_get(int unit, uint32 *vp)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_T3P1_MAC_LIMIT_ID].value;

    return SOC_E_NONE;
}






static int soc_sbx_t3p1_tables_init(int unit, soc_sbx_t3p1_table_manager_t *tm) {  

	int i, s, j, m, p;
	char *e = "";
	int port_init[SOC_SBX_T3P1_MEMORY_MAX_ID] = {6,13,7,14,12,11,10,2,3,4,5,8,9,0,1};
	
	/*
     * Per-table state initialization
     */
    tm->tables = UTG_MALLOC(sizeof(soc_sbx_t3p1_table_desc_t)
                         * SOC_SBX_T3P1_TABLE_MAX_ID);
    if (!tm->tables) {
        soc_sbx_t3p1_uninit(unit);
        return SOC_E_MEMORY;
    }
    sal_memset(tm->tables, 0, sizeof(soc_sbx_t3p1_table_desc_t)
           * SOC_SBX_T3P1_TABLE_MAX_ID);
           
    tm->tables[SOC_SBX_T3P1_LAG_TABLE_ID].name =
            "lag";        
    tm->tables[SOC_SBX_T3P1_VLAN_TABLE_ID].name =
            "vlan";        
    tm->tables[SOC_SBX_T3P1_IRT_TABLE_ID].name =
            "irt";        
    tm->tables[SOC_SBX_T3P1_OAM_BUBBLE_TABLE_ID].name =
            "oam_bubble";        
    tm->tables[SOC_SBX_T3P1_DEMOAGE_TABLE_ID].name =
            "demoage";        
    tm->tables[SOC_SBX_T3P1_DEMOAGEID_TABLE_ID].name =
            "demoageid";        
    
    for (i = 0; i < SOC_SBX_T3P1_TABLE_MAX_ID; i++) {
        if (!tm->tables[i].name) {
            /* Caladan3 complex tables not supported yet, skipping */
            continue;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->tables[i].nbanks,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_BANKS");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &j,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_ALIGN");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        tm->tables[i].nextaligned = j ? -2 : 0;
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->tables[i].type,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_TYPE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        for (j = 0; j < tm->tables[i].nbanks; j++) {

            int nb = tm->tables[i].nbanks;

            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].memory,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "MEMORY");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].base,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "BASE");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].size,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SIZE");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].width,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "TABLE_WIDTH");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].segment,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SEGMENT");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].segflags,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SEGMENT_FLAGS");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                      soc_sbx_t3p1_sym,
                      128,
                      &tm->tables[i].banks[j].limit,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "LIMIT");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
        }
    }
    for (p = 0;p < SOC_SBX_T3P1_MEMORY_MAX_ID;p++) {
        m = port_init[p];
            
        for (i = 0; i < SOC_SBX_T3P1_TABLE_MAX_ID; i++) {
            if (!tm->tables[i].name) {
               /* Caladan3 complex tables not supported yet, skipping */
               continue;
            }
            for (j = 0; j < tm->tables[i].nbanks; j++) {
                sbx_caladan3_ocm_port_alloc_t segalloc = {0};
                if (tm->tables[i].banks[j].memory != m) {
                    /* Skipping reverse allocation scheme */
                    continue;
                }
                if (tm->tables[i].banks[j].segflags & 1 || tm->tables[i].banks[j].segflags & 8) {
                    /* Skipping Overlap or overlayed segments */
                    continue;
                }

                 /* Table Id ZERO is reserved per OCM API. Start our IDs "+1" */
                 segalloc.table_id = i + 1;
                 segalloc.bank_id = j + 1;

                segalloc.segment = tm->tables[i].banks[j].segment;
                segalloc.port = tm->tables[i].banks[j].memory;
                /*segalloc.size = tm->tables[i].banks[j].size;*/
                segalloc.size = tm->tables[i].banks[j].limit - tm->tables[i].banks[j].base;
                segalloc.datum_size = tm->tables[i].banks[j].width;
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nAttempting to allocate for table %s"), tm->tables[i].name));
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\n    Port %d Segment %d Flags:0x%08x"), segalloc.port, segalloc.segment, tm->tables[i].banks[j].segflags));
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\n    Base: %x Limit %x Size %d Width %d"), 
                          tm->tables[i].banks[j].base, tm->tables[i].banks[j].limit,
                          segalloc.size, segalloc.datum_size));

                if (segalloc.segment >= 0) {            
	                if (!(tm->tables[i].banks[j].segflags & 2)) {
                        s = soc_sbx_caladan3_ocm_port_segment_alloc(unit, &segalloc);
              	 	 } else if ((tm->tables[i].banks[j].segflags & 2) && (tm->tables[i].banks[j].segflags & 4)) {
                        segalloc.size = (tm->tables[i].banks[j].limit - tm->tables[i].banks[j].base) * tm->tables[i].nbanks;
                        /*  LOG_CLI((BSL_META_U(unit,
                                                "%s: Allocating interleaved table size:%d\n"), __func__, segalloc.size)); */
                        s = soc_sbx_caladan3_ocm_port_segment_alloc(unit, &segalloc);
              	 	 } else {
                    	s = SOC_E_NONE;
              	  }                                  
                } else {
                    s = soc_sbx_caladan3_ocm_port_mem_alloc(unit, &segalloc);
                }

                if (SOC_FAILURE(s)) {
                    soc_sbx_t3p1_uninit(unit);
                    return s;
                }
            }
        }
    }

	return SOC_E_NONE;
}

static int soc_sbx_t3p1_entries_init(int unit, soc_sbx_t3p1_table_manager_t *tm) {  

	int i, s, j;
	char *e = "";
	
	/*
     * Per-entry state initialization
     */
    tm->entries = UTG_MALLOC(sizeof(soc_sbx_t3p1_entry_desc_t)
                         * SOC_SBX_T3P1_ENTRY_MAX_ID);
    if (!tm->entries) {
        return SOC_E_MEMORY;
    }
    

    tm->entries[SOC_SBX_T3P1_LAG_ID].name =
            "lag";
    tm->entries[SOC_SBX_T3P1_LAG_ID].table =
        SOC_SBX_T3P1_LAG_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_LAG_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_lag_pack;
    tm->entries[SOC_SBX_T3P1_LAG_ID].esize =
        sizeof(soc_sbx_t3p1_lag_t);
    tm->entries[SOC_SBX_T3P1_LAG_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_LAG_ID].nfields = 2;


    tm->entries[SOC_SBX_T3P1_VLAN_ID].name =
            "vlan";
    tm->entries[SOC_SBX_T3P1_VLAN_ID].table =
        SOC_SBX_T3P1_VLAN_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_VLAN_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_vlan_pack;
    tm->entries[SOC_SBX_T3P1_VLAN_ID].esize =
        sizeof(soc_sbx_t3p1_vlan_t);
    tm->entries[SOC_SBX_T3P1_VLAN_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_VLAN_ID].nfields = 2;


    tm->entries[SOC_SBX_T3P1_IRT_ID].name =
            "irt";
    tm->entries[SOC_SBX_T3P1_IRT_ID].table =
        SOC_SBX_T3P1_IRT_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_IRT_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_irt_pack;
    tm->entries[SOC_SBX_T3P1_IRT_ID].esize =
        sizeof(soc_sbx_t3p1_irt_t);
    tm->entries[SOC_SBX_T3P1_IRT_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_IRT_ID].nfields = 15;


    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].name =
            "oam_bubble";
    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].table =
        SOC_SBX_T3P1_OAM_BUBBLE_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_oam_bubble_pack;
    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].esize =
        sizeof(soc_sbx_t3p1_oam_bubble_t);
    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID].nfields = 9;


    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].name =
            "demoage";
    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].table =
        SOC_SBX_T3P1_DEMOAGE_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_demoage_pack;
    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].esize =
        sizeof(soc_sbx_t3p1_demoage_t);
    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_DEMOAGE_ID].nfields = 2;


    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].name =
            "demoageid";
    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].table =
        SOC_SBX_T3P1_DEMOAGEID_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].pack =
        (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_demoageid_pack;
    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].esize =
        sizeof(soc_sbx_t3p1_demoageid_t);
    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID].nfields = 1;

    
    for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
        if (!tm->entries[i].name) {
            /* Caladan3 complex tables not supported yet, skipping */
            continue;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_sym,
                    128,
                    &tm->entries[i].nbanks,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "BANKS");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_sym,
                    128,
                    &tm->entries[i].type,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "TYPE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        tm->entries[i].epsize = 0;
        for (j = 0; j < tm->entries[i].nbanks; j++) {
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].banks[j].tablebank,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "BANK");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].banks[j].width,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "WIDTH");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            tm->entries[i].epsize += tm->entries[i].banks[j].width;
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].banks[j].stridebits,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "STRIDE");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            tm->entries[i].totalwidth +=
                tm->entries[i].banks[j].width;
        }
    
    	/*
         * Per-index state initialization
         */
        if (tm->entries[i].nindexes) {
            tm->entries[i].indexes =
                UTG_MALLOC(sizeof(soc_sbx_t3p1_index_desc_t)
                       * tm->entries[i].nindexes);
            if (!tm->entries[i].indexes) {
                soc_sbx_t3p1_uninit(unit);
                return SOC_E_MEMORY;
            }
            sal_memset(tm->entries[i].indexes, 0, 
              (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[i].nindexes));
        }
        
        switch(i) {
         case SOC_SBX_T3P1_LAG_ID:
            tm->entries[i].indexes[0].name = "lagi";	
        	break;	
        case SOC_SBX_T3P1_VLAN_ID:
            tm->entries[i].indexes[0].name = "vlan";	
        	break;	
        case SOC_SBX_T3P1_IRT_ID:
            tm->entries[i].indexes[0].name = "irule";	
        	break;	
        case SOC_SBX_T3P1_OAM_BUBBLE_ID:
            tm->entries[i].indexes[0].name = "oamepi";	
        	break;	
        case SOC_SBX_T3P1_DEMOAGE_ID:
            tm->entries[i].indexes[0].name = "macindex";	
        	break;	
        case SOC_SBX_T3P1_DEMOAGEID_ID:
            tm->entries[i].indexes[0].name = "macindex";	
        	break;	

        }
        
        for (j = 0; j < tm->entries[i].nindexes; j++) {
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_POSITION");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].orange,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_RANGE");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            tm->entries[i].indexes[j].range
                = tm->entries[i].indexes[j].orange;
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_WIDTH");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].format,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "FORMAT");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
        }

        if (tm->entries[i].nindexes) {
            tm->entries[i].indexeswidth =
                ((tm->entries[i].indexes[tm->entries[i].nindexes - 1].pos
                  + tm->entries[i].indexes[tm->entries[i].nindexes - 1].width
                  + 7) / 8) * 8;
        }

        soc_sbx_t3p1_entry_index_ranges_set(unit, i);
        
        /*
         * Per-field state initialization
         */
        if (tm->entries[i].nfields) {
            tm->entries[i].fields =
                UTG_MALLOC(sizeof(soc_sbx_t3p1_field_desc_t)
                       * tm->entries[i].nfields);
            if (!tm->entries[i].fields) {
                return SOC_E_MEMORY;
            }
        }
        
        switch(i) {
         case SOC_SBX_T3P1_LAG_ID:
        	tm->entries[i].fields[0].name = "qid";
        	tm->entries[i].fields[1].name = "oi";
        	break;
        case SOC_SBX_T3P1_VLAN_ID:
        	tm->entries[i].fields[0].name = "qid";
        	tm->entries[i].fields[1].name = "oi";
        	break;
        case SOC_SBX_T3P1_IRT_ID:
        	tm->entries[i].fields[0].name = "vlan";
        	tm->entries[i].fields[1].name = "ftidx";
        	tm->entries[i].fields[2].name = "mirror";
        	tm->entries[i].fields[3].name = "usevlan";
        	tm->entries[i].fields[4].name = "useftidx";
        	tm->entries[i].fields[5].name = "copy";
        	tm->entries[i].fields[6].name = "dp";
        	tm->entries[i].fields[7].name = "cos";
        	tm->entries[i].fields[8].name = "fcos";
        	tm->entries[i].fields[9].name = "usedp";
        	tm->entries[i].fields[10].name = "usecos";
        	tm->entries[i].fields[11].name = "policer";
        	tm->entries[i].fields[12].name = "typedpolice";
        	tm->entries[i].fields[13].name = "mefcos";
        	tm->entries[i].fields[14].name = "mef";
        	break;
        case SOC_SBX_T3P1_OAM_BUBBLE_ID:
        	tm->entries[i].fields[0].name = "bubble_mode";
        	tm->entries[i].fields[1].name = "je";
        	tm->entries[i].fields[2].name = "i";
        	tm->entries[i].fields[3].name = "bubble_stream";
        	tm->entries[i].fields[4].name = "t";
        	tm->entries[i].fields[5].name = "interval_index";
        	tm->entries[i].fields[6].name = "reserved";
        	tm->entries[i].fields[7].name = "count";
        	tm->entries[i].fields[8].name = "timeout";
        	break;
        case SOC_SBX_T3P1_DEMOAGE_ID:
        	tm->entries[i].fields[0].name = "age";
        	tm->entries[i].fields[1].name = "age_valid";
        	break;
        case SOC_SBX_T3P1_DEMOAGEID_ID:
        	tm->entries[i].fields[0].name = "age_id";
        	break;

        }
        
        for (j = 0; j < tm->entries[i].nfields; j++) {
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].fields[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "POSITION");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].fields[j].range,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "RANGE");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_t3p1_ucode_get(unit,
                        soc_sbx_t3p1_sym,
                        128,
                        &tm->entries[i].fields[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "WIDTH");
            if (s) {
                soc_sbx_t3p1_uninit(unit);
                return s;
            }
        }
    }
    
    return SOC_E_NONE;
}

/*
 * Table state accessor implementations
 */

/* get table bank parameters for lag */
int soc_sbx_t3p1_lag_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_LAG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for lag */
int soc_sbx_t3p1_lag_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_LAG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for lag */
int soc_sbx_t3p1_lag_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_LAG_TABLE_ID, size, 1);
}

/* get table bank parameters for vlan */
int soc_sbx_t3p1_vlan_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_VLAN_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for vlan */
int soc_sbx_t3p1_vlan_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_VLAN_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for vlan */
int soc_sbx_t3p1_vlan_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_VLAN_TABLE_ID, size, 1);
}

/* get table bank parameters for irt */
int soc_sbx_t3p1_irt_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_IRT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for irt */
int soc_sbx_t3p1_irt_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_IRT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for irt */
int soc_sbx_t3p1_irt_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_IRT_TABLE_ID, size, 1);
}

/* get table bank parameters for oam_bubble */
int soc_sbx_t3p1_oam_bubble_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_OAM_BUBBLE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oam_bubble */
int soc_sbx_t3p1_oam_bubble_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_OAM_BUBBLE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oam_bubble */
int soc_sbx_t3p1_oam_bubble_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_OAM_BUBBLE_TABLE_ID, size, 1);
}

/* get table bank parameters for demoage */
int soc_sbx_t3p1_demoage_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_DEMOAGE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for demoage */
int soc_sbx_t3p1_demoage_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_DEMOAGE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for demoage */
int soc_sbx_t3p1_demoage_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_DEMOAGE_TABLE_ID, size, 1);
}

/* get table bank parameters for demoageid */
int soc_sbx_t3p1_demoageid_bank_params_get(int unit, int bank,
                soc_sbx_t3p1_table_bank_params_t *p)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_DEMOAGEID_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for demoageid */
int soc_sbx_t3p1_demoageid_table_size_get(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[SOC_SBX_T3P1_DEMOAGEID_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for demoageid */
int soc_sbx_t3p1_demoageid_table_size_set(int unit, int size)
{
    return soc_sbx_t3p1_generic_table_size_set(unit,
                     SOC_SBX_T3P1_DEMOAGEID_TABLE_ID, size, 1);
}

 
/*
 * Table entry accessors
 */
/**
New entry set accessor implementation for lag
*/
int soc_sbx_t3p1_lag_data_set(int unit,
                    int ilagi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_lag_t entry;

    soc_sbx_t3p1_lag_t_init(&entry);
    s = soc_sbx_t3p1_lag_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_lag_set(unit,   ilagi  , &entry);

    return s;
}

/**
New entry get accessor implementation for lag
*/
int soc_sbx_t3p1_lag_data_get(int unit,
                    int ilagi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_lag_t entry;

    soc_sbx_t3p1_lag_t_init(&entry);
    s = soc_sbx_t3p1_lag_get(unit,   ilagi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_lag_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for lag
 */

void soc_sbx_t3p1_lag_t_init(
    soc_sbx_t3p1_lag_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_lag_t));
}

/* entry pack accessor implementation for lag */
int soc_sbx_t3p1_lag_pack(int unit,
    soc_sbx_t3p1_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lag */
int soc_sbx_t3p1_lag_unpack(int unit,
                soc_sbx_t3p1_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lag */
int soc_sbx_t3p1_lag_index_check(int unit,
                int *vindex,
                  int ilagi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilagi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lag */
int soc_sbx_t3p1_lag_entry_check(int unit,
                soc_sbx_t3p1_lag_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->qid; break;
        case 1: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* lag table size get */
int soc_sbx_t3p1_lag_entry_table_size_get(int unit,
                int *tsize,
                  int ilagi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilagi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for lag */
int soc_sbx_t3p1_lag_set(int unit,
                  int ilagi  ,
                soc_sbx_t3p1_lag_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_lag_index_check(unit, key,
                  ilagi  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_lag_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_lag_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for lag */
int soc_sbx_t3p1_lag_get(int unit,
                  int ilagi  ,
                soc_sbx_t3p1_lag_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_lag_index_check(unit, key,
                  ilagi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_lag_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for vlan
*/
int soc_sbx_t3p1_vlan_data_set(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_vlan_t entry;

    soc_sbx_t3p1_vlan_t_init(&entry);
    s = soc_sbx_t3p1_vlan_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_vlan_set(unit,   ivlan  , &entry);

    return s;
}

/**
New entry get accessor implementation for vlan
*/
int soc_sbx_t3p1_vlan_data_get(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_vlan_t entry;

    soc_sbx_t3p1_vlan_t_init(&entry);
    s = soc_sbx_t3p1_vlan_get(unit,   ivlan  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_vlan_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for vlan
 */

void soc_sbx_t3p1_vlan_t_init(
    soc_sbx_t3p1_vlan_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_vlan_t));
}

/* entry pack accessor implementation for vlan */
int soc_sbx_t3p1_vlan_pack(int unit,
    soc_sbx_t3p1_vlan_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for vlan */
int soc_sbx_t3p1_vlan_unpack(int unit,
                soc_sbx_t3p1_vlan_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for vlan */
int soc_sbx_t3p1_vlan_index_check(int unit,
                int *vindex,
                  int ivlan  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for vlan */
int soc_sbx_t3p1_vlan_entry_check(int unit,
                soc_sbx_t3p1_vlan_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->qid; break;
        case 1: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* vlan table size get */
int soc_sbx_t3p1_vlan_entry_table_size_get(int unit,
                int *tsize,
                  int ivlan  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for vlan */
int soc_sbx_t3p1_vlan_set(int unit,
                  int ivlan  ,
                soc_sbx_t3p1_vlan_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_vlan_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_vlan_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_vlan_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for vlan */
int soc_sbx_t3p1_vlan_get(int unit,
                  int ivlan  ,
                soc_sbx_t3p1_vlan_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_vlan_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_vlan_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for irt
*/
int soc_sbx_t3p1_irt_data_set(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_irt_t entry;

    soc_sbx_t3p1_irt_t_init(&entry);
    s = soc_sbx_t3p1_irt_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_irt_set(unit,   iirule  , &entry);

    return s;
}

/**
New entry get accessor implementation for irt
*/
int soc_sbx_t3p1_irt_data_get(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_irt_t entry;

    soc_sbx_t3p1_irt_t_init(&entry);
    s = soc_sbx_t3p1_irt_get(unit,   iirule  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_irt_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for irt
 */

void soc_sbx_t3p1_irt_t_init(
    soc_sbx_t3p1_irt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_irt_t));
}

/* entry pack accessor implementation for irt */
int soc_sbx_t3p1_irt_pack(int unit,
    soc_sbx_t3p1_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for irt */
int soc_sbx_t3p1_irt_unpack(int unit,
                soc_sbx_t3p1_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for irt */
int soc_sbx_t3p1_irt_index_check(int unit,
                int *vindex,
                  int iirule  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iirule; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for irt */
int soc_sbx_t3p1_irt_entry_check(int unit,
                soc_sbx_t3p1_irt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->mirror; break;
        case 3: ev = e->usevlan; break;
        case 4: ev = e->useftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->cos; break;
        case 8: ev = e->fcos; break;
        case 9: ev = e->usedp; break;
        case 10: ev = e->usecos; break;
        case 11: ev = e->policer; break;
        case 12: ev = e->typedpolice; break;
        case 13: ev = e->mefcos; break;
        case 14: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* irt table size get */
int soc_sbx_t3p1_irt_entry_table_size_get(int unit,
                int *tsize,
                  int iirule  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iirule; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for irt */
int soc_sbx_t3p1_irt_set(int unit,
                  int iirule  ,
                soc_sbx_t3p1_irt_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_irt_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_irt_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_irt_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for irt */
int soc_sbx_t3p1_irt_get(int unit,
                  int iirule  ,
                soc_sbx_t3p1_irt_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_irt_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_irt_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for oam_bubble
*/
int soc_sbx_t3p1_oam_bubble_data_set(int unit,
                    int ioamepi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_oam_bubble_t entry;

    soc_sbx_t3p1_oam_bubble_t_init(&entry);
    s = soc_sbx_t3p1_oam_bubble_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_oam_bubble_set(unit,   ioamepi  , &entry);

    return s;
}

/**
New entry get accessor implementation for oam_bubble
*/
int soc_sbx_t3p1_oam_bubble_data_get(int unit,
                    int ioamepi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_oam_bubble_t entry;

    soc_sbx_t3p1_oam_bubble_t_init(&entry);
    s = soc_sbx_t3p1_oam_bubble_get(unit,   ioamepi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_oam_bubble_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_bubble
 */

void soc_sbx_t3p1_oam_bubble_t_init(
    soc_sbx_t3p1_oam_bubble_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_oam_bubble_t));
}

/* entry pack accessor implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_pack(int unit,
    soc_sbx_t3p1_oam_bubble_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bubble_mode; break;
        case 1: p = (uint8 *) &e->je; break;
        case 2: p = (uint8 *) &e->i; break;
        case 3: p = (uint8 *) &e->bubble_stream; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->interval_index; break;
        case 6: p = (uint8 *) &e->reserved; break;
        case 7: p = (uint8 *) &e->count; break;
        case 8: p = (uint8 *) &e->timeout; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_unpack(int unit,
                soc_sbx_t3p1_oam_bubble_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bubble_mode; break;
        case 1: p = (uint8 *) &e->je; break;
        case 2: p = (uint8 *) &e->i; break;
        case 3: p = (uint8 *) &e->bubble_stream; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->interval_index; break;
        case 6: p = (uint8 *) &e->reserved; break;
        case 7: p = (uint8 *) &e->count; break;
        case 8: p = (uint8 *) &e->timeout; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_bubble */
int soc_sbx_t3p1_oam_bubble_index_check(int unit,
                int *vindex,
                  int ioamepi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ioamepi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_bubble */
int soc_sbx_t3p1_oam_bubble_entry_check(int unit,
                soc_sbx_t3p1_oam_bubble_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->bubble_mode; break;
        case 1: ev = e->je; break;
        case 2: ev = e->i; break;
        case 3: ev = e->bubble_stream; break;
        case 4: ev = e->t; break;
        case 5: ev = e->interval_index; break;
        case 6: ev = e->reserved; break;
        case 7: ev = e->count; break;
        case 8: ev = e->timeout; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oam_bubble table size get */
int soc_sbx_t3p1_oam_bubble_entry_table_size_get(int unit,
                int *tsize,
                  int ioamepi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ioamepi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_set(int unit,
                  int ioamepi  ,
                soc_sbx_t3p1_oam_bubble_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_oam_bubble_index_check(unit, key,
                  ioamepi  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_oam_bubble_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_oam_bubble_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_get(int unit,
                  int ioamepi  ,
                soc_sbx_t3p1_oam_bubble_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_oam_bubble_index_check(unit, key,
                  ioamepi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_oam_bubble_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for demoage
*/
int soc_sbx_t3p1_demoage_data_set(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_demoage_t entry;

    soc_sbx_t3p1_demoage_t_init(&entry);
    s = soc_sbx_t3p1_demoage_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_demoage_set(unit,   imacindex  , &entry);

    return s;
}

/**
New entry get accessor implementation for demoage
*/
int soc_sbx_t3p1_demoage_data_get(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_demoage_t entry;

    soc_sbx_t3p1_demoage_t_init(&entry);
    s = soc_sbx_t3p1_demoage_get(unit,   imacindex  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_demoage_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for demoage
 */

void soc_sbx_t3p1_demoage_t_init(
    soc_sbx_t3p1_demoage_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_demoage_t));
}

/* entry pack accessor implementation for demoage */
int soc_sbx_t3p1_demoage_pack(int unit,
    soc_sbx_t3p1_demoage_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->age_valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for demoage */
int soc_sbx_t3p1_demoage_unpack(int unit,
                soc_sbx_t3p1_demoage_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->age_valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for demoage */
int soc_sbx_t3p1_demoage_index_check(int unit,
                int *vindex,
                  int imacindex  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imacindex; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for demoage */
int soc_sbx_t3p1_demoage_entry_check(int unit,
                soc_sbx_t3p1_demoage_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->age; break;
        case 1: ev = e->age_valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* demoage table size get */
int soc_sbx_t3p1_demoage_entry_table_size_get(int unit,
                int *tsize,
                  int imacindex  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imacindex; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for demoage */
int soc_sbx_t3p1_demoage_set(int unit,
                  int imacindex  ,
                soc_sbx_t3p1_demoage_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_demoage_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_demoage_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_demoage_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for demoage */
int soc_sbx_t3p1_demoage_get(int unit,
                  int imacindex  ,
                soc_sbx_t3p1_demoage_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_demoage_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_demoage_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for demoageid
*/
int soc_sbx_t3p1_demoageid_data_set(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_demoageid_t entry;

    soc_sbx_t3p1_demoageid_t_init(&entry);
    s = soc_sbx_t3p1_demoageid_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_demoageid_set(unit,   imacindex  , &entry);

    return s;
}

/**
New entry get accessor implementation for demoageid
*/
int soc_sbx_t3p1_demoageid_data_get(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_t3p1_demoageid_t entry;

    soc_sbx_t3p1_demoageid_t_init(&entry);
    s = soc_sbx_t3p1_demoageid_get(unit,   imacindex  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_t3p1_demoageid_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for demoageid
 */

void soc_sbx_t3p1_demoageid_t_init(
    soc_sbx_t3p1_demoageid_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_demoageid_t));
}

/* entry pack accessor implementation for demoageid */
int soc_sbx_t3p1_demoageid_pack(int unit,
    soc_sbx_t3p1_demoageid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age_id; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for demoageid */
int soc_sbx_t3p1_demoageid_unpack(int unit,
                soc_sbx_t3p1_demoageid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int be = tm->behost;
    /* bsz = bsz; */
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age_id; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
                         */
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for demoageid */
int soc_sbx_t3p1_demoageid_index_check(int unit,
                int *vindex,
                  int imacindex  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imacindex; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for demoageid */
int soc_sbx_t3p1_demoageid_entry_check(int unit,
                soc_sbx_t3p1_demoageid_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->age_id; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* demoageid table size get */
int soc_sbx_t3p1_demoageid_entry_table_size_get(int unit,
                int *tsize,
                  int imacindex  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_t3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_t3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imacindex; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_t3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for demoageid */
int soc_sbx_t3p1_demoageid_set(int unit,
                  int imacindex  ,
                soc_sbx_t3p1_demoageid_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_t3p1_demoageid_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_demoageid_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_t3p1_demoageid_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for demoageid */
int soc_sbx_t3p1_demoageid_get(int unit,
                  int imacindex  ,
                soc_sbx_t3p1_demoageid_t *e)
{
    int s, key[32];

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_t3p1_demoageid_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_t3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_t3p1_demoageid_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          












static int soc_sbx_t3p1_memory_init(int unit, soc_sbx_t3p1_table_manager_t *tm) {  
	int i, j, s;
	char *e="";
	
	/*
     * Per-memory state initialization
     */
    tm->memories = UTG_MALLOC(sizeof(soc_sbx_t3p1_memory_desc_t)
                              * SOC_SBX_T3P1_MEMORY_MAX_ID);
    if (!tm->memories) {
        soc_sbx_t3p1_uninit(unit);
        return SOC_E_MEMORY;
    }

    tm->memories[SOC_SBX_T3P1_LRP_PORT0_ID]
        .name = "lrp_port0";
    tm->memories[SOC_SBX_T3P1_LRP_PORT0_ID]
        .ocmport = 0;
    tm->memories[SOC_SBX_T3P1_LRP_PORT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT1_ID]
        .name = "lrp_port1";
    tm->memories[SOC_SBX_T3P1_LRP_PORT1_ID]
        .ocmport = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT8_ID]
        .name = "lrp_port8";
    tm->memories[SOC_SBX_T3P1_LRP_PORT8_ID]
        .ocmport = 11;
    tm->memories[SOC_SBX_T3P1_LRP_PORT8_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT8_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT8_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT2_ID]
        .name = "lrp_port2";
    tm->memories[SOC_SBX_T3P1_LRP_PORT2_ID]
        .ocmport = 2;
    tm->memories[SOC_SBX_T3P1_LRP_PORT2_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT2_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT2_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT3_ID]
        .name = "lrp_port3";
    tm->memories[SOC_SBX_T3P1_LRP_PORT3_ID]
        .ocmport = 3;
    tm->memories[SOC_SBX_T3P1_LRP_PORT3_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT3_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT3_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT4_ID]
        .name = "lrp_port4";
    tm->memories[SOC_SBX_T3P1_LRP_PORT4_ID]
        .ocmport = 4;
    tm->memories[SOC_SBX_T3P1_LRP_PORT4_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT4_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT4_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_CMU0_PORT_ID]
        .name = "cmu0_port";
    tm->memories[SOC_SBX_T3P1_CMU0_PORT_ID]
        .ocmport = 6;
    tm->memories[SOC_SBX_T3P1_CMU0_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_CMU0_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_CMU0_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_COP0_PORT_ID]
        .name = "cop0_port";
    tm->memories[SOC_SBX_T3P1_COP0_PORT_ID]
        .ocmport = 7;
    tm->memories[SOC_SBX_T3P1_COP0_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_COP0_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_COP0_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_BUBBLE_PORT_ID]
        .name = "bubble_port";
    tm->memories[SOC_SBX_T3P1_BUBBLE_PORT_ID]
        .ocmport = 8;
    tm->memories[SOC_SBX_T3P1_BUBBLE_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_BUBBLE_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_BUBBLE_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT5_ID]
        .name = "lrp_port5";
    tm->memories[SOC_SBX_T3P1_LRP_PORT5_ID]
        .ocmport = 5;
    tm->memories[SOC_SBX_T3P1_LRP_PORT5_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT5_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT5_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT9_ID]
        .name = "lrp_port9";
    tm->memories[SOC_SBX_T3P1_LRP_PORT9_ID]
        .ocmport = 12;
    tm->memories[SOC_SBX_T3P1_LRP_PORT9_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT9_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT9_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT6_ID]
        .name = "lrp_port6";
    tm->memories[SOC_SBX_T3P1_LRP_PORT6_ID]
        .ocmport = 9;
    tm->memories[SOC_SBX_T3P1_LRP_PORT6_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT6_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT6_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_LRP_PORT7_ID]
        .name = "lrp_port7";
    tm->memories[SOC_SBX_T3P1_LRP_PORT7_ID]
        .ocmport = 10;
    tm->memories[SOC_SBX_T3P1_LRP_PORT7_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT7_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_LRP_PORT7_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_CMU1_PORT_ID]
        .name = "cmu1_port";
    tm->memories[SOC_SBX_T3P1_CMU1_PORT_ID]
        .ocmport = 13;
    tm->memories[SOC_SBX_T3P1_CMU1_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_CMU1_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_CMU1_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_T3P1_COP1_PORT_ID]
        .name = "cop1_port";
    tm->memories[SOC_SBX_T3P1_COP1_PORT_ID]
        .ocmport = 14;
    tm->memories[SOC_SBX_T3P1_COP1_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_T3P1_COP1_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_T3P1_COP1_PORT_ID].alignedlist = -1;

    for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->memories[i].width,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                  soc_sbx_t3p1_sym,
                  128,
                  &tm->memories[i].size,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }

    j = 0;

    for (i = 0; i < SOC_SBX_T3P1_TABLE_MAX_ID; i++){
        j += tm->tables[i].nbanks;
    }

    tm->memorybanks = UTG_MALLOC(sizeof(soc_sbx_t3p1_memory_bank_desc_t) * j);
    if (!tm->memorybanks) {
        soc_sbx_t3p1_uninit(unit);
        return SOC_E_MEMORY;
    }

    soc_sbx_t3p1_memory_banks_init(tm);
    /* soc_sbx_t3p1_tables_aligned_topo_sort(unit); */

    tm->bufsize = 1024;
    tm->entrydmabuf = soc_cm_salloc(unit, tm->bufsize * sizeof(uint32),
                             "entry dma");
    if (!tm->entrydmabuf) {
        return SOC_E_MEMORY;
    }

    tm->dmabufmutex = sal_mutex_create("dma mutex");
    if (!tm->dmabufmutex) {
        return SOC_E_RESOURCE;
    }

    /* Sim support */
    tm->simbuffer = UTG_MALLOC(1024);
    if (!tm->simbuffer) {
        return SOC_E_MEMORY;
    }
    tm->simbuffersize = 1024;

    return SOC_E_NONE;
}

/*
 * Microcode definitions subsystem initializer implementation
 */
int soc_sbx_t3p1_init(int unit, void *ucode)
{    
    int rv;
    uint32 v;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_errsym = soc_sbx_t3p1_sym;

    if (fe->tableinfo) {
        /* Free old info */
        soc_sbx_t3p1_uninit(unit);
    }

    tm = UTG_MALLOC(sizeof(soc_sbx_t3p1_table_manager_t));
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_t3p1_table_manager_t));
    fe->tableinfo = tm;
    fe->regSet = (void*)unit;
    fe->unit = unit;
    fe->ucode = ucode;
   
    v = 0x1;
    tm->behost = !*((uint8 *) &v);
    
    rv = soc_sbx_t3p1_consts_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_t3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_t3p1_globals_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_t3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_t3p1_tables_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_t3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_t3p1_entries_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_t3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_t3p1_memory_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_t3p1_uninit(unit);
    	return rv;
    }
    
    return SOC_E_NONE;
}

/* Uninitialization function implementation */
int soc_sbx_t3p1_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm;

    if (!fe->tableinfo) return s;
    tm = fe->tableinfo;
    if (tm->entrydmabuf) soc_cm_sfree(unit, tm->entrydmabuf);
    if (tm->dmabufmutex) sal_mutex_destroy(tm->dmabufmutex);
    if (tm->memorybanks) UTG_FREE(tm->memorybanks);
    if (tm->memories)    UTG_FREE(tm->memories);
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
            if (tm->entries[i].fields) {
                UTG_FREE(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                UTG_FREE(tm->entries[i].indexes);
            }
        }
        UTG_FREE(tm->entries);
    }
    if (tm->tables) {
        UTG_FREE(tm->tables);
    }
    if (tm->globals)     UTG_FREE(tm->globals);
    if (tm->constants)   UTG_FREE(tm->constants);
    if (tm->simbuffer)   UTG_FREE(tm->simbuffer);
    UTG_FREE(tm);
    fe->tableinfo = NULL;

    return s;
}

/*
 * Memory accessor implementation
 */
int soc_sbx_t3p1_memory_params_get(int unit, int mid,
                soc_sbx_t3p1_memory_params_t *mp)
{
    soc_sbx_t3p1_state_t *fe =
      (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_memory_desc_t *md;

    if (mid > SOC_SBX_T3P1_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    mp->width = md->width;
    mp->size = md->size;

    return SOC_E_NONE;
}

int soc_sbx_t3p1_memory_size_set(int unit, int mid, int size)

{
    soc_sbx_t3p1_state_t *fe =
      (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_memory_desc_t *md;

    if (mid > SOC_SBX_T3P1_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    md->size = size;

    return SOC_E_NONE;
}

#endif

