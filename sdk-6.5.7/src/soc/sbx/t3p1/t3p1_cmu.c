
/*
 * $Id: cmu_c.stg,v 1.15 Broadcom SDK $    
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * t3p1_cmu.c: Guadalupe2k V1.3 CMU table manager & wrappers
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from sdk/caladan_ucode/t3p1/src/t3p1_cmu_cfg.lrp.
 * Edits to this file will be lost when it is regenerated.
 *
 */
#include <shared/bsl.h>

#include <soc/defs.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT) 

#include <sal/core/time.h>
#include <sal/core/alloc.h>
#include <sal/core/libc.h>
#include <sal/types.h>
#include <sal/appl/io.h>
#include <soc/types.h>
#include <soc/drv.h>
#include <sal/appl/sal.h>
#include <sal/core/time.h>
#include <appl/diag/test.h> 
#include <sal/core/thread.h>

#include <soc/sbx/caladan3/ocm.h>
#include <soc/sbx/caladan3/cmu.h>
#include <soc/error.h>
#include <soc/debug.h>

#include <soc/sbx/t3p1/t3p1_cmu.h>
#include <soc/sbx/t3p1/t3p1_cmu_sim.h>

typedef struct cmu_counter_group_s {
  int counter_start;
  int num_counters;
  int segment_id;
  soc_sbx_caladan3_cmu_segment_type_e_t segment_type;
} cmu_counter_group_t;

static cmu_counter_group_t *cmu_counter_groups;
static int next_group;


int t3p1_cmu_ocm_mem_size[2] = {16439, 0}; /* Size in number of 64 bit entries. Actual number of entries [0]=16439, [1]=0 */


static int example_counters_id = 0;
static int init_example_counters(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 55; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 1;
  example_counters_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[example_counters_id].segment_id,
                  55, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 1 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  
  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[example_counters_id].segment_id, FALSE);
  
  if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }        
  
        
  return SOC_E_NONE;

} 
 
   
static int rtctr_id = 0;
static int init_rtctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 16384; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 2;
  rtctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[rtctr_id].segment_id,
                  16384, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 2 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[rtctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }        
        
  return SOC_E_NONE;

}
 

int soc_sbx_t3p1_example_counters_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_t3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[example_counters_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_t3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
    LOG_CLI((BSL_META_U(unit,
                        "C3 %d example_counters read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_t3p1_example_counters_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[example_counters_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_t3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
    LOG_CLI((BSL_META_U(unit,
                        "C3 %d example_counters read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_t3p1_rtctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_t3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[rtctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_t3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
    LOG_CLI((BSL_META_U(unit,
                        "C3 %d rtctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_t3p1_rtctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[rtctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_t3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
    LOG_CLI((BSL_META_U(unit,
                        "C3 %d rtctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}



static int init_cmu_ocm_ports(int unit) {
  sbx_caladan3_ocm_port_alloc_t desc;
  int rv, i;

  for (i=0; i<2; i++) {
    desc.port = (i == 0) ? SOC_SBX_CALADAN3_OCM_CMU0_PORT : SOC_SBX_CALADAN3_OCM_CMU1_PORT;
    desc.segment = -1;
    desc.size = t3p1_cmu_ocm_mem_size[i];
    desc.datum_size = SOC_SBX_CALADAN3_DATUM_SIZE_QUADWORD; /* Assume worst case: Turbo64 */

    /* allocate memory */
    rv = soc_sbx_caladan3_ocm_port_mem_alloc(unit, &desc);
    if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "C3 %d CMU Allocation failed for port %d\n"),unit, desc.port));
      return rv;
    }

    /* set OCM memory size. */
    rv = soc_sbx_caladan3_cmu_ocm_memory_size_set(unit,
                desc.port,
                desc.size * sizeof(uint64));
    if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s Failed to register OCM memory for CMU port %d on unit %d\n"),
                 FUNCTION_NAME(), desc.port, unit));
      return rv;
    }
  }

  return SOC_E_NONE;
}


int soc_sbx_t3p1_cmu_init(int unit){
  int rv = SOC_E_NONE;

  cmu_counter_groups = sal_alloc(MAX_COUNTER_GROUPS * sizeof(cmu_counter_group_t), "asm3_cmu_counters");
  if (!cmu_counter_groups) {
    return SOC_E_MEMORY;
  }
  next_group = 0;

  rv = init_cmu_ocm_ports(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_example_counters(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_rtctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  
  return SOC_E_NONE;

}

int soc_sbx_t3p1_cmu_uninit(int unit){
  sbx_caladan3_ocm_port_alloc_t desc;
  int i, rv;
        
  for (i=0; i<next_group; i++) {
    rv = soc_sbx_caladan3_cmu_counter_group_unregister(unit, cmu_counter_groups[i].segment_id);
    if (SOC_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "C3 %d Unregiser failed for segment %d [%d]\n"),unit, i, cmu_counter_groups[i].segment_id));
    } 
  }
            
  for (i=0; i<2; i++) {
    desc.port = (i == 0) ? SOC_SBX_CALADAN3_OCM_CMU0_PORT : SOC_SBX_CALADAN3_OCM_CMU1_PORT;
    desc.segment = -1;
    desc.size = t3p1_cmu_ocm_mem_size[i];
    desc.datum_size = SOC_SBX_CALADAN3_DATUM_SIZE_QUADWORD;

    rv = soc_sbx_caladan3_ocm_port_mem_free(unit, &desc);
    if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "C3 %d Free failed for port %d\n"),unit, desc.port));
    }
  }

  sal_free(cmu_counter_groups);

  return SOC_E_NONE;
}



#endif
