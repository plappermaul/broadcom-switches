/*
 * $Id: ppe_tables_c.stg,v 1.32 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from sdk/caladan_ucode/t3p1/src/t3p1_ppe_cfg.lrp.
 * Edits to this file will be lost when it is regenerated.
 *
 */
#include <shared/bsl.h>

#include <soc/types.h>
#include <soc/drv.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT) 
#include <soc/sbx/t3p1/t3p1_int.h>
#include <soc/sbx/t3p1/t3p1_ppe_tables.h>
#include <sal/core/boot.h>

/* Static symbol name for initialization */
char soc_sbx_t3p1_ppe_sym[128];

/* Only for debugging */
char *soc_sbx_t3p1_ppe_errsym;


/*
 * Entry accessor implementations for p2e
 */

void soc_sbx_t3p1_p2e_t_init(
    soc_sbx_t3p1_p2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_p2e_t));
    e->defstrip = 0x1; 
    e->untaggedstrip = 0x1; 
}

/* entry size function for p2e */
int soc_sbx_t3p1_p2e_size(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for p2e */
int soc_sbx_t3p1_p2e_pack(int unit,
    soc_sbx_t3p1_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    int be = tm->behost;
    int bytes_to_clear;
    
    base = b;
    bytes_to_clear = bsz / 8;
    if (bsz & 0x7) {
        bytes_to_clear++;
    }
    sal_memset(b, 0, bytes_to_clear);
    
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
             case 0: p = (uint8 *) &e->portid; break; 
             case 1: p = (uint8 *) &e->state_num; break; 
             case 2: p = (uint8 *) &e->lsmmatch; break; 
             case 3: p = (uint8 *) &e->ipv4mc; break; 
             case 4: p = (uint8 *) &e->pbb; break; 
             case 5: p = (uint8 *) &e->twintpid; break; 
             case 6: p = (uint8 *) &e->tpid; break; 
             case 7: p = (uint8 *) &e->oamloop; break; 
             case 8: p = (uint8 *) &e->provider; break; 
             case 9: p = (uint8 *) &e->customer; break; 
             case 10: p = (uint8 *) &e->hdrtype; break; 
             case 11: p = (uint8 *) &e->timestamp; break; 
             case 12: p = (uint8 *) &e->aggr_hash; break; 
             case 13: p = (uint8 *) &e->port; break; 
             case 14: p = (uint8 *) &e->nativevid; break; 
             case 15: p = (uint8 *) &e->defcfi; break; 
             case 16: p = (uint8 *) &e->defpri; break; 
             case 17: p = (uint8 *) &e->defstrip; break; 
             case 18: p = (uint8 *) &e->pstrip; break; 
             case 19: p = (uint8 *) &e->mim; break; 
             case 20: p = (uint8 *) &e->mplstp; break; 
             case 21: p = (uint8 *) &e->untaggedstrip; break; 
             case 22: p = (uint8 *) &e->droptagged; break; 
             case 23: p = (uint8 *) &e->dropuntagged; break; 
             case 24: p = (uint8 *) &e->tc_1588; break; 
             case 25: p = (uint8 *) &e->rep_data; break; 
             case 26: p = (uint8 *) &e->ppe_variable; break; 
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }


    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e */
int soc_sbx_t3p1_p2e_unpack(int unit,
                soc_sbx_t3p1_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
             case 0: p = (uint8 *) &e->portid; break; 
             case 1: p = (uint8 *) &e->state_num; break; 
             case 2: p = (uint8 *) &e->lsmmatch; break; 
             case 3: p = (uint8 *) &e->ipv4mc; break; 
             case 4: p = (uint8 *) &e->pbb; break; 
             case 5: p = (uint8 *) &e->twintpid; break; 
             case 6: p = (uint8 *) &e->tpid; break; 
             case 7: p = (uint8 *) &e->oamloop; break; 
             case 8: p = (uint8 *) &e->provider; break; 
             case 9: p = (uint8 *) &e->customer; break; 
             case 10: p = (uint8 *) &e->hdrtype; break; 
             case 11: p = (uint8 *) &e->timestamp; break; 
             case 12: p = (uint8 *) &e->aggr_hash; break; 
             case 13: p = (uint8 *) &e->port; break; 
             case 14: p = (uint8 *) &e->nativevid; break; 
             case 15: p = (uint8 *) &e->defcfi; break; 
             case 16: p = (uint8 *) &e->defpri; break; 
             case 17: p = (uint8 *) &e->defstrip; break; 
             case 18: p = (uint8 *) &e->pstrip; break; 
             case 19: p = (uint8 *) &e->mim; break; 
             case 20: p = (uint8 *) &e->mplstp; break; 
             case 21: p = (uint8 *) &e->untaggedstrip; break; 
             case 22: p = (uint8 *) &e->droptagged; break; 
             case 23: p = (uint8 *) &e->dropuntagged; break; 
             case 24: p = (uint8 *) &e->tc_1588; break; 
             case 25: p = (uint8 *) &e->rep_data; break; 
             case 26: p = (uint8 *) &e->ppe_variable; break; 
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e */
int soc_sbx_t3p1_p2e_index_check(int unit,
                int *vindex,
                 int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
            case 0: p = (uint8 *) &iport; break; 
            default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_ppe_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e */
int soc_sbx_t3p1_p2e_entry_check(int unit,
                soc_sbx_t3p1_p2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 0: ev = e->portid; break; 
             case 1: ev = e->state_num; break; 
             case 2: ev = e->lsmmatch; break; 
             case 3: ev = e->ipv4mc; break; 
             case 4: ev = e->pbb; break; 
             case 5: ev = e->twintpid; break; 
             case 6: ev = e->tpid; break; 
             case 7: ev = e->oamloop; break; 
             case 8: ev = e->provider; break; 
             case 9: ev = e->customer; break; 
             case 10: ev = e->hdrtype; break; 
             case 11: ev = e->timestamp; break; 
             case 12: ev = e->aggr_hash; break; 
             case 13: ev = e->port; break; 
             case 14: ev = e->nativevid; break; 
             case 15: ev = e->defcfi; break; 
             case 16: ev = e->defpri; break; 
             case 17: ev = e->defstrip; break; 
             case 18: ev = e->pstrip; break; 
             case 19: ev = e->mim; break; 
             case 20: ev = e->mplstp; break; 
             case 21: ev = e->untaggedstrip; break; 
             case 22: ev = e->droptagged; break; 
             case 23: ev = e->dropuntagged; break; 
             case 24: ev = e->tc_1588; break; 
             case 25: ev = e->rep_data; break; 
             case 26: ev = e->ppe_variable; break; 
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_ppe_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

int soc_sbx_t3p1_p2e_set_ext_sim(int unit, int iport  , soc_sbx_t3p1_p2e_t *e)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    char *buffer;
    int s, i, size, skipsize;
    uint32 val = 0;

    buffer = tm->simbuffer;
    memset(buffer, 0, tm->simbuffersize);
    size = soc_sbx_caladan3_sim_block_encode(buffer, "ppe",  "p2e", 
                                              "set table", iport  );
    size += soc_sbx_caladan3_sim_keyword_encode(buffer+size, "ing_src_queue"); 
    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 11: val = e->timestamp; break; 
             case 12: val = e->aggr_hash; break; 
             case 13: val = e->port; break; 
             case 14: val = e->nativevid; break; 
             case 15: val = e->defcfi; break; 
             case 16: val = e->defpri; break; 
             case 17: val = e->defstrip; break; 
             case 18: val = e->pstrip; break; 
             case 19: val = e->mim; break; 
             case 20: val = e->mplstp; break; 
             case 21: val = e->untaggedstrip; break; 
             case 22: val = e->droptagged; break; 
             case 23: val = e->dropuntagged; break; 
             case 24: val = e->tc_1588; break; 
             case 25: val = e->rep_data; break; 
             case 26: val = e->ppe_variable; break; 
            default: 
                continue;
        }
        size += soc_sbx_caladan3_sim_verb_encode(buffer+size,
                      ed->fields[i].name, val); 
    }

    size += soc_sbx_caladan3_sim_keyword_encode(buffer+size, "parse_state"); 

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 0: val = e->portid; break; 
             case 1: val = e->state_num; break; 
             case 2: val = e->lsmmatch; break; 
             case 3: val = e->ipv4mc; break; 
             case 4: val = e->pbb; break; 
             case 5: val = e->twintpid; break; 
             case 6: val = e->tpid; break; 
             case 7: val = e->oamloop; break; 
             case 8: val = e->provider; break; 
             case 9: val = e->customer; break; 
             case 10: val = e->hdrtype; break; 
            default: 
                continue;
        }
        size += soc_sbx_caladan3_sim_verb_encode(buffer+size,
                      ed->fields[i].name, val); 
    }


    s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim sendrcv failed (%d)\n"), s));
        return s;
    }
    s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim set failed (%d)\n"), s));
    }
    return s;
}

/* entry set accessor implementation for p2e */
int soc_sbx_t3p1_p2e_set(int unit,
                 int iport  ,
                soc_sbx_t3p1_p2e_t *e)
{
    int s, key[32];

    s = soc_sbx_t3p1_p2e_index_check(unit, key, iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_p2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_p2e_set_ext(unit,
                 iport  ,
                e);
    return s;
}

int soc_sbx_t3p1_p2e_get_ext_sim(int unit, int iport  , soc_sbx_t3p1_p2e_t *e)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID];
    char *buffer, *p, *q;
    char *fname[100] = {0};
    char *fval[100] = {0};
    int s, i, j, size, skipsize;
    uint32 val;
    int fcnt = 0;

    buffer = tm->simbuffer;
    memset(buffer, 0, tm->simbuffersize);
    memset(e, 0, sizeof(soc_sbx_t3p1_p2e_t));
    size = soc_sbx_caladan3_sim_block_encode(buffer, "ppe", "p2e", "get table", iport  );

    s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim sendrcv failed (%d)\n"), s));
        return s;
    }
    s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim get failed (%d)\n"), s));
        return s;
    }
    buffer += skipsize;
    size -= skipsize;
    
    /* Eliminating the ingr_src_queue and parse_state key words */
    p = buffer;
    while (*p) {
        skipsize = strlen("ing_src_queue");
        if (sal_strncasecmp(p, "ing_src_queue", skipsize)==0) {
            q = p + skipsize + 1;
            sal_sprintf(p, "%s", q);
            break;
        } 
        p++;
    }
    while (*p) {
        skipsize = strlen("parse_state");
        if (sal_strncasecmp(p, "parse_state", skipsize)==0) {
            q = p + skipsize + 1;
            sal_sprintf(p, "%s", q);
        } 
        p++;
    }
    
    fcnt = soc_sbx_caladan3_sim_split(buffer, size, fname, fval); 
    if (fcnt <= 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim decode failed (%d)\n"), s));
        return s;
    }
    for (i = 0; i < ed->nfields; i++) {
        for (j = 0; j < fcnt; j++) {
            if (sal_strcmp(fname[j],ed->fields[i].name)==0) {
                val = _shr_ctoi(fval[j]);
               
                switch (i) {
                     case 0: e->portid = val; break; 
                     case 1: e->state_num = val; break; 
                     case 2: e->lsmmatch = val; break; 
                     case 3: e->ipv4mc = val; break; 
                     case 4: e->pbb = val; break; 
                     case 5: e->twintpid = val; break; 
                     case 6: e->tpid = val; break; 
                     case 7: e->oamloop = val; break; 
                     case 8: e->provider = val; break; 
                     case 9: e->customer = val; break; 
                     case 10: e->hdrtype = val; break; 
                     case 11: e->timestamp = val; break; 
                     case 12: e->aggr_hash = val; break; 
                     case 13: e->port = val; break; 
                     case 14: e->nativevid = val; break; 
                     case 15: e->defcfi = val; break; 
                     case 16: e->defpri = val; break; 
                     case 17: e->defstrip = val; break; 
                     case 18: e->pstrip = val; break; 
                     case 19: e->mim = val; break; 
                     case 20: e->mplstp = val; break; 
                     case 21: e->untaggedstrip = val; break; 
                     case 22: e->droptagged = val; break; 
                     case 23: e->dropuntagged = val; break; 
                     case 24: e->tc_1588 = val; break; 
                     case 25: e->rep_data = val; break; 
                     case 26: e->ppe_variable = val; break; 
                    default: 
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "\nCannot decode %s and %x "), fname[j], val));
                        continue;
                }
            }
        }
    }
    for (j = 0; j < fcnt; j++) {
        sal_free(fname[j]);
        sal_free(fval[j]);
    }
    return s;
}

/* entry get accessor implementation for p2e */
int soc_sbx_t3p1_p2e_get(int unit, int iport  , soc_sbx_t3p1_p2e_t *e)
{
    int s, key[32];


    s = soc_sbx_t3p1_p2e_index_check(unit, key,
                 iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_p2e_get_ext(unit,
                 iport  ,
                e);

    return s;
}

/*
 * Entry accessor implementations for ep2e
 */

void soc_sbx_t3p1_ep2e_t_init(
    soc_sbx_t3p1_ep2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_t3p1_ep2e_t));
}

/* entry size function for ep2e */
int soc_sbx_t3p1_ep2e_size(int unit)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    soc_sbx_t3p1_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ep2e */
int soc_sbx_t3p1_ep2e_pack(int unit,
    soc_sbx_t3p1_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    int be = tm->behost;
    int bytes_to_clear;
    
    base = b;
    bytes_to_clear = bsz / 8;
    if (bsz & 0x7) {
        bytes_to_clear++;
    }
    sal_memset(b, 0, bytes_to_clear);
    
    base = b;
    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
             case 0: p = (uint8 *) &e->portid; break; 
             case 1: p = (uint8 *) &e->state_num; break; 
             case 2: p = (uint8 *) &e->lsmmatch; break; 
             case 3: p = (uint8 *) &e->ipv4mc; break; 
             case 4: p = (uint8 *) &e->pbb; break; 
             case 5: p = (uint8 *) &e->twintpid; break; 
             case 6: p = (uint8 *) &e->tpid; break; 
             case 7: p = (uint8 *) &e->oamloop; break; 
             case 8: p = (uint8 *) &e->provider; break; 
             case 9: p = (uint8 *) &e->customer; break; 
             case 10: p = (uint8 *) &e->hdrtype; break; 
             case 11: p = (uint8 *) &e->timestamp; break; 
             case 12: p = (uint8 *) &e->aggr_hash; break; 
             case 13: p = (uint8 *) &e->mim; break; 
             case 14: p = (uint8 *) &e->port; break; 
             case 15: p = (uint8 *) &e->pid; break; 
             case 16: p = (uint8 *) &e->stpid0; break; 
             case 17: p = (uint8 *) &e->stpid1; break; 
             case 18: p = (uint8 *) &e->cep; break; 
             case 19: p = (uint8 *) &e->keeperh; break; 
             case 20: p = (uint8 *) &e->mirroridx; break; 
             case 21: p = (uint8 *) &e->tc_1588; break; 
             case 22: p = (uint8 *) &e->rep_data; break; 
             case 23: p = (uint8 *) &e->ppe_variable; break; 
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }


    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e */
int soc_sbx_t3p1_ep2e_unpack(int unit,
                soc_sbx_t3p1_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
        b+=bsz/8-1;
    }

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
             case 0: p = (uint8 *) &e->portid; break; 
             case 1: p = (uint8 *) &e->state_num; break; 
             case 2: p = (uint8 *) &e->lsmmatch; break; 
             case 3: p = (uint8 *) &e->ipv4mc; break; 
             case 4: p = (uint8 *) &e->pbb; break; 
             case 5: p = (uint8 *) &e->twintpid; break; 
             case 6: p = (uint8 *) &e->tpid; break; 
             case 7: p = (uint8 *) &e->oamloop; break; 
             case 8: p = (uint8 *) &e->provider; break; 
             case 9: p = (uint8 *) &e->customer; break; 
             case 10: p = (uint8 *) &e->hdrtype; break; 
             case 11: p = (uint8 *) &e->timestamp; break; 
             case 12: p = (uint8 *) &e->aggr_hash; break; 
             case 13: p = (uint8 *) &e->mim; break; 
             case 14: p = (uint8 *) &e->port; break; 
             case 15: p = (uint8 *) &e->pid; break; 
             case 16: p = (uint8 *) &e->stpid0; break; 
             case 17: p = (uint8 *) &e->stpid1; break; 
             case 18: p = (uint8 *) &e->cep; break; 
             case 19: p = (uint8 *) &e->keeperh; break; 
             case 20: p = (uint8 *) &e->mirroridx; break; 
             case 21: p = (uint8 *) &e->tc_1588; break; 
             case 22: p = (uint8 *) &e->rep_data; break; 
             case 23: p = (uint8 *) &e->ppe_variable; break; 
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e */
int soc_sbx_t3p1_ep2e_index_check(int unit,
                int *vindex,
                 int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    soc_sbx_t3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
            case 0: p = (uint8 *) &iport; break; 
            default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_t3p1_ppe_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
  pibe = 
    (fmt == SOC_SBX_T3P1_BE_INTEGER_FORMAT
     || (fmt == SOC_SBX_T3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_t3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e */
int soc_sbx_t3p1_ep2e_entry_check(int unit,
                soc_sbx_t3p1_ep2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 0: ev = e->portid; break; 
             case 1: ev = e->state_num; break; 
             case 2: ev = e->lsmmatch; break; 
             case 3: ev = e->ipv4mc; break; 
             case 4: ev = e->pbb; break; 
             case 5: ev = e->twintpid; break; 
             case 6: ev = e->tpid; break; 
             case 7: ev = e->oamloop; break; 
             case 8: ev = e->provider; break; 
             case 9: ev = e->customer; break; 
             case 10: ev = e->hdrtype; break; 
             case 11: ev = e->timestamp; break; 
             case 12: ev = e->aggr_hash; break; 
             case 13: ev = e->mim; break; 
             case 14: ev = e->port; break; 
             case 15: ev = e->pid; break; 
             case 16: ev = e->stpid0; break; 
             case 17: ev = e->stpid1; break; 
             case 18: ev = e->cep; break; 
             case 19: ev = e->keeperh; break; 
             case 20: ev = e->mirroridx; break; 
             case 21: ev = e->tc_1588; break; 
             case 22: ev = e->rep_data; break; 
             case 23: ev = e->ppe_variable; break; 
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_t3p1_ppe_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

int soc_sbx_t3p1_ep2e_set_ext_sim(int unit, int iport  , soc_sbx_t3p1_ep2e_t *e)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    char *buffer;
    int s, i, size, skipsize;
    uint32 val = 0;

    buffer = tm->simbuffer;
    memset(buffer, 0, tm->simbuffersize);
    size = soc_sbx_caladan3_sim_block_encode(buffer, "ppe",  "ep2e", 
                                              "set table", iport  );
    size += soc_sbx_caladan3_sim_keyword_encode(buffer+size, "egr_src_queue"); 
    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 11: val = e->timestamp; break; 
             case 12: val = e->aggr_hash; break; 
             case 13: val = e->mim; break; 
             case 14: val = e->port; break; 
             case 15: val = e->pid; break; 
             case 16: val = e->stpid0; break; 
             case 17: val = e->stpid1; break; 
             case 18: val = e->cep; break; 
             case 19: val = e->keeperh; break; 
             case 20: val = e->mirroridx; break; 
             case 21: val = e->tc_1588; break; 
             case 22: val = e->rep_data; break; 
             case 23: val = e->ppe_variable; break; 
            default: 
                continue;
        }
        size += soc_sbx_caladan3_sim_verb_encode(buffer+size,
                      ed->fields[i].name, val); 
    }

    size += soc_sbx_caladan3_sim_keyword_encode(buffer+size, "parse_state"); 

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
             case 0: val = e->portid; break; 
             case 1: val = e->state_num; break; 
             case 2: val = e->lsmmatch; break; 
             case 3: val = e->ipv4mc; break; 
             case 4: val = e->pbb; break; 
             case 5: val = e->twintpid; break; 
             case 6: val = e->tpid; break; 
             case 7: val = e->oamloop; break; 
             case 8: val = e->provider; break; 
             case 9: val = e->customer; break; 
             case 10: val = e->hdrtype; break; 
            default: 
                continue;
        }
        size += soc_sbx_caladan3_sim_verb_encode(buffer+size,
                      ed->fields[i].name, val); 
    }


    s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim sendrcv failed (%d)\n"), s));
        return s;
    }
    s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim set failed (%d)\n"), s));
    }
    return s;
}

/* entry set accessor implementation for ep2e */
int soc_sbx_t3p1_ep2e_set(int unit,
                 int iport  ,
                soc_sbx_t3p1_ep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_t3p1_ep2e_index_check(unit, key, iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_t3p1_ep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_ep2e_set_ext(unit,
                 iport  ,
                e);
    return s;
}

int soc_sbx_t3p1_ep2e_get_ext_sim(int unit, int iport  , soc_sbx_t3p1_ep2e_t *e)
{
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID];
    char *buffer, *p, *q;
    char *fname[100] = {0};
    char *fval[100] = {0};
    int s, i, j, size, skipsize;
    uint32 val;
    int fcnt = 0;

    buffer = tm->simbuffer;
    memset(buffer, 0, tm->simbuffersize);
    memset(e, 0, sizeof(soc_sbx_t3p1_ep2e_t));
    size = soc_sbx_caladan3_sim_block_encode(buffer, "ppe", "ep2e", "get table", iport  );

    s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim sendrcv failed (%d)\n"), s));
        return s;
    }
    s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
    if (SOC_FAILURE(s)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim get failed (%d)\n"), s));
        return s;
    }
    buffer += skipsize;
    size -= skipsize;
    
    /* Eliminating the ingr_src_queue and parse_state key words */
    p = buffer;
    while (*p) {
        skipsize = strlen("egr_src_queue");
        if (sal_strncasecmp(p, "egr_src_queue", skipsize)==0) {
            q = p + skipsize + 1;
            sal_sprintf(p, "%s", q);
            break;
        } 
        p++;
    }
    while (*p) {
        skipsize = strlen("parse_state");
        if (sal_strncasecmp(p, "parse_state", skipsize)==0) {
            q = p + skipsize + 1;
            sal_sprintf(p, "%s", q);
        } 
        p++;
    }
    
    fcnt = soc_sbx_caladan3_sim_split(buffer, size, fname, fval); 
    if (fcnt <= 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "sim decode failed (%d)\n"), s));
        return s;
    }
    for (i = 0; i < ed->nfields; i++) {
        for (j = 0; j < fcnt; j++) {
            if (sal_strcmp(fname[j],ed->fields[i].name)==0) {
                val = _shr_ctoi(fval[j]);
               
                switch (i) {
                     case 0: e->portid = val; break; 
                     case 1: e->state_num = val; break; 
                     case 2: e->lsmmatch = val; break; 
                     case 3: e->ipv4mc = val; break; 
                     case 4: e->pbb = val; break; 
                     case 5: e->twintpid = val; break; 
                     case 6: e->tpid = val; break; 
                     case 7: e->oamloop = val; break; 
                     case 8: e->provider = val; break; 
                     case 9: e->customer = val; break; 
                     case 10: e->hdrtype = val; break; 
                     case 11: e->timestamp = val; break; 
                     case 12: e->aggr_hash = val; break; 
                     case 13: e->mim = val; break; 
                     case 14: e->port = val; break; 
                     case 15: e->pid = val; break; 
                     case 16: e->stpid0 = val; break; 
                     case 17: e->stpid1 = val; break; 
                     case 18: e->cep = val; break; 
                     case 19: e->keeperh = val; break; 
                     case 20: e->mirroridx = val; break; 
                     case 21: e->tc_1588 = val; break; 
                     case 22: e->rep_data = val; break; 
                     case 23: e->ppe_variable = val; break; 
                    default: 
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "\nCannot decode %s and %x "), fname[j], val));
                        continue;
                }
            }
        }
    }
    for (j = 0; j < fcnt; j++) {
        sal_free(fname[j]);
        sal_free(fval[j]);
    }
    return s;
}

/* entry get accessor implementation for ep2e */
int soc_sbx_t3p1_ep2e_get(int unit, int iport  , soc_sbx_t3p1_ep2e_t *e)
{
    int s, key[32];


    s = soc_sbx_t3p1_ep2e_index_check(unit, key,
                 iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_t3p1_ep2e_get_ext(unit,
                 iport  ,
                e);

    return s;
}
static int create_table_p2e(int unit, soc_sbx_t3p1_ppe_table_manager_t *tm) {  
    
    int s, j;
    char *e = "";
    
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name = "p2e";
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].table = SOC_SBX_T3P1_PPE_MAX_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].pack = (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_p2e_pack;
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].esize = sizeof(soc_sbx_t3p1_p2e_t);
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nfields = 27;
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_ppe_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nbanks,
                e,
                tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                -1,
                e,
                "BANKS");
    if (s) {
        soc_sbx_t3p1_uninit(unit);
        return s;
    }
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_ppe_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].type,
                e,
                tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                -1,
                e,
                "TYPE");
    if (s) {
        soc_sbx_t3p1_uninit(unit);
        return s;
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].epsize = 0;
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nbanks; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].banks[j].tablebank,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "BANK");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].banks[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].epsize += tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].banks[j].width;
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].banks[j].stridebits,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "STRIDE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].totalwidth +=
            tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].banks[j].width;
    }
    
    /*
     * Per-index state initialization
     */
    if (tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes, "ppe_tm_indices");
        if (!tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes) {
            soc_sbx_t3p1_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[0].name = "port"; 
    
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].pos,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].name,
                    "INDEX_POSITION");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].orange,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].name,
                    "INDEX_RANGE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].range
            = tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].orange;
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].name,
                    "INDEX_WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].format,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[j].name,
                    "FORMAT");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }

    if (tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexeswidth =
            ((tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes - 1].pos
              + tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].indexes[tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nindexes - 1].width
              + 7) / 8) * 8;
    }

    soc_sbx_t3p1_entry_index_ranges_set(unit, SOC_SBX_T3P1_PPE_P2E_ID);

    /*
     * Per-field state initialization
     */
    if (tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nfields) {
        tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields =
            sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                   * tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nfields, "ppe_table_entries");
        if (!tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields) {
            soc_sbx_t3p1_uninit(unit);
            return SOC_E_MEMORY;
        }
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[0].name = "portid"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[1].name = "state_num"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[2].name = "lsmmatch"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[3].name = "ipv4mc"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[4].name = "pbb"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[5].name = "twintpid"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[6].name = "tpid"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[7].name = "oamloop"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[8].name = "provider"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[9].name = "customer"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[10].name = "hdrtype"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[11].name = "timestamp"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[12].name = "aggr_hash"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[13].name = "port"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[14].name = "nativevid"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[15].name = "defcfi"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[16].name = "defpri"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[17].name = "defstrip"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[18].name = "pstrip"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[19].name = "mim"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[20].name = "mplstp"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[21].name = "untaggedstrip"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[22].name = "droptagged"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[23].name = "dropuntagged"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[24].name = "tc_1588"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[25].name = "rep_data"; 
    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[26].name = "ppe_variable"; 

    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].nfields; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].pos,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].name,
                    "POSITION");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].range,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].name,
                    "RANGE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_P2E_ID].fields[j].name,
                    "WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }
    
    return SOC_E_NONE;
}

static int create_table_ep2e(int unit, soc_sbx_t3p1_ppe_table_manager_t *tm) {  
    
    int s, j;
    char *e = "";
    
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name = "ep2e";
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].table = SOC_SBX_T3P1_PPE_MAX_TABLE_ID;
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].pack = (soc_sbx_t3p1_complex_pack_f_t) soc_sbx_t3p1_ep2e_pack;
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].esize = sizeof(soc_sbx_t3p1_ep2e_t);
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nfields = 24;
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_ppe_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nbanks,
                e,
                tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                -1,
                e,
                "BANKS");
    if (s) {
        soc_sbx_t3p1_uninit(unit);
        return s;
    }
    
    s = soc_sbx_t3p1_ucode_get(unit,
                soc_sbx_t3p1_ppe_sym,
                128,
                &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].type,
                e,
                tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                -1,
                e,
                "TYPE");
    if (s) {
        soc_sbx_t3p1_uninit(unit);
        return s;
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].epsize = 0;
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nbanks; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].banks[j].tablebank,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "BANK");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].banks[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].epsize += tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].banks[j].width;
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].banks[j].stridebits,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    j == 0 ? -1 : j,
                    e,
                    "STRIDE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].totalwidth +=
            tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].banks[j].width;
    }
    
    /*
     * Per-index state initialization
     */
    if (tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes =
            sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t)
                   * tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes, "ppe_tm_indices");
        if (!tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes) {
            soc_sbx_t3p1_uninit(unit);
            return SOC_E_MEMORY;
        }
        sal_memset(tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes, 0, 
          (sizeof(soc_sbx_t3p1_index_desc_t) * tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes));
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[0].name = "port"; 
    
    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].pos,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].name,
                    "INDEX_POSITION");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].orange,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].name,
                    "INDEX_RANGE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].range
            = tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].orange;
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].name,
                    "INDEX_WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].format,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[j].name,
                    "FORMAT");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }

    if (tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes) {
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexeswidth =
            ((tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes - 1].pos
              + tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].indexes[tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nindexes - 1].width
              + 7) / 8) * 8;
    }

    soc_sbx_t3p1_entry_index_ranges_set(unit, SOC_SBX_T3P1_PPE_EP2E_ID);

    /*
     * Per-field state initialization
     */
    if (tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nfields) {
        tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields =
            sal_alloc(sizeof(soc_sbx_t3p1_field_desc_t)
                   * tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nfields, "ppe_table_entries");
        if (!tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields) {
            soc_sbx_t3p1_uninit(unit);
            return SOC_E_MEMORY;
        }
    }
    
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[0].name = "portid"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[1].name = "state_num"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[2].name = "lsmmatch"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[3].name = "ipv4mc"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[4].name = "pbb"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[5].name = "twintpid"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[6].name = "tpid"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[7].name = "oamloop"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[8].name = "provider"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[9].name = "customer"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[10].name = "hdrtype"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[11].name = "timestamp"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[12].name = "aggr_hash"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[13].name = "mim"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[14].name = "port"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[15].name = "pid"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[16].name = "stpid0"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[17].name = "stpid1"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[18].name = "cep"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[19].name = "keeperh"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[20].name = "mirroridx"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[21].name = "tc_1588"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[22].name = "rep_data"; 
    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[23].name = "ppe_variable"; 

    for (j = 0; j < tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].nfields; j++) {
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].pos,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].name,
                    "POSITION");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].range,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].name,
                    "RANGE");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_t3p1_ucode_get(unit,
                    soc_sbx_t3p1_ppe_sym,
                    128,
                    &tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].width,
                    e,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].name,
                    -1,
                    tm->entries[SOC_SBX_T3P1_PPE_EP2E_ID].fields[j].name,
                    "WIDTH");
        if (s) {
            soc_sbx_t3p1_uninit(unit);
            return s;
        }
    }
    
    return SOC_E_NONE;
}

soc_sbx_t3p1_field_desc_t g_soc_sbx_t3p1_egr_ppevar[PPE_RAM_EGR_PPEVAR_MAX] =
{
  {"pm_enable", 0, 2, 1},
  {"loopback", 1, 2, 1},
  {"pwe_y1731", 2, 2, 1},
};
soc_sbx_t3p1_field_desc_t g_soc_sbx_t3p1_ing_ppevar[PPE_RAM_ING_PPEVAR_MAX] =
{
  {"mim_transit", 0, 2, 1},
  {"lsm", 1, 2, 1},
  {"numlbls", 2, 4, 2},
  {"dcn", 4, 2, 1},
  {"oamen", 5, 2, 1},
  {"loopback", 6, 2, 1},
  {"lm_enable", 7, 2, 1},
  {"dm_enable", 8, 2, 1},
  {"vrrp", 9, 2, 1},
  {"mpls_ttl_expiry", 10, 2, 1},
  {"mplstp_loop", 11, 2, 1},
  {"pwe_ping", 12, 2, 1},
  {"pwe_y1731", 13, 2, 1},
  {"pwe_psc", 14, 2, 1},
  {"pwe_bfd", 15, 2, 1},
  {"lsp_gal", 16, 2, 1},
  {"traffictype", 17, 8, 3},
  {"l2cp", 20, 2, 1},
  {"l2cpslow", 21, 2, 1},
  {"pim", 22, 2, 1},
  {"igmp", 23, 2, 1},
  {"oamloop", 24, 2, 1},
};
/* PPE variable pack accessor implementation for egr_ppevar */
int soc_sbx_t3p1_egr_ppevar_pack(int unit, soc_sbx_t3p1_egr_ppevar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe = (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    int be = tm->behost;
    int bytes_to_clear;

    base = b;
    bytes_to_clear = bsz / 8;
    if (bsz & 0x7)
    {
        bytes_to_clear++;
    }
    sal_memset(b, 0, bytes_to_clear);

    base = b;
    if (be)
    {
        b+=bsz/8-1;
    }
    for (i = 0; i < SOC_SBX_T3P1_EGR_PPEVAR_MEMBER; ++i)
    {
        width = g_soc_sbx_t3p1_egr_ppevar[i].width;
        pos = g_soc_sbx_t3p1_egr_ppevar[i].pos;
        switch (i)
        {
              case 0: p = (uint8 *) &e->pm_enable; break;
              case 1: p = (uint8 *) &e->loopback; break;
              case 2: p = (uint8 *) &e->pwe_y1731; break;
             /* coverity[dead_error_begin] */
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe)
        {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b, be, pos, width, p, fbe, 0);
    }
    if (be) 
    {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }
    return SOC_E_NONE;
}
/* PPE variable unpack accessor implementation for egr_ppevar */
int soc_sbx_t3p1_egr_ppevar_unpack(int unit, soc_sbx_t3p1_egr_ppevar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe = (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+=bsz/8-1;
    }
    for (i = 0; i < SOC_SBX_T3P1_EGR_PPEVAR_MEMBER; ++i)
    {
        width = g_soc_sbx_t3p1_egr_ppevar[i].width;
        pos = g_soc_sbx_t3p1_egr_ppevar[i].pos;
        switch (i)
        {
              case 0: p = (uint8 *) &e->pm_enable; break;
              case 1: p = (uint8 *) &e->loopback; break;
              case 2: p = (uint8 *) &e->pwe_y1731; break;
             /* coverity[dead_error_begin] */
            default: return SOC_E_INTERNAL;
            
        }
        fbe = be && width <= 32;
        if (fbe)
        {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b, be, pos, width, p, fbe, 0);
    }
    return SOC_E_NONE;
}
/* PPE variable pack accessor implementation for ing_ppevar */
int soc_sbx_t3p1_ing_ppevar_pack(int unit, soc_sbx_t3p1_ing_ppevar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_t3p1_state_t *fe = (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    int be = tm->behost;
    int bytes_to_clear;

    base = b;
    bytes_to_clear = bsz / 8;
    if (bsz & 0x7)
    {
        bytes_to_clear++;
    }
    sal_memset(b, 0, bytes_to_clear);

    base = b;
    if (be)
    {
        b+=bsz/8-1;
    }
    for (i = 0; i < SOC_SBX_T3P1_ING_PPEVAR_MEMBER; ++i)
    {
        width = g_soc_sbx_t3p1_ing_ppevar[i].width;
        pos = g_soc_sbx_t3p1_ing_ppevar[i].pos;
        switch (i)
        {
              case 0: p = (uint8 *) &e->mim_transit; break;
              case 1: p = (uint8 *) &e->lsm; break;
              case 2: p = (uint8 *) &e->numlbls; break;
              case 3: p = (uint8 *) &e->dcn; break;
              case 4: p = (uint8 *) &e->oamen; break;
              case 5: p = (uint8 *) &e->loopback; break;
              case 6: p = (uint8 *) &e->lm_enable; break;
              case 7: p = (uint8 *) &e->dm_enable; break;
              case 8: p = (uint8 *) &e->vrrp; break;
              case 9: p = (uint8 *) &e->mpls_ttl_expiry; break;
              case 10: p = (uint8 *) &e->mplstp_loop; break;
              case 11: p = (uint8 *) &e->pwe_ping; break;
              case 12: p = (uint8 *) &e->pwe_y1731; break;
              case 13: p = (uint8 *) &e->pwe_psc; break;
              case 14: p = (uint8 *) &e->pwe_bfd; break;
              case 15: p = (uint8 *) &e->lsp_gal; break;
              case 16: p = (uint8 *) &e->traffictype; break;
              case 17: p = (uint8 *) &e->l2cp; break;
              case 18: p = (uint8 *) &e->l2cpslow; break;
              case 19: p = (uint8 *) &e->pim; break;
              case 20: p = (uint8 *) &e->igmp; break;
              case 21: p = (uint8 *) &e->oamloop; break;
             /* coverity[dead_error_begin] */
            default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe)
        {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_insert_or(b, be, pos, width, p, fbe, 0);
    }
    if (be) 
    {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }
    return SOC_E_NONE;
}
/* PPE variable unpack accessor implementation for ing_ppevar */
int soc_sbx_t3p1_ing_ppevar_unpack(int unit, soc_sbx_t3p1_ing_ppevar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_t3p1_state_t *fe = (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    int be = tm->behost;

    sal_memset(e, 0, sizeof(*e));
    if (be)
    {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
        b+=bsz/8-1;
    }
    for (i = 0; i < SOC_SBX_T3P1_ING_PPEVAR_MEMBER; ++i)
    {
        width = g_soc_sbx_t3p1_ing_ppevar[i].width;
        pos = g_soc_sbx_t3p1_ing_ppevar[i].pos;
        switch (i)
        {
              case 0: p = (uint8 *) &e->mim_transit; break;
              case 1: p = (uint8 *) &e->lsm; break;
              case 2: p = (uint8 *) &e->numlbls; break;
              case 3: p = (uint8 *) &e->dcn; break;
              case 4: p = (uint8 *) &e->oamen; break;
              case 5: p = (uint8 *) &e->loopback; break;
              case 6: p = (uint8 *) &e->lm_enable; break;
              case 7: p = (uint8 *) &e->dm_enable; break;
              case 8: p = (uint8 *) &e->vrrp; break;
              case 9: p = (uint8 *) &e->mpls_ttl_expiry; break;
              case 10: p = (uint8 *) &e->mplstp_loop; break;
              case 11: p = (uint8 *) &e->pwe_ping; break;
              case 12: p = (uint8 *) &e->pwe_y1731; break;
              case 13: p = (uint8 *) &e->pwe_psc; break;
              case 14: p = (uint8 *) &e->pwe_bfd; break;
              case 15: p = (uint8 *) &e->lsp_gal; break;
              case 16: p = (uint8 *) &e->traffictype; break;
              case 17: p = (uint8 *) &e->l2cp; break;
              case 18: p = (uint8 *) &e->l2cpslow; break;
              case 19: p = (uint8 *) &e->pim; break;
              case 20: p = (uint8 *) &e->igmp; break;
              case 21: p = (uint8 *) &e->oamloop; break;
             /* coverity[dead_error_begin] */
            default: return SOC_E_INTERNAL;
            
        }
        fbe = be && width <= 32;
        if (fbe)
        {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_t3p1_extract(b, be, pos, width, p, fbe, 0);
    }
    return SOC_E_NONE;
}
/* PPE variable argument checker for egr_ppevar */
int soc_sbx_t3p1_egr_ppevar_check(int unit, soc_sbx_t3p1_egr_ppevar_t *e)
{
    int i, r;
    uint32 ev = 0;

    for (i = 0; i < SOC_SBX_T3P1_EGR_PPEVAR_MEMBER; i++)
    {
        switch (i)
        {
          case 0: ev = e->pm_enable; break;
          case 1: ev = e->loopback; break;
          case 2: ev = e->pwe_y1731; break;
           /* coverity[dead_error_begin] */
          default: return SOC_E_INTERNAL;
        }
        r = g_soc_sbx_t3p1_egr_ppevar[i].range;
        if (0 < r && ((uint32) r) <= ev)
        {
            return SOC_E_PARAM;
        }
    }
    return SOC_E_NONE;
}
/* PPE variable argument checker for ing_ppevar */
int soc_sbx_t3p1_ing_ppevar_check(int unit, soc_sbx_t3p1_ing_ppevar_t *e)
{
    int i, r;
    uint32 ev = 0;

    for (i = 0; i < SOC_SBX_T3P1_ING_PPEVAR_MEMBER; i++)
    {
        switch (i)
        {
          case 0: ev = e->mim_transit; break;
          case 1: ev = e->lsm; break;
          case 2: ev = e->numlbls; break;
          case 3: ev = e->dcn; break;
          case 4: ev = e->oamen; break;
          case 5: ev = e->loopback; break;
          case 6: ev = e->lm_enable; break;
          case 7: ev = e->dm_enable; break;
          case 8: ev = e->vrrp; break;
          case 9: ev = e->mpls_ttl_expiry; break;
          case 10: ev = e->mplstp_loop; break;
          case 11: ev = e->pwe_ping; break;
          case 12: ev = e->pwe_y1731; break;
          case 13: ev = e->pwe_psc; break;
          case 14: ev = e->pwe_bfd; break;
          case 15: ev = e->lsp_gal; break;
          case 16: ev = e->traffictype; break;
          case 17: ev = e->l2cp; break;
          case 18: ev = e->l2cpslow; break;
          case 19: ev = e->pim; break;
          case 20: ev = e->igmp; break;
          case 21: ev = e->oamloop; break;
           /* coverity[dead_error_begin] */
          default: return SOC_E_INTERNAL;
        }
        r = g_soc_sbx_t3p1_ing_ppevar[i].range;
        if (0 < r && ((uint32) r) <= ev)
        {
            return SOC_E_PARAM;
        }
    }
    return SOC_E_NONE;
}
/*
 * PPE Table Manager initializer
 */
int soc_sbx_t3p1_ppe_tables_init(int unit)
{
    int rv;
    
    soc_sbx_t3p1_ppe_table_manager_t *tm;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;    
    uint32 v;
    
    if (!fe) {
        return SOC_E_INIT;
    }

    if (fe->ppe_mgr) {
        /* Free old info */
        soc_sbx_t3p1_ppe_tables_uninit(unit);
    }

    tm = sal_alloc(sizeof(soc_sbx_t3p1_ppe_table_manager_t), "ppe_tbl_mgr");
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_t3p1_ppe_table_manager_t));
    fe->ppe_mgr = tm;
    
    tm->indexes =  sal_alloc(sizeof(soc_sbx_t3p1_index_desc_t) * SOC_SBX_T3P1_PPE_MAX_TABLE_ID,
                           "ppe_mgr_idx");
    sal_memset(tm->indexes, 0, sizeof(soc_sbx_t3p1_index_desc_t) * SOC_SBX_T3P1_PPE_MAX_TABLE_ID);

    tm->entries =  sal_alloc(sizeof(soc_sbx_t3p1_entry_desc_t) * SOC_SBX_T3P1_PPE_MAX_TABLE_ID,
                             "ppe_mgr_entries");
    sal_memset(tm->entries, 0, sizeof(soc_sbx_t3p1_entry_desc_t) * SOC_SBX_T3P1_PPE_MAX_TABLE_ID);

    
    v = 0x1;
    tm->behost = !*((uint8 *) &v);   
  
    /* Sim support */
    tm->simbuffer = sal_alloc(1024, "ppe_sim_buffer");
    if (!tm->simbuffer) {
        return SOC_E_MEMORY;
    }
    tm->simbuffersize = 1024;
            
    rv = create_table_p2e(unit, tm);
    if (rv != SOC_E_NONE) {
       soc_sbx_t3p1_ppe_tables_uninit(unit);
       return rv;
    }     
    rv = create_table_ep2e(unit, tm);
    if (rv != SOC_E_NONE) {
       soc_sbx_t3p1_ppe_tables_uninit(unit);
       return rv;
    }     
    
    return SOC_E_NONE;
}

/* Uninitialization function implementation */
int soc_sbx_t3p1_ppe_tables_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_ppe_table_manager_t *tm;

    if (!fe->ppe_mgr) return s;
    tm = fe->ppe_mgr;
    
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_T3P1_PPE_MAX_TABLE_ID; i++) {
            if (tm->entries[i].fields) {
                sal_free(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                sal_free(tm->entries[i].indexes);
            }
        }
        sal_free(tm->entries);
    }
    
    if (tm->simbuffer)   sal_free(tm->simbuffer);
        
    sal_free(tm);
    fe->ppe_mgr = NULL;

    return s;
}

soc_sbx_t3p1_ppe_ptable_cfg_t soc_sbx_t3p1_ppe_ptable_cfg = {
  0, 3, 4, 5, 6, /* mode, CAM port A, B, C, D */
  {
    {"property_segment_0", 0, 0, 0} /* property_segment_0, segment, seg_id and start */,
    {"property_segment_1", 1, 1, 16} /* property_segment_1, segment, seg_id and start */,
    {"property_segment_2", 2, 2, 256} /* property_segment_2, segment, seg_id and start */,
    {"property_segment_3", 3, 3, 4096} /* property_segment_3, segment, seg_id and start */,
    {"property_segment_4", 4, 4, 8192} /* property_segment_4, segment, seg_id and start */,
    {"property_segment_5", 5, 5, 4096} /* property_segment_5, segment, seg_id and start */,
    {"property_segment_6", 6, 6, 4096} /* property_segment_6, segment, seg_id and start */,
    {"property_segment_7", 7, 7, 4096} /* property_segment_7, segment, seg_id and start */
  }
};



#endif
