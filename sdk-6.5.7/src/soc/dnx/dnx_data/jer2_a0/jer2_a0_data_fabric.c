/** \file jer2_a0_data_fabric.c
 * 
 * DEVICE DATA - FABRIC
 * 
 * Device Data
 * SW component that maintains per device data
 * The data is static and won't be changed after device initialization.
 *     
 * Supported data types:
 *     - Define             - a 'uint32' number (a max value for all devices is maintained)
 *     - feature            - 1 bit per each feature (supported/not supported) - support soc properties 
 *     - table              - the data is accessed with keys and/or can maintain multiple values and/or set by soc property
 *     - numeric            - a 'uint32' number that support soc properties
 * 
 * User interface for DNX DATA component can be found in "dnx_data_if.h" and "dnx_data_if_#module#.h"
 * 
 * Adding the data is done via XMLs placed in "tools/autocoder/DeviceData/dnx/.." 
 * "How to" User Guide can be found in confluence. 
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_FABRIC
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/dnx_data_internal_fabric.h>
#include <soc/dnx/dnx_data/dnx_data_property.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: links
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_links
 * define info:
 * nof of fabric links
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - see shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_links_nof_links_set(
    int unit)
{
    dnx_data_define_t *define;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_links;
    int define_index = dnx_data_fabric_links_define_nof_links;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnx_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 112;

    /* Set value */
    define->data = 112;

    /* Set data flags as supported */
    define->flags |= DNX_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: thresholds
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - see shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_thresholds_mode_supported_set(
    int unit)
{
    dnx_data_feature_t *feature;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_thresholds;
    int feature_index = dnx_data_fabric_thresholds_mode_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnx_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNX_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define default_mode
 * define info:
 * default mode for thresholds
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - see shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_thresholds_default_mode_set(
    int unit)
{
    dnx_data_define_t *define;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_thresholds;
    int define_index = dnx_data_fabric_thresholds_define_default_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnx_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNX_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table dch_default
 * Module - 'fabric', Submodule - 'thresholds', table - 'dch_default'
 * set of threholds
 * The function set relevant table structure in _dnx_data
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - See shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_thresholds_dch_default_set(
    int unit)
{
    int severity_index;
    int mode_index;
    dnx_data_fabric_thresholds_dch_default_t *data, *default_data;
    dnx_data_table_t *table;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_thresholds;
    int table_index = dnx_data_fabric_thresholds_table_dch_default;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnx_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNX_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 1;
    table->keys[1].size = 3;

    /* Info - default values */
    table->values[0].default_val = "SAL_UINT32_MAX";
    table->values[1].default_val = "SAL_UINT32_MAX";
    table->values[2].default_val = "SAL_UINT32_MAX";
    table->values[3].default_val = "SAL_UINT32_MAX";
    table->values[4].default_val = "SAL_UINT32_MAX";
    table->values[5].default_val = "SAL_UINT32_MAX";
    /* Store Default Values */
    default_data = (dnx_data_fabric_thresholds_dch_default_t *) dnx_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->gci0 = SAL_UINT32_MAX;
    default_data->gci1 = SAL_UINT32_MAX;
    default_data->gci2 = SAL_UINT32_MAX;
    default_data->rci0 = SAL_UINT32_MAX;
    default_data->rci1 = SAL_UINT32_MAX;
    default_data->rci2 = SAL_UINT32_MAX;
    /* Set Default Values */
    for (severity_index = 0; severity_index < 1; severity_index++)
    {
        for (mode_index = 0; mode_index < 3; mode_index++)
        {
            data = (dnx_data_fabric_thresholds_dch_default_t *) dnx_data_mgmt_table_data_get(unit, table, severity_index, mode_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_fabric_thresholds_dch_default_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    data->gci0 = 3;
    data->gci1 = 100;
    data->gci2 = 200;
    data->rci0 = 3;
    data->rci1 = 100;
    data->rci2 = 200;
    data = (dnx_data_fabric_thresholds_dch_default_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 1);
    data->gci0 = 3;
    data->gci1 = 100;
    data->gci2 = 200;
    data->rci0 = 3;
    data->rci1 = 100;
    data->rci2 = 200;
    data = (dnx_data_fabric_thresholds_dch_default_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 2);
    data->gci0 = 3;
    data->gci1 = 100;
    data->gci2 = 200;
    data->rci0 = 3;
    data->rci1 = 100;
    data->rci2 = 200;

    SHR_FUNC_EXIT;
}

/*
 * Submodule: cell
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_priorities
 * define info:
 * nof of supported fabric priorities
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - see shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_cell_nof_priorities_set(
    int unit)
{
    dnx_data_define_t *define;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_cell;
    int define_index = dnx_data_fabric_cell_define_nof_priorities;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnx_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNX_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table pcp
 * Module - 'fabric', Submodule - 'cell', table - 'pcp'
 * packet cell packing
 * The function set relevant table structure in _dnx_data
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - See shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_cell_pcp_set(
    int unit)
{
    dnx_data_fabric_cell_pcp_t *data, *default_data;
    dnx_data_table_t *table;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_cell;
    int table_index = dnx_data_fabric_cell_table_pcp;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnx_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNX_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "1";
    /* Store Default Values */
    default_data = (dnx_data_fabric_cell_pcp_t *) dnx_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->enable = 1;
    /* Set Default Values */
    data = (dnx_data_fabric_cell_pcp_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Property
     */
    table->property.name = "fabric_pcp_enable";
    table->property.doc =
        "\n"
        "Enable / Disable PCP:\n"
        "fabric_pcp_enable= 0 / 1\n"
        "When disabling PCP, the cell header will not include the extra fields required by PCP\n"
        "If directly connected to BCM88750 or in Mesh mode, PCP should be disabled.\n"
        "\n"
    ;
    table->property.method = dnx_data_property_method_enable;
    table->property.method_str = "enable";
    data = (dnx_data_fabric_cell_pcp_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    SHR_IF_ERR_EXIT(dnx_data_mgmt_property_read(unit, &table->property, 0, &data->enable));
    /* Set data flags as property */
    table->flags |= (DNX_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: pipes
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_pipes
 * define info:
 * max supported fabric pipes
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - see shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_pipes_max_nof_pipes_set(
    int unit)
{
    dnx_data_define_t *define;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_pipes;
    int define_index = dnx_data_fabric_pipes_define_max_nof_pipes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnx_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNX_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table nof_pipes
 * Module - 'fabric', Submodule - 'pipes', table - 'nof_pipes'
 * number of actual (configured) pipes
 * The function set relevant table structure in _dnx_data
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - See shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_pipes_nof_pipes_set(
    int unit)
{
    dnx_data_fabric_pipes_nof_pipes_t *data, *default_data;
    dnx_data_table_t *table;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_pipes;
    int table_index = dnx_data_fabric_pipes_table_nof_pipes;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnx_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNX_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "1";
    /* Store Default Values */
    default_data = (dnx_data_fabric_pipes_nof_pipes_t *) dnx_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = 1;
    /* Set Default Values */
    data = (dnx_data_fabric_pipes_nof_pipes_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Property
     */
    table->property.name = "fabric_num_pipes";
    table->property.doc =
        "\n"
        "Configure number of fabric pipes:\n"
        "fabric_num_pipes= 1/2/3\n"
        "Default: 1\n"
        "\n"
    ;
    table->property.method = dnx_data_property_method_range;
    table->property.method_str = "range";
    table->property.range_min = 0;
    table->property.range_max = 3;
    data = (dnx_data_fabric_pipes_nof_pipes_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    SHR_IF_ERR_EXIT(dnx_data_mgmt_property_read(unit, &table->property, 0, &data->val));
    /* Set data flags as property */
    table->flags |= (DNX_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table map
 * Module - 'fabric', Submodule - 'pipes', table - 'map'
 * map traffic cast X priority to fabric pipe
 * The function set relevant table structure in _dnx_data
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - See shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_pipes_map_set(
    int unit)
{
    dnx_data_fabric_pipes_map_t *data, *default_data;
    dnx_data_table_t *table;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_pipes;
    int table_index = dnx_data_fabric_pipes_table_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnx_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNX_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "0 0 0 0";
    table->values[1].default_val = "0 0 0 0";
    /* Store Default Values */
    default_data = (dnx_data_fabric_pipes_map_t *) dnx_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->uc[0] = 0;
    default_data->uc[1] = 0;
    default_data->uc[2] = 0;
    default_data->uc[3] = 0;
    default_data->mc[0] = 0;
    default_data->mc[1] = 0;
    default_data->mc[2] = 0;
    default_data->mc[3] = 0;
    /* Set Default Values */
    data = (dnx_data_fabric_pipes_map_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Property
     */
    table->property.name = "fabric_pipe_map";
    table->property.doc =
        "\n"
        "Assign traffic cast (unicast/multicast) and priority (0/1/2/3) to a pipe.\n"
        "fabric_pipe_map=0/1/2\n"
        "Assigning a specific traffic cast is done by a suffix uc/mc and a number which represents the cell priority.\n"
        "Not all the options supported, please find the supported options in UM\n"
        "\n"
    ;
    table->property.method = dnx_data_property_method_custom;
    table->property.method_str = "custom";
    data = (dnx_data_fabric_pipes_map_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    SHR_IF_ERR_EXIT(dnx_data_property_fabric_pipes_map_read(unit, data));
    /* Set data flags as property */
    table->flags |= (DNX_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table system
 * Module - 'fabric', Submodule - 'pipes', table - 'system'
 * system attributes
 * The function set relevant table structure in _dnx_data
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - See shr_error_e
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_fabric_pipes_system_set(
    int unit)
{
    dnx_data_fabric_pipes_system_t *data, *default_data;
    dnx_data_table_t *table;
    int module_index = dnx_data_module_fabric;
    int submodule_index = dnx_data_fabric_submodule_pipes;
    int table_index = dnx_data_fabric_pipes_table_system;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnx_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNX_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Store Default Values */
    default_data = (dnx_data_fabric_pipes_system_t *) dnx_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->multi_pipe = 0;
    /* Set Default Values */
    data = (dnx_data_fabric_pipes_system_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Property
     */
    table->property.name = "system_contains_multiple_pipe_device";
    table->property.doc =
        "\n"
        "To determine if there is a multiple pipe device in the system:\n"
        "system_contains_multiple_pipe_device = 0/1\n"
        "Default: 0\n"
        "\n"
    ;
    table->property.method = dnx_data_property_method_enable;
    table->property.method_str = "enable";
    data = (dnx_data_fabric_pipes_system_t *) dnx_data_mgmt_table_data_get(unit, table, 0, 0);
    SHR_IF_ERR_EXIT(dnx_data_mgmt_property_read(unit, &table->property, 0, &data->multi_pipe));
    /* Set data flags as property */
    table->flags |= (DNX_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \par DIRECT INPUT:
 *   \param [in] unit - Unit #
 * \par INDIRECT INPUT:
 *   * None
 * \par DIRECT OUTPUT:
 *     err - 
 * \par INDIRECT OUTPUT:
 * \remark
 *   * None
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_fabric_attach(
    int unit)
{
    dnx_data_module_t *module = NULL;
    dnx_data_submodule_t *submodule = NULL;
    dnx_data_define_t *define = NULL;
    dnx_data_feature_t *feature = NULL;
    dnx_data_table_t *table = NULL;
    int module_index = dnx_data_module_fabric;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnx_data[unit].modules[module_index];
    /*
     * Attach submodule: links
     */
    submodule_index = dnx_data_fabric_submodule_links;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_fabric_links_define_nof_links;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_fabric_links_nof_links_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: thresholds
     */
    submodule_index = dnx_data_fabric_submodule_thresholds;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_fabric_thresholds_define_default_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_fabric_thresholds_default_mode_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_fabric_thresholds_mode_supported;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_fabric_thresholds_mode_supported_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_fabric_thresholds_table_dch_default;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_fabric_thresholds_dch_default_set;
    /*
     * Attach submodule: cell
     */
    submodule_index = dnx_data_fabric_submodule_cell;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_fabric_cell_define_nof_priorities;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_fabric_cell_nof_priorities_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_fabric_cell_table_pcp;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_fabric_cell_pcp_set;
    /*
     * Attach submodule: pipes
     */
    submodule_index = dnx_data_fabric_submodule_pipes;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_fabric_pipes_define_max_nof_pipes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_fabric_pipes_max_nof_pipes_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_fabric_pipes_table_nof_pipes;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_fabric_pipes_nof_pipes_set;
    data_index = dnx_data_fabric_pipes_table_map;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_fabric_pipes_map_set;
    data_index = dnx_data_fabric_pipes_table_system;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_fabric_pipes_system_set;

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
