/*
 * $Id: ser.c $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * File:      ser.c
 * Purpose:   SER enable/detect and test functionality.
 * Requires:  sal/soc/shared layer
 */

#include <soc/saber2.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <shared/bsl.h>
#include <soc/soc_ser_log.h>

#ifdef BCM_SABER2_SUPPORT

#define _SOC_SABER2_SER_REG 1
#define _SOC_SABER2_SER_MEM 0
#define _SOC_SABER2_SER_INVALID 0xFF

#define _SOC_SABER2_SER_FLAG_MASK ( SOC_MEM_FLAG_SER_SPECIAL | SOC_MEM_FLAG_SER_ENGINE | SOC_MEM_FLAG_SER_ENTRY_CLEAR \
                                   | SOC_MEM_FLAG_SER_SRAM_CORRECTION | SOC_MEM_FLAG_SER_CACHE_RESTORE \
                                   | SOC_MEM_FLAG_SER_ECC_CORRECTABLE | SOC_MEM_FLAG_SER_WRITE_CACHE_RESTORE )

#define _SOC_SABER2_SAT_CMIC_BIT    (1U << 2)

typedef union _soc_saber2_ser_nack_reg_mem_u {
    soc_reg_t reg;
    soc_mem_t mem;
} _soc_saber2_ser_nack_reg_mem_t;

/*  ser part   */
typedef struct _soc_saber2_fifo_ser_info_s {
    soc_reg_t   enable_reg;
    soc_field_t enable_field;
    uint8       type; /* 0: mem, 1: reg,  */
    soc_mem_t   mem;
    soc_reg_t   reg;
    char        *name_str; /* Used when mem == INVALIDm or reg == INVALIDr */   
    soc_field_t        parity_field; /* used to sw inject test */
} _soc_saber2_fifo_ser_info_t;

typedef struct _soc_td2_ser_block_info_s {
    soc_block_t              blocktype;
    soc_reg_t                fifo_reset_reg;
    _soc_saber2_fifo_ser_info_t *info;
} _soc_saber2_fifo_ser_block_info_t;


typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_HASH,
    _SOC_PARITY_TYPE_EDATABUF,
    _SOC_PARITY_TYPE_COUNTER,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_TYPE_OAM
} _soc_saber2_parity_info_type_t;


typedef struct _soc_saber2_parity_reg_s {
    soc_reg_t          reg;
    char               *mem_str;
} _soc_saber2_parity_reg_t;


typedef struct _soc_saber2_parity_info_s {
    _soc_saber2_parity_info_type_t       type;
    struct _soc_saber2_parity_info_s *info;
    int                id;
    soc_field_t        group_reg_enable_field;
    soc_field_t        group_reg_status_field;
    soc_mem_t          mem;
    char               *mem_str;
    soc_reg_t          enable_reg;
    soc_field_t        enable_field;
    soc_reg_t          intr_status_reg;
    _soc_saber2_parity_reg_t         *intr_status_reg_list;
    soc_reg_t                         nack_status_reg;
    _soc_saber2_parity_reg_t         *nack_status_reg_list;
} _soc_saber2_parity_info_t;


typedef struct _soc_saber2_parity_route_block_s {
    uint32             cmic_bit;
    soc_block_t        blocktype;
    soc_reg_t          enable_reg;
    soc_reg_t          status_reg;    
    soc_field_t        enable_field;
    _soc_saber2_parity_info_t *info;
    uint8              id;
} _soc_saber2_parity_route_block_t;


typedef struct _soc_saber2_skip_mem_reg_s {
    uint32           regmem;
    soc_reg_t        skip_reg;    
    soc_mem_t        skip_mem;
} _soc_saber2_skip_mem_reg_t;


/* this enums  need to modify.  */
typedef enum {
    _SOC_SABER2_MMU_SUBBLOCK_IPCTR,
    _SOC_SABER2_MMU_SUBBLOCK_ADM,
    _SOC_SABER2_MMU_SUBBLOCK_RDE,
    _SOC_SABER2_MMU_SUBBLOCK_INFO2,
    _SOC_SABER2_MMU_SUBBLOCK_MEM1,
    _SOC_SABER2_MMU_SUBBLOCK_INTFI_ECC,
    _SOC_SABER2_MMU_SUBBLOCK_ITE_CFG,
    _SOC_SABER2_MMU_SUBBLOCK_THDI,
    _SOC_SABER2_MMU_SUBBLOCK_ENQ_CFG,
    _SOC_SABER2_MMU_SUBBLOCK_ENQ_FAP,
    _SOC_SABER2_MMU_SUBBLOCK_CI1,
    _SOC_SABER2_MMU_SUBBLOCK_CI0,
    _SOC_SABER2_MMU_SUBBLOCK_WRED,
    _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS1,
    _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS2,
    _SOC_SABER2_MMU_SUBBLOCK_RQE_SER,
    _SOC_SABER2_MMU_SUBBLOCK_RQE_EXTQ,
    _SOC_SABER2_MMU_SUBBLOCK_EMC,
    _SOC_SABER2_MMU_SUBBLOCK_DEQ,
    _SOC_SABER2_MMU_SUBBLOCK_CTR,
    _SOC_SABER2_MMU_SUBBLOCK_CFAPI,
    _SOC_SABER2_MMU_SUBBLOCK_CFAPE,
    _SOC_SABER2_MMU_SUBBLOCK_CCP,
    _SOC_SABER2_MMU_SUBBLOCK_AGING_INT,
    _SOC_SABER2_MMU_SUBBLOCK_AGING_EXT,
    _SOC_SABER2_MMU_SUBBLOCK_LLS,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_PORT,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_L0_ECC,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_UPD2,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_L1_ECC,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_L2_ECC,
    _SOC_SABER2_MMU_SUBBLOCK_LLS_MISC_ECC,
    _SOC_SABER2_MMU_SUBBLOCK_QSTRUCT,
    _SOC_SABER2_MMU_SUBBLOCK_TOQ,
    _SOC_SABER2_MMU_SUBBLOCK_MAX
} _soc_saber2_mmu_subblock_type_t;


/* this enums  need to modify.  */
typedef enum {
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
    _SOC_SABER2_MMU_LVL2_SUBBLOCK_MAX
} _soc_saber2_mmu_lvl2_subblock_type_t;


typedef struct _soc_saber2_mmu_sub_block_leaf_info_s {
    uint32             intr_bit; /* bit position in intr register of sub block */
    soc_mem_t          mem;
    char               *mem_str;
    soc_field_t        status_field; /* INTR field of a leaf block */
    soc_field_t        enable_field; /* MASK field of a leaf block */    
    soc_field_t        mem_parity_field; /* used to sw inject test */
    soc_mem_t          mem_parity_enable_reg;  /* mem parity enable reg */
    soc_field_t        mem_parity_enable_field; /* mem parity enable field */    
    soc_mem_t          mem_ecc_address_reg;  /* get memory entry id for correction */
    soc_field_t        mem_ecc_address_field; /* get memory entry id for correction */
} _soc_saber2_mmu_sub_block_leaf_info_t;


typedef struct _soc_saber2_mmu_sub_block_internal_info_s {
    uint32             intr_bit; /* bit position in level 1 sub block INTR and INTR_MASK */
    _soc_saber2_mmu_lvl2_subblock_type_t lvl2_sub_block; /* level 2 sub block  */
    soc_field_t        internal_enable_field; /* field in 1evel 1 sub block INTR MASK register */
    soc_field_t        internal_status_field; /* field in level 1 sub block INTR register */
    soc_reg_t          leaf_enable_reg;   /* intr mask register for level 2 sub block */
    soc_reg_t          leaf_status_reg;   /* intr register for level 2 sub block */
    _soc_saber2_mmu_sub_block_leaf_info_t *info;
} _soc_saber2_mmu_sub_block_internal_info_t;


typedef struct _soc_saber2_mmu_sub_block_one_level_s {
    uint32             mmu_bit;  /* bit position in MMU_INTR and MMU_INTR_MASK  */
    _soc_saber2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_intr_mask_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_intr_status_field; /* field in MMU_INTR */    
    soc_reg_t          intr_mask_reg; /* intr mask register for sub block */
    soc_reg_t          lntr_status_reg; /* intr register for sub block */
    _soc_saber2_mmu_sub_block_leaf_info_t *info; /* list of memory instances */
} _soc_saber2_mmu_sub_block_one_level_t;


typedef struct _soc_saber2_mmu_sub_block_two_level_s {
    uint32             mmu_bit; /* bit position in MMU_INTR and MMU_INTR_MASK */
    _soc_saber2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_enable_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_status_field; /* field in MMU_INTR */
    soc_reg_t          internal_enable_reg; /* intr mask for sub block */
    soc_reg_t          internal_status_reg; /* intr for sub block */
    _soc_saber2_mmu_sub_block_internal_info_t *info;
} _soc_saber2_mmu_sub_block_two_level_t;


STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_lls_l0_parity_info[] = {

    /* LLS_L0_ECC_ERROR1 */
    { 0x00000001, LLS_L0_SHAPER_BUCKET_Cm, "", 
        DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L0_SHAPER_BUCKET_C_ECC_STATUSr, DB_L0_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},
    { 0x00000002, LLS_L0_SHAPER_BUCKET_Cm, "", 
        DB_L0_SHAPER_BUCKET_C_CORRECTED_ERRORf,
        DB_L0_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L0_SHAPER_BUCKET_C_ECC_STATUSr, DB_L0_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},

    { 0x00000004, LLS_L0_EF_NEXTm, "", 
        DB_L0_EF_NEXT_UNCORRECTED_ERRORf,
        DB_L0_EF_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_EF_NEXT_ENABLE_ECCf,
        LLS_L0_EF_NEXT_ECC_STATUSr, DB_L0_EF_NEXT_ECC_ERROR_ADDRESSf},
    { 0x00000008, LLS_L0_EF_NEXTm, "",  
        DB_L0_EF_NEXT_CORRECTED_ERRORf,
        DB_L0_EF_NEXT_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_EF_NEXT_ENABLE_ECCf,
        LLS_L0_EF_NEXT_ECC_STATUSr, DB_L0_EF_NEXT_ECC_ERROR_ADDRESSf},
    
    { 0x00000010, LLS_L0_WERR_NEXTm, "", 
        DB_L0_WERR_NEXT_UNCORRECTED_ERRORf,
        DB_L0_WERR_NEXT_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_WERR_NEXT_ENABLE_ECCf,
        LLS_L0_WERR_NEXT_ECC_STATUSr, DB_L0_WERR_NEXT_ECC_ERROR_ADDRESSf},
    { 0x00000020, LLS_L0_WERR_NEXTm, "", 
        DB_L0_WERR_NEXT_CORRECTED_ERRORf,
        DB_L0_WERR_NEXT_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_WERR_NEXT_ENABLE_ECCf,
        LLS_L0_WERR_NEXT_ECC_STATUSr, DB_L0_WERR_NEXT_ECC_ERROR_ADDRESSf},
 
    { 0x00000040, LLS_L0_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
        DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L0_CHILD_WEIGHT_CFG_CNT_ECC_STATUSr, DB_L0_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},    
    { 0x00000080, LLS_L0_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
        DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf,            
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L0_CHILD_WEIGHT_CFG_CNT_ECC_STATUSr, DB_L0_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},    

    { 0x00000100, LLS_L0_CHILD_STATE1m, "", 
        DB_L0_CHILD_STATE1_UNCORRECTED_ERRORf,
        DB_L0_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_CHILD_STATE1_ENABLE_ECCf,
        LLS_L0_CHILD_STATE1_ECC_STATUSr, DB_L0_CHILD_STATE1_ECC_ERROR_ADDRESSf},        
    { 0x00000200, LLS_L0_CHILD_STATE1m, "", 
        DB_L0_CHILD_STATE1_CORRECTED_ERRORf,
        DB_L0_CHILD_STATE1_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_CHILD_STATE1_ENABLE_ECCf,
        LLS_L0_CHILD_STATE1_ECC_STATUSr, DB_L0_CHILD_STATE1_ECC_ERROR_ADDRESSf},    

    { 0x00000400, LLS_L0_MIN_BUCKET_Cm, "", 
        DB_L0_MIN_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L0_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L0_MIN_BUCKET_C_ECC_STATUSr, DB_L0_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},     
    { 0x00000800, LLS_L0_MIN_BUCKET_Cm, "", 
        DB_L0_MIN_BUCKET_C_CORRECTED_ERRORf,
        DB_L0_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L0_MIN_BUCKET_C_ECC_STATUSr, DB_L0_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},     

    { 0x00001000, LLS_L0_WERR_MAX_SCm, "", 
        DB_L0_WERR_MAX_SC_UNCORRECTED_ERRORf,
        DB_L0_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_WERR_MAX_SC_ENABLE_ECCf,
        LLS_L0_WERR_MAX_SC_ECC_STATUSr, DB_L0_WERR_MAX_SC_ECC_ERROR_ADDRESSf},     
    { 0x00002000, LLS_L0_WERR_MAX_SCm, "", 
        DB_L0_WERR_MAX_SC_CORRECTED_ERRORf,
        DB_L0_WERR_MAX_SC_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_WERR_MAX_SC_ENABLE_ECCf,
        LLS_L0_WERR_MAX_SC_ECC_STATUSr, DB_L0_WERR_MAX_SC_ECC_ERROR_ADDRESSf},           
    
    { 0x00004000, LLS_L0_HEADS_TAILSm, "", 
        DB_L0_HEADS_TAILS_UNCORRECTED_ERRORf,
        DB_L0_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_HEADS_TAILS_ENABLE_ECCf,
        LLS_L0_HEADS_TAILS_ECC_STATUSr, DB_L0_HEADS_TAILS_ECC_ERROR_ADDRESSf},   
    { 0x00008000, LLS_L0_HEADS_TAILSm, "",  
        DB_L0_HEADS_TAILS_CORRECTED_ERRORf,
        DB_L0_HEADS_TAILS_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_HEADS_TAILS_ENABLE_ECCf,
        LLS_L0_HEADS_TAILS_ECC_STATUSr, DB_L0_HEADS_TAILS_ECC_ERROR_ADDRESSf}, 
        
    { 0x00010000, LLS_L0_PARENT_STATEm, "", 
        DB_L0_PARENT_STATE_UNCORRECTED_ERRORf,
        DB_L0_PARENT_STATE_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_PARENT_STATE_ENABLE_ECCf,
        LLS_L0_PARENT_STATE_ECC_STATUSr, DB_L0_PARENT_STATE_ECC_ERROR_ADDRESSf},           
    { 0x00020000, LLS_L0_PARENT_STATEm, "",  
        DB_L0_PARENT_STATE_CORRECTED_ERRORf,
        DB_L0_PARENT_STATE_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_PARENT_STATE_ENABLE_ECCf,
        LLS_L0_PARENT_STATE_ECC_STATUSr, DB_L0_PARENT_STATE_ECC_ERROR_ADDRESSf},   

    { 0x00040000, LLS_L0_MIN_CONFIG_Cm, "", 
        DB_L0_MIN_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L0_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUG1r, DB_L0_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L0_MIN_CONFIG_C_ECC_STATUSr, DB_L0_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},   
    { 0x00080000, LLS_L0_MIN_CONFIG_Cm, "",  
        DB_L0_MIN_CONFIG_C_CORRECTED_ERRORf,
        DB_L0_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUG1r, DB_L0_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L0_MIN_CONFIG_C_ECC_STATUSr, DB_L0_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},   

    { 0x00100000, LLS_L0_CONFIGm, "", 
        DB_L0_CONFIG_UNCORRECTED_ERRORf,
        DB_L0_CONFIG_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_CONFIG_ENABLE_ECCf,
        LLS_L0_CONFIG_ECC_STATUSr, DB_L0_CONFIG_ECC_ERROR_ADDRESSf},      
    { 0x00200000, LLS_L0_CONFIGm, "",  
        DB_L0_CONFIG_CORRECTED_ERRORf,
        DB_L0_CONFIG_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_CONFIG_ENABLE_ECCf,
        LLS_L0_CONFIG_ECC_STATUSr, DB_L0_CONFIG_ECC_ERROR_ADDRESSf},      

    { 0x00400000, LLS_L0_PARENTm, "", 
        DB_L0_PARENT_UNCORRECTED_ERRORf,
        DB_L0_PARENT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_PARENT_ENABLE_ECCf,
        LLS_L0_PARENT_ECC_STATUSr, DB_L0_PARENT_ECC_ERROR_ADDRESSf},      
    { 0x00800000, LLS_L0_PARENTm, "", 
        DB_L0_PARENT_CORRECTED_ERRORf,
        DB_L0_PARENT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_PARENT_ENABLE_ECCf,
        LLS_L0_PARENT_ECC_STATUSr, DB_L0_PARENT_ECC_ERROR_ADDRESSf},      

    { 0x01000000, LLS_L0_MIN_NEXTm, "", 
        DB_L0_MIN_NEXT_UNCORRECTED_ERRORf,
        DB_L0_MIN_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUGr, DB_L0_MIN_NEXT_ENABLE_ECCf,
        LLS_L0_MIN_NEXT_ECC_STATUSr, DB_L0_MIN_NEXT_ECC_ERROR_ADDRESSf},      
    { 0x02000000, LLS_L0_MIN_NEXTm, "",  
        DB_L0_MIN_NEXT_CORRECTED_ERRORf,
        DB_L0_MIN_NEXT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUGr, DB_L0_MIN_NEXT_ENABLE_ECCf,
        LLS_L0_MIN_NEXT_ECC_STATUSr, DB_L0_MIN_NEXT_ECC_ERROR_ADDRESSf},      
    
    { 0x04000000, LLS_L0_SHAPER_CONFIG_Cm, "", 
        DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L0_ECC_DEBUG1r, DB_L0_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L0_SHAPER_CONFIG_C_ECC_STATUSr, DB_L0_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},      
    { 0x08000000, LLS_L0_SHAPER_CONFIG_Cm, "", 
        DB_L0_SHAPER_CONFIG_C_CORRECTED_ERRORf,
        DB_L0_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L0_ECC_DEBUG1r, DB_L0_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L0_SHAPER_CONFIG_C_ECC_STATUSr, DB_L0_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},             
    
    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_lls_l1_parity_info[] = {
    /* LLS_L1_ECC_ERROR1 */
    { 0x00000001, LLS_L1_SHAPER_BUCKET_Cm, "", 
        DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L1_SHAPER_BUCKET_C_ECC_STATUSr, DB_L1_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},
    { 0x00000002, LLS_L1_SHAPER_BUCKET_Cm, "", 
        DB_L1_SHAPER_BUCKET_C_CORRECTED_ERRORf,
        DB_L1_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L1_SHAPER_BUCKET_C_ECC_STATUSr, DB_L1_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},       

    { 0x00000004, LLS_L1_EF_NEXTm, "", 
        DB_L1_EF_NEXT_UNCORRECTED_ERRORf,
        DB_L1_EF_NEXT_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_EF_NEXT_ENABLE_ECCf,
        LLS_L1_EF_NEXT_ECC_STATUSr, DB_L1_EF_NEXT_ECC_ERROR_ADDRESSf},       
    { 0x00000008, LLS_L1_EF_NEXTm, "",  
        DB_L1_EF_NEXT_CORRECTED_ERRORf,
        DB_L1_EF_NEXT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_EF_NEXT_ENABLE_ECCf,
        LLS_L1_EF_NEXT_ECC_STATUSr, DB_L1_EF_NEXT_ECC_ERROR_ADDRESSf},    
        
    { 0x00000010, LLS_L1_WERR_NEXTm, "", 
        DB_L1_WERR_NEXT_UNCORRECTED_ERRORf,
        DB_L1_WERR_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_WERR_NEXT_ENABLE_ECCf,
        LLS_L1_WERR_NEXT_ECC_STATUSr, DB_L1_WERR_NEXT_ECC_ERROR_ADDRESSf},            
    { 0x00000020, LLS_L1_WERR_NEXTm, "", 
        DB_L1_WERR_NEXT_CORRECTED_ERRORf,
        DB_L1_WERR_NEXT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_WERR_NEXT_ENABLE_ECCf,
        LLS_L1_WERR_NEXT_ECC_STATUSr, DB_L1_WERR_NEXT_ECC_ERROR_ADDRESSf},            
 
    { 0x00000040, LLS_L1_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
        DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L1_CHILD_WEIGHT_CFG_CNT_ECC_STATUSr, DB_L1_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},            
    { 0x00000080, LLS_L1_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
        DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L1_CHILD_WEIGHT_CFG_CNT_ECC_STATUSr, DB_L1_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},            

    { 0x00000100, LLS_L1_CHILD_STATE1m, "", 
        DB_L1_CHILD_STATE1_UNCORRECTED_ERRORf,
        DB_L1_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_CHILD_STATE1_ENABLE_ECCf,
        LLS_L1_CHILD_STATE1_ECC_STATUSr, DB_L1_CHILD_STATE1_ECC_ERROR_ADDRESSf},            
    { 0x00000200, LLS_L1_CHILD_STATE1m, "", 
        DB_L1_CHILD_STATE1_CORRECTED_ERRORf,
        DB_L1_CHILD_STATE1_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_CHILD_STATE1_ENABLE_ECCf,
        LLS_L1_CHILD_STATE1_ECC_STATUSr, DB_L1_CHILD_STATE1_ECC_ERROR_ADDRESSf},            

    { 0x00000400, LLS_L1_MIN_BUCKET_Cm, "", 
        DB_L1_MIN_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L1_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L1_MIN_BUCKET_C_ECC_STATUSr, DB_L1_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},            
    { 0x00000800, LLS_L1_MIN_BUCKET_Cm, "", 
        DB_L1_MIN_BUCKET_C_CORRECTED_ERRORf,
        DB_L1_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L1_MIN_BUCKET_C_ECC_STATUSr, DB_L1_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},            

    { 0x00001000, LLS_L1_WERR_MAX_SCm, "", 
        DB_L1_WERR_MAX_SC_UNCORRECTED_ERRORf,
        DB_L1_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_WERR_MAX_SC_ENABLE_ECCf,
        LLS_L1_WERR_MAX_SC_ECC_STATUSr, DB_L1_WERR_MAX_SC_ECC_ERROR_ADDRESSf},                 
    { 0x00002000, LLS_L1_WERR_MAX_SCm, "", 
        DB_L1_WERR_MAX_SC_CORRECTED_ERRORf,
        DB_L1_WERR_MAX_SC_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_WERR_MAX_SC_ENABLE_ECCf,
        LLS_L1_WERR_MAX_SC_ECC_STATUSr, DB_L1_WERR_MAX_SC_ECC_ERROR_ADDRESSf},  
    
    { 0x00004000, LLS_L1_HEADS_TAILSm, "", 
        DB_L1_HEADS_TAILS_UNCORRECTED_ERRORf,
        DB_L1_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_HEADS_TAILS_ENABLE_ECCf,
        LLS_L1_HEADS_TAILS_ECC_STATUSr, DB_L1_HEADS_TAILS_ECC_ERROR_ADDRESSf},            
    { 0x00008000, LLS_L1_HEADS_TAILSm, "",  
        DB_L1_HEADS_TAILS_CORRECTED_ERRORf,
        DB_L1_HEADS_TAILS_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_HEADS_TAILS_ENABLE_ECCf,
        LLS_L1_HEADS_TAILS_ECC_STATUSr, DB_L1_HEADS_TAILS_ECC_ERROR_ADDRESSf},                    

    { 0x00010000, LLS_L1_PARENT_STATEm, "", 
        DB_L1_PARENT_STATE_UNCORRECTED_ERRORf,
        DB_L1_PARENT_STATE_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_PARENT_STATE_ENABLE_ECCf,
        LLS_L1_PARENT_STATE_ECC_STATUSr, DB_L1_PARENT_STATE_ECC_ERROR_ADDRESSf},          
    { 0x00020000, LLS_L1_PARENT_STATEm, "",  
        DB_L1_PARENT_STATE_CORRECTED_ERRORf,
        DB_L1_PARENT_STATE_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_PARENT_STATE_ENABLE_ECCf,
        LLS_L1_PARENT_STATE_ECC_STATUSr, DB_L1_PARENT_STATE_ECC_ERROR_ADDRESSf},          

    { 0x00040000, LLS_L1_MIN_CONFIG_Cm, "", 
        DB_L1_MIN_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L1_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1Ar, DB_L1_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L1_MIN_CONFIG_C_ECC_STATUSr, DB_L1_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},          
    { 0x00080000, LLS_L1_MIN_CONFIG_Cm, "",  
        DB_L1_MIN_CONFIG_C_CORRECTED_ERRORf,
        DB_L1_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1Ar, DB_L1_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L1_MIN_CONFIG_C_ECC_STATUSr, DB_L1_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},          

    { 0x00100000, LLS_L1_CONFIGm, "", 
        DB_L1_CONFIG_UNCORRECTED_ERRORf,
        DB_L1_CONFIG_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1r, DB_L1_CONFIG_ENABLE_ECCf,
        LLS_L1_CONFIG_ECC_STATUSr, DB_L1_CONFIG_ECC_ERROR_ADDRESSf},  
    { 0x00200000, LLS_L1_CONFIGm, "",  
        DB_L1_CONFIG_CORRECTED_ERRORf,
        DB_L1_CONFIG_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1r, DB_L1_CONFIG_ENABLE_ECCf,
        LLS_L1_CONFIG_ECC_STATUSr, DB_L1_CONFIG_ECC_ERROR_ADDRESSf},  

    { 0x00400000, LLS_L1_PARENTm, "", 
        DB_L1_PARENT_UNCORRECTED_ERRORf,
        DB_L1_PARENT_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L1_ECC_DEBUG1r, DB_L1_PARENT_ENABLE_ECCf,
        LLS_L1_PARENT_ECC_STATUSr, DB_L1_PARENT_ECC_ERROR_ADDRESSf},  
    { 0x00800000, LLS_L1_PARENTm, "", 
        DB_L1_PARENT_CORRECTED_ERRORf,
        DB_L1_PARENT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1r, DB_L1_PARENT_ENABLE_ECCf,
        LLS_L1_PARENT_ECC_STATUSr, DB_L1_PARENT_ECC_ERROR_ADDRESSf},          

    { 0x01000000, LLS_L1_MIN_NEXTm, "", 
        DB_L1_MIN_NEXT_UNCORRECTED_ERRORf,
        DB_L1_MIN_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1r, DB_L1_MIN_NEXT_ENABLE_ECCf,
        LLS_L1_MIN_NEXT_ECC_STATUSr, DB_L1_MIN_NEXT_ECC_ERROR_ADDRESSf},  
    { 0x02000000, LLS_L1_MIN_NEXTm, "",  
        DB_L1_MIN_NEXT_CORRECTED_ERRORf,
        DB_L1_MIN_NEXT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1r, DB_L1_MIN_NEXT_ENABLE_ECCf,
        LLS_L1_MIN_NEXT_ECC_STATUSr, DB_L1_MIN_NEXT_ECC_ERROR_ADDRESSf},          
    
    { 0x04000000, LLS_L1_SHAPER_CONFIG_Cm, "", 
        DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L1_ECC_DEBUG1r, DB_L1_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L1_SHAPER_CONFIG_C_ECC_STATUSr, DB_L1_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},  
    { 0x08000000, LLS_L1_SHAPER_CONFIG_Cm, "", 
        DB_L1_SHAPER_CONFIG_C_CORRECTED_ERRORf,
        DB_L1_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L1_ECC_DEBUG1r, DB_L1_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L1_SHAPER_CONFIG_C_ECC_STATUSr, DB_L1_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},         
    
    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_lls_l2_parity_info[] = {
    /* LLS_L2_ECC_ERROR1 */
    { 0x00000001, LLS_L2_MIN_NEXTm, "", 
        DB_L2_MIN_NEXT_UNCORRECTED_ERRORf,
        DB_L2_MIN_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG1r, DB_L2_MIN_NEXT_ENABLE_ECCf,
        LLS_L2_MIN_NEXT_ECC_STATUSr, DB_L2_MIN_NEXT_ECC_ERROR_ADDRESSf},         
    { 0x00000002, LLS_L2_MIN_NEXTm, "",  
        DB_L2_MIN_NEXT_CORRECTED_ERRORf,
        DB_L2_MIN_NEXT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG1r, DB_L2_MIN_NEXT_ENABLE_ECCf,
        LLS_L2_MIN_NEXT_ECC_STATUSr, DB_L2_MIN_NEXT_ECC_ERROR_ADDRESSf},                 
           
    { 0x00000004, LLS_L2_WERR_NEXTm, "", 
        DB_L2_WERR_NEXT_UNCORRECTED_ERRORf,
        DB_L2_WERR_NEXT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG1r, DB_L2_WERR_NEXT_ENABLE_ECCf,
        LLS_L2_WERR_NEXT_ECC_STATUSr, DB_L2_WERR_NEXT_ECC_ERROR_ADDRESSf},                         
    { 0x00000008, LLS_L2_WERR_NEXTm, "", 
        DB_L2_WERR_NEXT_CORRECTED_ERRORf,
        DB_L2_WERR_NEXT_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_L2_ECC_DEBUG1r, DB_L2_WERR_NEXT_ENABLE_ECCf,
        LLS_L2_WERR_NEXT_ECC_STATUSr, DB_L2_WERR_NEXT_ECC_ERROR_ADDRESSf},                         

    { 0x00000010, LLS_L2_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
        DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG1r, DB_L2_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L2_CHILD_WEIGHT_CFG_ECC_STATUSr, DB_L2_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},                            
    { 0x00000020, LLS_L2_CHILD_WEIGHT_CFG_CNTm, "", 
        DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
        DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG1r, DB_L2_CHILD_WEIGHT_CFG_CNT_ENABLE_ECCf,
        LLS_L2_CHILD_WEIGHT_CFG_ECC_STATUSr, DB_L2_CHILD_WEIGHT_CFG_CNT_ECC_ERROR_ADDRESSf},                                   

    { 0x00000040, LLS_L2_PARENTm, "", 
        DB_L2_PARENT_UNCORRECTED_ERRORf,
        DB_L2_PARENT_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG1r, DB_L2_PARENT_ENABLE_ECCf,
        LLS_L2_PARENT_ECC_STATUSr, DB_L2_PARENT_ECC_ERROR_ADDRESSf},
    { 0x00000080, LLS_L2_PARENTm, "", 
        DB_L2_PARENT_CORRECTED_ERRORf,
        DB_L2_PARENT_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG1r, DB_L2_PARENT_ENABLE_ECCf,
        LLS_L2_PARENT_ECC_STATUSr, DB_L2_PARENT_ECC_ERROR_ADDRESSf},        

    { 0x00000100, LLS_L2_CHILD_STATE1m, "", 
        DB_L2_CHILD_STATE1_UNCORRECTED_ERRORf,
        DB_L2_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_L2_ECC_DEBUG1r, DB_L2_CHILD_STATE1_ENABLE_ECCf,
        LLS_L2_CHILD_STATE1_ECC_STATUSr, DB_L2_CHILD_STATE1_ECC_ERROR_ADDRESSf},        
    { 0x00000200, LLS_L2_CHILD_STATE1m, "", 
        DB_L2_CHILD_STATE1_CORRECTED_ERRORf,
        DB_L2_CHILD_STATE1_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG1r, DB_L2_CHILD_STATE1_ENABLE_ECCf,
        LLS_L2_CHILD_STATE1_ECC_STATUSr, DB_L2_CHILD_STATE1_ECC_ERROR_ADDRESSf},        


    { 0x00000400, LLS_L2_SHAPER_BUCKETm, "", 
        DB_L2_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L2_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf,       
        ECCf, LLS_L2_ECC_DEBUG2r, DB_L2_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L2_SHAPER_BUCKET_C_ECC_STATUSr, DB_L2_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},        
    { 0x00000800, LLS_L2_SHAPER_BUCKETm, "", 
        DB_L2_SHAPER_BUCKET_C_CORRECTED_ERRORf,
        DB_L2_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG2r, DB_L2_SHAPER_BUCKET_C_ENABLE_ECCf,
        LLS_L2_SHAPER_BUCKET_C_ECC_STATUSr, DB_L2_SHAPER_BUCKET_C_ECC_ERROR_ADDRESSf},        

    { 0x00001000, LLS_L2_MIN_BUCKET_Cm, "", 
        DB_L2_MIN_BUCKET_C_UNCORRECTED_ERRORf,
        DB_L2_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG2r, DB_L2_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L2_MIN_BUCKET_C_ECC_STATUSr, DB_L2_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},                
    { 0x00002000, LLS_L2_MIN_BUCKET_Cm, "", 
        DB_L2_MIN_BUCKET_C_CORRECTED_ERRORf,
        DB_L2_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG2r, DB_L2_MIN_BUCKET_C_ENABLE_ECCf,
        LLS_L2_MIN_BUCKET_C_ECC_STATUSr, DB_L2_MIN_BUCKET_C_ECC_ERROR_ADDRESSf},                

    { 0x00004000, LLS_L2_MIN_CONFIG_Cm, "", 
        DB_L2_MIN_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L2_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG2r, DB_L2_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L2_MIN_CONFIG_C_ECC_STATUSr, DB_L2_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},                        
    { 0x00008000, LLS_L2_MIN_CONFIG_Cm, "",  
        DB_L2_MIN_CONFIG_C_CORRECTED_ERRORf,
        DB_L2_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG2r, DB_L2_MIN_CONFIG_C_ENABLE_ECCf,
        LLS_L2_MIN_CONFIG_C_ECC_STATUSr, DB_L2_MIN_CONFIG_C_ECC_ERROR_ADDRESSf},                

    
    { 0x00010000, LLS_L2_SHAPER_CONFIG_Cm, "", 
        DB_L2_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
        DB_L2_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_L2_ECC_DEBUG2r, DB_L2_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L2_SHAPER_CONFIG_C_ECC_STATUSr, DB_L2_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},                
    { 0x00020000, LLS_L2_SHAPER_CONFIG_Cm, "", 
        DB_L2_SHAPER_CONFIG_C_CORRECTED_ERRORf,
        DB_L2_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_L2_ECC_DEBUG2r, DB_L2_SHAPER_CONFIG_C_ENABLE_ECCf,
        LLS_L2_SHAPER_CONFIG_C_ECC_STATUSr, DB_L2_SHAPER_CONFIG_C_ECC_ERROR_ADDRESSf},                
        
    
    { 0 } /* table terminator */ 
    
};


STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_lls_port_parity_info[] = {
    /* LLS_PORT_ECC_ERRORr */
    { 0x00000001, LLS_PORT_TDMm, "", 
        DB_PORT_TDM_UNCORRECTED_ERRORf,
        DB_PORT_TDM_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_PORT_ECC_DEBUGr, DB_PORT_TDM_ENABLE_ECCf,
        LLS_PORT_TDM_ECC_STATUSr, DB_PORT_TDM_ECC_ERROR_ADDRESSf},                
    { 0x00000002, LLS_PORT_TDMm, "",  
        DB_PORT_TDM_CORRECTED_ERRORf,
        DB_PORT_TDM_CORRECTED_ERROR_DISINTf,        
        PARITYf, LLS_PORT_ECC_DEBUGr, DB_PORT_TDM_ENABLE_ECCf,
        LLS_PORT_TDM_ECC_STATUSr, DB_PORT_TDM_ECC_ERROR_ADDRESSf},                

    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_lls_misc_parity_info[] = {
    /* LLS_MISC_ECC_ERROR1 */
    { 0x00000001, LLS_L2_ERRORm, "", 
        DB_L2_ERROR_UNCORRECTED_ERRORf,
        DB_L2_ERROR_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_ERROR_ECC_DEBUGr, DB_L2_ERROR_ENABLE_ECCf,
        LLS_L2_ERROR_ECC_STATUSr, DB_L2_ERROR_ECC_ERROR_ADDRESSf},                
    { 0x00000002, LLS_L2_ERRORm, "", 
        DB_L2_ERROR_CORRECTED_ERRORf,
        DB_L2_ERROR_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_ERROR_ECC_DEBUGr, DB_L2_ERROR_ENABLE_ECCf,
        LLS_L2_ERROR_ECC_STATUSr, DB_L2_ERROR_ECC_ERROR_ADDRESSf},                

    { 0x00000004, LLS_L1_ERRORm, "", 
        DB_L1_ERROR_UNCORRECTED_ERRORf,
        DB_L1_ERROR_UNCORRECTED_ERROR_DISINTf,        
        ECCf, LLS_ERROR_ECC_DEBUGr, DB_L1_ERROR_ENABLE_ECCf,
        LLS_L1_ERROR_ECC_STATUSr, DB_L1_ERROR_ECC_ERROR_ADDRESSf},                
    { 0x00000008, LLS_L1_ERRORm, "", 
        DB_L1_ERROR_CORRECTED_ERRORf,
        DB_L1_ERROR_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_ERROR_ECC_DEBUGr, DB_L1_ERROR_ENABLE_ECCf,
        LLS_L1_ERROR_ECC_STATUSr, DB_L1_ERROR_ECC_ERROR_ADDRESSf},                

    
    { 0x00000010, LLS_L0_ERRORm, "", 
        DB_L0_ERROR_UNCORRECTED_ERRORf,
        DB_L0_ERROR_UNCORRECTED_ERROR_DISINTf,
        ECCf, LLS_ERROR_ECC_DEBUGr, DB_L0_ERROR_ENABLE_ECCf,
        LLS_L0_ERROR_ECC_STATUSr, DB_L0_ERROR_ECC_ERROR_ADDRESSf},                
    { 0x00000020, LLS_L0_ERRORm, "", 
        DB_L0_ERROR_CORRECTED_ERRORf,
        DB_L0_ERROR_CORRECTED_ERROR_DISINTf,
        PARITYf, LLS_ERROR_ECC_DEBUGr, DB_L0_ERROR_ENABLE_ECCf,
        LLS_L0_ERROR_ECC_STATUSr, DB_L0_ERROR_ECC_ERROR_ADDRESSf},                

    { 0 } /* table terminator */ 

};
STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                      _soc_saber2_mmu_sb_aging_int_parity_info [] = {
    /* AGING_ERROR_INT */
    { 0x0020, MMU_AGING_LMT_INTm, "",
        LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf, 
        PARITYf, AGING_LMT_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_LMT_INTr, PTRf},    
    { 0x0010, MMU_AGING_LMT_INTm, "",
        LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf, 
        ECCf, AGING_LMT_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_LMT_INTr, PTRf},    

    { 0x0008, MMU_AGING_CTR_INTm, "",    
        CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf, 
        PARITYf, AGING_CTR_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_CTR_INTr, PTRf},        
    { 0x0004, MMU_AGING_CTR_INTm, "",
        CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf, 
        ECCf, AGING_CTR_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_CTR_INTr, PTRf},    
        
    { 0x0002, MMU_AGING_EXP_INTm, "",
        EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf, 
        PARITYf, AGING_EXP_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_EXP_INTr, PTRf},            
    { 0x0001, MMU_AGING_EXP_INTm, "",
        EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf, 
        ECCf, AGING_EXP_ECC_CONTROL_INTr, ENABLE_ECCf,
        ECC_ERR_PTR_EXP_INTr, PTRf},    

    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                                _soc_saber2_mmu_sb_aging_ext_parity_info [] = {
    { 0x0020, MMU_AGING_LMT_EXTm, "",
        LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf, 
        PARITYf, AGING_LMT_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_LMT_EXTr, PTRf},   
    { 0x0010, MMU_AGING_LMT_EXTm, "",
        LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf,
        ECCf, AGING_LMT_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_LMT_EXTr, PTRf},          
        
    { 0x0008, MMU_AGING_CTR_EXTm, "",
        CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf,
        PARITYf, AGING_CTR_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_CTR_EXTr, PTRf},          
    { 0x0004, MMU_AGING_CTR_EXTm, "",
        CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf, 
        ECCf, AGING_CTR_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_CTR_EXTr, PTRf},           
        
    { 0x0002, MMU_AGING_EXP_EXTm, "",
        EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf,
        PARITYf, AGING_EXP_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_EXP_EXTr, PTRf},    
    { 0x0001, MMU_AGING_EXP_EXTm, "",
        EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf, 
        ECCf, AGING_EXP_ECC_CONTROL_EXTr, ENABLE_ECCf,
        ECC_ERR_PTR_EXP_EXTr, PTRf},   
        
    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_ccp_parity_info [] = {
    /* CCP_ERROR */
    
    { 0x20000, INVALIDm, "CCPE_SOP_FIFO_TAIL_OVERFLOW", 
        CCPE_SOP_FIFO_TAIL_OVERFLOWf, CCPE_SOP_FIFO_TAIL_OVERFLOW_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x10000, INVALIDm, "CCPE_SOP_FIFO_FRONT_OVERFLOW", 
        CCPE_SOP_FIFO_FRONT_OVERFLOWf, CCPE_SOP_FIFO_FRONT_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x8000, INVALIDm, "CCPI_SOP_FIFO_TAIL_OVERFLOW", 
        CCPI_SOP_FIFO_TAIL_OVERFLOWf, CCPI_SOP_FIFO_TAIL_OVERFLOW_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x4000, INVALIDm, "CCPI_SOP_FIFO_FRONT_OVERFLOW", 
        CCPI_SOP_FIFO_FRONT_OVERFLOWf, CCPI_SOP_FIFO_FRONT_OVERFLOW_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x2000, INVALIDm, "CCPE_FIFO_TAIL_CORRECTED", 
        CCPE_FIFO_TAIL_CORRECTED_ERRORf, CCPE_FIFO_TAIL_CORRECTED_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x1000, INVALIDm, "CCPE_FIFO_TAIL_UNCORRECTED", 
        CCPE_FIFO_TAIL_UNCORRECTED_ERRORf, CCPE_FIFO_TAIL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0800, INVALIDm, "CCPE_FIFO_FRONT_CORRECTED", 
        CCPE_FIFO_FRONT_CORRECTED_ERRORf, CCPE_FIFO_FRONT_CORRECTED_ERRORf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0400, INVALIDm, "CCPE_FIFO_FRONT_UNCORRECTED", 
        CCPE_FIFO_FRONT_UNCORRECTED_ERRORf, CCPE_FIFO_FRONT_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0200, INVALIDm, "CCPI_FIFO_TAIL_CORRECTED_ERROR", 
        CCPI_FIFO_TAIL_CORRECTED_ERRORf, CCPI_FIFO_TAIL_CORRECTED_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0100,  INVALIDm, "CCPI_FIFO_TAIL_UNCORRECTED_ERROR", 
        CCPI_FIFO_TAIL_UNCORRECTED_ERRORf, CCPI_FIFO_TAIL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0080, INVALIDm, "CCPI_FIFO_FRONT_CORRECTED_ERROR", 
        CCPI_FIFO_FRONT_CORRECTED_ERRORf, CCPI_FIFO_FRONT_CORRECTED_ERRORf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0040, INVALIDm, "CCPI_FIFO_FRONT_UNCORRECTED_ERROR", 
        CCPI_FIFO_FRONT_UNCORRECTED_ERRORf, CCPI_FIFO_FRONT_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0020, INVALIDm, "CCPI_RQE_UPD_NEGATIVE", 
        CCPI_RQE_UPD_NEGATIVEf, CCPI_RQE_UPD_NEGATIVE_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0010, INVALIDm, "CCPE_RQE_UPD_NEGATIVE", 
        CCPE_RQE_UPD_NEGATIVEf, CCPE_RQE_UPD_NEGATIVE_DISINTf,       
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        

    { 0x0008, MMU_CCPE_MEMm, "", 
        CCPE_CORRECTED_ERRORf, CCPE_CORRECTED_ERROR_DISINTf,
        PARITYf, CCPE_MEMDEBUGr, ENABLE_ECCf,
        MMU_CCPE_MEM_ECC_STATUSr, ECC_ERROR_ADDRESSf},
    { 0x0004, MMU_CCPE_MEMm, "", 
        CCPE_UNCORRECTED_ERRORf, CCPE_UNCORRECTED_ERROR_DISINTf,
        ECCf, CCPE_MEMDEBUGr, ENABLE_ECCf,
        MMU_CCPE_MEM_ECC_STATUSr, ECC_ERROR_ADDRESSf},
    
    { 0x0002, MMU_CCPI_MEMm, "", 
        CCPI_CORRECTED_ERRORf, CCPI_CORRECTED_ERROR_DISINTf,
        PARITYf, CCPI_MEMDEBUGr, ENABLE_ECCf,
        MMU_CCPI_MEM_ECC_STATUSr, ECC_ERROR_ADDRESSf},
    { 0x0001, MMU_CCPI_MEMm, "", 
        CCPI_UNCORRECTED_ERRORf, CCPI_UNCORRECTED_ERROR_DISINTf,   
        ECCf, CCPI_MEMDEBUGr, ENABLE_ECCf,
        MMU_CCPI_MEM_ECC_STATUSr, ECC_ERROR_ADDRESSf},
        
    { 0 } /* table terminator */
    
};


STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_cfapi_parity_info [] = {
    /* CFAPI_ECC_ERROR */
    { 0x0008, MMU_CFAPI_BITMAPm, "", 
        BITMAP_CORRECTED_ERRORf, BITMAP_CORRECTED_ERROR_DISINTf,
        PARITYf, INVALIDr, INVALIDf,
        CFAPI_BITMAP_ECC_STATUSr, ECC_ERROR_ADDRESSf},
    { 0x0004, MMU_CFAPI_BITMAPm, "", 
        BITMAP_UNCORRECTED_ERRORf, BITMAP_UNCORRECTED_ERROR_DISINTf,        
        ECCf, INVALIDr, INVALIDf,
        CFAPI_BITMAP_ECC_STATUSr, ECC_ERROR_ADDRESSf},

    { 0x0002, MMU_CFAPI_STACKm, "", 
        STACK_CORRECTED_ERRORf, STACK_CORRECTED_ERROR_DISINTf,  
        PARITYf, INVALIDr, INVALIDf,
        CFAPI_STACK_ECC_STATUSr, ECC_ERROR_ADDRESSf},        
    { 0x0001, MMU_CFAPI_STACKm, "", 
        STACK_UNCORRECTED_ERRORf, STACK_UNCORRECTED_ERROR_DISINTf,
        ECCf, INVALIDr, INVALIDf,
        CFAPI_STACK_ECC_STATUSr, ECC_ERROR_ADDRESSf},

    { 0 } /* table terminator */
    
};


STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_cfape_parity_info [] = {
    /* CFAPE_ECC_ERROR */   
    { 0x0008, MMU_CFAPE_BITMAPm, "", 
        BITMAP_CORRECTED_ERRORf, BITMAP_CORRECTED_ERROR_DISINTf,
        PARITYf, INVALIDr, INVALIDf,
        CFAPE_BITMAP_ECC_STATUSr, ECC_ERROR_ADDRESSf},
    { 0x0004, MMU_CFAPE_BITMAPm, "", 
        BITMAP_UNCORRECTED_ERRORf, BITMAP_UNCORRECTED_ERROR_DISINTf,
        ECCf, INVALIDr, INVALIDf,
        CFAPE_BITMAP_ECC_STATUSr, ECC_ERROR_ADDRESSf},

    { 0x0002, MMU_CFAPE_STACKm, "", 
        STACK_CORRECTED_ERRORf, STACK_CORRECTED_ERROR_DISINTf,  
        PARITYf, INVALIDr, INVALIDf,
        CFAPE_STACK_ECC_STATUSr, ECC_ERROR_ADDRESSf},        
    { 0x0001, MMU_CFAPE_STACKm, "", 
        STACK_UNCORRECTED_ERRORf, STACK_UNCORRECTED_ERROR_DISINTf,
        ECCf, INVALIDr, INVALIDf,
        CFAPE_STACK_ECC_STATUSr, ECC_ERROR_ADDRESSf},

    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_ctr_parity_info [] = {
    /* CTR_ERROR */
    { 0x0002, INVALIDm, "CTR_FLEX_COUNT", 
        CTR_FLEX_CNT_CORRECTED_ERRORf, CTR_FLEX_CNT_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0001, INVALIDm, "CTR_FLEX_COUNT", 
        CTR_FLEX_CNT_UNCORRECTED_ERRORf, CTR_FLEX_CNT_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_rqe_parity_info [] = {
    /* RQE_SER_STATUS */
    { 0x003fe00, INVALIDm, "RQE ECC_1B_BITMAP",
        ECC_1B_BITMAPf, ECC_1B_MASKf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x00001ff, INVALIDm, "RQE ECC_2B_BITMAP",
        ECC_2B_BITMAPf, ECC_2B_MASKf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_thdo_stat1_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS1 */
    { 0x003ffff, INVALIDm, "THDO ECC_1B_BITMAP",
        ECC_1B_ERROR_STATUSf, ECC_1B_MASKf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    
    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_thdo_stat2_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS2 */
    { 0x003ffff, INVALIDm, "THDO ECC_2B_BITMAP",
        ECC_2B_ERROR_STATUSf, ECC_2B_MASKf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_wred_parity_info [] = {
    /* WRED_PARITY_ERROR_BITMAP */
    { 0x3ffe000, INVALIDm, "WRED ECC_1BIT error",
        ECC_ERROR_1Bf, ECC_1B_ERROR_MASKf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x1fff, INVALIDm, "WRED ECC_2BIT error",
        ECC_ERROR_2Bf, ECC_2B_ERROR_MASKf,    
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_wred_profile_parity_info [] = {
    /* WRED_PROFILE_PARITY_ERROR_BITMAP */
    { 0xfff000, INVALIDm, "WRED PROFILE ECC_1_BIT error",
        ECC_ERROR_1Bf, ECC_1B_ERROR_MASKf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0xfff, INVALIDm, "WRED PROFILE ECC_2BIT error",
        ECC_ERROR_2Bf, ECC_2B_ERROR_MASKf,    
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                    _soc_saber2_mmu_sb_ci_parity_info [] = {
    /* CI_ERROR */
    { 0x0080, INVALIDm, "CI PHY_ERROR",
        PHY_ERROR_DETECTf, PHY_ERROR_DETECTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0040, INVALIDm, "CI PHY_READY_EVENT",
        PHY_READY_EVENTf, PHY_READY_EVENTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0020, INVALIDm, "CI WFIFO_CTL_CORRECTED_ERROR",
        WFIFO_CTL_CORRECTED_ERRORf, WFIFO_CTL_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0010, INVALIDm, "CI WFIFO_CTL_UNCORRECTED_ERROR",
        WFIFO_CTL_UNCORRECTED_ERRORf, WFIFO_CTL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0008, INVALIDm, "CI WFIFO_OVERFLOW",
        WFIFO_OVERFLOWf, WB_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
       
    { 0x0004, INVALIDm, "CI RFIFO_CTL_CORRECTED_ERROR",
        RFIFO_CTL_CORRECTED_ERRORf, RFIFO_CTL_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0002, INVALIDm, "CI RFIFO_CTL_UNCORRECTED_ERROR",
        RFIFO_CTL_UNCORRECTED_ERRORf, RFIFO_CTL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0001, INVALIDm, "CI RFIFO_OVERFLOW",
        RFIFO_OVERFLOWf, RFIFO_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    
    { 0 } /* table terminator */

};


STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                           _soc_saber2_mmu_sb_enq_cfg_parity_info [] = {
    /* MMU_ENQ_CFG_ECC_ERROR_0 */
    { 0x800000, INVALIDm, "ENQ CFG CBI_CORRECTED_ERROR",
        CBI_CORRECTED_ERRORf, CBI_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x400000, INVALIDm, "ENQ CFG CBI_UNCORRECTED_ERROR",
        CBI_UNCORRECTED_ERRORf, CBI_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x200000, INVALIDm, "ENQ CFG ITE_REORDER_FIFO_CORRECTED_ERROR",
        ITE_REORDER_FIFO_CORRECTED_ERRORf, ITE_REORDER_FIFO_CORRECTED_ERRORf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x100000, INVALIDm, "ENQ CFG ITE_REORDER_FIFO_UNCORRECTED_ERROR",
        ITE_REORDER_FIFO_UNCORRECTED_ERRORf, ITE_REORDER_FIFO_UNCORRECTED_ERRORf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x80000, INVALIDm, "ENQ CFG PACKING_PKT_LEN_FIFOS_CORRECTED_ERROR",
        PACKING_PKT_LEN_FIFOS_CORRECTED_ERRORf, PACKING_PKT_LEN_FIFOS_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x40000, INVALIDm, "ENQ CFG PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERROR",
        PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERRORf, PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},


    { 0x20000, INVALIDm, "ENQ CFG PACKING_PORT_FIFOS_CORRECTED_ERROR",
        PACKING_PORT_FIFOS_CORRECTED_ERRORf, PACKING_PORT_FIFOS_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x10000, INVALIDm, "ENQ CFG PACKING_PORT_FIFOS_UNCORRECTED_ERROR",
        PACKING_PORT_FIFOS_UNCORRECTED_ERRORf, PACKING_PORT_FIFOS_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x8000, INVALIDm, "ENQ CFG PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERROR",
        PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERRORf, PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x4000, INVALIDm, "ENQ CFG PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERROR",
        PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERRORf, PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x2000, INVALIDm, "ENQ CFG PACKING_CTXT_FIFOS_CORRECTED_ERROR",
        PACKING_CTXT_FIFOS_CORRECTED_ERRORf, PACKING_CTXT_FIFOS_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x1000, INVALIDm, "ENQ CFG PACKING_CTXT_FIFOS_UNCORRECTED_ERROR",
        PACKING_CTXT_FIFOS_UNCORRECTED_ERRORf, PACKING_CTXT_FIFOS_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0800, INVALIDm, "ENQ CFG CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR",
        CFAPI_INTERNAL_RECYCLE_CORRECTED_ERRORf, CFAPI_INTERNAL_RECYCLE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0400, INVALIDm, "ENQ CFG CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR",
        CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERRORf, CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0200, INVALIDm, "ENQ CFG SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERROR",
        SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERRORf, SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0100, INVALIDm, "ENQ CFG SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERROR",
        SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERRORf, SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
            
    { 0x0080, INVALIDm, "ENQ CFG SRC_PORT_STATE_CORRECTED_ERROR",
        SRC_PORT_STATE_CORRECTED_ERRORf, SRC_PORT_STATE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0040, INVALIDm, "ENQ CFG SRC_PORT_STATE_UNCORRECTED_ERROR",
        SRC_PORT_STATE_UNCORRECTED_ERRORf, SRC_PORT_STATE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0020, INVALIDm, "ENQ CFG SOP_STORE_CORRECTED_ERROR",
        SOP_STORE_CORRECTED_ERRORf, SOP_STORE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0010, INVALIDm, "ENQ CFG SOP_STORE_UNCORRECTED_ERROR",
        SOP_STORE_UNCORRECTED_ERRORf, SOP_STORE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
            
    { 0x0008, INVALIDm, "ENQ CFG RQE_WR_COMPLETE_CORRECTED_ERROR", 
        RQE_WR_COMPLETE_CORRECTED_ERRORf, RQE_WR_COMPLETE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0004, INVALIDm, "ENQ CFG RQE_WR_COMPLETE_UNCORRECTED_ERROR",
        RQE_WR_COMPLETE_UNCORRECTED_ERRORf, RQE_WR_COMPLETE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0002, INVALIDm, "ENQ CFG CBP_32B_WR_STORE_CORRECTED_ERROR",
        CBP_32B_WR_STORE_CORRECTED_ERRORf, CBP_32B_WR_STORE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0001, INVALIDm, "ENQ CFG CBP_32B_WR_STORE_UNCORRECTED_ERROR",
        CBP_32B_WR_STORE_UNCORRECTED_ERRORf, CBP_32B_WR_STORE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */
    
};
STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                     _soc_saber2_mmu_sb_enq_fap_parity_info [] = {
    /* MMU_ENQ_FAP_ECC_ERROR_0 */
    { 0x0008, INVALIDm, "ENQ FAP_STACK_CORRECTED_ERROR",
        FAP_STACK_CORRECTED_ERRORf, FAP_STACK_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0004, INVALIDm, "ENQ FAP_STACK_UNCORRECTED_ERROR",
        FAP_STACK_UNCORRECTED_ERRORf, FAP_STACK_UNCORRECTED_ERROR_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0002, INVALIDm, "ENQ FAP_BITMAP_CORRECTED_ERROR",
        FAP_BITMAP_CORRECTED_ERRORf, FAP_BITMAP_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0001, INVALIDm, "ENQ FAP_BITMAP_UNCORRECTED_ERROR",
        FAP_BITMAP_UNCORRECTED_ERRORf, FAP_BITMAP_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */
    
};


STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                     _soc_saber2_mmu_sb_thdi_parity_info [] = {
    /* MMU_THDI_INTR */
    { 0x0010, INVALIDm, "THDI_INTR_4", 
        THDI_INTR_4f, THDI_INTR_4_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0008, INVALIDm, "THDI_INTR_3",
        THDI_INTR_3f, THDI_INTR_3_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0004, INVALIDm, "THDI_INTR_2",
        THDI_INTR_2f, THDI_INTR_2_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0002, INVALIDm, "THDI_INTR_1",
        THDI_INTR_1f, THDI_INTR_1_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0001, INVALIDm, "THDI_INTR_0",
        THDI_INTR_0f, THDI_INTR_0_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                         _soc_saber2_mmu_sb_ite_cfg_parity_info [] = {
    /* MMU_ITE_CFG_ECC_ERROR_0 */
    { 0x0800, INVALIDm, "lTE CFG SOP_CONTROL_ECC_0_CORRECTED_ERROR", 
        SOP_CONTROL_ECC_0_CORRECTED_ERRORf, SOP_CONTROL_ECC_0_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0400, INVALIDm, "ITE CFG SOP_CONTROL_ECC_0_UNCORRECTED_ERROR",  
        SOP_CONTROL_ECC_0_UNCORRECTED_ERRORf, SOP_CONTROL_ECC_0_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0200, MMU_ITE_PACKET_PTR_STOREm, "",  
        PACKET_PTR_STORE_CORRECTED_ERRORf, PACKET_PTR_STORE_FORCE_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_ITE_CFG_ECC_DEBUG_0r, PACKET_PTR_STORE_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_1r, PACKET_PTR_STORE_ECC_ERROR_ADDRESSf},
    { 0x0100, MMU_ITE_PACKET_PTR_STOREm, "",  
        PACKET_PTR_STORE_UNCORRECTED_ERRORf, PACKET_PTR_STORE_FORCE_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_ITE_CFG_ECC_DEBUG_0r, PACKET_PTR_STORE_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_1r, PACKET_PTR_STORE_ECC_ERROR_ADDRESSf},

    { 0x0080, INVALIDm, "ITE_WORK_QUEUE_CORRECTED_ERROR", 
        ITE_WORK_QUEUE_CORRECTED_ERRORf, ITE_WORK_QUEUE_FORCE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0040, INVALIDm, "ITE_WORK_QUEUE_UNCORRECTED_ERROR", 
        ITE_WORK_QUEUE_UNCORRECTED_ERRORf, ITE_WORK_QUEUE_FORCE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0020, INVALIDm, "ITE_CTRL_CORRECTED_ERROR",
        ITE_CTRL_CORRECTED_ERRORf, ITE_CTRL_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0010, INVALIDm, "ITE_CTRL_UNCORRECTED_ERROR",
        ITE_CTRL_UNCORRECTED_ERRORf, ITE_CTRL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0008, MMU_ITE_QMGR_FLLm, "",
        ITE_QMGR_FLL_CORRECTED_ERRORf, ITE_QMGR_FLL_FORCE_CORRECTED_ERROR_DISINTf,        
        PARITYf, MMU_ITE_CFG_ECC_DEBUG_0r, ITE_QMGR_FLL_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_0r, ITE_QMGR_FLL_ECC_ERROR_ADDRESSf},
    { 0x0004, MMU_ITE_QMGR_FLLm, "",
        ITE_QMGR_FLL_UNCORRECTED_ERRORf, ITE_QMGR_FLL_FORCE_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_ITE_CFG_ECC_DEBUG_0r, ITE_QMGR_FLL_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_0r, ITE_QMGR_FLL_ECC_ERROR_ADDRESSf},

    { 0x0002, MMU_ITE_QMGR_QLLm, "",
        ITE_QMGR_QLL_CORRECTED_ERRORf, ITE_QMGR_QLL_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_ITE_CFG_ECC_DEBUG_0r, ITE_QMGR_QLL_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_0r, ITE_QMGR_QLL_ECC_ERROR_ADDRESSf},        
    { 0x0001, MMU_ITE_QMGR_QLLm, "",
        ITE_QMGR_QLL_UNCORRECTED_ERRORf, ITE_QMGR_QLL_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_ITE_CFG_ECC_DEBUG_0r, ITE_QMGR_QLL_ENABLE_ECCf,
        MMU_ITE_CFG_ECC_STATUS_0r, ITE_QMGR_QLL_ECC_ERROR_ADDRESSf},  
    
    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                         _soc_saber2_mmu_sb_inti_1_parity_info [] = {
    /* ST_TRANS_TBL_ECC_ERR1r */
    { 0x0001, INVALIDm, "INTI 1 BIT ECC ERROR", 
        ERRf, ENABLE_1B_ERR_INTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
                         
    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                         _soc_saber2_mmu_sb_inti_2_parity_info [] = {
    /* ST_TRANS_TBL_ECC_ERR2r */
    { 0x0001, INVALIDm, "INTI 2 BIT ECC ERROR", 
        ERRf, ENABLE_2B_ERR_INTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0 } /* table terminator */
                         
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                        _soc_saber2_mmu_sb_mem1_parity_info [] = {
    /* CLINK_ERROR */
    { 0x0008, INVALIDm, "MEM1 CLINKE_CORRECTED_ERROR", 
        CLINKE_CORRECTED_ERRORf, CLINKE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0004, INVALIDm, "MEM1 CLINKE_UNCORRECTED_ERROR",
        CLINKE_UNCORRECTED_ERRORf, CLINKE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    
    { 0x0002, INVALIDm, "MEM1 CLINKI_CORRECTED_ERROR",
        CLINKI_CORRECTED_ERRORf, CLINKI_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0001, INVALIDm, "MEM1 CLINKI_UNCORRECTED_ERROR",
        CLINKI_UNCORRECTED_ERRORf, CLINKI_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0 } /* table terminator */
    
};


STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_info2_1_parity_info[] = {
    /* CHFC_TC2PRI_TBL_ECC_ERR1 1bit */
    { 0x1, MMU_INTFO_TC2PRI_MAPPINGm, "",
        ERRf, ERR1_MASKf,
        PARITYf, CHFC_TC2PRI_TBL_ECC_CONFIGr, ECC_ENf,
        CHFC_TC2PRI_TBL_ECC_ERR1r, ENTRY_IDXf},
    
    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_info2_2_parity_info[] = {
    /* CHFC_TC2PRI_TBL_ECC_ERR2  2bits*/
    { 0x1, MMU_INTFO_TC2PRI_MAPPINGm, "",
        ERRf, ERR2_MASKf,
        ECCf, CHFC_TC2PRI_TBL_ECC_CONFIGr, ECC_ENf,
        CHFC_TC2PRI_TBL_ECC_ERR2r, ENTRY_IDXf},

    { 0 } /* table terminator */ 
    
};


STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_rde_parity_info[] = {
    /* RDE_SER_STATUS */
    { 0xFF00, INVALIDm, "MMU RDE ECC_1B_BITMAP",
        ECC_1B_BITMAPf, ECC_1B_MASKf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0xFF, INVALIDm, "MMU RDE ECC_2B_BITMAP",
        ECC_2B_BITMAPf, ECC_2B_MASKf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_adm_parity_info[] = {
    /* MMU_ADM_ECC_ERROR_0 */
    { 0x0008, MMU_ADM_SRC_CTXT_DBm, "", 
        SRC_CTXT_DB_CORRECTED_ERRORf, SRC_CTXT_DB_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_ADM_ECC_DEBUG_0r, SRC_CTXT_DB_ENABLE_ECCf,
        MMU_ADM_ECC_STATUS_0r, SRC_CTXT_DB_ECC_ERROR_ADDRESSf},        
    { 0x0004, MMU_ADM_SRC_CTXT_DBm, "",
        SRC_CTXT_DB_UNCORRECTED_ERRORf, SRC_CTXT_DB_UNCORRECTED_ERROR_ERROR_DISINTf,
        ECCf, MMU_ADM_ECC_DEBUG_0r, SRC_CTXT_DB_ENABLE_ECCf,
        MMU_ADM_ECC_STATUS_0r, SRC_CTXT_DB_ECC_ERROR_ADDRESSf},
        
    { 0x0002, MMU_ADM_QUEUE_DBm, "",
        QUEUE_DB_CORRECTED_ERRORf, QUEUE_DB_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_ADM_ECC_DEBUG_0r, QUEUE_DB_ENABLE_ECCf,
        MMU_ADM_ECC_STATUS_0r, QUEUE_DB_ECC_ERROR_ADDRESSf},          
    { 0x0001, MMU_ADM_QUEUE_DBm, "",
        QUEUE_DB_UNCORRECTED_ERRORf, QUEUE_DB_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_ADM_ECC_DEBUG_0r, QUEUE_DB_ENABLE_ECCf,
        MMU_ADM_ECC_STATUS_0r, QUEUE_DB_ECC_ERROR_ADDRESSf},        

    { 0 } /* table terminator */ 
    
};

STATIC 
_soc_saber2_mmu_sub_block_leaf_info_t _soc_saber2_mmu_sb_ipctr_parity_info[] = {
    /* MMU_IPCTR_ECC_ERROR_0 */
    { 0x0020, MMU_IPCTR_CTXT_COUNTER_0m, "",
        CTXT_COUNTER_0_CORRECTED_ERRORf, CTXT_COUNTER_0_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_IPCTR_ECC_DEBUG_0r, CTXT_COUNTER_0_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, CTXT_COUNTER_0_ECC_ERROR_ADDRESSf},  
    { 0x0010, MMU_IPCTR_CTXT_COUNTER_0m, "",
        CTXT_COUNTER_0_UNCORRECTED_ERRORf, CTXT_COUNTER_0_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_IPCTR_ECC_DEBUG_0r, CTXT_COUNTER_0_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, CTXT_COUNTER_0_ECC_ERROR_ADDRESSf},  

    { 0x0008, MMU_IPCTR_PG_COUNTER_1m, "",
        PG_COUNTER_1_CORRECTED_ERRORf, PG_COUNTER_1_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_IPCTR_ECC_DEBUG_0r, PG_COUNTER_1_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, PG_COUNTER_1_ECC_ERROR_ADDRESSf},          
    { 0x0004, MMU_IPCTR_PG_COUNTER_1m, "",
        PG_COUNTER_1_UNCORRECTED_ERRORf, PG_COUNTER_1_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_IPCTR_ECC_DEBUG_0r, PG_COUNTER_1_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, PG_COUNTER_1_ECC_ERROR_ADDRESSf},    

    { 0x0002, MMU_IPCTR_PG_COUNTER_0m, "",
        PG_COUNTER_0_CORRECTED_ERRORf, PG_COUNTER_0_CORRECTED_ERROR_DISINTf,
        PARITYf, MMU_IPCTR_ECC_DEBUG_0r, PG_COUNTER_0_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, PG_COUNTER_0_ECC_ERROR_ADDRESSf},    
    { 0x0001, MMU_IPCTR_PG_COUNTER_0m, "",
        PG_COUNTER_0_UNCORRECTED_ERRORf, PG_COUNTER_0_UNCORRECTED_ERROR_DISINTf,
        ECCf, MMU_IPCTR_ECC_DEBUG_0r, PG_COUNTER_0_ENABLE_ECCf,
        MMU_IPCTR_ECC_STATUS_0r, PG_COUNTER_0_ECC_ERROR_ADDRESSf},    

    { 0 } /* table terminator */ 
    
};


STATIC 
_soc_saber2_mmu_sub_block_one_level_t  _soc_saber2_mmu_sub_blocks_type_1[] = {

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L0_ECC_ERROR1_MASKr,
      LLS_L0_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l0_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L1_ECC_ERROR1_MASKr,
      LLS_L1_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l1_parity_info},

        
    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L2_ECC_ERROR1_MASKr,
      LLS_L2_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l2_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf, 
      LLS_PORT_ECC_ERROR_MASKr,
      LLS_PORT_ECC_ERRORr,
      _soc_saber2_mmu_sb_lls_port_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,  
      LLS_MISC_ECC_ERROR1_MASKr,
      LLS_MISC_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_misc_parity_info},


    { 0x00000008, 
      _SOC_SABER2_MMU_SUBBLOCK_AGING_INT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_INTr,
      AGING_ERROR_INTr,
      _soc_saber2_mmu_sb_aging_int_parity_info},
      
    { 0x00000008, 
      _SOC_SABER2_MMU_SUBBLOCK_AGING_EXT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_EXTr,
      AGING_ERROR_EXTr,
      _soc_saber2_mmu_sb_aging_ext_parity_info},

    { 0x00000010, 
      _SOC_SABER2_MMU_SUBBLOCK_CCP,
      CCP_INTR_DISINTf, 
      CCP_INTRf,
      CCP_ERROR_MASKr,
      CCP_ERRORr,
      _soc_saber2_mmu_sb_ccp_parity_info},

    { 0x00000020, 
      _SOC_SABER2_MMU_SUBBLOCK_CFAPI,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPI_ERROR_MASKr,
      CFAPI_ECC_ERRORr,
      _soc_saber2_mmu_sb_cfapi_parity_info},  

    { 0x00000020, 
      _SOC_SABER2_MMU_SUBBLOCK_CFAPI,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPE_ERROR_MASKr,
      CFAPE_ECC_ERRORr,
      _soc_saber2_mmu_sb_cfape_parity_info},

    { 0x00000040, 
      _SOC_SABER2_MMU_SUBBLOCK_CTR,
      CTR_INTR_DISINTf, 
      CTR_INTRf,
      CTR_ERROR_MASKr,
      CTR_ERRORr,
      _soc_saber2_mmu_sb_ctr_parity_info},

    { 0x00000200, 
      _SOC_SABER2_MMU_SUBBLOCK_RQE_EXTQ,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_SER_MASKr,
      RQE_SER_STATUSr,
      _soc_saber2_mmu_sb_rqe_parity_info},

    { 0x00000400, 
      _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS1,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK1r,
      THDO_PARITY_ERROR_STATUS1r,
      _soc_saber2_mmu_sb_thdo_stat1_parity_info},
    
    { 0x00000400, 
      _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS2,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK2r,
      THDO_PARITY_ERROR_STATUS2r,
      _soc_saber2_mmu_sb_thdo_stat2_parity_info},

    { 0x00000800, 
      _SOC_SABER2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,
      WRED_PARITY_ERROR_MASKr,
      WRED_PARITY_ERROR_BITMAPr,
      _soc_saber2_mmu_sb_wred_parity_info},

    { 0x00000800, 
      _SOC_SABER2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,  
      WRED_PROFILE_PARITY_ERROR_MASKr,
      WRED_PROFILE_PARITY_ERROR_BITMAPr,
      _soc_saber2_mmu_sb_wred_profile_parity_info},

    { 0x00001000, 
      _SOC_SABER2_MMU_SUBBLOCK_CI0,
      CI0_INTR_DISINTf, 
      CI0_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_saber2_mmu_sb_ci_parity_info},    

    { 0x00002000, 
      _SOC_SABER2_MMU_SUBBLOCK_CI0,
      CI1_INTR_DISINTf, 
      CI1_INTRf,        
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_saber2_mmu_sb_ci_parity_info},   

    { 0x00004000, 
      _SOC_SABER2_MMU_SUBBLOCK_ENQ_CFG,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_CFG_ECC_ERROR_0_MASKr,
      MMU_ENQ_CFG_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_enq_cfg_parity_info},  

    { 0x00004000, 
      _SOC_SABER2_MMU_SUBBLOCK_ENQ_FAP,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_FAP_ECC_ERROR_0_MASKr,
      MMU_ENQ_FAP_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_enq_fap_parity_info},  

    { 0x00008000, 
      _SOC_SABER2_MMU_SUBBLOCK_THDI,
      THDI_INTR_DISINTf, 
      THDI_INTRf,
      MMU_THDI_INTR_MASKr,
      MMU_THDI_INTRr,
      _soc_saber2_mmu_sb_thdi_parity_info},

    { 0x00010000, 
      _SOC_SABER2_MMU_SUBBLOCK_ITE_CFG,
      ITE_INTR_DISINTf, 
      ITE_INTRf, 
      MMU_ITE_CFG_ECC_ERROR_0_MASKr,
      MMU_ITE_CFG_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_ite_cfg_parity_info},

    /* 0x00020000
        MMU_E2EFC_ERROR_0 is not ECC/Parity error
        e.g. E2EFC_INT_CNT_UNDERRUN /OVERFLOW 
        */
        
    { 0x00040000, 
      _SOC_SABER2_MMU_SUBBLOCK_INTFI_ECC,
      INTF1_INTR_DISINTf, 
      INTFI_INTRf,
      INTFI_ECC_INTR_MASKr,
      ST_TRANS_TBL_ECC_ERR1r,
      _soc_saber2_mmu_sb_inti_1_parity_info},

    { 0x00040000, 
      _SOC_SABER2_MMU_SUBBLOCK_INTFI_ECC,
      INTF1_INTR_DISINTf, 
      INTFI_INTRf,
      INTFI_ECC_INTR_MASKr,
      ST_TRANS_TBL_ECC_ERR2r,
      _soc_saber2_mmu_sb_inti_2_parity_info},

    { 0x00080000, 
      _SOC_SABER2_MMU_SUBBLOCK_MEM1,
      MEM1_INTR_DISINTf, 
      MEM1_INTRf,
      CLINK_ERROR_MASKr,
      CLINK_ERRORr,
      _soc_saber2_mmu_sb_mem1_parity_info },

    { 0x00100000, 
      _SOC_SABER2_MMU_SUBBLOCK_INFO2,
      INFO2_INTR_DISINTf, 
      INFO2_INTRf,
      CHFC_TC2PRI_TBL_ECC_CONFIGr,
      CHFC_TC2PRI_TBL_ECC_ERR1r,
      _soc_saber2_mmu_sb_info2_1_parity_info },

    { 0x00100000, 
      _SOC_SABER2_MMU_SUBBLOCK_INFO2,
      INFO2_INTR_DISINTf, 
      INFO2_INTRf,
      CHFC_TC2PRI_TBL_ECC_CONFIGr,
      CHFC_TC2PRI_TBL_ECC_ERR2r,
      _soc_saber2_mmu_sb_info2_2_parity_info },  


    { 0x00200000, 
      _SOC_SABER2_MMU_SUBBLOCK_RDE,
      RDE_INTR_DISINTf, 
      RDE_INTRf,
      RDE_SER_MASKr,
      RDE_SER_STATUSr,
      _soc_saber2_mmu_sb_rde_parity_info },
    
    { 0x00400000, 
      _SOC_SABER2_MMU_SUBBLOCK_ADM,
      ADM_INTR_DISINTf, 
      ADM_INTRf,
      MMU_ADM_ECC_ERROR_0_MASKr,
      MMU_ADM_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_adm_parity_info },

    { 0x00800000, 
      _SOC_SABER2_MMU_SUBBLOCK_IPCTR,
      IPCTR_INTR_DISINTf, 
      IPCTR_INTRf,
      MMU_IPCTR_ECC_ERROR_0_MASKr,
      MMU_IPCTR_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_ipctr_parity_info },

    
    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                        _soc_saber2_mmu_sb_toq1_parity_info [] = {

    /* TOQ_ERROR1 */
    { 0x20000, MMU_TOQ_EOPE_TBLm, "",
        EOPE_TBL_CORRECTED_ERRORf, EOPE_TBL_CORRECTED_ERROR_DISINTf,
        PARITYf, TOQ_ECC_DEBUGr, EOPE_TBL_ENABLE_ECCf,
        MMU_TOQ_EOPE_ECC_STATUSr, ECC_ERROR_ADDRESSf},        
    { 0x10000, MMU_TOQ_EOPE_TBLm, "",
        EOPE_TBL_UNCORRECTED_ERRORf, EOPE_TBL_UNCORRECTED_ERROR_DISINTf,
        ECCf, TOQ_ECC_DEBUGr, EOPE_TBL_ENABLE_ECCf,
        MMU_TOQ_EOPE_ECC_STATUSr, ECC_ERROR_ADDRESSf},  
        
    { 0x8000, MMU_REPL_MAP_TBLm, "",
        REPL_MAP_TBL_CORRECTED_ERRORf, REPL_MAP_TBL_CORRECTED_ERROR_DISINTf,
        PARITYf, TOQ_ECC_DEBUGr, REPL_MAP_TBL_ENABLE_ECCf,
        MMU_REPL_MAP_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  
    { 0x4000, MMU_REPL_MAP_TBLm, "",
        REPL_MAP_TBL_UNCORRECTED_ERRORf, REPL_MAP_TBL_UNCORRECTED_ERROR_DISINTf,
        ECCf, TOQ_ECC_DEBUGr, REPL_MAP_TBL_ENABLE_ECCf,
        MMU_REPL_MAP_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  

    { 0x2000, MMU_REPL_STATE_TBLm, "",
        REPL_STATE_TBL_CORRECTED_ERRORf, REPL_STATE_TBL_CORRECTED_ERROR_DISINTf,
        PARITYf, TOQ_ECC_DEBUGr, REPL_STATE_TBL_ENABLE_ECCf,
        MMU_REPL_STATE_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  
    { 0x1000, MMU_REPL_STATE_TBLm, "",
        REPL_STATE_TBL_UNCORRECTED_ERRORf, REPL_STATE_TBL_UNCORRECTED_ERROR_DISINTf,
        ECCf, TOQ_ECC_DEBUGr, REPL_STATE_TBL_ENABLE_ECCf,
        MMU_REPL_STATE_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  

    { 0x0800, INVALIDm, "MMU PORT_STATE_CORRECTED_ERROR",
        PORT_STATE_CORRECTED_ERRORf, PORT_STATE_CORRECTED_ERROR_DISINTf,       
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0400, INVALIDm, "MMU PORT_STATE_UNCORRECTED_ERROR",
        PORT_STATE_UNCORRECTED_ERRORf, PORT_STATE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0200, INVALIDm, "MMU RQE_FIFO_CORRECTED_ERROR",
        RQE_FIFO_CORRECTED_ERRORf, RQE_FIFO_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0100, INVALIDm, "MMU RQE_FIFO_UNCORRECTED_ERROR",
        RQE_FIFO_UNCORRECTED_ERRORf, RQE_FIFO_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
         
    { 0x0080, INVALIDm, "MMU REPL_GRP_TBL_CORRECTED_ERROR",
        REPL_GRP_TBL_CORRECTED_ERRORf, REPL_GRP_TBL_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0040, INVALIDm, "MMU REPL_GRP_TBL_UNCORRECTED_ERROR", 
        REPL_GRP_TBL_UNCORRECTED_ERRORf, REPL_GRP_TBL_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0020, MMU_REPL_HEAD_TBLm, "",  
        REPL_HEAD_TBL_CORRECTED_ERRORf, REPL_HEAD_TBL_CORRECTED_ERROR_DISINTf,
        PARITYf, TOQ_ECC_DEBUGr, REPL_HEAD_TBL_ENABLE_ECCf,
        MMU_REPL_HEAD_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  
    { 0x0010, MMU_REPL_HEAD_TBLm, "", 
        REPL_HEAD_TBL_UNCORRECTED_ERRORf, REPL_HEAD_TBL_UNCORRECTED_ERROR_DISINTf,
        ECCf, TOQ_ECC_DEBUGr, REPL_HEAD_TBL_ENABLE_ECCf,
        MMU_REPL_HEAD_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},  

    { 0x0008, MMU_REPL_LIST_TBLm, "",
        REPL_LIST_TBL_CORRECTED_ERRORf, REPL_LIST_TBL_CORRECTED_ERROR_DISINTf,
        PARITYf, TOQ_ECC_DEBUGr, REPL_LIST_TBL_ENABLE_ECCf,
        MMU_REPL_LIST_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},          
    { 0x0004, MMU_REPL_LIST_TBLm, "",
        REPL_LIST_TBL_UNCORRECTED_ERRORf, REPL_LIST_TBL_UNCORRECTED_ERROR_DISINTf,
        ECCf, TOQ_ECC_DEBUGr, REPL_LIST_TBL_ENABLE_ECCf,
        MMU_REPL_LIST_TBL_ECC_STATUSr, ECC_ERROR_ADDRESSf},   

    { 0x0002, INVALIDm, "MMU TOQ_STATE_CORRECTED_ERROR",
        TOQ_STATE_CORRECTED_ERRORf, TOQ_STATE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0001, INVALIDm, "MMU TOQ_STATE_UNCORRECTED_ERROR",
        TOQ_STATE_UNCORRECTED_ERRORf, TOQ_STATE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0 } /* table terminator */
    
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                        _soc_saber2_mmu_sb_toq2_parity_info [] = {
    /* TOQ_ERROR2 */
    { 0x0800, INVALIDm, "MMU REPL_HEAD_WRAP",
        REPL_HEAD_WRAPf, REPL_HEAD_WRAP_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0400, INVALIDm, "MMU PQE_CREDIT_UNDERRUN",
        PQE_CREDIT_UNDERRUNf, PQE_CREDIT_UNDERRUN_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0200, INVALIDm, "MMU PQE_CREDIT_OVERFLOW",
        PQE_CREDIT_OVERFLOWf, PQE_CREDIT_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0100, INVALIDm, "MMU FLUSH_COMPLETE",
        FLUSH_COMPLETEf, FLUSH_COMPLETE_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0080, INVALIDm, "MMU QDIS_FIFO_OVERFLOW",
        QDIS_FIFO_OVERFLOWf, QDIS_FIFO_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0040, INVALIDm, "MMU TRACE_DEQ_EVENT",
        TRACE_DEQ_EVENTf, TRACE_DEQ_EVENT_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0020, INVALIDm, "MMU TRACE_ENQ_EVENT",
        TRACE_ENQ_EVENTf, TRACE_ENQ_EVENT_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0010, INVALIDm, "MMU DEQ_TO_EMPTY_QUEUE_ERROR",
        DEQ_TO_EMPTY_QUEUE_ERRORf, DEQ_TO_EMPTY_QUEUE_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0008, INVALIDm, "MMU QSTRUCT_EMPTY_ERROR",
        QSTRUCT_EMPTY_ERRORf, QSTRUCT_EMPTY_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0004, INVALIDm, "MMU QUEUE_OVELOAD_ERROR",
        QUEUE_OVELOAD_ERRORf, QUEUE_OVELOAD_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x0002, INVALIDm, "MMU TDM_VIOLATION_ERROR",
        TDM_VIOLATION_ERRORf, TDM_VIOLATION_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0001, INVALIDm, "MMU RQE_FIFO_OVERFLOW",
        RQE_FIFO_OVERFLOWf, RQE_FIFO_OVERFLOW_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0 } /* table terminator */
    
};


STATIC  
_soc_saber2_mmu_sub_block_internal_info_t
               _soc_saber2_mmu_sb_toq_parity_info [] = {
    /* TOQ_ERROR2 is not ecc/parity err*/
    { 0x0002, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
      TOQ_ERROR2_DISINTf,
      TOQ_ERROR2f,
      TOQ_ERROR2_MASKr,
      TOQ_ERROR2r, 
      _soc_saber2_mmu_sb_toq2_parity_info },
      
    { 0x0001, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
      TOQ_ERROR1_DISINTf,
      TOQ_ERROR1_ERRORf,
      TOQ_ERROR1_MASKr,
      TOQ_ERROR1r, 
      _soc_saber2_mmu_sb_toq1_parity_info },
      
    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                _soc_saber2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info [] = {
     /* QSTRUCT_QBLOCK_NEXT_ERROR_0 */
    { 0x0002, MMU_QSTRUCT_QBLOCK_NEXTm, "", 
        CORRECTED_ERRORf, CORRECTED_ERROR_DISINTf,
        PARITYf, QSTRUCT_QBLOCK_NEXT_ECC_DEBUGr, DB_QSTRUCT_QBLOCK_NEXT_0_ENABLE_ECCf,
        QBLOCK_NEXT_MEM_ECC_STATUS_0r, ECC_ERROR_ADDRESSf},        

    { 0x0001, MMU_QSTRUCT_QBLOCK_NEXTm, "",
        UNCORRECTED_ERRORf, UNCORRECTED_ERROR_DISINTf,
         ECCf, QSTRUCT_QBLOCK_NEXT_ECC_DEBUGr, DB_QSTRUCT_QBLOCK_NEXT_0_ENABLE_ECCf,
         QBLOCK_NEXT_MEM_ECC_STATUS_0r, ECC_ERROR_ADDRESSf},        
        
    { 0 } /* table terminator */
     
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                _soc_saber2_mmu_sb_qstruct_qentry_parity_info [] = {
     /* QSTRUCT_QENTRY_ERROR_0 */
    { 0x0002, MMU_QSTRUCT_QENTRYm, "", 
        CORRECTED_ERRORf, CORRECTED_ERROR_DISINTf,
         PARITYf, QSTRUCT_QENTRY_ECC_DEBUGr, DB_QSTRUCT_QENTRY_ENABLE_ECCf,
         INVALIDr, INVALIDf}, 
         
    { 0x0001, MMU_QSTRUCT_QENTRYm, "",
        UNCORRECTED_ERRORf, UNCORRECTED_ERROR_DISINTf,
         ECCf, QSTRUCT_QENTRY_ECC_DEBUGr, DB_QSTRUCT_QENTRY_ENABLE_ECCf,
         INVALIDr, INVALIDf},    
        
    { 0 } /* table terminator */
     
};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t
                      _soc_saber2_mmu_sb_qstruct_fap_parity_info [] = {                     
    /* QSTRUCT_FAP_MEM_ERROR */
    /* not ECC error */  
    { 0x4000, INVALIDm, "MMU FAP FAP1_VALID_LOW_NO_FULLASSERT_ERROR",
        FAP1_VALID_LOW_NO_FULLASSERT_ERRORf, FAP1_VALID_LOW_NO_FULLASSERT_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x2000, INVALIDm, "MMU FAP FAP0_VALID_LOW_NO_FULLASSERT_ERROR",
        FAP0_VALID_LOW_NO_FULLASSERT_ERRORf, FAP0_VALID_LOW_NO_FULLASSERT_ERROR_DISINTf,     
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x1000, INVALIDm, "MMU FAP FAP1_INVALID_PTR_ERROR",
        FAP1_INVALID_PTR_ERRORf, FAP1_INVALID_PTR_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0800, INVALIDm, "MMU FAP FAP0_INVALID_PTR_ERROR",
        FAP0_INVALID_PTR_ERRORf, FAP0_INVALID_PTR_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0400, INVALIDm, "MMU FAP FAP1_DUPLICATE_PTR_ERROR",
        FAP1_DUPLICATE_PTR_ERRORf, FAP1_DUPLICATE_PTR_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0200, INVALIDm, "MMU FAP FAP0_DUPLICATE_PTR_ERROR",
        FAP0_DUPLICATE_PTR_ERRORf, FAP0_DUPLICATE_PTR_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0100, INVALIDm, "MMU FAP FAP_LOADING_ERROR",
        FAP_LOADING_ERRORf, FAP_LOADING_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    /* ECC error */ 
    
    { 0x0080, INVALIDm, "MMU FAP CORRECTED_BITMAP_ERROR_1",
        CORRECTED_BITMAP_ERROR_1f, CORRECTED_BITMAP_ERROR_1_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0040, INVALIDm, "MMU FAP UNCORRECTED_BITMAP_ERROR_1",
        UNCORRECTED_BITMAP_ERROR_1f, UNCORRECTED_BITMAP_ERROR_1_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0020, INVALIDm, "MMU FAP CORRECTED_STACK_ERROR_1",
        CORRECTED_STACK_ERROR_1f, CORRECTED_STACK_ERROR_1_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0010, INVALIDm, "MMU FAP UNCORRECTED_STACK_ERROR_1",
        UNCORRECTED_STACK_ERROR_1f, UNCORRECTED_STACK_ERROR_1_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0008, INVALIDm, "MMU FAP CORRECTED_BITMAP_ERROR_0",
        CORRECTED_BITMAP_ERROR_0f, CORRECTED_BITMAP_ERROR_0_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0004, INVALIDm, "MMU FAP UNCORRECTED_BITMAP_ERROR_0",
        UNCORRECTED_BITMAP_ERROR_0f, UNCORRECTED_BITMAP_ERROR_0_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0002, INVALIDm, "MMU FAP CORRECTED_STACK_ERROR_0",
        CORRECTED_STACK_ERROR_0f, CORRECTED_STACK_ERROR_0_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0001, INVALIDm, "MMU FAP UNCORRECTED_STACK_ERROR_0",
        UNCORRECTED_STACK_ERROR_0f, UNCORRECTED_STACK_ERROR_0_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */
    
};


STATIC  _soc_saber2_mmu_sub_block_internal_info_t
                           _soc_saber2_mmu_sb_qstruct_parity_info [] = {
    { 0x0004, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
      QENTRY_FAP_ERROR_DISINTf,
      QENTRY_FAP_ERRORf,
      QSTRUCT_FAP_MEM_ERROR_MASKr,
      QSTRUCT_FAP_MEM_ERRORr,
      _soc_saber2_mmu_sb_qstruct_fap_parity_info }, 
           
    { 0x0002, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY,
      QENTRY_ERROR_0_DISINTf,
      QENTRY_ERROR_0f,
      QSTRUCT_QENTRY_ERROR_MASK_0r,
      QSTRUCT_QENTRY_ERROR_0r,
      _soc_saber2_mmu_sb_qstruct_qentry_parity_info }, 
      
    { 0x0001, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
      QBLOCK_NEXT_ERROR_0_DISINTf,
      QBLOCK_NEXT_ERROR_0f, 
      QSTRUCT_QBLOCK_NEXT_ERROR_MASK_0r,
      QSTRUCT_QBLOCK_NEXT_ERROR_0r,                                         
      _soc_saber2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info }, 
      
    { 0 } /* table terminator */
    
};

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t
                                  _soc_saber2_mmu_sb_deq0_parity_info [] = {
    /* Not ECC error */                                    
    { 0x0800, INVALIDm, "MMU DEQ_RDE_TRACE_EVENT",
        DEQ_RDE_TRACE_EVENTf, 
        DEQ_RDE_TRACE_EVENT_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x0400, INVALIDm, "MMU CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERROR",
        CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERRORf, 
        CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERROR_DISINTf,        	
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0200, INVALIDm, "MMU CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERROR",
        CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERRORf, 
        CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x0100, INVALIDm, "MMU CCBE_CONTROL_DATA_REPLICATION_ERROR",
        CCBE_CONTROL_DATA_REPLICATION_ERRORf, 
        CCBE_CONTROL_DATA_REPLICATION_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0080, INVALIDm, "MMU CELL_CLASSIFICATION_EXT_ERROR",
        CELL_CLASSIFICATION_EXT_ERRORf, 
        CELL_CLASSIFICATION_EXT_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0040, INVALIDm, "MMU CELL_CLASSIFICATION_INT_ERROR",
        CELL_CLASSIFICATION_INT_ERRORf, 
        CELL_CLASSIFICATION_INT_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0020, INVALIDm, "MMU RD_CTRL_RD_REQ_DISCARD_ERROR",
        RD_CTRL_RD_REQ_DISCARD_ERRORf, 
        RD_CTRL_RD_REQ_DISCARD_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0010, INVALIDm, "MMU DEQ_TRACE_EVENT",
        DEQ_TRACE_EVENTf, 
        DEQ_TRACE_EVENT_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0008, INVALIDm, "MMU EGRESS_FIFO_OVERFLOW_ERROR",
        EGRESS_FIFO_OVERFLOW_ERRORf, 
        EGRESS_FIFO_OVERFLOW_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0004, INVALIDm, "MMU EGRESS_FIFO_UNDERRUN_ERROR",
        EGRESS_FIFO_UNDERRUN_ERRORf,
        EGRESS_FIFO_UNDERRUN_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
        
    { 0x0002, INVALIDm, "MMU TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERROR",
        TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x0001, INVALIDm, "MMU TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERROR",
        TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    
    { 0 } /* table terminator */
    
};

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t 
                                  _soc_saber2_mmu_sb_deq1_parity_info [] = {
    { 0x20000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x10000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x08000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x04000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x02000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x01000000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERRORf",  
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00800000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf},
    { 0x00400000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf},
        
    { 0x00200000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf},
    { 0x00100000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf},
        
    { 0x00080000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x00040000, INVALIDm, "MMU DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERROR",  
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERRORf,
        DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf,      
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00020000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR",  
        DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x00010000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERROR",  
        DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x00008000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR",  
        DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x00004000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERROR",  
        DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    
    { 0x00002000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR",  
        DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x00001000, INVALIDm, "MMU DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERROR", 
        DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERRORf,
        DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
          
    { 0x00000800, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x00000400, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00000200, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x00000100, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
        
    { 0x00000080, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},                
    { 0x00000040, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00000020, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x00000010, INVALIDm, "MMU DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERROR", 
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERRORf,
        DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00000008, INVALIDm, "MMU DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERROR",
        DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERRORf,
        DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},               
    { 0x00000004, INVALIDm, "MMU DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERROR",
        DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERRORf,
        DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERROR_DISINTf,    
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00000002, INVALIDm, "MMU DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERROR",
        DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERRORf,
  	    DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x00000001, INVALIDm, "MMU DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERROR",
        DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERRORf,
        DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */
    
};

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t 
                                  _soc_saber2_mmu_sb_deq2_parity_info [] = {

    { 0x00000010, INVALIDm, "MMU DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_4",
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_4_PARITY_ERRORf,
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_4_PARITY_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},       
    
    { 0x00000008, INVALIDm, "MMU DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_3",
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_3_PARITY_ERRORf,
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_3_PARITY_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
            
    { 0x00000004, INVALIDm, "MMU DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_2",
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_2_PARITY_ERRORf,
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_2_PARITY_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x00000002, INVALIDm, "MMU DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_1",
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_1_PARITY_ERRORf,
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_1_PARITY_ERROR_DISINTf,   
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
            
    { 0x00000001, INVALIDm, "MMU DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_0",
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_0_PARITY_ERRORf,
        DEQ_CELL_RECONSTRUCTION_RESIDUAL_BUFFER_0_PARITY_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */
    
};


STATIC  _soc_saber2_mmu_sub_block_internal_info_t
                           _soc_saber2_mmu_sb_deq_parity_info [] = {
    /*  DEQ_ERROR  */    
    { 0x0004, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2, 
      INVALIDf,
      DEQ_ERROR_2f,
      DEQ_ERROR_MASK_2r,
      DEQ_ERROR_2r, 
      _soc_saber2_mmu_sb_deq2_parity_info },
      
    { 0x0002, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
      INVALIDf,
      DEQ_ERROR_1f, 
      DEQ_ERROR_MASK_1r,
      DEQ_ERROR_1r, 
      _soc_saber2_mmu_sb_deq1_parity_info },
      
    { 0x0001, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
      INVALIDf,
      DEQ_ERROR_0f, 
      DEQ_ERROR_MASK_0r,
      DEQ_ERROR_0r, 
      _soc_saber2_mmu_sb_deq0_parity_info },
      
    { 0 } /* table terminator */
    
};

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t 
                         _soc_saber2_mmu_sb_emc0_parity_info [] = {
    /* EMC_ERROR_0 */
    { 0x0080, INVALIDm, "MMU EMC_WTAC_WTFP_CFG_ERROR",
        EMC_WTAC_WTFP_CFG_ERRORf, EMC_WTAC_WTFP_CFG_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},      
    
    { 0x0040, INVALIDm, "MMU EMC_RSAG_RSFP_CFG_ERROR",
        EMC_RSAG_RSFP_CFG_ERRORf, EMC_RSAG_RSFP_CFG_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
        
    { 0x0020, INVALIDm, "MMU EMC_CI_WR_REQ_FULL_ERROR",
        EMC_CI_WR_REQ_FULL_ERRORf, EMC_CI_WR_REQ_FULL_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
        
    { 0x0010, INVALIDm, "MMU EMC_WTAC_SPC_EMA_LOCKUP_ERRORf",
        EMC_WTAC_SPC_EMA_LOCKUP_ERRORf, EMC_WTAC_SPC_EMA_LOCKUP_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0008, INVALIDm, "MMU EMC_WLCT_ERROR",
        EMC_WLCT_ERRORf, EMC_WLCT_ERROR_DISINTf,         
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0004, INVALIDm, "MMU EMC_WLCT_MF_BUFFER_OVERFLOW_ERROR",
        EMC_WLCT_MF_BUFFER_OVERFLOW_ERRORf, EMC_WLCT_MF_BUFFER_OVERFLOW_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0002, INVALIDm, "MMU EMC_IRRB_BUFFER_OVERFLOW_ERROR",
        EMC_IRRB_BUFFER_OVERFLOW_ERRORf, EMC_IRRB_BUFFER_OVERFLOW_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0001, INVALIDm, "MMU EMC_IWRB_BUFFER_OVERFLOW_ERROR",
        EMC_IWRB_BUFFER_OVERFLOW_ERRORf, EMC_IWRB_BUFFER_OVERFLOW_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */
    
};

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t
                                 _soc_saber2_mmu_sb_emc1_parity_info [] = {
    /* EMC_ERROR_1 */
    { 0x80000, INVALIDm,"MMU EMC_CSDB_1_BUFFER_MEM_3_UNCORRECTED_ERROR",
        EMC_CSDB_1_BUFFER_MEM_3_UNCORRECTED_ERRORf,      
        EMC_CSDB_1_BUFFER_MEM_3_UNCORRECTED_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x40000, INVALIDm,"MMU EMC_CSDB_1_BUFFER_MEM_2_UNCORRECTED_ERROR",
        EMC_CSDB_1_BUFFER_MEM_2_UNCORRECTED_ERRORf,    
        EMC_CSDB_1_BUFFER_MEM_2_UNCORRECTED_ERROR_DISINTf,   
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x20000, INVALIDm,"MMU EMC_CSDB_1_BUFFER_MEM_1_UNCORRECTED_ERROR",
        EMC_CSDB_1_BUFFER_MEM_1_UNCORRECTED_ERRORf,      
        EMC_CSDB_1_BUFFER_MEM_1_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x10000, INVALIDm,"MMU EMC_CSDB_1_BUFFER_MEM_0_UNCORRECTED_ERROR",
        EMC_CSDB_1_BUFFER_MEM_0_UNCORRECTED_ERRORf,    
        EMC_CSDB_1_BUFFER_MEM_0_UNCORRECTED_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x8000, INVALIDm,"MMU EMC_CSDB_0_BUFFER_MEM_3_UNCORRECTED_ERROR",
        EMC_CSDB_0_BUFFER_MEM_3_UNCORRECTED_ERRORf,      
        EMC_CSDB_0_BUFFER_MEM_3_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x4000, INVALIDm,"MMU EMC_CSDB_0_BUFFER_MEM_2_UNCORRECTED_ERROR",
        EMC_CSDB_0_BUFFER_MEM_2_UNCORRECTED_ERRORf,    
        EMC_CSDB_0_BUFFER_MEM_2_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x2000, INVALIDm,"MMU EMC_CSDB_0_BUFFER_MEM_1_UNCORRECTED_ERROR",
        EMC_CSDB_0_BUFFER_MEM_1_UNCORRECTED_ERRORf,      
        EMC_CSDB_0_BUFFER_MEM_1_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    
    { 0x1000, INVALIDm,"MMU EMC_CSDB_0_BUFFER_MEM_0_UNCORRECTED_ERROR",
        EMC_CSDB_0_BUFFER_MEM_0_UNCORRECTED_ERRORf,    
        EMC_CSDB_0_BUFFER_MEM_0_UNCORRECTED_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0800, INVALIDm,"MMU EMC_RFCQ_BUFFER_UNCORRECTED_ERROR",
        EMC_RFCQ_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RFCQ_BUFFER_UNCORRECTED_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0400, INVALIDm,"MMU EMC_RFCQ_BUFFER_CORRECTED_ERROR",
        EMC_RFCQ_BUFFER_CORRECTED_ERRORf,    
        EMC_RFCQ_BUFFER_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0200, INVALIDm,"MMU EMC_RSFP_BUFFER_UNCORRECTED_ERROR",
        EMC_RSFP_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RSFP_BUFFER_UNCORRECTED_ERROR_DISINTf,      
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    { 0x0100, INVALIDm,"MMU EMC_RSFP_BUFFER_CORRECTED_ERROR",
        EMC_RSFP_BUFFER_CORRECTED_ERRORf,    
        EMC_RSFP_BUFFER_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0x0080, INVALIDm,"MMU EMC_IRRB_BUFFER_UNCORRECTED_ERROR",
        EMC_IRRB_BUFFER_UNCORRECTED_ERRORf,      
        EMC_IRRB_BUFFER_UNCORRECTED_ERROR_DISINTf,      
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0040, INVALIDm,"MMU EMC_IRRB_BUFFER_CORRECTED_ERROR",
        EMC_IRRB_BUFFER_CORRECTED_ERRORf,    
        EMC_IRRB_BUFFER_CORRECTED_ERROR_DISINTf, 
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0020, INVALIDm,"MMU EMC_SWAT_BUFFER_UNCORRECTED_ERROR",
        EMC_SWAT_BUFFER_UNCORRECTED_ERRORf,       
        EMC_SWAT_BUFFER_UNCORRECTED_ERROR_DISINTf,       
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0010, INVALIDm,"MMU EMC_SWAT_BUFFER_CORRECTED_ERROR",
        EMC_SWAT_BUFFER_CORRECTED_ERRORf,     
        EMC_SWAT_BUFFER_CORRECTED_ERROR_DISINTf,    
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0008, INVALIDm,"MMU EMC_WTOQ_BUFFER_UNCORRECTED_ERROR",
        EMC_WTOQ_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTOQ_BUFFER_UNCORRECTED_ERROR_DISINTf,      
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0004, INVALIDm,"MMU EMC_WTOQ_BUFFER_CORRECTED_ERROR",
        EMC_WTOQ_BUFFER_CORRECTED_ERRORf,     
        EMC_WTOQ_BUFFER_CORRECTED_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0x0002, INVALIDm,"MMU EMC_WTFP_BUFFER_UNCORRECTED_ERROR",
        EMC_WTFP_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTFP_BUFFER_UNCORRECTED_ERROR_DISINTf,       
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0001, INVALIDm,"MMU EMC_WTFP_BUFFER_CORRECTED_ERROR",
        EMC_WTFP_BUFFER_CORRECTED_ERRORf,     
        EMC_WTFP_BUFFER_CORRECTED_ERROR_DISINTf,  
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
        
    { 0 } /* table terminator */
    
};


STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t
                          _soc_saber2_mmu_sb_emc2_parity_info [] = {
    /* EMC_ERROR_2 */
    { 0x02,INVALIDm, "MMU EMC_WLCT_BUFFER_UNCORRECTED_ERROR", 
        EMC_WLCT_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT_BUFFER_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x01,INVALIDm, "MMU EMC_WLCT_BUFFER_CORRECTED_ERROR", 
        EMC_WLCT_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT_BUFFER_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */
    
};


STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t
                          _soc_saber2_mmu_sb_emc3_parity_info [] = {
    /* EMC_ERROR_3 */
    { 0x08,INVALIDm, "MMU EMC_CI1_FIXED_PATTERN_ERROR",
        EMC_CI1_FIXED_PATTERN_ERRORf,
        EMC_CI1_FIXED_PATTERN_ERROR_DISINTf,   
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},       

    { 0x04,INVALIDm, "MMU EMC_CI0_FIXED_PATTERN_ERROR",
        EMC_CI0_FIXED_PATTERN_ERRORf,
        EMC_CI0_FIXED_PATTERN_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
    
    { 0x02,INVALIDm, "MMU EMC_WLCT_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR",
        EMC_WLCT_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        
        
    { 0x01,INVALIDm, "MMU EMC_WLCT_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR",
        EMC_WLCT_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},        

    { 0 } /* table terminator */

};

    
STATIC  
_soc_saber2_mmu_sub_block_internal_info_t
               _soc_saber2_mmu_sb_emc_parity_info [] = {
    { 0x0008, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3, 
      INVALIDf,
      EMC_ERROR_3f,
      EMC_ERROR_MASK_3r,
      EMC_ERROR_3r,
      _soc_saber2_mmu_sb_emc3_parity_info },
      
    { 0x0004, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2, 
      INVALIDf,
      EMC_ERROR_2f,
      EMC_ERROR_MASK_2r,
      EMC_ERROR_2r,
      _soc_saber2_mmu_sb_emc2_parity_info },
      
    { 0x0002, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
      INVALIDf,
      EMC_ERROR_1f,
      EMC_ERROR_MASK_1r,
      EMC_ERROR_1r, 
      _soc_saber2_mmu_sb_emc1_parity_info },
      
    { 0x0001, 
      _SOC_SABER2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
      INVALIDf,
      EMC_ERROR_0f,
      EMC_ERROR_MASK_0r,
      EMC_ERROR_0r, 
      _soc_saber2_mmu_sb_emc0_parity_info },
      
    { 0 } /* table terminator */
    
};



STATIC
_soc_saber2_mmu_sub_block_two_level_t  _soc_saber2_mmu_sub_blocks_type_2[] = {

    { 0x00000001, 
      _SOC_SABER2_MMU_SUBBLOCK_TOQ,
      TOQ_INTR_DISINTf, 
      TOQ_INTRf,
      TOQ_INTERRUPT_MASKr,
      TOQ_INTERRUPTr,
      _soc_saber2_mmu_sb_toq_parity_info},

    { 0x00000002, 
      _SOC_SABER2_MMU_SUBBLOCK_QSTRUCT,
      QSTRUCT_INTR_DISINTf, 
      QSTRUCT_INTRf,
      QSTRUCT_INTERRUPT_MASKr,
      QSTRUCT_INTERRUPTr,
      _soc_saber2_mmu_sb_qstruct_parity_info},

    
    { 0x00000080, 
      _SOC_SABER2_MMU_SUBBLOCK_DEQ,
      DEQ_INTR_DISINTf, 
      DEQ_INTRf,
      INVALIDr,
      DEQ_ERRORr,
      _soc_saber2_mmu_sb_deq_parity_info},

    { 0x00000100, 
      _SOC_SABER2_MMU_SUBBLOCK_EMC,
      EMC_INTR_DISINTf, 
      EMC_INTRf,
      INVALIDr,
      EMC_ERRORr,
      _soc_saber2_mmu_sb_emc_parity_info},


    { 0 } /* table terminator */

};
#ifdef BCM_METROLITE_SUPPORT

STATIC  
_soc_saber2_mmu_sub_block_leaf_info_t 
                                  _soc_metrolite_mmu_sb_deq1_parity_info [] = {

    { 0x00000200, INVALIDm, "MMU EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_2_UNCORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x00000100, INVALIDm, "MMU EP_REDIRECT_BUFFER_2_CORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_1_CORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_1_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x00000080, INVALIDm, "MMU EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_1_UNCORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x00000040, INVALIDm, "MMU EP_REDIRECT_BUFFER_1_CORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_1_CORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_1_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x00000020, INVALIDm, "MMU EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_0_UNCORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x00000010, INVALIDm, "MMU EP_REDIRECT_BUFFER_0_CORRECTED_ERROR", 
        EP_REDIRECT_BUFFER_0_CORRECTED_ERRORf,
        EP_REDIRECT_BUFFER_0_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x00000008, INVALIDm, "MMU ECC_VERIFICATION_1520_UNCORRECTED_ERROR",
        ECC_VERIFICATION_1520_UNCORRECTED_ERRORf,
        ECC_VERIFICATION_1520_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x00000004, INVALIDm, "MMU ECC_VERIFICATION_1520_CORRECTED_ERROR",
        ECC_VERIFICATION_1520_CORRECTED_ERRORf,
        ECC_VERIFICATION_1520_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x00000002, INVALIDm, "MMU VERIFICATION_57_CORRECTED_UNCORRECTED_ERROR",
        ECC_VERIFICATION_57_UNCORRECTED_ERRORf,
        ECC_VERIFICATION_57_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x00000001, INVALIDm, "MMU VERIFICATION_57_CORRECTED_ERROR",
        ECC_VERIFICATION_57_CORRECTED_ERRORf,
        ECC_VERIFICATION_57_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */

};

STATIC  _soc_saber2_mmu_sub_block_leaf_info_t 
                           _soc_metrolite_mmu_sb_enq_cfg_parity_info [] = {
    /* MMU_ENQ_CFG_ECC_ERROR_0 */
    { 0x2000, INVALIDm, "ENQ CFG POST_PAC_SAE_FIFO_CORRECTED_ERROR",
        POST_PAC_SAE_FIFO_CORRECTED_ERRORf, POST_PAC_SAE_FIFO_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x1000, INVALIDm, "ENQ CFG POST_PAC_SAE_FIFO_UNCORRECTED_ERROR",
        POST_PAC_SAE_FIFO_UNCORRECTED_ERRORf, POST_PAC_SAE_FIFO_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0800, INVALIDm, "ENQ CFG CBI_CORRECTED_ERROR",
        CBI_CORRECTED_ERRORf, CBI_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0400, INVALIDm, "ENQ CFG CBI_UNCORRECTED_ERROR",
        CBI_UNCORRECTED_ERRORf, CBI_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0200, INVALIDm, "ENQ CFG CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR",
        CFAPI_INTERNAL_RECYCLE_CORRECTED_ERRORf, CFAPI_INTERNAL_RECYCLE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0100, INVALIDm, "ENQ CFG CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR",
        CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERRORf, CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0080, INVALIDm, "ENQ CFG SRC_PORT_STATE_CORRECTED_ERROR",
        SRC_PORT_STATE_CORRECTED_ERRORf, SRC_PORT_STATE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0040, INVALIDm, "ENQ CFG SRC_PORT_STATE_UNCORRECTED_ERROR",
        SRC_PORT_STATE_UNCORRECTED_ERRORf, SRC_PORT_STATE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0020, INVALIDm, "ENQ CFG SOP_STORE_CORRECTED_ERROR",
        SOP_STORE_CORRECTED_ERRORf, SOP_STORE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0010, INVALIDm, "ENQ CFG SOP_STORE_UNCORRECTED_ERROR",
        SOP_STORE_UNCORRECTED_ERRORf, SOP_STORE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0008, INVALIDm, "ENQ CFG RQE_WR_COMPLETE_CORRECTED_ERROR",
        RQE_WR_COMPLETE_CORRECTED_ERRORf, RQE_WR_COMPLETE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0004, INVALIDm, "ENQ CFG RQE_WR_COMPLETE_UNCORRECTED_ERROR",
        RQE_WR_COMPLETE_UNCORRECTED_ERRORf, RQE_WR_COMPLETE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0x0002, INVALIDm, "ENQ CFG CBP_32B_WR_STORE_CORRECTED_ERROR",
        CBP_32B_WR_STORE_CORRECTED_ERRORf, CBP_32B_WR_STORE_CORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},
    { 0x0001, INVALIDm, "ENQ CFG CBP_32B_WR_STORE_UNCORRECTED_ERROR",
        CBP_32B_WR_STORE_UNCORRECTED_ERRORf, CBP_32B_WR_STORE_UNCORRECTED_ERROR_DISINTf,
        INVALIDf, INVALIDr, INVALIDf,
        INVALIDr, INVALIDf},

    { 0 } /* table terminator */

};


STATIC 
_soc_saber2_mmu_sub_block_one_level_t  _soc_metrolite_mmu_sub_blocks_type_1[] = {

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L0_ECC_ERROR1_MASKr,
      LLS_L0_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l0_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L1_ECC_ERROR1_MASKr,
      LLS_L1_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l1_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L2_ECC_ERROR1_MASKr,
      LLS_L2_ECC_ERROR1r,
      _soc_saber2_mmu_sb_lls_l2_parity_info},

    { 0x00000004, 
      _SOC_SABER2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf, 
      LLS_PORT_ECC_ERROR_MASKr,
      LLS_PORT_ECC_ERRORr,
      _soc_saber2_mmu_sb_lls_port_parity_info},

    { 0x00000008, 
      _SOC_SABER2_MMU_SUBBLOCK_AGING_INT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_INTr,
      AGING_ERROR_INTr,
      _soc_saber2_mmu_sb_aging_int_parity_info},

    { 0x00000010, 
      _SOC_SABER2_MMU_SUBBLOCK_CCP,
      CCP_INTR_DISINTf, 
      CCP_INTRf,
      CCP_ERROR_MASKr,
      CCP_ERRORr,
      _soc_saber2_mmu_sb_ccp_parity_info},

    { 0x00000020, 
      _SOC_SABER2_MMU_SUBBLOCK_CFAPI,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPI_ERROR_MASKr,
      CFAPI_ECC_ERRORr,
      _soc_saber2_mmu_sb_cfapi_parity_info},

    { 0x00000040, 
      _SOC_SABER2_MMU_SUBBLOCK_CTR,
      CTR_INTR_DISINTf, 
      CTR_INTRf,
      CTR_ERROR_MASKr,
      CTR_ERRORr,
      _soc_saber2_mmu_sb_ctr_parity_info},

    { 0x00000080, 
      _SOC_SABER2_MMU_SUBBLOCK_DEQ,
      DEQ_INTR_DISINTf, 
      DEQ_INTRf,
      DEQ_ERROR_MASK_1r,
      DEQ_ERROR_1r,
      _soc_metrolite_mmu_sb_deq1_parity_info},

    { 0x00000100, 
      _SOC_SABER2_MMU_SUBBLOCK_RQE_EXTQ,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_SER_MASKr,
      RQE_SER_STATUSr,
      _soc_saber2_mmu_sb_rqe_parity_info},

    { 0x00000200, 
      _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS1,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK1r,
      THDO_PARITY_ERROR_STATUS1r,
      _soc_saber2_mmu_sb_thdo_stat1_parity_info},

    { 0x00000200, 
      _SOC_SABER2_MMU_SUBBLOCK_THDO_STATUS2,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK2r,
      THDO_PARITY_ERROR_STATUS2r,
      _soc_saber2_mmu_sb_thdo_stat2_parity_info},

    { 0x00000400, 
      _SOC_SABER2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,
      WRED_PARITY_ERROR_MASKr,
      WRED_PARITY_ERROR_BITMAPr,
      _soc_saber2_mmu_sb_wred_parity_info},

    { 0x00000400, 
      _SOC_SABER2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,
      WRED_PROFILE_PARITY_ERROR_MASKr,
      WRED_PROFILE_PARITY_ERROR_BITMAPr,
      _soc_saber2_mmu_sb_wred_profile_parity_info},

    { 0x00000800, 
      _SOC_SABER2_MMU_SUBBLOCK_ENQ_CFG,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_CFG_ECC_ERROR_0_MASKr,
      MMU_ENQ_CFG_ECC_ERROR_0r,
      _soc_metrolite_mmu_sb_enq_cfg_parity_info},

    { 0x00000800, 
      _SOC_SABER2_MMU_SUBBLOCK_ENQ_FAP,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_FAP_ECC_ERROR_0_MASKr,
      MMU_ENQ_FAP_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_enq_fap_parity_info},

    { 0x00001000, 
      _SOC_SABER2_MMU_SUBBLOCK_THDI,
      THDI_INTR_DISINTf, 
      THDI_INTRf,
      MMU_THDI_INTR_MASKr,
      MMU_THDI_INTRr,
      _soc_saber2_mmu_sb_thdi_parity_info},

    { 0x00004000, 
      _SOC_SABER2_MMU_SUBBLOCK_INTFI_ECC,
      INTF1_INTR_DISINTf, 
      INTFI_INTRf,
      INTFI_ECC_INTR_MASKr,
      ST_TRANS_TBL_ECC_ERR1r,
      _soc_saber2_mmu_sb_inti_1_parity_info},

    { 0x00004000, 
      _SOC_SABER2_MMU_SUBBLOCK_INTFI_ECC,
      INTF1_INTR_DISINTf, 
      INTFI_INTRf,
      INTFI_ECC_INTR_MASKr,
      ST_TRANS_TBL_ECC_ERR2r,
      _soc_saber2_mmu_sb_inti_2_parity_info},

    { 0x00008000, 
      _SOC_SABER2_MMU_SUBBLOCK_MEM1,
      MEM1_INTR_DISINTf, 
      MEM1_INTRf,
      CLINK_ERROR_MASKr,
      CLINK_ERRORr,
      _soc_saber2_mmu_sb_mem1_parity_info },

    { 0x00010000, 
      _SOC_SABER2_MMU_SUBBLOCK_INFO2,
      INFO2_INTR_DISINTf, 
      INFO2_INTRf,
      CHFC_TC2PRI_TBL_ECC_CONFIGr,
      CHFC_TC2PRI_TBL_ECC_ERR1r,
      _soc_saber2_mmu_sb_info2_1_parity_info },

    { 0x00010000, 
      _SOC_SABER2_MMU_SUBBLOCK_INFO2,
      INFO2_INTR_DISINTf, 
      INFO2_INTRf,
      CHFC_TC2PRI_TBL_ECC_CONFIGr,
      CHFC_TC2PRI_TBL_ECC_ERR2r,
      _soc_saber2_mmu_sb_info2_2_parity_info },

    { 0x00020000, 
      _SOC_SABER2_MMU_SUBBLOCK_RDE,
      RDE_INTR_DISINTf, 
      RDE_INTRf,
      RDE_SER_MASKr,
      RDE_SER_STATUSr,
      _soc_saber2_mmu_sb_rde_parity_info },

    { 0x00040000, 
      _SOC_SABER2_MMU_SUBBLOCK_IPCTR,
      IPCTR_INTR_DISINTf, 
      IPCTR_INTRf,
      MMU_IPCTR_ECC_ERROR_0_MASKr,
      MMU_IPCTR_ECC_ERROR_0r,
      _soc_saber2_mmu_sb_ipctr_parity_info },

    { 0 } /* table terminator */

};

STATIC 
_soc_saber2_mmu_sub_block_two_level_t  _soc_metrolite_mmu_sub_blocks_type_2[] = {

    { 0x00000001, 
      _SOC_SABER2_MMU_SUBBLOCK_TOQ,
      TOQ_INTR_DISINTf, 
      TOQ_INTRf,
      TOQ_INTERRUPT_MASKr,
      TOQ_INTERRUPTr,
      _soc_saber2_mmu_sb_toq_parity_info},

    { 0x00000002, 
      _SOC_SABER2_MMU_SUBBLOCK_QSTRUCT,
      QSTRUCT_INTR_DISINTf, 
      QSTRUCT_INTRf,
      QSTRUCT_INTERRUPT_MASKr,
      QSTRUCT_INTERRUPTr,
      _soc_saber2_mmu_sb_qstruct_parity_info},

    { 0 } /* table terminator */

};

#endif


/* SER processing for TCAMs */
static _soc_generic_ser_info_t *_soc_saber2_tcam_ser_info[SOC_MAX_NUM_DEVICES];


STATIC _soc_generic_ser_info_t _soc_saber2_tcam_ser_info_template[] = {

    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 97}, {1, 97}, {98, 193}, {99, 193} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},

    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 121}, {1, 121}, {122, 241}, {122, 241} }, 0, 0, 0, 0, 
      _SOC_SER_FLAG_XY_READ },

    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 120}, {1, 120}, {121, 240}, {122, 240} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    { SUBPORT_TAG_TO_PP_PORT_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 121}, {1, 121}, {122, 241}, {123, 241} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 121}, {1, 121}, {122, 241}, {123, 241} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    /* FP_GLOBAL_MASK_TCAM */    
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 120}, {1, 120}, {121, 240}, {122, 240} }, 0, 0, 0, 0,
       _SOC_SER_FLAG_XY_READ },

    /* EGR_SAT_SAMP_TCAM */
    { EGR_SAT_SAMP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {238, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    /* ING_SAT_SAMP_TCAM  */
    { ING_SAT_SAMP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },    

    /* VLAN_SUBNET_ONLY  */
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0, 
      _SOC_SER_FLAG_XY_READ },

    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },

    /* end flag */
    { INVALIDm },
    
};

STATIC
_soc_saber2_fifo_ser_info_t _soc_saber2_ep_ser_info[] = {

    { EFP_POLICY_PARITY_CONTROLr, PARITY_ENf, 0, EFP_POLICY_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_PW_INIT_COUNTERS_PARITY_CONTROLr, PARITY_ENf, 0, EGR_PW_INIT_COUNTERSm, INVALIDr, "", EVEN_PARITYf },
    { EFP_METER_PARITY_CONTROLr, PARITY_ENf, 0, EFP_METER_TABLEm, INVALIDr, "", EVEN_PARITYf },    
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_PCP_DE_MAPPING_PARITY_ENf, 0, EGR_PCP_DE_MAPPINGm, INVALIDr, "", EVEN_PARITYf },    
    { EGR_1588_SA_PARITY_CONTROLr, PARITY_ENf, 0, EGR_1588_SAm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf, 0, EGR_MOD_MAP_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_1588_LINK_DELAY_64_PARITY_CONTROLr, PARITY_ENf, 1, INVALIDm, EGR_1588_LINK_DELAY_64r, "", PARITYf },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, SF_SRC_MODID_CHECK_PARITY_ENf, 1, INVALIDm, EGR_SF_SRC_MODID_CHECKr, "", PARITYf },
    { EGR_SAT_SAMP_DATA_PARITY_CONTROLr, PARITY_ENf, 0, EGR_SAT_SAMP_DATAm, INVALIDr, "", EVEN_PARITYf },
    /* Not support EGR_VLAN_CONTROL_1r  */    
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf, 0, EGR_MAP_MHm, INVALIDr, "", EVEN_PARITYf },
    /* Not support EGR_PMOD_PKT_LEN_BUF (not defined in Allenum.h) */
    { EGR_EHCPM_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf, 0, INVALIDm, INVALIDr, "INIT BUFF", INVALIDf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_VLAN_STG_PARITY_ENf, 0, EGR_VLAN_STGm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_ECC_ENf, 0, EGR_L3_NEXT_HOPm, INVALIDr, "", ECCf }, 
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf, 0, EGR_MAC_DA_PROFILEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_ECC_ENf, 0, EGR_L3_INTFm, INVALIDr, "", ECCf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_ECC_ENf, 0, EGR_DVP_ATTRIBUTEm, INVALIDr, "", ECCf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf, 0, EGR_VFIm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf, 0, EGR_IPMCm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_QUEUE_TO_PP_PORT_MAP_PARITY_ENf, 0, EGR_QUEUE_TO_PP_PORT_MAPm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf, 0, EGR_PORTm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EFPMOD_PARITY_CONTROLr, FLEX_CTR_TOS_MAP_PAR_ENf, 0, EGR_FLEX_CTR_TOS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EFPMOD_PARITY_CONTROLr, FLEX_CTR_PKT_PRI_MAP_PAR_ENf, 0, EGR_FLEX_CTR_PKT_PRI_MAPm, INVALIDr, "", EVEN_PARITYf },
    /* The EGR_MIRROR_ENCAP_DATA_1/2 is set as SER_RESPONSE => SER_NONE, no correction */
    { EGR_EPMOD_PARITY_CONTROLr, MIRROR_ENCAP_DATA_1_ENf, 0, EGR_MIRROR_ENCAP_DATA_1m, INVALIDr, "", EVEN_PARITYf },
    { EGR_EPMOD_PARITY_CONTROLr, MIRROR_ENCAP_DATA_2_ENf, 0, EGR_MIRROR_ENCAP_DATA_2m, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf, 0, EGR_PRI_CNG_MAPm, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_IP_TUNNEL_ECC_ENf, 0, EGR_IP_TUNNELm, INVALIDr, "", ECCf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_IP_TUNNEL_ECC_ENf, 0, EGR_IP_TUNNEL_MPLSm, INVALIDr, "", ECCf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_IP_TUNNEL_ECC_ENf, 0, EGR_IP_TUNNEL_IPV6m, INVALIDr, "", EVEN_PARITY_LOWERf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf, 0, EGR_DSCP_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_VLAN_XLATE_ECC_ENf, 0, EGR_VLAN_XLATEm, INVALIDr, "", ECCf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_1m, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_2m, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf, 0, EGR_FRAGMENT_ID_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_ECC_ENf, 0, EGR_GPP_ATTRIBUTESm, INVALIDr, "", EVEN_PARITYf },      
    { EGR_OAM_OPCODE_GROUP_PARITY_CONTROLr, PARITY_ENf, 0, EGR_OAM_OPCODE_GROUPm, INVALIDr, "", EVEN_PARITYf },        
    { EGR_MA_INDEX_ECC_CONTROLr, ECC_ENf, 0, EGR_MA_INDEXm, INVALIDr, "", EVEN_PARITYf },
    { EGR_MP_GROUP_ECC_CONTROLr, ECC_ENf, 0, EGR_MP_GROUPm, INVALIDr, "", EVEN_PARITYf },      
    { EGR_OAM_FLEXIBLE_DOMAIN_CONTROL_PARITY_CONTROLr, PARITY_ENf, 0, EGR_OAM_FLEXIBLE_DOMAIN_CONTROLm, INVALIDr, "", EVEN_PARITYf },
    { EGR_OAM_OPCODE_CONTROL_PROFILE_PARITY_CONTROLr, PARITY_ENf, 0, EGR_OAM_OPCODE_CONTROL_PROFILEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_EDATABUF_PARITY_CONTROLr, LP_ECC_ENf, 0, INVALIDm, INVALIDr, "EP_EDATABUF_LP_MEM", INVALIDf },       
    { EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf, 0, EFP_COUNTER_TABLEm, INVALIDr, "" , EVEN_PARITYf},
    { EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf, 0, INVALIDm, INVALIDr, "Egress stats counter memory", INVALIDf },
    { EGR_EDATABUF_PARITY_CONTROLr, RESI_ECC_ENf, 0, INVALIDm, INVALIDr, "EP_EDATABUF_RESI_MEM", INVALIDf },
    { EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf, 0, INVALIDm, INVALIDr, "EP_EDATABUF_CM_MEM", INVALIDf },
    { IARB_LEARN_FIFO_ECC_CONTROLr, ECC_ENf, 0, INVALIDm, INVALIDr, "IARB_LEARN_FIFO_PIPE_X", INVALIDf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_VLAN_ECC_ENf, 0, EGR_VLANm, INVALIDr, "", ECCf },

    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_ECC_ENf, 0, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, INVALIDr, "", ECCf },

    /* These mem/regs are removed in 56270 */
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_VLAN_CONTROL_2_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_2r, "", PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_VLAN_CONTROL_3_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_3r, "", PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf, 0, EGR_GPP_ATTRIBUTES_MODBASEm, INVALIDr, "", EVEN_PARITYf },
    { EGR_VLAN_ECC_PARITY_CONTROLr, EGR_PVLAN_EPORT_CONTROL_PARITY_ENf, 1, INVALIDm, EGR_PVLAN_EPORT_CONTROLr, "", PARITYf },

    /* These memories have deleted the ECC or Parity field in 56270 */
    { EGR_EPMOD_PARITY_CONTROLr, MTU_ENf, 1, INVALIDm, EGR_MTUr, "", PARITYf },
    { EGR_EPMOD_PARITY_CONTROLr, COUNTER_CONTROL_ENf, 1, INVALIDm, EGR_COUNTER_CONTROLr, "", PARITYf },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, SAT_SAMP_DATA_1_ENf, 0, EGR_SAT_SAMP_DATA_1m, INVALIDr, "", EVEN_PARITYf },    
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_CFG2_PARITY_ENf, 1, INVALIDm, EGR_IPMC_CFG2r, "", PARITYf },

#ifdef BCM_METROLITE_SUPPORT
    /* These mem/regs are added in 56270 */
    { EGR_EFPMOD_PARITY_CONTROLr, MCPE0_CNTXT_BUFFER_PAR_ENf, 0, INVALIDm, INVALIDr, "EGR_EFPMOD_MCPE0_CNTXT_BUFFER", INVALIDf },
    { EGR_EFPMOD_PARITY_CONTROLr, MCPE1_CNTXT_BUFFER_PAR_ENf, 0, INVALIDm, INVALIDr, "EGR_EFPMOD_MCPE1_CNTXT_BUFFER", INVALIDf },
#endif

    /* end flag */
    { INVALIDr }
    
};

STATIC
_soc_saber2_fifo_ser_info_t _soc_saber2_ip_ser_info[] = {

    { VLAN_SUBNET_PARITY_CONTROLr, PARITY_ENf, 0, VLAN_SUBNET_DATA_ONLYm, INVALIDr, "", EVEN_PARITYf },
    { MY_STATION_DATA_PARITY_CONTROLr, PARITY_ENf, 0, MY_STATION_TCAM_DATA_ONLYm, INVALIDr, "", EVEN_PARITYf },
    { VRF_PARITY_CONTROLr, PARITY_ENf, 0, VRFm, INVALIDr, "", EVEN_PARITYf },
    { VLAN_STG_PARITY_CONTROLr, PARITY_ENf, 0, STG_TABm, INVALIDr, "", EVEN_PARITYf },
    { RTAG7_FLOW_BASED_HASH_PARITY_CONTROLr, PARITY_ENf, 0, RTAG7_FLOW_BASED_HASHm, INVALIDr, "", EVEN_PARITYf },
    { VFP_POLICY_ECC_CONTROLr, ECC_ENf, 0, VFP_POLICY_TABLEm, INVALIDr, "", ECCf },
    { SOURCE_VP_ECC_CONTROLr, ECC_ENf, 0, SOURCE_VPm, INVALIDr, "", ECCf },
    { L3_IIF_ECC_CONTROLr, ECC_ENf, 0, L3_IIFm, INVALIDr, "", ECCf },
    { VFI_ECC_CONTROLr, ECC_ENf, 0, VFIm, INVALIDr, "", ECCf },
    { VFI_1_PARITY_CONTROLr, PARITY_ENf, 0, VFI_1m, INVALIDr, "", EVEN_PARITYf },
    { L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf, 0, L2_MOD_FIFOm, INVALIDr, "", EVEN_PARITYf },
    { RTAG7_PORT_BASED_HASH_PARITY_CONTROLr, PARITY_ENf, 0, RTAG7_PORT_BASED_HASHm, INVALIDr, "", EVEN_PARITYf },
    { MAID_REDUCTION_PARITY_CONTROLr, PARITY_ENf, 0, MAID_REDUCTIONm, INVALIDr, "", EVEN_PARITYf },
    { L3_IPMC_1_ECCP_CONTROLr, ECC_ENf, 0, L3_IPMC_1m, INVALIDr, "", PARITYf },
    { INITIAL_L3_ECMP_GROUP_ECCP_CONTROLr, ECC_ENf, 0, INITIAL_L3_ECMP_GROUPm, INVALIDr, "", PARITYf },
    { INITIAL_PROT_NHI_TABLE_ECCP_CONTROLr, ECC_ENf, 0, INITIAL_PROT_NHI_TABLEm, INVALIDr, "", PARITYf },
    { INITIAL_ING_L3_NEXT_HOP_ECCP_CONTROLr, ECC_ENf, 0, INITIAL_ING_L3_NEXT_HOPm, INVALIDr, "", PARITYf },
    { INITIAL_L3_ECMP_ECCP_CONTROLr, ECC_ENf, 0, INITIAL_L3_ECMPm, INVALIDr, "", PARITYf },
    { ING_DVP_TABLE_ECCP_CONTROLr, ECC_ENf, 0, ING_DVP_TABLEm, INVALIDr, "", ECCf },
    { DSCP_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, DSCP_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { ING_PRI_CNG_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_PRI_CNG_MAPm, INVALIDr, "", EVEN_PARITYf },
    { VLAN_MPLS_PARITY_CONTROLr, PARITY_ENf, 0, VLAN_MPLSm, INVALIDr, "", EVEN_PARITYf },
    { INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf, 0, INITIAL_PROT_NHI_TABLE_1_DMAm, INVALIDr, "", EVEN_PARITYf },
    { TTL_FN_PARITY_CONTROLr, PARITY_ENf, 0, TTL_FNm, INVALIDr, "", EVEN_PARITYf },
    { TOS_FN_PARITY_CONTROLr, PARITY_ENf, 0, TOS_FNm, INVALIDr, "", EVEN_PARITYf },
    { ING_SVM_PKT_RES_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_SVM_PKT_RES_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_SVM_TOS_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_SVM_TOS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_SVM_PKT_PRI_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_SVM_PKT_PRI_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_1588_PROFILE_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, ING_1588_TS_DISPOSITION_PROFILE_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { STORM_CONTROL_METER_CONFIG_PARITY_CONTROLr, PARITY_ENf, 1, INVALIDm, STORM_CONTROL_METER_CONFIGr, "", EVEN_PARITYf },
    { VLAN_XLATE_ECC_CONTROLr, ECC_ENf, 0, VLAN_XLATEm, INVALIDr, "", ECCf },
    { MPLS_ENTRY_ECC_CONTROLr, ECC_ENf, 0, MPLS_ENTRYm, INVALIDr, "", ECCf },
    { VLAN_ECC_CONTROLr, ECC_ENf, 0, VLAN_TABm, INVALIDr, "", ECCf },
    { RX_PROT_GROUP_TABLE_DMA_PARITY_CONTROLr, PARITY_ENf, 0, RX_PROT_GROUP_TABLE_DMAm, INVALIDr, "", EVEN_PARITYf },
    { L2_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L2Xm, INVALIDr, "", ECCf },
    { VLAN_OR_VFI_MAC_COUNT_PARITY_CONTROLr, PARITY_ENf, 0, VLAN_OR_VFI_MAC_COUNTm, INVALIDr, "", EVEN_PARITYf },
    { VLAN_OR_VFI_MAC_LIMIT_ECC_CONTROLr, ECC_ENf, 0, VLAN_OR_VFI_MAC_LIMITm, INVALIDr, "", EVEN_PARITYf },
    { PORT_CBL_TABLE_MODBASE_PARITY_CONTROLr, PARITY_ENf, 0, PORT_CBL_TABLE_MODBASEm, INVALIDr, "", EVEN_PARITYf },
    { RMEP_ECCP_CONTROLr, ECC_ENf, 0, RMEPm, INVALIDr, "", PARITYf },
    { MA_STATE_ECCP_CONTROLr, ECC_ENf, 0, MA_STATEm, INVALIDr, "", PARITYf },
    { PORT_CBL_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, PORT_CBL_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { FP_FIELD_SEL_PARITY_CONTROLr, PARITY_ENf, 0, FP_PORT_FIELD_SELm, INVALIDr, "", EVEN_PARITYf },
    { OAM_OPCODE_GROUP_PARITY_CONTROLr, PARITY_ENf, 0, OAM_OPCODE_GROUPm, INVALIDr, "", EVEN_PARITYf },
    { MA_INDEX_ECC_CONTROLr, ECC_ENf, 0, MA_INDEXm, INVALIDr, "", EVEN_PARITYf },
    { MP_GROUP_ECC_CONTROLr, ECC_ENf, 0, MP_GROUPm, INVALIDr, "", EVEN_PARITYf },
    { OAM_FLEXIBLE_DOMAIN_CONTROL_PARITY_CONTROLr, PARITY_ENf, 0, OAM_FLEXIBLE_DOMAIN_CONTROLm, INVALIDr, "", EVEN_PARITYf },
    { OAM_OPCODE_CONTROL_PROFILE_PARITY_CONTROLr, PARITY_ENf, 0, OAM_OPCODE_CONTROL_PROFILEm, INVALIDr, "", EVEN_PARITYf },
    { IFP_STORM_CONTROL_PARITY_CONTROLr, PARITY_ENf, 0, FP_STORM_CONTROL_METERSm, INVALIDr, "", EVEN_PARITYf },
    { IFP_COUNTER_PARITY_CONTROLr, PARITY_ENf, 0, FP_COUNTER_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { IFP_METER_PARITY_CONTROLr, PARITY_ENf, 0, FP_METER_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { IFP_POLICY_PARITY_CONTROLr, PARITY_ENf, 0, FP_POLICY_TABLEm, INVALIDr, "" ,EVEN_PARITY_0f },
    { ICONTROL_OPCODE_BITMAP_PARITY_CONTROLr, PARITY_ENf, 0, ICONTROL_OPCODE_BITMAPm, INVALIDr, "", EVEN_PARITYf },
    { PHB2_COS_MAP_PARITY_CONTROLr, PARITY_ENf, 0, PHB2_COS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { E2E_HOL_STATUS_PARITY_CONTROLr, PARITY_ENf, 0, E2E_HOL_STATUSm, INVALIDr, "", EVEN_PARITYf },
    { E2E_HOL_STATUS_1_PARITY_CONTROLr, PARITY_ENf, 0, E2E_HOL_STATUS_1m, INVALIDr, "", EVEN_PARITYf },
    { LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_CONTROLr, PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBMm, INVALIDr, "", EVEN_PARITYf },
    { LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_CONTROLr, PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, INVALIDr, "", EVEN_PARITYf },
    { ING_EGRMSKBMAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_EGRMSKBMAPm, INVALIDr, "", EVEN_PARITYf },
    { EMIRROR_CONTROL_PARITY_CONTROLr, PARITY_ENf, 0, EMIRROR_CONTROLm, INVALIDr, "", EVEN_PARITYf },
    { EMIRROR_CONTROL1_PARITY_CONTROLr, PARITY_ENf, 0, EMIRROR_CONTROL1m, INVALIDr, "", EVEN_PARITYf },
    { EMIRROR_CONTROL2_PARITY_CONTROLr, PARITY_ENf, 0, EMIRROR_CONTROL2m, INVALIDr, "", EVEN_PARITYf },
    { EMIRROR_CONTROL3_PARITY_CONTROLr, PARITY_ENf, 0, EMIRROR_CONTROL3m, INVALIDr, "", EVEN_PARITYf },
    { IMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf, 0, IMIRROR_BITMAPm, INVALIDr, "", EVEN_PARITYf },
    { UNKNOWN_HGI_BITMAP_PARITY_CONTROLr, PARITY_ENf, 0, UNKNOWN_HGI_BITMAPm, INVALIDr, "", EVEN_PARITYf },
    { VLAN_PROFILE_2_PARITY_CONTROLr, PARITY_ENf, 0, VLAN_PROFILE_2m, INVALIDr, "", EVEN_PARITYf },
    { SW2_EOP_BUFFER_C_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "SW2_EOP_BUFFER_C", INVALIDf },
    { SRC_MODID_INGRESS_BLOCK_PARITY_CONTROLr, PARITY_ENf, 0, SRC_MODID_INGRESS_BLOCKm, INVALIDr, "", EVEN_PARITYf },
    { ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf, 0, ALTERNATE_EMIRROR_BITMAPm, INVALIDr, "", EVEN_PARITYf },
    { NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, 0, NONUCAST_TRUNK_BLOCK_MASKm, INVALIDr, "", EVEN_PARITYf },
    { MAC_BLOCK_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, MAC_BLOCKm, INVALIDr, "", EVEN_PARITYf },
    { TRUNK_BITMAP_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, TRUNK_BITMAPm, INVALIDr, "", EVEN_PARITYf },
    /* ING_TRILL_RX_PKTS_ETC can not access */
    { TRILL_RX_PKTS_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "TRILL_RX_PKTS", INVALIDf },
    /* ISC_IP  can not access */
    { IP_COUNTERS_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "ISC_IP", INVALIDf },
    /* ISC_MEM0/1/2  can not access */
    { RDBGC_MEM_INST0_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "ISC_MEM0", INVALIDf },
    { RDBGC_MEM_INST1_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "ISC_MEM1", INVALIDf },
    { RDBGC_MEM_INST2_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "ISC_MEM2", INVALIDf }, 
    /* ISC_HIGIG  can not access  */
    { HG_COUNTERS_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "ISC_HIGIG", INVALIDf }, 
    { ING_SERVICE_PRI_MAP_0_PARITY_CONTROLr, PARITY_ENf, 0, ING_SERVICE_PRI_MAP_0m, INVALIDr, "", EVEN_PARITYf},
    { ING_SERVICE_PRI_MAP_1_PARITY_CONTROLr, PARITY_ENf, 0, ING_SERVICE_PRI_MAP_1m, INVALIDr, "", EVEN_PARITYf},
    { ING_SERVICE_PRI_MAP_2_PARITY_CONTROLr, PARITY_ENf, 0, ING_SERVICE_PRI_MAP_2m, INVALIDr, "", EVEN_PARITYf },
    { L3_ECMP_GROUP_ECCP_CONTROLr, ECC_ENf, 0, L3_ECMP_COUNTm, INVALIDr, "", ECC_0f },
    { L3_ECMP_PARITY_CONTROLr, PARITY_ENf, 0, L3_ECMPm, INVALIDr, "", EVEN_PARITYf },
    { L2MC_ECCP_CONTROLr, ECC_ENf, 0, L2MCm, INVALIDr, "", ECCf },
    { L3_IPMC_REMAP_PARITY_CONTROLr, PARITY_ENf, 0, L3_IPMC_REMAPm, INVALIDr, "", EVEN_PARITYf },
    { L3_IPMC_ECCP_CONTROLr, ECC_ENf, 0, L3_IPMCm, INVALIDr, "", ECCf },
    { BCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, 0, BCAST_BLOCK_MASKm, INVALIDr, "", EVEN_PARITYf },
    { KNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, 0, KNOWN_MCAST_BLOCK_MASKm, INVALIDr, "", EVEN_PARITYf },
    { UNKNOWN_UCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, 0, UNKNOWN_UCAST_BLOCK_MASKm, INVALIDr, "", EVEN_PARITYf },
    { UNKNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, 0, UNKNOWN_MCAST_BLOCK_MASKm, INVALIDr, "", EVEN_PARITYf },
    { SERVICE_COS_MAP_ECC_CONTROLr, ECC_ENf, 0, SERVICE_COS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { TRUNK_MEMBER_PARITY_CONTROLr, PARITY_ENf, 0, TRUNK_MEMBERm, INVALIDr, "", EVEN_PARITYf },
    { ING_QUEUE_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_QUEUE_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_FLEX_CTR_PKT_RES_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_FLEX_CTR_PKT_RES_MAPm, INVALIDr, "", EVEN_PARITYf },
    /*    IFP_HIGHWAY_PASSTHRU  can not access by cpu */    
    { IFP_PKT_ECC_CONTROLr, ECC_ENf, 2, INVALIDm, INVALIDr, "IFP_HIGHWAY_PASSTHRU", INVALIDf }, 
    { ING_FLEX_CTR_PRI_CNG_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_FLEX_CTR_PRI_CNG_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_FLEX_CTR_PKT_PRI_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_FLEX_CTR_PKT_PRI_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_FLEX_CTR_TOS_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_FLEX_CTR_TOS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { IFP_REDIRECTION_PROFILE_PARITY_CONTROLr, PARITY_ENf, 0, IFP_REDIRECTION_PROFILEm, INVALIDr, "", EVEN_PARITYf },
    { ING_PW_TERM_SEQ_NUM_PARITY_CONTROLr, PARITY_ENf, 0, ING_PW_TERM_SEQ_NUMm, INVALIDr, "", EVEN_PARITYf },
    { ING_OAM_LM_COUNTERS_0_ECC_CONTROLr, ECC_ENf, 0, ING_OAM_LM_COUNTERS_0m, INVALIDr, "", EVEN_PARITYf },
    { ING_OAM_LM_COUNTERS_1_ECC_CONTROLr, ECC_ENf, 0, ING_OAM_LM_COUNTERS_1m, INVALIDr, "", EVEN_PARITYf },
    { UDF_OFFSET_ECC_CONTROLr, ECC_ENf, 0, FP_UDF_OFFSETm, INVALIDr, "", EVEN_PARITYf },
    { L3_DEFIP_DATA_ECC_CONTROLr, ECC_ENf, 0, L3_DEFIP_DATA_ONLYm, INVALIDr, "", ECCf },
    /* why has not defined OAM_LM_COUNTERS_2m in Allenum.h  
       { ING_OAM_LM_COUNTERS_2_ECC_CONTROLr, ECC_ENf, 0, OAM_LM_COUNTERS_2m, INVALIDr, "" },
        */
    { IARB_LEARN_FIFO_ECC_CONTROLr, ECC_ENf, 2, INVALIDm, INVALIDr, "IARB_LEARN_FIFO_ECC_CONTROL", INVALIDf },
    { MOD_MAP_PARITY_CONTROLr, PARITY_ENf, 0, ING_MOD_MAP_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { ING_SAT_SAMP_DATA_PARITY_CONTROLr, PARITY_ENf, 0, ING_SAT_SAMP_DATAm, INVALIDr, "", EVEN_PARITYf },
    { ARB_SER_CONTROLr, LMEP_ECC_ENf, 0, LMEPm, INVALIDr, "", EVEN_PARITYf },
    { ARB_SER_CONTROLr, LMEP_1_ECC_ENf, 0, LMEP_1m, INVALIDr, "", EVEN_PARITYf },
    { SYSTEM_CONFIG_PARITY_CONTROLr, PARITY_ENf, 0, SYSTEM_CONFIG_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { L3_TUNNEL_PARITY_CONTROLr, PARITY_ENf, 0, L3_TUNNEL_DATA_ONLYm, INVALIDr, "", EVEN_PARITYf },
    { DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_CONTROLr, PARITY_ENf, 0, DEVICE_STREAM_ID_TO_PP_PORT_MAPm, INVALIDr, "", EVEN_PARITYf },
    { RX_PROT_GROUP_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf, 0, RX_PROT_GROUP_TABLE_1_DMAm, INVALIDr, "", EVEN_PARITYf },
    { VLAN_RANGE_PARITY_CONTROLr, PARITY_ENf, 0, ING_VLAN_RANGEm, INVALIDr, "", EVEN_PARITYf },
    { PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, PTP_LABEL_RANGE_PROFILE_TABLEm, INVALIDr, "", EVEN_PARITYf },

    { L3_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L3_ENTRY_ONLYm, INVALIDr, "", EVEN_PARITYf },
    { L3_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L3_ENTRY_IPV4_UNICASTm, INVALIDr, "", ECCf },
    { L3_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L3_ENTRY_IPV4_MULTICASTm, INVALIDr, "", ECC_0f },
    { L3_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L3_ENTRY_IPV6_UNICASTm, INVALIDr, "", ECC_0f },
    { L3_ENTRY_ECC_CONTROLr, ECC_ENf, 0, L3_ENTRY_IPV6_MULTICASTm, INVALIDr, "", ECC_0f },

    { SRC_TRUNK_ECC_CONTROLr, ECC_ENf, 0, SOURCE_TRUNK_MAP_TABLEm, INVALIDr, "", ECCf },
    { CPU_TS_PARITY_CONTROLr, PARITY_ENf, 0, CPU_TS_MAPm, INVALIDr, "", EVEN_PARITYf },
    { LPORT_ECC_CONTROLr, ECC_ENf, 0, LPORT_TABm, INVALIDr, "", ECC_0f },

    { ING_L3_NEXT_HOP_ECCP_CONTROLr, ECC_ENf, 0, ING_L3_NEXT_HOPm, INVALIDr, "", ECCf },
    { VLAN_PROFILE_PARITY_CONTROLr, PARITY_ENf, 0, VLAN_PROFILE_TABm, INVALIDr, "", EVEN_PARITYf },
    { PORT_TABLE_ECC_CONTROLr, ECC_ENf, 0, PORT_TABm, INVALIDr, "", ECC_0f },
    { VLAN_PROT_ECC_CONTROLr, ECC_ENf, 0, VLAN_PROTOCOL_DATAm, INVALIDr, "", ECCf },

    /* These mem/regs are removed in 56270 */
    { ING_LMFC_EOP_BUFFER_0_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "LMFC_EOP_BUFFER_0", INVALIDf },
    { ING_LMFC_EOP_BUFFER_1_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "LMFC_EOP_BUFFER_1", INVALIDf },
    { ING_LMFC_EOP_BUFFER_2_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "LMFC_EOP_BUFFER_2", INVALIDf },   
    { SW2_EOP_BUFFER_A_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "SW2_EOP_BUFFER_A", INVALIDf },
    { SW2_EOP_BUFFER_B_PARITY_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "SW2_EOP_BUFFER_B", INVALIDf },
    { SFLOW_ING_THRESHOLD_PARITY_CONTROLr, PARITY_ENf, 1, INVALIDm, SFLOW_ING_THRESHOLDr, "", EVEN_PARITYf },

    /* These memories have deleted the ECC or Parity field in 56270 */
    { TRUNK_GROUP_PARITY_CONTROLr, PARITY_ENf, 0, TRUNK_GROUPm, INVALIDr, "", EVEN_PARITYf },
    { EGR_MASK_MODBASE_PARITY_CONTROLr, PARITY_ENf, 0, EGR_MASK_MODBASEm, INVALIDr, "", EVEN_PARITYf },
    { FP_PORT_METER_MAP_PARITY_CONTROLr, PARITY_ENf, 0, FP_PORT_METER_MAPm, INVALIDr, "", EVEN_PARITYf },
    { ING_PHYSICAL_PORT_TABLE_PARITY_CONTROLr, PARITY_ENf, 0, ING_PHYSICAL_PORT_TABLEm, INVALIDr, "", EVEN_PARITYf },
    { SOURCE_TRUNK_MAP_MODVIEW_PARITY_CONTROLr, PARITY_ENf, 0, SOURCE_TRUNK_MAP_MODBASEm, INVALIDr, "", EVEN_PARITYf },
    { SYSTEM_CONFIG_MODVIEW_PARITY_CONTROLr, PARITY_ENf, 0, SYSTEM_CONFIG_TABLE_MODBASEm, INVALIDr, "", EVEN_PARITYf },
    { SUBPORT_TAG_TO_PP_PORT_MAP_DATA_ONLY_PARITY_CONTROLr, PARITY_ENf, 0, SUBPORT_TAG_TO_PP_PORT_MAP_DATA_ONLYm, INVALIDr, "", EVEN_PARITYf },

    /* These SER control registers have been renamed in 56270 */
    { EGR_MASK_ECC_CONTROLr, ECC_ENf, 0, EGR_MASKm, INVALIDr, "", ECCf },
    { L3_MTU_VALUES_ECC_CONTROLr, ECC_ENf, 0, L3_MTU_VALUESm, INVALIDr, "",EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_ECC_CONTROLr, ECC_ENf, 0, MODPORT_MAP_M0m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_ECC_CONTROLr, ECC_ENf, 0, MODPORT_MAP_M1m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_ECC_CONTROLr, ECC_ENf, 0, MODPORT_MAP_M2m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_SW_ECC_CONTROLr, ECC_ENf, 0, MODPORT_MAP_SWm, INVALIDr, "", ECCf },
    { SRC_MODID_EGRESS_ECC_CONTROLr, ECC_ENf, 0, SRC_MODID_EGRESSm, INVALIDr, "", EVEN_PARITYf },

#ifdef BCM_METROLITE_SUPPORT
    /* These SER control registers have been renamed in 56270 */
    { EGR_MASK_PARITY_CONTROLr, PARITY_ENf, 0, EGR_MASKm, INVALIDr, "", EVEN_PARITYf },
    { L3_MTU_VALUES_PARITY_CONTROLr, PARITY_ENf, 0, L3_MTU_VALUESm, INVALIDr, "",EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf, 0, MODPORT_MAP_M0m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf, 0, MODPORT_MAP_M1m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf, 0, MODPORT_MAP_M2m, INVALIDr, "", EVEN_PARITYf },
    { MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf, 0, MODPORT_MAP_SWm, INVALIDr, "", EVEN_PARITYf },
    { SRC_MODID_EGRESS_PARITY_CONTROLr, PARITY_ENf, 0, SRC_MODID_EGRESSm, INVALIDr, "", EVEN_PARITYf },
#endif

    /* end flag */
    { INVALIDr }
    
};

STATIC const
_soc_saber2_fifo_ser_block_info_t _soc_saber2_fifo_ser_block_info[] = {

    { SOC_BLK_IPIPE, ING_SER_FIFO_CTRLr, _soc_saber2_ip_ser_info },
    { SOC_BLK_EPIPE, EGR_SER_FIFO_CTRLr, _soc_saber2_ep_ser_info },

    /* end flag */
    { 0 }
    
};


STATIC _soc_saber2_parity_info_t _soc_saber2_xport_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO_MEM_ERRf,
        TXFIFO_MEM_ERRf,
        INVALIDm, "TX FIFO",
        XPORT_ECC_CONTROLr, TXFIFO_MEM_ENf,
        XPORT_TXFIFO_MEM_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM0_ERRf,
        MIB_TSC_MEM0_ERRf,
        INVALIDm, "TX MIB MEM0",
        XPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        XPORT_MIB_TSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM1_ERRf,
        MIB_TSC_MEM1_ERRf,
        INVALIDm, "TX MIB MEM1",
        XPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        XPORT_MIB_TSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM2_ERRf,
        MIB_TSC_MEM2_ERRf,
        INVALIDm, "TX MIB MEM2",
        XPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        XPORT_MIB_TSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM3_ERRf,
        MIB_TSC_MEM3_ERRf,
        INVALIDm, "TX MIB MEM3",
        XPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        XPORT_MIB_TSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM0_ERRf,
        MIB_RSC_MEM0_ERRf,
        INVALIDm, "RX MIB MEM0",
        XPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        XPORT_MIB_RSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM1_ERRf,
        MIB_RSC_MEM1_ERRf,
        INVALIDm, "RX MIB MEM1",
        XPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        XPORT_MIB_RSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM2_ERRf,
        MIB_RSC_MEM2_ERRf,
        INVALIDm, "RX MIB MEM2",
        XPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        XPORT_MIB_RSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM3_ERRf,
        MIB_RSC_MEM3_ERRf,
        INVALIDm, "RX MIB MEM3",
        XPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        XPORT_MIB_RSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM4_ERRf,
        MIB_RSC_MEM4_ERRf,
        INVALIDm, "RX MIB MEM4",
        XPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        XPORT_MIB_RSC_MEM4_ECC_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM_ERRf,
        RXFIFO_MEM_ERRf,
        INVALIDm, "RX FIFO MEM",
        XPORT_ECC_CONTROLr, RXFIFO_MEM_ENf,
        XPORT_RXFIFO_MEM_ECC_STATUSr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};

STATIC _soc_saber2_parity_info_t _soc_saber2_xlport_tsc_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INVALIDf,
        ECC_ERRf,
        INVALIDm, "TX MIB MEM0",
        XLPORT_ECC_CONTROLr, MIB_TSC0_MEM_EN_COR_ERR_RPTf,
        XLPORT_MIB_TSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INVALIDf,
        ECC_ERRf,
        INVALIDm, "TX MIB MEM1",
        XLPORT_ECC_CONTROLr, MIB_TSC1_MEM_EN_COR_ERR_RPTf,
        XLPORT_MIB_TSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },  
               
    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};

STATIC _soc_saber2_parity_info_t _soc_saber2_xlport_rsc_parity_info[] = {
       
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INVALIDf,
        ECC_ERRf,
        INVALIDm, "RX MIB MEM0",
        XLPORT_ECC_CONTROLr, MIB_RSC0_MEM_EN_COR_ERR_RPTf,
        XLPORT_MIB_RSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INVALIDf,
        ECC_ERRf,
        INVALIDm, "RX MIB MEM1",
        XLPORT_ECC_CONTROLr, MIB_RSC1_MEM_EN_COR_ERR_RPTf,
        XLPORT_MIB_RSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};

STATIC _soc_saber2_parity_info_t _soc_saber2_xlport_parity_info[] = {
       
    { _SOC_PARITY_TYPE_ECC, _soc_saber2_xlport_tsc_parity_info, 0,
        TSC_ERRf,
        INVALIDf,
        INVALIDm, "",
        XLPORT_ECC_CONTROLr, INVALIDf,
        INVALIDr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_ECC, _soc_saber2_xlport_rsc_parity_info, 0,
        MIB_RX_MEM_ERRf,
        INVALIDf,
        INVALIDm, "",
        XLPORT_ECC_CONTROLr, INVALIDf,
        INVALIDr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};

/*  For detect IP/EP's memories don't support SER_FIFO */
STATIC _soc_saber2_parity_info_t _soc_saber2_ep_parity_info[] = {

    /* flex counter */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },

    /* These memories(flex ctr 4~7) have been removed in 56270 */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7m, "",
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },

    /* These memories(flex ctr 4~7) have been removed in 56270 */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7m, "",
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },


    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};



/*  For detect IP/EP's memories don't support SER_FIFO */
STATIC _soc_saber2_parity_info_t _soc_saber2_ip_parity_info[] = {

    /* flex counter */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_0m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_1m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_2m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_3m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },

    /* These memories(flex ctr 4~7) have been removed in 56270 */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_4m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_5m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_6m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_7m, "",
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_0m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_1m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_2m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_3m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },

    /* These memories(flex ctr 4~7) have been removed in 56270 */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_4m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_5m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_6m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_7m, "",
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },

    /*SVM tables */
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INVALIDf,
        INVALIDf,
        SVM_METER_TABLEm, "",
        ING_SVM_METER_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_METER_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_METER_TABLE_PARITY_STATUS_NACKr, NULL },

    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INVALIDf,
        INVALIDf,
        SVM_MACROFLOW_INDEX_TABLEm, "",
        ING_SVM_MACROFLOW_INDEX_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INVALIDf,
        INVALIDf,
        SVM_POLICY_TABLEm, "",
        ING_SVM_POLICY_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INVALIDf,
        INVALIDf,
        SVM_OFFSET_TABLEm, "",
        ING_SVM_OFFSET_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};


STATIC _soc_saber2_parity_info_t _soc_saber2_rxlp_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MAIN_BUFF_ECC_INTR_ENABLEf,
        MAIN_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "main data buffer",
        RXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        RXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CTRL_BUFFER_ECC_INTR_ENABLEf,
        CTRL_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "ctrl data buffer",
        RXLP_ECC_PARITY_CONTROLr, CTRLBUF_ECC_ENf,
        RXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDUAL_CRC_ECC_INTR_ENABLEf,
        RESIDUAL_CRC_ECC_INTR_STATUSf,
        INVALIDm, "Residual CRC Buffer ",
        RXLP_ECC_PARITY_CONTROLr, RESIDUALCRC_ECC_ENf,
        RXLP_RESIDUAL_CRC_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_BUF_ECC_INTR_ENABLEf,
        IARB_BUF_ECC_INTR_STATUSf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, IARBBUF_ECC_ENf,
        RXLP_IARBBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRIGGER_MEM_PARITY_ERR_INTR_ENABLEf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        RXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        RXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        COUNTER_MEM_PARITY_ERR_INTR_ENABLEf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        RXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        RXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};

STATIC _soc_saber2_parity_info_t _soc_saber2_txlp_parity_info[] = {
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INT2EXT_PARITY_ERRf,
        INT2EXT_PARITY_ERRf,
        INVALIDm, "INT2EXT-MAP-TABLE",
        TXLP_ECC_PARITY_CONTROLr, INT2EXT_STREAM_MAP_PARITY_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RESICRCBUF_PARITY_ERRf,
        RESICRCBUF_PARITY_ERRf,
        INVALIDm, "RESIDUAL-CRC-BUFFER",
        TXLP_ECC_PARITY_CONTROLr, RESICRCBUF_PARITY_ENf,
        TXLP_RESICRCBUF_PARITY_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDATABUF_ECC_ERRf,
        RESIDATABUF_ECC_ERRf,
        INVALIDm, "RESIDUAL-DATA-BUFFER",
        TXLP_ECC_PARITY_CONTROLr, RESIDATABUF_ECC_ENf,
        TXLP_RESIDATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        DATABUF_ECC_ERRf,
        DATABUF_ECC_ERRf,
        INVALIDm, "MAIN-DATA-BUFFER.",
        TXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CSTATEBUF_PARITY_ERRf,
        CSTATEBUF_PARITY_ERRf,
        INVALIDm, "HANNEL-STATE-BUFFER.",
        TXLP_ECC_PARITY_CONTROLr, CSTATEBUF_PARITY_ENf,
        TXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRIGGER_MEM_PARITY_ERRf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[0-7]",
        TXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        TXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        TXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        COUNTER_MEM_PARITY_ERRf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[8-11]",
        TXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        TXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        TXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */

};



STATIC const
_soc_saber2_parity_route_block_t  _soc_saber2_parity_intr_route_blocks[] = {

    /* CMIC_CMC0_IRQ_STAT3.   refer to CMIC_INTR_STATUS Format */


    /* IP1_TO_CMIC_L2MF_INTR bit0 */

    /* IP1_TO_CMIC_L2_OVERFLOW_INTR bit1 */

    /* IP1_TO_CMIC_OAMP2ECI_C_INTR bit2 
           Indicates ECC Error detected or SAT event pending or RX SAT done 
        */
    
    /* unused interrupt bit3~7 */

   
    /* MMU_TO_CMIC_MEMFAIL_INTR bit 8*/
    { 0x00000100, SOC_BLK_MMU, 
      MMU_INTR_MASKr, MMU_INTRr,INVALIDf, NULL, 0},
    
    /* EP1_TO_CMIC_PERR_INTR bit 9 */
    { 0x00000200, SOC_BLK_EPIPE, 
      EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr, SER_FIFO_NON_EMPTYf, _soc_saber2_ep_parity_info, 0},
    
    /* EP2_TO_CMIC_PERR_INTR bit 10*/
    { 0x00000400, SOC_BLK_EPIPE, 
      EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr, SER_FIFO_NON_EMPTYf, NULL, 0},

    /* IP0_TO_CMIC_PERR_INTR bit 11 */
    { 0x00000800, SOC_BLK_IPIPE, 
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0},

    /* IP1_TO_CMIC_PERR_INTR bit 12 */
    { 0x00001000, SOC_BLK_IPIPE, 
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0},
        
    /* IP2_TO_CMIC_PERR_INTR bit 13*/
    { 0x00002000, SOC_BLK_IPIPE, 
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0}, 

    /* MXQ0_TO_CMIC_PERR_INTR bit 14*/
    { 0x00004000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 0}, 

    /* MXQ1_TO_CMIC_PERR_INTR bit 15*/
    { 0x00008000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 1}, 

    /* MXQ2_TO_CMIC_PERR_INTR bit 16*/
    { 0x00010000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 2}, 

    /* MXQ3_TO_CMIC_PERR_INTR bit 17*/
    { 0x00020000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 3}, 

    /* MXQ4_TO_CMIC_PERR_INTR bit 18*/
    { 0x00040000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 4}, 

    /* MXQ5_TO_CMIC_PERR_INTR bit 19*/
    { 0x00080000, SOC_BLK_MXQPORT, 
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 5}, 

    /* PM_TO_CMIC_PERR_INTR bit20  xlport */
    { 0x00100000, SOC_BLK_XLPORT, 
      XLPORT_INTR_ENABLEr, INVALIDr, INVALIDf, _soc_saber2_xlport_parity_info, 0},

    /*  RXLP0_TO_CMIC_PERR_INTR bit 21 */
    { 0x00200000, SOC_BLK_RXLP, 
      RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr, INVALIDf, _soc_saber2_rxlp_parity_info, 0}, 
    
    /*  TXLP0_TO_CMIC_PERR_INTR bit 22 */
    { 0x00400000, SOC_BLK_TXLP, 
      TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr, INVALIDf, _soc_saber2_txlp_parity_info, 0}, 

    /* IP3_TO_CMIC_PERR_INTR bit 23 */
    { 0x00800000, SOC_BLK_IPIPE, 
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, _soc_saber2_ip_parity_info, 0}, 

    /* other interrupt bits */

    { 0 } /* table terminator */

};

#ifdef BCM_METROLITE_SUPPORT
STATIC const
_soc_saber2_parity_route_block_t  _soc_metrolite_parity_intr_route_blocks[] = {

    /* CMIC_CMC0_IRQ_STAT3.   refer to CMIC_INTR_STATUS Format */


    /* IP1_TO_CMIC_L2MF_INTR bit0 */

    /* IP1_TO_CMIC_L2_OVERFLOW_INTR bit1 */

    /* IP1_TO_CMIC_OAMP2ECI_C_INTR bit2
       Indicates ECC Error detected or SAT event pending or RX SAT done
    */

    /* PULL_DOWN0 bit3~7 */


    /* MMU_TO_CMIC_MEMFAIL_INTR bit 8*/
    { 0x00000100, SOC_BLK_MMU,
      MMU_INTR_MASKr, MMU_INTRr,INVALIDf, NULL, 0},

    /* EP1_TO_CMIC_PERR_INTR bit 9 */
    { 0x00000200, SOC_BLK_EPIPE,
      EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr, SER_FIFO_NON_EMPTYf, _soc_saber2_ep_parity_info, 0},

    /* EP2_TO_CMIC_PERR_INTR bit 10*/
    { 0x00000400, SOC_BLK_EPIPE,
      EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr, SER_FIFO_NON_EMPTYf, NULL, 0},

    /* IP0_TO_CMIC_PERR_INTR bit 11 */
    { 0x00000800, SOC_BLK_IPIPE,
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0},

    /* IP1_TO_CMIC_PERR_INTR bit 12 */
    { 0x00001000, SOC_BLK_IPIPE,
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0},

    /* IP2_TO_CMIC_PERR_INTR bit 13*/
    { 0x00002000, SOC_BLK_IPIPE,
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, NULL, 0},

    /* MXQ_TO_CMIC_PERR_INTR bit 14*/
    { 0x00004000, SOC_BLK_MXQPORT,
      XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, INVALIDf, _soc_saber2_xport_parity_info, 0}, 

    /* PM0_TO_CMIC_PERR_INTR bit 15*/
    { 0x00008000, SOC_BLK_MXQPORT,
      XLPORT_INTR_ENABLEr, INVALIDr, INVALIDf, _soc_saber2_xlport_parity_info, 0},

    /* PM1_TO_CMIC_PERR_INTR bit 16*/
    { 0x00010000, SOC_BLK_MXQPORT,
      XLPORT_INTR_ENABLEr, INVALIDr, INVALIDf, _soc_saber2_xlport_parity_info, 1},

    /* RXLP0_TO_CMIC_PERR_INTR bit 17*/
    { 0x00020000, SOC_BLK_RXLP,
      RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr, INVALIDf, _soc_saber2_rxlp_parity_info, 0}, 

    /* TXLP0_TO_CMIC_PERR_INTR bit 18*/
    { 0x00040000, SOC_BLK_TXLP,
      TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr, INVALIDf, _soc_saber2_txlp_parity_info, 0},

    /* IP3_TO_CMIC_PERR_INTR bit 19*/
    { 0x00080000, SOC_BLK_IPIPE,
      IP3_INTR_ENABLEr, IP3_INTR_STATUSr, ING_SER_FIFO_INTR_STATUSf, _soc_saber2_ip_parity_info, 0}, 

    /* other interrupt bits */

    { 0 } /* table terminator */

};
#endif

STATIC const 
_soc_saber2_skip_mem_reg_t _soc_saber2_skip_memreg_table[] = {
    /* SER_SPECIAL type. For TR 144, it will failed in comparing entry after correction */
    { _SOC_SABER2_SER_MEM, INVALIDr, VLAN_OR_VFI_MAC_COUNTm},
    /* OAM ser correction */
    { _SOC_SABER2_SER_MEM, INVALIDr, RMEPm},
    
    { _SOC_SABER2_SER_INVALID } /* table terminator */

};

STATIC 
uint32 _soc_saber2_mem_reg_skip(uint32 regmem, soc_mem_t mem_id, soc_reg_t reg_id)
{
    int index;
    uint32 rv = 0;

    for(index = 0; _soc_saber2_skip_memreg_table[index].regmem != _SOC_SABER2_SER_INVALID ; index ++) {
        if (((regmem == _SOC_SABER2_SER_MEM) && 
            (mem_id == _soc_saber2_skip_memreg_table[index].skip_mem)) ||
            ((regmem == _SOC_SABER2_SER_REG) && 
            (mem_id == _soc_saber2_skip_memreg_table[index].skip_reg))) {
            rv = 1;
            break;
        }
    }

    return rv;
}

STATIC int soc_saber2_ser_engine_init(int unit);

STATIC 
soc_error_t soc_saber2_found_mem_in_mmu(int unit, soc_mem_t mem,
                            _soc_saber2_mmu_sub_block_leaf_info_t  * mmu_leaf_info);

STATIC 
soc_field_t soc_saber2_set_test_field(soc_mem_t memory, soc_field_t field);


int
soc_saber2_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm) {
        wide = 1;
    }

    return soc_l3_defip_index_remap(unit, wide, index);
}

int
soc_saber2_mem_index_remap(int unit, soc_mem_t mem, int index)
{
    switch (mem) {
        case L3_DEFIPm:
        case L3_DEFIP_PAIR_128m:
        case L3_DEFIP_ONLYm:
        case L3_DEFIP_PAIR_128_ONLYm:
        case L3_DEFIP_DATA_ONLYm:
        case L3_DEFIP_PAIR_128_DATA_ONLYm:
            return soc_saber2_l3_defip_index_remap(unit, mem, index);
        default:
            return index;
    }
}

STATIC
int soc_saber2_ci_block_get(int unit, 
                              _soc_saber2_mmu_subblock_type_t sub_block, 
                              soc_block_t* block)
{
    switch(sub_block) {
    case _SOC_SABER2_MMU_SUBBLOCK_CI1:
    *block = CI1_BLOCK(unit);
        break;
        
    case _SOC_SABER2_MMU_SUBBLOCK_CI0:
    *block = CI0_BLOCK(unit);
        break;
    
    default:
        break;	
    }
    return SOC_E_NONE;
}

STATIC
int soc_saber2_process_sb_mmu_leaf_parity_enable(int unit,
                          soc_port_t port,
                          soc_reg_t leaf_enable_reg,
                          _soc_saber2_mmu_sub_block_leaf_info_t * leaf_info,
                          int enable)
{
    uint32 en_rval;
    int index;
    soc_field_t enable_field;
    _soc_saber2_mmu_sub_block_leaf_info_t * info;
    
    /* leaf_info contains a list of leaf block, each leaf has a bit in leaf_enable_reg */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, leaf_enable_reg, port, 0, 
                                      &en_rval));
    
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        if(info->intr_bit == 0) {
            /* End of leaf table */
            break;
        }
        enable_field = info->enable_field;
        
        if (SOC_REG_FIELD_VALID(unit, leaf_enable_reg, enable_field)) {
            if (enable_field == FLUSH_COMPLETE_DISINTf) {
                continue;
            }
            /* set corresponding field for a leaf block */
            soc_reg_field_set(unit, leaf_enable_reg, &en_rval, enable_field, 
                              enable ? 0 : 1);
        }
    }

    /* write back enable register */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, leaf_enable_reg, port, 0, en_rval));
    return SOC_E_NONE;
}



STATIC
int soc_saber2_process_sb_one_level_mmu_parity_enable(int unit, 
                        soc_reg_t mmu_en_reg,
                        _soc_saber2_mmu_sub_block_one_level_t * sub_block_info,
                        int enable)
{
    uint32 en_rval;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    soc_reg_t leaf_enable_reg;
    _soc_saber2_mmu_subblock_type_t sub_block_type;
    _soc_saber2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }

    /* some fields in MMU_INTR_MASK have been removed in 56270 */
    if (!soc_reg_field_valid(unit, mmu_en_reg, sub_block_info->mmu_intr_mask_field)) {
        return SOC_E_NONE;
    }

    sub_block_type = sub_block_info->mmu_sub_block;
    if ((sub_block_type == _SOC_SABER2_MMU_SUBBLOCK_CI1)||
        (sub_block_type == _SOC_SABER2_MMU_SUBBLOCK_CI0)) { 
        if (soc_feature(unit, soc_feature_ddr3)) {
            soc_saber2_ci_block_get (unit, sub_block_type, &block);
            port = SOC_BLOCK_PORT(unit, block);
        } else {
          return SOC_E_NONE;
        }
    }
    
    leaf_info = sub_block_info->info;
    
    /* enable for this sub block */
    leaf_enable_reg = sub_block_info->intr_mask_reg;
    SOC_IF_ERROR_RETURN
        (soc_saber2_process_sb_mmu_leaf_parity_enable (unit, port, 
                               leaf_enable_reg, leaf_info, enable));
    
    /* set MMU_INTR_MASK. 1 for disable. */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_intr_mask_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, en_rval));


    return SOC_E_NONE;
}


STATIC
int soc_saber2_process_sb_two_level_mmu_parity_enable(int unit, 
                       soc_reg_t mmu_en_reg,
                       _soc_saber2_mmu_sub_block_two_level_t * sub_block_info,
                       int enable)
{
    uint32 en_rval;
    soc_reg_t internal_enable_reg;
    soc_reg_t leaf_enable_reg;
    soc_field_t internal_enable_field;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_saber2_mmu_sub_block_internal_info_t * internal_info;
    _soc_saber2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }

    /* some fields in MMU_INTR_MASK have been removed in 56270 */
    if (!soc_reg_field_valid(unit, mmu_en_reg, sub_block_info->mmu_enable_field)) {
        return SOC_E_NONE;
    }
    
    internal_info = sub_block_info->info;
    internal_enable_reg = sub_block_info->internal_enable_reg;
    
    /* get mask register of level 1 sub block */
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, internal_enable_reg, 
                                      REG_PORT_ANY, 0, &en_rval));
    }

    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        if(internal_info->intr_bit == 0) {
            /* End of internal_info table */
            break;
        }

        internal_enable_field = internal_info->internal_enable_field;
        
        if ((internal_enable_reg != 0) && 
            (SOC_REG_FIELD_VALID(unit, internal_enable_reg, 
                              internal_enable_field))) {
            soc_reg_field_set(unit, internal_enable_reg, &en_rval, 
                              internal_enable_field, enable ? 0 : 1);
        }
        
        /* get mask register of level 2 sub mask */
        leaf_enable_reg = internal_info->leaf_enable_reg;
        leaf_info = internal_info->info;
                                                    
        SOC_IF_ERROR_RETURN
            (soc_saber2_process_sb_mmu_leaf_parity_enable (unit, port,
                                   leaf_enable_reg, leaf_info, enable));
    }
    
    /* write back mask register of level 1 sub block */
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, internal_enable_reg, 
                                          REG_PORT_ANY, 0, en_rval));
    }
    
    /* set MMU_INTR_MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_enable_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      en_rval));
    
    return SOC_E_NONE;
}

STATIC int
soc_saber2_parity_enable_mmu(int unit, soc_reg_t mmu_en_reg, int enable)
{
    int index;
    uint32 sub_block_num = 0;
    _soc_saber2_mmu_sub_block_one_level_t * sub_block = NULL;
    _soc_saber2_mmu_sub_block_two_level_t * two_level_sub_block = NULL;
    uint32 ext_pbmp_count=0;
    pbmp_t ext_pbmp;

    ext_pbmp = soc_property_get_pbmp(unit, spn_PBMP_EXT_MEM, 0);
    SOC_PBMP_COUNT(ext_pbmp, ext_pbmp_count);

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_1);
        sub_block = &_soc_metrolite_mmu_sub_blocks_type_1[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_1);
        sub_block = &_soc_saber2_mmu_sub_blocks_type_1[0];
    }
    for (index = 0; index < sub_block_num; index++, sub_block++) {
         /* coverity[overrun-local:FALSE] */
         if(sub_block->mmu_bit == 0) {
            break;
         }
         if ((sub_block->mmu_sub_block == _SOC_SABER2_MMU_SUBBLOCK_CI1) ||
             (sub_block->mmu_sub_block == _SOC_SABER2_MMU_SUBBLOCK_CI0)) {
             if ((!soc_feature(unit, soc_feature_ddr3)) ||
                 (ext_pbmp_count == 0)) {
                  continue;
            }
         }
         SOC_IF_ERROR_RETURN
            (soc_saber2_process_sb_one_level_mmu_parity_enable(unit, 
                                       mmu_en_reg, sub_block, enable));
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_2);
        two_level_sub_block = &_soc_metrolite_mmu_sub_blocks_type_2[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_2);
        two_level_sub_block = &_soc_saber2_mmu_sub_blocks_type_2[0];
    }
    for (index = 0; index < sub_block_num; index++, two_level_sub_block++) {
        /* coverity[overrun-local:FALSE] */
        if(two_level_sub_block->mmu_bit == 0) {
           break;
        }
        if (two_level_sub_block->mmu_sub_block == _SOC_SABER2_MMU_SUBBLOCK_EMC) {
            if ((!soc_feature(unit, soc_feature_ddr3)) ||
                (ext_pbmp_count == 0)) {
                 continue;
            }
        }
        SOC_IF_ERROR_RETURN
            (soc_saber2_process_sb_two_level_mmu_parity_enable(unit, 
                            mmu_en_reg, two_level_sub_block, enable));
    }
    return SOC_E_NONE;
}

STATIC int
soc_saber2_parity_enable_info(int unit, soc_port_t port,
                                soc_reg_t group_reg,
                                uint32 *group_rval,
                                const _soc_saber2_parity_info_t *info_list,
                                int enable)
{
    const _soc_saber2_parity_info_t *info;
    int info_index;
    soc_reg_t reg;
    uint32 rval;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Enable the info entry in the group register */
        soc_reg_field_set(unit, group_reg, group_rval,
                          info->group_reg_enable_field, enable ? 1 : 0);

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
            reg = info->enable_reg;
            if ((!SOC_REG_IS_VALID(unit, reg)) || (info->enable_field == INVALIDf)) {
                continue;
            }

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            soc_reg_field_set(unit, reg, &rval, info->enable_field,
                              enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the route block */

    return SOC_E_NONE;
}


STATIC int 
soc_saber2_ser_engine_init(int unit)
{
    int alloc_size;
    
    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_saber2_tcam_ser_info_template);
    if (NULL == _soc_saber2_tcam_ser_info[unit]) {
        if ((_soc_saber2_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "saber2 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_saber2_tcam_ser_info[unit],
               &(_soc_saber2_tcam_ser_info_template),
               alloc_size);
    return soc_generic_ser_init(unit, _soc_saber2_tcam_ser_info[unit]);

  
}



STATIC int
soc_saber2_ser_enable_all(int unit, int enable)
{
    uint16      bcount, pcount;
    int         port = REG_PORT_ANY;
    uint32      rval, cmic_bit, cmic_rval = 0;
    soc_reg_t   reg;
    soc_field_t field;    
    int route_block_index, block_idx;
    const _soc_saber2_parity_route_block_t *route_block;
    soc_reg_t route_block_en_reg;
    uint32 route_block_rval;
    const _soc_saber2_parity_route_block_t *parity_intr_route_block = NULL;

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        parity_intr_route_block = &_soc_metrolite_parity_intr_route_blocks[0];
    } else
#endif
    {
        parity_intr_route_block = &_soc_saber2_parity_intr_route_blocks[0];
    }

    /*  Init IP/EP fifo    */
    for (bcount = 0; SOC_BLK_NONE != _soc_saber2_fifo_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0;
             _soc_saber2_fifo_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
             pcount++) {
            reg = _soc_saber2_fifo_ser_block_info[bcount].info[pcount].enable_reg;
            field = _soc_saber2_fifo_ser_block_info[bcount].info[pcount].enable_field;

            /* Some memories have different parity control regs in 56270/56260 */
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
            }
            /* some memories have removed ecc/parity field in 56270 */
            if ((_soc_saber2_fifo_ser_block_info[bcount].info[pcount].mem != INVALIDm) && 
                !soc_mem_field_valid(unit,
                _soc_saber2_fifo_ser_block_info[bcount].info[pcount].mem,
                _soc_saber2_fifo_ser_block_info[bcount].info[pcount].parity_field)) {
                continue;
            }
            
            /* NOTE: Do not use the field modify routine in the following as
                     some regs do not return the correct value due to which the 
                     modify routine skips the write */
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, port, 0, &rval));
            if (soc_reg_field_valid(unit, reg, field)) {
                soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, rval));
            switch (_soc_saber2_fifo_ser_block_info[bcount].info[pcount].type) {
            case 0:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for mem: %s\n"),
                             _soc_saber2_fifo_ser_block_info[bcount].info[pcount].mem != INVALIDm ?
                             SOC_MEM_NAME(unit, _soc_saber2_fifo_ser_block_info[bcount].info[pcount].mem) :
                             _soc_saber2_fifo_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            case 1:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for reg: %s\n"),
                             _soc_saber2_fifo_ser_block_info[bcount].info[pcount].reg != INVALIDr ?
                             SOC_REG_NAME(unit, _soc_saber2_fifo_ser_block_info[bcount].info[pcount].reg) :
                             _soc_saber2_fifo_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            default: break;
            }
        }

        /* Loop through each place-and-route block entry */
        for (route_block_index = 0; ; route_block_index++) {
            route_block = parity_intr_route_block + route_block_index;
            cmic_bit = route_block->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (route_block->blocktype == _soc_saber2_fifo_ser_block_info[bcount].blocktype) {
                /* New SER mechanism */
                cmic_rval |= cmic_bit;
                if (route_block->enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, route_block->enable_reg,
                            REG_PORT_ANY, route_block->enable_field, enable ? 1 : 0));
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (_soc_saber2_fifo_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_saber2_fifo_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_saber2_fifo_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }

    /*  Init MMU route block    */
    soc_saber2_parity_enable_mmu(unit, MMU_INTR_MASKr, enable);


    /* Init other blocks */
    port = REG_PORT_ANY;
    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = parity_intr_route_block + route_block_index;
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        /* Enable the route block entry in the CMIC register */
        if (enable) {
            cmic_rval |= cmic_bit;
        }

        route_block_en_reg = route_block->enable_reg;
        
        /* Get block and port for MXQ and RXLP and TXLP */
        if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
            (route_block->blocktype == SOC_BLK_TXLP) ||
            (route_block->blocktype == SOC_BLK_RXLP)) {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    port = SOC_BLOCK_PORT(unit, block_idx);
                    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg,
                                        port, 0, &route_block_rval));
                    SOC_IF_ERROR_RETURN(soc_saber2_parity_enable_info(
                                        unit, port, route_block_en_reg,
                                        &route_block_rval, 
                                        route_block->info, enable));
                    /* coverity[negative_returns : FALSE] */
                    /* Write per route block parity enable register */
                    SOC_IF_ERROR_RETURN(soc_reg32_set(
                                        unit, route_block_en_reg, 
                                        port, 0, route_block_rval));
                    break;
                }
            }
        }   


        /* enable SVM,Flex counter in IP/EP */
        if (((route_block->blocktype == SOC_BLK_IPIPE) ||
            (route_block->blocktype == SOC_BLK_EPIPE)) && 
            (route_block->info != NULL)) {
            for(block_idx = 0; route_block->info[block_idx].type != _SOC_PARITY_TYPE_NONE; 
                block_idx ++) {
                   
                /* These memories(flex ctr 4~7) have been removed in 56270 */
                if (!SOC_MEM_IS_VALID(unit, route_block->info[block_idx].mem)) {
                    continue;
                }
                
                if (route_block->info[block_idx].group_reg_enable_field != INVALIDf) {
                    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                            route_block_en_reg, REG_PORT_ANY, 
                            route_block->info[block_idx].group_reg_enable_field, enable ? 1 : 0));
                }

                if (route_block->info[block_idx].enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                            route_block->info[block_idx].enable_reg, REG_PORT_ANY, 
                            route_block->info[block_idx].enable_field, enable ? 1 : 0)); 
                }
            }
                   
        }   
            
    } /* Loop through each place-and-route block entry */

    /* enable interrupt mask */

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_RQE_GLOBAL_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_RQE_GLOBAL_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_CHK_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_GEN_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, STAT_CLEARf, 0);
    SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_CHK_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_GEN_ENf,
            enable ? 1 : 0);
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_STAT_CLRf, 0);
    SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_RQE_GLOBAL_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_CHK_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_GEN_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_STAT_CLRf, 0);
    SOC_IF_ERROR_RETURN(WRITE_RQE_GLOBAL_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_INTFI_ECC_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, INTFI_ECC_CONTROLr, &rval, ENABLE_ECCf,
            enable ? 1 : 0);
    SOC_IF_ERROR_RETURN(WRITE_INTFI_ECC_CONTROLr(unit, rval));


    if (enable)
    {
        /* Write CMIC enable register */       
        (void)soc_cmicm_intr3_enable(unit, cmic_rval); 
    } else {
        /* Write CMIC disable register */
        (void)soc_cmicm_intr3_disable(unit, cmic_rval);
    }

    /* Set SAT interrupt */
    if (soc_feature(unit, soc_feature_sat) &&
        soc_property_get(unit, spn_SAT_ENABLE, 0)) {
        if (enable) {
            (void)soc_cmicm_intr3_enable(unit, _SOC_SABER2_SAT_CMIC_BIT);
        } else {
            (void)soc_cmicm_intr3_disable(unit, _SOC_SABER2_SAT_CMIC_BIT);
        }
    }

    return SOC_E_NONE;
}

STATIC void
soc_saber2_print_ser_fifo_details(int unit, uint8 regmem, soc_block_t blk, 
                                     uint32 sblk, uint32 address, 
                                     uint32 stage, uint32 base, uint32 index, 
                                     uint32 hwmbase, uint32 type, uint8 drop, 
                                     uint8 non_sbus)
{
    
    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityError, unit)) {
        switch (type) {
        case 0:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SOP cell.\n")));
            break;
        case 1:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: MOP cell.\n")));
            break;
        case 2:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: EOP cell.\n")));
            break;
        case 3:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SBUS transaction.\n")));
            break;
        case 4:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: miscellaneous transaction.\n")));
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid error reported !!\n")));
            break;
        }
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Blk: %d, Address: 0x%08x, base: 0x%x, stage: %d, index: %d\n"),
                              sblk, address, base, stage, index));

        if (drop) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "SER caused packet drop.\n")));
        }
    }
}


STATIC void
soc_saber2_ser_control_reg_get(int unit, CONST _soc_saber2_fifo_ser_info_t *fifo_ser_list,
                                        soc_mem_t   mem,
                                        soc_reg_t   *ser_control_reg,
                                        soc_field_t *ser_enable_field)
{
    int i;

    if ((fifo_ser_list == NULL) || (ser_control_reg == NULL) || 
        (ser_enable_field == NULL)) {
        return;
    }

    for (i = 0; fifo_ser_list[i].enable_reg != INVALIDr; i++) {
        if (fifo_ser_list[i].mem == mem) {
            /* Some memories have different parity control regs in 56270/56260 */
            if (soc_reg_field_valid(unit, fifo_ser_list[i].enable_reg,
                fifo_ser_list[i].enable_field)) {
                *ser_control_reg = fifo_ser_list[i].enable_reg;
                *ser_enable_field = fifo_ser_list[i].enable_field;
                break;
            }
        }
    }

    return;
}


STATIC int
soc_saber2_populate_ser_log(int unit, soc_reg_t parity_enable_reg,
                          soc_field_t parity_enable_field,
                          soc_mem_t mem,
                          int mem_block,
                          soc_acc_type_t acc_type,
                          int index,
                          sal_usecs_t detect_time,
                          uint32 sblk,
                          uint32 address)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS];
    int log_entry_size, id, entry_dw;
    uint32 *cache;
    uint8 *vmap;
    soc_ser_log_tlv_memory_t log_mem;
    soc_ser_log_tlv_generic_t log_generic;

    sal_memset(&log_generic, 0, sizeof(log_generic));
    sal_memset(&log_mem, 0, sizeof(log_mem));

    /*
    must be large enough for at least generic and terminator, as well as the
    memory type since we might decode it in soc_ser_correction.
    */
    log_entry_size = sizeof(soc_ser_log_tlv_hdr_t)*3 +
                     sizeof(soc_ser_log_tlv_generic_t) +
                     sizeof(soc_ser_log_tlv_memory_t);

    if (mem == INVALIDm) {
        mem = soc_addr_to_mem_extended(unit, sblk, acc_type, address);
        if (mem != INVALIDm) {
            if (sblk) {
                SOC_MEM_BLOCK_ITER(unit, mem, mem_block) {
                    if (SOC_BLOCK2OFFSET(unit, mem_block) == sblk) {
                        break;
                    }
                }
            } else {
                mem_block = SOC_MEM_BLOCK_ANY(unit, mem);
            }
        }
    }
    /*
    If we have decoded the memory we can record its contents/cache
    */
    if((mem != INVALIDm) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != SOC_MEM_FLAG_SER_SPECIAL) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != 0)) {
        entry_dw = soc_mem_entry_words(unit, mem);

        /* Check to make sure this isn't a duplicate */
        /* Search for a log entry with the same mem, and index with within the last 5 seconds */
        if (soc_ser_log_find_recent(unit, mem, index, sal_time_usecs()) > 0) {
            return 0;
        }

        log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;

        cache = SOC_MEM_STATE(unit, mem).cache[mem_block];
        vmap = SOC_MEM_STATE(unit, mem).vmap[mem_block];
        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;
        }

        /* create the entry based on determined size, save id */
        id = soc_ser_log_create_entry(unit, log_entry_size);

        /* Add the memory information to the log now so we can detect duplicate errors */
        log_generic.time = detect_time;
        log_mem.memory = mem;
        log_mem.index = index;
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_MEMORY,
            sizeof(soc_ser_log_tlv_memory_t), &log_mem);
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_GENERIC,
            sizeof(soc_ser_log_tlv_generic_t), &log_generic);

        /* Disable Parity */
        if ((parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 0) < 0) {
                return 0;
            }
        }


        /* read the memory into a buffer */
        if (acc_type == _SOC_ACC_TYPE_PIPE_Y) {
            soc_mem_pipe_select_read(unit, SOC_MEM_NO_FLAGS, mem, mem_block,
                                     acc_type, index, tmp_entry);
        } else {
            /*Enable NACK on read */
             soc_mem_read_extended(unit, SOC_MEM_SCHAN_ERR_RETURN,
                                   mem, 0, mem_block,
                                   index, tmp_entry);
        }

        /* Enable Parity */
        if ((parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 1) < 0) {
                return 0;
            }
        }

        /* fill in the memory contents tlv */
        if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CONTENTS,
            entry_dw*4, tmp_entry) < 0) {
            return 0;
        }


        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            /* fill in the memory cache tlv */
            if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CACHE,
                entry_dw*4, (cache + index*entry_dw)) < 0) {
                return 0;
            }
        }
    } else {
        id = soc_ser_log_create_entry(unit, log_entry_size);
    }

    return id;
}

STATIC int
soc_saber2_process_ser_fifo(int unit, soc_block_t blk, char *prefix_str)
{
    int rv = SOC_E_NONE;
    uint8 bidx, idx_offset;
    soc_mem_t mem;
    char blk_str[10];
    soc_reg_t reg = INVALIDr;
    _soc_ser_correct_info_t spci;
    _soc_saber2_fifo_ser_info_t* ser_info_table = NULL;
    soc_reg_t parity_enable_reg = INVALIDr;
    soc_field_t parity_enable_field = INVALIDf;

    uint32 reg_val, mask, entry[SOC_MAX_MEM_WORDS] = { 0 };
    uint32 stage = 0, addrbase = 0, index = 0, hwmbase = 0, type = 0, multiple = 0;
    uint32 sblk = 0, inst_type = 0, regmem = 0, non_sbus = 0, drop = 0, ecc_parity = 0, address = 0;


    switch (blk) {
    case SOC_BLK_IPIPE:
        mem = ING_SER_FIFOm;
        mask = 0x803800;      /* IP0~3 bit 11,12,13,23 in CMIC_CMC0_IRQ_STAT3 */ 
        ser_info_table = _soc_saber2_ip_ser_info;
        sal_sprintf(blk_str, "IPIPE");
        break;
    case SOC_BLK_EPIPE:
        mem = EGR_SER_FIFOm;
        mask = 0x1;  /*SER_FIFO_NON_EMPTY in EGR_INTR1_STATUSr */
        reg = EGR_INTR1_STATUSr;
        ser_info_table = _soc_saber2_ep_ser_info;
        sal_sprintf(blk_str, "EPIPE");
        break;
    default:
        return SOC_E_PARAM;
    }

    do {
        rv = soc_mem_pop(unit, mem, MEM_BLOCK_ANY, entry);
        SOC_IF_ERROR_RETURN(rv);

        /* process entry. */           
        if (soc_mem_field32_get(unit, mem, entry, VALIDf)) {  
            multiple = soc_mem_field32_get(unit, mem, entry, MULTIPLEf);            
            ecc_parity = soc_mem_field32_get(unit, mem, entry, ECC_PARITYf);
            regmem = soc_mem_field32_get(unit, mem, entry, MEM_TYPEf);
            address = soc_mem_field32_get(unit, mem, entry, ADDRESSf);
            stage = soc_mem_field32_get(unit, mem, entry, PIPE_STAGEf);
            type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
            drop = soc_mem_field32_get(unit, mem, entry, DROPf);
            inst_type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
       
            SOC_BLOCK_ITER(unit, bidx, blk) {
                sblk = SOC_BLOCK2SCH(unit, bidx);
                break;
            }
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s\n"), prefix_str));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Multiple: ")));
            }
            if (regmem == _SOC_SABER2_SER_REG) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Reg: ")));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem: ")));
            }
            spci.double_bit = 0;
            switch (ecc_parity) {
            case 0:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Parity error..\n")));
                break;
            case 1:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Corrected single bit ECC error..\n")));
                break;
            case 2:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Double or Multiple bit ECC error..\n")));
                spci.double_bit = 1;
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid SER issue !!\n")));
                return SOC_E_INTERNAL;
            }
            if (regmem == _SOC_SABER2_SER_MEM) {
                /* process mem */                               
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, MEMBASEf);
                index = soc_mem_field32_get(unit, mem, entry, MEMINDEXf);
                hwmbase = soc_mem_field32_get(unit, mem, entry, HWMEMBASEf);
                
                if (non_sbus == 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, 
                                       address);
                    soc_saber2_print_ser_fifo_details(unit, 0, blk, sblk, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_MEM;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.pipe_num = 0;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address - index;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();
                    spci.parity_type = ecc_parity ? SOC_PARITY_TYPE_ECC : SOC_PARITY_TYPE_PARITY;
                    spci.double_bit = (ecc_parity == 2) ? 1 : 0;

                    /* Try to decode mem first */
                    spci.mem = soc_addr_to_mem_extended(unit,
                                spci.sblk, SOC_MEM_ACC_TYPE(unit, mem), spci.addr);

                    if (spci.mem != INVALIDm) {
                        spci.acc_type = SOC_MEM_ACC_TYPE(unit, mem);
                        spci.flags |= SOC_SER_REG_MEM_KNOWN;                        
                        spci.index = soc_saber2_mem_index_remap(unit, spci.mem, index);
                    }
                    else {
                        /* Invalid mem, use the first acc_type_ptr*/
                        spci.acc_type = SOC_MEM_ACC_TYPE(unit, mem);
                        spci.flags |= SOC_SER_REG_MEM_UNKNOWN;
                    }

                    /*  HW issue: SER_FIFO has not report correct STORM_CONTROL_METER_MAPPINGm's index
                     *  when packet operation. This work-around triggers 4 times 'MEM_READ' to get valid 
                     *  memory index for correct the entry. SDK-78352 */
                    if ((spci.mem == FP_STORM_CONTROL_METERSm) && (inst_type == 2)
                        && (!SOC_IS_METROLITE(unit)))  {
                        for (idx_offset = 0; idx_offset <= 3; idx_offset ++) {
                            (void) soc_mem_read(unit, FP_STORM_CONTROL_METERSm, MEM_BLOCK_ANY, 4*index + idx_offset, entry);
                        }
                    } else {
                        if (spci.mem != INVALIDm) {
                            soc_saber2_ser_control_reg_get(unit, ser_info_table,
                                spci.mem,
                                &parity_enable_reg,
                                &parity_enable_field);
                        }
                        if (spci.mem != INVALIDm) {
                            MEM_LOCK(unit,spci.mem);
                        }
                        spci.log_id = soc_saber2_populate_ser_log(unit,
                                                  parity_enable_reg,
                                                  parity_enable_field,
                                                  spci.mem,
                                                  bidx,
                                                  spci.acc_type,
                                                  spci.index,
                                                  spci.detect_time,
                                                  spci.sblk,
                                                  spci.addr);
                        if (spci.mem != INVALIDm) {
                            MEM_UNLOCK(unit,spci.mem);
                        }
                        if (spci.mem == L2_ENTRY_ONLYm ) {
                            spci.mem = L2Xm;
                        }

                        rv = soc_ser_correction(unit, &spci);
                    }

                    if (SOC_FAILURE(rv)) {
                        if (rv != SOC_E_NOT_FOUND) {
                        /* Add reporting failed to correct event flag to application */
                            soc_event_generate(unit,
                                    SOC_SWITCH_EVENT_PARITY_ERROR,
                                    SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                    sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, 
                                    address);
                            return rv;
                        }
                    }
                    if (spci.log_id != 0) {
                        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                           SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                           spci.log_id, 0);
                    }

                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER mem address un-accessable !!\n"), blk_str));
                    soc_saber2_print_ser_fifo_details(unit, 0, blk, sblk, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            } else {
                /* process reg */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, REGBASEf);
                index = soc_mem_field32_get(unit, mem, entry, REGINDEXf);
                
                if (non_sbus == 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, 
                                       address);
                    soc_saber2_print_ser_fifo_details(unit, 1, blk, sblk, address, 
                                                         stage, addrbase, index, 0, type, 
                                                         drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();
                    spci.parity_type = ecc_parity ? SOC_PARITY_TYPE_ECC : SOC_PARITY_TYPE_PARITY;
                    spci.double_bit = (ecc_parity == 2) ? 1 : 0;
                    
                    spci.acc_type = SOC_MEM_ACC_TYPE(unit, mem);
                    spci.log_id = soc_ser_log_create_entry(unit,
                        sizeof(soc_ser_log_tlv_generic_t) +
                        sizeof(soc_ser_log_tlv_register_t) +
                        sizeof(soc_ser_log_tlv_hdr_t) *3);
                    rv = soc_ser_correction(unit, &spci);
                    SOC_IF_ERROR_RETURN(rv);

                    /* Add reporting failed to correct event flag to application */
                    soc_event_generate(unit,
                            SOC_SWITCH_EVENT_PARITY_ERROR,
                            SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                            sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, 
                            address);
                    
                    if (spci.log_id != 0) {
                        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                           SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                           spci.log_id, 0);
                    }
                    break;

                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER reg address un-accessable !!\n"), blk_str));
                    soc_saber2_print_ser_fifo_details(unit, 0, blk, sblk, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d Got invalid mem pop from %s !!\n"),
                                  unit, SOC_MEM_NAME(unit, mem)));
        }
        /* check if any more pending */
        if (reg == INVALIDr) {
            rv = READ_CMIC_CMC0_IRQ_STAT3r(unit, &reg_val);
        } else {
            rv = soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &reg_val);
        }
        SOC_IF_ERROR_RETURN(rv);
    } while (reg_val & mask);


    return SOC_E_NONE;
}

STATIC 
void soc_saber2_mem_parity_info(int unit, int block_idx, int pipe,
                                  soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}



STATIC
int soc_saber2_process_sb_mmu_leaf_parity_error (int unit, 
                      _soc_saber2_mmu_subblock_type_t sub_block_type,
                      soc_port_t port,
                      soc_reg_t leaf_enable_reg,
                      soc_reg_t leaf_status_reg,
                      _soc_saber2_mmu_sub_block_leaf_info_t * leaf_info)
{
    uint32 stat_rval, en_rval, minfo, rval, min_addr, stat_field, mask_field;
    uint32 intr_bit, sblk = 0;
    int index = 0, blk_idx;
    _soc_saber2_mmu_sub_block_leaf_info_t *info;
    char prefix_str[10];
    char *reg_str;
    char *field_str;
    _soc_ser_correct_info_t spci;    
    int rv;

    sal_sprintf(prefix_str, "unit:%d", unit);

    if(sub_block_type == _SOC_SABER2_MMU_SUBBLOCK_INFO2) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, leaf_status_reg, port, 0, &stat_rval));
        
        stat_field = soc_reg_field_get(
                        unit, leaf_status_reg, stat_rval,leaf_info->status_field);

        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, leaf_status_reg, port, 0, &en_rval));
        
        mask_field = soc_reg_field_get(
                        unit, leaf_enable_reg, en_rval,leaf_info->enable_field);

        stat_field &= (~mask_field);

        if(stat_field == 0) {            
            return SOC_E_NONE; 
        }

    } else {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, leaf_status_reg, port, 0, &stat_rval));
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, leaf_enable_reg, port, 0, &en_rval));
        
        /* mask bit =0 for enable */
        if (leaf_status_reg == RQE_EXTQ_REPLICATION_COUNTr) {
            stat_rval &= ((~en_rval) << 11);
        } else {
            stat_rval &= (~en_rval);
        }

        if (stat_rval == 0) {
            return SOC_E_NONE; 
        }

        LOG_CLI((BSL_META_U(unit,
                        "\nleaf_parity: status reg:%s value 0x:%x mask reg:%s value 0x:%x\n"),
                    SOC_REG_NAME(unit, leaf_status_reg), stat_rval,
                    SOC_REG_NAME(unit, leaf_enable_reg), en_rval));

#ifdef BCM_METROLITE_SUPPORT
        if (SOC_IS_METROLITE(unit)) {
            /* If WRED FSM received a new update tick, while it was not done with the previous update
             * cycle. The UPDATE_INTRPT will be triggered.  Write 1 to clear. */
            if ((leaf_status_reg == WRED_PARITY_ERROR_BITMAPr) &&
                ((stat_rval & 0x4000000) != 0)) {
                SOC_IF_ERROR_RETURN(READ_WRED_PARITY_ERROR_BITMAPr(unit, &rval));
                soc_reg_field_set(unit, WRED_PARITY_ERROR_BITMAPr, &rval, UPDATE_INTRPT_STATUSf, 1);
                SOC_IF_ERROR_RETURN(WRITE_WRED_PARITY_ERROR_BITMAPr(unit, rval));
            }
        }
#endif
    }
        
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        intr_bit = info->intr_bit;
        if(intr_bit == 0) {
            /* reach the end of leaf table */
            return SOC_E_NONE;
        }

        /* some fields have been removed in 56270 */
        if (!soc_reg_field_valid(unit, leaf_status_reg, info->status_field)) {
            continue;
        }
        
        /* get a match */
        if (stat_rval & intr_bit) {
            field_str = SOC_FIELD_NAME(unit, info->status_field);
            reg_str = SOC_REG_NAME(unit, leaf_status_reg);

            /* do ser correction  */     
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = (SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN);
            spci.reg = INVALIDr;
            spci.mem = info->mem;

            /* found block type for mem */
            blk_idx = 0;
            SOC_MEM_BLOCK_ITER(unit, spci.mem, blk_idx) {
                if (SOC_MEM_BLOCK_VALID(unit, spci.mem, blk_idx)) {
                    break;
                }                
            }            
            spci.blk_type = SOC_BLOCK_INFO(unit, blk_idx).type ;

            SOC_BLOCK_ITER(unit, blk_idx, spci.blk_type) {
                sblk = SOC_BLOCK2SCH(unit, blk_idx);
                break;
            }            
            spci.sblk = sblk;
            
            spci.detect_time = sal_time_usecs();
            spci.acc_type = SOC_MEM_ACC_TYPE(unit, spci.mem);


            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, info->mem_ecc_address_reg , port, 0, &rval));
            spci.index = soc_reg_field_get(unit, info->mem_ecc_address_reg, rval, info->mem_ecc_address_field);

            min_addr = SOC_MEM_INFO(unit, spci.mem).base + SOC_MEM_INFO(unit, spci.mem).index_min;
            spci.addr = min_addr + spci.index;

            /* report ser event */
            soc_saber2_mem_parity_info(unit, blk_idx, 0,
                                 info->status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE,
                                0, minfo);
                        
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                       "mem:%s address 0x:%x index:%d has MMU parity error,correction type 0x:%x \n"),
                       SOC_MEM_NAME(unit, spci.mem),
                       spci.addr, spci.index, 
                       SOC_MEM_SER_CORRECTION_TYPE(unit, spci.mem)));

            rv = soc_ser_correction(unit, &spci);
             
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                       "%s MMU subblock:%d parity err is detected by reg:%s.field:%s(value0x:%x), corrected result %d\n"),
                       prefix_str, sub_block_type, reg_str, 
                       field_str, stat_rval, rv));

            /* clear the parity error bit */
            SOC_IF_ERROR_RETURN
                 (soc_reg32_set(unit, leaf_status_reg, port, 0, intr_bit));
        }
    }
    return SOC_E_NONE;
}



STATIC
int soc_saber2_process_sb_one_level_mmu_parity_error(int unit,
                      _soc_saber2_mmu_sub_block_one_level_t * sub_block_info)
{
    soc_reg_t leaf_enable_reg;
    soc_reg_t leaf_status_reg; 
    _soc_saber2_mmu_subblock_type_t sub_block_type;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    _soc_saber2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    if ((sub_block_type == _SOC_SABER2_MMU_SUBBLOCK_CI1)||
        (sub_block_type == _SOC_SABER2_MMU_SUBBLOCK_CI0)) {
        if (soc_feature(unit, soc_feature_ddr3)){
          soc_saber2_ci_block_get (unit, sub_block_type, &block);
        port = SOC_BLOCK_PORT(unit, block);
        } else {
          return SOC_E_NONE;
        }
    }
    
    leaf_enable_reg = sub_block_info->intr_mask_reg;
    leaf_status_reg = sub_block_info->lntr_status_reg;
    leaf_info = sub_block_info->info;

    /* process this sub block */
    SOC_IF_ERROR_RETURN
        (soc_saber2_process_sb_mmu_leaf_parity_error (unit, sub_block_type,
                         port, leaf_enable_reg, leaf_status_reg, leaf_info));

    return SOC_E_NONE;
}


STATIC
int soc_saber2_process_sb_two_level_mmu_parity_error(int unit,
                          _soc_saber2_mmu_sub_block_two_level_t * sub_block_info)
{
    uint32 en_rval;
    uint32 status_rval;
    soc_reg_t internal_status_reg;
    soc_reg_t internal_enable_reg;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_saber2_mmu_subblock_type_t sub_block_type;
    _soc_saber2_mmu_sub_block_internal_info_t * internal_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    /* get status register of level 1 sub block */
    internal_status_reg = sub_block_info->internal_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                       &status_rval));
    /* get mask register of level 1 sub block */
    internal_enable_reg = sub_block_info->internal_enable_reg;
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, internal_enable_reg, REG_PORT_ANY, 0, 
                                                               &en_rval));
        /* remove masked */
        status_rval &= (~en_rval);
    }
    
    if (status_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE; 
    }
    
    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        
        if(internal_info->intr_bit == 0) {
            break;
        }
        if (status_rval & internal_info->intr_bit){
        /* process this sub block */
        SOC_IF_ERROR_RETURN
            (soc_saber2_process_sb_mmu_leaf_parity_error (unit, 
            sub_block_type, port, internal_info->leaf_enable_reg,
            internal_info->leaf_status_reg, internal_info->info));
        
        /* clear the parity error bit */
        SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                  internal_info->intr_bit));
        }
    }
    return SOC_E_NONE;
}



STATIC int
soc_saber2_parity_process_mmu(int unit, soc_reg_t mmu_en_reg, 
                               soc_reg_t mmu_stat_reg, char *prefix_str)
{
    uint32 en_rval, stat_rval, mmu_bit;
    int index;
    uint32 sub_block_num = 0;
    _soc_saber2_mmu_sub_block_one_level_t * sub_block = NULL;
    _soc_saber2_mmu_sub_block_two_level_t * sub_block_2 = NULL;

    /* get MMU INTR and MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_stat_reg, REG_PORT_ANY, 0, &stat_rval));
    
    /* remove masked */
    stat_rval &= (~en_rval);
    if (stat_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE;
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_1);
        sub_block = &_soc_metrolite_mmu_sub_blocks_type_1[0];
    } else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_1);
        sub_block = &_soc_saber2_mmu_sub_blocks_type_1[0];
    }
    for (index = 0; index < sub_block_num; index++, sub_block++) {
        /* coverity[overrun-local:FALSE] */
        if(sub_block->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block->mmu_bit;
        
        if ((sub_block->mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }

        soc_saber2_process_sb_one_level_mmu_parity_error(unit, sub_block);

        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_2);
        sub_block_2 = &_soc_metrolite_mmu_sub_blocks_type_2[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_2);
        sub_block_2 = &_soc_saber2_mmu_sub_blocks_type_2[0];
    }
    for (index = 0; index < sub_block_num; index++, sub_block_2++) {
        /* coverity[overrun-local:FALSE] */
        if(sub_block_2->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block_2->mmu_bit;

        if ((mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }
        
        soc_saber2_process_sb_two_level_mmu_parity_error(unit, sub_block_2);
        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }
    
    return SOC_E_NONE;
}


STATIC int
soc_saber2_parity_ser_correction(int unit, const _soc_saber2_parity_info_t *info,
                                   char *prefix_str, char *mem_str_ptr,
                                   uint32 entry_idx, uint32 multiple,
                                   soc_block_t block_type)
{
    int rv = SOC_E_NONE;
    _soc_ser_correct_info_t spci = {0};
    
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s %s entry %d parity error\n"), prefix_str, 
                          mem_str_ptr, entry_idx));
    if (multiple) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s has multiple parity errors\n"),
                              prefix_str, mem_str_ptr));
    }
    if (info->mem != INVALIDm) {
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = info->mem;
        spci.blk_type = block_type;
        spci.index = entry_idx;
        rv = soc_ser_correction(unit, &spci);
    }
    
    return rv;
}


STATIC soc_error_t
soc_saber2_parity_process_parity(int unit, soc_port_t port,
                                   const _soc_saber2_parity_info_t *info,
                                   int schan, char *prefix_str, char *mem_str, 
                                   soc_block_t block_type, int block_idx)
{
    _soc_saber2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    int rv = SOC_E_NONE;

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return rv;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return rv;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_valid(unit, reg, PARITY_ERRf)) {
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
                if (soc_reg_field_valid(unit, reg, ADDRESSf)) {
                    entry_idx = soc_reg_field_get(unit, reg, rval, ADDRESSf);
                } else {
                    entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
                }
                /* Convert physical index to logical index */
                entry_idx = soc_saber2_mem_index_remap(unit, info->mem, entry_idx);

                soc_saber2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = soc_saber2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
                /* Clear parity status */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
            }
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_Af)) {
            /* For registers RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_INTR/NACK
               they have fileds PARITY_ERR_A and PARITY_ERR_B */
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERR_Af)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_Af);
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDX_Af);
                soc_saber2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = soc_saber2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERR_Bf)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_Bf);
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDX_Bf);
                soc_saber2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = soc_saber2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            if (has_error == TRUE) {    
                /* Clear parity status */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
            }
        } else {
            return rv;
        }
    }
                
    if (!has_error) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return rv;
} /*_soc_katana_parity_process_parity*/


STATIC soc_error_t
soc_saber2_parity_process_ecc(int unit, soc_port_t port,
                                const _soc_saber2_parity_info_t *info,
                                int schan, char *prefix_str, char *mem_str, 
                                soc_block_t block_type, int block_idx)
{
    int rv = SOC_E_NONE;
    _soc_saber2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple = 0;
    uint32 double_bit = 0;
    uint32 entry_idx = 0;
    uint32 idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return rv;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return rv;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, ECC_ERRf)) {
            has_error = TRUE;
            if (SOC_REG_FIELD_VALID(unit, reg, MULTIPLE_ERRf)) {
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            } else if (SOC_REG_FIELD_VALID(unit, reg, ECC_ERR_MULTIf)) {
                multiple = soc_reg_field_get(unit, reg, rval, ECC_ERR_MULTIf);
            }    
            if (SOC_REG_FIELD_VALID(unit, reg, DOUBLE_BIT_ERRf)) {
                double_bit = soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
            } else if (SOC_REG_FIELD_VALID(unit, reg, ECC_ERR_2Bf)) {
                double_bit = soc_reg_field_get(unit, reg, rval, ECC_ERR_2Bf);
            }    
            if (SOC_REG_FIELD_VALID(unit, reg, ENTRY_IDXf)) {
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            }
            if (double_bit) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d double-bit ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
                spci.double_bit = 1;
            } else if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple ECC errors\n"),
                           prefix_str, mem_str_ptr));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            }
            soc_saber2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                               entry_idx, minfo);
            if (info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem; 
                spci.blk_type = block_type;
                spci.index = entry_idx;
                spci.parity_type = SOC_PARITY_TYPE_ECC;
                rv = soc_ser_correction(unit, &spci);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }

    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return rv;
}


STATIC int
soc_saber2_parity_process_info(int unit, soc_port_t port,
                                 soc_reg_t group_reg,
                                 uint32 group_rval,
                                 const _soc_saber2_parity_info_t *info_list,
                                 char *prefix_str,
                                 soc_block_t block_type,
                                 int block_idx)
{
    const _soc_saber2_parity_info_t *info;
    int info_index;
    char *mem_str;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* This function is used for txlp/rxlp/xport parity error processing.
         * These blocks' memories all cannot be accessed by SW.In the parity_info
         * array, they are set as 'INVALIDm". If use SOC_MEM_IS_VALID() to check,
         * it will skip to clear all memories related interrupt status registers.
         */

        /* Check status for the info entry in the group register */
        if (!soc_reg_field_get(unit, group_reg, group_rval,
                               info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s asserted\n"), prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (soc_saber2_parity_process_parity(unit, port, info, FALSE,
                                                    prefix_str, mem_str, 
                                                    block_type, block_idx));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (soc_saber2_parity_process_ecc(unit, port, info, FALSE,
                                                 prefix_str, mem_str, 
                                                 block_type, block_idx));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}



STATIC int
soc_saber2_parity_process_err(int unit, uint32 route_block_index)
{
    const _soc_saber2_parity_route_block_t *route_block = NULL;
    int block_idx = 0;
    soc_port_t port;
    soc_reg_t route_block_en_reg, route_block_status_reg;
    uint32 route_block_rval;
    uint32 route_block_enable;
    char prefix_str[10];
    
    port = REG_PORT_ANY;

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        route_block = &_soc_metrolite_parity_intr_route_blocks[route_block_index];
    } else
#endif
    {
        route_block = &_soc_saber2_parity_intr_route_blocks[route_block_index];
    }

    /* get block and port for MXQ and RXLP and TXLP */
    if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
        (route_block->blocktype == SOC_BLK_TXLP) ||
        (route_block->blocktype == SOC_BLK_RXLP)) {
        SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                port = SOC_BLOCK_PORT(unit, block_idx);
                break;
            }
        }
    } else {
        SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                break;
            }
        }
    }

    /* Read per route block parity status register */
    route_block_status_reg = route_block->status_reg;
    route_block_en_reg = route_block->enable_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_status_reg, port, 0, 
                                      &route_block_rval));
    if (route_block_rval == 0) {
        return SOC_E_NONE;
    }
    if (route_block->blocktype == SOC_BLK_MMU) {
        SOC_IF_ERROR_RETURN
            (soc_saber2_parity_process_mmu(unit, route_block_en_reg, 
                                             route_block_status_reg, prefix_str));
    } else {
        SOC_IF_ERROR_RETURN
            (soc_saber2_parity_process_info(unit, port, route_block_status_reg,
                                              route_block_rval,
                                              route_block->info,
                                              prefix_str,
                                              route_block->blocktype,
                                              block_idx));

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg, port, 0, 
                                          &route_block_enable));
        route_block_enable &= ~route_block_rval;
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, 
                                          route_block_enable));
        route_block_enable |= route_block_rval;
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, 
                                          route_block_enable));
    }

    return SOC_E_NONE;
}
extern void
soc_kt2_oam_interrupt_process(int unit);

#define KT2_OAM_INTR_MASK 0xFF
#define KT2_RXLP_INTR_MASK 0x7FFF

#include <soc/shared/sat.h>
void soc_saber2_sat_interrupt_process(int unit)
{
    soc_sat_handler_t handler = NULL;

    soc_common_sat_handler_get(unit, &handler);

    if (handler != NULL) {
        (void)(handler(unit));
    }
}

STATIC int
soc_saber2_ser_process_all(int unit)
{
    uint8      rbi;
    uint32     block_num = 0;
    uint32     cmic_rval, cmic_bit, rval = 0, fval;
    const      _soc_saber2_parity_route_block_t *rb = NULL;
    char       prefix_str[10];
    soc_stat_t *stat = SOC_STAT(unit);
    bcm_port_t port = 0;
    soc_info_t *si = &SOC_INFO(unit);

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

    /* Read CMIC parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT3r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        rb  = &_soc_metrolite_parity_intr_route_blocks[0];
        block_num = COUNTOF(_soc_metrolite_parity_intr_route_blocks);
    } else
#endif
    {
        rb  = &_soc_saber2_parity_intr_route_blocks[0];
        block_num = COUNTOF(_soc_saber2_parity_intr_route_blocks);
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; rbi < block_num ; rbi++, rb++) {
        /* coverity[overrun-local:FALSE] */
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }
        if (rb->blocktype == SOC_BLK_IPIPE || rb->blocktype == SOC_BLK_EPIPE) {
            /* New fifo style processing */
            (void)soc_saber2_process_ser_fifo(unit, rb->blocktype, prefix_str);
            stat->ser_err_fifo++;
        } else {
            /* Legacy processing */
            soc_saber2_parity_process_err(unit, rbi);
            
            stat->ser_err_int++;
        }
    }
    

    /* Handle LINK-PHY interrupt */
    SOC_PBMP_ITER(si->linkphy_pbm, port) {
        if (SOC_REG_PORT_VALID(unit, RXLP_INTERRUPT_STATUSr, port)) {

            if (READ_RXLP_INTERRUPT_STATUSr(unit, port, &rval)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "unit %d: Error reading %s reg !!\n"),
                         unit, SOC_REG_NAME(unit, RXLP_INTERRUPT_STATUSr)));
                return SOC_E_INTERNAL;
            }
            if (rval & KT2_RXLP_INTR_MASK) {
                /* Call Linkphy interrupt handler */
                soc_kt2_rxlp_interrupt_process(unit, port, rval);
            }
        }
    }
    
    rval = 0;

     /* Handle OAM interrupt */
    if (READ_IP1_INTR_STATUS_1r(unit, &rval)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_STATUS_1r)));
        return SOC_E_INTERNAL;
    }
    if (rval & KT2_OAM_INTR_MASK) {
       /* Call OAM interrupt handler */
        soc_kt2_oam_interrupt_process(unit);
    }

    /* Handle SAT interrupt */
    if (cmic_rval & _SOC_SABER2_SAT_CMIC_BIT) {
        SOC_IF_ERROR_RETURN(READ_OAMP_INTERRUPT_REGISTERr(unit, &rval));
        fval = soc_reg_field_get(unit, OAMP_INTERRUPT_REGISTERr, rval,
                                 STAT_PENDING_EVENTf);
        if (fval) {
            soc_saber2_sat_interrupt_process(unit);
        }
    }

    return SOC_E_NONE;
}


soc_ser_test_functions_t ser_saber2_test_fun;

soc_error_t
soc_saber2_ser_error_injection_support (int unit, soc_mem_t mem, int pipe) 
{
    /* for check memory support "ser inject" or not */
    int i,j;
    int rv        = SOC_E_UNAVAIL;
    _soc_saber2_fifo_ser_info_t *fifo_parity;
    _soc_generic_ser_info_t *tcams = _soc_saber2_tcam_ser_info[unit];
    _soc_saber2_mmu_sub_block_leaf_info_t leaf_info;

    /* EP/IP */
    for (i = 0; _soc_saber2_fifo_ser_block_info[i].blocktype != 0; i++) {
        fifo_parity = _soc_saber2_fifo_ser_block_info[i].info;
        for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
            if (fifo_parity[j].mem != INVALIDm && fifo_parity[j].mem == mem) {
                return SOC_E_NONE;
            }
        }
    }

    for (i = 0; _soc_saber2_ip_parity_info[i].type != _SOC_PARITY_TYPE_NONE; i++) {
        if (_soc_saber2_ip_parity_info[i].mem == mem && 
            _soc_saber2_ip_parity_info[i].mem != INVALIDm) {           
            return SOC_E_NONE;
        }
    }
    
    for (i = 0; _soc_saber2_ep_parity_info[i].type != _SOC_PARITY_TYPE_NONE; i++) {
        if (_soc_saber2_ep_parity_info[i].mem == mem &&
            _soc_saber2_ep_parity_info[i].mem != INVALIDm) {           
            return SOC_E_NONE;
        }
    }

    /* MMU*/    
    rv = soc_saber2_found_mem_in_mmu(unit, mem, &leaf_info);
    if (rv == SOC_E_NONE) {        
        return SOC_E_NONE;
    }
    
    /* Now xport, xlport, rxlp, txlp tables are INVAILDm */
    
    /* tcam  */
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        if (tcams[i].mem == mem) {
            return SOC_E_NONE;
        }
    }
    
    return rv;
}

STATIC 
soc_field_t soc_saber2_set_test_field(soc_mem_t memory, soc_field_t field)
{
    soc_field_t test_field = field;

    switch(memory) {
    /* TCAM fields*/
    case CPU_COS_MAPm:
    case MY_STATION_TCAMm:
    case FP_UDF_TCAMm:
    case EFP_TCAMm:
    case VLAN_SUBNETm:
    case L2_USER_ENTRYm:        
    case VFP_TCAMm:
    case L3_TUNNELm:        
    case ING_SAT_SAMP_TCAMm: 
    case EGR_SAT_SAMP_TCAMm:  
    case SUBPORT_TAG_TO_PP_PORT_MAPm:        
        test_field = MASKf;        
        break;
    case FP_GLOBAL_MASK_TCAMm:
        test_field = FULL_MASKf;
        break;
    case FP_TCAMm:
        test_field = DATA_MASKf;
        break;
    case L3_DEFIPm:        
        test_field = RESERVED_2f;        
        break;
    default:
        break;
    }
    
    return test_field;
}

STATIC int
soc_saber2_parity_block_port(int unit, soc_block_t block, soc_port_t *port)
{
    *port = SOC_BLOCK_PORT(unit, block);
    if ((*port != REG_PORT_ANY) && !SOC_PORT_VALID(unit, *port)) {
        return SOC_E_PORT;
    }

    return SOC_E_NONE;
}

soc_error_t soc_saber2_ser_mmu_inject_error(int unit, 
                        uint32 flags, soc_mem_t mem,
                        int block, int index) 
{
    _soc_saber2_mmu_sub_block_leaf_info_t leaf_info = {0};
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_MEM_FIELD_WORDS];    
    ser_test_data_t test_data;

    if((SOC_MEM_INFO(unit, mem).flags & SOC_MEM_FLAG_CACHABLE) == 0) {        
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Uncached memory.\n")));
        return SOC_E_PARAM;
    }

    if (SOC_E_NONE != soc_saber2_found_mem_in_mmu(unit, mem, &leaf_info)) { 
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s is not support in Saber2.\n"),
                              SOC_MEM_NAME(unit,mem))); 
        
        return SOC_E_PARAM;
    }
    
    soc_ser_create_test_data(unit, tmp_entry, fieldData,
                             leaf_info.mem_parity_enable_reg,
                             SOC_INVALID_TCAM_PARITY_BIT,
                             leaf_info.mem_parity_enable_field,
                             mem, leaf_info.mem_parity_field, 
                             MEM_BLOCK_ANY,
                             REG_PORT_ANY, 
                             _SOC_ACC_TYPE_PIPE_ANY, index, 
                             &test_data);
    
    if (soc_mem_field_length(unit, mem,
        leaf_info.mem_parity_field) >= 2 ) {
        flags |= SOC_INJECT_ERROR_2BIT_ECC;
    }
    
    /*Read the memory for successful injection*/
    SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
    /*Disable parity*/
    SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
    /*Inject error*/
    SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
    /*Enable parity*/
    SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
    
    return SOC_E_NONE;
    
}

soc_error_t
soc_saber2_ser_inject_error (int unit, uint32 flags, soc_mem_t mem,
                          int pipe_target, int block, int index) 
{
    /* for  ser inject */    
     int group, table, i,j;
     _soc_saber2_parity_info_t *info = NULL;
     soc_mem_t memTable;
     soc_port_t block_port = 0;
     soc_block_t blk;
     ser_test_data_t test_data;
     soc_field_t field;
     uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_MEM_FIELD_WORDS];
     const _soc_saber2_parity_route_block_t *parity_intr_route_block = NULL;
     sal_memset(&test_data, 0, sizeof(test_data));

#ifdef BCM_METROLITE_SUPPORT
     if (SOC_IS_METROLITE(unit)) {
         parity_intr_route_block = &_soc_metrolite_parity_intr_route_blocks[0];
     } else
#endif
     {
         parity_intr_route_block = &_soc_saber2_parity_intr_route_blocks[0];
     }

    /* some mem/regs have been deleted in 56270 */
    if (!SOC_MEM_IS_VALID(unit,mem)) {
        return SOC_E_FAIL;
    }

     /* Check if memory needs to be skipped */
     if (NULL != ser_saber2_test_fun.injection_support) {
         SOC_IF_ERROR_RETURN(
             (ser_saber2_test_fun.injection_support)(unit, mem, pipe_target));
     }
        
     field = soc_saber2_set_test_field(mem, INVALIDf);
    
     /*TCAM ser inject*/
     if (_soc_saber2_tcam_ser_info[unit] != NULL) {
         for (i = 0; _soc_saber2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {
             if (_soc_saber2_tcam_ser_info[unit][i].mem == mem) {
                 soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                          SER_RANGE_ENABLEr, i, VALIDf, mem,
                                          field, MEM_BLOCK_ANY, REG_PORT_ANY,
                                          _SOC_ACC_TYPE_PIPE_ANY, index, &test_data);

                 /*Read the memory for successful injection*/
                 SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                 /*Disable parity*/
                 SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                 /*Inject error*/            
                 SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
                 /*Enable parity*/
                 SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                 return SOC_E_NONE;
             }
         }
     }

     
     /*IP/EP ser inject*/     
     for (i = 0; _soc_saber2_fifo_ser_block_info[i].blocktype != 0; i++) {
         for (j = 0; _soc_saber2_fifo_ser_block_info[i].info[j].enable_reg != INVALIDr; j++) {

             /* Some mem/regs have been removed or without ecc/parity fields in 56270. */
             if ((!soc_reg_field_valid(unit, 
                _soc_saber2_fifo_ser_block_info[i].info[j].enable_reg, 
                _soc_saber2_fifo_ser_block_info[i].info[j].enable_field)) ||
                (!soc_mem_field_valid(unit, mem,
                 _soc_saber2_fifo_ser_block_info[i].info[j].parity_field))) {
                 continue;
             }

             if (_soc_saber2_fifo_ser_block_info[i].info[j].mem == mem) {
                 soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                  _soc_saber2_fifo_ser_block_info[i].info[j].enable_reg,
                                  SOC_INVALID_TCAM_PARITY_BIT,
                                  _soc_saber2_fifo_ser_block_info[i].info[j].enable_field,
                                  mem,
                                  _soc_saber2_fifo_ser_block_info[i].info[j].parity_field, 
                                  block, REG_PORT_ANY, _SOC_ACC_TYPE_PIPE_ANY,
                                  index, &test_data);

                 if (soc_mem_field_length(unit, mem,
                     _soc_saber2_fifo_ser_block_info[i].info[j].parity_field) >= 2 ) {
                     flags |= SOC_INJECT_ERROR_2BIT_ECC;
                 }

                 /*Read the memory for successful injection*/
                 SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                 /*Disable parity*/
                 SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                 /*Inject error*/
                 SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
                 /*Enable parity*/
                 SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                 
                 return SOC_E_NONE;
             }
        }
    }

         
     /*H/W memory ser inject. */
     for (group = 0; parity_intr_route_block[group].cmic_bit; group++) {
         if(parity_intr_route_block[group].info == NULL) {
             continue;
         }
         info = parity_intr_route_block[group].info;

         if (parity_intr_route_block[group].blocktype == SOC_BLK_MMU) {
             continue;
         } else {
             SOC_BLOCK_ITER(unit, blk,parity_intr_route_block[group].blocktype) {
                 if (soc_saber2_parity_block_port(unit, blk, &block_port) < 0) {
                     continue;
                 }
                 for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                     memTable = info[table].mem;
                     if ((memTable == INVALIDm) || 
                        (!soc_reg_field_valid(unit, 
                        info[table].enable_reg,
                        info[table].enable_field))) {
                         continue;
                     }
                     if (memTable == mem) {
                         if((blk == block) || (block == MEM_BLOCK_ANY)) {
                             /*Inject error*/
                             soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                                      info[table].enable_reg,
                                                      SOC_INVALID_TCAM_PARITY_BIT,
                                                      info[table].enable_field,
                                                      mem, field, blk,
                                                      block_port, 
                                                      _SOC_ACC_TYPE_PIPE_ANY, index, 
                                                      &test_data);
                             /*Read the memory for successful injection*/
                             SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                             /*Disable parity*/
                             SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                             /*Inject error*/
                             SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
                             /*Enable parity*/
                             SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));

                             return SOC_E_NONE;
                        }
                    }
                } 
            } 
        } 
    }

    /* MMU */
    SOC_IF_ERROR_RETURN(soc_saber2_ser_mmu_inject_error(unit, flags, mem, block, index));

    return SOC_E_NONE;
}

soc_error_t soc_saber2_ser_mmu_test_mem(int unit, 
                            soc_mem_t mem, _soc_ser_test_t test_type,
                            int * pTestErrors) 
{
    int rv = SOC_E_NONE;
    _soc_saber2_mmu_sub_block_leaf_info_t leaf_info = {0};
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_MEM_FIELD_WORDS];    
    ser_test_data_t test_data;

    if((SOC_MEM_INFO(unit, mem).flags & SOC_MEM_FLAG_CACHABLE) == 0) {        
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Uncached memory.\n")));
        return SOC_E_PARAM;
    }

    soc_saber2_found_mem_in_mmu(unit, mem, &leaf_info);

    soc_ser_create_test_data(unit, tmp_entry, fieldData,
                             leaf_info.mem_parity_enable_reg,
                             SOC_INVALID_TCAM_PARITY_BIT,
                             leaf_info.mem_parity_enable_field,
                             mem, leaf_info.mem_parity_field, 
                             MEM_BLOCK_ANY,
                             REG_PORT_ANY, 
                             _SOC_ACC_TYPE_PIPE_ANY, 0, 
                             &test_data);
    
    rv = ser_test_mem(unit, 0, &test_data, test_type, 
                      pTestErrors);

    if (rv != SOC_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "Error during H/W test.  Aborting.\n")));
    }

    return rv;

}

int soc_saber2_ser_test_mem(int unit, soc_mem_t mem, 
                            _soc_ser_test_t test_type, int cmd) 
{
    int group, table, i, j, rv;
    _soc_saber2_parity_info_t *info;
    soc_mem_t memTable;
    soc_field_t field;
    soc_port_t block_port=0;
    soc_block_t blk;
    int testErrors = 0;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    const _soc_saber2_parity_route_block_t *parity_intr_route_block = NULL;

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        parity_intr_route_block = &_soc_metrolite_parity_intr_route_blocks[0];
    } else
#endif
    {
        parity_intr_route_block = &_soc_saber2_parity_intr_route_blocks[0];
    }

    /*Prevent compiler error for common function signature.*/
    (void) cmd;
    sal_memset(&test_data, 0, sizeof(test_data));

    field = soc_saber2_set_test_field(mem, INVALIDf);

    /*TCAM_test*/
    if (_soc_saber2_tcam_ser_info[unit] != NULL) {
        for (i = 0; _soc_saber2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {
            if (_soc_saber2_tcam_ser_info[unit][i].mem == mem) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         SER_RANGE_ENABLEr, i, INVALIDf, mem,
                                         VALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                         _SOC_ACC_TYPE_PIPE_ANY, 0, &test_data);
                rv = ser_test_mem(unit, 0, &test_data, test_type, &testErrors);

                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Error during TCAM test.  Aborting.\n")));
                    return rv;
                }
            }
        }
    }

     /*IP/EP mem test */     
     for (i = 0; _soc_saber2_fifo_ser_block_info[i].blocktype != 0; i++) {
         for (j = 0; _soc_saber2_fifo_ser_block_info[i].info->enable_reg != INVALIDr; j++) {
             if (_soc_saber2_fifo_ser_block_info[i].info->mem == mem) {
                 soc_ser_create_test_data(unit, tmp_entry, field_data,
                                          SER_RANGE_ENABLEr, i, VALIDf, mem,
                                          field, MEM_BLOCK_ANY, REG_PORT_ANY,
                                          _SOC_ACC_TYPE_PIPE_ANY, 0, &test_data);
                 rv = ser_test_mem(unit, 0, &test_data, test_type, &testErrors);
                             
                 if (rv != SOC_E_NONE) {
                     LOG_CLI((BSL_META_U(unit,
                                         "Error during TCAM test.  Aborting.\n")));
                     return rv;
                 }
             }
        }
    }

    
    
    /*H/W memory Test. MMU not include */
    for (group = 0; parity_intr_route_block[group].cmic_bit; group++) {
        info = parity_intr_route_block[group].info;

        if (parity_intr_route_block[group].blocktype == SOC_BLK_MMU) {

            rv = soc_saber2_ser_mmu_test_mem(unit, mem, test_type, &testErrors);           
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                                    "Error during MMU test.  Aborting.\n")));
                return rv;
            }
        } else {
            SOC_BLOCK_ITER(unit, blk,parity_intr_route_block[group].blocktype) {
                if (soc_saber2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }

                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    memTable = info[table].mem;
                    if (memTable == INVALIDm) {
                        continue;
                    }
                    if (memTable == mem) {
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 info[table].enable_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 info[table].enable_field,
                                                 mem, EVEN_PARITYf, blk,
                                                 block_port, 
                                                 _SOC_ACC_TYPE_PIPE_ANY, 0,
                                                 &test_data);
                        rv = ser_test_mem(unit, 0, &test_data, test_type, 
                                          &testErrors);
                        if (rv != SOC_E_NONE) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Error during H/W test.  Aborting.\n")));
                            return rv;
                        }
                    }
                }
            }
        }
    }
    if (testErrors == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test passed on unit: %d for memory %s\n "),
                 unit, SOC_MEM_NAME(unit,mem)));
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test failed on unit: %d for memory %s\n"),
                 unit, SOC_MEM_NAME(unit,mem)));
        return SOC_E_MEMORY;
    }
    return SOC_E_NONE;
}

int
soc_saber2_ser_tcam_test (int unit, _soc_ser_test_t test_type, int *pNumTCAMErr) 
{
    int i, rv;    
    int numTCAMtest   = 0;
    soc_field_t field;
    
    int numTotalTcam = (sizeof(_soc_saber2_tcam_ser_info_template) / 
                        sizeof(_soc_saber2_tcam_ser_info_template[0])) - 1;
    
    if (_soc_saber2_tcam_ser_info[unit] != NULL) {
        for (i = 0; _soc_saber2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {
            field = soc_saber2_set_test_field(_soc_saber2_tcam_ser_info[unit][i].mem, INVALIDf);
            LOG_CLI((BSL_META_U(unit,
                            "SER TCAM test begin: %s id:%d\n"),
                             SOC_MEM_NAME(unit, _soc_saber2_tcam_ser_info[unit][i].mem),
                             _soc_saber2_tcam_ser_info[unit][i].mem));
                    
            rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                                   _soc_saber2_tcam_ser_info[unit][i].mem, field, 
                                   test_type, MEM_BLOCK_ANY, REG_PORT_ANY, -1, 
                                   pNumTCAMErr);
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                        "Error during TCAM:%s SER test.\n\n"),
                        SOC_MEM_NAME(unit, _soc_saber2_tcam_ser_info[unit][i].mem)));
            }else {
            
                LOG_CLI((BSL_META_U(unit,
                        "TCAM:%s SER test passsed.\n\n"),
                        SOC_MEM_NAME(unit, _soc_saber2_tcam_ser_info[unit][i].mem)));
            }
            numTCAMtest ++;
        }
    }
    
    LOG_CLI((BSL_META_U(unit,
            "Total TCAM num:%d, failed num:%d \n\n"), 
            numTotalTcam, *pNumTCAMErr));

    return numTCAMtest;

}

int  
soc_saber2_ser_mmu_test(int unit, _soc_ser_test_t test_type, int *pTestErrors)
{
    int rv = 0; 
    int test_count = 0;
    uint32 sub_block_num = 0;
    soc_mem_t mem;
    int block_index, sub_block_index, node_index;     
    _soc_saber2_mmu_sub_block_one_level_t * sub_block = NULL;
    _soc_saber2_mmu_sub_block_two_level_t * sub_block_2 = NULL;
    _soc_saber2_mmu_sub_block_internal_info_t * sub_block_internal = NULL;
    _soc_saber2_mmu_sub_block_leaf_info_t  * leaf_info = NULL;
    void *null_entry = NULL;

    if(pTestErrors == NULL) {
        return 0;
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_1);
        sub_block = &_soc_metrolite_mmu_sub_blocks_type_1[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_1);
        sub_block = &_soc_saber2_mmu_sub_blocks_type_1[0];
    }
    for (block_index = 0; block_index < sub_block_num; block_index++, sub_block++) {
        /* coverity[overrun-local:FALSE] */
        leaf_info = sub_block->info;
        if ((leaf_info == NULL) || (sub_block->mmu_bit == 0)) {
            break;
        }
        for(node_index = 0; ; node_index ++) {
            if(leaf_info[node_index].intr_bit == 0) {
                break;
            }
            mem = leaf_info[node_index].mem;
            if(mem == INVALIDm) {
                continue;
            }
            if (!SOC_MEM_IS_VALID(unit, mem)) {
                LOG_CLI((BSL_META_U(unit,
                        "%s is not a valid memory for this platform. Skipping.\n"),
                         SOC_MEM_NAME(unit, mem)));
                continue;
            }
            /* now test 1 bit error */
            if(soc_mem_field_length(unit, mem, leaf_info[node_index].mem_parity_field) > 1) {
                continue;
            }
             
            if (SOC_MEM_SER_CORRECTION_TYPE(unit, mem)) {                
                LOG_CLI((BSL_META_U(unit,
                        "\nMMU SER test begin: %s id:%d mem flag:0x%x field:%s\n"),
                         SOC_MEM_NAME(unit, mem), mem, 
                         SOC_MEM_SER_CORRECTION_TYPE(unit, mem),
                         SOC_FIELD_NAME(unit, leaf_info[node_index].mem_parity_field)));
                
                null_entry = soc_mem_entry_null(unit, mem);
                rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, 0, null_entry);
                
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "mem:%s id:%d clear entry failed.\n"),
                                        SOC_MEM_NAME(unit, mem), mem));
                }
                
                rv = ser_test_mem_pipe(unit, 
                                       leaf_info[node_index].mem_parity_enable_reg,
                                       SOC_INVALID_TCAM_PARITY_BIT,
                                       leaf_info[node_index].mem_parity_enable_field,
                                       mem, 
                                       leaf_info[node_index].mem_parity_field, 
                                       test_type,
                                       MEM_BLOCK_ANY, 0, 
                                       _SOC_ACC_TYPE_PIPE_ANY,
                                       pTestErrors);
                
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                            "Error during MMU:%s SER test.\n"),
                            SOC_MEM_NAME(unit, mem)));
                } else {
                    LOG_CLI((BSL_META_U(unit,
                            "MMU SER test passed: %s id:%d\n\n"),
                             SOC_MEM_NAME(unit, mem), mem));
                }
                
                test_count ++;
            }
        }                     
    }

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_2);
        sub_block_2 = &_soc_metrolite_mmu_sub_blocks_type_2[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_2);
        sub_block_2 = &_soc_saber2_mmu_sub_blocks_type_2[0];
    }
    for (block_index = 0; block_index < sub_block_num; block_index++, sub_block_2++) {
        /* coverity[overrun-local:FALSE] */
        sub_block_internal = sub_block_2->info;
        if ((sub_block_internal == NULL) || (sub_block_2->mmu_bit == 0)) {
            break;
        }
        for(sub_block_index = 0; ; sub_block_index ++) {
            if(sub_block_internal[sub_block_index].intr_bit == 0)  {
                break;
            }
            leaf_info = sub_block_internal[sub_block_index].info;
            for(node_index = 0; ; node_index ++) {
                if(leaf_info[node_index].intr_bit == 0) {
                    break;
                }
                mem = leaf_info[node_index].mem;
                if(mem == INVALIDm) {
                    continue;
                }

                if (!SOC_MEM_IS_VALID(unit, mem)) {
                    LOG_CLI((BSL_META_U(unit,
                            "%s is not a valid memory for this platform. Skipping.\n"),
                             SOC_MEM_NAME(unit, mem)));
                    continue;
                }
                /* now test 1 bit error */
                if(soc_mem_field_length(unit, mem, leaf_info[node_index].mem_parity_field) > 1) {
                    continue;
                }
                 
                if (SOC_MEM_SER_CORRECTION_TYPE(unit, mem)) {   
                    LOG_CLI((BSL_META_U(unit,
                            "\nMMU SER test begin: %s id:%d flag:0x%x\n"),
                             SOC_MEM_NAME(unit, mem), mem, 
                             SOC_MEM_INFO(unit, mem).flags & _SOC_SABER2_SER_FLAG_MASK));
                    
                    null_entry = soc_mem_entry_null(unit, mem);
                    rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, 0, null_entry);
                    
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                            "mem:%s id:%d clear entry failed.\n"),
                                            SOC_MEM_NAME(unit, mem), mem));
                    }
                    
                    rv = ser_test_mem_pipe(unit, 
                                           leaf_info[node_index].mem_parity_enable_reg,
                                           SOC_INVALID_TCAM_PARITY_BIT,
                                           leaf_info[node_index].mem_parity_enable_field,
                                           mem, INVALIDf, test_type,
                                           MEM_BLOCK_ANY, 0, 
                                           _SOC_ACC_TYPE_PIPE_ANY,
                                           pTestErrors);
                    
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                "Error during MMU:%s SER test.\n"),
                                SOC_MEM_NAME(unit, mem)));
                    } else {
                        LOG_CLI((BSL_META_U(unit,
                                "MMU SER test passed: %s id:%d\n\n"),
                                 SOC_MEM_NAME(unit, mem), mem));
                    }
                    
                    test_count ++;
                }
            }
        }                     
    }

    LOG_CLI((BSL_META_U(unit,
            "MMU SER memories tested:%u failed:%u.\n\n"), test_count, *pTestErrors));

    
    return test_count;
}


int
soc_saber2_ser_hw_test(int unit, _soc_ser_test_t test_type, int *pTestErrors)
{
    int group, i, j, rv, table = 0;
    _soc_saber2_parity_info_t *info = NULL;
    _soc_saber2_fifo_ser_info_t *fifo_info = NULL;
    soc_mem_t mem = INVALIDm;
    soc_port_t block_port = 0;
    soc_block_t blk;
    uint32 test_count = 0;    
    void *null_entry = NULL;
    const _soc_saber2_parity_route_block_t *parity_intr_route_block = NULL;

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        parity_intr_route_block = &_soc_metrolite_parity_intr_route_blocks[0];
    } else
#endif
    {
        parity_intr_route_block = &_soc_saber2_parity_intr_route_blocks[0];
    }

    /* loop through each group.  not fifo mode */
    for (group = 0; parity_intr_route_block[group].cmic_bit; group++) {
        info = parity_intr_route_block[group].info;
        if(NULL == info) {
            continue;
        }

        if ((parity_intr_route_block[group].blocktype == SOC_BLK_MXQPORT) ||
            (parity_intr_route_block[group].blocktype == SOC_BLK_XLPORT) ||
            (parity_intr_route_block[group].blocktype == SOC_BLK_TXLP) ||
            (parity_intr_route_block[group].blocktype == SOC_BLK_RXLP))
        {
            continue;
        } 
        
        if (parity_intr_route_block[group].blocktype == SOC_BLK_MMU) {
            continue;
        } 
        
        SOC_BLOCK_ITER(unit, blk, parity_intr_route_block[group].blocktype) {
            if (soc_saber2_parity_block_port(unit, blk, &block_port) < 0) {
                continue;
            }
            
            for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                mem = info[table].mem;
                if (mem == INVALIDm) {
                    continue;
                }
                    
                if ((info[table].enable_reg == INVALIDr) ||
                    !soc_reg_field_valid(unit, info[table].enable_reg,
                                         info[table].enable_field)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s has no parity toggle.\n"),
                               unit, SOC_MEM_NAME(unit, mem)));
                    continue;
                }

                test_count++;
                LOG_CLI((BSL_META_U(unit,
                                    "SER HW test begin: %s id:%d\n"),
                         SOC_MEM_NAME(unit, mem), mem));

                null_entry = soc_mem_entry_null(unit, mem);
                rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, 0, null_entry);
               
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                       "mem:%s id:%d clear entry failed.\n"),
                                       SOC_MEM_NAME(unit, mem), mem));
                }
               
                rv = ser_test_mem_pipe(unit, info[table].enable_reg, -1,
                                       info[table].enable_field,
                                       mem, INVALIDf, test_type,
                                       MEM_BLOCK_ANY, REG_PORT_ANY, 
                                       _SOC_ACC_TYPE_PIPE_ANY,
                                       pTestErrors);

                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "%s Error during H/W SER test.\n\n"),
                                        SOC_MEM_NAME(unit, mem)));
                } else {
                    LOG_CLI((BSL_META_U(unit,
                                        "%s SER test passed.\n\n"),
                                        SOC_MEM_NAME(unit, mem)));
                }
                
            }
        }
    }
    block_port = 0;

    /* IP/EP in fifo mode */    
    for (i = 0; _soc_saber2_fifo_ser_block_info[i].blocktype; i++) {
        fifo_info = _soc_saber2_fifo_ser_block_info[i].info;

        for (j = 0; fifo_info[j].enable_reg != INVALIDr;j++) {

            if(_soc_saber2_mem_reg_skip(fifo_info[j].type, fifo_info[j].mem, fifo_info[j].reg)) {
               continue ;
            }
            
            if ((fifo_info[j].mem != INVALIDm) && 
                (SOC_MEM_SER_CORRECTION_TYPE(unit, fifo_info[j].mem))) {                
                mem = fifo_info[j].mem;
                
                /* Some mem/regs have been removed or without ecc/parity fields in 56270. */
                if (!soc_reg_field_valid(unit, fifo_info[j].enable_reg, fifo_info[j].enable_field)
                    || (!soc_mem_field_valid(unit, mem, fifo_info[j].parity_field))) {
                    continue;
                }
                
                LOG_CLI((BSL_META_U(unit,
                        "mem:%s id:%d SER test begin, mem type 0x:%x field:%s\n"),
                        SOC_MEM_NAME(unit, mem), mem,
                        SOC_MEM_SER_CORRECTION_TYPE(unit, mem),
                        SOC_FIELD_NAME(unit, fifo_info[j].parity_field)));
                
                null_entry = soc_mem_entry_null(unit, mem);
                rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, 0, null_entry);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "mem:%s id:%d clear entry failed.\n"),
                                        SOC_MEM_NAME(unit, mem), mem));
                }
                
                rv = ser_test_mem_pipe(unit, fifo_info[j].enable_reg, -1,
                                       fifo_info[j].enable_field,
                                       mem, 
                                       fifo_info[j].parity_field, 
                                       test_type,
                                       MEM_BLOCK_ANY, REG_PORT_ANY, 
                                       _SOC_ACC_TYPE_PIPE_ANY,
                                       pTestErrors);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "mem:%s id:%d Error during IP/EP SER test.\n\n"),
                                        SOC_MEM_NAME(unit, mem), mem));
                }
                else {                    
                    LOG_CLI((BSL_META_U(unit,
                                    "mem:%s id:%d SER test passed.\n\n"),
                                    SOC_MEM_NAME(unit, mem), mem));
                }
                    
                test_count++;
            }
        }        
    }

    
    LOG_CLI((BSL_META_U(unit,
            "Hardware SER memories tested:%u failed:%u.\n\n"), test_count, *pTestErrors));

    return test_count;
}



soc_error_t
soc_saber2_ser_test (int unit, _soc_ser_test_t test_type) 
{
    /* For TR 144*/    
    int numTCAMErr = 0 , numHWErr = 0, numMMUErr   = 0;
    int numTotalErr   = 0;
    int numTotalTest   = 0;

    /* tcam */
    numTotalTest += soc_saber2_ser_tcam_test(unit, test_type, &numTCAMErr);

    /* HW */    
    numTotalTest += soc_saber2_ser_hw_test(unit, test_type, &numHWErr);

    /* MMU test*/
    numTotalTest += soc_saber2_ser_mmu_test(unit, test_type, &numMMUErr);

    numTotalErr = numTCAMErr + numHWErr + numMMUErr;
    
    LOG_CLI((BSL_META_U(unit,
            "\nSER test:%d failed:%d passed:%d\n"),
             numTotalTest, numTotalErr, numTotalTest - numTotalErr));

    
    return SOC_E_NONE;
}

void soc_saber2_ser_test_function_register(int unit)
{
    /*Initialize chip-specific functions for SER testing*/
    memset(&ser_saber2_test_fun, 0, sizeof(soc_ser_test_functions_t));
    ser_saber2_test_fun.inject_error_f = &soc_saber2_ser_inject_error;
    ser_saber2_test_fun.test_mem = &soc_saber2_ser_test_mem;
    ser_saber2_test_fun.test = &soc_saber2_ser_test;
    ser_saber2_test_fun.parity_control = &_ser_test_parity_control_reg_set;  /* tcam */
    ser_saber2_test_fun.injection_support = &soc_saber2_ser_error_injection_support;

    soc_ser_test_functions_register(unit, &ser_saber2_test_fun);
}

static soc_ser_functions_t ser_saber2_functions;
static soc_oam_event_functions_t ser_sb2_oam_event_funs;

void
soc_saber2_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_saber2_tcam_ser_info[unit],
                                       _SOC_PARITY_TYPE_SER);
    return;
}


STATIC soc_error_t
soc_saber2_mem_nack_process_info(int unit, int reg_mem,
                                   _soc_saber2_ser_nack_reg_mem_t nack_reg_mem,
                                   const _soc_saber2_parity_info_t *info_list,
                                   char *prefix_str, soc_block_t block_type, 
                                   int block_idx)
{
    const _soc_saber2_parity_info_t *info;
    int info_index;
    char *mem_str;
    soc_port_t port = REG_PORT_ANY;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (reg_mem == _SOC_SABER2_SER_MEM && info->mem != nack_reg_mem.mem) {
            continue;
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        } else {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
            SOC_IF_ERROR_RETURN
                (soc_saber2_parity_process_parity(unit, port, info, TRUE,
                                                    prefix_str, mem_str, block_type,
                                                    block_idx));
            break;
        case _SOC_PARITY_TYPE_ECC:
            SOC_IF_ERROR_RETURN
                (soc_saber2_parity_process_ecc(unit, port, info, TRUE,
                                                 prefix_str, mem_str, block_type,
                                                 block_idx));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC soc_error_t
soc_saber2_found_mem_in_mmu(int unit, soc_mem_t mem,
                            _soc_saber2_mmu_sub_block_leaf_info_t  * mmu_leaf_info)
{
    int rv = SOC_E_UNAVAIL;    
    uint32 sub_block_num = 0;
    int block_index, sub_block_index, node_index;     
    _soc_saber2_mmu_sub_block_one_level_t * sub_block = NULL;
    _soc_saber2_mmu_sub_block_two_level_t * sub_block_2 = NULL;
    _soc_saber2_mmu_sub_block_internal_info_t * sub_block_internal = NULL;
    _soc_saber2_mmu_sub_block_leaf_info_t  * leaf_info = NULL;

    if(mmu_leaf_info == NULL) {
        return SOC_E_PARAM;
    }

#ifdef BCM_METROLITE_SUPPORT
    /* Exclude the last one */
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_1) - 1;
        sub_block = &_soc_metrolite_mmu_sub_blocks_type_1[0];
    }else
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_1) - 1;
        sub_block = &_soc_saber2_mmu_sub_blocks_type_1[0];
    }
    for (block_index = 0; block_index < sub_block_num; block_index++, sub_block++) {
        leaf_info = sub_block->info;
        if(leaf_info == NULL) {
            break;
        }
        for(node_index = 0; ; node_index ++) {
            if(leaf_info[node_index].intr_bit == 0) {
                break;
            }
            if(leaf_info[node_index].mem == mem) {
                *mmu_leaf_info = leaf_info[node_index];
                return SOC_E_NONE;
            }
        }                     
    }

#ifdef BCM_METROLITE_SUPPORT
    /* Exclude the last one */
    if (SOC_IS_METROLITE(unit)) {
        sub_block_num = COUNTOF(_soc_metrolite_mmu_sub_blocks_type_2) - 1;
        sub_block_2 = &_soc_metrolite_mmu_sub_blocks_type_2[0];
    }else 
#endif
    {
        sub_block_num = COUNTOF(_soc_saber2_mmu_sub_blocks_type_2) - 1;
        sub_block_2 = &_soc_saber2_mmu_sub_blocks_type_2[0];
    }
    for (block_index = 0; block_index < sub_block_num; block_index++, sub_block_2++) {
        sub_block_internal = sub_block_2->info;
        if(sub_block_internal == NULL) {
            break;
        }
        for(sub_block_index = 0; ; sub_block_index ++) {
            if(sub_block_internal[sub_block_index].intr_bit == 0)  {
                break;
            }
            leaf_info = sub_block_internal[sub_block_index].info;
            if(leaf_info == NULL) {
                break;
            }
            for(node_index = 0; ; node_index ++) {
                if(leaf_info[node_index].intr_bit == 0) {
                    break;
                }
                if(leaf_info[node_index].mem == mem) {          
                    *mmu_leaf_info = leaf_info[node_index];                    
                    return SOC_E_NONE;
                }                    
            }
        }                     
    }
    
    return rv;
}



STATIC int
soc_saber2_mem_nack_error_process(int unit, 
                                   _soc_saber2_ser_nack_reg_mem_t nack_reg_mem,  
                                   int reg_mem, uint32 address)
{
    const _soc_saber2_parity_route_block_t *route_block = NULL;
    int route_block_index, block_idx, block_num = 0;
    uint32 cmic_bit;
    char prefix_str[10];

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        route_block  = &_soc_metrolite_parity_intr_route_blocks[0];
        block_num    = COUNTOF(_soc_metrolite_parity_intr_route_blocks);
    } else
#endif
    {
        route_block  = &_soc_saber2_parity_intr_route_blocks[0];
        block_num    = COUNTOF(_soc_saber2_parity_intr_route_blocks);
    }

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; route_block_index < block_num;
            route_block_index++, route_block++) {
        /* coverity[overrun-local:FALSE] */
        cmic_bit = route_block->cmic_bit;

        if(route_block->info == NULL) {
            continue;
        }

        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
       
        SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                break;
            }
        }

        /* IP/EP none-fifo mem */
        if ((route_block->blocktype == SOC_BLK_IPIPE) || 
            (route_block->blocktype == SOC_BLK_EPIPE)) {            
            SOC_IF_ERROR_RETURN
            (soc_saber2_mem_nack_process_info(unit, 
                                            reg_mem, nack_reg_mem,
                                            route_block->info,
                                            prefix_str, route_block->blocktype,
                                            block_idx));
        }
        
    } /* Loop through each place-and-route block entry */

    return SOC_E_NONE;
}


void
soc_saber2_mem_nack(void *unit_vp, void *addr_vp, void *blk_vp, 
                     void *d3, void *d4)
{
    soc_mem_t mem = INVALIDm;
    int reg_mem = PTR_TO_INT(d3);
    int rv, unit = PTR_TO_INT(unit_vp);
    uint32 address = PTR_TO_INT(addr_vp);
    uint32 block = PTR_TO_INT(blk_vp);
    soc_regaddrinfo_t ainfo;
    _soc_saber2_ser_nack_reg_mem_t nack_reg_mem = { 0 };

    if (reg_mem == _SOC_SABER2_SER_REG) {
        if (address) {
            soc_regaddrinfo_get(unit, &ainfo, address);
            nack_reg_mem.reg = ainfo.reg;
        }
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d REG SCHAN NACK analysis address 0x:%x\n"),
                               unit, address));        
    } else {
        mem = soc_addr_to_mem_extended(unit, block, 0, address);
        if (mem == INVALIDm) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d mem decode failed, "
                                  "SCHAN NACK analysis failure address 0x:%x\n"), 
                                  unit, address));
            return;
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                      "unit %d mem:%s decode address 0x:%x\n"), 
                      unit,SOC_MEM_NAME(unit, mem), address));
        }        
        
        nack_reg_mem.mem = mem;
    }

    if ((rv = soc_saber2_mem_nack_error_process(unit, nack_reg_mem,
        reg_mem, address)) < 0) {
        if (reg_mem == _SOC_SABER2_SER_REG) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d REG SCHAN NACK analysis failure\n"),
                                   unit));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d mem:%s SCHAN NACK analysis failure\n"),
                                   unit, SOC_MEM_NAME(unit, mem)));
        }
    }
    
}

STATIC void
soc_saber2_ser_error(void *unit_vp, void *d1, void *d2, void *d3,
                       void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)soc_saber2_ser_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr3_enable(unit, PTR_TO_INT(d2));
    }

}

STATIC void
soc_saber2_oam_event_process(void *unit_vp, void *d1, 
                                    void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32   rval = 0;

     /* Handle OAM interrupt */
    if (READ_IP1_INTR_STATUS_1r(unit, &rval) == SOC_E_NONE) {
        if (rval & KT2_OAM_INTR_MASK) {
           /* Call OAM interrupt handler */
           soc_kt2_oam_interrupt_process(unit);
        }
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_STATUS_1r)));
    }
    
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr3_enable(unit, PTR_TO_INT(d2));
    }

}

void soc_saber2_ser_function_register(int unit)
{
    memset(&ser_saber2_functions, 0, sizeof(soc_ser_functions_t));
    /*_soc_ser_stat_nack_f is used for counter err statistics . */
    ser_saber2_functions._soc_ser_stat_nack_f = NULL;
    /* _soc_ser_fail_f  is used to TCAM ser process*/
    ser_saber2_functions._soc_ser_fail_f = &soc_saber2_ser_fail;
    /* schan nack process */
    ser_saber2_functions._soc_ser_mem_nack_f = &soc_saber2_mem_nack;
    ser_saber2_functions._soc_ser_parity_error_cmicm_intr_f = 
        &soc_saber2_ser_error;
   
    soc_ser_function_register(unit, &ser_saber2_functions);

}

void soc_saber2_oam_event_function_register(int unit)
{
    memset(&ser_sb2_oam_event_funs, 0, sizeof(soc_oam_event_functions_t));
    ser_sb2_oam_event_funs._soc_oam_event_intr_f =
                            &soc_saber2_oam_event_process;
    soc_oam_event_function_register(unit, &ser_sb2_oam_event_funs);

}

int soc_saber2_ser_init(int unit,int enable)
{       
    soc_ser_log_init(unit, NULL, 0); 

    if (!enable) {
        soc_saber2_oam_event_function_register (unit);
    }
    /* include all init process  */
    SOC_IF_ERROR_RETURN(soc_saber2_ser_enable_all(unit, enable ? TRUE : FALSE));

    if(TRUE == enable) {
        soc_saber2_ser_function_register(unit);

        /* tcam */
        SOC_IF_ERROR_RETURN(soc_saber2_ser_engine_init(unit));


#if defined(SER_TR_TEST_SUPPORT)
        soc_saber2_ser_test_function_register(unit);
#endif
    }
    
#ifdef INCLUDE_MEM_SCAN
    soc_mem_scan_ser_list_register(unit, enable ? TRUE : FALSE,
                           _soc_saber2_tcam_ser_info[unit]);
#endif
    
    return SOC_E_NONE;

}

soc_error_t
soc_saber2_mem_parity_control(int unit, soc_mem_t mem, int copyno, int enable)
{
    int i,j;
    int rv        = SOC_E_UNAVAIL;
    _soc_saber2_fifo_ser_info_t *fifo_parity;
    _soc_saber2_mmu_sub_block_leaf_info_t leaf_info;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, FALSE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }

    /* EP/IP */
    for (i = 0; _soc_saber2_fifo_ser_block_info[i].blocktype != 0; i++) {
        fifo_parity = _soc_saber2_fifo_ser_block_info[i].info;
        for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
            if (fifo_parity[j].mem != INVALIDm && fifo_parity[j].mem == mem) {                
                SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                        fifo_parity[j].enable_reg, REG_PORT_ANY, 
                        fifo_parity[j].enable_field, enable ? 1 : 0)); 

                return SOC_E_NONE;
            }
        }
    }

    for (i = 0; _soc_saber2_ip_parity_info[i].type != _SOC_PARITY_TYPE_NONE; i++) {
        if (_soc_saber2_ip_parity_info[i].mem == mem && 
            _soc_saber2_ip_parity_info[i].mem != INVALIDm) {   
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    _soc_saber2_ip_parity_info[i].enable_reg, REG_PORT_ANY, 
                    _soc_saber2_ip_parity_info[i].enable_field, enable ? 1 : 0)); 

            return SOC_E_NONE;
        }
    }
    
    for (i = 0; _soc_saber2_ep_parity_info[i].type != _SOC_PARITY_TYPE_NONE; i++) {
        if (_soc_saber2_ep_parity_info[i].mem == mem &&
            _soc_saber2_ep_parity_info[i].mem != INVALIDm) {           
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    _soc_saber2_ep_parity_info[i].enable_reg, REG_PORT_ANY, 
                    _soc_saber2_ep_parity_info[i].enable_field, enable ? 1 : 0)); 

            return SOC_E_NONE;
        }
    }

    /* MMU*/    
    rv = soc_saber2_found_mem_in_mmu(unit, mem, &leaf_info);
    if (rv == SOC_E_NONE) {  
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                leaf_info.mem_parity_enable_reg, REG_PORT_ANY, 
                leaf_info.mem_parity_enable_field, enable ? 1 : 0)); 
        
        return SOC_E_NONE;
    }
       
    return rv;

}

soc_error_t
soc_saber2_ser_mem_clear(int unit, soc_mem_t mem)
{
    uint32  range_enable;
    int info_ix, i;
    _soc_generic_ser_info_t *cur_spi;
    ser_memory_entry_t ser_mem;
    
    /* Check if enable */
    SOC_IF_ERROR_RETURN
        (READ_SER_RANGE_ENABLEr(unit, &range_enable));

    if (!range_enable) {
        return SOC_E_NONE;
    }

    info_ix = 0;

    while (_soc_saber2_tcam_ser_info[unit][info_ix].mem != INVALIDm) {
        if (_soc_saber2_tcam_ser_info[unit][info_ix].mem == mem) {
            break;
        }
        info_ix++;
    }

    if ((_soc_saber2_tcam_ser_info[unit][info_ix].mem != INVALIDm) &&
        (range_enable & (1 << info_ix))) {
        cur_spi = &(_soc_saber2_tcam_ser_info[unit][info_ix]);

        range_enable &= ~(1 << info_ix);
        /* Disable SER protection on this memory */
        SOC_IF_ERROR_RETURN
            (WRITE_SER_RANGE_ENABLEr(unit, range_enable));
        

        /* Flush SER memory segment for the table */
        sal_memset(&ser_mem, 0, sizeof(ser_mem));
        for (i = cur_spi->ser_section_start;
             i <= cur_spi->ser_section_end;
             i++) {
            SOC_IF_ERROR_RETURN
                    (WRITE_SER_MEMORYm(unit, MEM_BLOCK_ALL, i, &ser_mem));
        }

        range_enable |= (1 << info_ix);
        /* Enable SER protection on this memory */
        SOC_IF_ERROR_RETURN
            (WRITE_SER_RANGE_ENABLEr(unit, range_enable));

        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "\t%s: SER[%d-%d]\n"),
                     SOC_MEM_NAME(unit, cur_spi->mem),
                     cur_spi->ser_section_start, cur_spi->ser_section_end));
    }

    return SOC_E_NONE;
    
}


#endif /* BCM_SABER_SUPPORT */
