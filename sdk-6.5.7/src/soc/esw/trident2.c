/*
 * $Id: trident2.c,v 1.298 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * File:        trident2.c
 * Purpose:
 * Requires:
 */
#include <shared/bsl.h>
#include <sal/core/boot.h>
#include <soc/trident2.h>
#include <soc/bradley.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/mspi.h>
#include <soc/l2x.h>
#include <soc/soc_ser_log.h>
#include <soc/tdm/core/tdm_top.h>

#ifdef BCM_TRIDENT2_SUPPORT

#include <soc/td2_td2p.h>
#include <soc/scache.h>

#ifdef ALPM_ENABLE
#include <soc/lpm.h>
#include <soc/alpm.h>
#include <soc/esw/alpm_int.h>
#endif /* ALPM_ENABLE */

#include <soc/mmu_config.h>
#include <soc/trident2.h>
#include <soc/post.h>

#define TDM_CHIP_EXEC__IARB_TD2 11
#define TDM_CHIP_EXEC__IARB_TD2P 12
#include <soc/esw/portctrl.h>

#ifdef PORTMOD_SUPPORT
#include <soc/portmod/portmod.h>
#endif /* PORTMOD_SUPPORT */

#define TRIDENT2_PHY_PORT_MAX 128

/* Globally stored reserved buffer values
 * for egress rsvd & asf rsvd */
static int asf_rsvd_g = 0;
static int egr_rsvd_g = 0;

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_CPORT,
    _SOC_PARITY_TYPE_MMU_SER,
    _SOC_PARITY_TYPE_START_ERR,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_TYPE_BST
} _soc_td2_ser_info_type_t;

typedef struct _soc_td2_fifo_ser_info_s {
    soc_reg_t   enable_reg;
    soc_field_t enable_field;
    uint8       type; /* 0: mem, 1: reg, 2: bus ,3 : internal buffer */
    soc_mem_t   mem;
    soc_reg_t   reg;
    char        *name_str; /* Used when mem == INVALIDm or reg == INVALIDr or type == bus
                              (either not accessible or multiple) */
} _soc_td2_fifo_ser_info_t;

typedef struct _soc_td2_ser_block_info_s {
    soc_block_t              blocktype;
    soc_reg_t                fifo_reset_reg;
    _soc_td2_fifo_ser_info_t *info;
} _soc_td2_ser_block_info_t;

typedef struct _soc_td2_ser_reg_s {
    soc_reg_t reg;
    char      *mem_str;
} _soc_td2_ser_reg_t;

typedef struct _soc_td2_ser_info_s {
    _soc_td2_ser_info_type_t   type;
    struct _soc_td2_ser_info_s *info;
    int                        id;
    soc_field_t                group_reg_enable_field;
    soc_field_t                group_reg_status_field;
    soc_mem_t                  mem;
    char                       *mem_str;
    soc_reg_t                  enable_reg;
    soc_field_t                enable_field;
    soc_reg_t                  intr_status_reg;
    _soc_td2_ser_reg_t         *intr_status_reg_list;
} _soc_td2_ser_info_t;

typedef struct _soc_td2_ser_route_block_s {
    uint32              cmic_bit;
    soc_block_t         blocktype;
    int                 pipe;
    soc_reg_t           enable_reg;
    soc_reg_t           status_reg;
    soc_field_t         enable_field;
    _soc_td2_ser_info_t *info;
    uint8               id;
} _soc_td2_ser_route_block_t;

typedef struct _soc_td2_mmu_traffic_ctrl_s {
    uint8   thdo_drop_bmp[_SOC_TD2_MAX_PORT];
} _soc_td2_mmu_traffic_ctrl_t;


#define   MAC_ENABLE_SET_CTRL          (1 << 0)
#define   MMU_TRAFFIC_EN_CTRL          (1 << 1)
#define   COSQ_SCHED_SET_CTRL          (1 << 2) 
static    _soc_td2_mmu_traffic_ctrl_t
              *_soc_td2_mmu_traffic_ctrl[SOC_MAX_NUM_DEVICES];
static    sal_mutex_t _fwd_ctrl_lock[SOC_MAX_NUM_DEVICES];
#define   FWD_CTRL_LOCK(unit) \
          sal_mutex_take(_fwd_ctrl_lock[unit], sal_mutex_FOREVER)
#define   FWD_CTRL_UNLOCK(unit) \
          sal_mutex_give(_fwd_ctrl_lock[unit])

/* Forward declarations */
extern int
tdm_td2_set_iarb_tdm_table(int core_bw, int is_x_ovs, int is_y_ovs, int mgm4x1,
int mgm4x2p5, int mgm1x10, int *iarb_tdm_wrap_ptr_x, int *iarb_tdm_wrap_ptr_y,
int *iarb_tdm_tbl_x, int *iarb_tdm_tbl_y);

enum tdm_td2_port_speed {TDM_TD2_SPEED_0=0, TDM_TD2_SPEED_10M=10, TDM_TD2_SPEED_20M=20,
TDM_TD2_SPEED_25M=25, TDM_TD2_SPEED_33M=33, TDM_TD2_SPEED_40M=40, TDM_TD2_SPEED_50M=50,
TDM_TD2_SPEED_100M=100, TDM_TD2_SPEED_100M_FX=101, TDM_TD2_SPEED_120M=120,TDM_TD2_SPEED_400M=400,
TDM_TD2_SPEED_1G=1000, TDM_TD2_SPEED_1G_FX=1001, TDM_TD2_SPEED_1p2G=1200, TDM_TD2_SPEED_2G=2000,
TDM_TD2_SPEED_2p5G=2500, TDM_TD2_SPEED_4G=4000, TDM_TD2_SPEED_5G=5000, TDM_TD2_SPEED_7p5G=7500,
TDM_TD2_SPEED_10G=10000, TDM_TD2_SPEED_10G_DUAL=10001, TDM_TD2_SPEED_10G_XAUI=10002,
TDM_TD2_SPEED_12G=12000, TDM_TD2_SPEED_12p5G=12500, TDM_TD2_SPEED_13G=13000, TDM_TD2_SPEED_15G=15000,
TDM_TD2_SPEED_16G=16000, TDM_TD2_SPEED_20G=20000, TDM_TD2_SPEED_21G=21000, TDM_TD2_SPEED_21G_DUAL=21010,
TDM_TD2_SPEED_24G=24000, TDM_TD2_SPEED_25G=25000, TDM_TD2_SPEED_30G=30000, TDM_TD2_SPEED_40G=40000,
TDM_TD2_SPEED_42G=40005, TDM_TD2_SPEED_50G=50000,TDM_TD2_SPEED_75G=75000, TDM_TD2_SPEED_82G=82000,
TDM_TD2_SPEED_100G=100000, TDM_TD2_SPEED_120G=120000, TDM_TD2_SPEED_126G=126000};

#define TDM_TD2_NUM_EXT_PORTS 130

extern int
_soc_td2_set_tdm_tbl(enum tdm_td2_port_speed speed[TDM_TD2_NUM_EXT_PORTS],
int tdm_bw, int pgw_tdm_tbl_x0[32], int ovs_tdm_tbl_x0[32], int ovs_spacing_x0[32],
int pgw_tdm_tbl_x1[32], int ovs_tdm_tbl_x1[32], int ovs_spacing_x1[32],
int pgw_tdm_tbl_y0[32], int ovs_tdm_tbl_y0[32], int ovs_spacing_y0[32],
int pgw_tdm_tbl_y1[32], int ovs_tdm_tbl_y1[32], int ovs_spacing_y1[32],
int mmu_tdm_tbl_x[256], int mmu_tdm_ovs_x_1[16], int mmu_tdm_ovs_x_2[16],
int mmu_tdm_ovs_x_3[16], int mmu_tdm_ovs_x_4[16], int mmu_tdm_tbl_y[256],
int mmu_tdm_ovs_y_1[16], int mmu_tdm_ovs_y_2[16], int mmu_tdm_ovs_y_3[16],
int mmu_tdm_ovs_y_4[16], int port_state_map[128], int iarb_tdm_tbl_x[512],
int iarb_tdm_tbl_y[512], int ancillary_bandwidth_mode);

STATIC int
_soc_trident2_mdio_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data);
STATIC int
_soc_trident2_mdio_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data);

STATIC void
_soc_trident2_ser_control_reg_get(int unit, void *fifo_ser_list,
                                  soc_mem_t   mem,
                                  soc_reg_t   *ser_control_reg,
                                  soc_field_t *ser_enable_field);

STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ep_ser_info[] = {
    { EFP_PARITY_CONTROLr, EFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFP BUS" },
    { EFP_PARITY_CONTROLr, PW_INIT_COUNTERS_PARITY_ENf, 0, EGR_PW_INIT_COUNTERSm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, EFP_METER_TABLEm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, EFP_POLICY_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 CELL DATABUF" },
    /*{ EGR_EDATABUF_PARITY_CONTROLr, XLP_RESI_BUFFER_PAR_ENf, 0, INVALIDm, INVALIDr, "EP RESIDUE BUF" },*/
    { EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CM" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_DELIMITER_ERR_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_DELIMITER_ERROR_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_INVALID_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_INVALID_CRC_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, PERQ_PAR_ENf, 0, EGR_PERQ_XMT_COUNTERSm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf, 0, EFP_COUNTER_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf, 0, INVALIDm, INVALIDr, "TX DEBUG COUNTER" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 DATABUF CONTROL INFO" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_0m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_1m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_2m, INVALIDr, "" },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf, 0, EGR_FLEX_CTR_OFFSET_TABLE_3m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_0m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_1m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_2m, INVALIDr, "" },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf, 0, EGR_FLEX_CTR_COUNTER_TABLE_3m, INVALIDr, "" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_LINK_DELAY_PARITY_ENf, 1, INVALIDm, EGR_1588_LINK_DELAY_64r, "" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_SA_PARITY_ENf, 0, EGR_1588_SAm, INVALIDr, "" },
    { EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFPPARS BUS" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, SF_SRC_MODID_CHECK_PARITY_ENf, 1, INVALIDm, EGR_SF_SRC_MODID_CHECKr, "" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf, 0, EGR_MOD_MAP_TABLEm, INVALIDr, "" },
    { EGR_EHCPM_SER_CONTROLr, EHCPM_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EHCPM BUS" },
    { EGR_EL3_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf, 0, INVALIDm, INVALIDr, "INIT BUFF" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_NAT_PACKET_EDIT_INFO_PARITY_ENf, 0, EGR_NAT_PACKET_EDIT_INFOm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf, 0, EGR_MAP_MHm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf, 0, INVALIDm, INVALIDr, "EGR MPB" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf, 0, EGR_PORTm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf, 0, EGR_IPMCm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf, 0, EGR_VFIm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf, 0, EGR_DVP_ATTRIBUTEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf, 0, EGR_MAC_DA_PROFILEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, 0, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_PARITY_ENf, 0, EGR_L3_INTFm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf, 0, EGR_L3_NEXT_HOPm, INVALIDr, "" },
    { EGR_EPMOD_SER_CONTROLr, EPMOD_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EPMOD BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_EN_LPf, 0, EGR_VLAN_XLATE_LPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EVLAN_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EVLAN BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, EGR_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_ETAG_PCP_MAPPING_PARITY_ENf, 0, EGR_ETAG_PCP_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_3_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_3r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_2_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_2r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PVLAN_EPORT_CONTROL_PARITY_ENf, 1, INVALIDm, EGR_PVLAN_EPORT_CONTROLr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VP_VLAN_MEMBERSHIP_PARITY_ENf, 0, EGR_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_MEMBER_PARITY_ENf, 0, EGR_VPLAG_MEMBERm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_GROUP_PARITY_ENf, 0, EGR_VPLAG_GROUPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_1m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf, 0, EGR_GPP_ATTRIBUTESm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf, 0, EGR_GPP_ATTRIBUTES_MODBASEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf, 0, EGR_FRAGMENT_ID_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf, 0, EGR_DSCP_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf, 0, EGR_PRI_CNG_MAPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf, 0, EGR_MPLS_PRI_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_2m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf, 0, EGR_IP_TUNNELm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_ENf, 0, EGR_VLAN_XLATEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_STG_PARITY_ENf, 0, EGR_VLAN_STGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_PARITY_ENf, 0, EGR_VLANm, INVALIDr, "" },
    { INVALIDr }
};

STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ip_ser_info[] = {
    { CFG_SER_CONTROLr, PORT_TABLE_ECC_ENf, 0, PORT_TABm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_PAR_ENf, 0, SYSTEM_CONFIG_TABLEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_MODBASE_PAR_ENf, 0, SYSTEM_CONFIG_TABLE_MODBASEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SOURCE_TRUNK_MAP_MODBASE_PAR_ENf, 0, SOURCE_TRUNK_MAP_MODBASEm, INVALIDr, "" },
    /* NOTE: Read does not get the correct value for this reg */
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, INVALIDr, "" }, 
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_PARITY_ENf, 0, DLB_HGT_FLOWSETm, INVALIDr, "" },
    { IARB_SER_CONTROLr, LEARN_FIFO_ECC_ENf, 3, INVALIDm, INVALIDr, "IARB LEARN FIFO" },
    { IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf, 3, INVALIDm, INVALIDr, "CMIC BUFFER" },
    { IFP_PARITY_CONTROLr, IFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IFP BUS" },
    /*{ IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "COUNTER MUX DATA STAGING" }, HOW TO CLEAR */
    /*{ IFP_PARITY_CONTROLr, METER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "METER MUX DATA STAGING" }, HOW TO CLEAR */
    { IFP_PARITY_CONTROLr, PORT_METER_MAP_PARITY_ENf, 0, FP_PORT_METER_MAPm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, ING_DVP_2_PARITY_ENf, 0, ING_DVP_2_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, STORM_PARITY_ENf, 0, FP_STORM_CONTROL_METERSm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, COUNTER_PARITY_ENf, 0, FP_COUNTER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, FP_METER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, FP_POLICY_TABLEm, INVALIDr, "" },
    { IL2L3_BUS_SER_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "IL2L3 BUS" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, L3_DEFIP_ALPM_IPV6_128m, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, L3_DEFIP_ALPM_IPV6_64_1m, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, L3_DEFIP_ALPM_IPV6_64m, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, L3_DEFIP_ALPM_IPV4_1m, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, L3_DEFIP_ALPM_IPV4m, INVALIDr, "" },
    /* { ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, INVALIDm, INVALIDr, "L3 DEFIP ALPM IPV4/_1/IPV6_64/_64_1/_128" } */
    { ILPM_SER_CONTROLr, L3_DEFIP_AUX_PARITY_ENf, 0, L3_DEFIP_AUX_TABLEm, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_DATA_PARITY_ENf, 0, L3_DEFIP_DATA_ONLYm, INVALIDr, "" },
    { ILPM_SER_CONTROLr, L3_DEFIP_DATA_PARITY_ENf, 0, L3_DEFIP_PAIR_128_DATA_ONLYm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_PORT_BASED_HASH_PARITY_ENf, 0, RTAG7_PORT_BASED_HASHm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_FLOW_BASED_HASH_PARITY_ENf, 0, RTAG7_FLOW_BASED_HASHm, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_7m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_7m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, IPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IARS BUS" },
    { IPARS_SER_CONTROLr, SRC_VP_2_PARITY_ENf, 0, SOURCE_VP_2m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, SRC_TRUNK_ECC_ENf, 0, SOURCE_TRUNK_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, L3_TUNNEL_PARITY_ENf, 0, L3_TUNNEL_DATA_ONLYm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, FP_UDF_PARITY_ENf, 0, FP_UDF_OFFSETm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, MOD_MAP_PARITY_ENf, 0, ING_MOD_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, LPORT_TABLE_ECC_ENf, 0, LPORT_TABm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, CPU_TS_PARITY_ENf, 0, CPU_TS_MAPm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, VLAN_RANGE_PARITY_ENf, 0, ING_VLAN_RANGEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_ING_L3_NEXT_HOP_PARITY_ENf, 0, INITIAL_ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_GROUP_PARITY_ENf, 0, INITIAL_L3_ECMP_GROUPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_PARITY_ENf, 0, INITIAL_L3_ECMPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, OAM_OPCODE_CONTROL_PROFILE_PARITY_ENf, 0, OAM_OPCODE_CONTROL_PROFILEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_PROT_NHI_TABLE_PARITY_ENf, 0, INITIAL_PROT_NHI_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_PARITY_ENf, 0, PORT_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, TRUNK_CBL_TABLE_PARITY_ENf, 0, TRUNK_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_MODBASE_PARITY_ENf, 0, PORT_CBL_TABLE_MODBASEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, L3_IPMC_1_PARITY_ENf, 0, L3_IPMC_1m, INVALIDr, "" },
/*    { IRSEL1_SER_CONTROLr, MAID_REDUCTION_PARITY_ENf, 0, MAID_REDUCTIONm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_INDEX_PARITY_ENf, 0, MA_INDEXm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_STATE_PARITY_ENf, 0, MA_STATEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, RMEP_PARITY_ENf, 0, RMEPm, INVALIDr, "" },*/
    { IRSEL1_SER_CONTROLr, ING_1588_INGRESS_CTRL_PARITY_ENf, 0, ING_1588_INGRESS_CTRLm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, IRSEL1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL1 BUS" },
    { IRSEL2_SER_CONTROLr, ING_L3_NEXT_HOP_PARITY_ENf, 0, ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L2MC_PARITY_ENf, 0, L2MCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_PARITY_ENf, 0, L3_IPMCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_REMAP_PARITY_ENf, 0, L3_IPMC_REMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_GROUP_PARITY_ENf, 0, L3_ECMP_COUNTm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_PARITY_ENf, 0, L3_ECMPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IFP_REDIRECTION_PROFILE_PARITY_ENf, 0, IFP_REDIRECTION_PROFILEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ICONTROL_OPCODE_BITMAP_PARITY_ENf, 0, ICONTROL_OPCODE_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, EGR_MASK_MODBASE_PARITY_ENf, 0, EGR_MASK_MODBASEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, DEST_TRUNK_BITMAP_PARITY_ENf, 0, DEST_TRUNK_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, TRUNK_GROUP_PARITY_ENf, 0, TRUNK_GROUPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_ECMP_FLOWSET_PARITY_ENf, 0, RH_ECMP_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_LAG_FLOWSET_PARITY_ENf, 0, RH_LAG_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ING_SNAT_DATA_ONLY_PARITY_ENf, 0, ING_SNAT_DATA_ONLYm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IRSEL2_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL2 BUS" },
    { ISW1_SER_CONTROLr, FP_PORT_FIELD_SEL_PARITY_ENf, 0, FP_PORT_FIELD_SELm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TTL_FN_PARITY_ENf, 0, TTL_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TOS_FN_PARITY_ENf, 0, TOS_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_PRI_CNG_MAP_PARITY_ENf, 0, ING_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_UNTAGGED_PHB_PARITY_ENf, 0, ING_UNTAGGED_PHBm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, DSCP_TABLE_PARITY_ENf, 0, DSCP_TABLEm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, STORM_CONTROL_METER_CONFIG_PARITY_ENf, 1, INVALIDm, STORM_CONTROL_METER_CONFIGr, "" },
    { ISW1_SER_CONTROLr, FCOE_HOP_COUNT_FN_PARITY_ENf, 0, FCOE_HOP_COUNT_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ISW1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "ISW1 BUS" },
    { ISW2_SER_CONTROL_0r, VOQ_PORT_MAP_PARITY_ENf, 0, VOQ_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VOQ_MOD_MAP_PARITY_ENf, 0, VOQ_MOD_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_MEMBER_PARITY_ENf, 0, TRUNK_MEMBERm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, 
      INVALIDr, "" }, DUPLICATE */
    { ISW2_SER_CONTROL_0r, UNKNOWN_HGI_BITMAP_PARITY_ENf, 0, UNKNOWN_HGI_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, IMIRROR_BITMAP_PARITY_ENf, 0, IMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, KNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, KNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_EGRMSKBMAP_PARITY_ENf, 0, ING_EGRMSKBMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, BCAST_BLOCK_MASK_PARITY_ENf, 0, BCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_UCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_UCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBMm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, VOQ_COS_MAP_PARITY_ENf, 0, VOQ_COS_MAPm, INVALIDr, "" }, NA */
    { ISW2_SER_CONTROL_0r, NUM_QCN_CNM_RECEIVED_PARITY_ENf, 0, NUM_QCN_CNM_RECEIVEDm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, OAM_LM_COUNTERS_PARITY_ENf, 0, OAM_LM_COUNTERSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_EGRESS_PARITY_ENf, 0, SRC_MODID_EGRESSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_INGRESS_BLOCK_PARITY_ENf, 0, SRC_MODID_INGRESS_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_1_PARITY_ENf, 0, E2E_HOL_STATUS_1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_PARITY_ENf, 0, E2E_HOL_STATUSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VLAN_PROFILE_2_PARITY_ENf, 0, VLAN_PROFILE_2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MAC_BLOCK_TABLE_PARITY_ENf, 0, MAC_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_PW_TERM_SEQ_NUM_PARITY_ENf, 0, ING_PW_TERM_SEQ_NUMm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ALTERNATE_EMIRROR_BITMAP_PARITY_ENf, 0, ALTERNATE_EMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_MIRRORm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, PORT_LAG_FAILOVER_SET_PARITY_ENf, 0, PORT_LAG_FAILOVER_SETm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_HIGIG_TRUNK_OVERRIDE_PROFILE_PARITY_ENf, 0, ING_HIGIG_TRUNK_OVERRIDE_PROFILEm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_SW_PARITY_ENf, 0, MODPORT_MAP_SWm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, NONUCAST_TRUNK_BLOCK_MASK_PARITY_ENf, 0, NONUCAST_TRUNK_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_BITMAP_TABLE_PARITY_ENf, 0, TRUNK_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, EGR_MASK_PARITY_ENf, 0, EGR_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_M1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_PORT_MAP_PARITY_ENf, 0, SERVICE_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_QUEUE_MAP_PARITY_ENf, 0, SERVICE_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, ING_MISC_PORT_CONFIG_PARITY_ENf, 1, INVALIDm, ING_MISC_PORT_CONFIGr, "" },
    { ISW2_SER_CONTROL_1r, SFLOW_EGR_THRESHOLD_PARITY_ENf, 1, INVALIDm, SFLOW_EGR_THRESHOLDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_VLAN_TAGGEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf, 1, INVALIDm, 
      ING_NIV_RX_FRAMES_FORWARDING_DROPr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_ERROR_DROPr, "" },*/
    
    
    { ISW2_SER_CONTROL_1r, L3_MTU_VALUES_PARITY_ENf, 0, L3_MTU_VALUESm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf, 1, INVALIDm, ING_TRILL_RX_PKTSr, "" },*/
    { ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "HG STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC5/RDBGC6/RDBGC7/RDBGC8" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST1_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC1/RDBGC2/RDBGC3/RDBGC4" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDISC/RUC/RPORTD/RDBGC0" },
    { ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "IP STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER C" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER B" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER A" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL3_PARITY_ENf, 0, EMIRROR_CONTROL3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL2_PARITY_ENf, 0, EMIRROR_CONTROL2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL1_PARITY_ENf, 0, EMIRROR_CONTROL1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL_PARITY_ENf, 0, EMIRROR_CONTROLm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_COS_MAP_PARITY_ENf, 0, ENDPOINT_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, PHB2_COS_MAP_PARITY_ENf, 0, PHB2_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_QUEUE_MAP_PARITY_ENf, 0, ENDPOINT_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_PRI_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_PRI_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PRI_CNG_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PORT_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_TOS_MAP_PARITY_ENf, 0, ING_FLEX_CTR_TOS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_RES_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_RES_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_SERVICE_PRI_MAP_PARITY_ENf, 0, ING_SERVICE_PRI_MAPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_EN_LPf, 0, VLAN_XLATE_LPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_ETAG_PCP_MAPPING_PARITY_ENf, 0, ING_ETAG_PCP_MAPPINGm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf, 0, VLAN_PROTOCOL_DATAm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, ING_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, MPLS_ENTRY_PARITY_ENf, 0, MPLS_ENTRYm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_SUBNET_PARITY_ENf, 0, VLAN_SUBNET_DATA_ONLYm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf, 0, VLAN_PROTOCOLm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_ENf, 0, VLAN_XLATEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VFP_POLICY_PARITY_ENf, 0, VFP_POLICY_TABLEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, IVXLT_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IVXLT BUS" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L2Xm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, ING_DVP_TABLE_PARITY_ENf, 0, ING_DVP_TABLEm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, L2_ENDPOINT_ID_PARITY_ENf, 0, L2_ENDPOINT_IDm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L2_ENTRY_LPm, INVALIDr, "" },
    { L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf, 0, L2_MOD_FIFOm, INVALIDr, "" },
    { L2_USER_ENTRY_DATA_PARITY_CONTROLr, PARITY_ENf, 0, L2_USER_ENTRY_DATA_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_IPV4_UNICASTm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_IPV4_MULTICASTm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_IPV6_UNICASTm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_IPV6_MULTICASTm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, ING_ACTIVE_L3_IIF_PROFILE_PARITY_ENf, 0, ING_ACTIVE_L3_IIF_PROFILEm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L3_ENTRY_LPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_VP_VLAN_MEMBERSHIP_PAR_ENf, 0, ING_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PAR_ENf, 0, L3_IIFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_MPLS_EXP_MAPPING_PAR_ENf, 0, ING_MPLS_EXP_MAPPINGm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VRF_PAR_ENf, 0, VRFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PAR_ENf, 0, VLAN_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_STG_PAR_ENf, 0, STG_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PROFILE_PAR_ENf, 0, VLAN_PROFILE_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_OUTER_DOT1P_MAPPING_TABLE_PAR_ENf, 0, ING_OUTER_DOT1P_MAPPING_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, IP_OPTION_CONTROL_PROFILE_TABLE_PAR_ENf, 0, IP_OPTION_CONTROL_PROFILE_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PROFILE_PAR_ENf, 0, L3_IIF_PROFILEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_DNAT_ADDRESS_TYPE_PAR_ENf, 0, ING_DNAT_ADDRESS_TYPEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, MPLS_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "MPLS BUS" },
    { VP_SER_CONTROLr, VLAN_MPLS_PAR_ENf, 0, VLAN_MPLSm, INVALIDr, "" },
    { VP_SER_CONTROLr, MY_STATION_TCAM_DATA_ONLY_PAR_ENf, 0, MY_STATION_TCAM_DATA_ONLYm, INVALIDr, "" },
    { VP_SER_CONTROLr, SOURCE_VP_PAR_ENf, 0, SOURCE_VPm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_PAR_ENf, 0, VFIm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_1_PAR_ENf, 0, VFI_1m, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_VSAN_PAR_ENf, 0, ING_VSANm, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_TRILL_ADJACENCY_PAR_ENf, 1, INVALIDm, ING_TRILL_ADJACENCYr, "" },
    { VP_SER_CONTROLr, VP_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "VP BUS" },
    { INVALIDr }
};

STATIC const
_soc_td2_ser_block_info_t _soc_td2_ser_block_info[] = {
    { SOC_BLK_IPIPE, ING_SER_FIFO_CTRLr, _soc_td2_ip_ser_info },
    { SOC_BLK_EPIPE, EGR_SER_FIFO_CTRLr, _soc_td2_ep_ser_info },
    { 0 }
};

STATIC _soc_td2_ser_info_t _soc_td2_mmu_ser_info[] = {
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0,
        DEQ_NOT_IP_ERR_ENf,
        DEQ_NOT_IP_ERRf,
        INVALIDm, "MMU DEQ NOT IP",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_START_ERR, NULL, 0,
        START_BY_START_ERR_ENf,
        START_BY_START_ERRf,
        INVALIDm, "MMU START BY START",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_MMU_SER, NULL, 0,
        MEM_PAR_ERR_ENf,
        MEM_PAR_ERRf,
        INVALIDm, "MMU MEM PAR",
        INVALIDr, INVALIDf,
        MEM_FAIL_INT_STATr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDI_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDO_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_CFAP_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_info_t _soc_td2_cport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "CDC RX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_RXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CDC_TXFIFO_MEM_ERRf,
        CDC_TXFIFO_MEM_ERRf,
        INVALIDm, "CDC TX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_TXFIFO_MEM_ENf,
        CPORT_CDC_TXFIFO_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "TX FIFO ECC - XPORT CORE0 OR CPORT CORE",
        CPORT_ECC_CONTROLr, TXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_reg_t _soc_td2_pg_bod_status_reg[] = {
    { PGW_BOD_XLP0_ECC_STATUSr, "PGW BOD XLP0 ECC" },
    { PGW_BOD_XLP1_ECC_STATUSr, "PGW BOD XLP1 ECC" },
    { PGW_BOD_XLP2_ECC_STATUSr, "PGW BOD XLP2 ECC" },
    { PGW_BOD_XLP3_ECC_STATUSr, "PGW BOD XLP3 ECC" },
    { INVALIDr }
};

STATIC _soc_td2_ser_info_t _soc_td2_pg_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PGW_OBM_PERR_INTRf,
        PGW_OBM_PERR_INTRf,
        INVALIDm, "PGW OBM",
        PGW_OBM0_ECC_ENABLEr, ECC_ENABLEf,
        PGW_OBM0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PGW_BOD_PERR_INTRf,
        PGW_BOD_PERR_INTRf,
        INVALIDm, "PGW BOD",
        PGW_BOD_ECC_ENABLEr, BOD_ECC_ENABLEf,
        INVALIDr, _soc_td2_pg_bod_status_reg },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_RSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        PGW_MIB_RSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_TSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        PGW_MIB_TSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_CPORT, _soc_td2_cport_ser_info, 0,
        CPORT_ERRf,
        CPORT_ERRf,
        INVALIDm, "CPORT",
        CPORT_INTR_ENABLEr, INVALIDf, /* group enable */
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC const
_soc_td2_ser_route_block_t  _soc_td2_ser_route_blocks[] = {
    { 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
      SOC_BLK_MMU, -1, MEM_FAIL_INT_ENr, MEM_FAIL_INT_STATr, INVALIDf, 
      _soc_td2_mmu_ser_info, 0 },
    { 0x00000002, /* X_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000004, /* Y_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000008, /* X_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000010, /* Y_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000020, /* X_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000040, /* Y_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000080, /* X_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000100, /* Y_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000200, /* X_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000400, /* Y_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000800, /* X_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00001000, /* Y_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00002000, /* X_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00004000, /* Y_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00008000, /* X_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00010000, /* Y_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00040000, /* PGW_0_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 0 },
    { 0x00080000, /* PGW_1_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 1 },
    { 0x00100000, /* PGW_2_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 2 },
    { 0x00200000, /* PGW_3_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 3 },
    { 0x00400000, /* PGW_4_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 4 },
    { 0x00800000, /* PGW_5_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 5 },
    { 0x01000000, /* PGW_6_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 6 },
    { 0x02000000, /* PGW_7_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 7 },
    { 0 } /* table terminator */
};

STATIC const
soc_field_t _soc_td2_mmu_parity_enable_fields[] = {
    INVALIDf,         /* ADM */
    ENQ_PARITY_ENf,   /* ENQ */
    THDI_PARITY_ENf,  /* THDI */
    INVALIDf,         /* THDO */
    TOQ_PARITY_ENf,   /* TOQ */
    DEQ_PARITY_ENf,   /* DEQ */
    INVALIDf,
    CFAP_PARITY_ENf,  /* CFAP */
    CCP_PARITY_ENf,   /* CCP */
    MTRI_PARITY_ENf,  /* MTRI */
    MTRO_PARITY_ENf,  /* MTRO */
    INVALIDf,         /* INTF */
    INVALIDf,         /* CFG */
    AGING_PARITY_ENf, /* AGING */
    DEQ_PARITY_ENf,   /* MEM0 */
    INVALIDf,         /* MEM1 */
    INVALIDf,         /* MEM3 */
    INVALIDf,         /* MEM4 */
    INVALIDf,         /* TOQ2 */
    INVALIDf,         /* TOQ3 */
    INVALIDf,         /* TOQ4 */
    INTFI_PARITY_ENf, /* INTFI */
    INVALIDf,         /* INTFO */
    INTFO2_PARITY_ENf,/* INTFO2 */
    ES_PARITY_ENf,    /* LLS */
    ES_PARITY_ENf,    /* LLS_PORT */
    ES_PARITY_ENf,    /* LLS_L0 */
    ES_PARITY_ENf,    /* LLS_L1 */
    ES_PARITY_ENf,    /* LLS_L2 */
    WRED_PARITY_ENf,  /* WRED */
    INVALIDf,         /* MCQ */
    INVALIDf,         /* UCQ */
    PQE_PARITY_ENf,   /* PQE */
    QCN_PARITY_ENf,   /* QCN */
    CTR_PARITY_ENf,   /* CTR */
    INVALIDf,
    RQE_PARITY_ENf,   /* RQE */
    ES_PARITY_ENf,    /* VBS */
    ES_PARITY_ENf,    /* VBS_L0 */
    ES_PARITY_ENf,    /* VBS_L1 */
    ES_PARITY_ENf,    /* VBS_L2 */
    EPRG_PARITY_ENf,  /* EPRG */
    THDU_PARITY_ENf,  /* THDU */
    THDM_PARITY_ENf,  /* THDO_MC_DB */
    THDM_PARITY_ENf,  /* THDO_MC_QE */
    INVALIDf,         /* THDR_DB */
    INVALIDf,         /* THDR_QE */
    ES_PARITY_ENf,    /* TDM */
    INVALIDf,
    INVALIDf,
    INVALIDf,
    INVALIDf
};

static const soc_reg_t mmu_ovs_group_regs[2][MAX_MMU_OVS_GROUP_COUNT] = {
    {
        ES_PIPE0_OVR_SUB_GRP0_TBLr, ES_PIPE0_OVR_SUB_GRP1_TBLr,
        ES_PIPE0_OVR_SUB_GRP2_TBLr, ES_PIPE0_OVR_SUB_GRP3_TBLr
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
        ES_PIPE0_OVR_SUB_GRP4_TBLr, ES_PIPE0_OVR_SUB_GRP5_TBLr,
        ES_PIPE0_OVR_SUB_GRP6_TBLr, ES_PIPE0_OVR_SUB_GRP7_TBLr
#endif
    },
    {
        ES_PIPE1_OVR_SUB_GRP0_TBLr, ES_PIPE1_OVR_SUB_GRP1_TBLr,
        ES_PIPE1_OVR_SUB_GRP2_TBLr, ES_PIPE1_OVR_SUB_GRP3_TBLr
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
        ES_PIPE1_OVR_SUB_GRP4_TBLr, ES_PIPE1_OVR_SUB_GRP5_TBLr,
        ES_PIPE1_OVR_SUB_GRP6_TBLr, ES_PIPE1_OVR_SUB_GRP7_TBLr
#endif
    }
};

static const soc_field_t pgw_tdm_fields[] = {
    TDM_ENTRY0_PORT_IDf, TDM_ENTRY1_PORT_IDf,
    TDM_ENTRY2_PORT_IDf, TDM_ENTRY3_PORT_IDf,
    TDM_ENTRY4_PORT_IDf, TDM_ENTRY5_PORT_IDf,
    TDM_ENTRY6_PORT_IDf, TDM_ENTRY7_PORT_IDf,
    TDM_ENTRY8_PORT_IDf, TDM_ENTRY9_PORT_IDf,
    TDM_ENTRY10_PORT_IDf, TDM_ENTRY11_PORT_IDf,
    TDM_ENTRY12_PORT_IDf, TDM_ENTRY13_PORT_IDf,
    TDM_ENTRY14_PORT_IDf, TDM_ENTRY15_PORT_IDf,
    TDM_ENTRY16_PORT_IDf, TDM_ENTRY17_PORT_IDf,
    TDM_ENTRY18_PORT_IDf, TDM_ENTRY19_PORT_IDf,
    TDM_ENTRY20_PORT_IDf, TDM_ENTRY21_PORT_IDf,
    TDM_ENTRY22_PORT_IDf, TDM_ENTRY23_PORT_IDf,
    TDM_ENTRY24_PORT_IDf, TDM_ENTRY25_PORT_IDf,
    TDM_ENTRY26_PORT_IDf, TDM_ENTRY27_PORT_IDf,
    TDM_ENTRY28_PORT_IDf, TDM_ENTRY29_PORT_IDf,
    TDM_ENTRY30_PORT_IDf, TDM_ENTRY31_PORT_IDf
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
    TDM_ENTRY32_PORT_IDf, TDM_ENTRY33_PORT_IDf,
    TDM_ENTRY34_PORT_IDf, TDM_ENTRY35_PORT_IDf,
    TDM_ENTRY36_PORT_IDf, TDM_ENTRY37_PORT_IDf,
    TDM_ENTRY38_PORT_IDf, TDM_ENTRY39_PORT_IDf,
    TDM_ENTRY40_PORT_IDf, TDM_ENTRY41_PORT_IDf,
    TDM_ENTRY42_PORT_IDf, TDM_ENTRY43_PORT_IDf,
    TDM_ENTRY44_PORT_IDf, TDM_ENTRY45_PORT_IDf,
    TDM_ENTRY46_PORT_IDf, TDM_ENTRY47_PORT_IDf,
    TDM_ENTRY48_PORT_IDf, TDM_ENTRY49_PORT_IDf,
    TDM_ENTRY50_PORT_IDf, TDM_ENTRY51_PORT_IDf,
    TDM_ENTRY52_PORT_IDf, TDM_ENTRY53_PORT_IDf,
    TDM_ENTRY54_PORT_IDf, TDM_ENTRY55_PORT_IDf,
    TDM_ENTRY56_PORT_IDf, TDM_ENTRY57_PORT_IDf,
    TDM_ENTRY58_PORT_IDf, TDM_ENTRY59_PORT_IDf,
    TDM_ENTRY60_PORT_IDf, TDM_ENTRY61_PORT_IDf,
    TDM_ENTRY62_PORT_IDf, TDM_ENTRY63_PORT_IDf
#endif
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT
static soc_reg_t mmu_ovs_group_wt_select_regs[2] = {
    ES_PIPE0_GRP_WT_SELECTr,
    ES_PIPE1_GRP_WT_SELECTr
};
#endif

static soc_reg_t pgw_tdm_regs[] = {
    PGW_LR_TDM_REG_0r, PGW_LR_TDM_REG_1r,
    PGW_LR_TDM_REG_2r, PGW_LR_TDM_REG_3r,
    PGW_LR_TDM_REG_4r, PGW_LR_TDM_REG_5r,
    PGW_LR_TDM_REG_6r, PGW_LR_TDM_REG_7r
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    ,
    PGW_LR_TDM_REG_8r,  PGW_LR_TDM_REG_9r,
    PGW_LR_TDM_REG_10r, PGW_LR_TDM_REG_11r,
    PGW_LR_TDM_REG_12r, PGW_LR_TDM_REG_13r,
    PGW_LR_TDM_REG_14r, PGW_LR_TDM_REG_15r
#endif
};

static soc_reg_t pgw_ovs_tdm_regs[] = {
    PGW_OS_TDM_REG_0r, PGW_OS_TDM_REG_1r,
    PGW_OS_TDM_REG_2r, PGW_OS_TDM_REG_3r,
    PGW_OS_TDM_REG_4r, PGW_OS_TDM_REG_5r,
    PGW_OS_TDM_REG_6r, PGW_OS_TDM_REG_7r
};

static const soc_reg_t pgw_ovs_spacing_regs[] = {
    PGW_OS_PORT_SPACING_REG_0r, PGW_OS_PORT_SPACING_REG_1r,
    PGW_OS_PORT_SPACING_REG_2r, PGW_OS_PORT_SPACING_REG_3r,
    PGW_OS_PORT_SPACING_REG_4r, PGW_OS_PORT_SPACING_REG_5r,
    PGW_OS_PORT_SPACING_REG_6r, PGW_OS_PORT_SPACING_REG_7r
};

static const soc_field_t pgw_spacing_fields[] = {
    SLOT0f, SLOT1f, SLOT2f, SLOT3f, SLOT4f, SLOT5f, SLOT6f, SLOT7f,
    SLOT8f, SLOT9f, SLOT10f, SLOT11f, SLOT12f, SLOT13f, SLOT14f, SLOT15f,
    SLOT16f, SLOT17f, SLOT18f, SLOT19f, SLOT20f, SLOT21f, SLOT22f, SLOT23f,
    SLOT24f, SLOT25f, SLOT26f, SLOT27f, SLOT28f, SLOT29f, SLOT30f, SLOT31f
};

static soc_reg_t mmu_ovs_group_wt_regs_local[2][_MMU_OVS_WT_GROUP_COUNT] = {
    {
        ES_PIPE0_OVR_SUB_GRP0_WTr, ES_PIPE0_OVR_SUB_GRP1_WTr,
        ES_PIPE0_OVR_SUB_GRP2_WTr, ES_PIPE0_OVR_SUB_GRP3_WTr
    },
    {
        ES_PIPE1_OVR_SUB_GRP0_WTr, ES_PIPE1_OVR_SUB_GRP1_WTr,
        ES_PIPE1_OVR_SUB_GRP2_WTr, ES_PIPE1_OVR_SUB_GRP3_WTr
    }
};

static const soc_reg_t td2_pgw_obm_ctrl_regs[] = {
    PGW_OBM0_CONTROLr, PGW_OBM1_CONTROLr,
    PGW_OBM2_CONTROLr, PGW_OBM3_CONTROLr
};

static const soc_field_t td2_pgw_obm_bypass_fields[] = {
    PORT0_BYPASS_ENABLEf, PORT1_BYPASS_ENABLEf,
    PORT2_BYPASS_ENABLEf, PORT3_BYPASS_ENABLEf
};

static const soc_field_t td2_pgw_obm_oversub_fields[] = {
    PORT0_OVERSUB_ENABLEf, PORT1_OVERSUB_ENABLEf,
    PORT2_OVERSUB_ENABLEf, PORT3_OVERSUB_ENABLEf
};

static const soc_reg_t td2_pgw_obm_threshold_regs[] = {
    PGW_OBM0_THRESHOLDr, PGW_OBM1_THRESHOLDr,
    PGW_OBM2_THRESHOLDr, PGW_OBM3_THRESHOLDr
};

static const soc_reg_t td2_pgw_obm_priority_map_regs[] = {
    PGW_OBM0_PRIORITY_MAPr, PGW_OBM1_PRIORITY_MAPr,
    PGW_OBM2_PRIORITY_MAPr, PGW_OBM3_PRIORITY_MAPr
};

static const soc_reg_t td2_pgw_obm_use_counter_regs[] = {
    PGW_OBM0_USE_COUNTERr, PGW_OBM1_USE_COUNTERr,
    PGW_OBM2_USE_COUNTERr, PGW_OBM3_USE_COUNTERr
};

static const soc_field_t td2_pgw_obm_use_count_fields[] = {
    PORT0_USE_COUNTf, PORT1_USE_COUNTf,
    PORT2_USE_COUNTf, PORT3_USE_COUNTf
};

static const soc_reg_t td2_pgw_obm_max_usage_regs[] = {
    PGW_OBM0_MAX_USAGEr, PGW_OBM1_MAX_USAGEr,
    PGW_OBM2_MAX_USAGEr, PGW_OBM3_MAX_USAGEr
};

static const soc_field_t td2_pgw_obm_max_usage_fields[] = {
    PORT0_MAX_USAGEf, PORT1_MAX_USAGEf,
    PORT2_MAX_USAGEf, PORT3_MAX_USAGEf
};

static const soc_reg_t td2_pgw_obm_shared_config_regs[] = {
    PGW_OBM0_SHARED_CONFIGr, PGW_OBM1_SHARED_CONFIGr,
    PGW_OBM2_SHARED_CONFIGr, PGW_OBM3_SHARED_CONFIGr
};

static const soc_reg_t td2_pgw_obm_fc_config_regs[] = {
    PGW_OBM_PORT0_FC_CONFIGr, PGW_OBM_PORT1_FC_CONFIGr,
    PGW_OBM_PORT2_FC_CONFIGr, PGW_OBM_PORT3_FC_CONFIGr,
    PGW_OBM_PORT4_FC_CONFIGr, PGW_OBM_PORT5_FC_CONFIGr,
    PGW_OBM_PORT6_FC_CONFIGr, PGW_OBM_PORT7_FC_CONFIGr,
    PGW_OBM_PORT8_FC_CONFIGr, PGW_OBM_PORT9_FC_CONFIGr,
    PGW_OBM_PORT10_FC_CONFIGr, PGW_OBM_PORT11_FC_CONFIGr,
    PGW_OBM_PORT12_FC_CONFIGr, PGW_OBM_PORT13_FC_CONFIGr,
    PGW_OBM_PORT14_FC_CONFIGr, PGW_OBM_PORT15_FC_CONFIGr
};

static soc_ser_functions_t _td2_ser_functions;

uint8 _soc_alpm_mode[SOC_MAX_NUM_DEVICES];

static const int a1_freq_list[]      = { 760, 660, 608, 518, 415 };
static const int a2_793_freq_list[]  = { 793, 760, 635, 537, 415 };
static const int a2_635_freq_list[]  = { 635, 608, 537, 518, 415 };
static const int a1_td2p_freq_list[] = { 793, 760, 635, 537, 421 };


#ifdef BCM_TRIDENT2PLUS_SUPPORT
mmu_ovs_group_regs_t 
soc_trident2_mmu_ovs_group_regs_get (int unit)
{
    return mmu_ovs_group_regs;
}

mmu_ovs_group_wt_select_regs_t
soc_trident2_mmu_ovs_group_wt_select_regs_get (int unit)
{
    return mmu_ovs_group_wt_select_regs;
}

pgw_ovs_tdm_regs_t
soc_trident2_pgw_ovs_tdm_regs_get (int unit)
{
    return pgw_ovs_tdm_regs;
}

pgw_ovs_spacing_regs_t 
soc_trident2_pgw_ovs_spacing_regs_get (int unit)
{
    return pgw_ovs_spacing_regs;
}

pgw_obm_threshold_regs_t
soc_trident2_pgw_obm_threshold_regs_get (int unit)
{
    return td2_pgw_obm_threshold_regs;
}

pgw_tdm_fields_t 
soc_trident2_pgw_tdm_fields_get (int unit)
{
    return pgw_tdm_fields;
}

pgw_spacing_fields_t
soc_trident2_pgw_spacing_fields_get (int unit)
{
    return pgw_spacing_fields;
}
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

int
soc_trident2_pipe_select(int unit, int egress, int pipe)
{
    soc_reg_t reg;

    reg = egress ? EGR_SBS_CONTROLr : SBS_CONTROLr;
    return soc_reg_field32_modify(unit, reg, REG_PORT_ANY, PIPE_SELECTf, pipe);
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable);
STATIC int
soc_trident2_ser_enable_by_acctype(int unit, soc_reg_t reg, 
                                                soc_field_t field, int enable,
                                                int egress);


enum _td2p_ovs_wt_speed_group {
    td2p_ovs_wt_group_speed_10G,
    td2p_ovs_wt_group_speed_20G,
    td2p_ovs_wt_group_speed_40G,
    td2p_ovs_wt_group_speed_NA
};

/*
 * MMU SER control data for Trident2 chip, this array only include the memories
 * which are protected by ECC logic And whose SER_RESPONSE equal SER_NONE
 */
STATIC
_soc_mem_ser_en_info_t _soc_trident2_mmu_ecc_mem_ser_info[] = {
    /* MMU_CCP_EN_COR_ERR_RPTr */
    { MMU_CCP0_RESEQ_MEMm, PARITY_ENr, CCP_PARITY_ENf, MMU_CCP_EN_COR_ERR_RPTr, CCP0_RESEQf },
    { MMU_CCP1_RESEQ_MEMm, PARITY_ENr, CCP_PARITY_ENf, MMU_CCP_EN_COR_ERR_RPTr, CCP1_RESEQf },
    { MMU_CCP_MEMm, PARITY_ENr, CCP_PARITY_ENf, MMU_CCP_EN_COR_ERR_RPTr, CCP_MEMf },

    /* MMU_CFAP_EN_COR_ERR_RPTr */
    { MMU_CFAP_BANK0m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK0f },
    { MMU_CFAP_BANK1m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK1f },
    { MMU_CFAP_BANK2m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK2f },
    { MMU_CFAP_BANK3m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK3f },
    { MMU_CFAP_BANK4m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK4f },
    { MMU_CFAP_BANK5m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK5f },
    { MMU_CFAP_BANK6m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK6f },
    { MMU_CFAP_BANK7m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK7f },
    { MMU_CFAP_BANK8m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK8f },
    { MMU_CFAP_BANK9m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK9f },
    { MMU_CFAP_BANK10m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK10f },
    { MMU_CFAP_BANK11m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK11f },
    { MMU_CFAP_BANK12m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK12f },
    { MMU_CFAP_BANK13m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK13f },
    { MMU_CFAP_BANK14m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK14f },
    { MMU_CFAP_BANK15m, PARITY_ENr, CFAP_PARITY_ENf, MMU_CFAP_EN_COR_ERR_RPTr, CFAP_BANK15f },

    /* MMU_DEQ_EN_COR_ERR_RPTr */
    { MMU_PKTHDRm, PARITY_ENr, DEQ_PARITY_ENf, MMU_DEQ_EN_COR_ERR_RPTr, PKTHDRf },
    { MMU_PORTCNTm, PARITY_ENr, DEQ_PARITY_ENf, MMU_DEQ_EN_COR_ERR_RPTr, PORTCNTf },
    { MMU_REPL_STATE_TBL_PIPE1m, PARITY_ENr, DEQ_PARITY_ENf, MMU_DEQ_EN_COR_ERR_RPTr, REPL_STATE_TBL_PIPE1f },
    { MMU_REPL_STATE_TBL_PIPE0m, PARITY_ENr, DEQ_PARITY_ENf, MMU_DEQ_EN_COR_ERR_RPTr, REPL_STATE_TBL_PIPE0f },

    /* MMU_PQE_EN_COR_ERR_RPTr */
    { MMU_PQE0_MEMm, PARITY_ENr, PQE_PARITY_ENf, MMU_PQE_EN_COR_ERR_RPTr, PQE0f },
    { MMU_PQE1_MEMm, PARITY_ENr, PQE_PARITY_ENf, MMU_PQE_EN_COR_ERR_RPTr, PQE1f },

    /* THDI_EN_COR_ERR_RPTr */
    { THDI_PORT_PG_CNTRS_RT1_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_RT1_ERR_DET_EN_PIPEXf },
    { THDI_PORT_PG_CNTRS_RT2_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_RT2_ERR_DET_EN_PIPEXf },
    { THDI_PORT_PG_CNTRS_SH1_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_SH1_ERR_DET_EN_PIPEXf },
    { THDI_PORT_PG_CNTRS_SH2_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_SH2_ERR_DET_EN_PIPEXf },
    { THDI_PORT_SP_CNTRS_RT_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTSP_CNTR_RT_ERR_DET_EN_PIPEXf },
    { THDI_PORT_SP_CNTRS_SH_Xm, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTSP_CNTR_SH_ERR_DET_EN_PIPEXf },
    { THDI_PORT_PG_CNTRS_RT1_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_RT1_ERR_DET_EN_PIPEYf },
    { THDI_PORT_PG_CNTRS_RT2_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_RT2_ERR_DET_EN_PIPEYf },
    { THDI_PORT_PG_CNTRS_SH1_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_SH1_ERR_DET_EN_PIPEYf },
    { THDI_PORT_PG_CNTRS_SH2_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTPG_CNTR_SH2_ERR_DET_EN_PIPEYf },
    { THDI_PORT_SP_CNTRS_RT_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTSP_CNTR_RT_ERR_DET_EN_PIPEYf },
    { THDI_PORT_SP_CNTRS_SH_Ym, PARITY_ENr, THDI_PARITY_ENf, THDI_EN_COR_ERR_RPTr, THDI_PTSP_CNTR_SH_ERR_DET_EN_PIPEYf },

    /* MMU_THDU_EN_COR_ERR_RPTr */
    { MMU_THDU_XPIPE_COUNTER_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_QUEUEf },
    { MMU_THDU_XPIPE_COUNTER_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_QGROUPf },
    { MMU_THDU_XPIPE_COUNTER_PORTm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_PORTf },
    { MMU_THDU_XPIPE_BST_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_QUEUEf },
    { MMU_THDU_XPIPE_BST_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_QGROUPf },
    { MMU_THDU_XPIPE_BST_PORTm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_PORTf },
    { MMU_THDU_XPIPE_RESUME_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_RESUME_QUEUEf },
    { MMU_THDU_XPIPE_RESUME_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_RESUME_QGROUPf },
    { MMU_THDU_YPIPE_COUNTER_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_QUEUEf },
    { MMU_THDU_YPIPE_COUNTER_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_QGROUPf },
    { MMU_THDU_YPIPE_COUNTER_PORTm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_COUNTER_PORTf },
    { MMU_THDU_YPIPE_BST_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_QUEUEf },
    { MMU_THDU_YPIPE_BST_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_QGROUPf },
    { MMU_THDU_YPIPE_BST_PORTm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_BST_PORTf },
    { MMU_THDU_YPIPE_RESUME_QUEUEm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_RESUME_QUEUEf },
    { MMU_THDU_YPIPE_RESUME_QGROUPm, PARITY_ENr, THDU_PARITY_ENf, MMU_THDU_EN_COR_ERR_RPTr, MMU_THDU_RESUME_QGROUPf },

    /* MMU_TOQ_EN_COR_ERR_RPTr */
    { MMU_CELL_LINKm, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, CELL_LINKf },
    { MMU_PDB1m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, PDB1f },
    { MMU_PDB0m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, PDB0f },
    { MMU_MCQDB1m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, MCQDB1f },
    { MMU_MCQDB0m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, MCQDB0f },
    { MMU_UCQDB1m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, UCQDB1f },
    { MMU_UCQDB0m, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, UCQDB0f },
    { MMU_MCFPm, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, MCFPf },
    { MMU_MCQEm, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, MCQEf },
    { MMU_MCQNm, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, MCQNf },
    { MMU_PKT_LINKm, PARITY_ENr, TOQ_PARITY_ENf, MMU_TOQ_EN_COR_ERR_RPTr, PKT_LINKf },

    /* MMU_QCN_EN_COR_ERR_RPTr */
    { MMU_QCN_CNM_QUEUE0m, PARITY_ENr, QCN_PARITY_ENf, MMU_QCN_EN_COR_ERR_RPTr, CNM_QUEUE0f },
    { MMU_QCN_CNM_QUEUE1m, PARITY_ENr, QCN_PARITY_ENf, MMU_QCN_EN_COR_ERR_RPTr, CNM_QUEUE1f },

    /* ES_PIPE0_LLS_EN_COR_ERR_RPT_1r */
    { ES_PIPE0_LLS_PORT_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, PORT_PARENT_STATEf },
    { ES_PIPE0_LLS_PORT_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, PORT_HEADS_TAILSf },
    { ES_PIPE0_LLS_PORT_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, PORT_WERR_MAX_SCf },
    { ES_PIPE0_LLS_L0_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_PARENT_STATEf },
    { ES_PIPE0_LLS_L0_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_HEADS_TAILSf },
    { ES_PIPE0_LLS_L0_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_WERR_MAX_SCf },
    { ES_PIPE0_LLS_L0_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_ERRORf },
    { ES_PIPE0_LLS_L0_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_CHILD_STATE1f },
    { ES_PIPE0_LLS_L0_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE0_LLS_L0_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_MIN_NEXTf },
    { ES_PIPE0_LLS_L0_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_WERR_NEXTf },
    { ES_PIPE0_LLS_L0_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, L0_XOFFf },

    /* ES_PIPE0_LLS_EN_COR_ERR_RPT_2r */
    { ES_PIPE0_LLS_L1_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_PARENT_STATEf },
    { ES_PIPE0_LLS_L1_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_HEADS_TAILSf },
    { ES_PIPE0_LLS_L1_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_WERR_MAX_SCf },
    { ES_PIPE0_LLS_L1_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_ERRORf },
    { ES_PIPE0_LLS_L1_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_CHILD_STATE1f },
    { ES_PIPE0_LLS_L1_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE0_LLS_L1_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_MIN_NEXTf },
    { ES_PIPE0_LLS_L1_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_WERR_NEXTf },
    { ES_PIPE0_LLS_L1_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L1_XOFFf },
    { ES_PIPE0_LLS_L2_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_ERRORf },
    { ES_PIPE0_LLS_L2_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_CHILD_STATE1f },
    { ES_PIPE0_LLS_L2_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE0_LLS_L2_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_MIN_NEXTf },
    { ES_PIPE0_LLS_L2_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_WERR_NEXTf },
    { ES_PIPE0_LLS_L2_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r, L2_XOFFf },

    /* ES_PIPE1_LLS_EN_COR_ERR_RPT_1r */
    { ES_PIPE1_LLS_PORT_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, PORT_PARENT_STATEf },
    { ES_PIPE1_LLS_PORT_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, PORT_HEADS_TAILSf },
    { ES_PIPE1_LLS_PORT_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, PORT_WERR_MAX_SCf },
    { ES_PIPE1_LLS_L0_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_PARENT_STATEf },
    { ES_PIPE1_LLS_L0_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_HEADS_TAILSf },
    { ES_PIPE1_LLS_L0_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_WERR_MAX_SCf },
    { ES_PIPE1_LLS_L0_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_ERRORf },
    { ES_PIPE1_LLS_L0_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_CHILD_STATE1f },
    { ES_PIPE1_LLS_L0_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE1_LLS_L0_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_MIN_NEXTf },
    { ES_PIPE1_LLS_L0_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_WERR_NEXTf },
    { ES_PIPE1_LLS_L0_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, L0_XOFFf },

    /* ES_PIPE1_LLS_EN_COR_ERR_RPT_2r */
    { ES_PIPE1_LLS_L1_PARENT_STATEm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_PARENT_STATEf },
    { ES_PIPE1_LLS_L1_HEADS_TAILSm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_HEADS_TAILSf },
    { ES_PIPE1_LLS_L1_WERR_MAX_SCm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_WERR_MAX_SCf },
    { ES_PIPE1_LLS_L1_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_ERRORf },
    { ES_PIPE1_LLS_L1_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_CHILD_STATE1f },
    { ES_PIPE1_LLS_L1_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE1_LLS_L1_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_MIN_NEXTf },
    { ES_PIPE1_LLS_L1_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_WERR_NEXTf },
    { ES_PIPE1_LLS_L1_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L1_XOFFf },
    { ES_PIPE1_LLS_L2_ERRORm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_ERRORf },
    { ES_PIPE1_LLS_L2_CHILD_STATE1m, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_CHILD_STATE1f },
    { ES_PIPE1_LLS_L2_CHILD_WEIGHT_WORKINGm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_CHILD_WEIGHT_WORKINGf },
    { ES_PIPE1_LLS_L2_MIN_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_MIN_NEXTf },
    { ES_PIPE1_LLS_L2_WERR_NEXTm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_WERR_NEXTf },
    { ES_PIPE1_LLS_L2_XOFFm, PARITY_ENr, ES_PARITY_ENf, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r, L2_XOFFf },

    /* HSP_EN_COR_ERR_RPTr */
    { HSP_SCHED_L2_ACCUM_COMP_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L2_ACCUM_COMP_MEM_0f },
    { HSP_SCHED_L2_CREDIT_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L2_CREDITMEM_0f },
    { HSP_SCHED_L1_ACCUM_COMP_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L1_ACCUM_COMP_MEM_0f },
    { HSP_SCHED_L1_CREDIT_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L1_CREDITMEM_0f },
    { HSP_SCHED_L0_ACCUM_COMP_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L0_ACCUM_COMP_MEM_0f },
    { HSP_SCHED_L0_CREDIT_MEM_0m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L0_CREDITMEM_0f },
    { HSP_SCHED_L2_ACCUM_COMP_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L2_ACCUM_COMP_MEM_1f },
    { HSP_SCHED_L2_CREDIT_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L2_CREDITMEM_1f },
    { HSP_SCHED_L1_ACCUM_COMP_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L1_ACCUM_COMP_MEM_1f },
    { HSP_SCHED_L1_CREDIT_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L1_CREDITMEM_1f },
    { HSP_SCHED_L0_ACCUM_COMP_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L0_ACCUM_COMP_MEM_1f },
    { HSP_SCHED_L0_CREDIT_MEM_1m, PARITY_ENr, ES_PARITY_ENf, HSP_EN_COR_ERR_RPTr, L0_CREDITMEM_1f },

    /* MMU_THDM_DB_EN_COR_ERR_RPTr */
    { MMU_THDM_DB_QUEUE_RESUME_1m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_DB_EN_COR_ERR_RPTr, QUEUE_RESUME_1f },
    { MMU_THDM_DB_QUEUE_RESUME_0m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_DB_EN_COR_ERR_RPTr, QUEUE_RESUME_0f },
    { MMU_THDM_DB_QUEUE_COUNT_1m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_DB_EN_COR_ERR_RPTr, QUEUE_COUNT_1f },
    { MMU_THDM_DB_QUEUE_COUNT_0m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_DB_EN_COR_ERR_RPTr, QUEUE_COUNT_0f },

    /* MMU_THDM_MCQE_EN_COR_ERR_RPTr */
    { MMU_THDM_MCQE_QUEUE_RESUME_1m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_MCQE_EN_COR_ERR_RPTr, QUEUE_RESUME_1f },
    { MMU_THDM_MCQE_QUEUE_RESUME_0m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_MCQE_EN_COR_ERR_RPTr, QUEUE_RESUME_0f },
    { MMU_THDM_MCQE_QUEUE_COUNT_1m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_MCQE_EN_COR_ERR_RPTr, QUEUE_COUNT_1f },
    { MMU_THDM_MCQE_QUEUE_COUNT_0m, PARITY_ENr, THDM_PARITY_ENf, MMU_THDM_MCQE_EN_COR_ERR_RPTr, QUEUE_COUNT_0f },

    /* MMU_EPRG_EN_COR_ERR_RPTr */
    { MMU_EPRG_MEMm, PARITY_ENr, EPRG_PARITY_ENf, MMU_EPRG_EN_COR_ERR_RPTr, EPRG_MEMf },

    /* MMU_ENQ_EN_COR_ERR_RPTr */
    { MMU_ENQ_PBI_DBm, PARITY_ENr, ENQ_PARITY_ENf, MMU_ENQ_EN_COR_ERR_RPTr, SOP_INFO0f },

    /* RQE_EN_COR_ERR_RPTr */
    { REPLICATION_FIFO_BANK0m, PARITY_ENr, RQE_PARITY_ENf, RQE_EN_COR_ERR_RPTr, RFf },
    { REPLICATION_FIFO_BANK1m, PARITY_ENr, RQE_PARITY_ENf, RQE_EN_COR_ERR_RPTr, RFf },
    { RQE_FREE_LISTm, PARITY_ENr, RQE_PARITY_ENf, RQE_EN_COR_ERR_RPTr, FLf },
    { RQE_LINK_LISTm, PARITY_ENr, RQE_PARITY_ENf, RQE_EN_COR_ERR_RPTr, LLf },

    { INVALIDm } /* end */
};


#ifdef BCM_TRIDENT2PLUS_SUPPORT
static int _mmu_16_mode = 0;

#define _SOC_TD2P_SER_TYPE_REG 0
#define _SOC_TD2P_SER_TYPE_MEM 1
#define _SOC_TD2P_SER_TYPE_BUS 2
#define _SOC_TD2P_SER_TYPE_BUF 3

#ifdef BCM_56860_A0
/* These are now generated from the regsfile processing into bcm56860_a0.c */
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_ip_mem_ser_info[];
extern _soc_reg_ser_en_info_t _soc_bcm56860_a0_ip_reg_ser_info[];
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_ep_mem_ser_info[];
extern _soc_reg_ser_en_info_t _soc_bcm56860_a0_ep_reg_ser_info[];
extern _soc_mem_ser_en_info_t _soc_bcm56860_a0_mmu_mem_ser_info[];
/* Above structures are defined in chip.h */
#endif

/* Setup dynamically in enable ser */
static uint32 _soc_td2p_ip_pipe_fifo_bmask[] = {
    0, 0, 0, 0
};

_soc_bus_ser_en_info_t _soc_ep_bus_ser_info [] = {
    { "EFP",     EFP_PARITY_CONTROLr,      EFP_BUS_PARITY_ENf     },
    { "EFPPARS", EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf },
    { "EHCPM",   EGR_EHCPM_SER_CONTROLr,   EHCPM_BUS_PARITY_ENf },
    { "EPMOD",   EGR_EPMOD_SER_CONTROLr,   EPMOD_BUS_PARITY_ENf },
    { "EVLAN",   EGR_VLAN_SER_CONTROLr,    EVLAN_BUS_PARITY_ENf },
    { "", INVALIDr } /* end */ 
};

_soc_buffer_ser_en_info_t _soc_ep_buffer_ser_info[] = {
    { "INITBUF", EGR_EL3_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf },
    { "EGR MPB",  EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf },
    { "EDB_CM_MEM", EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf },
    { "XLP15_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP15_ECC_ENf },
    { "XLP14_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP14_ECC_ENf },
    { "XLP13_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP13_ECC_ENf },
    { "XLP12_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP12_ECC_ENf },
    { "XLP11_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP11_ECC_ENf },
    { "XLP10_CELL_BUF", EGR_EDATABUF_PARITY_CONTROLr, XLP10_ECC_ENf },
    { "XLP9_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP9_ECC_ENf  },
    { "XLP8_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP8_ECC_ENf  },
    { "XLP7_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP7_ECC_ENf  },
    { "XLP6_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP6_ECC_ENf  },
    { "XLP5_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP5_ECC_ENf  },
    { "XLP4_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP4_ECC_ENf  },
    { "XLP3_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP3_ECC_ENf  },
    { "XLP2_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP2_ECC_ENf  },
    { "XLP1_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf  },
    { "XLP0_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf  },
    { "CLP3_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP3_ECC_ENf  },
    { "CLP2_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP2_ECC_ENf  },
    { "CLP1_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf  },
    { "CLP0_CELL_BUF",  EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf  },
    { "EP_XLP15_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP15_ECC_ENf },
    { "EP_XLP14_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP14_ECC_ENf },
    { "EP_XLP13_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP13_ECC_ENf },
    { "EP_XLP12_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP12_ECC_ENf },
    { "EP_XLP11_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP11_ECC_ENf },
    { "EP_XLP10_DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP10_ECC_ENf },
    { "EP_XLP9__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP9_ECC_ENf  },
    { "EP_XLP8__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP8_ECC_ENf  },
    { "EP_XLP7__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP7_ECC_ENf  },
    { "EP_XLP6__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP6_ECC_ENf  },
    { "EP_XLP5__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP5_ECC_ENf  },
    { "EP_XLP4__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP4_ECC_ENf  },
    { "EP_XLP3__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP3_ECC_ENf  },
    { "EP_XLP2__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP2_ECC_ENf  },
    { "EP_XLP1__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP1_ECC_ENf  },
    { "EP_XLP0__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, XLP0_ECC_ENf  },
    { "EP_CLP3__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP3_ECC_ENf  },
    { "EP_CLP2__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP2_ECC_ENf  },
    { "EP_CLP1__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP1_ECC_ENf  },
    { "EP_CLP0__DATABUF_CONTROL_INFO", EGR_EDB_CTRL_PARITY_ENr, CLP0_ECC_ENf  },


    { "", INVALIDr }
};


_soc_bus_ser_en_info_t _soc_ip_bus_ser_info [] = {
    { "IPARS", IPARS_SER_CONTROLr, IPARS_BUS_PARITY_ENf },
    { "IRSEL1", IRSEL1_SER_CONTROLr, IRSEL1_BUS_PARITY_ENf },
    { "IRSEL2", IRSEL2_SER_CONTROLr, IRSEL2_BUS_PARITY_ENf },
    { "ISW1", ISW1_SER_CONTROLr, ISW1_BUS_PARITY_ENf },
    { "IVXLT", IVXLT_SER_CONTROLr, IVXLT_BUS_PARITY_ENf },
    { "LEARN_FIFO", IARB_SER_CONTROLr, LEARN_FIFO_ECC_ENf },
    { "MPLS", MPLS_SER_CONTROLr, MPLS_BUS_PAR_ENf, },
    { "SW2_EOP_BUF_C", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf },
    { "SW2_EOP_BUF_B", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf },
    { "SW2_EOP_BUF_A", ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf },
    { "VP", VP_SER_CONTROLr, VP_BUS_PAR_ENf },
    { "IFP", IFP_PARITY_CONTROLr, IFP_BUS_PARITY_ENf },
    { "IL2L3", IL2L3_BUS_SER_CONTROLr, PARITY_ENf },
    { "", INVALIDr } /* end */ 
};

_soc_buffer_ser_en_info_t _soc_ip_buffer_ser_info[] = {
    { "COUNTER_STAGING", IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf },
    { "METER_STAGING", IFP_PARITY_CONTROLr, METER_MUX_DATA_STAGING_PARITY_ENf },
    { "CMIC", IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf },
    { "IP STATS COUNTERS", ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf },
    { "RDISC/RUC/RPORTD/RDBGC0", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf },
    { "HG STATS COUNTERS", ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf },
    { "RDBGC5/RDBGC6/RDBGC7/RDBGC8", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf },
    { "RDBGC1/RDBGC2/RDBGC3/RDBGC4", ISW2_SER_CONTROL_1r, RDBGC_MEM_INST1_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_ERRe", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_FRWD", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf },
    { "ING_NIV_RX_FRAMES_VLAN", ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf },
    { "ING_TRILL_RX_ACCESS", ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { "ING_TRILL_RX_NETWORK_PORT", ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { "ING_TRILL_RX_PKTS table", ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf },
    { "DLB_HGT_FLOWSET_TIME", DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf },
    { "DLB_HGT_FLOWSET", DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_PARITY_ENf },

    { "", INVALIDr }
};

_soc_buffer_ser_en_info_t _soc_mmu_buffer_ser_info[] = {
    { "MMU EPRG", PARITY_ENr, EPRG_PARITY_ENf }, 
    { "MMU PQE", PARITY_ENr, PQE_PARITY_ENf }, 
    { "MMU WRED", PARITY_ENr, WRED_PARITY_ENf }, 
    { "MMU CTR", PARITY_ENr, CTR_PARITY_ENf }, 

    { "", INVALIDr }
};

typedef struct _soc_td2p_ser_block_info_s {
    int         type;
    soc_block_t blocktype;
    char        name[16];
    soc_reg_t   fifo_reset_reg;
    void        *info;
} _soc_td2p_ser_block_info_t;

static const
_soc_td2p_ser_block_info_t _soc_td2p_ser_block_info[] = {
#ifdef BCM_56860_A0
    { _SOC_TD2P_SER_TYPE_REG, SOC_BLK_IPIPE, "IPIPE regs", INVALIDr, _soc_bcm56860_a0_ip_reg_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_IPIPE, "IPIPE mems", ING_SER_FIFO_CTRLr, _soc_bcm56860_a0_ip_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_BUS, SOC_BLK_EPIPE, "IPIPE buses",INVALIDr, _soc_ip_bus_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_EPIPE, "IPIPE buff" ,INVALIDr, _soc_ip_buffer_ser_info },
    { _SOC_TD2P_SER_TYPE_REG, SOC_BLK_EPIPE, "EPIPE regs", INVALIDr, _soc_bcm56860_a0_ep_reg_ser_info },
    { _SOC_TD2P_SER_TYPE_BUS, SOC_BLK_EPIPE, "EPIPE buses",INVALIDr, _soc_ep_bus_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_EPIPE, "EPIPE buff" ,INVALIDr, _soc_ep_buffer_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_EPIPE, "EPIPE mems", EGR_SER_FIFO_CTRLr, _soc_bcm56860_a0_ep_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_MEM, SOC_BLK_MMU,   "MMU mems", INVALIDr, _soc_bcm56860_a0_mmu_mem_ser_info },
    { _SOC_TD2P_SER_TYPE_BUF, SOC_BLK_MMU,   "MMU buff", INVALIDr, _soc_mmu_buffer_ser_info },
#endif
    { -1, 0 }
};

int
_soc_trident2p_ser_enable_all(int unit, const _soc_td2p_ser_block_info_t *ser_block_info, int enable)
{
    uint8                           rbi, bcount, type;
    uint16                          pcount;
    uint32                          cmic_rval;
    uint32                          rval, cmic_bit;
    int                             port = REG_PORT_ANY;
    int                             phy_port, cport, slot_port, obm_slot;
    int                             rv, block_info_idx;
    uint64                          rval64;
    soc_reg_t                       reg, ecc1b_reg;
    soc_field_t                     field, ecc1b_field;
    _soc_reg_ser_en_info_t          *reg_info;
    _soc_mem_ser_en_info_t          *mem_info;
    _soc_bus_ser_en_info_t          *bus_info;
    _soc_buffer_ser_en_info_t       *buf_info;
    char                            *str_type;
    char                            *str_name;
    const _soc_td2_ser_route_block_t *rb;
    static char *parity_module_str[4] = {"REG", "MEM", "BUS", "BUF"};
    soc_info_t *si = &SOC_INFO(unit);

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));
    /* Enable new fifo mechanism based SER stuff */
    for (bcount = 0; ser_block_info[bcount].blocktype; bcount++) {
        int done = 0;

        LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                   (BSL_META_U(unit,
                               "Unit %d SER enable for: %s\n"),
                                    unit, ser_block_info[bcount].name));

        type = ser_block_info[bcount].type;
        reg_info = (_soc_reg_ser_en_info_t*)ser_block_info[bcount].info;
        mem_info = (_soc_mem_ser_en_info_t*)ser_block_info[bcount].info;
        bus_info = (_soc_bus_ser_en_info_t*)ser_block_info[bcount].info;
        buf_info = (_soc_buffer_ser_en_info_t*)ser_block_info[bcount].info;
        for (pcount = 0; ; pcount++) {
            ecc1b_reg = INVALIDr;    
            ecc1b_field = INVALIDf;
            switch (type) {
            case _SOC_TD2P_SER_TYPE_REG: 
                if (reg_info[pcount].reg == INVALIDr) { 
                    done = 1;
                } else {
                    reg = reg_info[pcount].en_reg;
                    field = reg_info[pcount].en_fld;
                    str_name = SOC_REG_NAME(unit, reg_info[pcount].reg);
                }
                break;
            case _SOC_TD2P_SER_TYPE_MEM:
                if (mem_info[pcount].mem == INVALIDm) { 
                    done = 1;
                } else {
                    if (soc_feature(unit, soc_feature_parity_injection_l2)) {
                        if ((mem_info[pcount].mem == L2_USER_ENTRYm) ||
                            (mem_info[pcount].mem == L2_USER_ENTRY_DATA_ONLYm)){ 
                            continue;
                        }
                    }
                    if (!SOC_MEM_IS_VALID(unit, mem_info[pcount].mem) ||
                        (SOC_MEM_INFO(unit, mem_info[pcount].mem).flags & 
                         SOC_MEM_FLAG_SER_PARITY_ENABLE_SKIP)) {
                        continue;
                    }
                    reg = mem_info[pcount].en_reg;
                    field = mem_info[pcount].en_fld;
                    ecc1b_reg = mem_info[pcount].ecc_1b_report_en_reg;
                    ecc1b_field = mem_info[pcount].ecc_1b_report_en_fld;
                    str_name = SOC_MEM_NAME(unit, mem_info[pcount].mem);
                }
                break;
            case _SOC_TD2P_SER_TYPE_BUS:
                if (bus_info[pcount].en_reg == INVALIDr) { 
                    done = 1;
                } else {
                    reg = bus_info[pcount].en_reg;
                    field = bus_info[pcount].en_fld;
                    str_name = bus_info[pcount].bus_name;
                }
                break;
            case _SOC_TD2P_SER_TYPE_BUF:
                if (buf_info[pcount].en_reg == INVALIDr) {
                    done = 1;
                } else {
                    reg = buf_info[pcount].en_reg;
                    field = buf_info[pcount].en_fld;
                    str_name = buf_info[pcount].buffer_name;
                    /* Do not enable this parity check for TD2+ because if DLB_HGT_FLOWSET_TIMESTAMP_PAGE_X/Y
                       get corrupted, we DO NOT support SER and hardware will continue to send us interrupts */
                    if(reg == DLB_HGT_SER_CONTROLr && field == DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf) {
                        continue;
                    }
                }
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_MEM,
                          (BSL_META_U(unit,
                                      "Unknown parity module [bcount: %d][pcount: %d].\n"),
                                       bcount, pcount));
                return SOC_E_INTERNAL;
            }
            if (done) { 
                break;
            } else {
                str_type = parity_module_str[type];
            }
            /* NOTE: Do not use the field modify routine in the following as
                     some regs do not return the correct value due to which the
                     modify routine skips the write */
            if (SOC_REG_IS_64(unit, reg)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, port, 0, &rval64));
                soc_reg64_field32_set(unit, reg, &rval64, field, enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, port, 0, rval64));
            } else {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            if (ecc1b_reg != INVALIDr && ecc1b_field != INVALIDf) {
                if (SOC_REG_IS_64(unit, ecc1b_reg)) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_get(unit, ecc1b_reg, port, 0, &rval64));
                    soc_reg64_field32_set(unit, ecc1b_reg, &rval64, ecc1b_field, enable ? 1 : 0);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, ecc1b_reg, port, 0, rval64));
                } else {
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_get(unit, ecc1b_reg, port, 0, &rval));
                    soc_reg_field_set(unit, ecc1b_reg, &rval, ecc1b_field, enable ? 1 : 0);
                    if (20 == SOC_REG_ACC_TYPE(unit, ecc1b_reg)) {
                        int inst, pipe;
                        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
                            inst = pipe | SOC_REG_ADDR_INSTANCE_MASK;
                            SOC_IF_ERROR_RETURN
                                (soc_reg32_set(unit, ecc1b_reg, inst, 0, rval));
                        }
                    } else {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_set(unit, ecc1b_reg, port, 0, rval));
                    }
                }
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                      (BSL_META_U(unit,
                                  "SER enable for %s: %s\n"),
                                   str_type, str_name));
        }

        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == ser_block_info[bcount].blocktype) {
                /* New SER mechanism (except IP.IDB) */
                cmic_rval |= cmic_bit;
                if (rb->enable_reg != INVALIDr && rb->enable_field != INVALIDf) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
                if (rb->blocktype == SOC_BLK_IPIPE) {
                    _soc_td2p_ip_pipe_fifo_bmask[rb->pipe] |= cmic_bit;
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }

    /* TBD: The following looks exactly the same like for TD2 */

    /* Enable 1B error reporting for some special items */
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, CMIC_BUFFER_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LEARN_FIFO_1BIT_ERROR_REPORTf, enable ? 1 : 0));

    /* Loop through each place-and-route block entry to enable legacy style SER stuff */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            cmic_rval |= cmic_bit;
        }

        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (rb->enable_reg != INVALIDr) {
            if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block,
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    continue;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rval64));
        }

        /*Find physical port number for the specified port */
        /* coverity[negative_returns: FALSE] */
        phy_port = si->port_l2p_mapping[port];

        /*Find the group and slot according to the physical port*/
        cport = phy_port / _TD2_PORTS_PER_PGW;
        slot_port = (phy_port % _TD2_PORTS_PER_PGW) / _TD2_XLPS_PER_PGW;

        /*If PGW number is even, the xlports are positive sequence */
        if((cport % 2) == 0) {
            obm_slot = slot_port;
        }else{
            /*If PGW number is odd, the xlports are reverse sequence */
            obm_slot = 3 - slot_port;
        }

        switch (obm_slot) {
            case 0:
                rb->info[0].enable_reg = PGW_OBM0_ECC_ENABLEr;
                break;
            case 1:
                rb->info[0].enable_reg = PGW_OBM1_ECC_ENABLEr;
                break;
            case 2:
                rb->info[0].enable_reg = PGW_OBM2_ECC_ENABLEr;
                break;
            case 3:
                rb->info[0].enable_reg = PGW_OBM3_ECC_ENABLEr;
                break;
            default:
                break;
        }

        rv = _soc_trident2_ser_enable_info(unit, block_info_idx, rb->id, port,
                                           rb->enable_reg, &rval64,
                                           rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        if (rb->enable_reg != INVALIDr) {
            /* Write per route block parity enable register */
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rval64));
        }
    }

    if (enable) {
        /* MMU enables */
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

#endif

STATIC int
_soc_trident2_ser_enable_cport(int unit, int inst, const _soc_td2_ser_info_t *info,
                               soc_mem_t mem, int enable)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }

    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->enable_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));

    SOC_IF_ERROR_RETURN
        (_soc_trident2_ser_enable_info(unit, block_info_idx, inst, port,
                                       port_reg, &port_rval,
                                       info->info, mem, enable));

    SOC_IF_ERROR_RETURN(soc_reg_set(unit, port_reg, port, 0, port_rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_mmu_1bit_ecc(int unit, int enable)
{
    int i, f;
    uint64 rval64;
    uint32 rval;
    soc_field_info_t *fieldp;
    soc_reg_info_t   *regp;
    soc_reg_t reg;
    
    soc_reg_t _1b_reg_list[] = {
        MMU_CCP_EN_COR_ERR_RPTr,
        MMU_CFAP_EN_COR_ERR_RPTr,
        MMU_DEQ_EN_COR_ERR_RPTr,
        MMU_ENQ_EN_COR_ERR_RPTr,
        MMU_EPRG_EN_COR_ERR_RPTr,
        INTFI_EN_COR_ERR_RPTr,
        ES_PIPE0_LLS_EN_COR_ERR_RPT_1r,
        ES_PIPE0_LLS_EN_COR_ERR_RPT_2r,
        ES_PIPE1_LLS_EN_COR_ERR_RPT_1r,
        ES_PIPE1_LLS_EN_COR_ERR_RPT_2r,
        MMU_PQE_EN_COR_ERR_RPTr,
        MMU_QCN_EN_COR_ERR_RPTr,
        RQE_EN_COR_ERR_RPTr,
        MMU_TDM_EN_COR_ERR_RPTr,
        THDI_EN_COR_ERR_RPTr,
        MMU_THDM_DB_EN_COR_ERR_RPTr,
        MMU_THDM_MCQE_EN_COR_ERR_RPTr,
        MMU_THDU_EN_COR_ERR_RPTr,
        MMU_TOQ_EN_COR_ERR_RPTr,
        HSP_EN_COR_ERR_RPTr
    };
    for (i = 0; i < COUNTOF(_1b_reg_list); i++) {
        reg = _1b_reg_list[i];
        regp = &(SOC_REG_INFO(unit, reg));
        if (SOC_REG_IS_64(unit, reg)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
            for (f = 0; f < regp->nFields; f++) {
                fieldp = &(regp->fields[f]);
                soc_reg64_field32_set(unit, reg, &rval64, fieldp->field,
                                      enable ? 1 : 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, REG_PORT_ANY, 0, rval64));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            for (f = 0; f < regp->nFields; f++) {
                fieldp = &(regp->fields[f]);
                soc_reg_field_set(unit, reg, &rval, fieldp->field,
                                  enable ? 1 : 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable)
{
    const _soc_td2_ser_info_t *info;
    int info_index, rv, rv1;
    soc_reg_t reg;
    uint32 rval;
    uint64 rval64;

    rv = SOC_E_NOT_FOUND;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        if (mem != INVALIDm && info->mem != mem) {
            continue;
        }

        rv = SOC_E_NONE;

        /* Enable the info entry in the group register */
        if (info->group_reg_enable_field != INVALIDf) {
            soc_reg64_field32_set(unit, group_reg, group_rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                break;
            }
            if (SOC_REG_IS_64(unit, reg)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, port, 0, &rval64));
                soc_reg64_field32_set(unit, reg, &rval64, info->enable_field,
                                      enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, port, 0, rval64));
            } else {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                  enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of enable tree structure */
            rv1 = _soc_trident2_ser_enable_cport(unit, inst, info, mem, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            rv1 = _soc_trident2_ser_enable_mmu_1bit_ecc(unit, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"), 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        case _SOC_PARITY_TYPE_START_ERR:
        case _SOC_PARITY_TYPE_BST:
            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem)));
        default:
            break;
        } /* Handle different parity error reporting style */
        if (mem != INVALIDm) {
            break;
        }

    } /* Loop through each info entry in the route block */

    return rv;
}

int
soc_trident2_l3_memwr_parity_check(int unit, soc_mem_t mem, int disable)
{
    uint32      rval;
    soc_field_t disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
    soc_reg_t   disable_reg;

    switch (mem) {
    case L3_ENTRY_ONLYm:
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
        disable_reg = L3_ENTRY_PARITY_CONTROLr;
        break;
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
    case L3_DEFIP_ALPM_RAWm:
        disable_reg = ILPM_SER_CONTROLr;
        break;
    default:
        return SOC_E_PARAM;
    }

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, disable_reg, REG_PORT_ANY, 0, &rval));
    soc_reg_field_set(unit, disable_reg, &rval, disable_field, disable ? 1 : 0);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, disable_reg, REG_PORT_ANY, 0, rval));

    return SOC_E_NONE;
}

/* The DISABLE_SBUS_MEMWR_PARITY_CHECK bit should be set to 0 by default */
STATIC int
_soc_trident2_sram_memwr_parity_check_init(int unit)
{
    uint32      rval, raddr;
    int         block, i, count;
    uint8       at;
    soc_field_t disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
    soc_reg_t   disable_regs[] =
        {
        VLAN_XLATE_DBGCTRL_0r,
        L2_ENTRY_PARITY_CONTROLr,
        L3_ENTRY_PARITY_CONTROLr,
        ILPM_SER_CONTROLr,
        EGR_VLAN_XLATE_CONTROLr
        };

    count = COUNTOF(disable_regs);

    for (i = 0; i < count; i++) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, disable_regs[i], REG_PORT_ANY, 0, &rval));

        soc_reg_field_set(unit, disable_regs[i], &rval, disable_field, 0);
        raddr = soc_reg_addr_get(unit, disable_regs[i], REG_PORT_ANY, 0,
                                 SOC_REG_ADDR_OPTION_WRITE, &block, &at);
        /* The original access type of VLAN_XLATE_CONTROL_0 is 6, but the
         * register also can support access type 3 to set the value on both
         * X Y pipes in same time. To simplify the initializing procedure,
         * here access type 3 is always applied.
         */
        if (!SAL_BOOT_SIMULATION) {
            at = 3;
        }
        SOC_IF_ERROR_RETURN(_soc_reg32_set(unit, block, at, raddr, rval));
    }

    return SOC_E_NONE;
}


STATIC int
_soc_trident2_ser_enable_all(int unit, int enable)
{
    int         rv, block_info_idx;
    int         phy_port, cport, slot_port, obm_slot, port = REG_PORT_ANY;
    int         egress = 0;
    uint8       rbi, bcount;
    uint16      pcount;
    uint32      rval, cmic_bit, cmic_rval;
    uint64      rb_rval64;
    soc_reg_t   reg, reg_enable;
    soc_field_t field;
    const       _soc_td2_ser_route_block_t *rb;
    soc_info_t *si = &SOC_INFO(unit);
    soc_mem_t   mem;
    
    _soc_trident2_sram_memwr_parity_check_init (unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(_soc_trident2p_ser_enable_all ( unit, _soc_td2p_ser_block_info, enable ));
        return SOC_E_NONE;
    }
#endif

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));

    /* Enable new fifo mechanism based SER stuff */
    for (bcount = 0; _soc_td2_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0;
             _soc_td2_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
             pcount++) {
            reg_enable = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
            field = _soc_td2_ser_block_info[bcount].info[pcount].enable_field;

            if(!SOC_REG_IS_VALID(unit, reg_enable)) {
                continue;
            }

            if (SOC_BLK_IPIPE == _soc_td2_ser_block_info[bcount].blocktype) {
                egress = 0;
            } else {
                egress = 1;
            }
            if (enable) {
                if (1 == _soc_td2_ser_block_info[bcount].info[pcount].type) { /* register */
                    reg = _soc_td2_ser_block_info[bcount].info[pcount].reg;
                    if (!SOC_REG_IS_VALID(unit, reg)) {
                        continue;
                    }
                } 
                if (0 == _soc_td2_ser_block_info[bcount].info[pcount].type) { /* mem */
                    mem = _soc_td2_ser_block_info[bcount].info[pcount].mem;
                    if (!SOC_MEM_IS_VALID(unit, mem) ||
                        ((mem != INVALIDm) && 
                         ((SOC_MEM_INFO(unit, mem).flags & 
                           SOC_MEM_FLAG_SER_PARITY_ENABLE_SKIP)))) {
                        continue;
                    }
                }
                if ((2 == _soc_td2_ser_block_info[bcount].info[pcount].type) ||
                    (3 == _soc_td2_ser_block_info[bcount].info[pcount].type)) { /* bus or internal buffer */
                    reg = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
                    if (!SOC_REG_IS_VALID(unit, reg)) {
                        continue;
                    }
                }

            }
            /*set reg according to the acctype, prevent only set pipe x when acctype is 6*/
            soc_trident2_ser_enable_by_acctype(unit, reg_enable, field, enable, egress);
            
            switch (_soc_td2_ser_block_info[bcount].info[pcount].type) {
            case 0:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for mem: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].mem != INVALIDm ?
                             SOC_MEM_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].mem) :
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            case 1:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for reg: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].reg != INVALIDr ?
                             SOC_REG_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].reg) :
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            case 2:
                LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                            (BSL_META_U(unit,
                                        "SER enable for bus: %s\n"),
                             _soc_td2_ser_block_info[bcount].info[pcount].name_str)); 
                break;
            default: break;
            }
        }

        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == _soc_td2_ser_block_info[bcount].blocktype) {
                /* New SER mechanism */
                cmic_rval |= cmic_bit;
                if (rb->enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (_soc_td2_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }
    
    /* Enable 1B error reporting for some special items */
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LPORT_TABLEf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, SRC_TRUNKf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, CMIC_BUFFER_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LEARN_FIFO_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, ICFG_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, PORT_TABLEf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, EGR_EFPPARS_PARITY_CONTROLr, 
                                 REG_PORT_ANY, EGR_1588_LINK_DELAY_PARITY_ENf, enable ? 1 : 0));
    
    /* Loop through each place-and-route block entry to enable legacy style SER stuff */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            cmic_rval |= cmic_bit;
        }
        
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
            SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                continue;
        }
        if (rb->blocktype == SOC_BLK_PGW_CL) {
            /*Find physical port number for the specified port */
            /* coverity[negative_returns: FALSE] */
            phy_port = si->port_l2p_mapping[port];

            /*Find the group and slot according to the physical port*/
            cport = phy_port / _TD2_PORTS_PER_PGW;
            slot_port = (phy_port % _TD2_PORTS_PER_PGW) / _TD2_XLPS_PER_PGW;

            /*If PGW number is even, the xlports are positive sequence */
            if((cport % 2) == 0) {
                obm_slot = slot_port;
            }else{
                /*If PGW number is odd, the xlports are reverse sequence */
                obm_slot = 3 - slot_port;
            }

            switch (obm_slot) {
                case 0:
                    rb->info[0].enable_reg = PGW_OBM0_ECC_ENABLEr;
                    break;
                case 1:
                    rb->info[0].enable_reg = PGW_OBM1_ECC_ENABLEr;
                    break;
                case 2:
                    rb->info[0].enable_reg = PGW_OBM2_ECC_ENABLEr;
                    break;
                case 3:
                    rb->info[0].enable_reg = PGW_OBM3_ECC_ENABLEr;
                    break;
                default:
                    break;
            }
        }

        SOC_IF_ERROR_RETURN
            (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_rval64));        
        rv = _soc_trident2_ser_enable_info(unit, block_info_idx, rb->id, port,
                                           rb->enable_reg, &rb_rval64,
                                           rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        /* Write per route block parity enable register */
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, rb->enable_reg, port, 0, rb_rval64));
    }
    if (enable) {
        /* MMU enables */
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

void 
_soc_trident2_mem_rename(soc_mem_t *memory)
{
    switch(*memory) {
        case EGR_FRAGMENT_ID_TABLE_Xm:
        case EGR_FRAGMENT_ID_TABLE_Ym:
            *memory = EGR_FRAGMENT_ID_TABLEm;
            break;
            
        case EFP_COUNTER_TABLE_Xm:
        case EFP_COUNTER_TABLE_Ym:
            *memory = EFP_COUNTER_TABLEm;
            break;
            
        case EGR_PERQ_XMT_COUNTERS_Xm:
        case EGR_PERQ_XMT_COUNTERS_Ym:
            *memory = EGR_PERQ_XMT_COUNTERSm;
            break;
            
        case EFP_METER_TABLE_Xm:
        case EFP_METER_TABLE_Ym:
            *memory = EFP_METER_TABLEm;
            break;
            
        case EGR_PW_INIT_COUNTERS_Xm:
        case EGR_PW_INIT_COUNTERS_Ym:
            *memory = EGR_PW_INIT_COUNTERSm;
            break;
            
        case FP_COUNTER_TABLE_Xm:
        case FP_COUNTER_TABLE_Ym:
            *memory = FP_COUNTER_TABLEm;
            break;

        case FP_STORM_CONTROL_METERS_Xm:
        case FP_STORM_CONTROL_METERS_Ym:
            *memory = FP_STORM_CONTROL_METERSm;
            break;
            
        case DLB_HGT_FLOWSET_Xm:
        case DLB_HGT_FLOWSET_Ym:
            *memory = DLB_HGT_FLOWSETm;
            break;

        case DLB_HGT_FLOWSET_TIMESTAMP_PAGE_Xm:
        case DLB_HGT_FLOWSET_TIMESTAMP_PAGE_Ym:
            *memory = DLB_HGT_FLOWSET_TIMESTAMP_PAGEm;
            break;
            
        case ING_PW_TERM_SEQ_NUM_Xm:
        case ING_PW_TERM_SEQ_NUM_Ym:
            *memory = ING_PW_TERM_SEQ_NUMm;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_0_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_0_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_0m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_1_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_1_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_1m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_2_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_2_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_2m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_3_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_3_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_3m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_4_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_4_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_4m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_5_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_5_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_5m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_6_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_6_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_6m;
            break;
        case ING_FLEX_CTR_COUNTER_TABLE_7_Xm:
        case ING_FLEX_CTR_COUNTER_TABLE_7_Ym:
            *memory = ING_FLEX_CTR_COUNTER_TABLE_7m;
            break;
        case EGR_FLEX_CTR_COUNTER_TABLE_0_Xm:
        case EGR_FLEX_CTR_COUNTER_TABLE_0_Ym:
            *memory = EGR_FLEX_CTR_COUNTER_TABLE_0m;
            break;
        case EGR_FLEX_CTR_COUNTER_TABLE_1_Xm:
        case EGR_FLEX_CTR_COUNTER_TABLE_1_Ym:
            *memory = EGR_FLEX_CTR_COUNTER_TABLE_1m;
            break;
        case EGR_FLEX_CTR_COUNTER_TABLE_2_Xm:
        case EGR_FLEX_CTR_COUNTER_TABLE_2_Ym:
            *memory = EGR_FLEX_CTR_COUNTER_TABLE_2m;
            break;
        case EGR_FLEX_CTR_COUNTER_TABLE_3_Xm:
        case EGR_FLEX_CTR_COUNTER_TABLE_3_Ym:
            *memory = EGR_FLEX_CTR_COUNTER_TABLE_3m;
            break;
        default:
            break;
    }
}

STATIC int
soc_trident2_ser_enable_by_acctype(int unit, soc_reg_t reg, 
                                                soc_field_t field, int enable,
                                                int egress)
{
    uint32  flags = 0;
    uint32  rval = 0;
    int     port = REG_PORT_ANY;
    int     rv = SOC_E_NONE;
    
    flags = SOC_REG_ACC_TYPE(unit, reg);
    if (_SOC_ACC_TYPE_PIPE_SBS == flags) {
        IP_ARBITER_LOCK(unit);
        /*set pipe x*/
        soc_trident2_pipe_select(unit, egress, 0);
        rv = soc_reg32_get(unit, reg, port, 0, &rval);
        if (rv != SOC_E_NONE) {
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        rv = soc_reg32_set(unit, reg, port, 0, rval);
        if (rv != SOC_E_NONE) {
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        
        /*set pipe y*/
        soc_trident2_pipe_select(unit, egress, 1);
        rv = soc_reg32_get(unit, reg, port, 0, &rval);
        if (rv != SOC_E_NONE) {
            soc_trident2_pipe_select(unit, egress, 0);
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        rv = soc_reg32_set(unit, reg, port, 0, rval);
        if (rv != SOC_E_NONE) {
            soc_trident2_pipe_select(unit, egress, 0);
            IP_ARBITER_UNLOCK(unit);
            return rv;
        }
    
        soc_trident2_pipe_select(unit, egress, 0);
        IP_ARBITER_UNLOCK(unit);
    } else {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        if (soc_reg_field_valid(unit, reg, field)) {
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, rval));
    }

    return rv;
}

int
soc_trident2_mem_parity_control(int unit, soc_mem_t mem, int copyno, 
                                            int enable)
{
    int             bcount = 0;
    int             pcount = 0;
    int             egress = 0;
    int             rv = SOC_E_NONE;
    uint8           rbi = 0;
    uint32          rval = 0;
    uint32          cmic_rval = 0;
    soc_reg_t       reg;
    soc_field_t     field;
    const _soc_td2_ser_route_block_t *rb;

    _soc_trident2_mem_rename(&mem);
    
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));
    
    for (bcount = 0; _soc_td2_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0; 
            _soc_td2_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
            pcount++) {
            if (_soc_td2_ser_block_info[bcount].info[pcount].mem == mem) {
                if (enable) {
                    if(!SOC_MEM_IS_VALID(unit, mem) ||
                       ((mem != INVALIDm) && 
                        ((SOC_MEM_INFO(unit, mem).flags & 
                          SOC_MEM_FLAG_SER_PARITY_ENABLE_SKIP)))) {
                        rv = SOC_E_UNAVAIL;
                        return rv;
                    }
                }
                reg = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
                field = _soc_td2_ser_block_info[bcount].info[pcount].enable_field;

                if (SOC_BLK_IPIPE == _soc_td2_ser_block_info[bcount].blocktype) {
                    egress = 0;
                } else {
                    egress = 1;
                }

                /*set reg according to the acctype, prevent only set pipe x when acctype is 6*/
                rv = soc_trident2_ser_enable_by_acctype(unit, reg, field, enable, egress);
                if (SOC_FAILURE(rv)) {
                    return rv;
                }
            }
        }
        
        if (_soc_td2_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }

    if ((rv == SOC_E_NONE) && (SOC_MEM_IS_VALID(unit, mem)) &&
        (SOC_BLOCK_TYPE(unit, SOC_MEM_BLOCK_ANY(unit, mem))) == SOC_BLK_MMU) {
        /* MMU controls */      
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            if (rb->cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == SOC_BLK_MMU) {
                cmic_rval |= rb->cmic_bit;
            }
        }
        
        if (enable) {
            /* MMU enables */
            /* TD-3384 */
            SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
            (void)soc_cmicm_intr2_enable(unit, cmic_rval);
        } else {
            /* MMU disables */
            SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
            /* TD-3384 */
            SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            (void)soc_cmicm_intr2_disable(unit, cmic_rval);
        }
    }

    return rv;
}

STATIC int
_soc_trident2_clear_mmu_memory(int unit, soc_mem_t mem)
{
    int i, count;
    static soc_mem_t mmu_mems[] = {
        MMU_INTFI_XPIPE_FC_MAP_TBL2m,
        MMU_INTFI_YPIPE_FC_MAP_TBL2m
    };

    count = COUNTOF(mmu_mems);
    /* MMU mem clear to avoid SER issue */
    for (i = 0; i < count; i++) {
        if (mem != INVALIDm) {
            if (mem == mmu_mems[i]) {
                SOC_IF_ERROR_RETURN
                    (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
                break;
            }
        } else {
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mmu_init_default_val(int unit)
{
    soc_mem_t           mem0, mem1;
    uint32              entry[SOC_MAX_MEM_WORDS];
    int                 index, unused_idx;

    /* Set LLS_Port memory. Point to Un-used L0 node.*/
    mem0 = ES_PIPE0_LLS_PORT_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_PORT_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 267;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }

    /* Set LLS_L0 memory. Point to Un-used L1 node.*/
    mem0 = ES_PIPE0_LLS_L0_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L0_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1023;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }

    /* Set LLS_L1 memory. Point to Un-used L2 child.*/
    mem0 = ES_PIPE0_LLS_L1_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L1_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1479;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_ser_control(int unit, soc_mem_t mem, int copyno,
                              int enable)
{
    if (enable) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr,
                                           REG_PORT_ANY, TOP_MMU_RST_Lf, 0));
        sal_usleep(1000);
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr,
                                           REG_PORT_ANY, TOP_MMU_RST_Lf, 1));
        sal_usleep(1000);
    }
    if (soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, INVALIDm));
        SOC_IF_ERROR_RETURN(_soc_trident2_ser_enable_all(unit, enable));
    }
    if (enable) {
        SOC_IF_ERROR_RETURN
            (_soc_trident2_mmu_init_default_val(unit));
    }
    return SOC_E_NONE;
}

STATIC void
_soc_td2_mem_parity_info(int unit, int block_info_idx, int pipe,
                         soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_info_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

STATIC int
_soc_td2_populate_ser_log(int unit, soc_reg_t parity_enable_reg,
                          soc_field_t parity_enable_field,
                          soc_mem_t mem,
                          int mem_block,
                          soc_acc_type_t acc_type,
                          int index,
                          sal_usecs_t detect_time,
                          uint32 sblk,
                          uint32 address,
                          int pipe,
                          int is_physical_index)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS];
    int log_entry_size, id, entry_dw;
    uint32 *cache;
    uint32 flags = SOC_MEM_NO_FLAGS;
    uint8 *vmap;
    soc_ser_log_tlv_memory_t log_mem;
    soc_ser_log_tlv_generic_t log_generic;

    sal_memset(&log_generic, 0, sizeof(log_generic));
    sal_memset(&log_mem, 0, sizeof(log_mem));

    /*
    must be large enough for at least generic and terminator, as well as the
    memory type since we might decode it in soc_ser_correction.
    */
    log_entry_size = sizeof(soc_ser_log_tlv_hdr_t)*3 +
                     sizeof(soc_ser_log_tlv_generic_t) +
                     sizeof(soc_ser_log_tlv_memory_t);

    if (mem == INVALIDm) {
        mem = soc_addr_to_mem_extended(unit, sblk, acc_type, address);
        if (mem != INVALIDm) {
            if (sblk) {
                SOC_MEM_BLOCK_ITER(unit, mem, mem_block) {
                    if (SOC_BLOCK2OFFSET(unit, mem_block) == sblk) {
                        break;
                    }
                }
            } else {
                mem_block = SOC_MEM_BLOCK_ANY(unit, mem);
            }
        }
    }
    /*
    If we have decoded the memory we can record its contents/cache
    */
    if((mem != INVALIDm) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != SOC_MEM_FLAG_SER_SPECIAL) &&
       (SOC_MEM_SER_CORRECTION_TYPE(unit, mem) != 0)) {
        entry_dw = soc_mem_entry_words(unit, mem);

        /* Check to make sure this isn't a duplicate */
        /* Search for a log entry with the same mem, and index with within the last 5 seconds */
        if (soc_ser_log_find_recent(unit, mem, index, sal_time_usecs()) > 0) {
            return 0;
        }

        log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;

        cache = SOC_MEM_STATE(unit, mem).cache[mem_block];
        vmap = SOC_MEM_STATE(unit, mem).vmap[mem_block];
        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            log_entry_size += sizeof(soc_ser_log_tlv_hdr_t) + entry_dw*4;
        }

        /* create the entry based on determined size, save id */
        id = soc_ser_log_create_entry(unit, log_entry_size);

        /* Add the memory information to the log now so we can detect duplicate errors */
        log_generic.time = detect_time;
        log_mem.memory = mem;
        log_mem.index = index;
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_MEMORY,
            sizeof(soc_ser_log_tlv_memory_t), &log_mem);
        soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_GENERIC,
            sizeof(soc_ser_log_tlv_generic_t), &log_generic);

        if ((SOC_IS_TRIDENT2(unit) || SOC_IS_TITAN2(unit))&&
             L2Xm == mem) {
            soc_l2x_selective_freeze(unit, SOC_L2X_FROZEN_WITHOUT_LOCK);
        }
        /* Disable Parity */
        if ((parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 0) < 0) {
                return 0;
            }
        }

        /* Make sure the pipe is set correctly */
        IP_ARBITER_LOCK(unit);
        if ((1 == pipe) && 
            ((_SOC_ACC_TYPE_PIPE_BCAST == acc_type) || 
             (_SOC_ACC_TYPE_PIPE_SBS == acc_type))) {
            soc_trident2_pipe_select(unit, TRUE, 1);
            soc_trident2_pipe_select(unit, FALSE, 1);
        } else {
            soc_trident2_pipe_select(unit, TRUE, 0);
            soc_trident2_pipe_select(unit, FALSE, 0);
        }

        if (is_physical_index) {
            flags = SOC_MEM_DONT_MAP_INDEX;
        }
        /* read the memory into a buffer */
        if ((1 == pipe) && 
            ((_SOC_ACC_TYPE_PIPE_BCAST == acc_type) || 
             (_SOC_ACC_TYPE_PIPE_SBS == acc_type))) {
            soc_mem_pipe_select_read(unit, flags, mem, mem_block,
                                     _SOC_ACC_TYPE_PIPE_Y, index, tmp_entry);
        } else {
            /*Enable NACK on read */
            flags |= SOC_MEM_SCHAN_ERR_RETURN;
             soc_mem_read_extended(unit, flags,
                                   mem, 0, mem_block,
                                   index, tmp_entry);
        }

        /* Make sure the pipe is set correctly */
        soc_trident2_pipe_select(unit, TRUE, 0);
        soc_trident2_pipe_select(unit, FALSE, 0);
        IP_ARBITER_UNLOCK(unit);

        /* Enable Parity */
        if ((parity_enable_reg != INVALIDr) &&
            (parity_enable_field != INVALIDf)) {
            if (soc_reg_field32_modify(unit, parity_enable_reg,
                REG_PORT_ANY, parity_enable_field, 1) < 0) {
                return 0;
            }
        }
        if ((SOC_IS_TRIDENT2(unit) || SOC_IS_TITAN2(unit)) &&
             L2Xm == mem) {
            soc_l2x_selective_thaw(unit, SOC_L2X_FROZEN_WITHOUT_LOCK);
        }

        /* fill in the memory contents tlv */
        if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CONTENTS,
            entry_dw*4, tmp_entry) < 0) {
            return 0;
        }


        if(cache != NULL && CACHE_VMAP_TST(vmap, index)) {
            /* fill in the memory cache tlv */
            if (soc_ser_log_add_tlv(unit, id, SOC_SER_LOG_TLV_CACHE,
                entry_dw*4, (cache + index*entry_dw)) < 0) {
                return 0;
            }
        }
    } else {
        id = soc_ser_log_create_entry(unit, log_entry_size);
    }

    return id;
}

STATIC int
_soc_trident2_ser_process_parity(int unit, int block_info_idx, int pipe, int port,
                                 const _soc_td2_ser_info_t *info,
                                 int schan, char *prefix_str, char *mem_str)
{
    int rv;
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s entry %d parity error\n"),
                       prefix_str, mem_str_ptr, entry_idx));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple parity errors\n"),
                           prefix_str, mem_str_ptr));
            }
            if (idx == 0 && info->mem != INVALIDm) {
                sal_memset(&spci, 0, sizeof(spci));
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN | SOC_SER_LOG_WRITE_CACHE;
                if (multiple) {
                    spci.flags |= SOC_SER_ERR_MULTI;
                }
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                spci.parity_type = info->type;
                spci.detect_time = sal_time_usecs();
                spci.log_id = _soc_td2_populate_ser_log(unit,
                                          info->enable_reg,
                                          info->enable_field,
                                          spci.mem,
                                          SOC_MEM_BLOCK_ANY(unit, spci.mem),
                                          spci.acc_type,
                                          spci.index,
                                          spci.detect_time,
                                          spci.sblk,
                                          spci.addr,
                                          pipe,
                                          FALSE);
                rv = soc_ser_correction(unit, &spci);
                if (spci.log_id != 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                       spci.log_id, 0);
                }
                if (SOC_FAILURE(rv)) {
                    /* Add reporting failed to correct event flag to
                     * application */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                            entry_idx, minfo);
                    return rv;
                }
            }
        }

        /* Clear parity status */
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, 0));
    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_ecc(int unit, int block_info_idx, int pipe, int port,
                              const _soc_td2_ser_info_t *info,
                              int schan, char *prefix_str, char *mem_str)
{
    int rv;
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 minfo;
    uint64 rval64;
    uint32 multiple, double_bit, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg_get(unit, reg, port, 0, &rval64));

        if (soc_reg64_field32_get(unit, reg, rval64, ECC_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg64_field32_get(unit, reg, rval64, MULTIPLE_ERRf);
            double_bit = soc_reg64_field32_get(unit, reg, rval64, DOUBLE_BIT_ERRf);
            entry_idx = soc_reg64_field32_get(unit, reg, rval64, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                               entry_idx, minfo);
            sal_memset(&spci, 0, sizeof(spci));
            if (double_bit) {
                spci.double_bit = 1;
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d double-bit ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            }
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple ECC errors\n"),
                           prefix_str, mem_str_ptr));
            }
            if (idx == 0 && info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN | SOC_SER_LOG_WRITE_CACHE;
                if (multiple) {
                    spci.flags |= SOC_SER_ERR_MULTI;
                }
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                spci.parity_type = SOC_PARITY_TYPE_ECC;
                spci.detect_time = sal_time_usecs();
                spci.log_id = _soc_td2_populate_ser_log(unit,
                                          info->enable_reg,
                                          info->enable_field,
                                          spci.mem,
                                          SOC_MEM_BLOCK_ANY(unit, spci.mem),
                                          spci.acc_type,
                                          spci.index,
                                          spci.detect_time,
                                          spci.sblk,
                                          spci.addr,
                                          pipe,
                                          FALSE);
                rv = soc_ser_correction(unit, &spci);
                if (spci.log_id != 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                       spci.log_id, 0);
                }
                if (SOC_FAILURE(rv)) {
                    /* Add reporting failed to correct event flag to
                     * application */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                            entry_idx, minfo);
                    return rv;
                }
            }
        }

        /* Clear parity status */
        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, reg, port, 0, rval64));
    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return SOC_E_NONE;
}

STATIC soc_bst_intr_check_cb td2_bst_intr_check;

STATIC int
_soc_td2_bst_intr_check(int unit)
{
    int rv = SOC_E_NONE;
    if (td2_bst_intr_check) {
        rv = td2_bst_intr_check(unit);
    }
    return rv;
}

int
soc_td2_set_bst_intr_check_callback(int unit, soc_bst_intr_check_cb cb)
{
    td2_bst_intr_check = cb;
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_bst_intr_check(int unit)
{
    uint32 do_check = 0, rval;
    uint32 sval[3] = {0}, tval[3] = {0};
    soc_field_t snap_fld[3] = {BST_HW_SNAPSHOT_EN_THDOf,
                        BST_HW_SNAPSHOT_EN_THDIf,
                        BST_HW_SNAPSHOT_EN_CFAPf};
    soc_field_t track_fld[3] = {BST_TRACK_EN_THDOf,
                        BST_TRACK_EN_THDIf,
                        BST_TRACK_EN_CFAPf};

    SOC_IF_ERROR_RETURN(READ_BST_HW_SNAPSHOT_ENr(unit, &rval));
    sval[0] = soc_reg_field_get(unit, BST_HW_SNAPSHOT_ENr, rval, snap_fld[0]);
    sval[1] = soc_reg_field_get(unit, BST_HW_SNAPSHOT_ENr, rval, snap_fld[1]);
    sval[2] = soc_reg_field_get(unit, BST_HW_SNAPSHOT_ENr, rval, snap_fld[2]);

    SOC_IF_ERROR_RETURN(READ_BST_TRACKING_ENABLEr(unit, &rval));
    tval[0] = soc_reg_field_get(unit, BST_TRACKING_ENABLEr, rval, track_fld[0]);
    tval[1] = soc_reg_field_get(unit, BST_TRACKING_ENABLEr, rval, track_fld[1]);
    tval[2] = soc_reg_field_get(unit, BST_TRACKING_ENABLEr, rval, track_fld[2]);

    do_check = ((sval[0] && !tval[0]) ||
        (sval[1] && !tval[1]) ||
        (sval[2] && !tval[2]));

    /* If any BST snapshot is enabled and BST tracking is disabled,  do an examination for BST_TRIGGER and BST_STAT*/
    if (do_check) {
        _soc_td2_bst_intr_check(unit);
        return SOC_E_NONE;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_mmu_err(int unit, int block_info_idx,
                                  const _soc_td2_ser_info_t *info,
                                  char *prefix_str, int pipe)
{
    uint32 rval, err, addr, bidx;
    uint64 rval64;
    soc_reg_t reg = MMU_MEM_FAIL_ADDR_64r;
    uint8 blk_idx;
    uint32 sblk = 0;
    int rv = SOC_E_NONE;
    soc_reg_t parity_enable_reg = INVALIDr;
    soc_field_t parity_enable_field = INVALIDf;
    _soc_ser_correct_info_t spci;
    
    SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    if (soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU SER interrupt with empty fifo !!\n"),
                              unit));
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_STATr(unit, &rval));
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR status: 0x%08x\n"), unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_MEM_FAIL_INT_STATr(unit, 0));
        /*Check if bst interrupt occurs and process it if yes*/
        _soc_trident2_ser_process_bst_intr_check(unit);
        return rv;
    }
    SOC_BLOCK_ITER(unit, blk_idx, SOC_BLK_MMU) {
        sblk = SOC_BLOCK2SCH(unit, blk_idx);
        break;
    }
    do {
        SOC_IF_ERROR_RETURN(READ_MMU_MEM_FAIL_ADDR_64r(unit, &rval64));
        err = soc_reg64_field32_get(unit, reg, rval64, ERR_TYPEf);
        addr = soc_reg64_field32_get(unit, reg, rval64, EADDRf);
        bidx = soc_reg64_field32_get(unit, reg, rval64, BIDXf);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR Type: %s, Addr: 0x%08x, module: %d\n"),
                              unit, (err == 1) ? "1B error" : "2B error", addr, bidx));
        /* Address reported in MMU_MEM_FAIL_ADDR_64 is the entry offset within 
         * MMU sub block. The complete Sbus address is composed of MMU sub block 
         * base address and offset within MMU sub block address space.
         */
        addr = (bidx << 26) | addr;
        sal_memset(&spci, 0, sizeof(spci));
        spci.flags |= SOC_SER_SRC_MEM;
        spci.reg = INVALIDr;
        spci.mem = INVALIDm;
        spci.blk_type = SOC_BLK_MMU;
        spci.sblk = sblk;
        spci.detect_time = sal_time_usecs();
        
        /* Try to decode memory */
        spci.mem = soc_addr_to_mem_extended(unit, sblk, _SOC_ACC_TYPE_PIPE_ANY, addr);
        if (spci.mem != INVALIDm) {
            spci.index = addr - soc_mem_base(unit, spci.mem);
            spci.flags |= SOC_SER_REG_MEM_KNOWN;
#ifdef BCM_56860_A0
            if (SOC_IS_TD2P_TT2P(unit)) {
                _soc_trident2_ser_control_reg_get(unit, _soc_bcm56860_a0_mmu_mem_ser_info,
                                                  spci.mem,
                                                  &parity_enable_reg,
                                                  &parity_enable_field);
            } else
#endif
            {
                parity_enable_reg = PARITY_ENr;
                parity_enable_field = _soc_td2_mmu_parity_enable_fields[bidx];
            }
        } else {
            spci.flags |= SOC_SER_REG_MEM_UNKNOWN;
        }
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
        spci.flags |= SOC_SER_LOG_WRITE_CACHE;
        spci.log_id = _soc_td2_populate_ser_log(unit, parity_enable_reg, parity_enable_field,
                                                spci.mem, blk_idx,
                                                _SOC_ACC_TYPE_PIPE_ANY, spci.index,
                                                spci.detect_time, spci.sblk,
                                                spci.addr, pipe, FALSE);
 
        if ((spci.mem == INVALIDm) || 
            (SOC_MEM_SER_CORRECTION_TYPE(unit, spci.mem) != 0)) {            
            rv = soc_ser_correction(unit, &spci);
            if (SOC_FAILURE(rv)) {
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                   SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                   sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
            }
        } else {
            rv = SOC_E_NONE;
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_AUTO_CORRECTED,
                               sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, addr);
        }
        
        if (spci.log_id != 0) {
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_LOG, 
                               spci.log_id, 0);
        }
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_CTRr(unit, &rval));
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d MMU ERR ctr: %d\n"), unit, rval));
        SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    } while (!soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, info->intr_status_reg, REG_PORT_ANY,
                                info->group_reg_status_field, 0));
    /*Check if bst interrupt occurs and process it if yes*/
    _soc_trident2_ser_process_bst_intr_check(unit);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MEM_FAIL_INT_CLEARr, REG_PORT_ANY,
                                    info->group_reg_status_field, 1));
    }
#endif
    return rv;
}

STATIC int
_soc_trident2_ser_process_start_err(int unit, int block_info_idx,
                                    const _soc_td2_ser_info_t *info,
                                    char *prefix_str)
{
    soc_info_t *si;
    uint64 rval64;
    uint32 pbmp_31_0, pbmp_63_32, pbmp_96_64, pbmp_116_97;
    soc_pbmp_t pbmp;
    uint32 minfo, rval;
    int port, mmu_port, phy_port;
    soc_ser_log_tlv_generic_t log_generic;
    int log_id;

    sal_memset(&log_generic, 0, sizeof(soc_ser_log_tlv_generic_t));

    si = &SOC_INFO(unit);

    /* mmu port 52-0 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_0r(unit, &rval64));
    pbmp_31_0 = COMPILER_64_LO(rval64);
    pbmp_63_32 = COMPILER_64_HI(rval64);
    /* mmu port 116-64 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_1r(unit, &rval64));
    pbmp_96_64 = COMPILER_64_LO(rval64);
    pbmp_116_97 = COMPILER_64_HI(rval64);
    SOC_PBMP_CLEAR(pbmp);
    SOC_PBMP_WORD_SET(pbmp, 0, pbmp_31_0);
    SOC_PBMP_WORD_SET(pbmp, 1, pbmp_63_32);
    SOC_PBMP_WORD_SET(pbmp, 2, pbmp_96_64);
    SOC_PBMP_WORD_SET(pbmp, 3, pbmp_116_97);

    SOC_PBMP_ITER(pbmp, mmu_port) {
        phy_port = si->port_m2p_mapping[mmu_port];
        port = si->port_p2l_mapping[phy_port];
        _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        /* Report uncorrectable event flag to application */
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE, 0,
                           minfo);

        log_generic.time = sal_time_usecs();
        log_generic.boot_count = soc_ser_log_get_boot_count(unit);
        log_generic.block_type = SOC_BLOCK_INFO(unit, block_info_idx).type;
        log_generic.parity_type = info->type;

        log_id = soc_ser_log_create_entry(unit,
            sizeof(soc_ser_log_tlv_generic_t) +
            sizeof(soc_ser_log_tlv_hdr_t) *2);

        soc_ser_log_add_tlv(unit, log_id, SOC_SER_LOG_TLV_GENERIC,
            sizeof(soc_ser_log_tlv_generic_t), &log_generic);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_LOG, log_id, 0);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s port %d start error detected\n"), prefix_str,
                              port));
    }

    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_0r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_1r(unit, rval64));
    SOC_IF_ERROR_RETURN
        (READ_MEM_FAIL_INT_STATr(unit, &rval));
    soc_reg_field_set(unit, MEM_FAIL_INT_STATr, &rval, START_BY_START_ERRf, 0);
    SOC_IF_ERROR_RETURN
        (WRITE_MEM_FAIL_INT_STATr(unit, rval));
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe,
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str);
STATIC int
_soc_trident2_ser_process_cport(int unit, int inst, int pipe,
                                const _soc_td2_ser_info_t *info)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;
    char prefix_str[24];

    if (info->intr_status_reg == INVALIDr) {
        return SOC_E_NONE;
    }

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }
    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));
    if (COMPILER_64_IS_ZERO(port_rval)) {
        return SOC_E_NONE;
    }

    sal_sprintf(prefix_str, "unit %d CPORT%d", unit, inst);
    SOC_IF_ERROR_RETURN
        (_soc_trident2_process_ser(unit, block_info_idx, inst, pipe, port,
                                   port_reg, port_rval, info->info, prefix_str));

    return SOC_E_NONE;
}

STATIC _soc_td2_bst_hw_cb td2_bst_cb;

STATIC int
_soc_td2_process_mmu_bst(int unit)
{
    int rv = SOC_E_NONE;
    if (td2_bst_cb) {
        rv = td2_bst_cb(unit);
    }
    return rv;
}

int soc_td2_set_bst_callback(int unit, _soc_td2_bst_hw_cb cb)
{
    td2_bst_cb = cb;
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe,
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str)
{
    const _soc_td2_ser_info_t *info;
    int info_index;
    char *mem_str;
    uint32 minfo;
    soc_ser_log_tlv_generic_t log_generic;
    int log_id;

    sal_memset(&log_generic, 0, sizeof(soc_ser_log_tlv_generic_t));

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Check status for the info entry in the group register */
        if (!soc_reg64_field32_get(unit, group_reg, group_rval,
                                   info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                     info->group_reg_status_field, &minfo);
            /* Report uncorrectable event flag to application */
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE, 0,
                               minfo);

            log_generic.time = sal_time_usecs();
            log_generic.boot_count = soc_ser_log_get_boot_count(unit);
            log_generic.block_type = SOC_BLOCK_INFO(unit, block_info_idx).type;
            log_generic.parity_type = info->type;

            log_id = soc_ser_log_create_entry(unit,
                sizeof(soc_ser_log_tlv_generic_t) +
                sizeof(soc_ser_log_tlv_hdr_t) *2);

            soc_ser_log_add_tlv(unit, log_id, SOC_SER_LOG_TLV_GENERIC,
                sizeof(soc_ser_log_tlv_generic_t), &log_generic);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_LOG, log_id, 0);

            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s asserted\n"), prefix_str, mem_str));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, 
                                            MEM_FAIL_INT_CLEARr, REG_PORT_ANY,
                                            info->group_reg_status_field, 1));
            } else
#endif
            /* TD2 does not have MEM_FAIL_INT_CLEARr, so clear the
               field manually. */
            {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, 
                                            MEM_FAIL_INT_STATr, REG_PORT_ANY,
                                            info->group_reg_status_field, 0));
            }
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_parity(unit, block_info_idx,
                                                  pipe, port, info, FALSE,
                                                  prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_ecc(unit, block_info_idx, pipe,
                                               port, info, FALSE,
                                               prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of report tree structure */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_cport(unit, inst, pipe, info));
            break;
        case _SOC_PARITY_TYPE_START_ERR:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_start_err(unit, block_info_idx,
                                                     info, prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_mmu_err(unit, block_info_idx,
                                                   info, prefix_str, pipe));
            break;
        case _SOC_PARITY_TYPE_BST:
            SOC_IF_ERROR_RETURN(_soc_td2_process_mmu_bst(unit));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC char *_soc_td2_ser_hwmem_base_info[] = {
    "CMIC PKT BUFFER - In Iarb",
    "CPU PKT BUFFER - In Iarb",
    "Invalid value",
    "EINITBUF_PACKET_BUFFER - In Iarb",
    "INGRESS PACKET BUFFER - In Ipars",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "EP MPB DATA - In El3",
    "EP INITBUF - In Ehcpm",
    "CM DATA BUFFER - In Edatabuf",
    "XLP0 DATA BUFFER - In Edatabuf",
    "XLP1 DATA BUFFER - In Edatabuf",
    "XLP2 DATA BUFFER - In Edatabuf",
    "XLP3 DATA BUFFER - In Edatabuf",
    "XLP4 DATA BUFFER - In Edatabuf",
    "XLP5 DATA BUFFER - In Edatabuf",
    "XLP6 DATA BUFFER - In Edatabuf",
    "XLP7 DATA BUFFER - In Edatabuf",
    "XLP8 DATA BUFFER - In Edatabuf",
    "XLP9 DATA BUFFER - In Edatabuf",
    "XLP10 DATA BUFFER - In Edatabuf",
    "XLP11 DATA BUFFER - In Edatabuf",
    "XLP12 DATA BUFFER - In Edatabuf",
    "XLP13 DATA BUFFER - In Edatabuf",
    "XLP14 DATA BUFFER - In Edatabuf",
    "XLP15 DATA BUFFER - In Edatabuf",
    "CLP0 DATA BUFFER - In Edatabuf",
    "CLP1 DATA BUFFER - In Edatabuf",
    "CLP2 DATA BUFFER - In Edatabuf",
    "CLP3 DATA BUFFER - In Edatabuf",
    "XLP RESI0 DATA BUFFER - In Edatabuf",
    "XLP RESI1 DATA BUFFER - In Edatabuf",
    "XLP RESI2 DATA BUFFER - In Edatabuf",
    "XLP RESI3 DATA BUFFER - In Edatabuf",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "XLP0 EDB CTRL BUFFER - In Edatabuf",
    "XLP1 EDB CTRL BUFFER - In Edatabuf",
    "XLP2 EDB CTRL BUFFER - In Edatabuf",
    "XLP3 EDB CTRL BUFFER - In Edatabuf",
    "XLP4 EDB CTRL BUFFER - In Edatabuf",
    "XLP5 EDB CTRL BUFFER - In Edatabuf",
    "XLP6 EDB CTRL BUFFER - In Edatabuf",
    "XLP7 EDB CTRL BUFFER - In Edatabuf",
    "XLP8 EDB CTRL BUFFER - In Edatabuf",
    "XLP9 EDB CTRL BUFFER - In Edatabuf",
    "XLP10 EDB CTRL BUFFER - In Edatabuf",
    "XLP11 EDB CTRL BUFFER - In Edatabuf",
    "XLP12 EDB CTRL BUFFER - In Edatabuf",
    "XLP13 EDB CTRL BUFFER - In Edatabuf",
    "XLP14 EDB CTRL BUFFER - In Edatabuf",
    "XLP15 EDB CTRL BUFFER - In Edatabuf",
    "CLP0 EDB CTRL BUFFER - In Edatabuf",
    "CLP1 EDB CTRL BUFFER - In Edatabuf",
    "CLP2 EDB CTRL BUFFER - In Edatabuf",
    "CLP3 EDB CTRL BUFFER - In Edatabuf",
    "LEARN FIFO - In IARB",
    "EGR VLAN BUS",
    "EGR HCPM BUS",
    "EGR PMOD BUS",
    "EGR FPPARS BUS",
    "EFP BUS",
    "IVP BUS",
    "ICFG BUS",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "IPARS BUS",
    "IVXLT BUS",
    "IMPLS BUS",
    "IL2L3 BUS",
    "Invalid value",
    "IFP BUS",
    "IRSEL1 BUS",
    "ISW1 BUS",
    "IRSEL2 BUS"
};

#define _SOC_TD2_SER_REG 1
#define _SOC_TD2_SER_MEM 0

STATIC void
_soc_trident2_print_ser_fifo_details(int unit, uint8 regmem, soc_block_t blk, 
                                     uint32 sblk, int pipe, uint32 address, 
                                     uint32 stage, uint32 base, uint32 index, 
                                     uint32 hwmbase, uint32 type, uint8 drop, 
                                     uint8 non_sbus)
{
    uint32 hwmbase_max = 0;
    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityError, unit)) {
        switch (type) {
        case 0:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SOP cell.\n")));
            break;
        case 1:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: MOP cell.\n")));
            break;
        case 2:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: EOP cell.\n")));
            break;
        case 3:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SBUS transaction.\n")));
            break;
        case 4:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: miscellaneous transaction.\n")));
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid error reported !!\n")));
            break;
        }
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Blk: %d, Pipe: %d, Address: 0x%08x, base: 0x%x, stage: %d, index: %d\n"),
                              sblk, pipe, address, base, stage, index));
        if (regmem == _SOC_TD2_SER_MEM) {
            if (hwmbase >= 0x80) {
                hwmbase -= 0x38; /* handle the gap */
            }
            if (non_sbus) {
                hwmbase_max = sizeof(_soc_td2_ser_hwmem_base_info)/sizeof(_soc_td2_ser_hwmem_base_info[0]);
                /* coverity[overrun-local] */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem hwbase: 0x%x [%s]\n"), hwmbase,
                                      (hwmbase < hwmbase_max) ? _soc_td2_ser_hwmem_base_info[hwmbase] : "--"));
            }
        }
        if (drop) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "SER caused packet drop.\n")));
        }
    }
}

#define IF_IPEP_SBS_CTRL_LOCK(_unit_) \
        if ((mem == EGR_SER_FIFOm) && (pipe != 0)) { \
            IP_ARBITER_LOCK(_unit_);\
            (void)soc_trident2_pipe_select(unit, TRUE, 1); \
        }

#define IF_IPEP_SBS_CTRL_UNLOCK(_unit_) \
        if ((mem == EGR_SER_FIFOm) && (pipe != 0)) { \
            (void)soc_trident2_pipe_select(unit, TRUE, 0); \
            IP_ARBITER_UNLOCK(_unit_); \
        } \

STATIC uint32
_soc_trident2_flex_ctr_addr_check(int unit, uint32 address, soc_block_t blk,
                                  uint32 stage, uint32 index)
{
    uint32 index2 = index;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        if ((SOC_BLK_IPIPE == blk) && (21 == stage)) {
            switch (address & 0xfffff000) {
            /* ING_FLEX_CTR_OFFSET_TABLE_*m */
            case 0x56800000:
            case 0x56801000:
            case 0x56802000:
            case 0x56803000:
            case 0x56840000:
            case 0x56841000:
            case 0x56842000:
            case 0x56843000:
                index2 = address & 0x3ff; break; /* 1K depth */
            /* ING_FLEX_CTR_COUNTER_TABLE_*m */
            case 0x56804000:
            case 0x56808000:
            case 0x5680c000:
            case 0x56810000:
            case 0x56844000:
            case 0x56848000:
            case 0x5684c000:
            case 0x56850000:
                index2 = address & 0xfff; break; /* 4K depth */
            default:
                break;
            }
        }
    } else
#endif
    {
        if ((blk == SOC_BLK_IPIPE) && (stage == 17)) {
            switch (address & 0XFFFFF000) {
            case 0x46800000:
            case 0x46801000:
            case 0x46802000:
            case 0x46803000:
            case 0x46840000:
            case 0x46841000:
            case 0x46842000:
            case 0x46843000:
                index2 = address & 0x3ff; break; /* 1K depth */
            case 0x46804000:
            case 0x46808000:
            case 0x4680c000:
            case 0x46810000:
            case 0x46844000:
            case 0x46848000:
            case 0x4684c000:
            case 0x46850000:
                index2 = address & 0xfff; break; /* 4K depth */
            default:
                break;
            }
        }
    }
    if ((SOC_BLK_EPIPE == blk) && (10 == stage)) {
        switch (address & 0XFFFFF000) {
        case 0x2a800000:
        case 0x2a801000:
        case 0x2a802000:
        case 0x2a803000:
            index2 = address & 0x3ff; break; /* 1K depth */
        case 0x2a804000:
        case 0x2a808000:
        case 0x2a80c000:
        case 0x2a810000:
            index2 = address & 0xfff; break; /* 4K depth */
        default:
            break;
        }
    }
    return index2;
}

STATIC int
_soc_trident2_process_ser_fifo(int unit, soc_block_t blk, int pipe, char *prefix_str)
{
    int i, rv;
    uint8 bidx;
    soc_mem_t mem;
    char blk_str[10];
    int *acc_type_ptr;
    soc_reg_t reg = INVALIDr;
    _soc_ser_correct_info_t spci;
    void* ser_info_table = NULL;
    soc_reg_t parity_enable_reg = INVALIDr;
    soc_field_t parity_enable_field = INVALIDf;
    /* There are a few tables in TD2 (like is ING_NEXT_HOP, L2MC, L3_IPMC),
     * whose physical implementation is only one copy. They are written through
     * the X-pipe. Type 1 in Y-pipe list covers memories of this structure.
     */
    static int acc_type1[] = { 3, 2, 6, 4, 1, 0, -1 };
    static int acc_type0[] = { 1, 3, 6, 4, 0, -1 };
    uint32 reg_val, mask, entry[SOC_MAX_MEM_WORDS];
    uint32 stage = 0, addrbase = 0, index = 0, hwmbase = 0, type = 0;
    uint32 sblk = 0, regmem = 0, non_sbus = 0, drop = 0, ecc_parity = 0, address = 0;


    switch (blk) {
    case SOC_BLK_IPIPE:
        mem = pipe ? ING_SER_FIFO_Ym : ING_SER_FIFO_Xm;
#ifdef BCM_56860_A0
        if (SOC_IS_TD2P_TT2P(unit)) {
            mask = _soc_td2p_ip_pipe_fifo_bmask [ pipe ];
            ser_info_table = _soc_bcm56860_a0_ip_mem_ser_info;
        } else
#endif
        {
            mask = pipe ? 0x15540 : 0xAAA0; /* All IP bits based upon pipe */ 
            ser_info_table = _soc_td2_ip_ser_info;
        }
        sal_sprintf(blk_str, "IPIPE");
        break;
    case SOC_BLK_EPIPE:
#ifdef BCM_56860_A0
        if (SOC_IS_TD2P_TT2P(unit)) {
            mem = EGR_SER_FIFOm;
            ser_info_table = _soc_bcm56860_a0_ep_mem_ser_info;
        } else
#endif
        {
            mem = pipe ? EGR_SER_FIFO_Ym : EGR_SER_FIFO_Xm;
            ser_info_table = _soc_td2_ep_ser_info;
        }
        mask = 0x00000001; /* SER_FIFO_NON_EMPTYf */
        reg = EGR_INTR_STATUSr;
        sal_sprintf(blk_str, "EPIPE");
        break;
    default:
        return SOC_E_PARAM;
    }

    do {
        
        IF_IPEP_SBS_CTRL_LOCK(unit);
        rv = soc_mem_pop(unit, mem, MEM_BLOCK_ANY, entry);
        IF_IPEP_SBS_CTRL_UNLOCK(unit);

        SOC_IF_ERROR_RETURN(rv);
        /* process entry */
        if (soc_mem_field32_get(unit, mem, entry, VALIDf)) {
            ecc_parity = soc_mem_field32_get(unit, mem, entry, ECC_PARITYf);
            regmem = soc_mem_field32_get(unit, mem, entry, MEM_TYPEf);
            address = soc_mem_field32_get(unit, mem, entry, ADDRESSf);
            stage = soc_mem_field32_get(unit, mem, entry, PIPE_STAGEf);
            type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
            drop = soc_mem_field32_get(unit, mem, entry, DROPf);
            SOC_BLOCK_ITER(unit, bidx, blk) {
                sblk = SOC_BLOCK2SCH(unit, bidx);
                break;
            }
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s\n"), prefix_str));
            if (soc_mem_field32_get(unit, mem, entry, MULTIPLEf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Multiple: ")));
            }
            if (regmem == _SOC_TD2_SER_REG) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Reg: ")));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem: ")));
            }
            spci.double_bit = 0;
            switch (ecc_parity) {
            case 0:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Parity error..\n")));
                break;
            case 1:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Corrected single bit ECC error..\n")));
                break;
            case 2:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Double or Multiple bit ECC error..\n")));
                spci.double_bit = 1;
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid SER issue !!\n")));

                return SOC_E_INTERNAL;
            }
            if (regmem == _SOC_TD2_SER_MEM) {
                /* process mem */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, MEMBASEf);
                index = soc_mem_field32_get(unit, mem, entry, MEMINDEXf);
                hwmbase = soc_mem_field32_get(unit, mem, entry, HWMEMBASEf);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TD2P_TT2P(unit)){
                    if ((blk == SOC_BLK_IPIPE) && (stage == 9 || stage == 13)) {
                        /* Mems in these stages in IPIPE have more than 
                         * 256k indexes */
                        index |= hwmbase << 18;
                        hwmbase = addrbase = 0;
                    }
                } else 
#endif
                {
                    if ((blk == SOC_BLK_IPIPE) &&
                        (stage == 7 ||stage == 8 || stage == 11)) {
                        /* Mems in these stages in IPIPE have more than 
                         * 256k indexes */
                        index |= hwmbase << 18;
                        hwmbase = addrbase = 0;
                    }
                }
                index = _soc_trident2_flex_ctr_addr_check(unit, address, blk,
                                                          stage, index);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_MEM;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.pipe_num = pipe;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address - index;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();
                    spci.parity_type = ecc_parity ? SOC_PARITY_TYPE_ECC : SOC_PARITY_TYPE_PARITY;
                    spci.double_bit = (ecc_parity == 2) ? 1 : 0;

                    /* Try to decode mem first */
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.mem = soc_addr_to_mem_extended(unit,
                                    spci.sblk, acc_type_ptr[i], spci.addr);

                        if (spci.mem != INVALIDm) {
                            break;
                        }
                    }

                    if (spci.mem != INVALIDm) {
                        spci.acc_type = acc_type_ptr[i];
                        spci.flags |= SOC_SER_REG_MEM_KNOWN; 
                    }
                    else {
                        /* Invalid mem, use the first acc_type_ptr*/
                        spci.acc_type = acc_type_ptr[0];
                        spci.flags |= SOC_SER_REG_MEM_UNKNOWN;
                    }

                    if (spci.mem != INVALIDm) {
                        _soc_trident2_ser_control_reg_get(unit, ser_info_table, 
                            spci.mem, 
                            &parity_enable_reg, 
                            &parity_enable_field);
                    }
                    
#ifdef ALPM_ENABLE
                    if ((spci.mem == L3_DEFIP_ALPM_ECCm) || 
                        (spci.mem == L3_DEFIP_ALPM_IPV4m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV4_1m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_64m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_64_1m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_128m) ||
                        (spci.mem == L3_DEFIP_AUX_TABLEm)) {
                        SOC_ALPM_LPM_LOCK(unit);
                    }
#endif
                    spci.flags |= SOC_SER_LOG_WRITE_CACHE;
                    if (spci.mem != INVALIDm) {
                        MEM_LOCK(unit,spci.mem);
                    }
                    spci.log_id = _soc_td2_populate_ser_log(unit,
                                              parity_enable_reg,
                                              parity_enable_field,
                                              spci.mem,
                                              bidx,
                                              spci.acc_type,
                                              spci.index,
                                              spci.detect_time,
                                              spci.sblk,
                                              spci.addr,
                                              pipe,
                                              TRUE);
                    if (spci.mem != INVALIDm) {
                        MEM_UNLOCK(unit,spci.mem);
                    }
#ifdef ALPM_ENABLE
                    if ((spci.mem == L3_DEFIP_ALPM_ECCm) || 
                        (spci.mem == L3_DEFIP_ALPM_IPV4m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV4_1m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_64m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_64_1m) ||
                        (spci.mem == L3_DEFIP_ALPM_IPV6_128m) ||
                        (spci.mem == L3_DEFIP_AUX_TABLEm)) {
                        SOC_ALPM_LPM_UNLOCK(unit);
                    }
#endif

                    rv = soc_ser_correction(unit, &spci);
                    if (spci.log_id != 0) {
                        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                           SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                           spci.log_id, 0);
                    }
                    if (SOC_FAILURE(rv)) {
                        if (rv != SOC_E_NOT_FOUND) {
                            /* Add reporting failed to correct event flag to
                             * application */
                            soc_event_generate(unit,
                                    SOC_SWITCH_EVENT_PARITY_ERROR,
                                    SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                    sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                    SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                            return rv;
                        }
                    }
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER mem address un-accessable !!\n"), blk_str));
                    /* Report an event to application even though the memory cannot be accessed */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       ecc_parity == 0 ?
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            } else {
                /* process reg */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, REGBASEf);
                index = soc_mem_field32_get(unit, mem, entry, REGINDEXf);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 1, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, 0, type, 
                                                         drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address;
                    spci.index = index;
                    spci.stage = stage;
                    spci.detect_time = sal_time_usecs();
                    spci.parity_type = ecc_parity ? SOC_PARITY_TYPE_ECC : SOC_PARITY_TYPE_PARITY;
                    spci.double_bit = (ecc_parity == 2) ? 1 : 0;
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.acc_type = acc_type_ptr[i];
                        spci.log_id = soc_ser_log_create_entry(unit,
                            sizeof(soc_ser_log_tlv_generic_t) +
                            sizeof(soc_ser_log_tlv_register_t) +
                            sizeof(soc_ser_log_tlv_hdr_t) *3);
                        rv = soc_ser_correction(unit, &spci);
                        if (spci.log_id != 0) {
                            soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_PARITY_ERROR,
                                               SOC_SWITCH_EVENT_DATA_ERROR_LOG,
                                               spci.log_id, 0);
                        }
                        if (SOC_FAILURE(rv)) {
                            if (rv == SOC_E_NOT_FOUND) {
                                continue;
                            }
                            /* Add reporting failed to correct event flag to
                             * application */
                            soc_event_generate(unit,
                                    SOC_SWITCH_EVENT_PARITY_ERROR,
                                    SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                    sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                    SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                            return rv;
                        }
                        break;
                    }
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER reg address un-accessable !!\n"), blk_str));
                    /* Report an event to application even though the reg cannot be accessed */
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                       ecc_parity == 0 ?
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d Got invalid mem pop from %s !!\n"),
                                  unit, SOC_MEM_NAME(unit, mem)));
        }
        /* check if any more pending */
        if (reg == INVALIDr) {
            rv = READ_CMIC_CMC0_IRQ_STAT2r(unit, &reg_val);
        } else {
            rv = soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &reg_val);
        }
        SOC_IF_ERROR_RETURN(rv);
    } while (reg_val & mask);
    return SOC_E_NONE;
}

STATIC void
_soc_trident2_ser_control_reg_get(int unit, void *fifo_ser_list,
                                  soc_mem_t   mem,
                                  soc_reg_t   *ser_control_reg,
                                  soc_field_t *ser_enable_field)
{
    int i;
    _soc_td2_fifo_ser_info_t *fifo_ser_info = NULL;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    _soc_mem_ser_en_info_t *ser_en_info = NULL;
#endif
    if ((fifo_ser_list == NULL) || (ser_control_reg == NULL) || 
        (ser_enable_field == NULL)) {
        return;
    }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        ser_en_info = (_soc_mem_ser_en_info_t*)fifo_ser_list;
        for (i = 0; ser_en_info[i].mem != INVALIDm; i++) {
            if (ser_en_info[i].mem == mem) {
                *ser_control_reg = ser_en_info[i].en_reg;
                *ser_enable_field = ser_en_info[i].en_fld;
                break;
            }
        }
    } else
#endif
    {
        fifo_ser_info = (_soc_td2_fifo_ser_info_t*)fifo_ser_list;
        _soc_trident2_mem_rename(&mem);
        for (i = 0; fifo_ser_info[i].enable_reg != INVALIDr; i++) {
            if (fifo_ser_info[i].mem == mem) {
                *ser_control_reg = fifo_ser_info[i].enable_reg;
                *ser_enable_field = fifo_ser_info[i].enable_field;
                break;
            }
        }
    }
    return;
}


STATIC int
_soc_trident2_ser_process_all(int unit)
{
    uint8      rbi;
    int        port = REG_PORT_ANY;
    uint32     cmic_rval, cmic_bit;
    uint64     rb_enable64, rb_rval64, tmp64;
    const      _soc_td2_ser_route_block_t *rb;
    char       prefix_str[10];
    int        block_info_idx;
    soc_stat_t *stat = SOC_STAT(unit);

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

    /* Read CMIC parity status register */
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }
        if (rb->blocktype == SOC_BLK_IPIPE || rb->blocktype == SOC_BLK_EPIPE) {
            /* New fifo style processing */
            (void)_soc_trident2_process_ser_fifo(unit, rb->blocktype, rb->pipe, prefix_str);
            stat->ser_err_fifo++;
        } else {
            /* Legacy processing */
            SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                    port = SOC_BLOCK_PORT(unit, block_info_idx);
                    break;
                }
            }
            if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d SER error on disabled port block %d !!\n"),
                                          unit, block_info_idx));
                    sal_usleep(SAL_BOOT_QUICKTURN ? 10000000 : 1000000); /* Don't reenable too soon */
                    continue;
            }
            /* Read per route block parity status register */
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->status_reg, port, 0, &rb_rval64));
            if (COMPILER_64_IS_ZERO(rb_rval64)) {
                continue;
            }
            SOC_IF_ERROR_RETURN
                (_soc_trident2_process_ser(unit, block_info_idx, rb->id, rb->pipe,
                                           port, rb->status_reg, rb_rval64,
                                           rb->info, prefix_str));
            
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_enable64));
            COMPILER_64_SET(tmp64, COMPILER_64_HI(rb_rval64), COMPILER_64_LO(rb_rval64));
            COMPILER_64_NOT(tmp64);
            COMPILER_64_AND(rb_enable64, tmp64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            COMPILER_64_OR(rb_enable64, rb_rval64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            
            stat->ser_err_int++;
        }
    }
    return SOC_E_NONE;
}



STATIC void
soc_trident2_ser_error(void *unit_vp, void *d1, void *d2, void *d3,
                       void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)_soc_trident2_ser_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
    /* soc_intr_enable(unit, IRQ_MEM_FAIL); */
}

/* SER processing for TCAMs */
static _soc_generic_ser_info_t _soc_td2_tcam_ser_info_template[] = {
    /* HW SER engine protection */
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ  |
      _SOC_SER_FLAG_SIZE_VERIFY},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ  |
      _SOC_SER_FLAG_SIZE_VERIFY},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 105}, {1, 105}, {106, 210}, {107, 210} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},

    /* SW memscan SER engine protection */
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { UDF_CONDITIONAL_CHECK_TABLE_CAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { UDF_CONDITIONAL_CHECK_TABLE_CAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    { MY_STATION_TCAM_2m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAM_2m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { SUBPORT_TAG_SGPP_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 32}, {1, 32}, {33, 64}, {34, 64} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { SUBPORT_TAG_SGPP_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 32}, {1, 32}, {33, 64}, {34, 64} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
#endif
    { INVALIDm },
};

static _soc_generic_ser_info_t *_soc_td2_tcam_ser_info[SOC_MAX_NUM_DEVICES];

#ifdef BCM_TRIDENT2PLUS_SUPPORT
STATIC int
_soc_trident2_tcam_idx_get(soc_mem_t mem)
{
    int idx;
    for (idx = 0; idx < COUNTOF(_soc_td2_tcam_ser_info_template); idx++) {
        if (_soc_td2_tcam_ser_info_template[idx].mem == mem) {
            break;
        }
    }
    return idx;
}

#define _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, table_index, section_index, start, end) \
    _soc_td2_tcam_ser_info[unit][table_index].start_end_bits[section_index].start_bit = start; \
    _soc_td2_tcam_ser_info[unit][table_index].start_end_bits[section_index].end_bit = end; \
    _soc_td2_tcam_ser_info[unit][table_index + 1].start_end_bits[section_index].start_bit = start; \
    _soc_td2_tcam_ser_info[unit][table_index + 1].start_end_bits[section_index].end_bit = end;
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
STATIC void
_soc_trident2_ser_info_flag_update(_soc_generic_ser_info_t *ser_info,
                              soc_mem_t mem, uint32 flag, int enable)
{
    int ser_idx = 0;

    while (INVALIDm != ser_info[ser_idx].mem) {
        if (ser_info[ser_idx].mem == mem) {
            if (enable) {
                ser_info[ser_idx].ser_flags |= flag;
            } else {
                ser_info[ser_idx].ser_flags &= ~flag;
            }
        }
        ser_idx++;
    }
}
#endif

STATIC int
_soc_trident2_tcam_ser_init(int unit)
{
    int alloc_size;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int override_idx = 0;
#endif
    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_td2_tcam_ser_info_template);
    if (NULL == _soc_td2_tcam_ser_info[unit]) {
        if ((_soc_td2_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "td2 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_td2_tcam_ser_info[unit],
               &(_soc_td2_tcam_ser_info_template),
               alloc_size);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (!SOC_IS_TD2P_TT2P(unit)) {
        /* MY_STATION_TCAM_2m exists in TD2_PLUS, not in TD2,
         * set it to INVALIDm for TD2. */
        override_idx = _soc_trident2_tcam_idx_get(MY_STATION_TCAM_2m);
        _soc_td2_tcam_ser_info[unit][override_idx].mem = INVALIDm;
    }
    
    if (SOC_IS_TD2P_TT2P(unit)) {
        /* override start and end bit for IP_MULTICAST_TCAMm */
        override_idx = _soc_trident2_tcam_idx_get(IP_MULTICAST_TCAMm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 145, 288);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 146, 288);
        
        /* override start and end bit for L3_DEFIPm */
        override_idx = _soc_trident2_tcam_idx_get(L3_DEFIPm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 97);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 97);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 98, 193);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 99, 193);
        
        /* override start and end bit for L3_DEFIP_PAIR_128m */
        override_idx = _soc_trident2_tcam_idx_get(L3_DEFIP_PAIR_128m);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 99);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 100, 195);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 196, 291);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 292, 387);
        
        /* override start and end bit for CPU_COS_MAPm */
        override_idx = _soc_trident2_tcam_idx_get(CPU_COS_MAPm);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 0, 0, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 1, 1, 144);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 2, 145, 288);
        _TCAM_PROT_SECTIONS_START_END_BIT_OVERRIDE(unit, override_idx, 3, 146, 288);

        if (soc_feature(unit, soc_feature_field_stage_quarter_slice) &&
            soc_feature(unit, soc_feature_field_quarter_slice_single_tcam) &&
            soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            _soc_trident2_ser_info_flag_update(_soc_td2_tcam_ser_info[unit], FP_GLOBAL_MASK_TCAMm,
                                          _SOC_SER_FLAG_NO_DMA, TRUE);
            _soc_trident2_ser_info_flag_update(_soc_td2_tcam_ser_info[unit], FP_TCAMm,
                                          _SOC_SER_FLAG_NO_DMA, TRUE);
            _soc_trident2_ser_info_flag_update(_soc_td2_tcam_ser_info[unit], FP_GM_FIELDSm,
                                          _SOC_SER_FLAG_NO_DMA, TRUE);
        }

        /*
        * Or _SOC_SER_FLAG_SW_COMPARE flag for EFP_TCAMm since consecutive ipipe
        * and epipe sbus transcations will cause H/W SER engine use incorrect parity bit
        * for checking, which result in false parity error reported.
        */
        _soc_trident2_ser_info_flag_update(_soc_td2_tcam_ser_info[unit], EFP_TCAMm,
                                           _SOC_SER_FLAG_SW_COMPARE, TRUE);
    }
#endif    
    return soc_generic_ser_init(unit, _soc_td2_tcam_ser_info[unit]);
}

STATIC void
soc_trident2_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_td2_tcam_ser_info[unit],
                                  _SOC_PARITY_TYPE_SER);
}

static soc_mem_t *_soc_td2_alpm_bkt_view_map[SOC_MAX_NUM_DEVICES];

#ifdef ALPM_ENABLE
int
soc_trident2_alpm_scrub(int unit)
{
    int ipv6;                   /* Iterate over ipv6 only flag. */
    int idx;                    /* Iteration index.             */
    int tmp_idx;                /* ipv4 entries iterator.       */
    int alloc_size;             /* Allocation size.             */
    int tbl_size;               /* HW table size.               */
    int rv = SOC_E_FAIL;        /* Operation return status.     */
    char *lpm_tbl_ptr = NULL;   /* Dma table pointer.           */
    int vrf, vrf_id, step_count;
    int idx_end, bkt_idx, bkt_ptr = 0, bkt_addr;
    int bank_num = 0, entry_num = 0, entry_count, bank_count;
    void *alpm_entry;
    uint32 rval;
    soc_mem_t alpm_mem;
    defip_entry_t *lpm_entry;   /* Hw entry buffer.             */
    defip_pair_128_entry_t *lpm_128_entry; /* Hw entry buffer.  */
    defip_alpm_ipv4_1_entry_t alpm_entry_v4;
    defip_alpm_ipv6_64_1_entry_t alpm_entry_v6_64;
    defip_alpm_ipv6_128_entry_t alpm_entry_v6_128;
    int flex;

    SOC_IF_ERROR_RETURN(READ_L3_DEFIP_RPF_CONTROLr(unit, &rval));
    if (0 == soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LPM_MODEf)) {
        return (SOC_E_NONE);
    }

    /* DMA the LPM table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIPm);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIPm, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIPm),
                           soc_mem_index_max(unit, L3_DEFIPm), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
    }

    idx_end = tbl_size;

    if (soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LOOKUP_MODEf)) {
        /* parallel search mode */
        if (SOC_URPF_STATUS_GET(unit)) {
            bank_count = 2;
        } else {
            bank_count = 4;
        }
    } else {
        bank_count = 4;
    }

    /* Walk all lpm entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry offset */
        lpm_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIPm,
                                         defip_entry_t *, lpm_tbl_ptr, idx);

        ipv6 = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry, MODE0f);

        /* Calculate LPM table traverse step count */
        if (ipv6) {
            if (SOC_ALPM_V6_SCALE_CHECK(unit, ipv6)) {
                step_count = 2;
            } else {
                step_count = 1;
            }
        } else {
            step_count = 2;
        }

        /* Each LPM index has two IPv4 entries */
        for (tmp_idx = 0; tmp_idx < step_count; tmp_idx++) {

            if (tmp_idx) {  /* If index == 1*/
                if (!ipv6) {
                    /* Copy upper half of lpm entry to lower half */
                    soc_alpm_lpm_ip4entry1_to_0(unit, lpm_entry, lpm_entry, TRUE);
                }
            }

            /* Make sure entry is valid. */
            if (!soc_L3_DEFIPm_field32_get(unit, lpm_entry, VALID0f)) {
                continue;
            }

            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_lpm_vrf_get
                            (unit, lpm_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            if (ipv6 && tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry,
                                              ALG_BKT_PTR0f);
                if (bkt_ptr == 0) {
                    if (ipv6) {
                        tmp_idx++;
                    }
                    continue;
                }
            }

            flex = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry,
                                              ENTRY_VIEW0f);
            if (ipv6) {
                if (flex) {
                    alpm_mem = L3_DEFIP_ALPM_IPV6_64_1m;
                    entry_count = 3;
                    alpm_entry = &alpm_entry_v6_64;
                } else {
                    alpm_mem = L3_DEFIP_ALPM_IPV6_64m;
                    entry_count = 4;
                    alpm_entry = &alpm_entry_v6_64;
                }
            } else {
                if (flex) {
                    alpm_mem = L3_DEFIP_ALPM_IPV4_1m;
                    entry_count = 4;
                    alpm_entry = &alpm_entry_v4;
                } else {
                    alpm_mem = L3_DEFIP_ALPM_IPV4m;
                    entry_count = 6;
                    alpm_entry = &alpm_entry_v4;
                }
            }

            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) |
                           (bank_num & 0x3);
                entry_num++;
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                             bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */
    soc_cm_sfree(unit, lpm_tbl_ptr);

    /* DMA the LPM_PAIR_128 table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIP_PAIR_128m);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_pair_128_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIP_PAIR_128m, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIP_PAIR_128m),
                           soc_mem_index_max(unit, L3_DEFIP_PAIR_128m), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    /* bkt_count = ALPM_IPV6_128_BKT_COUNT; ?? */

    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
        /* bucket size halves for parallel search mode */
        if (soc_alpm_mode_get(unit)) {
            /* bkt_count >>= 1; ?? */
        }
    }

    idx_end = tbl_size;
    entry_count = 2;
    alpm_entry = &alpm_entry_v6_128;

    if (SOC_ALPM_V6_SCALE_CHECK(unit, 1)) {
        step_count = 2;
    } else {
        step_count = 1;
    }

    /* Walk all lpm_pair_128 entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry ofset. */
        lpm_128_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIP_PAIR_128m,
                                         defip_pair_128_entry_t *, lpm_tbl_ptr, idx);

        /* Each lpm entry contains upto 24 IPV4 entries. Check all */
        for (tmp_idx = 0; tmp_idx < step_count; tmp_idx++) {

            /* Make sure entry is valid. */
            if (!soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry,
                                     VALID0_LWRf)) {
                continue;
            }

            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_128_lpm_vrf_get
                            (unit, lpm_128_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            if (tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry,
                                              ALG_BKT_PTRf);
                if (bkt_ptr == 0) {
                    tmp_idx++;
                    continue;
                }
            }

            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) |
                           (bank_num & 0x3);
                entry_num++;
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m,
                                MEM_BLOCK_ANY, bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m,
                                                 MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */

    rv = SOC_E_NONE;

free_lpm_table:
    soc_cm_sfree(unit, lpm_tbl_ptr);

    return (rv);
}
#ifdef BCM_TRIDENT2PLUS_SUPPORT
STATIC int
soc_trident2p_alpm_mode_enable(int unit)
{
    uint32 rval = 0;
    uint32 mode;

    mode = soc_property_get(unit, spn_L3_ALPM_ENABLE, 0);
    if (mode && soc_feature(unit, soc_feature_alpm)) {
        /* Set DEFIP mode to ALPM */
        SOC_IF_ERROR_RETURN(READ_L3_DEFIP_RPF_CONTROLr(unit, &rval));
        soc_reg_field_set(unit, L3_DEFIP_RPF_CONTROLr, &rval, LPM_MODEf, 1);
        /* Parallel mode */
        if (mode == SOC_ALPM_MODE_PARALLEL) {
            soc_reg_field_set(unit, L3_DEFIP_RPF_CONTROLr, &rval, LOOKUP_MODEf, 1);
        } else {
            /* combined search mode */
            soc_reg_field_set(unit, L3_DEFIP_RPF_CONTROLr, &rval, LOOKUP_MODEf, 0);
        }
        SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_RPF_CONTROLr(unit, rval));
    }
    return SOC_E_NONE;
}
#endif
#endif /* ALPM_ENABLE */


STATIC int
soc_bcm56830_mem_config(int unit)
{
    soc_persist_t *sop;
    int         index_max;
    
    sop = SOC_PERSIST(unit);

    index_max = 23;
    sop->memState[TRUNK_GROUPm].index_max = index_max;
    sop->memState[TRUNK_BITMAPm].index_max = index_max;
    sop->memState[TRUNK_CBL_TABLEm].index_max = index_max;


    sop->memState[L2MCm].index_max = 8191;

    return SOC_E_NONE;
}

STATIC int
soc_bcm56834_mem_config(int unit)
{
    soc_persist_t *sop;
    int         index_max;
    
    sop = SOC_PERSIST(unit);

    index_max = 47;
    sop->memState[TRUNK_GROUPm].index_max = index_max;
    sop->memState[TRUNK_BITMAPm].index_max = index_max;
    sop->memState[TRUNK_CBL_TABLEm].index_max = index_max;


    sop->memState[L2MCm].index_max = 8191;

    return SOC_E_NONE;
}

int
soc_trident2_mem_config(int unit)
{
    soc_persist_t *sop;
    int l2_entries, cfg_l2_entries, shared_l2_banks;
    int l3_entries, cfg_l3_entries, shared_l3_banks;
    int alpm_enable;
    int num_ecmp_rh_flowset_entries;
    int shared_bank_size;
    int max_l2_entries;
    int max_l3_entries;
    int num_ipv6_128b_entries = 0;
    int config_v6_entries = 0;
    int defip_config = 0;
    int lpm_scaling_enable = 0, lpm_ipv6_128b_reserved = 0;
    uint16              dev_id;
    uint8               rev_id;
    int shared_entries;
    int num_defip_entries = 0;

    sop = SOC_PERSIST(unit);

    /* TRIDENT2:
     * bank 0-1 are dedicated L2 banks (16k entries per bank)
     * bank 6-9 are dedicated L3 banks (4k entries per bank)
     * bank 2-5 are shared banks (64k entres per bank)
     * These dedicated/shared banks can be configured to one of the following
     * mode:
     *     mode 0: 288k L2 (bank 0-5),  16k L3 (bank 6-9),   no ALPM (default)
     *     mode 1: 224k L2 (bank 0-4),  80k L3 (bank 5-9),   no ALPM
     *     mode 2: 160k L2 (bank 0-3), 144k L3 (bank 4-9),   no ALPM
     *     mode 3:  96k L2 (bank 0-2), 208k L3 (bank 3-9),   no ALPM
     *     mode 4:  32k L2 (bank 0-1),  16k L3 (bank 6-9), 128k ALPM (bank 2-5)
     *
     * TRIDENT2+:
     * bank 0-1 are dedicated L2 banks (16k entries per bank)
     * bank 6-9 are dedicated L3 banks (4k entries per bank)
     * bank 2-5 are shared banks (64 or 128k entres per bank)
     * These dedicated/shared banks can be configured to one of the following
     * mode:
     *     mode 0: 544k L2 (bank 0-5),  16k L3 (bank 6-9),   no ALPM (default)
     *     mode 1: 416k L2 (bank 0-4), 144k L3 (bank 5-9),   no ALPM
     *     mode 2: 288k L2 (bank 0-3), 272k L3 (bank 4-9),   no ALPM
     *     mode 3: 160k L2 (bank 0-2), 400k L3 (bank 3-9),   no ALPM
     *     mode 4:  32k L2 (bank 0-1),  16k L3 (bank 6-9), 128k ALPM (bank 2-5)
     */

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        shared_bank_size = soc_td2p_get_shared_bank_size (unit, dev_id, rev_id);
    } else 
#endif
    {
        shared_bank_size = 64;
    }
    max_l2_entries = 32 + shared_bank_size * 4;
    max_l3_entries = 16 + shared_bank_size * 3;

    cfg_l2_entries = soc_property_get(unit, spn_L2_MEM_ENTRIES, -1);
    l2_entries = cfg_l2_entries == -1 ? max_l2_entries * 1024 : cfg_l2_entries;

    if ((dev_id == BCM56830_DEVICE_ID) || 
        ((dev_id == BCM56834_DEVICE_ID) && (l2_entries > 160 * 1024))) { 
        l2_entries = 160 * 1024;
    }

    if (l2_entries <= 32 * 1024) { /* 32k dedicated L2 entries */
        l2_entries = 32 * 1024;
        shared_l2_banks = 0;
    } else if (l2_entries <= max_l2_entries * 1024) {
        l2_entries -= 32 * 1024;
        shared_l2_banks = (l2_entries + (shared_bank_size * 1024 - 1)) / (shared_bank_size * 1024);
        l2_entries = 32 * 1024 + shared_l2_banks * shared_bank_size * 1024;
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "The specified l2_mem_entries (%d) exceeds %dK\n"),
                 cfg_l2_entries, max_l2_entries));
        return SOC_E_PARAM;
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (!soc_feature(unit, soc_feature_l3)) {
        l3_entries = 0;
        cfg_l3_entries = 0;
        shared_l3_banks = 0;
    } else
#endif
    {
        cfg_l3_entries = soc_property_get(unit, spn_L3_MEM_ENTRIES, -1);
        l3_entries = cfg_l3_entries == -1 ? 16384 : cfg_l3_entries;
        if (l3_entries <= 16 * 1024) { /* 16k dedicated L3 entries */
            l3_entries = 16 * 1024;
            shared_l3_banks = 0;
        } else if (l3_entries <= max_l3_entries * 1024) {
            l3_entries -= 16 * 1024;
            shared_l3_banks = (l3_entries + (shared_bank_size * 1024 - 1)) 
                                                / (shared_bank_size * 1024);
            l3_entries = 16 * 1024 + shared_l3_banks * shared_bank_size * 1024;
        } else {
            LOG_CLI((BSL_META_U(unit,
                        "The specified l3_mem_entries (%d) exceeds %dK\n"),
                        cfg_l3_entries, max_l3_entries));
            return SOC_E_PARAM;
        }
    }

    alpm_enable = soc_property_get(unit, spn_L3_ALPM_ENABLE, 0);

    if (alpm_enable && soc_feature(unit, soc_feature_alpm)) {
        if (shared_l2_banks + shared_l3_banks != 0) {
            LOG_CLI((BSL_META_U(unit,
                                "Shared banks can not be used for L2 or L3 when "
                                "ALPM is enabled\n")));
            return SOC_E_PARAM;
        }
    } else if (shared_l2_banks + shared_l3_banks > 4) {
        if (cfg_l2_entries == -1) {
            LOG_CLI((BSL_META_U(unit,
                                "Default L2 size (294912) and the specified "
                                "l3_mem_entries (%d) require more than 4 shared "
                                "banks\n"),
                     cfg_l3_entries));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "The specified l2_mem_entries (%d) and "
                                "l3_mem_entries (%d) require more than 4 shared "
                                "banks\n"),
                     cfg_l2_entries, cfg_l3_entries));
        }
        return SOC_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_alpm)) {
        _soc_alpm_mode[unit] = alpm_enable;
    }

    /* Adjust table size to match L2_TABLE_HASH_CONTROL.MODE setting*/
    sop->memState[L2Xm].index_max = l2_entries - 1;
    sop->memState[L2_ENTRY_ONLYm].index_max = l2_entries - 1;
    
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        sop->memState[L2_ENTRY_ONLY_ECCm].index_max = l2_entries - 1;
    }
#endif

    sop->memState[L2_HITDA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    if (soc_feature(unit, soc_feature_shared_bank_lp_disabled)) {
        /* Initialize to dedicated L2 entries count. */
        shared_entries = shared_l2_banks * shared_bank_size * 1024;
        sop->memState[L2_ENTRY_LPm].index_max =
                (l2_entries - shared_entries) / 4 - 1;
    } else {
        sop->memState[L2_ENTRY_LPm].index_max = l2_entries / 4 - 1;
    }

    /* Adjust table size to match L3_TABLE_HASH_CONTROL.MODE setting */
    sop->memState[L3_ENTRY_ONLYm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_ONLY_ECCm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_UNICASTm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_MULTICASTm].index_max = l3_entries / 2 - 1;
    sop->memState[L3_ENTRY_IPV6_UNICASTm].index_max = l3_entries/ 2 - 1;
    sop->memState[L3_ENTRY_IPV6_MULTICASTm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLYm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Xm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Ym].index_max = l3_entries / 4 - 1;

    if (soc_feature(unit, soc_feature_shared_bank_lp_disabled)) {
        /* Initialize to dedicated L3 entries count. */
        shared_entries = shared_l3_banks * shared_bank_size * 1024;
        sop->memState[L3_ENTRY_LPm].index_max =
                (l3_entries - shared_entries) / 4 - 1;
    } else {
        sop->memState[L3_ENTRY_LPm].index_max = l3_entries / 4 - 1;
    }

    /* Adjust table size to match L2/L3_TABLE_HASH_CONTROL.MODE setting */
    if (!(alpm_enable && soc_feature(unit, soc_feature_alpm))) {
        sop->memState[L3_DEFIP_ALPM_RAWm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_128m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Xm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Ym].index_max = -1;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            sop->memState[L3_DEFIP_ALPM_ECCm].index_max = -1;
        }
#endif
    }

    /* LAG and ECMP resilient hashing features share the same flow set table.
     * The table can be configured in one of 3 modes:
     * - dedicated to LAG resilient hashing,
     * - dedicated to ECMP resilient hashing,
     * - split evenly between LAG and ECMP resilient hashing.
     */
    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            sop->memState[RH_ECMP_FLOWSETm].index_max = -1;
            break;
        case 32768:
            sop->memState[RH_LAG_FLOWSETm].index_max /= 2;
            sop->memState[RH_ECMP_FLOWSETm].index_max /= 2;
            break;
        case 65536:
            sop->memState[RH_LAG_FLOWSETm].index_max = -1;
            break;
        default:
            return SOC_E_CONFIG;
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (!soc_feature(unit, soc_feature_lpm_tcam)) {
        SOC_CONTROL(unit)->l3_defip_max_tcams = 0;
    } else
    if (soc_feature(unit, soc_feature_l3_2k_defip_table)) {
        /* 56832 SKU supports only 4K IPV4 entries as compared to 16k
           IPV4 entries in base chip 56860 i.e only 2 TCAMs can be
           used since each TCAM can have 2k IPV4 entries.
        */
        SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_TD2P_DEFIP_REDUCED_TCAMS;
    } else 
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    {
        SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_TD2_DEFIP_MAX_TCAMS;
    }

    SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_TD2_DEFIP_TCAM_DEPTH; 

    if (!soc_feature(unit, soc_feature_lpm_tcam)) {
        /* LPM is disabled, disable all L3_DEFIP memories */
        sop->memState[L3_DEFIPm].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128m].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = -1;
        sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = -1;
        sop->memState[L3_DEFIP_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = -1;
        sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = -1;
        SOC_CONTROL(unit)->l3_defip_index_remap = 0;
    } else if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
        if (!(soc_property_get(unit, spn_L3_ALPM_ENABLE, 0) &&
              soc_feature(unit, soc_feature_alpm))) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_l3_2k_defip_table)) {
                num_ipv6_128b_entries = soc_property_get(unit, 
                                            spn_NUM_IPV6_LPM_128B_ENTRIES, 
                                            (defip_config ? 512 : 0));  
            } else 
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
                num_ipv6_128b_entries = soc_property_get(unit,
                                            spn_NUM_IPV6_LPM_128B_ENTRIES,
                                            (defip_config ? 2048 : 0));
            }
 
            num_ipv6_128b_entries = num_ipv6_128b_entries + 
                                    (num_ipv6_128b_entries % 2);

            if (SOC_CONTROL(unit)->tcam_protect_write) {
                num_ipv6_128b_entries = (num_ipv6_128b_entries + 3) / 4 * 4;
            }

            config_v6_entries = num_ipv6_128b_entries;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_l3_2k_defip_table)) {
                lpm_scaling_enable = soc_property_get(unit, 
                                    spn_LPM_SCALING_ENABLE, 1);
            } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
                lpm_scaling_enable = soc_property_get(unit, 
                                    spn_LPM_SCALING_ENABLE, 0);
            }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_l3_2k_defip_table)) {
                lpm_ipv6_128b_reserved = soc_property_get(unit, 
                                    spn_LPM_IPV6_128B_RESERVED, 0);
            } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
                lpm_ipv6_128b_reserved = soc_property_get(unit, 
                                    spn_LPM_IPV6_128B_RESERVED, 1);
            }

            if (lpm_scaling_enable){
                num_ipv6_128b_entries = 0;
            }

            num_defip_entries = (SOC_CONTROL(unit)->l3_defip_max_tcams *
                                 SOC_CONTROL(unit)->l3_defip_tcam_size) -
                                 (num_ipv6_128b_entries * 2);

            /* Adjust numbers for tcam_protect_write */
            if (SOC_CONTROL(unit)->tcam_protect_write) {
                /* not support in non-scaling LPM mode */
                if (!lpm_scaling_enable) {
                    LOG_CLI((BSL_META_U(unit,
                                        "LPM non-scaling mode does not support "
                                        "tcam_protect_write. Please retry with "
                                        "lpm_scaling_enable=1.\n")));
                    return SOC_E_CONFIG;
                }
                if (num_defip_entries) {
                    num_defip_entries -= 8;
                    /* Don't use up all entries as protect entries */
                    if (num_defip_entries <= 0) {
                        return SOC_E_CONFIG;
                    }
                    SOC_CONTROL(unit)->l3_defip_tcam_size --;
                }
                /* coverity[dead_error_begin] */
                if (num_ipv6_128b_entries) {
                    num_ipv6_128b_entries -= 4;
                    /* Don't use up all entries as protect entries */
                    if (num_ipv6_128b_entries <= 0) {
                        return SOC_E_CONFIG;
                    }
                    SOC_CONTROL(unit)->l3_defip_tcam_size --;
                }
                if (config_v6_entries) {
                    config_v6_entries -= 4;
                    if (config_v6_entries < 0) {
                        return SOC_E_CONFIG;
                    }
                }
            }

            if (lpm_scaling_enable){
                if (!lpm_ipv6_128b_reserved) {
                    config_v6_entries = ((config_v6_entries /
                                        SOC_CONTROL(unit)->l3_defip_tcam_size) +
                                        ((config_v6_entries %
                                         SOC_CONTROL(unit)->l3_defip_tcam_size)
                                        ? 1 : 0)) * SOC_CONTROL(unit)->l3_defip_tcam_size;
                }
            }
            sop->memState[L3_DEFIP_PAIR_128m].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = 
                                              num_ipv6_128b_entries - 1;

           /* For 56832 SKU, we use only 2 TCAMs to support 4k IPv4 entries.
              By default, IPV6 is supported so the two TCAMs are paired
              together, hence index_max for L3_DEFIP is 1023 for 56832.
              Calculation: index_max = ((2 * 1024 ) - (512 *2) -1) = 1023
              2-># of TCAMs, 1024-> size of TCAM,512-> ipv6_128b_entries
           */
            sop->memState[L3_DEFIPm].index_max = num_defip_entries - 1;

            sop->memState[L3_DEFIP_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
        } else {
            if (soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1)) {
                /* slightly different processing for v6-128 */
                num_ipv6_128b_entries = soc_property_get(unit, 
                                            spn_NUM_IPV6_LPM_128B_ENTRIES, 
                                            2048);  
                num_ipv6_128b_entries = num_ipv6_128b_entries + 
                                        (num_ipv6_128b_entries % 2);
                if (soc_trident2_alpm_mode_get(unit) == 1) {
                    num_ipv6_128b_entries = (num_ipv6_128b_entries + 3) / 4 * 4;
                }
                if (SOC_CONTROL(unit)->tcam_protect_write) {
                    num_ipv6_128b_entries = (num_ipv6_128b_entries + 3) / 4 * 4;
                }
                config_v6_entries = num_ipv6_128b_entries;
                num_defip_entries = (SOC_CONTROL(unit)->l3_defip_max_tcams *
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) -
                                     (num_ipv6_128b_entries * 2);

                /* Adjust numbers for tcam_protect_write */
                if (SOC_CONTROL(unit)->tcam_protect_write) {
                    if (num_defip_entries) {
                        num_defip_entries -= 8;
                        /* Don't use up all entries as protect entries */
                        if (num_defip_entries <= 0) {
                            return SOC_E_CONFIG;
                        }
                        SOC_CONTROL(unit)->l3_defip_tcam_size --;
                    }
                    if (num_ipv6_128b_entries) {
                        num_ipv6_128b_entries -= 4;
                        /* Don't use up all entries as protect entries */
                        if (num_ipv6_128b_entries <= 0) {
                            return SOC_E_CONFIG;
                        }
                        SOC_CONTROL(unit)->l3_defip_tcam_size --;
                    }
                    if (config_v6_entries) {
                        config_v6_entries -= 4;
                        if (config_v6_entries < 0) {
                            return SOC_E_CONFIG;
                        }
                    }
                }
                sop->memState[L3_DEFIP_PAIR_128m].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = 
                                                num_ipv6_128b_entries - 1;
                sop->memState[L3_DEFIPm].index_max = num_defip_entries - 1;
    
                sop->memState[L3_DEFIP_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;
                sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 
                                       sop->memState[L3_DEFIPm].index_max;

                SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
            } else {
                sop->memState[L3_DEFIP_PAIR_128m].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = -1;
            }
        }
        soc_l3_defip_indexes_init(unit, config_v6_entries); 
    }
    if (NULL == _soc_td2_alpm_bkt_view_map[unit]) {
        if ((_soc_td2_alpm_bkt_view_map[unit] = 
             sal_alloc(sizeof(soc_mem_t) * SOC_TD2_ALPM_MAX_BKTS, 
                       "alpm_bkt_map")) == NULL) {
            return SOC_E_MEMORY;
        }
    }    
    if (dev_id == BCM56830_DEVICE_ID) {
         soc_bcm56830_mem_config(unit);
    }
    if (dev_id == BCM56834_DEVICE_ID) {
         soc_bcm56834_mem_config(unit);
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
         soc_td2p_mem_config(unit, dev_id, rev_id);
    }    
#endif

    memset(_soc_td2_alpm_bkt_view_map[unit], INVALIDm,
           sizeof(soc_mem_t) * SOC_TD2_ALPM_MAX_BKTS);
    return SOC_E_NONE;
}

int 
soc_trident2_alpm_mode_get(int unit)
{
    return _soc_alpm_mode[unit];
}


/* Map logical (always starts from 0 and contiguous) index to physical index 
   which can have a starting offset and/or holes.
   Input  : logical index
   Returns: physical index */
int
soc_trident2_l3_defip_index_map(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    int alpm_mode = _soc_alpm_mode[unit];
    int is_urpf_mode = SOC_CONTROL(unit)->l3_defip_urpf;
    int defip128_tbl_sz = SOC_CONTROL(unit)->l3_defip_index_remap;
    int phy_index;

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (SOC_CONTROL(unit)->tcam_protect_write_init) {
        int incr = 0, hole = 0;
        incr = soc_mem_index_count(unit, mem) /
               (SOC_L3_DEFIP_MAX_TCAMS_GET(unit) >> wide);
        hole = index / incr;
        if (defip128_tbl_sz == 0) {
            phy_index = index;
        } else {
            phy_index = soc_l3_defip_alpm_urpf_index_map(unit, wide, index);

        }
        if (SOC_CONTROL(unit)->tcam_protect_write) {
            if (defip128_tbl_sz == 0) {
                phy_index += hole;
            } else {
                if (wide && soc_mem_index_count(unit, L3_DEFIPm)) {
                    hole = hole * 2;
                } else if (!wide && soc_mem_index_count(unit, L3_DEFIP_PAIR_128m)) {
                    hole = hole + (hole / 2 * 2) + (hole % 2) + 1;
                }
                phy_index += hole;
            }
        }
        return phy_index;
    }

    if (defip128_tbl_sz == 0) {
        phy_index = index;
    } else if ((alpm_mode == 2 || alpm_mode == 0) && !is_urpf_mode) {
        phy_index = soc_l3_defip_index_map(unit, wide, index);
    } else if ((alpm_mode == 1 || alpm_mode == 3) && is_urpf_mode) {
        phy_index = soc_l3_defip_alpm_urpf_index_map(unit, wide, index);
    } else {
        phy_index = soc_l3_defip_urpf_index_map(unit, wide, index);
    }

    return phy_index;
}


/* Reverse map physical index to logical index.
   Input  : physical index
   Returns: logical index */
int
soc_trident2_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    int alpm_mode = _soc_alpm_mode[unit];
    int is_urpf_mode = SOC_CONTROL(unit)->l3_defip_urpf;
    int defip128_tbl_sz = SOC_CONTROL(unit)->l3_defip_index_remap;
    int log_index = 0;

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (SOC_CONTROL(unit)->tcam_protect_write_init) {
        int tcam_size = SOC_L3_DEFIP_TCAM_DEPTH_GET(unit);
        int hole = 0;
        if (soc_mem_index_count(unit, L3_DEFIP_PAIR_128m)) {
            tcam_size++;
            defip128_tbl_sz += 4;
        }
        if (soc_mem_index_count(unit, L3_DEFIPm)) {
            tcam_size++;
        }

        if (SOC_CONTROL(unit)->tcam_protect_write) {
            if (defip128_tbl_sz == 0) {
                hole = index / tcam_size;
                index -= hole;
            } else {
                hole = index / tcam_size;
                if (wide && soc_mem_index_count(unit, L3_DEFIPm)) {
                    hole = hole * 2;
                } else if (!wide && soc_mem_index_count(unit, L3_DEFIP_PAIR_128m)) {
                    hole = hole + (hole / 2 * 2) + (hole % 2) + 1;
                }
                index -= hole;
            }
        }
        if (defip128_tbl_sz == 0) {
            log_index = index;
        } else {
            log_index = soc_l3_defip_alpm_urpf_index_remap(unit, wide, index);
        }
        return log_index;
    }

    if (defip128_tbl_sz == 0) {
        log_index = index;
    } else if ((alpm_mode == 2 || alpm_mode == 0) && !is_urpf_mode) {
        log_index = soc_l3_defip_index_remap(unit, wide, index);
    } else if ((alpm_mode == 1 || alpm_mode == 3) && is_urpf_mode) {
        log_index = soc_l3_defip_alpm_urpf_index_remap(unit, wide, index);
    } else {
        log_index = soc_l3_defip_urpf_index_remap(unit, wide, index);
    }

    return log_index;
}

/* Given a physical index (always in terms of the narrow entry) 
   return the logical index and memory type */
int
soc_trident2_l3_defip_mem_index_get(int unit, int pindex, soc_mem_t *mem)
{
    int logical_index =  -1;
    int defip_pair_index = -1;
    int cam_size = SOC_L3_DEFIP_TCAM_DEPTH_GET(unit);
    int alpm_mode = _soc_alpm_mode[unit];
    int is_urpf_mode = SOC_CONTROL(unit)->l3_defip_urpf;
    int defip128_tbl_sz = SOC_CONTROL(unit)->l3_defip_index_remap;

    *mem = L3_DEFIPm;

    if (soc_feature(unit, soc_feature_l3_lpm_scaling_enable)) {
        return pindex;
    }

    if (SOC_CONTROL(unit)->tcam_protect_write_init) {
        int tcam_size = SOC_L3_DEFIP_TCAM_DEPTH_GET(unit);
        int hole = 0;
        if (soc_mem_index_count(unit, L3_DEFIP_PAIR_128m)) {
            tcam_size++;
            defip128_tbl_sz += 4;
        }
        if (soc_mem_index_count(unit, L3_DEFIPm)) {
            tcam_size++;
        }

        if (SOC_CONTROL(unit)->tcam_protect_write) {
            if (defip128_tbl_sz == 0) {
                hole = pindex / tcam_size;
                pindex -= hole;
            } else {
                hole = pindex / tcam_size;
                if (soc_mem_index_count(unit, L3_DEFIPm)) {
                    /*First look up in the double wide. If not find then look up in the single wide*/
                    *mem = L3_DEFIP_PAIR_128m;
                    hole = hole * 2;
                    logical_index = soc_l3_defip_alpm_urpf_index_remap(unit, 1,
                                                                       pindex - hole);
                    if (logical_index == -1) {
                        if (soc_mem_index_count(unit, L3_DEFIP_PAIR_128m)) {
                            *mem = L3_DEFIPm;
                            hole = hole + (hole / 2 * 2) + (hole % 2) + 1;
                            logical_index = soc_l3_defip_alpm_urpf_index_remap(unit,
                                                                               0,
                                                                               pindex - hole);
                        }
                    }
                }
                return logical_index;
            }
        }
        if (defip128_tbl_sz == 0) {
            *mem = L3_DEFIPm;
            logical_index = pindex;
        } else {
            *mem = L3_DEFIPm;
            logical_index = soc_l3_defip_alpm_urpf_index_remap(unit, 0, pindex);
            if (logical_index == -1) {
                *mem = L3_DEFIP_PAIR_128m;
                logical_index = soc_l3_defip_alpm_urpf_index_remap(unit, 1, pindex);
            }
        }
        return logical_index;
    }

    if ((alpm_mode == 2 || alpm_mode == 0) && !is_urpf_mode) {
        logical_index = soc_l3_defip_index_remap(unit, 0, pindex);
    } else if ((alpm_mode == 1 || alpm_mode == 3) && is_urpf_mode) {
        logical_index = soc_l3_defip_alpm_urpf_index_remap(unit, 0, pindex);
    } else {
        logical_index = soc_l3_defip_urpf_index_remap(unit, 0, pindex);
    }

    if (logical_index == -1) {
        *mem = L3_DEFIP_PAIR_128m;
        defip_pair_index = ((pindex / (cam_size * 2)) * cam_size) +
                           (pindex % cam_size);
        if ((alpm_mode == 2 || alpm_mode == 0) && !is_urpf_mode) {
            logical_index = soc_l3_defip_index_remap(unit, 1, defip_pair_index);
        } else if ((alpm_mode == 1 || alpm_mode == 3) && is_urpf_mode) {
            logical_index = soc_l3_defip_alpm_urpf_index_remap(unit, 1,
                                                               defip_pair_index);
        } else {
            logical_index = soc_l3_defip_urpf_index_remap(unit, 1,
                                                          defip_pair_index);
        }
    }

    return logical_index;
}

void
_soc_trident2_alpm_bkt_view_set(int unit, int index, soc_mem_t view)
{
    int bkt = (index >> 2) & SOC_TD2_ALPM_BKT_MASK;

    if (view != INVALIDm) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "ALPM bkt set index:%d bkt:%d view:%s\n"),
                     index, bkt, SOC_MEM_NAME(unit, view)));
    }
    _soc_td2_alpm_bkt_view_map[unit][bkt] = view;
}

soc_mem_t
_soc_trident2_alpm_bkt_view_get(int unit, int index)
{
    soc_mem_t view;
    int bkt = (index >> 2) & SOC_TD2_ALPM_BKT_MASK;
    
    view = _soc_td2_alpm_bkt_view_map[unit][bkt];
    if (view != INVALIDm) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "ALPM bkt get index:%d bkt:%d view:%s\n"),
                     index, bkt, SOC_MEM_NAME(unit, view)));
    }
    return view;
}

int
_soc_trident2_mem_sram_info_get(int unit, soc_mem_t mem, int index, 
                                _soc_ser_sram_info_t *sram_info)
{
    soc_mem_t view;
    int i, j, base, base_index, offset, base_bucket, bkt_offset;
    int entries_per_ram = 0, entries_per_bank, contiguous = 0;
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    sram_info->disable_reg = INVALIDr;
    sram_info->disable_field = INVALIDf;
    sram_info->force_reg = INVALIDr;
    sram_info->force_field = INVALIDf;

    switch (mem) {
    case L2Xm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L2_ENTRY_ONLY_ECCm:
#endif
        if (!SOC_IS_TD2P_TT2P(unit)) {
            sram_info->disable_reg = L2_ENTRY_PARITY_CONTROLr;
            sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            sram_info->force_field = FORCE_XOR_GENERATIONf;
        } else {
            if (mem == L2Xm) {
                sram_info->disable_reg = L2_ENTRY_PARITY_CONTROLr;
                sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            }
        }

        if (index < SOC_TD2_NUM_ENTRIES_L2_BANK) {
            if (!SOC_IS_TD2P_TT2P(unit)) {
                sram_info->force_reg = L2_ENTRY_CONTROL_6r;
            }
            sram_info->ram_count = SOC_TD2_NUM_EL_L2;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_BANK;
            offset = index % entries_per_ram;
            base = offset;
            if (index >= SOC_TD2_NUM_ENTRIES_PER_L2_BANK) {                
                base = offset + SOC_TD2_NUM_ENTRIES_PER_L2_BANK;
            }
        } else {
            if (!SOC_IS_TD2P_TT2P(unit)) {
                sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            }
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_SHARED_BANK;
            base_index = SOC_TD2_NUM_ENTRIES_L2_BANK;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            offset = base_index + (index % entries_per_ram);
            base = offset;
            for (i = 1; i < SOC_TD2_NUM_EL_L2; i++) {
                if (index >= (base_index + (entries_per_bank * i))) {
                    base = offset + (entries_per_bank * i);
                }
            }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                if (dev_id == BCM56867_DEVICE_ID) {
                    sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED;
                } else {
                    sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED/2;
                }
                entries_per_bank = entries_per_ram * sram_info->ram_count;
                for (i = 1; i < SOC_TD2_NUM_EL_L2; i++) {
                    if (index >= (base_index + (entries_per_bank * i))) {
                        base = offset + (entries_per_bank * i);
                    }
                }
            }
#endif
        }
        break;
    case L3_ENTRY_ONLYm:
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L3_ENTRY_ONLY_ECCm:
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            if (index < SOC_TD2_NUM_ENTRIES_L3_BANK) {
                /* dedicated L3 entries - hash table */
                sram_info->ram_count = 1;
                entries_per_ram = SOC_TD2_NUM_ENTRIES_L3_BANK;
                base = index;
            } else {
                if (dev_id == BCM56867_DEVICE_ID) {
                    sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED;
                } else {
                    sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED/2;
                }
                entries_per_ram = SOC_TD2_RAM_OFFSET_L3_NARROW;
                base_index = SOC_TD2_NUM_ENTRIES_L3_BANK;
                entries_per_bank = entries_per_ram * sram_info->ram_count;
                offset = base_index + (index % entries_per_ram);
                base = offset;
                for (i = 1; i < SOC_TD2P_NUM_EL_L3; i++) {
                    if (index >= (base_index + (entries_per_bank * i))) {
                        base = offset + (entries_per_bank * i);
                    }
                }
            }
        } else 
#endif
        {
            if ((soc_mem_index_count(unit, L3_ENTRY_ONLYm) <= SOC_TD2_NUM_ENTRIES_L3_BANK) ||
                (index < SOC_TD2_NUM_ENTRIES_L3_BANK)) {
                /* No SRAM XOR RAM in L3 banks, or the entry locates at dedicated L3 banks */
                return SOC_E_UNAVAIL;
            }
            sram_info->disable_reg = L3_ENTRY_PARITY_CONTROLr;
            sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
            sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            sram_info->force_field = FORCE_XOR_GENERATIONf;
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            entries_per_ram = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ? 
                               SOC_TD2_RAM_OFFSET_L3_NARROW : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                               SOC_TD2_RAM_OFFSET_L3_DOUBLE_WIDE :
                               SOC_TD2_RAM_OFFSET_L3_WIDE);
            base_index = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ?
                          SOC_TD2_NUM_ENTRIES_L3_BANK : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                          SOC_TD2_NUM_ENTRIES_L3_BANK_DOUBLE_WIDE :
                          SOC_TD2_NUM_ENTRIES_L3_BANK_WIDE);
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            offset = base_index + (index % entries_per_ram);
            base = offset;
            for (i = 1; i < SOC_TD2_NUM_EL_ALPM; i++) {
                if (index >= (base_index + (entries_per_bank * i))) {
                    base = offset + (entries_per_bank * i);
                }
            }
        }
        break;
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
    case L3_DEFIP_ALPM_RAWm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L3_DEFIP_ALPM_ECCm:
#endif
        sram_info->disable_reg = ILPM_SER_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
        sram_info->force_field = FORCE_XOR_GENERATIONf;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            sram_info->ram_count = SOC_TD2P_NUM_EL_SHARED/2;
            base_bucket = ((index >> 2) & SOC_TD2_ALPM_BKT_MASK);
            base = index & 0x3;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "reported bucket: 0x%08x, bank:%d\n"), base_bucket, base));
            base_bucket = base_bucket % SOC_TD2_ALPM_BKT_OFFFSET;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "base bucket: 0x%08x\n"), base_bucket));
            for (i = 0; i < SOC_TD2_NUM_EL_SHARED; i++) {
                sram_info->view[i] = mem;
                sram_info->index_count[i] = 1;
                bkt_offset = base_bucket + SOC_TD2_ALPM_BKT_OFFFSET * i;
                sram_info->mem_indexes[i][0] =
                    (index & SOC_TD2P_ALPM_MODE0_BKT_MASK) |
                    (bkt_offset << 2) | base;
            }
        } else
#endif
        {
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            base_bucket = ((index  >> 2) & SOC_TD2_ALPM_BKT_MASK);
            base = index & 0x3;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "reported bucket: 0x%08x, bank:%d\n"), base_bucket, base));
            base_bucket = base_bucket % SOC_TD2_ALPM_BKT_OFFFSET;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "base bucket: 0x%08x\n"), base_bucket));
            
            for (i = 0; i < SOC_TD2_NUM_EL_SHARED; i++) {
                /* Retreive views for all 8 buckets */
                bkt_offset = base_bucket + SOC_TD2_ALPM_BKT_OFFFSET * i;
                view = _soc_td2_alpm_bkt_view_map[unit][bkt_offset];
                if (INVALIDm != view) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "\nbucket[%d]: 0x%08x view: %s\n"), i, bkt_offset,
                                            SOC_MEM_NAME(unit, view)));
                }
                /* Use RAW view to recovery those unused ALPM buckets and avoid
                 * false alarm */
                if (INVALIDm == view) {
                    view = L3_DEFIP_ALPM_RAWm;
                }
                sram_info->view[i] = view;
                switch (view) {
                case L3_DEFIP_ALPM_RAWm:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV6_128m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_128_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][1] = (1 << 16) | (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV6_64_1m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_64_1_PER_BKT_COUNT;
                    sram_info->mem_indexes[i][0] = (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][1] = (1 << 16) | (bkt_offset << 2) | base;
                    sram_info->mem_indexes[i][2] = (2 << 16) | (bkt_offset << 2) | base;
                    break;
                case L3_DEFIP_ALPM_IPV4m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV4_PER_BKT_COUNT;
                    for (j = 0; j < SOC_TD2_L3_DEFIP_ALPM_IPV4_PER_BKT_COUNT; j++) {
                        sram_info->mem_indexes[i][j] = (j << 16) | (bkt_offset << 2) |
                                                       base;                
                    }
                    break;
                case L3_DEFIP_ALPM_IPV4_1m:
                case L3_DEFIP_ALPM_IPV6_64m:
                    sram_info->index_count[i] = SOC_TD2_L3_DEFIP_ALPM_IPV6_64_PER_BKT_COUNT;
                    for (j = 0; j < SOC_TD2_L3_DEFIP_ALPM_IPV6_64_PER_BKT_COUNT; j++) {
                        sram_info->mem_indexes[i][j] = (j << 16) | (bkt_offset << 2) |
                                                       base;                
                    }
                default:
                    break;
                }
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Entries per bkt: %d\n"), sram_info->index_count[i]));
                for (j = 0; j < sram_info->index_count[i]; j++) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "Index[%d]: [0x%08x]%d\n"), j, sram_info->mem_indexes[i][j],
                                            sram_info->mem_indexes[i][j]));
                }
            }
        }
        return SOC_E_NONE;
    case VLAN_XLATEm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case VLAN_XLATE_ECCm:
#endif
        contiguous = 1;
        sram_info->disable_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_VLAN_XLATE;
        base = (index/4) * 4;
        break;
    case EGR_VLAN_XLATEm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case EGR_VLAN_XLATE_ECCm:
#endif
        contiguous = 1;
        sram_info->disable_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_EGR_VLAN_XLATE;
        base = (index/4) * 4;
        break;
    case ING_L3_NEXT_HOPm:
        sram_info->ram_count = SOC_TD2_NUM_EL_ING_L3_NEXT_HOP;
        entries_per_ram = SOC_TD2_RAM_OFFSET_ING_L3_NEXT_HOP;
        base = index % entries_per_ram;
        break;
    case L3_IPMCm:
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            sram_info->ram_count = SOC_TD2P_NUM_EL_L3_IPMC;
        } else
#endif
        {
            sram_info->ram_count = SOC_TD2_NUM_EL_L3_IPMC;
        }
        entries_per_ram = SOC_TD2_RAM_OFFSET_L3_IPMC;
        if (dev_id == BCM56832_DEVICE_ID) {
            entries_per_ram = 1024;
        }
        base = index % entries_per_ram;
        break;
    case L2MCm:
        sram_info->ram_count = SOC_TD2_NUM_EL_L2MC(unit);
        entries_per_ram = SOC_TD2_RAM_OFFSET_L2MC;
        base = index % entries_per_ram;
        break;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    case L2_ENTRY_LPm:
    case L3_ENTRY_LPm:
    case VLAN_XLATE_LPm:
    case EGR_VLAN_XLATE_LPm:
        sram_info->view[0] = mem;
        sram_info->index_count[0] = 1;
        sram_info->ram_count = 1;
        entries_per_ram = 0;
        base = index;
        break;
#endif
    default: return SOC_E_PARAM;
    }
    sram_info->mem_indexes[0][0] = base;
    if (contiguous) {
        for (i = 1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i][0] = sram_info->mem_indexes[i-1][0] + 1;
        }
    } else {
        for (i = 1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i][0] =  sram_info->mem_indexes[i-1][0] + entries_per_ram;
        }
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_cpu_write_control(int unit, soc_mem_t mem, int copyno,
                                    int enable, int *orig_enable)
{
    soc_reg_t reg;
    soc_field_t field;
    int blk, port;
    uint32 rval, fval, orig_fval, enable_fval, disable_fval;

    enable_fval = 1;
    disable_fval = 0;

    switch (mem) {
    case XLPORT_WC_UCMEM_DATAm:
        reg = XLPORT_WC_UCMEM_CTRLr;
        field = ACCESS_MODEf;
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            /* It will use the setting from the last block */
            *orig_enable = soc_reg_field_get(unit, reg, rval, field);
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
        return SOC_E_NONE;
    case MMU_CFAP_BANK0m:
    case MMU_CFAP_BANK1m:
    case MMU_CFAP_BANK10m:
    case MMU_CFAP_BANK11m:
    case MMU_CFAP_BANK12m:
    case MMU_CFAP_BANK13m:
    case MMU_CFAP_BANK14m:
    case MMU_CFAP_BANK15m:
    case MMU_CFAP_BANK16m:
    case MMU_CFAP_BANK17m:
    case MMU_CFAP_BANK18m:
    case MMU_CFAP_BANK19m:
    case MMU_CFAP_BANK2m:
    case MMU_CFAP_BANK20m:
    case MMU_CFAP_BANK3m: 
    case MMU_CFAP_BANK4m: 
    case MMU_CFAP_BANK5m: 
    case MMU_CFAP_BANK6m: 
    case MMU_CFAP_BANK7m: 
    case MMU_CFAP_BANK8m:
    case MMU_CFAP_BANK9m:
#ifdef BCM_TOMAHAWK_SUPPORT
        if(SOC_IS_TOMAHAWKX(unit)) {
            reg=MMU_GCFG_MISCCONFIGr;
        } else
#endif
        {
            reg=MISCCONFIGr;
        }
        field=INIT_MEMf;
        enable_fval=1;
        disable_fval=0;
        break;

    case L3_DEFIP_ALPM_RAWm:
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
        reg = ISS_MEMORY_CONTROL_84r;
        field = BYPASS_ISS_MEMORY_LPf;
        enable_fval = 0xf;
        break;
    case MMU_INTFI_PFC_ST_TBLm:
        reg = INTFI_CFGr;
        field = PFC_ST_TBL_DISABLEf;
        break;
    case LINK_STATUSm:
        reg = SW2_HW_CONTROLr;
        field = LINK_STATUS_UPDATE_ENABLEf;
        break;
    case MMU_INTFO_QCN_CNM_TIMER_TBLm:
    case MMU_INTFI_XPIPE_FC_MAP_TBL2m:
    case MMU_INTFI_YPIPE_FC_MAP_TBL2m:
        reg = MISCCONFIGr;
        field = REFRESH_ENf;
        enable_fval = 0;
        disable_fval = 1;
        break;
    default:
        return SOC_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    orig_fval = soc_reg_field_get(unit, reg, rval, field);
    fval = enable ? enable_fval : disable_fval;

    *orig_enable = orig_fval == enable_fval;
    if (fval != orig_fval) {
        soc_reg_field_set(unit, reg, &rval, field, fval);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    }

    return SOC_E_NONE;
}

/*
 * cpu port (mmu port 0): 48 queues (2000-2047)
 * loopback port (mmu port 116): 8 queues (4048-4055)
 */
int
soc_trident2_num_cosq_init(int unit)
{
    soc_info_t *si;
    int port, phy_port, mmu_port, mmu_port_offset, pipe;
    int uc_cosq_base, mc_cosq_base, uc_cosq_per_port;
    uint16 dev_id;
    uint8 rev_id;

    si = &SOC_INFO(unit);

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        si->port_num_cosq[CMIC_PORT(unit)] = 48;
    } else 
#endif
    {
        si->port_num_cosq[CMIC_PORT(unit)] = (rev_id >= BCM56850_A1_REV_ID) ? 44 : 48;
    }
    si->port_cosq_base[CMIC_PORT(unit)] = 520;
    si->port_num_cosq[LB_PORT(unit)] = 9; 
    si->port_cosq_base[LB_PORT(unit)] = 1088;

    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        if (pipe) { /* Y-pipe */
            uc_cosq_base = 1480;
            mc_cosq_base = 568;
        } else { /* X-pipe */
            uc_cosq_base = 0;
            mc_cosq_base = 0;
        }
        for (mmu_port_offset = 0; mmu_port_offset < _TD2_MMU_PORTS_PER_PIPE;
             mmu_port_offset++) {
            mmu_port = si->mmu_port_base[pipe] + mmu_port_offset;
            phy_port = si->port_m2p_mapping[mmu_port];
            if (phy_port == -1) {
                continue;
            }
            port = si->port_p2l_mapping[phy_port];

            if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
                continue;
            }

            if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base + (mmu_port_offset * si->port_num_cosq[port]);
                si->port_num_uc_cosq[port] = 10;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TD2P_TT2P(unit)) {
                    /* Made port_uc_cosq_base a function of mmu_port number
                     * rather than a running number (as calculated by
                     * uc_cosq_base before). If it is a running number, &
                     * the port numbers come & go dynamically (as in flex port)
                     * uc_cosq_base overlap. With port_uc_cosq_base a function
                     * of mmu_port, each port has a fixed offset
                     * */
                    si->port_uc_cosq_base[port] = uc_cosq_base + (mmu_port_offset * 10);
                } else
#endif
                {
                    si->port_uc_cosq_base[port] = uc_cosq_base;
                    uc_cosq_base += si->port_num_uc_cosq[port];
                }
            } else {
                uc_cosq_per_port =
                    soc_property_port_get(unit, port, spn_LLS_NUM_L2UC, 10);
                if (uc_cosq_per_port < 10 || uc_cosq_per_port > 16) {
                    uc_cosq_per_port = 10;
                }
                uc_cosq_per_port = (uc_cosq_per_port + 3) & ~3;

                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base + (mmu_port_offset * si->port_num_cosq[port]);
                si->port_num_uc_cosq[port] = uc_cosq_per_port;
                /* uc_cosq_base for LLS port must be
                 * divisible by 4 for PFC to work */
                uc_cosq_base = (uc_cosq_base + 3) & (~3);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TD2P_TT2P(unit)) {
                    /* Made port_uc_cosq_base a function of mmu_port
                     * number rather than a running number (as calculated by
                     * uc_cosq_base before).vIf it is a running number, & the
                     * port numbers come & go dynamically (as in flex port)
                     * uc_cosq_base overlap. With port_uc_cosq_base a function
                     * of mmu_port, each port has a fixed offset
                     * */
                    si->port_uc_cosq_base[port] =
                       uc_cosq_base + (mmu_port_offset * uc_cosq_per_port);
                } else
#endif
                {
                    si->port_uc_cosq_base[port] = uc_cosq_base;
                    uc_cosq_base += si->port_num_uc_cosq[port];
                }
            }
        }
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_max_frequency_get(int unit,  uint16 dev_id, uint8 rev_id,
                               int skew_id, int *frequency)
{
    switch (dev_id) {
    case BCM56861_DEVICE_ID:
    case BCM56864_DEVICE_ID:
        *frequency = 635;
        break;
    case BCM56860_DEVICE_ID:
    case BCM56862_DEVICE_ID:
    case BCM56865_DEVICE_ID:
    case BCM56866_DEVICE_ID:
    case BCM56867_DEVICE_ID:
    case BCM56868_DEVICE_ID:
    case BCM56836_DEVICE_ID:
        *frequency = 793;
        break;
    case BCM56832_DEVICE_ID:
        *frequency = 421;
        break;
    case BCM56833_DEVICE_ID:
        *frequency = 537;
        break;
    case BCM56850_DEVICE_ID:
    case BCM56852_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
    case BCM56834_DEVICE_ID:   	
        *frequency = rev_id < BCM56850_A2_REV_ID ? 760 : 793;
        break;
    case BCM56851_DEVICE_ID: /* Cannot handle 56851P */
        if (skew_id == 2) { /* 56851P */
            *frequency = rev_id < BCM56851_A2_REV_ID ? 518 : 537;
        } else {
            *frequency = rev_id < BCM56851_A2_REV_ID ? 608 : 635;
        }
        break;
    case BCM56854_DEVICE_ID:
        *frequency = rev_id < BCM56854_A2_REV_ID ? 608 : 635;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_max_io_frequency_get(int unit,  uint16 dev_id, uint8 rev_id,
                               int skew_id, int *iof)
{
    int frequency;

    switch (dev_id) {
    case BCM56860_DEVICE_ID:
    case BCM56861_DEVICE_ID:
    case BCM56866_DEVICE_ID:
    case BCM56867_DEVICE_ID:
    case BCM56868_DEVICE_ID:
    case BCM56836_DEVICE_ID:
        frequency = 1280000;
        break;
    case BCM56862_DEVICE_ID:
    case BCM56865_DEVICE_ID:
        frequency = 960000;
        break;
    case BCM56832_DEVICE_ID:
    case BCM56833_DEVICE_ID:
        frequency = 1080000;
        break;
    /*TD2*/ 
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
	case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56834_DEVICE_ID:   	
        frequency = 1280000;
        break;
    case BCM56830_DEVICE_ID:
    case BCM56852_DEVICE_ID:
        frequency = 960000;
        break;
    case BCM56854_DEVICE_ID:
    case BCM56864_DEVICE_ID:
        frequency = 720000;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    *iof = frequency;

    return SOC_E_NONE;
}

int
soc_trident2_tsc_map_get(int unit, uint32 *tsc_map)
{
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    switch (dev_id) {
    case BCM56861_DEVICE_ID: 
    case BCM56865_DEVICE_ID:
    case BCM56866_DEVICE_ID:
    case BCM56867_DEVICE_ID: 
    case BCM56868_DEVICE_ID:
    case BCM56860_DEVICE_ID: 
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56834_DEVICE_ID:   
    case BCM56833_DEVICE_ID:
    case BCM56836_DEVICE_ID:
        *tsc_map = 0xffffffff;
        break;
    case BCM56862_DEVICE_ID:
    case BCM56852_DEVICE_ID:
    case BCM56830_DEVICE_ID:
        *tsc_map = 0xe7e7e7ef;
        break;
    case BCM56854_DEVICE_ID:
    case BCM56864_DEVICE_ID:
        *tsc_map = 0x0f1ff8e8;
        break;
    case BCM56832_DEVICE_ID: 
        *tsc_map = 0xeff7efe7;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

typedef struct soc_td2_valid_fallback_lanes_s {
    soc_100g_lane_config_t lane_config;
    int                    valid_lanes[3];
}soc_td2_valid_fallback_lanes_t;

const soc_td2_valid_fallback_lanes_t soc_td2_valid_lanes[] = {
    {SOC_LANE_CONFIG_100G_4_4_2, {TRUE, TRUE, TRUE} },
    {SOC_LANE_CONFIG_100G_3_4_3, {TRUE, TRUE, TRUE} },
    {SOC_LANE_CONFIG_100G_2_4_4, {TRUE, TRUE, TRUE} },
    {SOC_INVALID_LANE_CONFIG}
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT
/*
 * Function:
 *      _soc_td2p_lane_speed_valid_check 
 * Purpose:
 *      Validates a given port speed against allowed
 *      lane configuration. Checks for valid lane values too. 
 * Parameters:
 *      unit       - (IN) Unit number.
 *      lanes      - (IN) Number of lanes used by port
 *      port_speed - (IN) Port Bandwidth of port.
 *
 * Returns:
 *      SOC_E_XXX
 */
STATIC int
_soc_td2p_lane_speed_valid_check(int unit, int lanes, int port_speed)
{
    int rv = SOC_E_NONE;

    switch (lanes) {
        case 1:
            if (port_speed != SPEED_1G   && \
                port_speed != SPEED_2p5G && \
                port_speed != SPEED_10G  && \
                port_speed != SPEED_11G) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "Invalid #lanes=(%d) "
                                          "for Speed=(%d)\n"),
                                          lanes, port_speed));
                rv = SOC_E_CONFIG;
            }
            break;
        case 2:
            if (port_speed != SPEED_10G  && \
                port_speed != SPEED_20G  && \
                port_speed != SPEED_21G) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "Invalid #lanes=(%d) "
                                          "for Speed=(%d)\n"),
                                          lanes, port_speed));
                rv = SOC_E_CONFIG;
            }
            break;
        case 4:
            if (SOC_IS_TITAN2PLUS(unit) && \
                (port_speed == SPEED_13G || port_speed == SPEED_16G)){
                break;
            }

            if (port_speed != SPEED_10G  && \
                port_speed != SPEED_20G  && \
                port_speed != SPEED_42G  && \
                port_speed != SPEED_40G  && \
                port_speed != SPEED_11G) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "Invalid #lanes=(%d) "
                                          "for Speed=(%d)\n"),
                                          lanes, port_speed));
                rv = SOC_E_CONFIG;
            }
            break;
        case 10:
            if (port_speed != SPEED_100G  && \
                port_speed != SPEED_106G) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "Invalid #lanes=(%d) "
                                          "for Speed=(%d)\n"),
                                          lanes, port_speed));
                rv = SOC_E_CONFIG;
            }
            break;
        case 12:
            if (port_speed != SPEED_127G) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "Invalid #lanes=(%d) "
                                          "for Speed=(%d)\n"),
                                          lanes, port_speed));
                rv = SOC_E_CONFIG;
            }
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit, "Invalid #lanes=(%d) specified\n"),
                                  lanes));
            rv = SOC_E_CONFIG;
    }

    return rv;
}
#endif

STATIC int
_soc_td2_port_speed_supported(int unit, soc_port_t port, int port_bandwidth)
{
    int rv;
    soc_pbmp_t my_pbmp_xport_xe;

    switch (port_bandwidth) {
    case 1000:
    case 10000:
    case 15000:
    case 20000:
    case 30000:
    case 40000:
    case 100000:
    case 120000:
        rv = SOC_E_NONE;
        break;
    case 13000:
    case 16000:
        if (!SOC_IS_TITAN2PLUS(unit)) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Invalid bandwidth %d Gb\n"),
                     port, port_bandwidth / 1000));
            rv = SOC_E_FAIL;
            break;
        }
    case 11000:
    case 21000:
    case 42000:
    case 106000:
    case 127000:
        SOC_PBMP_CLEAR(my_pbmp_xport_xe);
        my_pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                         my_pbmp_xport_xe);
        if (!SOC_PBMP_MEMBER(my_pbmp_xport_xe, port)) {
            rv = SOC_E_NONE;
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Invalid bandwidth %d Gb\n"),
                     port, port_bandwidth / 1000));
            rv = SOC_E_FAIL;
        }
        break;
    default:
        LOG_CLI((BSL_META_U(unit,
                            "Port %d: Invalid bandwidth %d Gb\n"),
                 port, port_bandwidth / 1000));
        rv = SOC_E_FAIL;
        break;
    }
    return rv;
}

STATIC int
soc_trident2_port_inactive_port_check(int unit, uint32 blk_inactive_map,
                                      int *blk_port, int *blk_port_bandwidth)
{
#define SOC_TRIDENT2_LANE0_MASK 0x1
#define SOC_TRIDENT2_LANE1_MASK 0x2
#define SOC_TRIDENT2_LANE2_MASK 0x4
#define SOC_TRIDENT2_LANE3_MASK 0x8
    int rv = SOC_E_NONE;
    int port, index;
    soc_info_t *si;

    si = &SOC_INFO(unit);

    /* use ieee bandwidth */
    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
        blk_port_bandwidth[index]
            = SOC_PORTCTRL_HG2_TO_IEEE_BW_GET(blk_port_bandwidth[index]);
    }
    if(SOC_IS_TD2P_TT2P(unit)) {
        if (blk_inactive_map & SOC_TRIDENT2_LANE0_MASK) {
            /* Lane 0 is inactive */
            LOG_CLI((BSL_META_U(unit,
                                "Port %d cannot be inactive\n"),
                     blk_port[0]));
            return SOC_E_FAIL;
        } else {
            /* Lane0 is active */
            if (blk_inactive_map & SOC_TRIDENT2_LANE2_MASK) {
                if ((blk_inactive_map & SOC_TRIDENT2_LANE1_MASK) &&
                    (blk_inactive_map & SOC_TRIDENT2_LANE3_MASK)) {
                    return SOC_E_NONE;
                } else {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d can be inactive if "
                                        "lane 1,2,3 are inactive\n"),
                             blk_port[0]));
                    return SOC_E_FAIL;
                }
            } else {
                /* Both Lane0 & Lane2 are active */
                port = blk_port[0];
                if (blk_inactive_map & SOC_TRIDENT2_LANE1_MASK) {
                    if (blk_port_bandwidth[0] < blk_port_bandwidth[1] * 2) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Port %d bandwidth %d Gb is not "
                                            "enough to cover flex port for "
                                            "port %d\n"),
                                 port, si->port_speed_max[port] / 1000,
                                 blk_port[1]));
                        return SOC_E_FAIL;
                    }
                }

                port = blk_port[2];
                if (blk_inactive_map & SOC_TRIDENT2_LANE3_MASK) {
                    if (blk_port_bandwidth[2] < blk_port_bandwidth[3] * 2) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Port %d bandwidth %d Gb is not "
                                            "enough to cover flex port for "
                                            "port %d\n"),
                                 port, si->port_speed_max[port] / 1000,
                                 blk_port[3]));
                        return SOC_E_FAIL;
                    }
                }
            }
        }
    } else {
        port = blk_port[2];
        if (port != -1) {
            /* Check reserved bandwidth if lane 3 is inactive flex
             * port and lane 2 is active */
            if ((blk_inactive_map & 0x0c) == 0x08 &&
                blk_port_bandwidth[2] <
                blk_port_bandwidth[3] * 2) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d bandwidth %d Gb is not "
                                    "enough to cover flex port for "
                                    "port %d\n"),
                         port, si->port_speed_max[port] / 1000,
                         blk_port[3]));
                rv = SOC_E_FAIL;
            }
        }

        port = blk_port[0];
        if (port != -1) {
            /* Check reserved bandwidth if lane 3 is inactive flex
             * port and lane 0 is active */
            if ((blk_inactive_map & 0x09) == 0x08 &&
                blk_port_bandwidth[0] <
                blk_port_bandwidth[3] * 4) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d bandwidth %d Gb is not "
                                    "enough to cover flex port for "
                                    "port %d\n"),
                         port, si->port_speed_max[port] / 1000,
                         blk_port[3]));
                rv = SOC_E_FAIL;
            }

            /* Check reserved bandwidth if lane 2 is inactive flex
             * port and lane 0 is active */
            if ((blk_inactive_map & 0x05) == 0x04 &&
                blk_port_bandwidth[0] <
                blk_port_bandwidth[2] * 2) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d bandwidth %d Gb is not "
                                    "enough to cover flex port for "
                                    "port %d\n"),
                         port, si->port_speed_max[port] / 1000,
                         blk_port[2]));
                rv = SOC_E_FAIL;
            }

            /* Check reserved bandwidth if lane 1 is inactive flex
             * port and lane 0 is active */
            if ((blk_inactive_map & 0x03) == 0x02 &&
                blk_port_bandwidth[0] <
                blk_port_bandwidth[1] * 4) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d bandwidth %d Gb is not "
                                    "enough to cover flex port for "
                                    "port %d\n"),
                         port, si->port_speed_max[port] / 1000,
                         blk_port[1]));
                rv = SOC_E_FAIL;
            }
        }
    }

    return rv;
}

/*
 * Function:
 *      soc_trident2_soc_info_misc_t_init
 * Purpose:
 *      Initialize soc_info_misc_t structure by the current SOC_INFO(unit).
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      si_m - soc_info_misc data
 * Note:
 *      port_speed is initialized by si->port_speed_max
 */
void
soc_trident2_soc_info_misc_t_init(int unit, soc_info_misc_t *si_m)
{
    soc_info_t *si = &SOC_INFO(unit);
    int i;
    int logic_port;
    int phy_port;

    sal_memset(si_m, 0, sizeof(*si_m));

    /* Get current information */
    for (i = 0; i < SOC_MAX_NUM_PORTS; i++) {
        si_m->port_l2p_mapping[i] = si->port_l2p_mapping[i];
        si_m->port_p2l_mapping[i] = si->port_p2l_mapping[i];
        si_m->port_speed_max[i] = si->port_speed_max[i];
        si_m->port_num_lanes[i] = si->port_num_lanes[i];
        si_m->port_speed[i] = -1;
        si_m->port_encap[i] = -1;

        logic_port = i;
        phy_port = si->port_l2p_mapping[logic_port];

        /* Skip ports not defined, LB, CPU, etc. */
        /* coverity[overrun-local] */
        if (!SOC_PORT_ADDRESSABLE(unit, logic_port) ||
            !((phy_port >= 0) && (phy_port <= TRIDENT2_PHY_PORT_MAX)) ||
            IS_LB_PORT(unit, logic_port) ||
            IS_CPU_PORT (unit, logic_port)) {
            continue;
        }

        si_m->port_speed[logic_port] = si->port_speed_max[logic_port];

        /*
         * Get encapsulation mode
         *
         * Validate need to differentiate between HG and non-HG modes,
         * so using SOC_ENCAP_HIGIG2 and SOC_ENCAP_IEEE will suffice
         * to indicate HG vs non-HG.
         */
        /* coverity[overrun-local] */
        if (IS_HG_PORT(unit, logic_port)) {
            si_m->port_encap[logic_port] = SOC_ENCAP_HIGIG2;
        } else {
            si_m->port_encap[logic_port] = SOC_ENCAP_IEEE;
        }
    }
    si_m->bandwidth = si->bandwidth;
    SOC_PBMP_ASSIGN(si_m->oversub_pbm, si->oversub_pbm);
    SOC_PBMP_ASSIGN(si_m->disabled_bitmap, si->all.disabled_bitmap);
    SOC_PBMP_ASSIGN(si_m->management_pbm, si->management_pbm);

    return;
}

/*
 * Function:
 *      soc_trident2_port_bandwidth_validate
 * Purpose:
 *      Validate the pgw port bandwidth
 * --------------------------------------------
 * | Frequency | Linerate bandwidth per quad  |
 * | 480MHz    | 120G                         |
 * | 640MHz    | 160G                         |
 * | 720MHz    | Quad X-0 [port 1-32]  : 160G |
 * |           | Quad X-1 [port 33-64] : 200G |
 * |           | Quad Y-0 [port 65-96] : 200G |
 * |           | Quad Y-1 [port 97-128]: 160G |
 * | 760MHz    | 240G                         |
 * --------------------------------------------
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      si_m - soc_info_misc data
 * Returns:
 *      SOC_E_NONE
 *      SOC_E_FAIL
 */
int
soc_trident2_port_bandwidth_validate(int unit, soc_info_misc_t *si_m)
{
    int rv = SOC_E_NONE;
    int pipe, quad, pgw, blk;
    int blk_linerate_bandwidth, blk_oversub_bandwidth;
    int pgw_linerate_bandwidth, pgw_oversub_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    int max_quad_core_bandwidth[_TD2_QUADS_PER_DEV];
    int port_bandwidth;
    uint32 blk_configured_map;
    uint32 blk_management_map, blk_inactive_map, blk_oversub_map;
    int port, phy_port;
    int lane_count;
    int index;
    int pgw_port[_TD2_PORTS_PER_PGW], *blk_port;
    int pgw_port_bandwidth[_TD2_PORTS_PER_PGW], *blk_port_bandwidth;
    int i;

    /* Setup max bandwidth for each per quadrant */
    if (si_m->bandwidth == 720000) {
        max_quad_core_bandwidth[0] = max_quad_core_bandwidth[3] = 160000;
        max_quad_core_bandwidth[1] = max_quad_core_bandwidth[2] = 200000;
    } else {
        for (quad = 0; quad < _TD2_QUADS_PER_DEV; quad++) {
            max_quad_core_bandwidth[quad] = si_m->bandwidth / 4;
        }
    }

    /* Bandwidth check for ports in each XLPORT/CPORT block */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) {
            quad_linerate_bandwidth = 0;
            quad_oversub_bandwidth = 0;
            for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) {
                pgw_linerate_bandwidth = 0;
                pgw_oversub_bandwidth = 0;

                /* Prepare per PGW local variables for ease of processing */
                for (index = 0; index < _TD2_PORTS_PER_PGW; index++) {
                    phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE +
                        quad * _TD2_PORTS_PER_QUAD +
                        pgw * _TD2_PORTS_PER_PGW + index;
                    port = si_m->port_p2l_mapping[phy_port];
                    pgw_port[index] = port;
                    if (port == -1) {
                        pgw_port_bandwidth[index] = 0;
                    } else if (si_m->port_speed_max[port] < 2500) {
                        pgw_port_bandwidth[index] = 2500;
                    } else {
                        pgw_port_bandwidth[index] = si_m->port_speed_max[port];
                    }
                }

                for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) {
                    blk_port = &pgw_port[blk * _TD2_PORTS_PER_XLP];
                    blk_port_bandwidth =
                        &pgw_port_bandwidth[blk * _TD2_PORTS_PER_XLP];
                    blk_configured_map = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        if (blk_port[index] != -1) {
                            blk_configured_map |= 1 << index;
                        }
                    }
                    if (blk_configured_map == 0) {
                        continue;
                    }

                    /* Management port block (XLPORT3) handling */
                    if (pipe == 0 && quad == 0 && pgw == 0 && blk == 3 &&
                        SOC_PBMP_NOT_NULL(si_m->management_pbm)) {
                        blk_management_map = 0;
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            if (SOC_PBMP_MEMBER(si_m->management_pbm, port)) {
                                blk_management_map |= 1 << index;
                            }
                        }
                        if (blk_management_map != blk_configured_map) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port")));
                            for (index = 0; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                if (blk_port[index] != -1) {
                                    LOG_CLI((BSL_META_U(unit,
                                                        " %d"), blk_port[index]));
                                }
                            }
                            LOG_CLI((BSL_META_U(unit,
                                                ": Can not be configured to "
                                                "different management port status\n")));
                            rv = SOC_E_FAIL;
                            continue;
                        }

                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            phy_port = si_m->port_l2p_mapping[port];
                            port_bandwidth = blk_port_bandwidth[index];
                            if (port_bandwidth > 10000 ||
                                (port_bandwidth > 2500 && index != 0)) {
                                LOG_CLI((BSL_META_U(unit,
                                                    "Management port %d: "
                                                    "Physical port %d can not be "
                                                    "configured to %d Gb\n"),
                                         port, phy_port,
                                         port_bandwidth / 1000));
                                rv = SOC_E_FAIL;
                                continue;
                            }
                        }
                        port_bandwidth = blk_port_bandwidth[0];
                        if (port_bandwidth > 2500) {
                            for (index = 1; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                port = blk_port[index];
                                if (port == -1) {
                                    continue;
                                }
                                LOG_CLI((BSL_META_U(unit,
                                                    "Management port %d bandwidth %d "
                                                    "Gb and port %d can not be both "
                                                    "configured\n"),
                                         blk_port[0],
                                         port_bandwidth / 1000, port));
                                rv = SOC_E_FAIL;
                            }
                        }
                        continue;
                    }

                    /* Normal port block handling */
                    blk_inactive_map = 0;
                    blk_oversub_map = 0;
                    blk_linerate_bandwidth = 0;
                    blk_oversub_bandwidth = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        int real_port_bandwidth;

                        port = blk_port[index];
                        if (port == -1) {
                            continue;
                        }
                        port_bandwidth = blk_port_bandwidth[index];
                        real_port_bandwidth = port_bandwidth;
                        if (SOC_PBMP_MEMBER(si_m->oversub_pbm, port)) {
                            blk_oversub_map |= 1 << index;
                        }
                        if (SOC_PBMP_MEMBER(si_m->disabled_bitmap, port)) {
                            blk_inactive_map |= 1 << index;
                        } else {
                            /* 13G/16G uses 21G bandwidth */
                            if (SOC_IS_TITAN2PLUS(unit) &&
                                ((port_bandwidth == 13000) ||
                                 (port_bandwidth == 16000))) {
                                real_port_bandwidth = 21000;
                            }
                            if (blk_oversub_map & (1 << index)) {
                                blk_oversub_bandwidth += real_port_bandwidth;
                            } else {
                                blk_linerate_bandwidth += real_port_bandwidth;
                            }
                        }
                        if ((port_bandwidth > 42000 &&
                             (index != 0 || blk != (pgw & 1))) ||
                            (port_bandwidth > 21000 && index != 0) ||
                            (SOC_IS_TITAN2PLUS(unit) &&
                            ((port_bandwidth == 13000 && index != 0) ||
                            (port_bandwidth == 16000 && index != 0))) ||
                            (port_bandwidth > 11000 && (index & 1))) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d: Physical port %d can not "
                                                "be configured to %d Gb\n"),
                                     port, si_m->port_l2p_mapping[port],
                                     port_bandwidth / 1000));
                            rv = SOC_E_FAIL;
                        }

                        /*
                         * max_quad_core_bandwidth is 240G(= 960/4).
                         * If port is defined HG11,HG21,HG42,HG106,HG127, then
                         * max_quad_core_bandwidth needs to be adjusted to
                         * accept HG speed. */
                        i = pipe * _TD2_QUADS_PER_PIPE + quad;
                        if (real_port_bandwidth == 127000) {
                            max_quad_core_bandwidth[i] += 7000;
                        } else if (real_port_bandwidth == 106000) {
                            max_quad_core_bandwidth[i] += 6000;
                        } else if (real_port_bandwidth == 42000) {
                            max_quad_core_bandwidth[i] += 2000;
                        } else if (real_port_bandwidth == 21000) {
                            max_quad_core_bandwidth[i] += 1000;
                        } else if (real_port_bandwidth == 11000) {
                            max_quad_core_bandwidth[i] += 1000;
                        }
                    }

                    /* Check if any the lanes used by first port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[0];
                    if (port_bandwidth > 42000) {
                        if (blk != (pgw & 1)) {
                            continue;
                        }
                        lane_count = 12;
                    } else if ((port_bandwidth > 21000) ||
                                (SOC_IS_TITAN2PLUS(unit) &&
                                 ((port_bandwidth == 13000) ||
                                  (port_bandwidth == 16000)))) {
                        lane_count = 4;
                    } else if (port_bandwidth > 11000) {
                        lane_count = 2;
                    } else {
                        lane_count = 1;
                    }
                    for (index = 1; index < lane_count; index++) {
                        port = blk_port[index];
                        if (port == -1 ||
                            SOC_PBMP_MEMBER(si_m->disabled_bitmap, port)) {
                            continue;
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            "Port %d bandwidth %d Gb and "
                                            "port %d can not be both configured\n"),
                                 blk_port[0], port_bandwidth / 1000, port));
                        rv = SOC_E_FAIL;
                    }

                    /* Check if any the lanes used by third port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[2];
                    if (port_bandwidth > 11000) {
                        port = blk_port[3];
                        if (port != -1 &&
                            !SOC_PBMP_MEMBER(si_m->disabled_bitmap, port)) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Port %d bandwidth %d Gb and port %d "
                                                "can not be both configured\n"),
                                     blk_port[2], port_bandwidth / 1000,
                                     port));
                            rv = SOC_E_FAIL;
                        }
                        if (blk_port[0] == -1) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Physical port %d needs to be "
                                                "configured in order to work with "
                                                "port %d\n"),
                                     1 + pipe * _TD2_PORTS_PER_PIPE +
                                     pgw * _TD2_PORTS_PER_PGW +
                                     blk * _TD2_PORTS_PER_XLP,
                                     blk_port[2]));
                            rv = SOC_E_FAIL;
                        }
                    }

                    if (blk_inactive_map == blk_configured_map) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Flex port")));
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            if (blk_port[index] != -1) {
                                LOG_CLI((BSL_META_U(unit,
                                                    " %d"), blk_port[index]));
                            }
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            ": Can not be all inactive\n")));
                        rv = SOC_E_FAIL;
                        continue;
                    }

                    if (blk_oversub_map != 0 &&
                        blk_oversub_map != blk_configured_map) {
                        /*
                         * Check whether user mixed line-rate and
                         * oversubscription ports together within a TSC
                         */
                        LOG_CLI((BSL_META_U(unit,
                                            "%s"), 
                                 blk_inactive_map ? "Flex port" : "Port"));
                        for (index = 0; index < _TD2_PORTS_PER_XLP;
                             index++) {
                            if (blk_port[index] != -1) {
                                LOG_CLI((BSL_META_U(unit,
                                                    " %d"), blk_port[index]));
                            }
                        }
                        LOG_CLI((BSL_META_U(unit,
                                            ": Can not be configured to "
                                            "different oversubscription "
                                            "status\n")));
                        rv = SOC_E_FAIL;
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(
                        soc_trident2_port_inactive_port_check(unit,
                                blk_inactive_map, blk_port, blk_port_bandwidth));

                    pgw_linerate_bandwidth += blk_linerate_bandwidth;
                    pgw_oversub_bandwidth += blk_oversub_bandwidth;
                } /* for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) */
                quad_linerate_bandwidth += pgw_linerate_bandwidth;
                quad_oversub_bandwidth += pgw_oversub_bandwidth;
            } /* for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) */

            index = pipe * _TD2_QUADS_PER_PIPE + quad;
            if (quad_linerate_bandwidth > max_quad_core_bandwidth[index]) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total line rate bandwidth "
                                    "(%d Gb) exceeds %d Gb\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_linerate_bandwidth / 1000,
                         max_quad_core_bandwidth[index] / 1000));
                rv = SOC_E_FAIL;
            } else if (quad_linerate_bandwidth ==
                       max_quad_core_bandwidth[index] &&
                       quad_oversub_bandwidth != 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total line rate bandwidth "
                                    "(%d Gb) equals to max core bandwidth, no extra "
                                    "bandwidth for oversubscription ports\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_linerate_bandwidth / 1000));
                rv = SOC_E_FAIL;
            } else if (quad_oversub_bandwidth >
                       (max_quad_core_bandwidth[index] -
                        quad_linerate_bandwidth) * 2) {
                LOG_CLI((BSL_META_U(unit,
                                    "PGW_CL%d and PGW_CL%d total I/O "
                                    "oversubscription bandwidth (%d Gb) is more than "
                                    "2 times of core oversubscription bandwidth "
                                    "(2 * %d Gb)\n"),
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD,
                         pipe * _TD2_PGWS_PER_PIPE +
                         quad * _TD2_PGWS_PER_QUAD + 1,
                         quad_oversub_bandwidth / 1000,
                         (max_quad_core_bandwidth[index] -
                         quad_linerate_bandwidth) / 1000));
                rv = SOC_E_FAIL;
            }
        } /* for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) */
    } /* for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) */

    return rv;
}

#define SOC_TD2_NUM_LPORT       (106)
#define SOC_TD2_NUM_PHY_PORT    (130)
#define SOC_TD2_NUM_MMU_PORT    (117) /* mmu port 53 to 63 are not used */
/* cpu port is logical port 0, physical port 0, mmu port 0 */
#define SOC_TD2_CPU_LPORT       (0)
#define SOC_TD2_CPU_PHY_PORT    (0)
#define SOC_TD2_CPU_MMU_PORT    (52)
/* loopback port is logical port 105, physical port 129, mmu port 116 */
#define SOC_TD2_LB_LPORT        (105)
#define SOC_TD2_LB_PHY_PORT     (129)
#define SOC_TD2_LB_MMU_PORT     (116)

static int port_count[_TD2_PIPES_PER_DEV];
static uint32 tsc_map = 0;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
static uint32 clmac_tsc_map = 0;
soc_logical_to_ifp_port_mapping_t soc_td2p_log_to_ifp_port[SOC_MAX_NUM_DEVICES];
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

/*
 * Function:
 *      soc_trident2_port_portmap_parse
 * Description:
 *      Parse portmap soc property and fill out all output information
 *      to soc_pmap_info_t pmap
 * Parameters:
 *      unit          - Device number
 *      port          - Logical port number
 *      pmap          - soc_pmap_info_t
 */
int
soc_trident2_port_portmap_parse(int unit, soc_port_t port,
                                soc_pmap_info_t *pmap)
{
    soc_info_t *si = &SOC_INFO(unit);
    char *config_str, *sub_str, *sub_str_end;
    static const char str_2p5[] = "2.5";
    static const char str_osg[] = "OSG.";
    int osg_cnt, osg_str_cnt; /* Oversub Speed Group count and string count */
    char str_buf[8];
    int phy_port, port_bandwidth;
    soc_100g_lane_config_t lane_config;
    int fallback_lane = SOC_LANE_CONFIG_100G_DEFAULT;
    int pipe;
    int tsc_id;
    int num_lanes = -1;
    int rv, i, index;

    config_str = soc_property_port_get_str(unit, port, spn_PORTMAP);
    if (config_str == NULL) {
        return SOC_E_NOT_FOUND;
    }

    /*
     * portmap.<port>=<physical port number>:<bandwidth in Gb>:<OSG.0xf>:
     * <100G TSC lanes>:<100G Fallback XLMAC>:<i> | <m|l:lanes>
     *
     * If the port config ends with 'i', the port is not enabled, but can
     * be enabled later as a flexport.
     */
    sub_str = config_str;

    /* Parse physical port number */
    phy_port = sal_ctoi(sub_str, &sub_str_end);
    if (sub_str == sub_str_end) {
        LOG_CLI((BSL_META_U(unit,
                            "Port %d: Missing physical port information \"%s\"\n"),
                 port, config_str));
        return SOC_E_FAIL;
    }
    if (phy_port < 1 || phy_port > (SOC_TD2_NUM_PHY_PORT - 2)) {
        LOG_CLI((BSL_META_U(unit,
                            "Port %d: Invalid physical port number %d\n"),
                 port, phy_port));
        return SOC_E_FAIL;
    }
    tsc_id = (phy_port - 1) / 4;
    if (!(tsc_map & (1 << tsc_id))) {
        LOG_CLI((BSL_META_U(unit,
                            "Port %d: Physical port %d is in disabled TSC %d\n"),
                 port, phy_port, tsc_id));
        return SOC_E_FAIL;
    }
    pipe = phy_port < si->phy_port_base[1] ? 0 : 1;
    if (port_count[pipe] >= SOC_TD2_NUM_LPORT / 2 - 1) {
        LOG_CLI((BSL_META_U(unit,
                            "Can not configure more than %d port in "
                            "%c pipeline\n"), SOC_TD2_NUM_LPORT / 2 - 1,
                 pipe ? 'Y' : 'X'));
        return SOC_E_FAIL;
    }

    /* Skip ':' between physical port number and bandwidth */
    sub_str = sub_str_end;
    if (*sub_str != '\0') {
        if (*sub_str != ':') {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Bad config string \"%s\"\n"),
                     port, config_str));
            return SOC_E_FAIL;
        }
        sub_str++;
    }

    /* Parse bandwidth */
    for (index = 0; index < sizeof(str_2p5) - 1; index++) {
        if (sub_str[index] == '\0') {
            break;
        }
        str_buf[index] = sub_str[index];
    }
    str_buf[index] = '\0';
    if (!sal_strcmp(str_buf, str_2p5)) {
        port_bandwidth = 2500;
        sub_str_end = &sub_str[sizeof(str_2p5) - 1];
    } else {
        port_bandwidth = sal_ctoi(sub_str, &sub_str_end) * 1000;
        if (sub_str == sub_str_end) {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Missing bandwidth information \"%s\"\n"),
                     port, config_str));
            return SOC_E_FAIL;
        }

        rv = _soc_td2_port_speed_supported(unit, port, port_bandwidth);
        if (SOC_FAILURE(rv)) {
            return SOC_E_FAIL;
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            if (soc_feature(unit, soc_feature_clmac)
                && soc_feature(unit, soc_feature_clmac_partial_support)) {
                if (port_bandwidth >= 100000
                    && !(clmac_tsc_map & (1 << tsc_id))) {
                        LOG_CLI((BSL_META_U(unit,
                                "Port %d: TSC %d does not support CMAC("
                                "port speed >=100G) for the given SKU.\n"),
                                port, tsc_id));
                        return SOC_E_FAIL;
                }
            }
        }
#endif
    }
    /* Skip ':' between Bandwidth and OSG */
    sub_str = sub_str_end;
    if (*sub_str != '\0') {
        if (*sub_str != ':') {
            LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                      "Port %d: Bad config string \"%s\"\n"),
                      port, config_str));
            return SOC_E_FAIL;
        }
        sub_str_end++;
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        int oversub;
        if (SOC_FAILURE
            (soc_td2p_port_oversub_get(unit, phy_port, port,
                                       &oversub))) {
            LOG_ERROR(BSL_LS_SOC_PORT,
                      (BSL_META_U(unit,
                                  "Port %d: Cannot get oversub mode\n"),
                       port));
            return SOC_E_FAIL;
        }
        if (oversub) {
            SOC_PBMP_PORT_ADD(pmap->oversub_pbm, port);
        }
    }
#endif

    /* All OSGs are availiable by default */
    osg_cnt = GET_MMU_OVS_GCOUNT(unit);
    if (SOC_PBMP_MEMBER(pmap->oversub_pbm, port)) {
        si->port_osg_bitmap[phy_port] = (1 << osg_cnt) - 1;
    }

    /*Read OSG configuration.  skip if options are present*/
    sub_str = sub_str_end;
    if (*sub_str != '\0' && (*sub_str != 'm' &&
                             *sub_str != 'i' && *sub_str != 'l')) {
        /* OSG.0xf <=> OSG.  0x  f*/
        osg_str_cnt = sal_strlen(str_osg) + 2 + (osg_cnt + 3) / 4;
        for (index = 0; index < osg_str_cnt; index++) {
            if (sub_str[index] == '\0') {
                break;
            }
            str_buf[index] = sub_str[index];
        }
        str_buf[index] = '\0';
        if (!sal_strncmp(str_buf, str_osg, sal_strlen(str_osg))) {
            if (!SOC_PBMP_MEMBER(pmap->oversub_pbm, port)) {
                LOG_CLI((BSL_META_U(unit,
                         "Port %d: Bad config string \"%s\"\n"),
                         port, config_str));
                return SOC_E_FAIL;
            }
            sub_str += sal_strlen(str_osg);
            si->port_osg_bitmap[phy_port] =
                        sal_ctoi(sub_str, &sub_str_end);
            if (sub_str == sub_str_end) {
                LOG_CLI((BSL_META_U(unit,
                         "Port %d: Missing OSG bitmap information \"%s\"\n"),
                         port, config_str));
                return SOC_E_FAIL;
            }
            si->port_osg_bitmap[phy_port] &= (1 << osg_cnt) - 1;

            if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
                LOG_CLI((BSL_META_U(unit,
                         "Port %d OSG bitmap: 0x%x\n"),
                         port, si->port_osg_bitmap[phy_port]));
            }
            sub_str_end = &sub_str[osg_str_cnt - sal_strlen(str_osg)]; /*Advance */

            /* Skip ':' between OSG and 100G lane config */
            sub_str = sub_str_end;
            if (*sub_str != '\0') {
                if (*sub_str != ':') {
                    LOG_CLI((BSL_META_U(unit,
                                        "Port %d: Bad config string \"%s\"\n"),
                             port, config_str));
                    return SOC_E_FAIL;
                }
                sub_str_end++;
            }
        }
    }
    /*Read 100G lane configuration if present.  skip if options are present*/
    sub_str = sub_str_end;
    lane_config = SOC_LANE_CONFIG_100G_DEFAULT;
    if (*sub_str != '\0' && (*sub_str != 'm' &&
                             *sub_str != 'i' && *sub_str != 'l')) {
        for (index = 0; index < 3; index++) {
            if (sub_str[index] == '\0') {
                break;
            }
            str_buf[index] = sub_str[index];
        }
        str_buf[index] = '\0';
        if (!sal_strcmp(str_buf, "442")) {
            lane_config = SOC_LANE_CONFIG_100G_4_4_2;
        } else if (!sal_strcmp(str_buf, "244")) {
            lane_config = SOC_LANE_CONFIG_100G_2_4_4;
        } else if (!sal_strcmp(str_buf, "343")) {
            lane_config = SOC_LANE_CONFIG_100G_3_4_3;
        } else {
            LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                      "Port %d: Invalid lane configuration: %s\n"),
                      port, str_buf));
            return SOC_E_FAIL;
        }
        sub_str_end = &sub_str[3]; /*Advance */

        /* Skip ':' between 100G lane config and 100G fallback port*/
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                          "Port %d: Bad config string \"%s\"\n"),
                          port, config_str));
                return SOC_E_FAIL;
            }
            sub_str_end++;
        }
    }
    sub_str = sub_str_end;
    /*Gather the desired fallback TSC for 100G auto-negotiation*/
    fallback_lane = SOC_LANE_CONFIG_100G_AN_CORE_DEFAULT;
    if (*sub_str != '\0' && (*sub_str != 'm' &&
                             *sub_str != 'i' && *sub_str != 'l')) {
        fallback_lane = sal_ctoi(sub_str, &sub_str_end);
        if (fallback_lane > 2 || fallback_lane < 0) {
            LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                      "Port %d: invalid default lane \"%d\"\n"),
                      port, fallback_lane));
            return SOC_E_FAIL;
        } else {
            /*Validate that for a given lane configuration the selected
             * fallback lane is valid.*/
            for (i = 0; soc_td2_valid_lanes[i].lane_config !=
                 SOC_INVALID_LANE_CONFIG; i++) {
                if (soc_td2_valid_lanes[i].lane_config == lane_config) {
                    if (!soc_td2_valid_lanes[i].valid_lanes[fallback_lane]) {
                        fallback_lane = -1;
                        break;
                    }
                }
            }
        }
        if (fallback_lane < 0) {
            LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                      "Port %d: invalid default lane \"%d\"\n"),
                      port, fallback_lane));
        }

        /* Skip ':' between 100G fallback port and options */
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                LOG_ERROR(BSL_LS_SOC_PORT,(BSL_META_U(unit,
                          "Port %d: Bad config string \"%s\"\n"),
                          port, config_str));
                return SOC_E_FAIL;
            }
            sub_str_end++;
        }
    }

    /* Check if option presents */
    *pmap->option = 0;
    sub_str = sub_str_end;

    if (*sub_str != '\0') {
        if (*sub_str == 'm') {
            if (phy_port < 13 || phy_port > 16) {
                LOG_CLI((BSL_META_U(unit,
                                    "Port %d: Physical port %d can not be "
                                    "configured as management port\n"),
                         port, phy_port));
                return SOC_E_FAIL;
            }
        } else if (*sub_str != 'i' && *sub_str != 'l') {
            LOG_CLI((BSL_META_U(unit,
                                "Port %d: Bad config string \"%s\"\n"),
                                port, config_str));
            return SOC_E_FAIL;
        }
        *pmap->option = *sub_str;
        sub_str++;
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        /* User has specified number of lanes for the port config*/
        if (*pmap->option == 'l') {
            if ((*sub_str != '\0') && (*sub_str != ':')) {
                LOG_CLI((BSL_META_U(unit,
                                      "Port %d: Bad lanes config \"%s\"\n"),
                           port, config_str));
                return SOC_E_FAIL;
            } else if (*sub_str == '\0') {
                LOG_CLI((BSL_META_U(unit,
                             "Port %d: #of lanes not specified in=(%s)\n"),
                               port, config_str));
                return SOC_E_FAIL;
            }
            /* Skip ':' */
            sub_str++;

            for (index = 0; index < 2; index++) {
                if (sub_str[index] == '\0') {
                    break;
                }
                str_buf[index] = sub_str[index];
            }
            str_buf[index] = '\0';

            if (!sal_strcmp(str_buf, "12")) {
                num_lanes = 12;
            } else if (!sal_strcmp(str_buf, "10")) {
                num_lanes = 10;
            } else {
                num_lanes = sal_ctoi(sub_str, &sub_str_end);
            }

            /* Validate port lanes and allowed port speed */
            rv = _soc_td2p_lane_speed_valid_check(unit, num_lanes, port_bandwidth);
            if (SOC_FAILURE(rv)) {
                LOG_CLI((BSL_META_U(unit,
                      "Port %d: Lane config error ..\n"), port));
                return SOC_E_FAIL;
            }
            /* Assign lanes */
            si->port_num_lanes[port] =  num_lanes;

            /* Shift ahead 2 places */
            sub_str_end = &sub_str[2];
            sub_str = sub_str_end;
        }
    }
#endif

    if (soc_feature(unit, soc_feature_management_port_lanes) &&
        /* Check if number of lanes is specified for management port */
        *pmap->option == 'm' && *sub_str != '\0') {
        if (*sub_str != ':') {
            LOG_ERROR(BSL_LS_SOC_PORT,
                      (BSL_META_U(unit,
                                  "Port %d: Bad config string \"%s\"\n"),
                       port, config_str));
            return SOC_E_FAIL;
        }
        /* Skip ':' */
        sub_str++;
        num_lanes = sal_ctoi(sub_str, &sub_str_end);
        if (num_lanes != 1 && num_lanes != 2 && num_lanes != 4) {
            LOG_ERROR(BSL_LS_SOC_PORT,
                      (BSL_META_U(unit,
                                  "Port %d: Invalid number of "
                                  "management port lanes \"%d\"\n"),
                       port, num_lanes));
            return SOC_E_FAIL;
        }
        if (num_lanes != 1 && port_bandwidth != 10000) {
            LOG_ERROR(BSL_LS_SOC_PORT,
                      (BSL_META_U(unit,
                                  "Port %d: Invalid number of "
                                  "management port lanes \"%d\" "
                                  "for this speed \"%d\"\n"),
                       port, num_lanes, port_bandwidth));
            return SOC_E_FAIL;
        }
        si->port_num_lanes[port] =  num_lanes;
        sub_str = sub_str_end;
    }

    /* Check trailing string */
    if (*sub_str != '\0') {
        LOG_CLI((BSL_META_U(unit,
                            "Port %d: Bad config string \"%s\"\n"),
                 port, config_str));
        return SOC_E_FAIL;
    }

    pmap->port = port;
    pmap->phy_port = phy_port;
    pmap->port_bandwidth = port_bandwidth;
    pmap->lane_config = lane_config;
    pmap->fallback_lane = fallback_lane;
    pmap->pipe = pipe;

    return SOC_E_NONE;
}

/*
 * Trident2 port mapping
 *     130 physical ports: port 0-64 in X pipe, port 65-129 in Y pipe
 *     106 logical ports
 *     108 mmu ports: port 0-53 in X pipe, port 64-117 in Y pipe
 *     cpu port number is fixed: physical 0, logical 0, mmu 52
 *     loopback port number is fixed: physical 129, logical 105, mmu 116
 *     mmu port 53 and mmu port 117 are purge port
 *     mmu port can only map to physical port ID in the same pipe
 *     XLPORT3 (physical port 13-16) can be configured as management port(s)
 *     management port can be:
 *     - one 10G port
 *     - one to four ports with speed up to 2.5G each
 * Physical port number in eacc port group
 *     PGW_CL0: CPORT0   TSC 0-2   port 1
 *              XLPORT0  TSC 0     port 1-4
 *              XLPORT1  TSC 1     port 5-8
 *              XLPORT2  TSC 2     port 9-12
 *              XLPORT3  TSC 3     port 13-16
 *     PGW_CL1: CPORT1   TSC 5-7   port 21
 *              XLPORT7  TSC 4     port 17-20
 *              XLPORT6  TSC 5     port 21-24
 *              XLPORT5  TSC 6     port 25-28
 *              XLPORT4  TSC 7     port 29-32
 *     PGW_CL2: CPORT2   TSC 8-10  port 33
 *              XLPORT8  TSC 8     port 33-36
 *              XLPORT9  TSC 9     port 37-40
 *              XLPORT10 TSC 10    port 41-44
 *              XLPORT11 TSC 11    port 45-48
 *     PGW_CL3: CPORT3   TSC 13-15 port 53
 *              XLPORT15 TSC 12    port 49-52
 *              XLPORT14 TSC 13    port 53-56
 *              XLPORT13 TSC 14    port 57-60
 *              XLPORT12 TSC 15    port 61-64
 *     PGW_CL4: CPORT4   TSC 16-18 port 65
 *              XLPORT16 TSC 16    port 65-68
 *              XLPORT17 TSC 17    port 69-72
 *              XLPORT18 TSC 18    port 73-76
 *              XLPORT19 TSC 19    port 77-80
 *     PGW_CL5: CPORT5   TSC 21-23 port 85
 *              XLPORT23 TSC 20    port 81-84
 *              XLPORT22 TSC 21    port 85-88
 *              XLPORT21 TSC 22    port 89-92
 *              XLPORT20 TSC 23    port 93-96
 *     PGW_CL6: CPORT6   TSC 24-26 port 97
 *              XLPORT24 TSC 24    port 97-100
 *              XLPORT25 TSC 25    port 101-104
 *              XLPORT26 TSC 26    port 105-108
 *              XLPORT27 TSC 27    port 109-112
 *     PGW_CL7: CPORT7   TSC 29-31 port 117
 *              XLPORT31 TSC 28    port 113-116
 *              XLPORT30 TSC 29    port 117-120
 *              XLPORT29 TSC 30    port 121-124
 *              XLPORT28 TSC 31    port 125-128
 * This routine will setup:
 *     SOC_INFO(unit).port_p2l_mapping[]
 *     SOC_INFO(unit).port_l2p_mapping[]
 *     SOC_INFO(unit).port_p2m_mapping[]
 *     SOC_INFO(unit).port_m2p_mapping[]
 *     SOC_INFO(unit).port_speed_max[]
 *     SOC_INFO(unit).port_group[]
 *     SOC_INFO(unit).port_serdes[]
 *     SOC_INFO(unit).port_num_lanes[]
 *     SOC_INFO(unit).phy_port_base[]
 *     SOC_INFO(unit).mmu_port_base[]
 * 100+G port:
 *     - can only be @ 760MHz
 *     - needs to be HSP
 *     - cannot be in oversubscribe mode
 * 40/42G port:
 *     - needs to be HSP except @ 760MHz
 *     - oversubscribe mode can support both cut-through and store-and-forward
 * sub-40G port:
 *     - oversubscribe mode can only support store-and-forward
 */
int
soc_trident2_port_config_init(int unit, uint16 dev_id, uint8 rev_id)
{
#if defined(BCM_56850_A0) || defined(BCM_56860_A0)
    /*
     * Compiling this function will fail due to a p2l mapping overrun, if
     * a low port count device (like Apache) defines BCM_TRIDENT2_SUPPORT
     * and no true TD2 devices are part of the build.
     */
    soc_info_t *si;
    soc_info_misc_t *si_m;
    soc_pmap_info_t pmap;
    char option = '\0';
    int rv;
    int port, phy_port, mmu_port;
    int pipe;
    int frequency;
    int index;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int i;
#endif
    soc_pbmp_t pbmp, oversub_pbm, pbmp_mmu_reserved;
    int freq_list_len;
    int const *freq_list;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int flexport_reserve_HSP[_TD2_PIPES_PER_DEV];
    int flexport_reserve_T2OQ[_TD2_PIPES_PER_DEV];
    int flexport_max_speed = -1;
    int flexport_max_speed_pipe[_TD2_PIPES_PER_DEV];
    int num_hsp_to_reserve[_TD2_PIPES_PER_DEV]; /* index 0 is for X pipe, 
                                  index 1 is for Y pipe */
    pbmp_t phy_pbmp;

#ifdef BCM_WARM_BOOT_SUPPORT
    uint16 upgrade_from_nosupport = 0;
#endif /* BCM_WARM_BOOT_SUPPORT */

    flexport_reserve_HSP[0] = 0;
    flexport_reserve_HSP[1] = 0;
    flexport_reserve_T2OQ[0] = 0;
    flexport_reserve_T2OQ[1] = 0;
    flexport_max_speed_pipe[0] = -1;
    flexport_max_speed_pipe[1] = -1;
    num_hsp_to_reserve[0] = 0;
    num_hsp_to_reserve[1] = 0;
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    si = &SOC_INFO(unit);
    si->flex_eligible = FALSE;

    /* Can't read skew_id from TOP register at this point */
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_frequency_get(unit, dev_id, rev_id, -1, 
                                                    &si->frequency));
    if (SOC_IS_TRIDENT2(unit)) {
        frequency = rev_id == BCM56850_A0_REV_ID ? 415 : -1;
    } else {
        frequency = -1;
    }
    frequency = soc_property_get(unit, spn_CORE_CLOCK_FREQUENCY, frequency);

    if (frequency != -1 && frequency < si->frequency) {
        if (SOC_IS_TRIDENT2(unit)) {
            if (rev_id <= BCM56850_A1_REV_ID) {
                freq_list = a1_freq_list;
                freq_list_len = sizeof(a1_freq_list) / sizeof(int);
            } else {
                if (si->frequency == 793) {
                    freq_list = a2_793_freq_list;
                    freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
                } else {
                    freq_list = a2_635_freq_list;
                    freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
                }
            }
        } else {
            freq_list = a1_td2p_freq_list;
            freq_list_len = sizeof(a1_td2p_freq_list) / sizeof(int);
        }

        for (index = 1; index < freq_list_len; index++) { /* skip index 0 */
            if (freq_list[index] < si->frequency &&
                frequency == freq_list[index]) {
                break;
            }
        }

        if (index < freq_list_len) {
            si->frequency = frequency;
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "*** Input core clock frequency %dMHz is not "
                                "supported!\n"), frequency));
        }
    } else if (frequency > si->frequency) {
        LOG_CLI((BSL_META_U(unit,
                            "*** Input core clock frequency %dMHz is not supported!\n"),
                 frequency));
    }

    /* Setup max I/O bandwidth */
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_io_frequency_get(unit, dev_id, rev_id, -1, 
                                           &si->io_bandwidth));

    /* Setup max core bandwidth */
    if (si->frequency >= 760) {
        si->bandwidth = 960000;
    } else if (si->frequency >= 608) {
        si->bandwidth = 720000;
    } else if (si->frequency >= 518) {
        si->bandwidth = 640000;
    } else {
        if (SOC_IS_TRIDENT2(unit)) {
            si->bandwidth = 480000;
        } else {
            if (si->frequency >= 517) {
                si->bandwidth = 640000;
            } else {
                si->bandwidth = 480000;
            }
        }
    }

    SOC_PBMP_CLEAR(oversub_pbm);
    if (!SOC_IS_TD2P_TT2P(unit)) {
        if (si->io_bandwidth > si->bandwidth) {
            oversub_pbm =
                soc_property_get_pbmp(unit, spn_PBMP_OVERSUBSCRIBE, 0);
        }
    }

    pbmp_mmu_reserved = 
        soc_property_get_pbmp(unit, "pbmp_mmu_reserved", 0);

    SOC_IF_ERROR_RETURN
        (soc_trident2_tsc_map_get(unit, &tsc_map));

    for (phy_port = 0; phy_port < SOC_TD2_NUM_PHY_PORT; phy_port++) {
        si->port_p2l_mapping[phy_port] = -1;
        si->port_p2m_mapping[phy_port] = -1;
    }
    for (port = 0; port < SOC_TD2_NUM_LPORT; port++) {
        si->port_l2p_mapping[port] = -1;
        si->port_speed_max[port] = -1;
        si->port_group[port] = -1;
        si->port_serdes[port] = -1;
        si->port_num_lanes[port] = -1;
    }
    for (mmu_port = 0; mmu_port < SOC_TD2_NUM_MMU_PORT ; mmu_port++) {
        si->port_m2p_mapping[mmu_port] = -1;
    }

    si->port_p2l_mapping[SOC_TD2_CPU_PHY_PORT] = SOC_TD2_CPU_LPORT;
    si->port_p2m_mapping[SOC_TD2_CPU_PHY_PORT] = SOC_TD2_CPU_MMU_PORT;
    si->port_p2l_mapping[SOC_TD2_LB_PHY_PORT] = SOC_TD2_LB_LPORT;
    si->port_p2m_mapping[SOC_TD2_LB_PHY_PORT] = SOC_TD2_LB_MMU_PORT;
    si->port_pipe[SOC_TD2_CPU_LPORT] = 0;
    si->port_pipe[SOC_TD2_LB_LPORT]  = 1;
    SOC_PBMP_PORT_SET(si->xpipe_pbm, SOC_TD2_CPU_LPORT);
    SOC_PBMP_PORT_SET(si->ypipe_pbm, SOC_TD2_LB_LPORT);
    SOC_PBMP_CLEAR(si->oversub_pbm);
    SOC_PBMP_CLEAR(si->management_pbm);
    SOC_PBMP_CLEAR(si->all.disabled_bitmap);

    si->phy_port_base[0] = 0;               /* First physical port in X pipe */
    si->phy_port_base[1] = SOC_TD2_NUM_PHY_PORT / 2;/* First physical port in Y pipe */
    si->mmu_port_base[0] = 0;               /* First mmu port in X pipe */
    si->mmu_port_base[1] = 64;              /* First mmu port in Y pipe */

    port_count[0] = 0; /* X pipe */
    port_count[1] = 0; /* Y pipe */

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        if (soc_feature(unit, soc_feature_clmac)
            && soc_feature(unit, soc_feature_clmac_partial_support)) {
                /* TSCs {5,6,7}, {13,14,15}, {16,17,18}, {24,25,26}
                 * support CE port. All other TSCs, if enabled, support
                 * XL ports.
                 */
                clmac_tsc_map = tsc_map & 0x0707e0e0;
        }
    }
#endif

    rv = SOC_E_NONE;
    for (port = 0; port < SOC_TD2_NUM_LPORT; port++) {
        int rv_p = SOC_E_NONE;
        if (port == SOC_TD2_CPU_LPORT || port == SOC_TD2_LB_LPORT) {
            continue;
        }

        sal_memset(&pmap, 0x0, sizeof(soc_pmap_info_t));
        pmap.option = &option;
        sal_memcpy(&pmap.oversub_pbm, &oversub_pbm, sizeof(soc_pbmp_t));

        rv_p = soc_trident2_port_portmap_parse(unit, port, &pmap);
        if (SOC_FAILURE(rv_p)) {
            if (rv_p == SOC_E_FAIL) {
                rv = SOC_E_FAIL;
            }
            continue;
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        /*
         * Use new properties for 100GE mode lane and
         * fallback autoneg core if these are specified.
         */
        if (SOC_IS_TRIDENT2PLUS(unit)) {
            int mode_lane, an_core, found = FALSE;

            if (pmap.port_bandwidth >= 100000) {
                if (SOC_SUCCESS(soc_td2p_port_lane_config_get(unit,
                                    pmap.phy_port, &mode_lane, &found))) {
                    if (found) {
                        pmap.lane_config = mode_lane;
                    }
                }
                if (SOC_SUCCESS(soc_td2p_port_autoneg_core_get(unit,
                                    pmap.phy_port, &an_core, &found))) {
                    if (found) {
                        pmap.fallback_lane = an_core;
                    }
                }
            }
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */


        /* Update soc_info */
        si->port_p2l_mapping[pmap.phy_port]  = pmap.port;
        si->port_l2p_mapping[port]           = pmap.phy_port;
        si->port_speed_max[port]             = pmap.port_bandwidth;
        si->port_100g_lane_config[port]      = pmap.lane_config;
        si->port_fallback_lane[port]         = pmap.fallback_lane;
        si->port_pipe[port]                  = pmap.pipe;

        if (option == 'i') {
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, pmap.port);
        } else if (option == 'm') {
            SOC_PBMP_PORT_ADD(si->management_pbm, pmap.port);
        }

        if (SOC_PBMP_MEMBER(pmap.oversub_pbm, pmap.port)) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                if (pmap.port_bandwidth >= SPEED_100G) {
                    LOG_CLI((BSL_META_U(unit,
                             "Port %d: Physical port %d port speed %d "
                             "cannot be configured as oversubscription port,"
                             " When port speed is 100G or beyond\n"),
                             pmap.port, pmap.phy_port, pmap.port_bandwidth));
                    rv = SOC_E_FAIL;
                    continue;
                } else {
                    SOC_PBMP_PORT_ADD(si->oversub_pbm, pmap.port);
                }
            }
            else
#endif
            {
                SOC_PBMP_PORT_ADD(si->oversub_pbm, pmap.port);
            }
        }

        port_count[pmap.pipe]++;
    }

    /* Legacy Flex config ":i" case detected, disabled ports in config */
    if (SOC_PBMP_NOT_NULL(SOC_PORT_DISABLED_BITMAP(unit, all))) {
        si->flex_eligible = TRUE;
    }

 #if defined(BCM_WARM_BOOT_SUPPORT) && defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit)) {
        if (SOC_WARM_BOOT(unit)) {
            upgrade_from_nosupport = 0;
            rv = soc_td2p_flexport_scache_recovery(unit);
            if (SOC_FAILURE(rv)) {
                if (rv == SOC_E_NOT_FOUND) {
                    upgrade_from_nosupport = 1;
                    rv = SOC_E_NONE;
                } else {
                    return rv;
                }
            }
        } else {
            /* Cold boot create */
            SOC_IF_ERROR_RETURN(soc_td2p_flexport_scache_allocate(unit));
        }
    }
#endif /* BCM_WARM_BOOT_SUPPORT && BCM_TRIDENT2PLUS_SUPPORT */
   
    if (port_count[0] == 0 && port_count[1] == 0) {
#ifdef __KERNEL__
        /* config.bcm is not parsed yet at the time 1st call of soc_attach
           in Kernel mode SDK. Shouldn't return error code. */
        return SOC_E_NONE;
#else
        if (SOC_CONTROL(unit)->soc_flags & SOC_F_ATTACHED) { /* not for PCID */
            rv = SOC_E_FAIL;
        }
#endif
    }

    si_m = sal_alloc(sizeof(soc_info_misc_t), "soc_info_misc");
    if (NULL == si_m) {
        return rv;
    }

    soc_trident2_soc_info_misc_t_init(unit, si_m);

    if (SOC_FAILURE(soc_trident2_port_bandwidth_validate(unit, si_m))) {
        rv = SOC_E_FAIL;
    }
    sal_free(si_m);

    if (SOC_FAILURE(rv)) {
        for (phy_port = 1; phy_port < 129; phy_port++) {
            si->port_p2l_mapping[phy_port] = -1;
        }
        return rv;
    }

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        LOG_CLI((BSL_META_U(unit,
                            "physical to logical mapping:")));
        for (index = 0; index < SOC_TD2_NUM_PHY_PORT; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %3d"),
                     si->port_p2l_mapping[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
        LOG_CLI((BSL_META_U(unit,
                            "physical port bandwidth:")));
        for (index = 0; index < SOC_TD2_NUM_PHY_PORT; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            port = si->port_p2l_mapping[index];
            if (port == -1) {
                LOG_CLI((BSL_META_U(unit,
                                    "  -1")));
            } else if (si->port_speed_max[port] == 2500) {
                LOG_CLI((BSL_META_U(unit,
                                    " 2.5")));
            } else {
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         si->port_speed_max[port] / 1000));
            }
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    /* Setup port_group, num_lanes, xpipe_pbm and ypipe_pbm */
    for (port = 0; port < SOC_TD2_NUM_LPORT; port++) {
        phy_port = si->port_l2p_mapping[port];
        /* cpu, loopback, or unused port */
        if ((port == SOC_TD2_CPU_LPORT) || (port == SOC_TD2_LB_LPORT)
            || (phy_port == -1)) {
            continue;
        }
        /* 16 ports per PGW_CL */
        si->port_group[port] = (phy_port - 1) / _TD2_PORTS_PER_PGW;
        si->port_serdes[port] = (phy_port - 1) / _TD2_PORTS_PER_XLP;
        if (si->port_num_lanes[port] == -1) {
            if (si->port_speed_max[port] > 106000) {
                si->port_num_lanes[port] = 12;
            } else if (si->port_speed_max[port] > 42000) {
                si->port_num_lanes[port] =  10;
            } else if (si->port_speed_max[port] > 21000) {
                si->port_num_lanes[port] =  4;
            } else if (SOC_IS_TITAN2PLUS(unit) &&
                       ((si->port_speed_max[port] == 13000) ||
                        (si->port_speed_max[port] == 16000))){
                si->port_num_lanes[port] = 4;
            } else if (si->port_speed_max[port] > 11000) {
                si->port_num_lanes[port] =  2;
            } else {
                si->port_num_lanes[port] =  1;
            }
        }
        if (phy_port < si->phy_port_base[1]) { /* X-pipe */
            SOC_PBMP_PORT_ADD(si->xpipe_pbm, port);
        } else { /* Y-pipe */
            SOC_PBMP_PORT_ADD(si->ypipe_pbm, port);
        }
    }

    SOC_PBMP_ASSIGN(si->pipe_pbm[0], si->xpipe_pbm);
    SOC_PBMP_ASSIGN(si->pipe_pbm[1], si->ypipe_pbm);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    /* Initialize device physical port information */
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(soc_td2p_phy_info_init(unit));
        SOC_IF_ERROR_RETURN(soc_td2p_port_mixed_sister_speed_validate(unit));

        /* If legacy flex (:i inactive ports) is not present, check to see if new dynamic flexing is possible.
           If it is, we need to reserve the appropriate number of HSP and T2OQ ports. */
        if (FALSE == si->flex_eligible) {
            if (soc_td2p_is_any_port_flex_enable(unit)) {

                /* 
                 * This finds out if the device is booting with too many logical
                 * ports given our flex situation by calling ports_max_validate
                 * Determine bitmaps of used/mapped logical ports and
                 * physical ports.
                 *
                 * A bit set indicates port is mapped.
                 */
                SOC_PBMP_CLEAR(phy_pbmp);
                /* Get current port assignment */
                for (phy_port = 0; phy_port < SOC_MAX_NUM_PORTS; phy_port++) {
                    /* Skip not-addressable and invalid ports */
                    if (!TD2P_PHY_PORT_ADDRESSABLE(unit, phy_port) ||
                        (si->port_p2l_mapping[phy_port] == -1)) {
                        continue;
                    }

                    SOC_PBMP_PORT_ADD(phy_pbmp, phy_port);
                }

                SOC_IF_ERROR_RETURN(soc_td2p_logic_ports_max_validate(unit, phy_pbmp));

                /* See whether we need to reserve HSP and T2OQ ports for flexport if we're
                   flexing any port.  Actual reservation will come AFTER HSP/T2OQ ports have
                   been assigned below. */
                SOC_IF_ERROR_RETURN(soc_td2p_port_resource_speed_max_get(unit, &flexport_max_speed));
                SOC_IF_ERROR_RETURN(soc_td2p_port_resource_speed_max_x_get(unit, &flexport_max_speed_pipe[0]));
                SOC_IF_ERROR_RETURN(soc_td2p_port_resource_speed_max_y_get(unit, &flexport_max_speed_pipe[1]));

                /* Error check to make sure that if one pipe's max flex speed is set, the other is as well */
                if ((flexport_max_speed_pipe[0] > 0 && flexport_max_speed_pipe[1] < 0) || 
                    (flexport_max_speed_pipe[0] < 0 && flexport_max_speed_pipe[1] > 0)) {

                    LOG_VERBOSE(BSL_LS_SOC_MMU,
                        (BSL_META_U(unit,
                         "Both port_flex_speed_max_x and port_flex_speed_max_y must be set!\n")
                          ));
                    return SOC_E_CONFIG;
                }

                /* Find out how many port macros are capable of flexing per pipe */
                SOC_IF_ERROR_RETURN(
                   soc_td2p_num_hsp_reserved_per_pipe(unit, 0, &num_hsp_to_reserve[0]));
                SOC_IF_ERROR_RETURN(
                   soc_td2p_num_hsp_reserved_per_pipe(unit, 1, &num_hsp_to_reserve[1]));
                /* If flexing any port to 100 gig is possible, we need to preallocate
                   a HSP port and T2OQ per port macro */

                for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {

                    /* If flexport_max_speed_pipe has been set for both pipes
                       (check is above), use them instead of the device
                       global flexport_max_speed, otherwise just use
                       the global */
                    if (flexport_max_speed_pipe[pipe] > 0 ) {
                        flexport_max_speed = flexport_max_speed_pipe[pipe];
                    }

                    if(flexport_max_speed > 42000) {
                        flexport_reserve_HSP[pipe] = 1;
                        flexport_reserve_T2OQ[pipe] = 1;
                    }
                    /* otherwise flexing only goes up to 40 gig */
                    else {
                        /* Table 6-16 of TD2+ FlexPort uArch Spec */
                        /* don't need to preallocate for frequencies at and above 960000 */
                        if(si->bandwidth >= 960000) {
                        }
                        /* Need to preallocate 1 HSP port per port macro
                           for above this freq */
                        else if(si->bandwidth >= 720000) {
                            flexport_reserve_HSP[pipe] = 1;
                            flexport_reserve_T2OQ[pipe] = 0;
                        }
                        /* Otherwise, for freq 480000 and below need to
                           preallocate 1 HSP and 1 T2OQ
                           per port macro */
                        else {
                            flexport_reserve_HSP[pipe] = 1;
                            flexport_reserve_T2OQ[pipe] = 1;
                        }
                    }
                }
            }
        }
    }
#endif

    /* Setup vector-based scheduler (VBS)
     * a.k.a high speed port scheduler (HSP) pbm */
    for (port = 0; port < SOC_TD2_NUM_LPORT; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) { /* cpu, loopback, or unused port */
            continue;
        }
        if (si->port_speed_max[port] >= 100000 ||
            (si->port_speed_max[port] >= 40000 && si->frequency < 760) ||
            soc_property_port_get(unit, port, spn_PORT_SCHED_HSP, 0)) {
            SOC_PBMP_PORT_ADD(si->eq_pbm, port);
        }
    }

#if defined(BCM_WARM_BOOT_SUPPORT) && defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit) && SOC_WARM_BOOT(unit) &&
        (!upgrade_from_nosupport)) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
               "\nwarmboot - Function %s Line %d"),
               __FUNCTION__,__LINE__));

    } else
#endif /* BCM_WARM_BOOT_SUPPORT && BCM_TRIDENT2PLUS_SUPPORT */
    {
        /* Assign MMU port */
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            mmu_port = pipe * _TD2_PORTS_PER_PIPE;
            /* First assign the lowest MMU port number for VBS (HSP) ports */
            pbmp = pipe ? si->ypipe_pbm : si->xpipe_pbm;
            SOC_PBMP_AND(pbmp, si->eq_pbm);
            SOC_PBMP_ITER(pbmp, port) {
                phy_port = si->port_l2p_mapping[port];
                while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                    mmu_port++;
                }
                si->port_p2m_mapping[phy_port] = mmu_port;
                /* for HSP PBM, In TD2+/TD2, mmu_port + 36 is reserved */
                SOC_PBMP_PORT_ADD(pbmp_mmu_reserved, mmu_port+36);
                mmu_port++;
            }

    #ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                /* Reserve HSP and T2OQ ports if we need to. This means that
               the "for" loops below will not allocate ports we put into
               this reservation bitmap.  According to TD2+
               FlexPort uArch, each pipe's ports 0-15 are HSP and HSP + 36 is T2OQ */
            if (flexport_reserve_HSP[pipe]) {


                /* Do not include HSP MMU ports that have already been allocated
                  that are flex capable. */
                for (i = 0; i < mmu_port; i++) {
                    if (soc_td2p_is_port_flex_enable(unit, 
                                      si->port_m2p_mapping[i]) == 1) {
                     num_hsp_to_reserve[pipe] -= 1;
                    }
                }

                for (i = mmu_port%_TD2_PORTS_PER_PIPE; i < num_hsp_to_reserve[pipe]; i++) {

                    /* mmu port 0-15 on each pipe; 0-15 on X Pipe, 64-79 on Y Pipe */
                    SOC_PBMP_PORT_ADD(pbmp_mmu_reserved,
                                   i + (pipe * _TD2_PORTS_PER_PIPE));
                        if(flexport_reserve_T2OQ[pipe] == 1) {
                        /* mmu port 36-51 on each pipe; 36-51 on X Pipe, 100-115 on Y Pipe */
                        SOC_PBMP_PORT_ADD(pbmp_mmu_reserved,
                                    i + (pipe * _TD2_PORTS_PER_PIPE)+36);
                        }
                    }
                }
            }
    #endif

              /* Then assign the next lowest MMU port number for 40+G ports */
            for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 4) {
                phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
                port = si->port_p2l_mapping[phy_port];
                if (port == -1) {
                    continue;
                }

                if (si->port_p2m_mapping[phy_port] == -1 &&
                    si->port_speed_max[port] > 21000) {
                    while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                        mmu_port++;
                    }
                    si->port_p2m_mapping[phy_port] = mmu_port;
                    mmu_port++;
                }
            }
            /* Then assign the next lowest MMU port number for 20+G ports */
            for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 2) {
                phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
                port = si->port_p2l_mapping[phy_port];
                if (port == -1) {
                    continue;
                }

                if (si->port_p2m_mapping[phy_port] == -1 &&
                    si->port_speed_max[port] > 11000) {
                    while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                        mmu_port++;
                    }
                    si->port_p2m_mapping[phy_port] = mmu_port;
                    mmu_port++;
                }
            }
            /* Finally assign MMU port number for all other ports */
            for (index = 0; index < _TD2_PORTS_PER_PIPE; index++) {
                phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
                port = si->port_p2l_mapping[phy_port];
                if (port == -1) {
                    continue;
                }

                if (si->port_p2m_mapping[phy_port] == -1 &&
                    si->port_speed_max[port] > 0) {
                    while (SOC_PBMP_MEMBER(pbmp_mmu_reserved, mmu_port)) {
                        mmu_port++;
                    }
                    si->port_p2m_mapping[phy_port] = mmu_port;
                    mmu_port++;
                }
            }
            /* if we've gone out of range of the MMU ports per
               pipe (0-52 in X pipe, 64-116 in Y Pipe) */
            if ((mmu_port < 0) ||
                (mmu_port > 52 && mmu_port < 64) ||
                (mmu_port > 116)) {
                 LOG_VERBOSE(BSL_LS_SOC_MMU,
                     (BSL_META_U(unit,
                      "MMU port resource allocation failure mmu_port %d\n"),
                       mmu_port));
                return SOC_E_RESOURCE;
            }
        }
    } /*  Not a TD2 &&Warmboot */

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        LOG_CLI((BSL_META_U(unit,
                            "physical to mmu mapping:")));
        for (index = 0; index < SOC_TD2_NUM_PHY_PORT; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %3d"),
                     si->port_p2m_mapping[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    return SOC_E_NONE;
#else
    LOG_ERROR(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
              "Internal TD2 configuration error")));
    return SOC_E_UNAVAIL;
#endif
}

int
soc_trident2_lls_bmap_alloc(int unit)
{
    soc_control_t *soc;
    soc_info_t *si;
    int port, phy_port, mmu_port, index;
    int alloc_size_l0, alloc_size_l1, alloc_size_l2;

    soc = SOC_CONTROL(unit);
    si = &SOC_INFO(unit);

    alloc_size_l0 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L0_PARENTm));
    alloc_size_l1 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L1_PARENTm));
    alloc_size_l2 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L2_PARENTm));

    PBMP_ALL_ITER(unit, port) {
        soc->port_lls_l0_bmap[port] = sal_alloc(alloc_size_l0, "LLS_L0_BMAP");
        soc->port_lls_l1_bmap[port] = sal_alloc(alloc_size_l1, "LLS_L1_BMAP");
        soc->port_lls_l2_bmap[port] = sal_alloc(alloc_size_l2, "LLS_L2_BMAP");
        sal_memset(soc->port_lls_l0_bmap[port], 0, alloc_size_l0);
        sal_memset(soc->port_lls_l1_bmap[port], 0, alloc_size_l1);
        sal_memset(soc->port_lls_l2_bmap[port], 0, alloc_size_l2);
        if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];
            for (index = 0; index < 5; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l0_bmap[port],
                           (mmu_port & 0x3f) * 5 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l1_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l2_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
        }
    }

    return SOC_E_NONE;
}

int
soc_trident2_lls_bmap_alloc_port(int unit, int port, int ets_mode)
{
    soc_control_t *soc;
    soc_info_t *si;
    int phy_port, mmu_port, index;
    int alloc_size_l0, alloc_size_l1, alloc_size_l2;

    soc = SOC_CONTROL(unit);
    si = &SOC_INFO(unit);

    alloc_size_l0 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L0_PARENTm));
    alloc_size_l1 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L1_PARENTm));
    alloc_size_l2 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, ES_PIPE0_LLS_L2_PARENTm));

    if(soc->port_lls_l0_bmap[port] == NULL) {
        soc->port_lls_l0_bmap[port] = sal_alloc(alloc_size_l0, "LLS_L0_BMAP");
    }
    if(soc->port_lls_l1_bmap[port] == NULL) {
        soc->port_lls_l1_bmap[port] = sal_alloc(alloc_size_l1, "LLS_L1_BMAP");
    }
    if(soc->port_lls_l2_bmap[port] == NULL) {
        soc->port_lls_l2_bmap[port] = sal_alloc(alloc_size_l2, "LLS_L2_BMAP");
    }
    sal_memset(soc->port_lls_l0_bmap[port], 0, alloc_size_l0);
    sal_memset(soc->port_lls_l1_bmap[port], 0, alloc_size_l1);
    sal_memset(soc->port_lls_l2_bmap[port], 0, alloc_size_l2);

    /* Dont' set any bits in the bitmap if ets_mode == 1.  Allow the user
       to set a custom hierarchy; user is responsible for setting these
       bits. */
    if (ets_mode == 0) {
        if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];
            for (index = 0; index < 5; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l0_bmap[port],
                           (mmu_port & 0x3f) * 5 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l1_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
            for (index = 0; index < 10; index++) {
                SHR_BITSET(SOC_CONTROL(unit)->port_lls_l2_bmap[port],
                           (mmu_port & 0x3f) * 10 + index);
            }
        }
    }

    return SOC_E_NONE;
}

int
soc_trident2_chip_reset(int unit)
{
    soc_info_t *si;
    uint16 dev_id;
    uint8 rev_id;
    int skew_id;
    int max_frequency;
    uint32 rval, to_usec;
    soc_reg_t reg;
    int index;
    int num_ecmp_rh_flowset_entries;
    int rh_table_config_encoding;
    soc_field_t fields[4];
    uint32 values[4];
    int freq_list_len, sel;
    int const *freq_list;
#if defined(BCM_RIOT_SUPPORT) || defined(BCM_MULTI_LEVEL_ECMP_SUPPORT)
    int num_overlay_ecmp_rh_flowset_entries;
    int rh_bank_sel = 0x0;
    int ecmp_levels = 1;
#endif
    static const soc_reg_t lcpll_ctrl1_reg[] = {
        TOP_XG_PLL0_CTRL_1r, TOP_XG_PLL1_CTRL_1r,
        TOP_XG_PLL2_CTRL_1r, TOP_XG_PLL3_CTRL_1r
    };
    static const soc_reg_t lcpll_ctrl2_reg[] = {
        TOP_XG_PLL0_CTRL_2r, TOP_XG_PLL1_CTRL_2r,
        TOP_XG_PLL2_CTRL_2r, TOP_XG_PLL3_CTRL_2r
    };
    static const soc_reg_t lcpll_ctrl3_reg[] = {
        TOP_XG_PLL0_CTRL_3r, TOP_XG_PLL1_CTRL_3r,
        TOP_XG_PLL2_CTRL_3r, TOP_XG_PLL3_CTRL_3r
    };
    static const soc_reg_t lcpll_ctrl4_reg[] = {
        TOP_XG_PLL0_CTRL_4r, TOP_XG_PLL1_CTRL_4r,
        TOP_XG_PLL2_CTRL_4r, TOP_XG_PLL3_CTRL_4r
    };
    static const soc_reg_t lcpll_status_reg[] = {
        TOP_XG_PLL0_STATUSr, TOP_XG_PLL1_STATUSr,
        TOP_XG_PLL2_STATUSr, TOP_XG_PLL3_STATUSr
    };
    soc_field_t top_soft_rst_field = TOP_TEMP_MON_PEAK_RST_Lf;


    si = &SOC_INFO(unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        top_soft_rst_field = TOP_PVT_MON_MIN_RST_Lf;
    }
#endif

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
                                   (10 * MILLISECOND_USEC);

    /*             Trident 2
     * SBUS ring and block number:
     * ring 0: IP(1)
     * ring 1: EP(2)
     * ring 2: MMU(3)
     * ring 3: PGW_CL0(6), CPORT0(14), XLPORT0(15)-XLPORT3(18)
     *         PGW_CL1(7), CPORT1(19), XLPORT4(20)-XLPORT7(23)
     * ring 4: PGW_CL2(8), CPORT2(24), XLPORT8(25)-XLPORT11(28)
     *         PGW_CL3(9), CPORT3(29), XLPORT12(30)-XLPORT15(33)
     * ring 5: OTPC(5), TOP(57), SER(58)
     * ring 6: PGW_CL4(10), CPORT4(34), XLPORT16(35)-XLPORT19(38)
     *         PGW_CL5(11), CPORT5(39), XLPORT20(40)-XLPORT23(43)
     * ring 7: PGW_CL6(12), CPORT6(44), XLPORT24(45)-XLPORT27(48)
     *         PGW_CL7(13), CPORT7(49), XLPORT28(50)-XLPORT31(53)
     */

    /*             Trident 2+
     * SBUS ring and block number:
     * ring 0: IP(1)
     * ring 1: EP(2)
     * ring 2: MMU(3)
     * ring 3: PGW_CL0(6), CPORT0(14), XLPORT0(15)-XLPORT3(18)
     *         PGW_CL1(7), CPORT1(19), XLPORT4(20)-XLPORT7(23)
     * ring 4: PGW_CL2(8), CPORT2(24), XLPORT8(25)-XLPORT11(28)
     *         PGW_CL3(9), CPORT3(29), XLPORT12(30)-XLPORT15(33)
     * ring 5: OTPC(4), TOP(57), SER(58), AVS(59)
     * ring 6: PGW_CL4(10), CPORT4(34), XLPORT16(35)-XLPORT19(38)
     *         PGW_CL5(11), CPORT5(39), XLPORT20(40)-XLPORT23(43)
     * ring 7: PGW_CL6(12), CPORT6(44), XLPORT24(45)-XLPORT27(48)
     *         PGW_CL7(13), CPORT7(49), XLPORT28(50)-XLPORT31(53)
     *
     *      OTPC  => {
     *          REGBASE    => 0,
     *          MEMBASE    => 0,
     *          DESC       => 'OTP',
     *          BLKTYPE    => OTPC,
     *          SCHANNUM   => 4,
     *          BLOCKNUM   => 4, <---- 
     *          VENDOR     => 'BROADCOM',
     *      },
     *
     */

    WRITE_CMIC_SBUS_RING_MAP_0_7r(unit, 0x33052100);
    WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x33776644);
    WRITE_CMIC_SBUS_RING_MAP_16_23r(unit, 0x33333333);
    WRITE_CMIC_SBUS_RING_MAP_24_31r(unit, 0x44444444);
    WRITE_CMIC_SBUS_RING_MAP_32_39r(unit, 0x66666644);
    WRITE_CMIC_SBUS_RING_MAP_40_47r(unit, 0x77776666);
    WRITE_CMIC_SBUS_RING_MAP_48_55r(unit, 0x00777777);
    if (!SOC_IS_TD2P_TT2P(unit)) {
        WRITE_CMIC_SBUS_RING_MAP_56_63r(unit, 0x00000550);
    } else {
        /*Adding AVS to ring 5*/
        WRITE_CMIC_SBUS_RING_MAP_56_63r(unit, 0x00005550);
    }

    WRITE_CMIC_SBUS_TIMEOUTr(unit, 0x7d0);

    sal_usleep(to_usec);


    SOC_IF_ERROR_RETURN(READ_TOP_DEV_REV_IDr(unit, &rval));
    skew_id = soc_reg_field_get(unit, TOP_DEV_REV_IDr, rval, DEVICE_SKEWf);
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_frequency_get(unit, dev_id, rev_id, skew_id,
                                        &max_frequency));

    if (SOC_IS_TRIDENT2(unit)) {
        if (rev_id <= BCM56850_A1_REV_ID) {
            freq_list = a1_freq_list;
            freq_list_len = sizeof(a1_freq_list) / sizeof(int);
        } else {
            if (max_frequency == 793) {
                freq_list = a2_793_freq_list;
                freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
            } else {
                freq_list = a2_635_freq_list;
                freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
            }
        }
    } else {
        freq_list = a1_td2p_freq_list;
        freq_list_len = sizeof(a1_td2p_freq_list) / sizeof(int);
    }
        
    if ((si->frequency != max_frequency) 
        || (si->frequency != freq_list[0])) {
        if (si->frequency > max_frequency) {
            si->frequency = max_frequency;
        }
        for (sel = 1; sel < freq_list_len; sel++) { /* skip index 0 */
            if (si->frequency == freq_list[sel]) {
                break;
            }
        }
        if (sel < freq_list_len) {
            LOG_CLI((BSL_META_U(unit,
                                "*** change CORE_CLK_FREQ_SEL to %d\n"), sel));
            LOG_CLI((BSL_META_U(unit,
                                "*** change core clock frequency to %dMHz\n"),
                     si->frequency));

            SOC_IF_ERROR_RETURN(READ_TOP_CORE_CLK_FREQ_SELr(unit, &rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              SW_CORE_CLK_SEL_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              CORE_CLK_FREQ_SELf, sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));

            if (SOC_IS_TRIDENT2(unit)) {
                soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                                  1);
                SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
                soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                                  0);
                SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            }

            sal_usleep(to_usec);
        }
    }

    /* Program LCPLL frequency */
    for (index = 0; index < 4; index++) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, lcpll_ctrl1_reg[index],
                                    REG_PORT_ANY, PDIVf, 7));
        if (SOC_IS_TD2P_TT2P(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl2_reg[index],
                                    REG_PORT_ANY, NDIV_INTf, 140));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl3_reg[index],
                                    REG_PORT_ANY, CML_BYP_ENf, 1));
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, lcpll_ctrl4_reg[index],
                                    REG_PORT_ANY, NDIV_INTf, 140));
        }
    }
    fields[0] = CMIC_TO_XG_PLL0_SW_OVWRf;
    values[0] = 1;
    fields[1] = CMIC_TO_XG_PLL1_SW_OVWRf;
    values[1] = 1;
    fields[2] = CMIC_TO_XG_PLL2_SW_OVWRf;
    values[2] = 1;
    fields[3] = CMIC_TO_XG_PLL3_SW_OVWRf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, TOP_MISC_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    rval = 0;

    /* Configure TS PLL */ 
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_PDIV, 1));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, 14));
        WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_PDIV, 1));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, 14));
        WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));    
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, NDIV_INTf,
                      soc_property_get(unit, spn_PTP_TS_PLL_N, 140));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));    
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf,
                      soc_property_get(unit, spn_PTP_TS_PLL_N, 140));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_5r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_TS_KA, 0));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_TS_KI, 2));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_5r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_TS_KP, 3));
        WRITE_TOP_TS_PLL_CTRL_5r(unit, rval);

        if (soc_property_get(unit, spn_PTP_TS_PLL_FREF, 0) == 0) {
            SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_1r, &rval, FREF_SELf, 0);
            WRITE_TOP_TS_PLL_CTRL_1r(unit, rval);
        } else {
            SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_1r, &rval, FREF_SELf, 1);
            WRITE_TOP_TS_PLL_CTRL_1r(unit, rval);
        }
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_TS_KA, 2));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_TS_KI, 4));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_TS_KP, 9));
        if (soc_property_get(unit, spn_PTP_TS_PLL_FREF, 0) == 0) {
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf, 0);
        }
        else {
            soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
        }
        WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);
    }
    
    /* Set 250Mhz (implies 4ns resolution) default timesync clock to 
       calculate assymentric delays */
    SOC_TIMESYNC_PLL_CLOCK_NS(unit) = (1/250 * 1000); /* clock period in nanoseconds */
     
    /* Configure BS PLL */
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_0r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_0r, &rval, VCO_FB_DIV2f,
                      1);  /* soc_property_get(unit, spn_BROAD_SYNC_VCO_DIV2, 1)); */
        WRITE_TOP_BS_PLL_CTRL_0r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_0r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_0r, &rval, VCO_DIV2f,
                      1);  /* soc_property_get(unit, spn_BROAD_SYNC_VCO_DIV2, 1)); */
        WRITE_TOP_BS_PLL_CTRL_0r(unit, rval);
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_BS_PDIV, 1));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_BS_MNDIV, 175));
        WRITE_TOP_BS_PLL_CTRL_3r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_BS_PDIV, 1));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_BS_MNDIV, 175));
        WRITE_TOP_BS_PLL_CTRL_2r(unit, rval);
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, NDIV_INTf, 140);
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_BS_PLL_CTRL_4r(unit, rval);
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_INTf, 140);
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
        WRITE_TOP_BS_PLL_CTRL_3r(unit, rval);
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_5r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_BS_KA, 0));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_BS_KI, 2));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_5r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_BS_KP, 3));
        WRITE_TOP_BS_PLL_CTRL_5r(unit, rval);

        if (soc_property_get(unit, spn_PTP_BS_FREF, 0) == 0) {
            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_1r, &rval, FREF_SELf, 0);
            WRITE_TOP_BS_PLL_CTRL_1r(unit, rval);
        } else {
            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_1r, &rval, FREF_SELf, 1);
            WRITE_TOP_BS_PLL_CTRL_1r(unit, rval);
        }
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_BS_KA, 2));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_BS_KI, 4));
        soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_BS_KP, 9));
        if (soc_property_get(unit, spn_PTP_BS_FREF, 0) == 0) {
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, REFCLK_SELf, 0);
        }
        else {
            soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
        }
        WRITE_TOP_BS_PLL_CTRL_4r(unit, rval);
    }

    /* Bring LCPLL, time sync PLL, BroadSync PLL out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit,&rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL0_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL1_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL2_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL3_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL_RST_Lf,
                      1);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_ARS_PMB_CLK_ENf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_AVS_PMB_RST_Lf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_ARS_RST_Lf,
                      1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_AVS_PVTMON_RST_Lf,
                      1);
    }
#endif

    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    if (!SAL_BOOT_SIMULATION) {
        /* Check LCPLL lock status */
        for (index = 0; index < 4; index++) {
            reg = lcpll_status_reg[index];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, TOP_XGPLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "LCPLL %d not locked on unit %d "
                                      "status = 0x%08x\n"), index, unit, rval));
            }
        }
        /* Check time sync lock status */
        reg = TOP_TS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "TS_PLL %d not locked on unit %d "
                                  "status = 0x%08x\n"), index, unit, rval));
        }
        /* Check BroadSync lock status */
        reg = TOP_BS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "BS_PLL %d not locked on unit %d "
                                  "status = 0x%08x\n"), index, unit, rval));
        }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            /* Check Core PLL lock status */
            reg = TOP_CORE_PLL_STATUSr;
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "CORE_PLL %d not locked on unit %d "
                                    "status = 0x%08x\n"), index, unit, rval));
            }
            /* Check Mcs PLL lock status */
            reg = TOP_MCS_PLL_STATUSr;
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "MCS_PLL %d not locked on unit %d "
                                    "status = 0x%08x\n"), index, unit, rval));
            }
        }
#endif
    }

    /* De-assert LCPLL's post reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL0_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL1_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL2_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL3_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_BS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    /* Bring port blocks out of reset */
    rval = 0;
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP2_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP3_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP4_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP5_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP6_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP7_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_TS_RST_Lf, 1);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

    sal_usleep(to_usec);

    /* Bring IP, EP, and MMU blocks out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_IP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_EP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));

    sal_usleep(to_usec);

    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            rh_table_config_encoding = 2;
            break;
        case 32768:
            rh_table_config_encoding = 0;
            break;
        case 65536:
            rh_table_config_encoding = 1;
            break;
        default:
            return SOC_E_CONFIG;
    }
#if defined(BCM_RIOT_SUPPORT) || defined(BCM_MULTI_LEVEL_ECMP_SUPPORT)
    ecmp_levels = soc_property_get(unit, spn_L3_ECMP_LEVELS, 1);
    if ((soc_feature(unit, soc_feature_riot) ||
         soc_feature(unit, soc_feature_multi_level_ecmp)) &&
        ecmp_levels > 1) {

        num_overlay_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_RIOT_OVERLAY_ECMP_RESILIENT_HASH_SIZE, 0);

        if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 0, 16384)) {  

            num_overlay_ecmp_rh_flowset_entries = 16384;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 16384, 32768)) {  

            num_overlay_ecmp_rh_flowset_entries = 32768;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 32768, 49152)) {  

            num_overlay_ecmp_rh_flowset_entries = 49152;
        } else if (SOC_FIELD_RANGE_CHECK(
            num_overlay_ecmp_rh_flowset_entries, 49152, 65536)) {  

            num_overlay_ecmp_rh_flowset_entries = 65536;
        }

        switch (num_overlay_ecmp_rh_flowset_entries) {
        case 0:
            rh_bank_sel = 0x0;
            break;
        case 16384:
            if (num_ecmp_rh_flowset_entries >= 16384) {
                rh_bank_sel = 0x1;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 32768:
            if (num_ecmp_rh_flowset_entries >= 32768) {
                rh_bank_sel = 0x3;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 49152:
            if (num_ecmp_rh_flowset_entries >= 49152) {
                rh_bank_sel = 0x7;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        case 65536:
            if (num_ecmp_rh_flowset_entries >= 65536) {
                rh_bank_sel = 0xf;
            } else {
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s:Total ECMP entries %d are less than RH entries :%d \n"), 
                    FUNCTION_NAME(),  num_ecmp_rh_flowset_entries, 
                    num_overlay_ecmp_rh_flowset_entries));
                return SOC_E_CONFIG;
            }
            break;
        default:
                LOG_ERROR(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                    "%s: Value for overlay RH entries is not correct : %d \n"), 
                    FUNCTION_NAME(),  num_overlay_ecmp_rh_flowset_entries)); 
            return SOC_E_CONFIG;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, RH_ECMP_FLOWSET_BANK_SELr,
                REG_PORT_ANY, BANK_SELf,
                rh_bank_sel));
  }
#endif

    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, ENHANCED_HASHING_CONTROLr,
                REG_PORT_ANY, RH_FLOWSET_TABLE_CONFIG_ENCODINGf,
                rh_table_config_encoding));

    if (SOC_IS_TD2P_TT2P(unit)) {
        READ_TOP_PVTMON_CTRL_1r(unit, &rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 0);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_ADC_RESETBf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    } else {
        READ_TOP_PVTMON_CTRL_1r(unit, &rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
        soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
        WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    }

    sal_usleep(1000);

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    /* Do not use SBUS MDIO by default */
    SOC_FUNCTIONS(unit)->soc_sbus_mdio_read = NULL;
    SOC_FUNCTIONS(unit)->soc_sbus_mdio_write = NULL;

    /* Optionally allow SBUS MDIO for debug */
    if (soc_property_get(unit, "td2_sbus_mdio", SOC_IS_TD2P_TT2P(unit))) {
        SOC_FUNCTIONS(unit)->soc_sbus_mdio_read = _soc_trident2_mdio_reg_read;
        SOC_FUNCTIONS(unit)->soc_sbus_mdio_write = _soc_trident2_mdio_reg_write;
    }

    if (!(SOC_CONTROL(unit)->soc_flags & SOC_F_ALL_MODULES_INITED) &&
        soc_feature(unit, soc_feature_turbo_boot)) {
        SOC_HW_RESET_START(unit);
    }

    return SOC_E_NONE;
}

int
soc_trident2_tsc_reset(int unit)
{
    int blk, port;
    uint32 rval;

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    /* TSC reset is controlled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);

        SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_enabled_port_data(int unit)
{
    uint32 rval;
    uint64 rval64;
    int port, block, pgw;
    uint32 evc = 0;
    
    /* Some registers are implemented in memory, need to clear them in order
     * to have correct parity value */
    COMPILER_64_ZERO(rval64);
    PBMP_ALL_ITER(unit, port) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_1_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_1m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, 0));
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_2_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_2m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_2r(unit, port, 0));
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
            egr_vlan_control_3_entry_t entry;
            sal_memset(&entry, 0, sizeof(entry));
            WRITE_EGR_VLAN_CONTROL_3m(unit, MEM_BLOCK_ANY, port, &entry);
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_3r(unit, port, 0));
        }
        SOC_IF_ERROR_RETURN(WRITE_EGR_PVLAN_EPORT_CONTROLr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_SF_SRC_MODID_CHECKr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_1588_LINK_DELAY_64r(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_INVALID_CRC_FRAMESr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_DELIMITER_ERROR_FRAMESr(unit, port, 0));
        if (SOC_MEM_IS_VALID(unit, EGR_IPMC_CFG2m)) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2m(unit, MEM_BLOCK_ALL, port, &evc));
        } else {
            SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2r(unit, port, 0));
        }
        SOC_IF_ERROR_RETURN(WRITE_ING_TRILL_ADJACENCYr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_STORM_CONTROL_METER_CONFIGr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_SFLOW_ING_THRESHOLDr(unit, port, 0));
    }
    rval = 0;
    soc_reg_field_set(unit, PGW_MIB_RESETr, &rval, CLR_CNTf, 0xffff);
    for (pgw = 0; pgw < 8; pgw++) {
        block = PGW_CL_BLOCK(unit, pgw);
        port = SOC_BLOCK_PORT(unit, block);
        if (port < 0) { /* the PGW_CL block is not in use */
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, rval));
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, 0));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_port_data(int unit)
{
    int r, p;
    uint32 addr;
    
    SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
    
    /* Clear TDBGCn regs for all indexes */
    for (r = 0; r < 12; r++) {
        addr = 0x28000000 + r*0x100;
        for (p = 0; p < 106; p++) {
            _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
            _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
        }
    }

    /* Clear EGR_TRILL_TX_PKTS */
    addr = 0x28000c00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_ACCESS_PORT_TRILL_PKTS_DISCARDED */
    addr = 0x28000d00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED */
    addr = 0x28000e00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear TPCE */
    addr = 0x28000f00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_memory(int unit, int mmu_init)
{
    uint32              rval, in_progress;
    int                 pipe_init_usec, index, count;
    soc_timeout_t       to;
    static const struct {
        soc_mem_t mem;
        uint32 skip_flags; /* always skip on QUICKTURN or XGSSIM */
    } cam_list[] = {
        { CPU_COS_MAPm,                     BOOT_F_PLISIM },
        { EFP_TCAMm,                        BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAMm,             BOOT_F_PLISIM },
        { FP_TCAMm,                         BOOT_F_PLISIM },
        { FP_UDF_TCAMm,                     BOOT_F_PLISIM },
        { ING_SNATm,                        BOOT_F_PLISIM },
        { IP_MULTICAST_TCAMm,               BOOT_F_PLISIM },
        { L2_USER_ENTRYm,                   BOOT_F_PLISIM },
        { L3_DEFIPm,                        BOOT_F_PLISIM },
        { L3_DEFIP_PAIR_128m,               BOOT_F_PLISIM },
        { L3_TUNNELm,                       BOOT_F_PLISIM },
        { MY_STATION_TCAMm,                 BOOT_F_PLISIM },
        { UDF_CONDITIONAL_CHECK_TABLE_CAMm, BOOT_F_PLISIM },
        { VFP_TCAMm,                        BOOT_F_PLISIM },
        { VLAN_SUBNETm,                     0 },/* VLAN API needs all 0 mask */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        { MY_STATION_TCAM_2m,               BOOT_F_PLISIM },
        { SUBPORT_TAG_SGPP_MAPm,            BOOT_F_PLISIM },
#endif
#ifdef PLISIM
        /* In HW, these are the same as FP_GLOBAL_MASK_TCAM.
         * In simulation, they are separate instances.
         */
        { FP_GM_FIELDSm,                    BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Xm,           BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Ym,           BOOT_F_PLISIM }
#endif
    };

    if (mmu_init) {
        /* Start MMU memory initialization */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MISCCONFIGr, REG_PORT_ANY, INIT_MEMf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, MISCCONFIGr, REG_PORT_ANY, INIT_MEMf, 1));
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
    }
    SOC_IF_ERROR_RETURN
        (_soc_trident2_mmu_init_default_val(unit));

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries of largest IPIPE table */
    count = soc_mem_index_count(unit, RH_HGT_FLOWSETm);
    if (count < soc_mem_index_count(unit, L2Xm)) {
        count = soc_mem_index_count(unit, L2Xm);
    }
    if (count < soc_mem_index_count(unit, L3_ENTRY_ONLYm)) {
        count = soc_mem_index_count(unit, L3_ENTRY_ONLYm);
    }
    if (count < soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m)) {
        count = soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m);
    }
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries of largest EPIPE table (EGR_L3_NEXT_HOP) */
    count = soc_mem_index_count(unit, EGR_L3_NEXT_HOPm);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Xr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Yr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            if (in_progress != 0) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit,
                                     "unit %d : ING_HW_RESET timeout\n"),
                         unit));
            }
            break;
        }
    } while (in_progress != 0);

    /* Wait for EPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Xr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Yr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            if (in_progress != 0) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit,
                                     "unit %d : EGR_HW_RESET timeout\n"),
                         unit));
            }
            break;
        }
    } while (in_progress != 0);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* TCAM tables are not handled by hardware reset control */
    if (!SAL_BOOT_QUICKTURN && !SAL_BOOT_XGSSIM) {
        for (index = 0; index < sizeof(cam_list) / sizeof(cam_list[0]);
             index++) {
            if (sal_boot_flags_get() & cam_list[index].skip_flags) {
                continue;
            }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (!SOC_IS_TD2P_TT2P(unit) &&
            	  ((cam_list[index].mem == MY_STATION_TCAM_2m) || 
            	   (cam_list[index].mem == SUBPORT_TAG_SGPP_MAPm))) {
                continue;
            } 
#endif
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, cam_list[index].mem, COPYNO_ALL, TRUE));
        }
    }

    return SOC_E_NONE;
}

#if defined(BCM_WARM_BOOT_SUPPORT) && defined(BCM_TRIDENT2PLUS_SUPPORT)
/*
 * IFP Logical to Physical mapping warmboot recovery.
 */
STATIC int
_soc_td2p_log_to_ifp_mapping_recover(int unit)
{
    int num_ports;
    int ifp_port;
    soc_port_t port;
    uint32 y_pipe, valid, rval;

    /* Ingress logical to physical port mapping */
    num_ports = soc_mem_index_count(unit, PORT_TABm) - 1;

    for (port = 0; port < num_ports; port++) {
        rval = 0;
        SOC_IF_ERROR_RETURN
         (READ_IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr(unit, port, &rval));
        if (rval == 0) {
           soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = -1;
           soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = -1;
           soc_td2p_log_to_ifp_port[unit].valid_x[port] = 0;
           soc_td2p_log_to_ifp_port[unit].valid_y[port] = 0;
           continue;
        }

        y_pipe = soc_reg_field_get(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                   rval, Y_PIPEf);

        ifp_port = soc_reg_field_get(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                     rval, PHYSICAL_PORT_NUMf);

        valid = soc_reg_field_get(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                  rval, VALIDf);
        if (y_pipe) {
           soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = ifp_port;
           soc_td2p_log_to_ifp_port[unit].valid_y[port] = valid;
           if (ifp_port > soc_td2p_log_to_ifp_port[unit].last_valid_y_port) {
              soc_td2p_log_to_ifp_port[unit].last_valid_y_port = ifp_port;
           }

           soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = -1;
           soc_td2p_log_to_ifp_port[unit].valid_x[port] = 0;
        } else {
           soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = ifp_port;
           soc_td2p_log_to_ifp_port[unit].valid_x[port] = valid;
           if (ifp_port > soc_td2p_log_to_ifp_port[unit].last_valid_x_port) {
              soc_td2p_log_to_ifp_port[unit].last_valid_x_port = ifp_port;
           }

           soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = -1;
           soc_td2p_log_to_ifp_port[unit].valid_y[port] = 0;
        }
    }

    return SOC_E_NONE;
}
#endif /* (BCM_WARM_BOOT_SUPPORT) && (BCM_TRIDENT2PLUS_SUPPORT) */


STATIC int
_soc_trident2_port_mapping_init(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int port, phy_port;
    int num_port, num_phy_port;
    int ifp_port = -1;
    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            port == -1 ? 0x7f : port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Ingress logical to physical port mapping */
    num_port = soc_mem_index_count(unit, PORT_TABm) - 1;

    /* Egress logical to physical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0xff : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit, port,
                                                                rval));
    }

    /* MMU to physical port mapping and MMU to logical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) {
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, &rval,
                          PHY_PORTf, phy_port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, port, 0,
                           rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, &rval,
                          LOGIC_PORTf, port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, port, 0,
                           rval));
    }

#if defined BCM_TRIDENT2PLUS_SUPPORT
    /*
     * Maintaining a mapping database which holds unique stream IDs
     * for all the valid logical ports for X and Y pipe.
     * Reason to maintain a mapping database:
     * Earlier, MMU port is been used as a merely unqiue stream ID.
     * During flex operation, a new MMU port is been assigned to a logical port
     * due to which the PHYSICAL_PORT_NUM of a IFP_GM mapping register is getting
     * modified to a new stream ID, which invalids the IPBM/IPBM_MASK fields of
     * FP_GLOBAL_MASK_TCAM.
     */
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        int ifp_x_port = 0;
        int ifp_y_port=0;
        int y_pipe=0;
        
        ifp_port = 0;
#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
           return _soc_td2p_log_to_ifp_mapping_recover(unit);
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
        LOG_DEBUG(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                  "lport pport IFP_Port Y-Pipe\n\r")));
        LOG_DEBUG(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                  "===== ===== ======== ======\n\r")));
        for (port = 0; port < num_port; port++) {
           /* Initialize IFP ports as per logical ports */
           if (SOC_PBMP_MEMBER(si->ypipe_pbm, port)) { /* Y-pipe */
              soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = ifp_y_port;
              soc_td2p_log_to_ifp_port[unit].valid_y[port] = 1;
              soc_td2p_log_to_ifp_port[unit].valid_x[port] = 0;
              soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = -1;
              ifp_port = ifp_y_port; 
              ifp_y_port++;
              y_pipe = 1;
           } else if (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) { /* X-pipe */
              soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = ifp_x_port;
              soc_td2p_log_to_ifp_port[unit].valid_x[port] = 1;
              soc_td2p_log_to_ifp_port[unit].valid_y[port] = 0;
              soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = -1;
              ifp_port = ifp_x_port; 
              ifp_x_port++;
              y_pipe = 0;
           } else {
              soc_td2p_log_to_ifp_port[unit].valid_x[port] = 0;
              soc_td2p_log_to_ifp_port[unit].valid_y[port] = 0;
              ifp_port = -1;
              soc_td2p_log_to_ifp_port[unit].ifp_x_port[port] = -1;
              soc_td2p_log_to_ifp_port[unit].ifp_y_port[port] = -1;
           }
           LOG_DEBUG(BSL_LS_BCM_COMMON, (BSL_META_U(unit,
                     "%02d  %02d  %02d     %d    \n\r"), port,
                      si->port_l2p_mapping[port], ifp_port, y_pipe));
        }
        soc_td2p_log_to_ifp_port[unit].last_valid_x_port = ifp_x_port - 1;
        soc_td2p_log_to_ifp_port[unit].last_valid_y_port = ifp_y_port - 1;
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        if (phy_port != -1) {
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              VALIDf, 1);

            if (SOC_PBMP_MEMBER(si->ypipe_pbm, port)) { /* Y-pipe */
                soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                  &rval, Y_PIPEf, 1);
            }

            /* IFP_GM_LOGICAL_TO_PHYSICAL_MAPP?ING.PHYSICAL_PORT_NUM is
             * merely a unique stream ID, it's not physical port number */
#if defined BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TRIDENT2PLUS(unit)) {
               if (soc_td2p_log_to_ifp_port[unit].valid_y[port] == 0) {
                   ifp_port = soc_td2p_log_to_ifp_port[unit].ifp_x_port[port];
               } else {
                   ifp_port = soc_td2p_log_to_ifp_port[unit].ifp_y_port[port];
               }
            } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
               ifp_port = si->port_p2m_mapping[phy_port];
            }
              
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              PHYSICAL_PORT_NUMf, ifp_port & 0x3f);
        }
        SOC_IF_ERROR_RETURN(
            WRITE_IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr(unit, port, rval));
    }


    return SOC_E_NONE;
}

void
_soc_trident2_quad_bandwidth_calculate(int unit, int quad,
                                       int *max_quad_core_bandwidth,
                                       int *quad_linerate_bandwidth,
                                       int *quad_oversub_bandwidth)
{
    soc_info_t *si;
    int port, phy_port, index;
    int bandwidth;

    si = &SOC_INFO(unit);

    if (si->bandwidth == 720000) {
        *max_quad_core_bandwidth = quad == 0 || quad == 3 ? 160000 : 200000;
    } else {
        *max_quad_core_bandwidth = si->bandwidth / 4;
    }
    *quad_linerate_bandwidth = 0;
    *quad_oversub_bandwidth = 0;
    for (index = 0; index < _TD2_PORTS_PER_QUAD; index++) {
        phy_port = 1 + quad * _TD2_PORTS_PER_QUAD + index;
        port = si->port_p2l_mapping[phy_port];
        if (port == -1) {
            continue;
        }
        if (si->port_speed_max[port] > 40000) {
           bandwidth = 100000;
        } else if (si->port_speed_max[port] > 20000) {
            bandwidth = 40000;
        } else if (si->port_speed_max[port] > 10000) {
            bandwidth = 20000;
        } else {
            bandwidth = 10000;
        }
        if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
            *quad_oversub_bandwidth += bandwidth;
        } else {
            *quad_linerate_bandwidth += bandwidth;
        }
    }
}

#define MGM_TOKEN (NUM_EXT_PORTS+3)

_soc_trident2_tdm_t *_soc_td2_tdm[SOC_MAX_NUM_DEVICES];

/*
 * Function:
 *      soc_td2_td2p_tdm_sched_info_get
 * Description:
 *      Get handle of TDM data.
 * Parameters:
 *      unit    - Device number
 *      create  - When set, alloc container if necessary.
 * Return:
 *      NULL    - If alloc failed or no TDM data without creation.
 *      data handler.
 */
_soc_trident2_tdm_t *soc_td2_td2p_tdm_sched_info_get(int unit, int create)
{
    _soc_trident2_tdm_t *tdm = NULL;

    tdm = _soc_td2_tdm[unit];
    if (tdm == NULL) {
        if (create) {
            tdm = sal_alloc(sizeof(_soc_trident2_tdm_t), "Trident2 TDM info");
            if (tdm == NULL) {
                return NULL;
            }
            sal_memset(tdm, 0, sizeof(_soc_trident2_tdm_t));
            _soc_td2_tdm[unit] = tdm;
        } else {
            return NULL;
        }
    } else {
        if (create) {
            sal_memset(tdm, 0, sizeof(_soc_trident2_tdm_t));
        }
    }

    return tdm;
}

int
soc_trident2_get_prio_map(int unit, int port, uint16 *pri_mask)
{
    char name[80];
    int  pri_to_prigroup[16];
    int  prio;

    if (NULL == pri_mask) {
        return SOC_E_PARAM;
    }

    /* internal priority to priority group mapping */
    sal_sprintf(name, "%s.%s.%s.%s", spn_BUF, spn_MAP, spn_PRI, spn_PRIGROUP);

    sal_memset(pri_to_prigroup, 0, sizeof(pri_to_prigroup));

    /* OBM Priority Map configuration needs to be in sync with MMU
     * configuration. If the config property is set use the prigroup map.
     * else use the default lossless setting.
     */
    if (soc_property_port_get_csv(unit, port, name,
                                  (_SOC_TD2_MAX_INTERNAL_PRIORITY + 1),
                                  pri_to_prigroup)) {
        *pri_mask = 0;
        for (prio=0; prio <= _SOC_TD2_MAX_INTERNAL_PRIORITY; prio++) {
            /*  PG7 (_SOC_TD2_MAX_PRIORITY) is mapped to Lossless priority, 
             *  If the config priority is lossless priority, Then Flow control
             *  is enabled.
             */
            if (pri_to_prigroup[prio] == _SOC_TD2_MAX_PRIORITY) {
                *pri_mask |= 1 << prio;
            }
        }
    }
    return SOC_E_NONE;
}

int
soc_td2_obm_ctrl_reg_default_set (int unit, int xlp, int port_index, int obm_inst,
                                  int oversub, int default_flag)
{
    soc_reg_t reg;
    uint64 ctrl_rval64;
    reg = td2_pgw_obm_ctrl_regs[xlp];
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, reg, obm_inst, 0, &ctrl_rval64));
    if ( PGW_OBM_INIT_HW_DEFAULT == default_flag ) {
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              td2_pgw_obm_oversub_fields[port_index],0);
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              td2_pgw_obm_bypass_fields[port_index], 1);
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              OVERSUB_HEADROOM_ENABLEf, 1);
    } else {
        uint8 rev_id;
        soc_cm_get_id_otp(unit, NULL, &rev_id);
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              td2_pgw_obm_oversub_fields[port_index],
                             (oversub ? 1 : 0));
        /* Do not allow OBM bypass if the oversubscribed
         * XLPORT block has more than 1 port configured */
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              td2_pgw_obm_bypass_fields[port_index],
                              (oversub ? 0 : 1));
        if (SOC_IS_TD2P_TT2P(unit) || (rev_id > BCM56850_A1_REV_ID)) {
            soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                  OVERSUB_HEADROOM_ENABLEf, 0);
        }
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

    return SOC_E_NONE;
}

int
soc_td2_obm_use_counter_reg_default_set (int unit, int xlp, int port_index,
                                         int obm_inst)
{
    soc_reg_t reg;
    uint64 ctrl_rval64;
    reg = td2_pgw_obm_use_counter_regs[xlp];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, port_index,
                                    &ctrl_rval64));
    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                          td2_pgw_obm_use_count_fields[port_index], 0);
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, reg, obm_inst, port_index, ctrl_rval64));

    return SOC_E_NONE;
}

int
soc_td2_obm_shared_config_reg_default_set (int unit, int xlp, int port_index,
                                           int obm_inst, int default_flag)
{
    soc_reg_t reg;
    uint64 ctrl_rval64;
    reg = td2_pgw_obm_shared_config_regs[xlp];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, port_index,
                                    &ctrl_rval64));
    if ( PGW_OBM_INIT_HW_DEFAULT == default_flag ) {
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              SHARED_POOL_SIZEf, 0x280);
    } else {
        uint8 rev_id;
        soc_cm_get_id_otp(unit, NULL, &rev_id);
        if (!SOC_IS_TD2P_TT2P(unit) && (rev_id <= BCM56850_A1_REV_ID)) {
            soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                  SHARED_POOL_SIZEf, 0);
        } else {
            soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                  SHARED_POOL_SIZEf, GET_NUM_CELLS_PER_OBM(unit));
        }
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, reg, obm_inst, port_index, ctrl_rval64));

    return SOC_E_NONE;
}

int
soc_td2_obm_max_usage_reg_default_set (int unit, int xlp, int port_index,
                                       int obm_inst)
{
    soc_reg_t reg;
    uint64 ctrl_rval64;
    reg = td2_pgw_obm_max_usage_regs[xlp];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, port_index,
                                    &ctrl_rval64));
    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                          td2_pgw_obm_max_usage_fields[port_index], 0);
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, reg, obm_inst, port_index, ctrl_rval64));

    return SOC_E_NONE;
}

int
soc_td2_obm_fc_config_reg_default_set (int unit, int xlp, int port_index,
                                       int obm_inst, int logical_port,
                                       int oversub, int default_flag)
{
    soc_reg_t reg;
    uint64 ctrl_rval64;
    int reg_index;
    uint16 pri_mask;

    if (logical_port == -1) {
        return SOC_E_NONE;
    }

    reg_index = xlp * _TD2_PORTS_PER_XLP + port_index;
    reg = td2_pgw_obm_fc_config_regs[reg_index];

    COMPILER_64_ZERO(ctrl_rval64);
    if ( PGW_OBM_INIT_HW_DEFAULT == default_flag || !oversub ) {
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              PORT_FC_ENABLEf, 0);
    } else {
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                              PORT_FC_ENABLEf, 1);
    }
    pri_mask = 0xffff;
    if (PGW_OBM_INIT_HW_DEFAULT == default_flag){
        pri_mask = 0xfffc;
    } else if (soc_feature(unit, soc_feature_prigrp_to_obm_prio_map)) {
        SOC_IF_ERROR_RETURN
            (soc_trident2_get_prio_map(
                              unit,
                              logical_port,
                              &pri_mask));
    }
    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                      PRIORITY_PROFILE_FCf, pri_mask);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    /* This field controls the frequence of XOFF status sent to
     * the xlmac is refreshed. units=250ns.
     */
    if (SOC_IS_TD2P_TT2P(unit)) {
        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                          XOFF_REFRESH_TIMERf, 0x100);
    }
#endif
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

    return SOC_E_NONE;
}


STATIC int
_soc_trident2_tdm_init(int unit)
{
    soc_info_t *si;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port, block, obm_inst;
    int pipe, pgw, xlp, tsc, group, slot, length, base, index, count, id;
    int wt_group = 0;
    int rv, i;
    int num_of_subport;
#ifdef BCM_56850_A0
    enum tdm_td2_port_speed td2_spd[TDM_TD2_NUM_EXT_PORTS];
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    tdm_soc_t _chip_pkg;
    tdm_mod_t *_tdm_pkg;
    int wt_group_select;
#endif
    int pgw_master, pgw_slave;
    int lossless;
    int speed_max, weight;
    int mtu_cells, res_cells, port_cells;
    uint32 xlport_map;
    soc_reg_t reg;
    soc_mem_t mem;
    uint64 rval64, ctrl_rval64;
    uint32 rval;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_field_t fields[4];
    uint32 values[4];
    int max_quad_core_bandwidth, quad_oversub_core_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    uint16 dev_id;
    uint8 rev_id;
    int obm_setting_idx, oversub_ratio_idx;
    int min_threshold, xoff_threshold, xon_threshold, xon_threshold_offset;
    uint16 pri_mask;
    int ancillary_bandwidth_mode = 0;
    _soc_trident2_tdm_t *td2_tdm = NULL;

    static const struct _obm_setting_s {
        int max_threshold;
        int xoff_threshold[3]; /* for oversub ratio 1.27, 1.43, and above */
    } obm_settings[] = {
        { _TD2_TD2_CELLS_PER_OBM / 4, { 79, 26, 37 } },      /* 10G */
        { _TD2_TD2_CELLS_PER_OBM / 2, { 315, 242, 86 } },    /* 20G */
        { _TD2_TD2_CELLS_PER_OBM, { 707, 584, 339 } }        /* 40G */
    };
    static const struct _obm_setting_a1_s {
        int xoff_threshold[3]; /* for oversub ratio 1.33, 1.5, and above */
        int mtu_cells[3];      /* for oversub ratio 1.33, 1.5, and above */
    } obm_settings_a1[] = {
        { /* 10G */
            { 56, 40, 23 },
            { 5 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              3 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              2 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 20G */
            { 215, 115, 60 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              6 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 40G */
            { 661, 543, 306 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        }
    };

    static const soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static const soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    static const soc_reg_t mmu_ovs_group_cfg_regs[] = {
        ES_PIPE0_OVR_SUB_GRP_CFGr, ES_PIPE1_OVR_SUB_GRP_CFGr
    };
    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;


    static const soc_field_t xlp_cell_asf_thresh_fields[] = {
        XLP0_CELL_ASM_CUT_THRU_THRESHOLDf, XLP1_CELL_ASM_CUT_THRU_THRESHOLDf,
        XLP2_CELL_ASM_CUT_THRU_THRESHOLDf, XLP3_CELL_ASM_CUT_THRU_THRESHOLDf
    };
    static const soc_mem_t iarb_tdm_mems[2] ={
        IARB_MAIN_TDM_Xm, IARB_MAIN_TDM_Ym
    };

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = 
        get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    ancillary_bandwidth_mode = soc_property_get(unit, spn_ANCILLARY_BANDWIDTH_MODE, 0); 

    td2_tdm = soc_td2_td2p_tdm_sched_info_get(unit, 1);
    if (td2_tdm == NULL) {
        return SOC_E_MEMORY;
    }

    si = &SOC_INFO(unit);

    td2_tdm->ancillary_bandwidth_mode = ancillary_bandwidth_mode;

    PBMP_PORT_ITER(unit, port) {
        if (SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        td2_tdm->speed[phy_port] = si->port_speed_max[port];
        td2_tdm->port_state[phy_port] =
            SOC_PBMP_MEMBER(si->oversub_pbm, port) ?
            PORT_STATE_OVERSUB : PORT_STATE_LINERATE;

        num_of_subport = 0;
        if (SOC_IS_TD2P_TT2P(unit) &&
            (td2_tdm->speed[phy_port] >= 120000)) {
            num_of_subport = 11;
        } else if (SOC_IS_TD2P_TT2P(unit) &&
            (td2_tdm->speed[phy_port] >= 100000)) {
            num_of_subport = 9;
        } else if (td2_tdm->speed[phy_port] >= 40000) {
            num_of_subport = 3;
        } else if (SOC_IS_TITAN2PLUS(unit) &&
                      ((td2_tdm->speed[phy_port] == 13000) ||
                       (td2_tdm->speed[phy_port] == 16000))) {
            num_of_subport = 3;
        } else if (td2_tdm->speed[phy_port] >= 20000) {
            num_of_subport = 1;
        }
        for (i = 0; i < num_of_subport; i++) {
            td2_tdm->port_state[phy_port + i + 1] = PORT_STATE_SUBPORT;
        }
    }

    td2_tdm->speed[0] = 1000;
    td2_tdm->speed[129] = 1000;
    td2_tdm->tdm_bw = si->bandwidth / 1000;

    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->xpipe_pbm);
    if (td2_tdm->tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 0); /* cpu port */
        td2_tdm->pipe_ovs_state[0] = SOC_PBMP_EQ(pbmp, si->xpipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        td2_tdm->pipe_ovs_state[0] = SOC_PBMP_NOT_NULL(pbmp);
    }
    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->ypipe_pbm);
    if (td2_tdm->tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 105); /* loopback port */
        td2_tdm->pipe_ovs_state[1] = SOC_PBMP_EQ(pbmp, si->ypipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        td2_tdm->pipe_ovs_state[1] = SOC_PBMP_NOT_NULL(pbmp);
    }
    td2_tdm->manage_port_type = 0;
    if (SOC_PBMP_NOT_NULL(si->management_pbm)) {
        speed_max = 0;
        for (phy_port = 13; phy_port <= 16; phy_port++) {
            port = si->port_p2l_mapping[phy_port];
            if (port == -1) {
                continue;
            }
            if (speed_max < si->port_speed_max[port]) {
                speed_max = si->port_speed_max[port];
            }
        }
        if (speed_max <= 1000) {
            td2_tdm->manage_port_type = 1; /* 4 x 1g */
        } else if (speed_max <= 2500) {
            td2_tdm->manage_port_type = 2; /* 4 * 2.5g */
        } else {
            td2_tdm->manage_port_type = 3; /* 1 x 10g */
        }
        if (td2_tdm->manage_port_type > 0) {
            td2_tdm->pgw_tdm[0][0] = 1234; /* magic number used by
                                                * tdm code */
        }
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        if (td2_tdm->manage_port_type != 0) {
            _chip_pkg.soc_vars.td2p.tdm_mgmt_en = 1;
        } else {
            _chip_pkg.soc_vars.td2p.tdm_mgmt_en = 0;
        }
    }
#endif

    for (slot = 0; slot <= _MMU_TDM_LENGTH; slot++) {
        td2_tdm->mmu_tdm[0][slot] = NUM_EXT_PORTS;
        td2_tdm->mmu_tdm[1][slot] = NUM_EXT_PORTS;
    }

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        LOG_CLI((BSL_META_U(unit,
                            "tdm_bw: %dG\n"), td2_tdm->tdm_bw));
        LOG_CLI((BSL_META_U(unit,
                            "port speed:")));
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 8 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                " %6d"), td2_tdm->speed[index]));
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
        LOG_CLI((BSL_META_U(unit,
                            "port state map:")));
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 16 == 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n    ")));
            }
            if (index == 0 || index == (NUM_EXT_PORTS - 1)) {
                LOG_CLI((BSL_META_U(unit,
                                    " ---")));
            } else {
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         td2_tdm->port_state[index]));
            }
        }
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        _chip_pkg.unit = unit;
        _chip_pkg.num_ext_ports = TD2P_NUM_EXT_PORTS;
        _chip_pkg.state=sal_alloc((_chip_pkg.num_ext_ports)*sizeof(int *), "port state list");
        _chip_pkg.speed=sal_alloc((_chip_pkg.num_ext_ports)*sizeof(int *), "port speed list");
        for (index=1; index<(_chip_pkg.num_ext_ports); index++) {
            _chip_pkg.state[index] = td2_tdm->port_state[index];
        }
        _chip_pkg.state[0]=1; /* enable cpu port */
        _chip_pkg.state[_chip_pkg.num_ext_ports-1]=1; /* enable loopback port */
        for (index=0; index<(_chip_pkg.num_ext_ports); index++) {
            _chip_pkg.speed[index] = td2_tdm->speed[index];
        }

        /*
         * Map detected core clk frequency to TDM algorithm internal code
         * value.
         */
        switch (si->frequency) {
            case 790:
            case 760:
                _chip_pkg.clk_freq = 760;
                break;
            case 635:
                _chip_pkg.clk_freq = 608;
                break;
            case 537:
                _chip_pkg.clk_freq = 518;
                break;
            case 421:
                _chip_pkg.clk_freq = 415;
                break;
            default:
                _chip_pkg.clk_freq = (si->frequency > 760) ? (760)
                                        : si->frequency;
        }

        _tdm_pkg = _soc_set_tdm_tbl(SOC_SEL_TDM(&_chip_pkg));
        if (!_tdm_pkg) {
            LOG_CLI((BSL_META_U(unit,
                "Unable to configure TDM, please contact your "
                "Field Applications Engineer or Sales Manager for "
                "additional assistance.\n")));
            return SOC_E_FAIL;
        }
        sal_memcpy(td2_tdm->pgw_tdm[0], _tdm_pkg->_chip_data.cal_0.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(td2_tdm->pgw_ovs_tdm[0], _tdm_pkg->_chip_data.cal_0.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_ovs_spacing[0], _tdm_pkg->_chip_data.cal_0.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_tdm[1], _tdm_pkg->_chip_data.cal_1.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(td2_tdm->pgw_ovs_tdm[1], _tdm_pkg->_chip_data.cal_1.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_ovs_spacing[1], _tdm_pkg->_chip_data.cal_1.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_tdm[2], _tdm_pkg->_chip_data.cal_2.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(td2_tdm->pgw_ovs_tdm[2], _tdm_pkg->_chip_data.cal_2.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_ovs_spacing[2], _tdm_pkg->_chip_data.cal_2.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_tdm[3], _tdm_pkg->_chip_data.cal_3.cal_main, sizeof(int)*MAX_PGW_TDM_LENGTH);
        sal_memcpy(td2_tdm->pgw_ovs_tdm[3], _tdm_pkg->_chip_data.cal_3.cal_grp[0], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->pgw_ovs_spacing[3], _tdm_pkg->_chip_data.cal_3.cal_grp[1], sizeof(int)*_PGW_TDM_OVS_SIZE);
        sal_memcpy(td2_tdm->mmu_tdm[0], _tdm_pkg->_chip_data.cal_4.cal_main, sizeof(int)*_MMU_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][0], _tdm_pkg->_chip_data.cal_4.cal_grp[0], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][1], _tdm_pkg->_chip_data.cal_4.cal_grp[1], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][2], _tdm_pkg->_chip_data.cal_4.cal_grp[2], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][3], _tdm_pkg->_chip_data.cal_4.cal_grp[3], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][4], _tdm_pkg->_chip_data.cal_4.cal_grp[4], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][5], _tdm_pkg->_chip_data.cal_4.cal_grp[5], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][6], _tdm_pkg->_chip_data.cal_4.cal_grp[6], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[0][7], _tdm_pkg->_chip_data.cal_4.cal_grp[7], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_tdm[1], _tdm_pkg->_chip_data.cal_5.cal_main, sizeof(int)*_MMU_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][0], _tdm_pkg->_chip_data.cal_5.cal_grp[0], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][1], _tdm_pkg->_chip_data.cal_5.cal_grp[1], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][2], _tdm_pkg->_chip_data.cal_5.cal_grp[2], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][3], _tdm_pkg->_chip_data.cal_5.cal_grp[3], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][4], _tdm_pkg->_chip_data.cal_5.cal_grp[4], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][5], _tdm_pkg->_chip_data.cal_5.cal_grp[5], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][6], _tdm_pkg->_chip_data.cal_5.cal_grp[6], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_memcpy(td2_tdm->mmu_ovs_group_tdm[1][7], _tdm_pkg->_chip_data.cal_5.cal_grp[7], sizeof(int)*_MMU_OVS_GROUP_TDM_LENGTH);
        sal_free(_chip_pkg.state);
        sal_free(_chip_pkg.speed);
        _tdm_pkg->_chip_exec[TDM_CHIP_EXEC__FREE](_tdm_pkg);
        sal_free(_tdm_pkg);
    } else 
#endif
    {
#ifdef BCM_56850_A0
        for (index=0; index<130; index++) {
            td2_spd[index] = td2_tdm->speed[index];
        }
        rv = _soc_td2_set_tdm_tbl(td2_spd, td2_tdm->tdm_bw,
                         td2_tdm->pgw_tdm[0],
                         td2_tdm->pgw_ovs_tdm[0],
                         td2_tdm->pgw_ovs_spacing[0],
                         td2_tdm->pgw_tdm[1],
                         td2_tdm->pgw_ovs_tdm[1],
                         td2_tdm->pgw_ovs_spacing[1],
                         td2_tdm->pgw_tdm[2],
                         td2_tdm->pgw_ovs_tdm[2],
                         td2_tdm->pgw_ovs_spacing[2],
                         td2_tdm->pgw_tdm[3],
                         td2_tdm->pgw_ovs_tdm[3],
                         td2_tdm->pgw_ovs_spacing[3],
                         td2_tdm->mmu_tdm[0],
                         td2_tdm->mmu_ovs_group_tdm[0][0],
                         td2_tdm->mmu_ovs_group_tdm[0][1],
                         td2_tdm->mmu_ovs_group_tdm[0][2],
                         td2_tdm->mmu_ovs_group_tdm[0][3],
                         td2_tdm->mmu_tdm[1],
                         td2_tdm->mmu_ovs_group_tdm[1][0],
                         td2_tdm->mmu_ovs_group_tdm[1][1],
                         td2_tdm->mmu_ovs_group_tdm[1][2],
                         td2_tdm->mmu_ovs_group_tdm[1][3],
                         &td2_tdm->port_state[1], /* skip cpu port */
                         td2_tdm->iarb_tdm[0],
                         td2_tdm->iarb_tdm[1],
                         td2_tdm->ancillary_bandwidth_mode);
		if (rv == 0) {
			LOG_CLI((BSL_META_U(unit,
								"Unable to configure TDM, please contact your "
								"Field Applications Engineer or Sales Manager for "
								"additional assistance.\n")));
			return SOC_E_FAIL;
		}
#endif
	}

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_tdm:"), pgw));
            for (index = 0; index < GET_PGW_TDM_LENGTH(unit); index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         td2_tdm->pgw_tdm[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_ovs_tdm:"), pgw));
            for (index = 0; index < _PGW_TDM_OVS_SIZE; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                                    td2_tdm->pgw_ovs_tdm[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "PGW_CL%d pgw_ovs_spacing:"), pgw));
            for (index = 0; index < _PGW_TDM_OVS_SIZE; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         td2_tdm->pgw_ovs_spacing[pgw / 2][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
        }
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            LOG_CLI((BSL_META_U(unit,
                                "Pipe %c mmu_tdm:"), pipe ? 'y' : 'x'));
            for (index = 0; index < _MMU_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         td2_tdm->mmu_tdm[pipe][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
                LOG_CLI((BSL_META_U(unit,
                                    "Pipe %c group %d ovs_group_tdm"),
                         pipe ? 'y' : 'x', group));
                for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH;
                     index++) {
                    if (index % 16 == 0) {
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    ")));
                    }
                    LOG_CLI((BSL_META_U(unit,
                                        " %3d"),
                             td2_tdm->mmu_ovs_group_tdm[pipe][group][index]));
                }
                LOG_CLI((BSL_META_U(unit,
                                    "\n")));
            }
        }
    }

    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        LOG_CLI((BSL_META_U(unit,
                            "tdm_bw: %dG\n"), td2_tdm->tdm_bw));
        LOG_CLI((BSL_META_U(unit,
                            "x pipe ovs state: %d\n"),
                 td2_tdm->pipe_ovs_state[0]));
        LOG_CLI((BSL_META_U(unit,
                            "y pipe ovs state: %d\n"),
                 td2_tdm->pipe_ovs_state[1]));
        LOG_CLI((BSL_META_U(unit,
                            "manage port type: %d\n"),
                 td2_tdm->manage_port_type));
    }
	
#ifdef BCM_56860_A0
    if (SOC_IS_TD2P_TT2P(unit)) {
        rv = tdm_td2p_set_iarb_tdm_table(td2_tdm->tdm_bw,
                                td2_tdm->pipe_ovs_state[0],
                                td2_tdm->pipe_ovs_state[1],
                                td2_tdm->manage_port_type == 1,
                                td2_tdm->manage_port_type == 2,
                                td2_tdm->manage_port_type == 3,
                                &td2_tdm->iarb_tdm_wrap_ptr[0],
                                &td2_tdm->iarb_tdm_wrap_ptr[1],
                                td2_tdm->iarb_tdm[0],
                                td2_tdm->iarb_tdm[1]);
    } else 
#endif
    {
        rv = tdm_td2_set_iarb_tdm_table(td2_tdm->tdm_bw,
                                td2_tdm->pipe_ovs_state[0],
                                td2_tdm->pipe_ovs_state[1],
                                td2_tdm->manage_port_type == 1,
                                td2_tdm->manage_port_type == 2,
                                td2_tdm->manage_port_type == 3,
                                &td2_tdm->iarb_tdm_wrap_ptr[0],
                                &td2_tdm->iarb_tdm_wrap_ptr[1],
                                td2_tdm->iarb_tdm[0],
                                td2_tdm->iarb_tdm[1]);
    }
    if (rv == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "Unable to configure IARB TDM, please contact your "
                            "Field Applications Engineer or Sales Manager for "
                            "additional assistance.\n")));
        return SOC_E_FAIL;
    }
	
    if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            LOG_CLI((BSL_META_U(unit,
                                "Pipe %c iarb_tdm: (wrap_ptr %d)"),
                     pipe ? 'y' : 'x',
                     td2_tdm->iarb_tdm_wrap_ptr[pipe]));
            for (index = 0; index < _IARB_TDM_LENGTH; index++) {
                if (index > td2_tdm->iarb_tdm_wrap_ptr[pipe]) {
                    break;
                }
                if (index % 16 == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " %3d"),
                         td2_tdm->iarb_tdm[pipe][index]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
        }
    }

    /* Configure PGW TDM for TD2,  only need to program master PGWs (PGW_CL0/2/4/6) */
    /* Configure PGW TDM for TD2+, only need to program master PGWs (PGW_CL0/3/4/7) */
    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
        pgw_master = pgw;
        pgw_slave  = pgw + 1;

        if (SOC_IS_TD2P_TT2P(unit)) {
            if (( pgw == 2 ) || ( pgw == 6 )) {
                pgw_master = pgw + 1;
                pgw_slave  = pgw;
            }
        }

        /* coverity[negative_returns : FALSE] */
        if (!si->block_valid[PGW_CL_BLOCK(unit, pgw_master)] &&
            !si->block_valid[PGW_CL_BLOCK(unit, pgw_slave)]) {
            /* Both master and slave are not in use */
            continue;
        }

        obm_inst = pgw_master | SOC_REG_ADDR_INSTANCE_MASK;

        SOC_IF_ERROR_RETURN(soc_reg_get(unit, PGW_TDM_CONTROLr, obm_inst, 0,
                                        &ctrl_rval64));

        /* Configure PGW line rate ports TDM */
        count = 0;
        for (base = 0; base < GET_PGW_TDM_LENGTH(unit);
            base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = td2_tdm->pgw_tdm[pgw_master / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    break;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
                count++;
            }
            if (index != 0) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, 0, rval64));
            }
            if (index != _PGW_TDM_SLOTS_PER_REG) {
            /* Due to the hardware limitation, Line-rate TDM 
               wrap pointer MUST be larger than 0 */
                if (count == 1) {
                    count = 2;
                    soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                          PGW_LR_UNUSED_SLOT);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, 0, rval64));
                }
                break;
            }
        }

        if (count > 0) {
            soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                                  LR_TDM_WRAP_PTRf, count - 1);
        } else {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            /* Switch from/to TDM table1 and to/from TDM table 2
             * When switching from TDM table1 to table2, there is an
             * intermediate state to wait for End-of-Table to check if tdm_ptr is equal
             * to LR_TDMx_WRAP_PTR. If there's no entry in TDM table(count == 0),
             * need to set LR_TDMx_WRAP_PTRf to 0 to switch new table completely */
            if (SOC_IS_TD2P_TT2P(unit)) {
                soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                                      LR_TDM_WRAP_PTRf, 0);
            }
#endif
        }
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              LR_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription ports TDM */
        count = 0;
        for (base = 0; base < _PGW_TDM_OVS_SIZE;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = td2_tdm->pgw_ovs_tdm[pgw_master / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    phy_port = 0xff;
                } else {
                    count++;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }
        /* OS_TDM_WRAP_PTR is always 31 (reset value) */
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              OS_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription port spacing */
        for (base = 0; base < _PGW_TDM_OVS_SIZE;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_spacing_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = td2_tdm->pgw_ovs_spacing[pgw_master / 2][slot];
                soc_reg64_field32_set(unit, reg, &rval64,
                                      pgw_spacing_fields[slot], phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }

        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, PGW_TDM_CONTROLr, obm_inst, 0, ctrl_rval64));
    }

    /* Configure PGW TDM oversubscription buffer manager (OBM) */
    xlport_map = 0;
    SOC_BLOCK_ITER(unit, block, SOC_BLK_XLPORT) {
        xlport_map |= 1 << SOC_BLOCK_NUMBER(unit, block);
    }
    quad_oversub_bandwidth = 0; /* to eliminate false compiler warning */
    quad_oversub_core_bandwidth = 0; /* to eliminate false compiler warning */

    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw++) {
        if (!(pgw & 1)) {
            /* coverity[negative_returns : FALSE] */
            if (!si->block_valid[PGW_CL_BLOCK(unit, pgw)] &&
                !si->block_valid[PGW_CL_BLOCK(unit, pgw + 1)]) {
                /* Both master and slave are not in use */
                pgw++;
                continue;
            }
            /* Calculate per quadrant line rate and oversub bandwidth */
            _soc_trident2_quad_bandwidth_calculate
                (unit, pgw / _TD2_PGWS_PER_QUAD, &max_quad_core_bandwidth,
                 &quad_linerate_bandwidth, &quad_oversub_bandwidth);
            quad_oversub_core_bandwidth =
                max_quad_core_bandwidth - quad_linerate_bandwidth;
        }

        block = PGW_CL_BLOCK(unit, pgw);
        /* coverity[negative_returns : FALSE] */
        if (SOC_BLOCK_PORT(unit, block) < 0) { /* PGW is not in use */
            continue;
        }

        obm_inst = pgw | SOC_REG_ADDR_INSTANCE_MASK;

        COMPILER_64_ZERO(rval64);
        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++){
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            index = pgw & 1 ? _TD2_XLPS_PER_PGW - 1 - xlp : xlp;
            soc_reg64_field32_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr, &rval64,
                                  xlp_cell_asf_thresh_fields[index], _TD2_PGW_CELL_ASM_CUT_THRU_THRESHOLD);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr,
                                        obm_inst, 0, rval64));

        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++) {
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            /* XLP number is reversed (mirrored) in odd number PGW block */
            tsc = pgw * _TD2_XLPS_PER_PGW +
                ((pgw & 1) ? (_TD2_XLPS_PER_PGW - 1 - xlp) : xlp);

            /* Count number of oversub ports in the OBM (XLPORT) */
            count = 0;
            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (td2_tdm->port_state[phy_port] == PORT_STATE_OVERSUB) {
                    count++;
                }
            }
            if (count == 0) { /* the XLPORT is not in oversub mode */
                continue;
            }

            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (si->port_p2l_mapping[phy_port] == -1) {
                    continue;
                }
                SOC_IF_ERROR_RETURN(
                    soc_td2_obm_ctrl_reg_default_set(unit, xlp, index, obm_inst,
                                                     count, PGW_OBM_INIT_SW_DEFAULT));
            }

            if (!SOC_IS_TD2P_TT2P(unit) && (rev_id <= BCM56850_A1_REV_ID)) {
                /* Do not map to low priority on A0/A1 */
                reg = td2_pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          PCP_MAPf, 0xffff);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                SOC_IF_ERROR_RETURN
                    (soc_td2_obm_shared_config_reg_default_set(unit, xlp,
                                        0, obm_inst, PGW_OBM_INIT_SW_DEFAULT));

                reg = td2_pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

                    if (si->port_speed_max[port] > 20000) {
                        obm_setting_idx = 2; /* entry 2 in the lookup table */
                        xon_threshold_offset = 24; /* xon = xoff - 24 */
                    } else if (si->port_speed_max[port] > 10000) {
                        obm_setting_idx = 1; /* entry 1 in the lookup table */
                        xon_threshold_offset = 12; /* xon = xoff - 12 */
                    } else {
                        obm_setting_idx = 0; /* entry 0 in the lookup table */
                        xon_threshold_offset = 6; /* xon = xoff - 6 */
                    }
                    if (quad_oversub_bandwidth * 2 >
                        quad_oversub_core_bandwidth * 3) {
                        /* oversub ratio greater than 1.5 (3/2) */
                        oversub_ratio_idx = 1;
                    } else if (quad_oversub_bandwidth * 3 >
                        quad_oversub_core_bandwidth * 4) {
                        /* oversub ratio greater than 1.33 (4/3) */
                        oversub_ratio_idx = 1;
                    } else {
                        oversub_ratio_idx = 0;
                    }

                    if (lossless) {
                        xoff_threshold = obm_settings_a1[obm_setting_idx].
                            xoff_threshold[oversub_ratio_idx];
                        xon_threshold = xoff_threshold - xon_threshold_offset;
                        mtu_cells = obm_settings_a1[obm_setting_idx].
                            mtu_cells[oversub_ratio_idx];
                    } else {
                        xoff_threshold = 1020;
                        xon_threshold = 1020;
                        mtu_cells = 9 * 1024 / _TD2_BYTES_PER_OBM_CELL;
                    }
                    if (count > 1 &&
                        quad_oversub_bandwidth > quad_oversub_core_bandwidth) {
                        /*
                         * packet_completion_reserved cells =
                         *  (num_ports - 1) * mtu * (1 - 1 / oversub_ratio) + 4
                         */
                        res_cells = (count - 1) * mtu_cells *
                            (quad_oversub_bandwidth -
                             quad_oversub_core_bandwidth) /
                            quad_oversub_bandwidth  + 4;
                    } else {
                        res_cells = 4;
                    }
                    /*
                     * port_cells =
                     *  (1020 - packet_completion_reserved_cells) / num_ports
                     */
                    port_cells = (_TD2_TD2_CELLS_PER_OBM - res_cells) / count;

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MIN_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          LOW_PRI_THRESHOLDf, 0);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MAX_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XONf, xon_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XOFFf, xoff_threshold);
                    if (!SOC_IS_TD2P_TT2P(unit)) {
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          CUT_THROUGH_OKf, 2);
                    }
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }
            } else {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TD2P_TT2P(unit)) {
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                        port = si->port_p2l_mapping[phy_port];
                        if (port == -1) {
                            continue;
                        }
                        SOC_IF_ERROR_RETURN
                             (soc_td2p_obm_cut_through_threshold_set(unit,
                                                     xlp, index,
                                                     obm_inst,
                                                     PGW_OBM_INIT_SW_DEFAULT));
                    }
                }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
                /* Maintaining of Priority to Priority_group mapping requires
                 * sufficient Memory for OAM, Hence calling the
                 * soc_property_port_get_csv function where necessary.
                 */
                reg = td2_pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    pri_mask = 0xffff;
                    if (lossless && 
                        soc_feature(unit, soc_feature_prigrp_to_obm_prio_map)) {
                        SOC_IF_ERROR_RETURN
                            (soc_trident2_get_prio_map(
                                              unit, 
                                              si->port_p2l_mapping[phy_port],
                                              &pri_mask));
                    }
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PCP_MAPf, lossless ? pri_mask : 0);
                   
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                SOC_IF_ERROR_RETURN
                    (soc_td2_obm_shared_config_reg_default_set(unit, xlp,
                                        index, obm_inst, PGW_OBM_INIT_SW_DEFAULT));

                reg = td2_pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
                    if (SOC_IS_TD2P_TT2P(unit)) {
                         soc_td2p_set_obm_registers (unit, reg, 
                                       si->port_speed_max[port], index, 
                                       obm_inst, lossless,
                                       PGW_OBM_INIT_SW_DEFAULT);
                       
                        SOC_IF_ERROR_RETURN
                            (soc_td2p_obm_prob_drop_default_set (unit, xlp, 
                                                         index, obm_inst,
                                                         PGW_OBM_INIT_SW_DEFAULT));
                    } else
#endif
                    {
                        if (si->port_speed_max[port] > 20000) {
                            obm_setting_idx = 2; /* entry 2 in the lookup table */
                            xon_threshold_offset = 24; /* xon = xoff - 24 */
                        } else if (si->port_speed_max[port] > 10000) {
                            obm_setting_idx = 1; /* entry 1 in the lookup table */
                            xon_threshold_offset = 12; /* xon = xoff - 12 */
                        } else {
                            obm_setting_idx = 0; /* entry 0 in the lookup table */
                            xon_threshold_offset = 6; /* xon = xoff - 6 */
                        }
                        if (lossless) {
                            if (quad_oversub_bandwidth * 2 >
                                quad_oversub_core_bandwidth * 3) {
                                /* oversub ratio greater than 1.5 (3/2) */
                                oversub_ratio_idx = 2;
                            } else if (quad_oversub_bandwidth * 3 >
                                quad_oversub_core_bandwidth * 4) {
                                /* oversub ratio greater than 1.33 (4/3) */
                                oversub_ratio_idx = 1;
                            } else {
                                oversub_ratio_idx = 0;
                            }

                            xoff_threshold = obm_settings[obm_setting_idx].
                                xoff_threshold[oversub_ratio_idx];
                            xon_threshold = xoff_threshold - xon_threshold_offset;
                            min_threshold = xon_threshold + 3;
                        } else {
                            xoff_threshold = 1023;
                            xon_threshold = 1023;
                            min_threshold = obm_settings[obm_setting_idx].
                                max_threshold;
                        }

                        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                        &ctrl_rval64));
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              MIN_THRESHOLDf, min_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              LOW_PRI_THRESHOLDf, 0);
                        soc_reg64_field32_set
                            (unit, reg, &ctrl_rval64, MAX_THRESHOLDf,
                             obm_settings[obm_setting_idx].max_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              FLOW_CTRL_XONf, xon_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              FLOW_CTRL_XOFFf, xoff_threshold);
                        soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                              CUT_THROUGH_OKf, 2);
                        SOC_IF_ERROR_RETURN
                            (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                    }
                }

                if (!lossless) {
                    continue;
                }
                /* The configuration of OBM is configured in sync with the MMU.
                 * if spn_MMU_LOSSLESS is NOT configured, then all the priority
                 * groups are Lossy (Flow Control is disabled).
                 * if spn_MMU_LOSSLESS is SET (1), then the priorities which are
                 * mapped to Priority Group - 7 will have flow control enabled.
                 */
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }
                    SOC_IF_ERROR_RETURN
                        (soc_td2_obm_fc_config_reg_default_set(unit, xlp,
                            index, obm_inst, si->port_p2l_mapping[phy_port],
                            count, PGW_OBM_INIT_SW_DEFAULT));
                }
            }
        }
    }

    /* Configure MMU TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        reg = mmu_tdm_regs[pipe];
        mem = mmu_tdm_mems[pipe];
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        wt_group_select = 0;
#endif

        length = _MMU_TDM_LENGTH;
        for (slot = _MMU_TDM_LENGTH - 1; slot >= 0; slot--) {
            if (td2_tdm->mmu_tdm[pipe][slot] != NUM_EXT_PORTS) {
                length = slot + 1;
                break;
            }
        }
        
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < length; slot += 2) {
            phy_port = td2_tdm->mmu_tdm[pipe][slot];
            if (phy_port == GET_OVS_TOKEN(unit)) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == GET_IDL_TOKEN(unit)) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_EVENf,
                                mmu_port & 0x3f);

            phy_port = td2_tdm->mmu_tdm[pipe][slot + 1];
            if (phy_port == GET_OVS_TOKEN(unit)) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == GET_IDL_TOKEN(unit)) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_ODDf,
                                mmu_port & 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        }

        soc_reg_field_set(unit, reg, &rval, CAL0_ENDf, slot / 2);
        if (length & 1) {
            soc_reg_field_set(unit, reg, &rval, CAL0_END_SINGLEf, 1);
        }

        if (SOC_IS_TD2P_TT2P(unit)) {
            /* 
             *  Control strict priority scheduling between CPU/Loopback port
             *  and Oversub port. 
             *  Setting - Oversub has highest priority
             */
            soc_reg_field_set(unit, reg, &rval, OPP_STRICT_PRIf, 1);
            soc_reg_field_set(unit, reg, &rval, OPP_PORT_ENf, 1);
        }
        soc_reg_field_set(unit, reg, &rval, OPP_CPULB_ENf, 1);
        soc_reg_field_set(unit, reg, &rval, ENABLEf, 1);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

        if (si->frequency < 760) {
            reg = mmu_ovs_group_cfg_regs[pipe];
            for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
                phy_port = td2_tdm->mmu_ovs_group_tdm[pipe][group][0];
                if (phy_port >= NUM_EXT_PORTS) {
                    continue;
                }
                port = si->port_p2l_mapping[phy_port];
                if (si->port_speed_max[port] < 30000) {
                    continue;
                }
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, REG_PORT_ANY, group, &rval));
                soc_reg_field_set(unit, reg, &rval, SAME_SPACINGf,
                                  si->frequency < 500 ? 6 : 8);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, group, rval));
            }
        }

        /* There are 8 oversub groups in TD2+ but we support 4 speeds only
         * there is ES_PIPE0_GRP_WT_SELECT register that will select
         * which queue belong to which group. By default 
         */

        for (group = 0; group < GET_MMU_OVS_GCOUNT(unit); group++) {
            reg = mmu_ovs_group_regs[pipe][group];
            rval = 0;
            for (slot = 0; slot < _MMU_OVS_GROUP_TDM_LENGTH; slot++) {
                phy_port = td2_tdm->mmu_ovs_group_tdm[pipe][group][slot];
                if (phy_port >= NUM_EXT_PORTS) {
                    mmu_port = 0x3f;
                    id = 0;
                } else {
                    mmu_port = si->port_p2m_mapping[phy_port];
                    id = si->port_serdes[si->port_p2l_mapping[phy_port]];
                }
                if (!SOC_IS_TD2P_TT2P(unit)) {
                    soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf, id & 0xf);
                }
                soc_reg_field_set(unit, reg, &rval, MMU_PORTf,
                                  mmu_port & 0x3f);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, slot, rval));
            }
            rval = 0;
            phy_port = td2_tdm->mmu_ovs_group_tdm[pipe][group][0];
            if (phy_port >= NUM_EXT_PORTS) {
                weight = 0;
                wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
            } else {
                int speed;

                port = si->port_p2l_mapping[phy_port];
                speed = soc_property_port_get(unit, port, spn_PORT_INIT_SPEED,
                                              si->port_speed_max[port]);
                if (SOC_IS_TD2P_TT2P(unit)) {
                    if ( speed <= 11000 ) {
                        wt_group = td2p_ovs_wt_group_speed_10G;
                    } else if ( speed <= 21000 ) {
                        wt_group = td2p_ovs_wt_group_speed_20G;
                    } else if ( speed <= 42000 ) {
                        wt_group = td2p_ovs_wt_group_speed_40G;
                    } else {
                        wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
                    }
                }
                /* use 2500M as weight unit */
                weight = (speed > 2500 ? speed : 2500) / 2500;
            }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
            /* TD2P supports 4 oversub speeds only 10/20 and 40*/
            if (SOC_IS_TD2P_TT2P(unit)) {
                wt_group_select |= (wt_group << (group * 2));
            } else
#endif
            {
                wt_group = group;
            }

            reg = mmu_ovs_group_wt_regs[pipe][wt_group];

            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
        }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, mmu_ovs_group_wt_select_regs [pipe], 
                               REG_PORT_ANY, 0, wt_group_select));
        }
#endif
    }

    /* Configure IARB TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        mem = iarb_tdm_mems[pipe];
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < _IARB_TDM_LENGTH; slot++) {
            if (slot > td2_tdm->iarb_tdm_wrap_ptr[pipe]) {
                break;
            }
            soc_mem_field32_set(unit, mem, entry, TDM_SLOTf,
                                td2_tdm->iarb_tdm[pipe][slot]);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot, entry));
        }
    }
    /* Both pipe are expected to have same IARB TDM table length */
    fields[0] = TDM_WRAP_PTRf;
    values[0] = td2_tdm->iarb_tdm_wrap_ptr[0];
    fields[1] = DISABLEf;
    values[1] = 0;
    fields[2] = AUX_CMICM_SLOT_ENf;
    values[2] = 1;
    fields[3] = AUX_EP_LB_SLOT_ENf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit)) {
        /* Configure oversubscription port with WAIT_FOR_2ND_MOP */
        SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
        SOC_PBMP_AND(pbmp, si->oversub_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            SOC_IF_ERROR_RETURN(soc_td2p_egr_edb_xmit_ctrl_set(
                                    unit, phy_port, si->port_speed_max[port],
                                    1 /*oversub*/, 0));
        }

        /* Configure linerate port with WAIT_FOR_MOP */
        SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
        SOC_PBMP_XOR(pbmp, si->oversub_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            SOC_IF_ERROR_RETURN(soc_td2p_egr_edb_xmit_ctrl_set(
                                    unit, phy_port, si->port_speed_max[port],
                                    0 /*oversub*/, 0));
        }
    } else
#endif
    {
        /* Configure oversubscription port with WAIT_FOR_2ND_MOP */
        sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_2ND_MOPf, 1);
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
                _TD2_MMU_XMIT_START_CNT_OVERSUB);
        SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
        SOC_PBMP_AND(pbmp, si->oversub_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                              MEM_BLOCK_ALL, phy_port, &entry));
        }

        /* Configure linerate port with WAIT_FOR_MOP */
        sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_MOPf, 1);
        SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
        SOC_PBMP_XOR(pbmp, si->oversub_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
                    _TD2_MMU_XMIT_START_CNT_LINERATE(si->port_speed_max[port]));
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                              MEM_BLOCK_ALL, phy_port, &entry));
        }
    }

    rval = 0;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        soc_reg_field_set(unit, ENQ_CONFIGr, &rval,
                      ASF_ENABLE_HS_PORT_EP_CREDIT_CHKf, 0);
    }
#endif
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_CFAP_FULL_DROP_ENf, 1);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_FIFO_THRESHOLDf, _TD2_MMU_ASF_FIFO_THRESHOLD);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_HS_FIFO_THRESHOLDf, _TD2_MMU_ASF_HS_FIFO_THRESHOLD);
    SOC_IF_ERROR_RETURN(WRITE_ENQ_CONFIGr(unit, rval));

    /*
     * bcmsim: C model cannot support cell based flow
     */
    if (SAL_BOOT_BCMSIM) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 
                                    DISABLEf, 1));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_hash_init(int unit)
{
    soc_field_t fields[4];
    uint32 values[4];

    /* L2 dedicated banks */
    fields[0] = BANK0_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK1_HASH_OFFSETf;
    values[1] = 16; /* CRC32_UPPER */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_TABLE_HASH_CONTROLr, REG_PORT_ANY, 2,
                                 fields, values));

    /* L3 dedicated banks */
    fields[0] = BANK6_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK7_HASH_OFFSETf;
    values[1] = 12; /* CRC32 >> 12 */
    fields[2] = BANK8_HASH_OFFSETf;
    values[2] = 24; /* CRC16_LOWER << 8 | CRC32 >> 24 */
    fields[3] = BANK9_HASH_OFFSETf;
    values[3] = 36; /* CRC16 >> 4 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_TABLE_HASH_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    /* L2/L3/ALPM shared banks */
    fields[0] = BANK2_HASH_OFFSETf;
    values[0] = 4;  /* CRC32 >> 4 */
    fields[1] = BANK3_HASH_OFFSETf;
    values[1] = 12; /* CRC32 >> 12 */
    fields[2] = BANK4_HASH_OFFSETf;
    values[2] = 20; /* CRC32 >> 20 */
    fields[3] = BANK5_HASH_OFFSETf;
    values[3] = 24; /* CRC32 >> 24 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, SHARED_TABLE_HASH_CONTROLr,
                                 REG_PORT_ANY, 4, fields, values));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    /* Robust Hash initialization */
    if (SOC_IS_TD2P_TT2P(unit)) {
        uint32 value, seed = 0;

        if (NULL == ROBUSTHASH(unit)) {
            ROBUSTHASH(unit) = sal_alloc(sizeof(soc_robust_hash_db_t),
                                         "soc_robust_hash");
            if (ROBUSTHASH(unit) == NULL) {
                return SOC_E_MEMORY;
            }
            sal_memset(ROBUSTHASH(unit), 0, sizeof(soc_robust_hash_db_t));
        }
 
        /* Enable Robust hashing for ING_VP_VLAN_MEMBERSHIP table and configure 
         * corresponding remap and action tables.
         */
          
        if ((soc_property_get(unit, "robust_hash_disable_ing_vp_vlan", 0)) == 1)
        {
            /* Disable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr, 
                              &value, ROBUST_HASH_ENABLEf, 0x0);
            SOC_IF_ERROR_RETURN
                (WRITE_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));

            ROBUSTHASH(unit)->ing_vp_vlan_member.enable = 0;
        } else {
            /* Enable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr,
                              &value, ROBUST_HASH_ENABLEf, 0x1);
            SOC_IF_ERROR_RETURN
                (WRITE_ING_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));
            ROBUSTHASH(unit)->ing_vp_vlan_member.enable = 1;

            /* Fill action and remap tables with random data */
            ROBUSTHASH(unit)->ing_vp_vlan_member.remap_tab[0] = 
                                              ING_VP_VLAN_MEMBERSHIP_REMAP_Am;
            ROBUSTHASH(unit)->ing_vp_vlan_member.remap_tab[1] = 
                                              ING_VP_VLAN_MEMBERSHIP_REMAP_Bm;
            ROBUSTHASH(unit)->ing_vp_vlan_member.action_tab[0] = 
                                              ING_VP_VLAN_MEMBERSHIP_ACTION_Am;
            ROBUSTHASH(unit)->ing_vp_vlan_member.action_tab[1] = 
                                              ING_VP_VLAN_MEMBERSHIP_ACTION_Bm;

            seed = soc_property_get(unit, 
                                    spn_ROBUST_HASH_SEED_INGRESS_VP_VLAN, 
                                    16777213);

            SOC_IF_ERROR_RETURN
                (soc_robust_hash_table_set(unit,
                                        &(ROBUSTHASH(unit)->ing_vp_vlan_member),
                                        seed));
        }
 
        /* Enable Robust hashing for EGR_VP_VLAN_MEMBERSHIP table and configure 
         * corresponding remap and action tables.
         */
          
        if ((soc_property_get(unit, "robust_hash_disable_egr_vp_vlan", 0)) == 1)
        {
            /* Disable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr, 
                              &value, ROBUST_HASH_ENABLEf, 0x0);
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));

            ROBUSTHASH(unit)->egr_vp_vlan_member.enable = 0;
        } else {
            /* Enable robust hashing */
            SOC_IF_ERROR_RETURN
                (READ_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, &value));
            soc_reg_field_set(unit, EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr,
                              &value, ROBUST_HASH_ENABLEf, 0x1);
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_VP_VLAN_MEMBERSHIP_HASH_CONTROLr(unit, value));
            ROBUSTHASH(unit)->egr_vp_vlan_member.enable = 1;

            /* Fill action and remap tables with random data */
            ROBUSTHASH(unit)->egr_vp_vlan_member.remap_tab[0] = 
                                              EGR_VP_VLAN_MEMBERSHIP_REMAP_Am;
            ROBUSTHASH(unit)->egr_vp_vlan_member.remap_tab[1] = 
                                              EGR_VP_VLAN_MEMBERSHIP_REMAP_Bm;
            ROBUSTHASH(unit)->egr_vp_vlan_member.action_tab[0] = 
                                              EGR_VP_VLAN_MEMBERSHIP_ACTION_Am;
            ROBUSTHASH(unit)->egr_vp_vlan_member.action_tab[1] = 
                                              EGR_VP_VLAN_MEMBERSHIP_ACTION_Bm;

            seed = soc_property_get(unit, 
                                    spn_ROBUST_HASH_SEED_EGRESS_VP_VLAN, 
                                    16777213);

            SOC_IF_ERROR_RETURN
                (soc_robust_hash_table_set(unit,
                                        &(ROBUSTHASH(unit)->egr_vp_vlan_member),
                                        seed));
        }
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    return SOC_E_NONE;
}

STATIC int
_soc_td2_ledup_init(int unit)
{
    uint32 rval = 0, ix, reg_val = 0;
    int port_delay, start_delay[2];
    soc_info_t *si;
    int port = 0, blk, lport = 0;
    int x_data_ram_loc = 0;
    int y_data_ram_loc = 0;
    int *data_ram_loc = NULL;
    int phy_port, index;
    soc_reg_t   remap_reg;
    soc_field_t remap_field;

    soc_reg_t remap_led0_regs[] = {
        CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r,
        CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r
    };

    soc_reg_t remap_led1_regs[] = {
        CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r,
        CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r
    };

    soc_field_t remap_fields[] = {
        REMAP_PORT_63f, REMAP_PORT_62f, REMAP_PORT_61f, REMAP_PORT_60f,
        REMAP_PORT_59f, REMAP_PORT_58f, REMAP_PORT_57f, REMAP_PORT_56f,
        REMAP_PORT_55f, REMAP_PORT_54f, REMAP_PORT_53f, REMAP_PORT_52f,
        REMAP_PORT_51f, REMAP_PORT_50f, REMAP_PORT_49f, REMAP_PORT_48f,
        REMAP_PORT_47f, REMAP_PORT_46f, REMAP_PORT_45f, REMAP_PORT_44f,
        REMAP_PORT_43f, REMAP_PORT_42f, REMAP_PORT_41f, REMAP_PORT_40f,
        REMAP_PORT_39f, REMAP_PORT_38f, REMAP_PORT_37f, REMAP_PORT_36f,
        REMAP_PORT_35f, REMAP_PORT_34f, REMAP_PORT_33f, REMAP_PORT_32f,
        REMAP_PORT_31f, REMAP_PORT_30f, REMAP_PORT_29f, REMAP_PORT_28f,
        REMAP_PORT_27f, REMAP_PORT_26f, REMAP_PORT_25f, REMAP_PORT_24f,
        REMAP_PORT_23f, REMAP_PORT_22f, REMAP_PORT_21f, REMAP_PORT_20f,
        REMAP_PORT_19f, REMAP_PORT_18f, REMAP_PORT_17f, REMAP_PORT_16f,
        REMAP_PORT_15f, REMAP_PORT_14f, REMAP_PORT_13f, REMAP_PORT_12f,
        REMAP_PORT_11f, REMAP_PORT_10f, REMAP_PORT_9f, REMAP_PORT_8f,
        REMAP_PORT_7f, REMAP_PORT_6f, REMAP_PORT_5f, REMAP_PORT_4f,
        REMAP_PORT_3f, REMAP_PORT_2f, REMAP_PORT_1f, REMAP_PORT_0f
    };

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    uint64 led_chain_delay;
    uint64 led_chain_delay1;
#endif

    si = &SOC_INFO(unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        start_delay[0] = 19;
        start_delay[1] = 34;
        port_delay = 4;
    } else
#endif
    {
        start_delay[0] = 14;
        start_delay[1] = 24;
        port_delay = 1;
    }
    /* configure the LED scan delay cycles */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP0_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval,
                        LEDUP_SCAN_START_DELAYf, start_delay[0]);
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval,
                        LEDUP_SCAN_INTRA_PORT_DELAYf, port_delay);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_CTRLr(unit, rval));

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP1_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval,
                        LEDUP_SCAN_START_DELAYf, start_delay[1]);
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval,
                        LEDUP_SCAN_INTRA_PORT_DELAYf, port_delay);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_CTRLr(unit, rval));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {

        /* Program the PGW_LED_CHAIN_OUT_CONFIG irrespective of the
           pgw block being enabled. even pgw like pgw.cl0 are set
           to delay of 4 and odd pgw i.e pgw.cl1 are set to delay value
           of 1 */
        COMPILER_64_SET(led_chain_delay, 0, 0x4);
        COMPILER_64_SET(led_chain_delay1, 0, 0x1);
        _soc_reg64_set(unit, 6, 0, (0x2006300), led_chain_delay);
        _soc_reg64_set(unit, 7, 0, (0x2006300), led_chain_delay1);
        _soc_reg64_set(unit, 8, 0, (0x2006300), led_chain_delay);
        _soc_reg64_set(unit, 9, 0, (0x2006300), led_chain_delay1);
        _soc_reg64_set(unit, 10, 0, (0x2006300), led_chain_delay);
        _soc_reg64_set(unit, 11, 0, (0x2006300), led_chain_delay1);
        _soc_reg64_set(unit, 12, 0, (0x2006300), led_chain_delay);
        _soc_reg64_set(unit, 13, 0, (0x2006300), led_chain_delay1);

        rval = 0xffffff;
        /* Initialize LED Port remap registers */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));
    
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));
    }else
#endif 
    {
        x_data_ram_loc = 1;
        y_data_ram_loc = 1;
    }

    for (phy_port = 1; phy_port <= TRIDENT2_PHY_PORT_MAX; phy_port++) {
        lport = si->port_p2l_mapping[phy_port];
        if (lport == -1) {
            continue;
        }

        index = phy_port;
        index--;

        if ((index % 32) / 16) {
            /* Handle the mapping in the odd-numbered PGWs */
            if (si->port_num_lanes[lport] >= 10) {
                index -= 4;
            } else if (index % 16 < 4) {
                index += 12;
            } else if (index % 16 < 8) {
                index += 4;
            } else if (index % 16 < 12) {
                index -= 4;
            } else {
                index -= 12;
            }
        }

        if (index >= 64) {
            index = index - 64;
            /* coverity[overrun-local] */
            remap_reg = remap_led1_regs[index / 4];
            remap_field = remap_fields[index];
            data_ram_loc = &y_data_ram_loc;
        } else {
            remap_reg = remap_led0_regs[index / 4];
            remap_field = remap_fields[index];
            data_ram_loc = &x_data_ram_loc;
        }

        SOC_IF_ERROR_RETURN(soc_pci_getreg(unit, soc_reg_addr(unit, remap_reg,
                                 REG_PORT_ANY, 0), &rval));
        soc_reg_field_set(unit, remap_reg, &rval, remap_field, *data_ram_loc);
        SOC_IF_ERROR_RETURN(soc_pci_write(unit, soc_reg_addr(unit, remap_reg,                                            REG_PORT_ANY, 0), rval));

        (*data_ram_loc)++;
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
           reg_val = 0x00000005;
    } else 
#endif
    {
           reg_val = 0x00000002;
    }

    if ( SAL_BOOT_QUICKTURN ) {
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            if (port == -1) {
                continue;
            }
            
            #if 0
            if (SOC_USE_PORTCTRL(unit)) {
                SOC_IF_ERROR_RETURN
                    (soc_portctrl_led_chain_config(unit, port, 0x00000002));
            } else
            #endif
            {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, XLPORT_LED_CHAIN_CONFIGr,
                                   port, 0, reg_val));
            }
        }
    } else {
 
        /* Raw SCHAN ops due to missing blocks */
        _soc_reg32_set(unit, 15, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 16, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 17, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 18, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 20, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 21, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 22, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 23, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 25, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 26, 0, (0x2021700), reg_val);

        _soc_reg32_set(unit, 27, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 28, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 30, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 31, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 32, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 33, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 35, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 36, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 37, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 38, 0, (0x2021700), reg_val);

        _soc_reg32_set(unit, 40, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 41, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 42, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 43, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 45, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 46, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 47, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 48, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 50, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 51, 0, (0x2021700), reg_val);

        _soc_reg32_set(unit, 52, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 53, 0, (0x2021700), reg_val);
        _soc_reg32_set(unit, 55, 0, (0x2021700), reg_val);
        
        /* Setting the CPORT_LED_CHAIN_CONFIG register*/
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            _soc_reg32_set(unit, 14, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 19, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 24, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 29, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 34, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 39, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 44, 0, (0x2021100), reg_val);
            _soc_reg32_set(unit, 49, 0, (0x2021100), reg_val);
        }
#endif
    }
    /* initialize the UP0, UP1 data ram */
    rval = 0;
    for (ix = 0; ix < 256; ix++) {
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit,ix, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit,ix, rval));
    }

    return SOC_E_NONE;
}


extern int (*_phy_tscmod_firmware_set_helper[SOC_MAX_NUM_DEVICES])
            (int, int, uint8 *, int);
STATIC int
_soc_trident2_tsc_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    /* TSC firmware set is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }

    return soc_warpcore_firmware_set(unit, port, array, datalen, 0,
                                     XLPORT_WC_UCMEM_DATAm,
                                     XLPORT_WC_UCMEM_CTRLr);
}

#if defined(SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_trident2_test_fun;
#endif

STATIC int
_soc_trident2_egr_buf_reset(int unit, int port, int reset)
{
    uint32 entry[SOC_MAX_MEM_WORDS];

    SOC_IF_ERROR_RETURN(
        READ_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                                            port, entry));
    soc_mem_field32_set(unit, EGR_PER_PORT_BUFFER_SFT_RESETm,
                        entry, ENABLEf, reset);
    SOC_IF_ERROR_RETURN(
        WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                                             port, entry));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_cport_reset(int unit, int port, int reset)
{
    uint32 rval = 0;

    if (reset == 1) {
        SOC_IF_ERROR_RETURN(READ_CPORT_SOFT_RESETr(unit, port, &rval));
        soc_reg_field_set(unit, CPORT_SOFT_RESETr, &rval,
                          CPORT_COREf, 1);
        SOC_IF_ERROR_RETURN(WRITE_CPORT_SOFT_RESETr(unit, port, rval));

        SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 1));
    } else {
        SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 0));

        SOC_IF_ERROR_RETURN(READ_CPORT_SOFT_RESETr(unit, port, &rval));
        soc_reg_field_set(unit, CPORT_SOFT_RESETr, &rval,
                          CPORT_COREf, 0);
        SOC_IF_ERROR_RETURN(WRITE_CPORT_SOFT_RESETr(unit, port, rval));
    }

    return SOC_E_NONE;
}


STATIC int
_soc_portctrl_trident2_port_init(int unit)
{
    soc_info_t *si;
    int port;
    int blk;

    si = &SOC_INFO(unit);

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }

        /* If this is a 100G port, reset egress port buffer */
        if (si->port_speed_max[port] >= 100000) {
            SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 1));

            soc_trident2_port_speed_update(unit, port, si->port_speed_max[port]);

            SOC_IF_ERROR_RETURN(_soc_trident2_egr_buf_reset(unit, port, 0));
        }
    }

    /* Cut through settings for all ports */
    PBMP_ALL_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_td2_port_asf_set(unit, port, si->port_speed_max[port]));
    }

    return SOC_E_NONE;
}


STATIC int
_soc_trident2_port_init(int unit)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f
    };
    soc_info_t *si;
    uint32 rval = 0;
    int port;
    int subport0, subport2, phy_port_base;
    int blk, bindex, mode;

    si = &SOC_INFO(unit);

    if (SOC_USE_PORTCTRL(unit)) {
        return _soc_portctrl_trident2_port_init(unit);
    }

    PBMP_PORT_ITER(unit, port) {
        if ( IS_C_PORT(unit, port) &&
             (SOC_REG_IS_VALID(unit, CPORT_CONFIGr))) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, CPORT_SPARE0_REGr, port, RSVDf, 0));

            if (!IS_HG_PORT(unit, port)) {
                continue;
            }
            SOC_IF_ERROR_RETURN(READ_CPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, CPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_CPORT_CONFIGr(unit, port, rval));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, XLPORT_SPARE0_REGr, port, RSVDf, 0));

            if (!IS_HG_PORT(unit, port)) {
                continue;
            }
            SOC_IF_ERROR_RETURN(READ_XLPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, XLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_XLPORT_CONFIGr(unit, port, rval));
        }
    }

    /* Enable 100G /Cports */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }
        /* If this is a 100G port, enable the CPORT */
        if (si->port_speed_max[port] >= 100000) {
            SOC_IF_ERROR_RETURN(_soc_trident2_cport_reset(unit, port, 1));

            SOC_IF_ERROR_RETURN(READ_CPORT_ENABLE_REGr(unit, port, &rval));
            soc_reg_field_set(unit, CPORT_ENABLE_REGr, &rval, PORT0f, 1);
            SOC_IF_ERROR_RETURN(WRITE_CPORT_ENABLE_REGr(unit, port, rval));

            soc_trident2_port_speed_update(unit, port, si->port_speed_max[port]);

            /* take cport out of reset after enable */
            SOC_IF_ERROR_RETURN(_soc_trident2_cport_reset(unit, port, 0));
        }

    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }
        phy_port_base = ((si->port_l2p_mapping[port] - 1) & ~0x3) + 1;

        /* Assert XLPORT soft reset */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_SOFT_RESETr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, rval));

        if ((si->port_speed_max[port] > 21000) ||
             (SOC_IS_TITAN2PLUS(unit) &&
              ((si->port_speed_max[port] == 13000) ||
              (si->port_speed_max[port] == 16000)))) {
            mode = SOC_TD2_PORT_MODE_SINGLE;
        } else {
            subport0 = si->port_p2l_mapping[phy_port_base];
            subport2 = si->port_p2l_mapping[phy_port_base + 2];
            if (subport0 >= 0 && si->port_speed_max[subport0] > 11000) {
                if (subport2 < 0 || si->port_speed_max[subport2] <= 11000) {
                    mode = SOC_TD2_PORT_MODE_TRI_023;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else if (subport2 >= 0 && si->port_speed_max[subport2] > 11000) {
                if (subport0 < 0 || si->port_speed_max[subport0] <= 11000) {
                    mode = SOC_TD2_PORT_MODE_TRI_012;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else {
                mode = SOC_TD2_PORT_MODE_QUAD;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_CORE_PORT_MODEf, mode);
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_PHY_PORT_MODEf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

        /* De-assert XLPORT soft reset */
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, 0));

        /* Enable XLPORT */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_ENABLE_REGr(unit, port, rval));
    }

    return SOC_E_NONE;
}

/* Configure HSP port multicast T2OQ setting.
 * Note: Caller must check if the Port is part of HSP port bitmap
 * HSP Port check:  SOC_PBMP_MEMBER(si->eq_pbm, port)
 * */

STATIC int
_soc_trident2_mc_toq_cfg(int unit, int port, int enable)
{
    static soc_field_t t2oq_fields[] = {
        IS_MC_T2OQ_PORT0f, IS_MC_T2OQ_PORT1f
    };
    soc_field_t field;
    uint32 rval, fval;
    int pipe, mmu_port, phy_port;
    soc_reg_t reg = TOQ_MC_CFG1r;
    soc_info_t *si = &SOC_INFO(unit);;

    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;
    field = t2oq_fields[pipe & 0x01];
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    fval = soc_reg_field_get(unit, reg, rval, field);

    if (enable) {
        fval |= 1 << (mmu_port & 0x0f);
    } else {
        fval &= ~(1 << (mmu_port & 0x0f));
    }
    soc_reg_field_set(unit, reg, &rval, field, fval);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_misc_init(int unit)
{
    static int rtag7_field_width[] = { 16, 16, 4, 16, 8, 8, 16, 16 };
    soc_info_t *si;
    uint32 rval = 0;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_pbmp_t pbmp;
    int port;
    int index, count, sub_sel, offset;
    int freq, target_freq, divisor, dividend, delay;
    int parity_enable, cache_fpgm;
    soc_field_t fields[2];
    uint32 values[2];
    uint16 dev_id;
    uint8 rev_id;
    int l2_banks, l3_banks, l2_mode, l3_mode;
    int shared_l2_banks, shared_l3_banks;
    uint32 uft_bank_enable_bitmap;    
    int cam_enable;
    int higig2;
    
    si = &SOC_INFO(unit);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    _mmu_16_mode = get_mmu_mode (unit);
#endif

    /* Stop the mem scan task before all of the parity init takes place */
    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_stop(unit));
    SOC_IF_ERROR_RETURN(soc_generic_sram_mem_scan_stop(unit));

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    if (parity_enable) {
        if ((!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN) &&
            !SOC_WARM_BOOT(unit)) {
            /* Certain mems/regs need to be cleared before enabling SER */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, INVALIDm));
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_all_port_data(unit));
        }

        /* Check the whether the alpm tables use cache to recover*/
        soc_ser_alpm_cache_check(unit);

        /* Enable logging of SER events */
        soc_ser_log_init(unit, NULL, 0);

        SOC_IF_ERROR_RETURN(_soc_trident2_tcam_ser_init(unit));
        SOC_IF_ERROR_RETURN(_soc_trident2_ser_enable_all(unit, TRUE));
#ifdef INCLUDE_MEM_SCAN
        soc_mem_scan_ser_list_register(unit, TRUE,
                                       _soc_td2_tcam_ser_info[unit]);
#endif
        memset(&_td2_ser_functions, 0, sizeof(soc_ser_functions_t));
        _td2_ser_functions._soc_ser_fail_f = &soc_trident2_ser_fail;
        _td2_ser_functions._soc_ser_parity_error_cmicm_intr_f = 
            &soc_trident2_ser_error;
        soc_ser_function_register(unit, &_td2_ser_functions);
#if defined(SER_TR_TEST_SUPPORT)
        /*Initialize chip-specific functions for SER testing*/
        memset(&ser_trident2_test_fun, 0, sizeof(soc_ser_test_functions_t));
        ser_trident2_test_fun.inject_error_f = &soc_td2_ser_inject_error;
        ser_trident2_test_fun.test_mem = &soc_td2_ser_test_mem;
        ser_trident2_test_fun.test = &soc_td2_ser_test;
        ser_trident2_test_fun.parity_control = &_ser_test_parity_control_reg_set;
        ser_trident2_test_fun.injection_support = &soc_td2_ser_error_injection_support;
        soc_ser_test_functions_register(unit, &ser_trident2_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/
    }
    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        if (!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN ||
                            soc_property_get(unit, "sim_clear_all_mem", 0)) {
            SOC_IF_ERROR_RETURN
                (_soc_trident2_clear_all_memory(unit, (parity_enable ? 0 : 1)));
        }
        if (!parity_enable) {
            /* Clear enabled port's regs if not done above */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
        }
    }

    _soc_trident2_port_mapping_init(unit);
    _soc_trident2_tdm_init(unit);

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(multipass_loopback_bitmap_entry_t));
    soc_mem_pbmp_field_set(unit, MULTIPASS_LOOPBACK_BITMAPm, entry, BITMAPf,
                           &PBMP_LB(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, MULTIPASS_LOOPBACK_BITMAPm, MEM_BLOCK_ALL, 0,
                       entry));

    sal_memset(entry, 0, sizeof(isbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ISBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ISBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(esbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ESBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ESBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TRIDENT2PLUS(unit) && soc_feature(unit, soc_feature_fp_based_oam)) {
        sal_memset(entry, 0, sizeof(sgpp_to_pipe_mapping_entry_t));
        soc_mem_pbmp_field_set(unit, SGPP_TO_PIPE_MAPPINGm, entry,
                               PIPE_Y_BITMAPf, &PBMP_YPIPE(unit));
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, SGPP_TO_PIPE_MAPPINGm,
                                          MEM_BLOCK_ALL, 0, entry));
    }
#endif

    sal_memset(entry, 0, sizeof(egr_ing_port_entry_t));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 1);
    PBMP_HG_ITER(unit, port) {
        higig2 = soc_property_port_get(unit, port, spn_HIGIG2_HDR_MODE,
                                       soc_feature(unit,
                                       soc_feature_no_higig_plus) ? 1 : 0)
                                       ? 1 : 0;
        soc_mem_field32_set(unit, EGR_ING_PORTm, entry, HIGIG2f, higig2);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, port, entry));
    }
    higig2 = soc_property_port_get(unit, CMIC_PORT(unit), spn_HIGIG2_HDR_MODE,
                                   soc_feature(unit,
                                   soc_feature_no_higig_plus) ? 1 : 0)
                                   ? 1 : 0;
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, HIGIG2f, higig2);
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index,
                       entry));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 2);
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, HIGIG2f, 0);
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, LB_PORT(unit),
                       entry));

    /* For FP_GLOBAL_MASK_TCAM, we don't have the pbmp's necessary to
     * initialize the cache until now.  This is the time to check for
     * the cache permission of this table.
     */
    cache_fpgm = soc_feature(unit, soc_feature_mem_cache) && 
            soc_property_get(unit, spn_MEM_CACHE_ENABLE, 
                             (SAL_BOOT_RTLSIM || SAL_BOOT_XGSSIM) ? 0 : 1);
    if (soc_property_get(unit, spn_MEM_CHECK_NOCACHE_OVERRIDE, 0)) {
        char mem_name[100];
        char *mptr;

        sal_memset(mem_name, 0, sizeof(mem_name));
        sal_strncpy(mem_name, "mem_nocache_", sal_strlen("mem_nocache_"));
        mptr = &mem_name[sal_strlen(mem_name)];
        sal_strncpy(mptr, SOC_MEM_NAME(unit, FP_GLOBAL_MASK_TCAMm),
                    sizeof(mem_name) - sal_strlen(mem_name) - 1);
        if (soc_property_get(unit, mem_name, 0)) {
            cache_fpgm = 0;
        }
    }

    if (cache_fpgm && (SOC_SWITCH_BYPASS_MODE(unit) != SOC_SWITCH_BYPASS_MODE_L3_AND_FP)) {
        SOC_MEM_INFO(unit, FP_GLOBAL_MASK_TCAMm).flags |=
            SOC_MEM_FLAG_CACHABLE;
        SOC_IF_ERROR_RETURN
            (soc_mem_cache_set(unit, FP_GLOBAL_MASK_TCAMm,
                               MEM_BLOCK_ALL, TRUE));
    }

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Must clear FP_GLOBAL_MASK_TCAM after port to pipe mappings
         * are initialized. */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, FP_GLOBAL_MASK_TCAMm, COPYNO_ALL, TRUE));
    }

    SOC_IF_ERROR_RETURN(_soc_trident2_port_init(unit));

    /* Enable QGPORT in XLPORT3 block (if present) */
    SOC_PBMP_ITER(si->management_pbm, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, CELL_ASM_0_CONTROLr, &rval64,
                              QGPORT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, CELL_ASM_0_CONTROLr, port, 0, rval64));
        break;
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    /* Enable dual hash tables */
    SOC_IF_ERROR_RETURN(_soc_trident2_hash_init(unit));
    if (!soc_feature(unit, soc_feature_enable_lp)) {
        if (!SOC_IS_TRIDENT2PLUS(unit) && !SOC_IS_TITAN2PLUS(unit)) {
            SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, L2_ENTRY_CONTROL_6r, REG_PORT_ANY,
                                            DISABLE_L2_ENTRY_LPf, 3));
        }
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L3_ENTRY_CONTROL_10r, 
                            REG_PORT_ANY, DISABLE_L3_ENTRY_LPf, 0xf));
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r, 
                            REG_PORT_ANY, DISABLE_ISS_MEMORY_LPf, 0xf));
    }

    /* 
     * Disable Low Power mode for shared banks - UFT banks: 2, 3, 4 and 5.
     */
    if (soc_feature(unit, soc_feature_shared_bank_lp_disabled)) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
            ISS_MEMORY_CONTROL_84r, REG_PORT_ANY, DISABLE_ISS_MEMORY_LPf,
            0xf));
    }

    if (soc_mem_index_count(unit, L3_DEFIP_ALPM_RAWm) > 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r, REG_PORT_ANY,
                                    BYPASS_ISS_MEMORY_LPf, 0xf));
    }

    if (SOC_IS_TD2P_TT2P(unit)) {
        soc_cm_get_id_otp(unit, &dev_id, &rev_id);
        switch (dev_id) { 
            default:
                cam_enable = 0xFF;
                break;
        }
        soc_reg32_set(unit, L3_DEFIP_CAM_ENABLEr, REG_PORT_ANY, 0, cam_enable);
    }
#ifdef ALPM_ENABLE
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        int alpm_mode = 0;
        SOC_IF_ERROR_RETURN
            (soc_trident2p_alpm_mode_enable(unit));

        alpm_mode = soc_property_get(unit, spn_L3_ALPM_ENABLE, 0);
        if (alpm_mode && soc_feature(unit, soc_feature_alpm)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r,
                                        REG_PORT_ANY, FORCE_8XORf, 0x1));
        }
    }
#endif
#endif
    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L2Xm, &l2_banks));
    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L3_ENTRY_ONLYm, &l3_banks));
    switch (l2_banks) {
    case 2: l2_mode = 4;
        break;
    case 3: l2_mode = 3;
        break;
    case 4: l2_mode = 2;
        break;
    case 5: l2_mode = 1;
        break;
    case 6: l2_mode = 0;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    switch (l3_banks) {
    case 4: l3_mode = 4;
        break;
    case 5: l3_mode = 1;
        break;
    case 6: l3_mode = 2;
        break;
    case 7: l3_mode = 3;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L2_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l2_mode));
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L3_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l3_mode));

    if (soc_property_get(unit, spn_LOW_POWER, 0) && 
        soc_mem_index_max(unit, L3_DEFIP_ALPM_RAWm) == -1 ) {
        shared_l2_banks = l2_banks - 2;
        shared_l3_banks = l3_banks - 4;
        uft_bank_enable_bitmap = ((0x70 >> shared_l3_banks)&0xf) | ((1 << shared_l2_banks) - 1);
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, SHARED_TABLE_HASH_CONTROLr, 
                                                   REG_PORT_ANY, UFT_BANK_ENABLEf, 
                                                   uft_bank_enable_bitmap));
    }

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_DEBUGr, &rval, AGE_COUNTf,
                      soc_mem_index_max(unit, L2Xm));
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_DEBUGr(unit, rval));

    rval = 0;
    soc_reg32_get(unit, TOQ_MC_CFG2r, REG_PORT_ANY, 0, &rval);
    soc_reg_field_set(unit, TOQ_MC_CFG2r, &rval, EPRG_KILL_TIMEOUTf, 500);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, TOQ_MC_CFG2r,
                REG_PORT_ANY, 0, rval));

    if (SOC_IS_TRIDENT2(unit)) {
        soc_cm_get_id_otp(unit, &dev_id, &rev_id);
        if (BCM56850_A2_REV_ID == rev_id) {
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, EGR_Q_BEGINr,
                REG_PORT_ANY, QBUSf, 1));
        }
    }

    /*
     * Egress Enable
     */
    if (!SOC_IS_TD2P_TT2P(unit)) {
        int phy_port = 0;
        sal_memset(entry, 0, sizeof(egr_enable_entry_t));
        soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        PBMP_ALL_ITER(unit, port) {
            phy_port = si->port_l2p_mapping[port];
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port, entry));
        }
    } else {
        /* TD2+ EGR_ENABLE should be setup during port up/down sequence
         * Only CPU port EGR_ENABLE should be set here
         */
        const int cpu_port = 0;
        const int loopback_port = si->port_l2p_mapping[LB_PORT(unit)];
        sal_memset(entry, 0, sizeof(egr_enable_entry_t));
        soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, cpu_port, entry));
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, loopback_port, entry));
    }
    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if ((SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TITAN2PLUS(unit))) {

        /* Bypass control settings */
        if (SOC_SWITCH_BYPASS_MODE(unit) != SOC_SWITCH_BYPASS_MODE_NONE) {
            rval = 0;

            /* TD2+ does not support IRSEL1 and IVP bypass stage */
            /*soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IRSEL1_STAGE_BYPASS_ENABLEf, 1); 
            soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IVP_STAGE_BYPASS_ENABLEf, 1);*/

            soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                   IVXLT_STAGE_BYPASS_ENABLEf, 1);

            if (SOC_SWITCH_BYPASS_MODE(unit) == SOC_SWITCH_BYPASS_MODE_L3_AND_FP) {
                soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval,
                                      IFP_STAGE_BYPASS_ENABLEf, 1);
            }

            SOC_IF_ERROR_RETURN(WRITE_ING_BYPASS_CTRLr(unit, rval));

            soc_reg_field_set(unit, EGR_BYPASS_CTRLr, &rval,
                                   EFP_STAGE_BYPASS_ENABLEf, 1);

            SOC_IF_ERROR_RETURN(WRITE_EGR_BYPASS_CTRLr(unit, rval));
        }
    }
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        /* enable all ports */
        ing_dest_port_enable_entry_t ingr_entry;
        modport_map_subport_entry_t map_entry;

        sal_memset(&ingr_entry, 0, sizeof(ingr_entry));
        soc_mem_pbmp_field_set(unit, ING_DEST_PORT_ENABLEm, &ingr_entry, PORT_BITMAPf,
                               &PBMP_ALL(unit));

        SOC_IF_ERROR_RETURN(WRITE_ING_DEST_PORT_ENABLEm(unit, MEM_BLOCK_ALL, 0,
                                                 &ingr_entry));

        sal_memset(&map_entry, 0, sizeof(map_entry));
        soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, ENABLEf, 1);

        /* my_modid and other modid related initialization */
        PBMP_ALL_ITER(unit, port) {
            /* by default port is not trunk */
            /* value already 0
            soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, ISTRUNKf, 0);
            */
            /* configure logical port numbers */
            soc_mem_field32_set(unit, MODPORT_MAP_SUBPORTm, &map_entry, DESTf, port);
            SOC_IF_ERROR_RETURN
                (WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ALL, port, &map_entry));
        }
        /* setting up my_modid */
        SOC_IF_ERROR_RETURN(READ_MY_MODID_SET_2_64r(unit, &rval64));

        soc_reg64_field32_set(unit, MY_MODID_SET_2_64r, &rval64,
                              MODID_0_VALIDf, 1);
        soc_reg64_field32_set(unit, MY_MODID_SET_2_64r, &rval64,
                              MODID_0f, SOC_BASE_MODID(unit));

        SOC_IF_ERROR_RETURN(WRITE_MY_MODID_SET_2_64r(unit, rval64));

    }
#endif

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &rval64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_VALIDATION_ENf, 1);
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    /*
     * If riot is enabled,
     *     MY_STATION1 will be used for tunnels.
     *     MY_STATION2 will be used for routing.
     * Else,
     *     MY_STATION1 should be used for both tunnels and routing.
     *     For this, USE_MY_STATION1_FOR_NON_TUNNELS should be set to TRUE.
     *
     * To avoid executing this code on non-td2plus devices, this code needs to
     * be checked with soc_feature_my_station_2 as well.
     */
    if (soc_feature(unit, soc_feature_my_station_2) &&
        (!soc_feature(unit, soc_feature_riot))) {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                USE_MY_STATION1_FOR_NON_TUNNELSf, 1);
    }
#endif
    if (soc_feature(unit, soc_feature_port_lag_failover)) {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 0);
    } else {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    }
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, rval64));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EGR_CONFIG_1r, REG_PORT_ANY, RING_MODEf,
                                1));

    PBMP_ALL_ITER(unit, port) {
        if (SOC_PBMP_MEMBER(si->eq_pbm, port)) {
            SOC_IF_ERROR_RETURN(_soc_trident2_mc_toq_cfg(unit, port, TRUE));
        }
    }

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
        egr_vlan_control_1_entry_t entry;
        sal_memset(&entry, 0, sizeof(entry));

        soc_mem_field32_set(unit, EGR_VLAN_CONTROL_1m, &entry, VT_MISS_UNTAGf, 0);

        /* Enable pri/cfi remarking on egress ports. */
        soc_mem_field32_set(unit, EGR_VLAN_CONTROL_1m, &entry, REMARK_OUTER_DOT1Pf,
                      1);
        PBMP_ALL_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1m(unit, MEM_BLOCK_ALL, port, &entry));
        }
    } else
#endif
    {
        rval = 0;
        soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

        /* Enable pri/cfi remarking on egress ports. */
        soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
        PBMP_ALL_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
        }
    }

    SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
    SOC_PBMP_REMOVE(pbmp, PBMP_LB(unit));
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                     MEM_BLOCK_ANY, 0, &entry));
    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm, &entry, BITMAPf,
                           &pbmp);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ANY, 0, &entry));

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2)));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_ipmc_to_l2mc_table_size_2_to_3)) {
        /*
         * Trident2+ supports 8K L2MC groups and 16K IPMC groups.
         * When the device is configured as a fabric,
         * L2MC table support both L2MC and IPMC groups.
         * Hence the L2MC table is 24K
         */
        int l2mc_size = (soc_mem_index_count(unit, L2MCm) / 3);
        int ipmc_size = ((soc_mem_index_count(unit, L2MCm) / 3) * 2);
        SOC_IF_ERROR_RETURN
            (soc_hbx_mcast_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L2_RANGE, l2mc_size)));
        SOC_IF_ERROR_RETURN
            (soc_hbx_ipmc_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L3_RANGE, ipmc_size)));
    } else
#endif
    {
        SOC_IF_ERROR_RETURN
            (soc_hbx_mcast_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L2_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));
        SOC_IF_ERROR_RETURN
            (soc_hbx_ipmc_size_set(unit, soc_property_get(unit,
                 spn_MULTICAST_L3_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));
    }

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    values[0] = 1;
    fields[1] = LAG_RES_ENf;
    values[1] = 1;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                SW2_FP_DST_ACTION_CONTROLr, REG_PORT_ANY, 2, fields, values));

    /* Populate and enable RTAG7 Macro flow offset table */
    if (soc_mem_is_valid(unit, RTAG7_FLOW_BASED_HASHm)) {
        count = soc_mem_index_max(unit, RTAG7_FLOW_BASED_HASHm);
        sal_memset(entry, 0, sizeof(rtag7_flow_based_hash_entry_t));
        for (index = 0; index < count; ) {
            for (sub_sel = 0; sub_sel < 8 && index < count; sub_sel++) {
                for (offset = 0;
                     offset < rtag7_field_width[sub_sel] && index < count;
                     offset++) {
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        SUB_SEL_ECMPf, sub_sel);
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        OFFSET_ECMPf, offset);
#if defined(BCM_RIOT_SUPPORT) || defined(BCM_MULTI_LEVEL_ECMP_SUPPORT)
                    if(soc_feature(unit, soc_feature_riot) ||
                       soc_feature(unit, soc_feature_multi_level_ecmp)) {
                        soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                            SUB_SEL_ECMP_LEVEL1f, sub_sel);
                        soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                            OFFSET_ECMP_LEVEL1f, offset);
                    }
#endif
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, RTAG7_FLOW_BASED_HASHm,
                                       MEM_BLOCK_ANY, index, &entry));
                    index++;
                }
            }
        }
        rval = 0;
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, USE_FLOW_SEL_ECMPf, 1);
#if defined(BCM_RIOT_SUPPORT) || defined(BCM_MULTI_LEVEL_ECMP_SUPPORT)
        if(soc_feature(unit, soc_feature_riot) ||
           soc_feature(unit, soc_feature_multi_level_ecmp)) {
            soc_reg_field_set(unit, RTAG7_HASH_SELr,
                &rval, USE_FLOW_SEL_ECMP1f, 1);
        }
#endif
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, 
                                                USE_FLOW_SEL_TRILL_ECMPf, 1);
        SOC_IF_ERROR_RETURN(WRITE_RTAG7_HASH_SELr(unit, rval));
    }

    freq = si->frequency;

    /*
     * Set external MDIO freq to around 6MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    target_freq = 6;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to around 12MHz
     * Valid range is from 2.5MHz to 20MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     * or
     * DIVISOR = core_clock_freq * DIVIDENT / (target_freq * 2)
     */
    target_freq = 12;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_INT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_INT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf,
                       divisor);
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf,
                       dividend);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    if (!SOC_WARM_BOOT(unit)) {
        SOC_IF_ERROR_RETURN(_soc_td2_ledup_init(unit));
    }

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    _phy_tscmod_firmware_set_helper[unit] = _soc_trident2_tsc_firmware_set;

    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
        SOC_IF_ERROR_RETURN(soc_generic_sram_mem_scan_start(unit));
    }

    return SOC_E_NONE;
}


soc_mem_t
_soc_trident2_pmem(int unit, int port, soc_mem_t memx, soc_mem_t memy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? memx : memy;
}

soc_reg_t
_soc_trident2_preg(int unit, int port, soc_reg_t regx, soc_reg_t regy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? regx : regy;
}

uint32 _soc_trident2_mmu_port(int unit, int port)
{
    soc_info_t *si = &SOC_INFO(unit);
    return si->port_p2m_mapping[si->port_l2p_mapping[port]];
}

uint32 _soc_trident2_piped_mem_index(int unit, soc_port_t port,
                                     soc_mem_t mem, int arr_off)
{
    int     mmu_port;

    mmu_port = SOC_TD2_MMU_PORT(unit, port);

    switch (mem) {
    case MMU_THDM_DB_PORTSP_CONFIG_0m:
    case MMU_THDM_DB_PORTSP_CONFIG_1m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_0m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_1m:
        return (mmu_port & 0x3f) + _TD2_MMU_PORTS_PER_PIPE * arr_off;
    case THDI_PORT_SP_CONFIG_Xm:
    case THDI_PORT_SP_CONFIG_Ym:
    case THDI_PORT_SP_CNTRS_RT_Xm:
    case THDI_PORT_SP_CNTRS_RT_Ym:
    case THDI_PORT_SP_CNTRS_SH_Xm:
    case THDI_PORT_SP_CNTRS_SH_Ym:        
    case MMU_THDU_XPIPE_CONFIG_PORTm:
    case MMU_THDU_YPIPE_CONFIG_PORTm:
    case MMU_THDU_XPIPE_RESUME_PORTm:
    case MMU_THDU_YPIPE_RESUME_PORTm:
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_POOL + arr_off;
    case THDI_PORT_PG_CONFIG_Xm:
    case THDI_PORT_PG_CONFIG_Ym: 
    case THDI_PORT_PG_CNTRS_RT1_Xm:
    case THDI_PORT_PG_CNTRS_RT1_Ym:
    case THDI_PORT_PG_CNTRS_RT2_Xm:
    case THDI_PORT_PG_CNTRS_RT2_Ym:
    case THDI_PORT_PG_CNTRS_SH1_Xm:
    case THDI_PORT_PG_CNTRS_SH1_Ym:
    case THDI_PORT_PG_CNTRS_SH2_Xm:
    case THDI_PORT_PG_CNTRS_SH2_Ym:        
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_PG + arr_off;
   default:
        return 0xffffffff;
    }
}

#define _TD2_MMU_BYTES_TO_CELLS(_byte_)  \
    (((_byte_) + _TD2_MMU_BYTES_PER_CELL - 1) / _TD2_MMU_BYTES_PER_CELL)
    
void
_soc_td2_mmu_init_dev_config(int unit, _soc_mmu_device_info_t *devcfg,
                             int lossless)
{
    soc_info_t *si;
    int fifo_entry_count;
    soc_pbmp_t pbmp;
    int port;
    uint16 dev_id;
    uint8 rev_id;
    uint32* dev_mmu_params_arr = NULL;
    
    si = &SOC_INFO(unit);
    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    sal_memset(devcfg, 0, sizeof(_soc_mmu_device_info_t));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        dev_mmu_params_arr = soc_td2p_mmu_params_arr_get(dev_id, rev_id);
    } else 
#endif
    {
        dev_mmu_params_arr = soc_td2_mmu_params_arr_get(dev_id, rev_id);
    }

    if (!dev_mmu_params_arr) {
        return;
    }

    devcfg->max_pkt_byte = dev_mmu_params_arr[_MMU_MAX_PACKET_BYTES];
    devcfg->mmu_hdr_byte = _TD2_MMU_PACKET_HEADER_BYTES;
    devcfg->jumbo_pkt_size = _TD2_MMU_JUMBO_FRAME_BYTES;
    devcfg->default_mtu_size = _TD2_MMU_DEFAULT_MTU_BYTES;
    devcfg->mmu_cell_size = _TD2_MMU_BYTES_PER_CELL;
    /*
     * Reserve 1 cell for each cut-through fifo entry
     * Assume each port use 1 QCN queue, reserve 1 cell for each QCN queue
     * Reserve 10 cells for ingress pool overshoot for lossless setting
     */
    fifo_entry_count = 0;
    SOC_PBMP_ASSIGN(pbmp, si->port.bitmap);
    SOC_PBMP_REMOVE(pbmp, si->all.disabled_bitmap);
    SOC_PBMP_ITER(pbmp, port) {
        fifo_entry_count += si->port_speed_max[port] <= 11000 ? 4 : 16;
    }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if ((FALSE == si->flex_eligible) && soc_td2p_is_any_port_flex_enable(unit)) {
                fifo_entry_count = 0;
            }
        }
#endif
    devcfg->mmu_total_cell = dev_mmu_params_arr[_MMU_TOTAL_CELLS] - fifo_entry_count -
        NUM_PORT(unit) - (lossless ? 10 : 0);
    devcfg->num_pg = _TD2_MMU_NUM_PG;
    devcfg->num_service_pool = _TD2_MMU_NUM_POOL;
    devcfg->flags = SOC_MMU_CFG_F_PORT_MIN | SOC_MMU_CFG_F_PORT_POOL_MIN |
                    SOC_MMU_CFG_F_RQE | SOC_MMU_CFG_F_EGR_MCQ_ENTRY;
    devcfg->total_mcq_entry = _TD2_MMU_TOTAL_MCQ_ENTRY(unit);
    devcfg->total_mcq_entry -= SOC_TD2_MMU_MCQ_RSVD_ENTRY;
    devcfg->rqe_queue_num = 11;
}

int
_soc_td2_default_lossless_pg_headroom(int unit, soc_port_t port)
{
    soc_info_t *si;

    if (IS_CPU_PORT(unit, port)) {
        return 50;
    } else if (IS_LB_PORT(unit, port)) {
        return 162;
    }

    si = &SOC_INFO(unit);
    if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
        if (si->port_speed_max[port] >= 40000) {
            return 461;
        } else if (si->port_speed_max[port] >= 20000) {
            return 262;
        } else {
            return 182;
        }
    } else {
        if (si->port_speed_max[port] >= 100000) {
            return 558;
        } else if (si->port_speed_max[port] >= 40000) {
            return 284;
        } else if (si->port_speed_max[port] >= 20000) {
            return 183;
        } else {
            return 162;
        }
    }

    return 0;
}

int
_soc_td2_min_cell_rsvd_per_mcq(int unit, int port, int default_val)
{
    int freq, speed, osub;
    soc_info_t *si;
    uint8 rev_id;

    soc_cm_get_id_otp(unit, NULL, &rev_id);

    if (rev_id == BCM56850_A1_REV_ID) {
        si = &SOC_INFO(unit);
        speed = si->port_speed_max[port];
        osub = (SOC_PBMP_MEMBER(si->oversub_pbm, port)) ? 1 : 0;

        if (speed <= 10000) {
            return (osub) ? 10 : 5;
        } else if (speed <= 40000) {
            freq = si->frequency;
            return ((freq >= 760) && !osub) ? 9 : 16;
        }
    }

    return default_val;
}

void
_soc_td2_mmu_config_buf_default_global(int unit, _soc_mmu_cfg_buf_t *buf,
                                _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    int max_packet_cells, default_mtu_cells;
    int port, idx, per_q_guarentee;
    int total_pool_size = 0, egr_shared_total = 0;
    int q_reserved = 0, in_reserved = 0;
    int rqe_entry_shared_total;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;
    int asf_rsvd = 0, ing_rsvd = 0, egr_rsvd = 0, mcq_entry_rsvd = 0;

    si = &SOC_INFO(unit);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Initializing default MMU config (u=%d)\n"), unit));
    max_packet_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->max_pkt_byte +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    total_pool_size = devcfg->mmu_total_cell;

    /* Flex port Additional buffer reserve
     * */
    for (idx = 0; idx < NUM_PIPE(unit); idx++) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            /* si->flex_eligible TRUE means that the old legacy ':i' flexport
               is enabled. We should NOT be allocating resources according to
               the new specifications. */
            if (FALSE == si->flex_eligible) {
                /* This checks to see if the new flex port method has been specified
                   in the config file and is being used */
                if(soc_td2p_is_any_port_flex_enable(unit)) {
                    soc_td2p_mmu_additional_buffer_reserve(unit, idx, FALSE,
                            &buf->rsvd_buffers[idx]);
                }
            }
        }
#endif
            asf_rsvd += buf->rsvd_buffers[idx].asf_rsvd_cells;
            egr_rsvd += buf->rsvd_buffers[idx].egr_rsvd_cells;
            ing_rsvd += buf->rsvd_buffers[idx].ing_rsvd_cells;
            mcq_entry_rsvd += buf->rsvd_buffers[idx].mcq_entry_rsvd;
    }

    egr_rsvd_g = egr_rsvd;
    asf_rsvd_g = asf_rsvd;

    if (SOC_IS_TD2P_TT2P(unit)) {
        buf->headroom = _TD2_PIPES_PER_DEV * _TD2P_MMU_GLOBAL_HEADROOM;
    } else {
        buf->headroom = _TD2_PIPES_PER_DEV * max_packet_cells;
    }

    in_reserved += buf->headroom;

    per_q_guarentee = (lossless) ? 0 : default_mtu_cells;

    PBMP_ALL_ITER(unit, port) {
        q_reserved += (si->port_num_cosq[port] + si->port_num_uc_cosq[port]) *
            per_q_guarentee;
    }

    egr_shared_total = total_pool_size - q_reserved - 
                       (asf_rsvd + egr_rsvd);
    
    LOG_VERBOSE(BSL_LS_SOC_MMU,
                (BSL_META_U(unit,
                            "MMU config: Total Shared size: %d\n"),
                            egr_shared_total));

    rqe_entry_shared_total = _TD2_MMU_TOTAL_RQE_ENTRY(unit) -
                             SOC_TD2_MMU_RQE_TOTAL_RSVD_ENTRY - 
                             SOC_TD2_MMU_RQE_USER_RSVD_ENTRY;

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];

        if (idx == 0) {  /* 100% scale up by 100 */
            buf_pool->size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->yellow_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->red_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_mcq_entry = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_rqe_entry = rqe_entry_shared_total;
        } else {
            buf_pool->size = 0;
            buf_pool->yellow_size = 0;
            buf_pool->red_size = 0;
            buf_pool->total_mcq_entry = 0;
            buf_pool->total_rqe_entry = 0;
        }
    }

    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
        queue_grp->guarantee = SOC_TD2_MMU_QGROUP_MIN_RSVD;
        queue_grp->pool_limit = total_pool_size;
        queue_grp->discard_enable = (lossless) ? 0 : 1;
        queue_grp->pool_scale = -1;
        queue_grp->pool_resume = default_mtu_cells * 2;
        queue_grp->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_resume = default_mtu_cells * 2;
        queue_grp->red_resume = default_mtu_cells * 2;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if (!lossless) {
                queue_grp->pool_limit = 0;
                queue_grp->pool_scale = 8;
                queue_grp->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                queue_grp->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            }
        }
#endif
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];
        buf_rqe_queue->pool_idx = 0;
        if (lossless) {
            buf_rqe_queue->discard_enable = 0;
            buf_rqe_queue->pool_scale = -1;
            buf_rqe_queue->pool_limit = egr_shared_total;
            buf_rqe_queue->yellow_limit = egr_shared_total;
            buf_rqe_queue->red_limit = egr_shared_total;
        } else {
            buf_rqe_queue->discard_enable = 1;
            buf_rqe_queue->pool_scale = 8;
            buf_rqe_queue->pool_limit = 0;
            buf_rqe_queue->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            buf_rqe_queue->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        }
        buf_rqe_queue->guarantee = default_mtu_cells;
    }
}

void
_soc_td2_mmu_config_buf_default_port(int unit, int in_port, _soc_mmu_cfg_buf_t *buf,
                                _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    int max_packet_cells, default_mtu_cells;
    int port, idx, per_q_guarentee, mcq_guarentee;
    int total_pool_size = 0, egr_shared_total = 0;
    int q_reserved = 0, in_reserved = 0;
    int min_cell_per_mcq;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    uint32 mmu_port = 0;
#endif

    si = &SOC_INFO(unit);

    min_cell_per_mcq = soc_feature(unit, soc_feature_min_cell_per_queue) ? 1 : 0;
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Initializing default MMU config (u=%d)\n"), unit));
    max_packet_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->max_pkt_byte +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    total_pool_size = devcfg->mmu_total_cell;

    if (SOC_IS_TD2P_TT2P(unit)) {
        buf->headroom = _TD2_PIPES_PER_DEV * _TD2P_MMU_GLOBAL_HEADROOM;
    } else {
        buf->headroom = _TD2_PIPES_PER_DEV * max_packet_cells;
    }

    in_reserved += buf->headroom;

    per_q_guarentee = (lossless) ? 0 : default_mtu_cells;

    PBMP_ALL_ITER(unit, port) {
        q_reserved += si->port_num_uc_cosq[port] * per_q_guarentee;

        mcq_guarentee = min_cell_per_mcq ?
            _soc_td2_min_cell_rsvd_per_mcq(unit, port, per_q_guarentee) :
            per_q_guarentee;
        q_reserved += si->port_num_cosq[port] * mcq_guarentee;
    }
    q_reserved += devcfg->rqe_queue_num * 8;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        if ((FALSE == si->flex_eligible) && soc_td2p_is_any_port_flex_enable(unit)) {
            /* Legacy flex port (:i) is not enabled */
            /* additional per port macro buffers reserved */
            egr_shared_total = total_pool_size - q_reserved - 
                ((asf_rsvd_g + egr_rsvd_g) << 1);
        }
        else {
            egr_shared_total = total_pool_size - q_reserved;
        }
    } else
#endif
    {
        egr_shared_total = total_pool_size - q_reserved;
    }
    egr_shared_total += (lossless)? 10:0;
    
    port = in_port;
    buf_port = &buf->ports[port];

    /* internal priority to priority group mapping */
    for (idx = 0; idx < 16; idx++) {
        buf_port->pri_to_prigroup[idx] = 7;
    }

    /* priority group to pool mapping */
    for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
        buf_port->prigroups[idx].pool_idx = 0;
    }

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_port_pool = &buf_port->pools[idx];
        buf_port_pool->guarantee = 0;
        buf_port_pool->pool_limit = 0;
        buf_port_pool->pool_resume = 0;
        if (idx == 0) {
            buf_port_pool->pool_limit = total_pool_size;
            buf_port_pool->pool_resume = 
                total_pool_size - (default_mtu_cells * 2);
        }
        in_reserved += buf_port_pool->guarantee;
    }

    buf_port->pkt_size = max_packet_cells;

    /* priority group */
    for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
        buf_prigroup = &buf_port->prigroups[idx];
        buf_prigroup->guarantee = 0;
        buf_prigroup->user_delay = -1;
        buf_prigroup->switch_delay = -1;
        buf_prigroup->pkt_size = max_packet_cells;
        buf_prigroup->device_headroom_enable = 0;
        buf_prigroup->pool_limit = 0;
        buf_prigroup->pool_floor = 0;
        buf_prigroup->pool_scale = -1;
        buf_prigroup->headroom = 0;
        buf_prigroup->pool_resume = 0;
        buf_prigroup->flow_control_enable = 0;
        if (idx == 7) {
            buf_prigroup->device_headroom_enable = 1;
            buf_prigroup->flow_control_enable = lossless;
            if (lossless) {
                buf_prigroup->guarantee = 8;
                buf_prigroup->headroom = 
                    _soc_td2_default_lossless_pg_headroom(unit, port);
                buf_prigroup->pool_scale = 8;
                buf_prigroup->pool_resume = default_mtu_cells * 2;
            } else {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                if (SOC_IS_TD2P_TT2P(unit)) {
                    if (IS_CPU_PORT(unit, port)) {
                        buf_prigroup->headroom =
                            _soc_td2_default_lossless_pg_headroom(unit, port);
                    }
                }
#endif
            }
        }
        in_reserved += buf_prigroup->guarantee + buf_prigroup->headroom;
    }

    /* multicast queue */
    for (idx = 0; idx < si->port_num_cosq[port]; idx++) {
        buf_queue = &buf_port->queues[idx];
        buf_queue->qgroup_id = -1;
        buf_queue->color_discard_enable = 0;
        if (SOC_IS_TD2P_TT2P(unit)) {
            buf_queue->mcq_entry_guarantee = 4;
            if (IS_LB_PORT(unit, port) &&
                    (idx == (si->port_num_cosq[port]-1))) {
                buf_queue->mcq_entry_guarantee = 0;
            }
        } else {
            buf_queue->mcq_entry_guarantee = 8;
        }
        if (lossless) {
            buf_queue->guarantee = min_cell_per_mcq ?
                _soc_td2_min_cell_rsvd_per_mcq(unit, port, 0) : 0;
            buf_queue->discard_enable = 0;
            buf_queue->pool_scale = -1;
            buf_queue->pool_limit = egr_shared_total;
            buf_queue->yellow_limit = egr_shared_total;
            buf_queue->red_limit = egr_shared_total;
            buf_queue->pool_resume = 16;
        } else {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                if (IS_CPU_PORT(unit, port) ||
                        (IS_LB_PORT(unit, port) && (idx != (si->port_num_cosq[port]-1)))) {
                    buf_queue->guarantee = min_cell_per_mcq ?
                        _soc_td2_min_cell_rsvd_per_mcq(unit, port, default_mtu_cells) :
                        default_mtu_cells;
                } else {
                    buf_queue->guarantee = min_cell_per_mcq ?
                        _soc_td2_min_cell_rsvd_per_mcq(unit, port, 0) : 0;
                }
            } else
#endif
            {
                buf_queue->guarantee = min_cell_per_mcq ?
                    _soc_td2_min_cell_rsvd_per_mcq(unit, port, default_mtu_cells) :
                    default_mtu_cells;
            }
            buf_queue->discard_enable = 1;
            buf_queue->pool_scale = 8;
            buf_queue->pool_limit = 0;
            buf_queue->yellow_limit = 8 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            buf_queue->red_limit = 8 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            buf_queue->pool_resume = 16;
        }
    }

    /* unicast queue */
    for (idx = 0; idx < si->port_num_uc_cosq[port]; idx++) {
        buf_queue = &buf_port->queues[si->port_num_cosq[port] + idx];
        buf_queue->qgroup_id = -1;
        buf_queue->color_discard_enable = 0;
        if (lossless) {
            buf_queue->guarantee = 0;
            buf_queue->discard_enable = 0;
            buf_queue->pool_scale = -1;
            buf_queue->pool_limit = egr_shared_total;
            buf_queue->yellow_limit = egr_shared_total;
            buf_queue->red_limit = egr_shared_total;
            buf_queue->pool_resume = default_mtu_cells * 2;
            buf_queue->yellow_resume = default_mtu_cells * 2;
            buf_queue->red_resume = default_mtu_cells * 2;
        } else {
            buf_queue->guarantee = SOC_TD2_MMU_Q_MIN_RSVD;
            buf_queue->discard_enable = 1;
            buf_queue->pool_scale = 8;
            buf_queue->pool_limit = 0;
            buf_queue->yellow_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            buf_queue->red_limit = 0 | _MMU_CFG_BUF_DYNAMIC_FLAG;
            buf_queue->pool_resume = default_mtu_cells * 2;
            buf_queue->yellow_resume = default_mtu_cells * 2;
            buf_queue->red_resume = default_mtu_cells * 2;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                /* Enable QGROUP in LOSSY MODE */
                /* All Queues belong to the same egress port are assigned
                 * to one queue group. Queues belong to different egress
                 * ports are assigned to different queue group.
                 */
                mmu_port = SOC_TD2_MMU_PORT(unit, port);
                buf_queue->qgroup_id = (mmu_port & 0x3f);
                buf_queue->qgroup_min_enable = 1;
            }
#endif
        }
    }

    /* queue to pool mapping */
    for (idx = 0; 
            idx < si->port_num_cosq[port] + si->port_num_uc_cosq[port]; idx++) {
        buf_port->queues[idx].pool_idx = 0;
    }

    buf_port = &buf->ports[port];
    buf_prigroup = &buf_port->prigroups[7];
    if (!lossless) {
        buf_prigroup->pool_limit = total_pool_size - in_reserved;
    }

}

STATIC void
_soc_td2_mmu_config_buf_default(int unit, _soc_mmu_cfg_buf_t *buf,
                                _soc_mmu_device_info_t *devcfg, int lossless)
{
    int port;
    
    _soc_td2_mmu_config_buf_default_global(unit,
            buf, devcfg, lossless);

    PBMP_ALL_ITER(unit, port) {
        _soc_td2_mmu_config_buf_default_port(unit, port,
                buf, devcfg, lossless);
    }
}


STATIC int
_soc_td2_pool_scale_to_limit(int size, int scale)
{
    int factor = 1000;

    switch (scale) {
        case 7: factor = 875; break;
        case 6: factor = 750; break;
        case 5: factor = 625; break;
        case 4: factor = 500; break;
        case 3: factor = 375; break;
        case 2: factor = 250; break;
        case 1: factor = 125; break;
        case 0:
        default:
            factor = 1000; break;
    }
    return (size * factor)/1000;
}

STATIC int
_soc_td2_mmu_config_buf_set_hw_global(int unit, _soc_mmu_cfg_buf_t *buf,
                               _soc_mmu_device_info_t *devcfg, int lossless)
{
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    soc_mem_t mem, mem2;
    uint32 rval, fval, rval2, rval3;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    mmu_thdu_offset_qgroup_entry_t qgrp_offset;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;
    int port, idx, limit, pval, rqlen;
    int default_mtu_cells, jumbo_frame_cells;
    int pool_resume = 0;
    uint16      dev_id;
    uint8       rev_id;
    uint32* dev_mmu_params_arr = NULL;
    int         ing_rsvd = 0, egr_rsvd = 0, asf_rsvd = 0, mcq_entry_rsvd = 0;
    int         pool_pg_headroom = 0, queue_guarantee = 0;
    int         total_rsvd = 0;
    int cpu_hdrm = 0;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int lb_hdrm = 0;
    int prigroup_guarantee = 0;
    int rqe = 0, rqe_rsvd = 0;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe;
    soc_info_t *si;
    si = &SOC_INFO(unit);
#endif
    
    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        dev_mmu_params_arr = soc_td2p_mmu_params_arr_get(dev_id, rev_id);
    } else 
#endif
    {
        dev_mmu_params_arr = soc_td2_mmu_params_arr_get(dev_id, rev_id);
    }

    if (!dev_mmu_params_arr) {
        return SOC_E_NOT_FOUND;
    }

    PBMP_ALL_ITER(unit, port) {
        pool_resume += 4;
    }

    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->jumbo_pkt_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    rval = 0;
    fval = dev_mmu_params_arr[_MMU_PHYSICAL_CELLS] - dev_mmu_params_arr[_MMU_RSVD_CELLS_CFAP];
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDSETr, &rval, CFAPFULLSETPOINTf,
                      fval);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDSETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDRESETr, &rval,
                      CFAPFULLRESETPOINTf, fval - 2 * jumbo_frame_cells);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDRESETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPBANKFULLr, &rval, LIMITf, 2046);
    for (idx = 0; idx < 16; idx++) {
        SOC_IF_ERROR_RETURN(WRITE_CFAPBANKFULLr(unit, idx, rval));
    }

    if (SOC_IS_TRIDENT2(unit)) {
        if (rev_id == BCM56850_A0_REV_ID || rev_id == BCM56850_A1_REV_ID) {
            rval = 0;
            soc_reg_field_set(unit, CFAP_ARBITER_MASKr, &rval, MASKf, 0xA);
            SOC_IF_ERROR_RETURN(WRITE_CFAP_ARBITER_MASKr(unit, rval));
        }
    }

    for (idx = 0; idx < NUM_PIPE(unit); idx++) {
            asf_rsvd += buf->rsvd_buffers[idx].asf_rsvd_cells;
            egr_rsvd += buf->rsvd_buffers[idx].egr_rsvd_cells;
            ing_rsvd += buf->rsvd_buffers[idx].ing_rsvd_cells;
            mcq_entry_rsvd += buf->rsvd_buffers[idx].mcq_entry_rsvd;
    }

    LOG_VERBOSE(BSL_LS_SOC_MMU,
                (BSL_META_U(unit,
                            "MMU config set HW: Cells rsvd Total : %d ing %d egr %d asf %d mcq_entry %d\n"),
                            (ing_rsvd + egr_rsvd + asf_rsvd), ing_rsvd, egr_rsvd, asf_rsvd, mcq_entry_rsvd));

    /* Input thresholds */
    rval = 0;
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                                        REG_PORT_ANY, 0, rval));
    
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                                        REG_PORT_ANY, 0, rval));
    
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        if ((buf->pools[idx].size & ~_MMU_CFG_BUF_PERCENT_FLAG) != 0) {
            fval |= 1 << idx;
        }
    }

    rval = 0;
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            if ((buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) < 10000) {
                fval |= 1 << idx;
            }
        } else {
            if (buf->pools[idx].size != buf->pools[idx].yellow_size) {
                fval |= 1 << idx;
            }
        }
    }
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, COLOR_AWAREf, fval);
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, PUBLIC_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDI_POOL_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, THDI_BYPASSr, &rval, INPUT_THRESHOLD_BYPASSf, 0);
    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, rval));

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        if (SOC_IS_TD2P_TT2P(unit)) {
            cpu_hdrm = _TD2P_MMU_CPU_HEADROOM;
        }

        if (!lossless) {
            buf_pool->prigroup_headroom += cpu_hdrm;
        }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if ((FALSE == si->flex_eligible) && soc_td2p_is_any_port_flex_enable(unit)) {
                /* Legacy flex port (:i) is not enabled */
                /* additional per port macro buffers reserved */
                /* Add cpu & lb port pg headroom */
                if (lossless) {
                    lb_hdrm = _soc_td2_default_lossless_pg_headroom(
                            unit,
                            LB_PORT(unit));
                    /* Add PG min for CPU & Loopback port */
                    prigroup_guarantee = _TD2P_MMU_RSVD_BUF_FLEX_PGMIN_LOSSLESS * 2;
                }
                pool_pg_headroom = ing_rsvd + cpu_hdrm + lb_hdrm + prigroup_guarantee;
            } else {
                /* cpu & lb port pg headroom is already
                 * included in buf_pool->prigroup_headroom */
                pool_pg_headroom = buf_pool->prigroup_headroom +
                    buf_pool->prigroup_guarantee;
            }
        } else
#endif
        {
            pool_pg_headroom = buf_pool->prigroup_headroom +
                buf_pool->prigroup_guarantee;
        }

        if (lossless) {
            total_rsvd = (pool_pg_headroom +
                    buf_pool->queue_guarantee + 
                    buf->headroom + asf_rsvd);
        } else {
            total_rsvd = (pool_pg_headroom + 
                    buf->headroom + asf_rsvd);
        }

        limit = buf_pool->total - total_rsvd;

        LOG_VERBOSE(BSL_LS_SOC_MMU,
                (BSL_META_U(unit,
                            "_soc_td2_mmu_config_buf_set_hw THDI_BUFFER_CELL_LIMIT_SP %d\n"), limit));

        rval = 0;
        soc_reg_field_set(unit, THDI_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_SPr(unit, idx, rval));
        
        rval = 0;
        soc_reg_field_set(unit, THDI_CELL_RESET_LIMIT_OFFSET_SPr, &rval, 
                            OFFSETf, pool_resume);
        SOC_IF_ERROR_RETURN(WRITE_THDI_CELL_RESET_LIMIT_OFFSET_SPr(unit, idx, rval));
    }

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_PUBLIC_POOLr(unit, rval));

    /* output thresholds */
    SOC_IF_ERROR_RETURN(READ_OP_THDU_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_QUEUE_AND_GROUP_TICKETf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_UPDATE_COLOR_RESUMEf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THDU_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval, MOP_POLICYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));

    /* per service pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        queue_guarantee = buf_pool->queue_guarantee;
        total_rsvd = queue_guarantee;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if ((FALSE == si->flex_eligible) && soc_td2p_is_any_port_flex_enable(unit)) {
                /* Legacy flex port (:i) is not enabled 
                * Overwrite total_rsvd with flexport reservations made
                * Add cpu & lb port egr rsvd entries */
                if (devcfg->flags & SOC_MMU_CFG_F_RQE) {
                    for (rqe = 0; rqe < 11; rqe++) {
                        buf_rqe = &buf->rqe_queues[rqe];
                        rqe_rsvd += buf_rqe->guarantee;
                    }
                }
                if (lossless) {
                    total_rsvd = egr_rsvd + asf_rsvd + rqe_rsvd;
                } else {
                    total_rsvd = egr_rsvd + asf_rsvd + 
                        soc_td2p_egr_buf_rsvd_port(unit, CMIC_PORT(unit), default_mtu_cells) +
                        soc_td2p_egr_buf_rsvd_port(unit, LB_PORT(unit), default_mtu_cells) +
                        rqe_rsvd;
                }
            }
        }
#endif
        limit = buf_pool->total - total_rsvd + (lossless ? 10 : 0);

        if (limit <= 0) {
            limit = 0;
        }

        LOG_VERBOSE(BSL_LS_SOC_MMU,
                (BSL_META_U(unit,
                            "_soc_td2_mmu_config_buf_set_hw MMU_THDM_DB_POOL_SHARED_LIMIT %d\n"), limit));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_SHARED_LIMITr, &rval, 
                                                SHARED_LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr, 
                                    &rval, YELLOW_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_SHARED_LIMITr, 
                            &rval, RED_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RESUME_LIMITr, 
                            &rval, RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr, 
                            &rval, YELLOW_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_RESUME_LIMITr, 
                            &rval, RED_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_RESUME_LIMITr(unit, idx, rval));

        /* mcq entries */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if ((FALSE == si->flex_eligible) && soc_td2p_is_any_port_flex_enable(unit)) {
                /* Legacy flex port (:i) is not enabled */
                /* additional per port macro mcq entries reserved */
                /* Add cpu & lb port mcs entries */
                total_rsvd = mcq_entry_rsvd + 
                    soc_td2p_mcq_entries_rsvd_port(unit, CMIC_PORT(unit)) +
                    soc_td2p_mcq_entries_rsvd_port(unit, LB_PORT(unit));
            } else {
                /* cpu & lb port mcq reserved entries already included
                 *  in buf_pool->mcq_entry_reserved
                 */
                total_rsvd = buf_pool->mcq_entry_reserved;
            }
        } else
#endif
        {
            total_rsvd = buf_pool->mcq_entry_reserved;
        }

        limit = buf_pool->total_mcq_entry - total_rsvd;
        LOG_VERBOSE(BSL_LS_SOC_MMU,
                (BSL_META_U(unit,
                            "_soc_td2_mmu_config_buf_set_hw MMU_THDM_MCQE_POOL_SHARED_LIMIT %d\n"), limit));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_SHARED_LIMITr, 
                          &rval, SHARED_LIMITf, (limit + 3)/4);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr, 
                          &rval, YELLOW_SHARED_LIMITf, (limit + 7)/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr, 
                          &rval, RED_SHARED_LIMITf, (limit + 7)/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RESUME_LIMITr, 
                          &rval, RESUME_LIMITf, (limit + 7)/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr, 
                          &rval, YELLOW_RESUME_LIMITf, (limit + 7)/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr, 
                          &rval, RED_RESUME_LIMITf, (limit + 7)/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr(unit, 
                                                                   idx, rval));
    }

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_QE_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIGr(unit, rval));

    /* configure Q-groups */
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
    
        mem = MMU_THDU_XPIPE_CONFIG_QGROUPm;
        mem2 = MMU_THDU_YPIPE_CONFIG_QGROUPm;
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                            Q_MIN_LIMIT_CELLf, queue_grp->guarantee);

        if (queue_grp->pool_scale != -1) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                               Q_SHARED_ALPHA_CELLf, queue_grp->pool_scale);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_LIMIT_DYNAMIC_CELLf, 1);
        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                Q_SHARED_LIMIT_CELLf, queue_grp->pool_limit);
        }
        
        if ((queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
        }

        if (queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, queue_grp->red_limit);
        }

        if (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, queue_grp->yellow_limit);
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));
        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem2, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        mem = MMU_THDU_XPIPE_OFFSET_QGROUPm;
        mem2 = MMU_THDU_YPIPE_OFFSET_QGROUPm;
        sal_memset(&qgrp_offset, 0, sizeof(qgrp_offset));
        soc_mem_field32_set(unit, mem, &qgrp_offset,
                            RESET_OFFSET_CELLf, 2);
        soc_mem_field32_set(unit, mem, &qgrp_offset,
                            RESET_OFFSET_YELLOW_CELLf, 2);
        soc_mem_field32_set(unit, mem, &qgrp_offset,
                            RESET_OFFSET_RED_CELLf, 2);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &qgrp_offset));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem2, MEM_BLOCK_ALL, idx, &qgrp_offset));
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        if ((buf_rqe_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (buf_rqe_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                        &rval, COLOR_LIMIT_DYNAMICf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit / 8);

            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit / 8);
        }

        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 
                            (buf_rqe_queue->discard_enable ? 1 : 0));

        if (buf_rqe_queue->pool_scale != -1) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                            &rval, DYNAMIC_ENABLEf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_ALPHAf, buf_rqe_queue->pool_scale);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_LIMITf, buf_rqe_queue->pool_limit);
        }
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 2);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, (default_mtu_cells * 2)/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, (default_mtu_cells * 2)/8);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

        /* queue entry */
        buf_pool = &buf->pools[buf_rqe_queue->pool_idx];
        if (idx == 0) {
            LOG_VERBOSE(BSL_LS_SOC_MMU,
                    (BSL_META_U(unit,
                                "_soc_td2_mmu_config_buf_set_hw Total shared RQE entries limit %d\n"), buf_pool->total_rqe_entry));
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        if (SOC_IS_TD2P_TT2P(unit) && !lossless) {
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                    &rval, DYNAMIC_ENABLEf, 1);
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                    &rval, COLOR_LIMIT_DYNAMICf, 1);
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 1);
        } else {
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                    &rval, DYNAMIC_ENABLEf, 0);
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                    &rval, COLOR_LIMIT_DYNAMICf, 0);
            soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 0);
        }

        fval = (buf_pool->total_rqe_entry + 8 * 11 - 1) / (8 * 11);
        if (SOC_IS_TD2P_TT2P(unit) && !lossless) {
            fval = 0;
        }
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
                          &rval3, SHARED_RED_LIMITf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
                          &rval3, SHARED_YELLOW_LIMITf, fval);
        if (SOC_IS_TD2P_TT2P(unit) && !lossless) {
            fval = 8;
        }
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, 
                SHARED_LIMITf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 1);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        if (SOC_IS_TD2P_TT2P(unit) && !lossless) {
            fval = 1;
        } else {
            fval = default_mtu_cells/8;
        }
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, fval);
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, fval);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

    }

    /* per pool RQE settings */
    for (idx = 0; idx < 4; idx++) {
        buf_pool = &buf->pools[idx];
        if (((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) ||
            (buf_pool->total == 0)) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee;
        
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, 
                                &rval, SHARED_LIMITf, limit);
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, &rval, RESUME_LIMITf, 
                                    (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                     SHARED_RED_LIMITf, limit/8);
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                  SHARED_YELLOW_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_SP_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                     RESUME_RED_LIMITf, (limit - (default_mtu_cells * 2))/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                  RESUME_YELLOW_LIMITf, (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));

        rqlen = buf_pool->total_rqe_entry/8 - 1;
        if (rqlen == 0) {
            continue;
        }

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, SHARED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, RESUME_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_RED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_YELLOW_LIMITf, rqlen);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_RED_LIMITf, rqlen - 1);
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_YELLOW_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));
    }

    /* Device level config setting */
    if (soc_property_get(unit, spn_PORT_UC_MC_ACCOUNTING_COMBINE, 0)) {
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval,
                          UC_MC_PORTSP_COMB_ACCT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));
    }

    return SOC_E_NONE;
}

int
_soc_td2_mmu_config_buf_set_hw_port(int unit, int port, _soc_mmu_cfg_buf_t *buf,
                               _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    soc_reg_t reg = INVALIDr;
    soc_mem_t mem, mem1, mem2, mem3;
    uint32 rval, fval;
    uint32 entry0[SOC_MAX_MEM_WORDS], entry1[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    thdi_port_sp_config_entry_t thdi_sp_config;
    int default_mtu_cells, limit, midx, pri, rlimit, min_resume_limit;
    int base, numq, idx;
    int qbase;
    static const soc_field_t prigroup_reg[] = {
        THDI_PORT_PRI_GRP0r, THDI_PORT_PRI_GRP1r
    };
    static const soc_field_t prigroup_field[] = {
        PRI0_GRPf, PRI1_GRPf, PRI2_GRPf, PRI3_GRPf,
        PRI4_GRPf, PRI5_GRPf, PRI6_GRPf, PRI7_GRPf,
        PRI8_GRPf, PRI9_GRPf, PRI10_GRPf, PRI11_GRPf,
        PRI12_GRPf, PRI13_GRPf, PRI14_GRPf, PRI15_GRPf
    };
    static const soc_field_t prigroup_spid_field[] = {
        PG0_SPIDf, PG1_SPIDf, PG2_SPIDf, PG3_SPIDf,
        PG4_SPIDf, PG5_SPIDf, PG6_SPIDf, PG7_SPIDf
    };
    int index1;
    
    min_resume_limit = soc_feature(unit, soc_feature_min_resume_limit_1) ? 8 : 0;

    si = &SOC_INFO(unit);

    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    /* internal priority to priority group mapping */
    buf_port = &buf->ports[port];

    for (idx = 0; idx < 16; idx++) {
        if (idx % 8 == 0) { /* 8 fields per register */
            reg = prigroup_reg[idx / 8];
            rval = 0;
        }
        soc_reg_field_set(unit, reg, &rval, prigroup_field[idx],
                buf_port->pri_to_prigroup[idx]);
        if (idx % 8 == 7) { /* 8 fields per register */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
    }

    /* Input port per port settings */
    buf_port = &buf->ports[port];

    rval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
        soc_reg_field_set(unit, THDI_PORT_PG_SPIDr, &rval,
                prigroup_spid_field[idx],
                buf_port->prigroups[idx].pool_idx);
    }
    SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_PG_SPIDr(unit, port, rval));

    mem = SOC_TD2_PMEM(unit, port, THDI_PORT_SP_CONFIG_Xm, 
            THDI_PORT_SP_CONFIG_Ym);
    /* Per port per pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_port_pool = &buf_port->pools[idx];
        midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
        sal_memset(&thdi_sp_config, 0, sizeof(thdi_sp_config));
        soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                PORT_SP_MIN_LIMITf, buf_port_pool->guarantee);
        soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                PORT_SP_RESUME_LIMITf, buf_port_pool->pool_resume);
        soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                PORT_SP_MAX_LIMITf, buf_port_pool->pool_limit);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, midx, &thdi_sp_config));
    }

    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
        if (buf_port->prigroups[idx].flow_control_enable != 0) {
            for (pri=0; pri < 16; pri++) {
                if (buf_port->pri_to_prigroup[pri] == idx) {
                    fval |= 1 << pri;
                }
            }
        }
    }

    rval = 0;
    soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
            INPUT_PORT_RX_ENABLEf, 1);
    soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
            PORT_PRI_XON_ENABLEf, fval);
    soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
            PORT_PAUSE_ENABLEf, fval ? 1 : 0);
    SOC_IF_ERROR_RETURN(WRITE_THDI_INPUT_PORT_XON_ENABLESr(unit, port, rval));

    rval = 0;
    soc_reg_field_set(unit, THDI_PORT_MAX_PKT_SIZEr, &rval, 
            PORT_MAX_PKT_SIZEf, buf_port->pkt_size);
    SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_MAX_PKT_SIZEr(unit, rval));

    /* Input port per port per priority group settings */
    mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
            THDI_PORT_PG_CONFIG_Ym);
    for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
        buf_prigroup = &buf->ports[port].prigroups[idx];

        midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
        sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
        soc_mem_field32_set(unit, mem, &pg_config_mem, 
                PG_MIN_LIMITf, buf_prigroup->guarantee);

        if (buf_prigroup->pool_scale != -1) {
            soc_mem_field32_set(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf, 1);
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                    PG_SHARED_LIMITf, buf_prigroup->pool_scale);
        } else {
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                    PG_SHARED_LIMITf, buf_prigroup->pool_limit);
        }

        soc_mem_field32_set(unit, mem, &pg_config_mem, 
                PG_GBL_HDRM_ENf, buf_prigroup->device_headroom_enable);
        soc_mem_field32_set(unit, mem, &pg_config_mem, 
                PG_HDRM_LIMITf, buf_prigroup->headroom);

        soc_mem_field32_set(unit, mem, &pg_config_mem, 
                PG_RESET_OFFSETf, buf_prigroup->pool_resume);

        soc_mem_field32_set(unit, mem, &pg_config_mem, 
                PG_RESET_FLOORf, buf_prigroup->pool_floor);

        SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                    MEM_BLOCK_ALL, midx, &pg_config_mem));
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    numq = si->port_num_cosq[port];
    qbase = si->port_cosq_base[port];
    if (numq != 0) {

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_OFFSET_0m, 
                MMU_THDM_DB_QUEUE_OFFSET_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                    Q_MIN_LIMITf, buf_queue->guarantee);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_LIMITf, buf_queue->pool_limit);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                    (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                        Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                        buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                        buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                        buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                        buf_queue->red_limit / 8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                    Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                    RESUME_OFFSETf, (default_mtu_cells * 2)/8);
            soc_mem_field32_set(unit, mem1, entry0, 
                    YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                    RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0, 2));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0, 2));
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_CONFIG_0m, 
                MMU_THDM_MCQE_QUEUE_CONFIG_1m);
        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_OFFSET_0m,
                MMU_THDM_MCQE_QUEUE_OFFSET_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];
            buf_pool = &buf->pools[buf_queue->pool_idx];
            if (buf_pool->total == 0) {
                continue;
            }
            limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                    Q_MIN_LIMITf, buf_queue->mcq_entry_guarantee/4);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_LIMITf, (limit + 3)/4);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                    (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                        Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf, 0);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf, 0);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                        (limit + 7)/8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                        (limit + 7)/8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                    Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                    RESUME_OFFSETf, 1);
            soc_mem_field32_set(unit, mem1, entry0, 
                    YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                    RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0, 1));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0, 1));
        }

        /* Per  port per pool */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];
            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            rlimit = (limit < min_resume_limit) ? \
                        min_resume_limit : (limit - 2 * default_mtu_cells);
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                    MMU_THDM_DB_PORTSP_CONFIG_1m);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem2, entry0, RED_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_SHARED_LIMITf, limit/8);

            soc_mem_field32_set(unit, mem2, entry0, 
                    SHARED_LIMIT_ENABLEf, !lossless);

            soc_mem_field32_set(unit, mem2, entry0, SHARED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, RED_RESUME_LIMITf, rlimit/8);

            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                        index1, entry0));

            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_PORTSP_CONFIG_0m, 
                    MMU_THDM_MCQE_PORTSP_CONFIG_1m);
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_portsp_config_0_entry_t));

            limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;

            soc_mem_field32_set(unit, mem2, entry0,
                    SHARED_LIMITf, (limit + 3)/4);
            soc_mem_field32_set(unit, mem2, entry0,
                    SHARED_RESUME_LIMITf, limit/8 - 1);
            soc_mem_field32_set(unit, mem2, entry0,
                    SHARED_LIMIT_ENABLEf, !lossless);
            soc_mem_field32_set(unit, mem2, entry0,
                    RED_SHARED_LIMITf, (limit + 7)/8);
            soc_mem_field32_set(unit, mem2, entry0,
                    RED_RESUME_LIMITf, (limit + 7)/8 - 1);
            soc_mem_field32_set(unit, mem2, entry0,
                    YELLOW_SHARED_LIMITf, (limit + 7)/8);
            soc_mem_field32_set(unit, mem2, entry0,
                    YELLOW_RESUME_LIMITf, (limit + 7)/8 - 1);


            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                        index1, entry0));
        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    /* per port regular unicast queue */
    numq = si->port_num_uc_cosq[port];
    qbase = si->port_uc_cosq_base[port];
    if (numq != 0) {
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                MMU_THDU_YPIPE_CONFIG_QUEUEm);
        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_OFFSET_QUEUEm, 
                MMU_THDU_YPIPE_OFFSET_QUEUEm);
        mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_Q_TO_QGRP_MAPm, 
                MMU_THDU_YPIPE_Q_TO_QGRP_MAPm);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[si->port_num_cosq[port] + idx];

            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_offset_queue_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                    Q_MIN_LIMIT_CELLf, buf_queue->guarantee);
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_ALPHA_CELLf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                        Q_SHARED_LIMIT_CELLf, buf_queue->pool_limit);
            }
            soc_mem_field32_set(unit, mem1, 
                    entry1, RESET_OFFSET_CELLf, buf_queue->pool_resume / 8);

            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                    (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                        Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                        buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                        buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                        buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                        buf_queue->red_limit / 8);
            }
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_YELLOW_CELLf,
                    buf_queue->yellow_resume / 8);
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_RED_CELLf,
                    buf_queue->red_resume / 8);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx, entry1));

            sal_memset(entry0, 0, sizeof(mmu_thdo_q_to_qgrp_map_entry_t));
            soc_mem_field32_set(unit, mem2,
                    entry0, Q_SPIDf, buf_queue->pool_idx);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_COLOR_ENABLE_CELLf, 1);
            }


            if (buf_queue->qgroup_id >= 0) {
                soc_mem_field32_set(unit, mem2, entry0, QGROUP_VALIDf, 1);
                soc_mem_field32_set(unit, mem2, entry0, QGROUPf, buf_queue->qgroup_id);
                if (buf_queue->qgroup_min_enable) {
                    soc_mem_field32_set(unit, mem2, entry0, USE_QGROUP_MINf, 1);
                }
            }

            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                        base + idx, entry0));
        }

        /* Per  port per pool unicast */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];

            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                    MMU_THDU_YPIPE_CONFIG_PORTm);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            mem3 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_RESUME_PORTm, 
                    MMU_THDU_YPIPE_RESUME_PORTm);
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_resume_port_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem3, entry1,
                    SHARED_RESUMEf, (limit - (default_mtu_cells * 2))/8);

            soc_mem_field32_set(unit, mem2, entry0, YELLOW_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                    YELLOW_RESUMEf, (limit - (default_mtu_cells*2))/8);

            soc_mem_field32_set(unit, mem2, entry0, RED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                    RED_RESUMEf, (limit - (default_mtu_cells * 2))/8);

            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                        index1, entry0));
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem3, MEM_BLOCK_ALL, 
                        index1, entry1));
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_td2_mmu_config_buf_set_hw(int unit, _soc_mmu_cfg_buf_t *buf,
                               _soc_mmu_device_info_t *devcfg, int lossless)
{
    int port;
    
    SOC_IF_ERROR_RETURN(_soc_td2_mmu_config_buf_set_hw_global(unit,
            buf, devcfg, lossless));

    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(_soc_td2_mmu_config_buf_set_hw_port(unit, port,
                buf, devcfg, lossless));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_td2_mmu_config_shared_update_check(int unit, int val1, int val2, int flags)
{
    int rv = 0;
    if (flags == 1) {
        if (val1 > val2) {
            rv = 1;
        }
    } else {
        if (val1 < val2) {
            rv = 1;
        }
    }
    return rv;
}

int
soc_td2_mmu_config_shared_buf_recalc(int unit, uint32 spid,
                                     int shared_size, int flags)
{
    soc_info_t *si;
    soc_mem_t mem, mem2;
    soc_reg_t reg = INVALIDr;
    soc_field_t field = INVALIDf;
    uint32 rval, rval2, mmu_port;
    uint32 entry0[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int port, base, qbase, numq, idx;
    int cur_limit, midx, index1;
    int granularity;
    uint16      dev_id;
    uint8       rev_id;
    static const soc_field_t pg_spid_field[] = {
        PG0_SPIDf, PG1_SPIDf, PG2_SPIDf, PG3_SPIDf,
        PG4_SPIDf, PG5_SPIDf, PG6_SPIDf, PG7_SPIDf
    };

    if (spid >= _TD2_MMU_NUM_POOL) {
        return SOC_E_PARAM;
    }

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);

    si = &SOC_INFO(unit);

    /* per service pool settings */
    idx = spid;
    rval = 0;
    reg = MMU_THDM_DB_POOL_SHARED_LIMITr;
    field = SHARED_LIMITf;
    granularity = 1;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
    cur_limit = soc_reg_field_get(unit, reg, rval, field);
    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
    }

    rval = 0;
    reg = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;
    field = YELLOW_SHARED_LIMITf;
    granularity = 8;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
    cur_limit = soc_reg_field_get(unit, reg, rval, field);
    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
    }

    rval = 0;
    reg = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;
    field = RED_SHARED_LIMITf;
    granularity = 8;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
    cur_limit = soc_reg_field_get(unit, reg, rval, field);
    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
    }

    /* configure Q-groups */
    mem = MMU_THDU_XPIPE_CONFIG_QGROUPm;
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        field = Q_SHARED_LIMIT_CELLf;
        granularity = 1;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp, Q_LIMIT_DYNAMIC_CELLf)) {
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }
        
        granularity = 8;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp,
                                 Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
            field = LIMIT_RED_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }

            field = LIMIT_YELLOW_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        /* Y pipe */
        if ((mem == MMU_THDU_XPIPE_CONFIG_QGROUPm) &&
            (idx == (SOC_TD2_MMU_CFG_QGROUP_MAX -1))) {
            idx = 0;
            mem = MMU_THDU_YPIPE_CONFIG_QGROUPm;
        }
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        rval = 0;
        /* Input port per port per priority group settings */
        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
                                       THDI_PORT_PG_CONFIG_Ym);
        field = PG_SHARED_LIMITf;
        granularity = 1;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            mmu_port = _soc_trident2_mmu_port(unit, port);
            SOC_IF_ERROR_RETURN(READ_THDI_PORT_PG_SPIDr(unit, mmu_port, &rval));
            if (spid != soc_reg_field_get(unit, THDI_PORT_PG_SPIDr, rval, 
                                          pg_spid_field[idx])) {
                continue;
            }
            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, 
                                             MEM_BLOCK_ALL, midx, &pg_config_mem));
            if (!soc_mem_field32_get(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, &pg_config_mem, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                        field, shared_size/granularity);
                }
            }
        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    PBMP_PORT_ITER(unit, port) {
        numq = si->port_num_cosq[port];
        qbase = si->port_cosq_base[port];
        if (numq == 0) {
            continue;
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                                       MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));
            if (spid != soc_mem_field32_get(unit, mem, entry0, Q_SPIDf)) {
                continue;
            }

            field = Q_SHARED_LIMITf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMICf)) {
                field = YELLOW_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = RED_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));
        }

        /* Per  port per pool */
        idx = spid;
        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                                        MMU_THDM_DB_PORTSP_CONFIG_1m);
        index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
        sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

        SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                            index1, entry0));

        field = SHARED_LIMITf;
        granularity = 1;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }

        field = RED_SHARED_LIMITf;
        granularity = 8;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }

        field = YELLOW_SHARED_LIMITf;
        granularity = 8;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }

        SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                            index1, entry0));
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_PORT_ITER(unit, port) {
        /* per port regular unicast queue */
        numq = si->port_num_uc_cosq[port];
        qbase = si->port_uc_cosq_base[port];

        if (numq == 0) {
            continue;
        }
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                                       MMU_THDU_YPIPE_CONFIG_QUEUEm);
        mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_Q_TO_QGRP_MAPm, 
                                       MMU_THDU_YPIPE_Q_TO_QGRP_MAPm);
        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_q_to_qgrp_map_entry_t));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem2, MEM_BLOCK_ALL, base + idx, entry0));
            if (spid != soc_mem_field32_get(unit, mem2, entry0, Q_SPIDf)) {
                continue;
            }
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMIT_CELLf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
                field = LIMIT_YELLOW_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = LIMIT_RED_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));
        }
        
        /* Per  port per pool unicast */
        idx = spid;
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                                       MMU_THDU_YPIPE_CONFIG_PORTm);
        index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
        sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));

        SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                            index1, entry0));

        field = SHARED_LIMITf;
        granularity = 1;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }

        granularity = 8;
        field = YELLOW_LIMITf;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }
        field = RED_LIMITf;
        cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_mem_field32_set(unit, mem, entry0, 
                                field, shared_size/granularity);
        }
        
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                            index1, entry0));
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        rval = 0;
        rval2 = 0;

        SOC_IF_ERROR_RETURN(READ_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, &rval));
        if (spid != soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                                      SPIDf)) {
            continue;
        }

        reg = MMU_THDR_DB_CONFIG_PRIQr;
        field = SHARED_LIMITf;
        granularity = 1;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               DYNAMIC_ENABLEf)) {
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
            }
        }

        rval2 = 0;
        reg = MMU_THDR_DB_LIMIT_COLOR_PRIQr;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               COLOR_LIMIT_DYNAMICf)) {
            field = SHARED_RED_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }

            field = SHARED_YELLOW_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

    }

    /* per pool RQE settings */
    idx = spid;
    reg = MMU_THDR_DB_CONFIG_SPr;
    field = SHARED_LIMITf;
    granularity = 1;

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
    cur_limit = soc_reg_field_get(unit, reg, rval, field);

    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
    }

    reg = MMU_THDR_DB_SP_SHARED_LIMITr;
    granularity = 8;

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

    field = SHARED_YELLOW_LIMITf;
    cur_limit = soc_reg_field_get(unit, reg, rval, field);

    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
    }

    field = SHARED_RED_LIMITf;
    cur_limit = soc_reg_field_get(unit, reg, rval, field);

    if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
        soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
    }
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));

    return SOC_E_NONE;
}

STATIC int
soc_td2_mmu_config_init(int unit, int test_only)
{
    int rv;
    int lossless;
    _soc_mmu_cfg_buf_t *buf;
    _soc_mmu_device_info_t devcfg;

    buf = soc_mmu_cfg_alloc(unit);
    if (!buf) {
        return SOC_E_MEMORY;
    }

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    _soc_td2_mmu_init_dev_config(unit, &devcfg, lossless);
    _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
    if (soc_property_get(unit, spn_MMU_CONFIG_OVERRIDE, 1) == 0) {
        _soc_mmu_cfg_buf_read(unit, buf, &devcfg);
    }
    rv = _soc_mmu_cfg_buf_check(unit, buf, &devcfg);
    if (!test_only) {
        if (SOC_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "MMU config: Use default setting\n")));
            _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
            _soc_mmu_cfg_buf_calculate(unit, buf, &devcfg);
        }
        rv = _soc_td2_mmu_config_buf_set_hw(unit, buf, &devcfg, lossless);
    }

    soc_mmu_cfg_free(unit, buf);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "MMU THDI/THDO init done\n")));
    return rv;
}

/*Clear MMU_CBPDATA for TD2 mmu_init*/
STATIC int
_soc_trident2_mmu_cbpdata_clear(int unit)
{
    soc_mem_t mem;
    soc_mem_t cbpdata_start_m;
    soc_mem_t cbpdata_end_m;

    cbpdata_start_m = MMU_CBPDATA0m;
    cbpdata_end_m = MMU_CBPDATA63m;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        cbpdata_end_m = MMU_CBPDATA83m;
    }
#endif

    for (mem = cbpdata_start_m; mem <= cbpdata_end_m; mem++) {
        SOC_IF_ERROR_RETURN(
                soc_mem_clear(unit, mem, MEM_BLOCK_ALL, TRUE));
    }
    return SOC_E_NONE;
}

int soc_td2_mmu_traffic_ctrl_size(int unit, int *req_scache_size)
{
    *req_scache_size += sizeof(_soc_td2_mmu_traffic_ctrl_t);

    return SOC_E_NONE;
}

int soc_td2_mmu_traffic_ctrl_wb_sync(int unit, uint8 **scache_ptr)
{
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl_scache_p;    
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl;

    mmu_traffic_ctrl_scache_p =
        (_soc_td2_mmu_traffic_ctrl_t *)(*scache_ptr);

    
    mmu_traffic_ctrl = _soc_td2_mmu_traffic_ctrl[unit];
    if (mmu_traffic_ctrl == NULL || mmu_traffic_ctrl_scache_p == NULL) {
        return SOC_E_NONE;
    }
    sal_memcpy(mmu_traffic_ctrl_scache_p, mmu_traffic_ctrl, sizeof(_soc_td2_mmu_traffic_ctrl_t));
    mmu_traffic_ctrl_scache_p++;

    *scache_ptr = (uint8 *)mmu_traffic_ctrl_scache_p;

    return SOC_E_NONE;
}

int soc_td2_mmu_traffic_ctrl_wb_restore(int unit, uint8 **scache_ptr)
{
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl_scache_p;    
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl;

    mmu_traffic_ctrl_scache_p =
        (_soc_td2_mmu_traffic_ctrl_t *)(*scache_ptr);

    
    mmu_traffic_ctrl = _soc_td2_mmu_traffic_ctrl[unit];
    if (mmu_traffic_ctrl == NULL || mmu_traffic_ctrl_scache_p == NULL) {
        return SOC_E_NONE;
    }
    sal_memcpy(mmu_traffic_ctrl, mmu_traffic_ctrl_scache_p, sizeof(_soc_td2_mmu_traffic_ctrl_t));
    mmu_traffic_ctrl_scache_p++;

    *scache_ptr = (uint8 *)mmu_traffic_ctrl_scache_p;

    return SOC_E_NONE;
}

/*
 * LLS creation will be skipped on TD2 only when the port bitmap
 * spn_PBMP_SKIP_DEFAULT_LLS is non-zero.
 */
int
soc_td2_is_skip_default_lls_creation(int unit) {
    int skip = 0;
    soc_pbmp_t skip_default_lls_pbmp;

    skip_default_lls_pbmp = soc_property_get_pbmp(unit, spn_PBMP_SKIP_DEFAULT_LLS, 0);
    if (SOC_PBMP_NOT_NULL(skip_default_lls_pbmp)) {
        skip = 1;
    } 
    
    return skip;
}

STATIC int
_soc_trident2_mmu_init(int unit)
{
    uint32 rval;
    uint64 rval64;
    soc_info_t *si;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port;    
    int alloc_size;
    int test_only;

    if (_fwd_ctrl_lock[unit] == NULL) {
        _fwd_ctrl_lock[unit] = sal_mutex_create("_fwd_ctrl_lock");
    }
    
    if (_fwd_ctrl_lock[unit] == NULL) {
        return SOC_E_MEMORY;
    }
    
    if (_soc_td2_mmu_traffic_ctrl[unit] == NULL) {
        alloc_size = sizeof(_soc_td2_mmu_traffic_ctrl_t);
        _soc_td2_mmu_traffic_ctrl[unit] = 
            sal_alloc(alloc_size,"_soc_td2_mmu_traffic_ctrl");
        if (_soc_td2_mmu_traffic_ctrl[unit] == NULL) {
            return SOC_E_MEMORY;
        }
        sal_memset(_soc_td2_mmu_traffic_ctrl[unit], 0, alloc_size);
    }

    test_only = (SAL_BOOT_BCMSIM || SAL_BOOT_XGSSIM) ? TRUE : FALSE;
    SOC_IF_ERROR_RETURN(soc_td2_mmu_config_init(unit, test_only));

    SOC_IF_ERROR_RETURN(soc_td2_lls_init(unit));

    rval = 0;
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_LLS_CONFIG0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_LLS_CONFIG0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_SC_FOR_MH_PRIf, 1);
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_QM_FOR_MH_PRIf, 1);
    SOC_IF_ERROR_RETURN(WRITE_PRIORITY_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, OOBFC_CHANNEL_BASE_64r, REG_PORT_ANY,
                                ENG_ENf, 1));

    /* Enable IP to CMICM credit transfer */
    rval = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, rval));

    /*Clear MMU_CBPData*/
    if ( !SAL_BOOT_SIMULATION ) {
        SOC_IF_ERROR_RETURN(_soc_trident2_mmu_cbpdata_clear(unit));
    }

    if (!soc_td2_is_skip_default_lls_creation(unit)) {
        /* Enable all ports */
        COMPILER_64_ZERO(rval64);
        
        COMPILER_64_SET(rval64, 0x1fffff, 0xffffffff);
        SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE0_64r(unit, rval64));
        SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE1_64r(unit, rval64));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE0_64r(unit, rval64));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE1_64r(unit, rval64));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r(unit, rval64));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r(unit, rval64));
    } else {
        /* enable cpu & loopback port */
        uint64 cpubit64;
        COMPILER_64_ZERO(cpubit64);
        COMPILER_64_SET(cpubit64, 0x100000, 0x00000000);

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_THDU_OUTPUT_PORT_RX_ENABLE0_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE0_64r(unit, rval64));

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_THDU_OUTPUT_PORT_RX_ENABLE1_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE1_64r(unit, rval64));

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_PORTSP_RX_ENABLE0_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE0_64r(unit, rval64));

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_PORTSP_RX_ENABLE1_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE1_64r(unit, rval64));

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r(unit, rval64));

        COMPILER_64_ZERO(rval64);
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r(unit, &rval64));
        COMPILER_64_OR(rval64, cpubit64);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r(unit, rval64));
    }
    
    if (soc_feature(unit, soc_feature_post)) {
        SOC_IF_ERROR_RETURN(soc_mmu_post_init(unit));
    }

    rval = 0;
    si = &SOC_INFO(unit);      
    pbmp = si->oversub_pbm;
    SOC_PBMP_ITER(pbmp, port) {
        if (si->port_speed_max[port] >= 30000) {
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];        
            if (mmu_port < si->mmu_port_base[1]) {
                rval |= 1 << mmu_port;
            } else {
                rval |= 1 << (mmu_port - si->mmu_port_base[1] + 16);
            }
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_ENQ_ASF_HS_OVERSUB_ENr(unit, rval));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN(READ_ES_PIPE0_MMU_1DBG_Cr(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE0_MMU_1DBG_Cr, &rval, FIELD_Af, 1);
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_MMU_1DBG_Cr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE1_MMU_1DBG_Cr(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE1_MMU_1DBG_Cr, &rval, FIELD_Af, 1);
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_MMU_1DBG_Cr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE0_MMU_2DBG_C_0r(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE0_MMU_2DBG_C_0r, &rval, FIELD_Af, (200 * si->frequency));
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_MMU_2DBG_C_0r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_ES_PIPE1_MMU_2DBG_C_0r(unit, &rval));
        soc_reg_field_set(unit, ES_PIPE1_MMU_2DBG_C_0r, &rval, FIELD_Af, (200 * si->frequency));
        SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_MMU_2DBG_C_0r(unit, rval));
    }
#endif

    PBMP_ALL_ITER(unit, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, INTFO_CONGST_STr, &rval64, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_INTFO_CONGST_STr(unit, port, rval64));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            SOC_IF_ERROR_RETURN(soc_td2p_mmu_delay_insertion_set (unit, 
                        port, si->port_speed_max [port])); 
        }
#endif

    }
    
    /* Enabling the Congestion state enable ,
     *  so that dmvoq message is transmitted 
     *  when a congestion is present 
     */
    PBMP_ALL_ITER(unit, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, INTFO_CONGST_STr, &rval64, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_INTFO_CONGST_STr(unit, port, rval64));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    uint32 rval;

    if (!soc->l2x_sw_aging) {
        SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &rval));
        *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_ENAf);
        *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_VALf);
    } else {
        *enabled = soc->l2x_age_pid != SAL_THREAD_ERROR &&
                   soc->l2x_age_enable ?
                   1 : 0;
        *age_seconds = soc->l2x_age_pid != SAL_THREAD_ERROR &&
                       soc->l2x_age_enable ?
                       soc->l2x_age_interval : 0;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_max_get(int unit, int *max_seconds)
{
    soc_control_t *soc = SOC_CONTROL(unit);

    if (!soc->l2x_sw_aging) {
        *max_seconds =
            soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);
    } else {
        *max_seconds = 0x7fffffff;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_set(int unit, int age_seconds, int enable)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    sal_usecs_t interval = soc->l2x_age_interval;
    uint32 rval = 0;

    if (!soc->l2x_sw_aging) {
        soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
        soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
        SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));
    } else if (soc->l2x_age_interval) {
        if (!enable) {
            soc->l2x_age_enable = 0;
        } else {
            if (age_seconds) {
                SOC_CONTROL_LOCK(unit);
                soc->l2x_age_interval = age_seconds;
                SOC_CONTROL_UNLOCK(unit);
            }
            soc->l2x_age_enable = 1;
            if (interval != age_seconds) {
                sal_sem_give(soc->l2x_age_notify);
            }
        }
    } else {
        if (enable) {
            SOC_IF_ERROR_RETURN
                (soc_td2_l2_bulk_age_start(unit, age_seconds));
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mdio_addr_to_port(uint32 phy_addr)
{
    int bus, offset;

    /* Must be internal MDIO address */
    if ((phy_addr & 0x80) == 0) {
        return 0;
    }

    /*
     * Internal phy address:
     * bus 0 phy 1 to 20 are mapped to Physical port 1 to 20
     * bus 1 phy 1 to 24 are mapped to Physical port 21 to 44
     * bus 2 phy 1 to 20 are mapped to Physical port 45 to 64
     * bus 3 phy 1 to 20 are mapped to Physical port 65 to 84
     * bus 4 phy 1 to 24 are mapped to Physical port 85 to 108
     * bus 5 phy 1 to 20 are mapped to Physical port 109 to 128
     */
    bus = 0;
    if (phy_addr & 0x20) {
        bus |= 0x1;
    }
    if (phy_addr & 0x40) {
        bus |= 0x2;
    }
    if (phy_addr & 0x100) {
        bus |= 0x4;
    }
    offset = 0;
    if (bus >= 5) {
        offset = 8;
    } else if (bus >= 2) {
        offset = 4;
    }
    return (20 * bus) + (phy_addr & 0x1f) + offset;
}

STATIC int
_soc_trident2_mdio_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data)
{
    int port, phy_port, blk;

#if 0
    /* phy access is the same regardless if PortMod enabled */
    /* TSC reg read/write is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }
#endif

    /* Physical port based on MDIO address */
    phy_port = _soc_trident2_mdio_addr_to_port(phy_addr);

    /* THIS IS A TEMPORARY WORK AROUND FOR THE ACCESS */
    port = SOC_INFO(unit).port_p2l_mapping[phy_port&0xFFF1];
    LOG_INFO(BSL_LS_SOC_MII,
             (BSL_META_U(unit,
                         "soc_trident2_mdio_reg_read[%d]: %d/%d/%d\n"),
              unit, phy_addr, phy_port, port));
    blk = SOC_PORT_BLOCK(unit, phy_port);

    /* Call common S-bus MDIO read function */
    return soc_sbus_mdio_reg_read(unit, port, blk, 0,
                                  phy_addr, phy_reg, phy_data,
                                  XLPORT_WC_UCMEM_DATAm,
                                  XLPORT_WC_UCMEM_CTRLr);
}

STATIC int
_soc_trident2_mdio_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data)
{
    int port, phy_port, blk;

#if 0
    /* phy access is the same regardless if PortMod enabled */
    /* TSC reg read/write is handled by PortMod internally */
    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_INTERNAL;
    }
#endif

    /* Physical port based on MDIO address */
    phy_port = _soc_trident2_mdio_addr_to_port(phy_addr);
    /* THIS IS A TEMPORARY WORK AROUND FOR THE ACCESS */
    port = SOC_INFO(unit).port_p2l_mapping[phy_port & 0xFFF1];
    blk = SOC_PORT_BLOCK(unit, phy_port);

    /* Call common S-bus MDIO read function */
    return soc_sbus_mdio_reg_write(unit, port, blk, 0,
                                   phy_addr, phy_reg, phy_data,
                                   XLPORT_WC_UCMEM_DATAm,
                                   XLPORT_WC_UCMEM_CTRLr);
}

/*
 * Function:
 *      _soc_trident2_port_lanes_update_tdm
 * Description:
 *      Update PGW and MMU TDM programming for flex port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 */
STATIC int
_soc_trident2_port_lanes_update_tdm(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg, *reg_list;
    soc_mem_t mem;
    soc_field_t field;
    int port_base, phy_port_base, mmu_port_base, pgw_inst;
    int block_info_idx, bindex;
    int cur_ids[4], cur_ids_len;
    int ids[4], ids_len;
    int pipe, base, index, slot, slot_len, seq, count, i;
    int base_end;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    uint32 rval, fval;
    static soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;

    static soc_mem_t mmu_tdm_fields[2] ={
        PORT_NUM_EVENf, PORT_NUM_ODDf
    };

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    /* Construct new and old physical port list for calendar replacement */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    ids[0] = cur_ids[0] = phy_port_base;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update PGW line rate ports or oversubscription ports TDM */
    reg_list = lanes_ctrl->oversub ? pgw_ovs_tdm_regs : pgw_tdm_regs;
    pgw_inst = (si->port_group[port_base] & 0x6) | SOC_REG_ADDR_INSTANCE_MASK;
    seq = 0;
    /* if oversub then TDM have _TD2_PGW_TDM_LENGTH registers */
    base_end = lanes_ctrl->oversub ? _TD2_PGW_TDM_LENGTH : 
                                     GET_PGW_TDM_LENGTH(unit);
    for (base = 0; base < base_end; base += _PGW_TDM_SLOTS_PER_REG) {
        reg = reg_list[base / _PGW_TDM_SLOTS_PER_REG];
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, pgw_inst, 0, &rval64));
        count = 0;
        for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
            slot = base + index;
            fval = soc_reg64_field32_get(unit, reg, rval64,
                                         pgw_tdm_fields[slot]);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match */
                continue;
            }
            if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
                LOG_CLI((BSL_META_U(unit,
                                    "set PGW_CL%d TDM slot %d from %d to %d\n"),
                         pgw_inst & ~SOC_REG_ADDR_INSTANCE_MASK, slot,
                         fval, ids[seq % ids_len]));
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, pgw_inst, 0, rval64));
        }
    }

    /* Update oversubscription buffer manager (OBM) */
    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_PGW_CL) {
            bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
            break;
        }
    }
    reg = td2_pgw_obm_ctrl_regs[bindex / _TD2_XLPS_PER_PGW];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, port_base, 0, &rval64));
    if (soc_reg64_field32_get(unit, reg, rval64,
                              td2_pgw_obm_oversub_fields[bindex & 3])) {
        /* The device does not support OBM bypass while operating in OS mode
         * on a 10GbE/20GbE */
        fval = (lanes_ctrl->lanes == 4) ? 1 : 0;
        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
            soc_reg64_field32_set(unit, reg, &rval64,
                                  td2_pgw_obm_bypass_fields[index], fval);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, port_base, 0, rval64));
    }

    /* Construct new and old MMU port list for calendar replacement */
    mmu_port_base = si->port_p2m_mapping[phy_port_base];
    ids[0] = cur_ids[0] = mmu_port_base & 0x3f;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] =
                si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update MMU TDM */
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;
    reg = mmu_tdm_regs[pipe];
    mem = mmu_tdm_mems[pipe];
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    slot_len = (soc_reg_field_get(unit, reg, rval, CAL0_ENDf) + 1) * 2;
    slot_len -= soc_reg_field_get(unit, reg, rval, CAL0_END_SINGLEf);
    seq = 0;
    for (slot = 0; slot < slot_len; slot += 2) {
        count = 0;
        SOC_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        for (index = 0; index < 2; index++) {
            if (slot + index >= slot_len){
                break;
            }
            field = mmu_tdm_fields[index];
            fval = soc_mem_field32_get(unit, mem, entry, field);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match found */
                continue;
            }
            if (LOG_CHECK(BSL_LS_SOC_TDM | BSL_INFO)) {
                LOG_CLI((BSL_META_U(unit,
                                    "set MMU pipe %d TDM slot %d from %d to %d\n"),
                         pipe, slot + index, fval, ids[seq % ids_len]));
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_mem_field32_set(unit, mem, entry, field,
                                    ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        }
    }

    if (lanes_ctrl->oversub) {
        if (lanes_ctrl->slot == -1) { /* new group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->group];
            rval = 0;
            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  lanes_ctrl->weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
            lanes_ctrl->slot = 0;
        }
        if (lanes_ctrl->cur_empty) { /* last entry of the current group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->cur_group];
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, 0));
        }
        /* Add into new group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
        rval = 0;
        if (!SOC_IS_TD2P_TT2P(unit)) {
            soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf,
                          si->port_serdes[port_base] & 0xf);
        }
        for (i = 0; i < ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, ids[i]);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->slot + i * count, rval));
        }
        /* Remove from current group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->cur_group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
        rval = 0;
        for (i = 0; i < cur_ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->cur_slot + i * count, rval));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_trident2_port_mode_to_portmod
 * Description:
 *      Convert TD2/HW port mode value to Portmod port mode
 * Parameters:
 *      hw_mode - TD2 port mode. SOC_TD2_PORT_MODE_XXX
 *      portmod_mode - (OUT) Portmod port mode. portmodPortModeXXX
 */
STATIC int
_soc_trident2_port_mode_to_portmod(int hw_mode, int *portmod_mode)
{
#ifdef PORTMOD_SUPPORT
    switch (hw_mode) {
        case SOC_TD2_PORT_MODE_QUAD:
            *portmod_mode = portmodPortModeQuad;
            break;
        case SOC_TD2_PORT_MODE_TRI_012:
            *portmod_mode = portmodPortModeTri012;
            break;
        case SOC_TD2_PORT_MODE_TRI_023:
            *portmod_mode = portmodPortModeTri023;
            break;
        case SOC_TD2_PORT_MODE_DUAL:
            *portmod_mode = portmodPortModeDual;
            break;
        case SOC_TD2_PORT_MODE_SINGLE:
            *portmod_mode = portmodPortModeSingle;
            break;
        default:
            return SOC_E_FAIL;
    }

    return SOC_E_NONE;

#else  /* PORTMOD_SUPPORT */
    return SOC_E_UNAVAIL;
#endif /* PORTMOD_SUPPORT */
}

/*
 * Function:
 *      _soc_trident2_port_mode_from_portmod
 * Description:
 *      Convert Portmod port mode to TD2/HW port mode value
 * Parameters:
 *      portmod_mode - Portmod port mode. portmodPortModeXXX
 *      hw_mode - (OUT) TD2 port mode. SOC_TD2_PORT_MODE_XXX
 */
STATIC int
_soc_trident2_port_mode_from_portmod(int portmod_mode, int *hw_mode)
{
#ifdef PORTMOD_SUPPORT
    switch (portmod_mode) {
        case portmodPortModeQuad:
            *hw_mode = SOC_TD2_PORT_MODE_QUAD;
            break;
        case portmodPortModeTri012:
            *hw_mode = SOC_TD2_PORT_MODE_TRI_012;
            break;
        case portmodPortModeTri023:
            *hw_mode = SOC_TD2_PORT_MODE_TRI_023;
            break;
        case portmodPortModeDual:
            *hw_mode = SOC_TD2_PORT_MODE_DUAL;
            break;
        case portmodPortModeSingle:
            *hw_mode = SOC_TD2_PORT_MODE_SINGLE;
            break;
        default:
            return SOC_E_FAIL;
    }

    return SOC_E_NONE;

#else  /* PORTMOD_SUPPORT */
    return SOC_E_UNAVAIL;
#endif /* PORTMOD_SUPPORT */
}

/*
 * Function:
 *      soc_trident2_port_lanes_validate
 * Description:
 *      Validate if the specified number of lanes can be configured on a port,
 *      If the request can be done, fill in the control structure which will
 *      be used by the routines programming the hardware.
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 *
 * Each TSC can be configured into following 5 mode:
 *   Lane number    0    1    2    3
 *   ------------  ---  ---  ---  ---
 *    single port  40G   x    x    x
 *      dual port  20G   x   20G   x
 *   tri_023 port  20G   x   10G  10G
 *   tri_012 port  10G  10G  20G   x
 *      quad port  10G  10G  10G  10G
 *
 *          lanes                mode         valid lane index
 *       ------------      ----------------   ----------------
 *       new  current        new    current
 *       ---  -------      -------  -------
 * #1     4      1         single    quad            0
 * #2     4      1         single   tri_012          0
 * #3     4      2         single   tri_023          0
 * #4     4      2         single    dual            0
 * #5     2      1         tri_023   quad            0
 * #6     2      1         tri_012   quad            2
 * #7     2      1          dual    tri_023          2
 * #8     2      1          dual    tri_012          0
 * #9     2      4          dual    single           0
 * #10    1      2         tri_023   dual            2
 * #11    1      2         tri_012   dual            0
 * #12    1      2          quad    tri_023          0
 * #13    1      2          quad    tri_012          2
 * #14    1      4          quad    single           0
 * Following mode change requires 2 transition
 *   - from single to tri_023: #9 + #10
 *   - from single to tri_012: #9 + #11
 * Following mode change are the result of lane change on multiple ports
 *   - from quad to dual: #12 + #7 or #13 + #8
 *   - from dual to quad: #10 + #12 or #11 + # 13
 *   - from tri_023 to tri_012: #7 + #11 or #12 + #6
 *   - from tri_012 to tri_023: #8 + #10 or #13 + #5
 *
 * Logical port number will stay the same after conversion, for example
 *     converting single port to dual port, the logical port number of lane 0
 *     will be changed.
 */
int
soc_trident2_port_lanes_validate(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    int port_base, phy_port_base, mmu_port_base, id, i;
    int block_info_idx;
    uint32 rval, fval;
    int subport0, phy_subport0;
    int pipe, group, slot, count;
    int speed_max, cur_speed_max;
    int wt_group = 0;
    int osg_bitmap;
    int port_mode;

    /* Trident2+ has different registers so pointer will be changed later */
    mmu_ovs_group_wt_regs_t mmu_ovs_group_wt_regs = mmu_ovs_group_wt_regs_local;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    mmu_ovs_group_wt_regs = get_mmu_ovs_group_wt_regs ( unit, mmu_ovs_group_wt_regs );
#endif

    /* Find physical and mmu port number for the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    lanes_ctrl->oversub = SOC_PBMP_MEMBER(si->oversub_pbm, port_base);

    if (lanes_ctrl->oversub && lanes_ctrl->lanes == 2) {
        if (!soc_property_get(unit, spn_20G_OVERSUB_PORT_FLEXPORT_ENABLE, 0)) {
            /* Does not allow doing flex port to 2 lanes on oversub */
            return SOC_E_PARAM;
        }
    }

    /* Find lane index for the specified port (base port) */
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                break;
            }
        }
    }
    lanes_ctrl->bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);

    /* Get the current mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_get(unit, port_base,
                                        &port_mode,
                                        &lanes_ctrl->cur_lanes));
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_mode_from_portmod(port_mode,
                                                  &lanes_ctrl->cur_mode));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
        lanes_ctrl->cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                                 XPORT0_CORE_PORT_MODEf);

        /* Figure out the current number of lanes */
        switch (lanes_ctrl->cur_mode) {
            case SOC_TD2_PORT_MODE_QUAD:
                lanes_ctrl->cur_lanes = 1;
                break;
            case SOC_TD2_PORT_MODE_TRI_012:
                lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 1 : 2;
                break;
            case SOC_TD2_PORT_MODE_TRI_023:
                lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 2 : 1;
                break;
            case SOC_TD2_PORT_MODE_DUAL:
                lanes_ctrl->cur_lanes = 2;
                break;
            case SOC_TD2_PORT_MODE_SINGLE:
                lanes_ctrl->cur_lanes = 4;
                break;
            default:
                return SOC_E_FAIL;
        }
    }

    /* Validate new number of lanes */
    if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
        if (lanes_ctrl->bindex & 0x3) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes == 2 || lanes_ctrl->cur_lanes == 2) {
        if (lanes_ctrl->bindex & 0x1) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes != 1) {
        return SOC_E_PARAM;
    }

    /* No change to number of lanes */
    if (lanes_ctrl->lanes == lanes_ctrl->cur_lanes) {
        return SOC_E_NONE;
    }

    /* Get valid Oversub Speed Group bitmap */
    osg_bitmap = si->port_osg_bitmap[phy_port_base];

    if (lanes_ctrl->oversub) {
        mmu_port_base = si->port_p2m_mapping[phy_port_base];
        phy_subport0 = ((phy_port_base - 1) & ~0x3) + 1;
        subport0 = si->port_p2l_mapping[phy_subport0];
        pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

        /* Figure out the new speed group */
        speed_max = si->port_speed_max[subport0] * lanes_ctrl->lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->weight = (speed_max > 2500 ? speed_max : 2500) / 2500;

        /* Figure out the current speed group */
        cur_speed_max = si->port_speed_max[subport0] * lanes_ctrl->cur_lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->cur_weight =
            (cur_speed_max > 2500 ? cur_speed_max : 2500) / 2500;

        lanes_ctrl->group = -1;
        lanes_ctrl->slot = -1;
        lanes_ctrl->cur_group = -1;
        lanes_ctrl->cur_slot = -1;

        for (group = 0; group < _TD2_MMU_OVS_GROUP_COUNT ; group++) {
            if (!(osg_bitmap & (0x1 << group))) {
                continue;
            }
            if (SOC_IS_TD2P_TT2P(unit)) {
                if ( speed_max <= 11000 ) {
                    wt_group = td2p_ovs_wt_group_speed_10G;
                } else if ( speed_max <= 21000 ) {
                    wt_group = td2p_ovs_wt_group_speed_20G;
                } else if ( speed_max <= 42000 ) {
                    wt_group = td2p_ovs_wt_group_speed_40G;
                } else {
                    wt_group = td2p_ovs_wt_group_speed_NA; /* "not" valid group */
                }
            } else {
                wt_group = group;
            }

            reg = mmu_ovs_group_wt_regs[pipe][wt_group];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            fval = soc_reg_field_get(unit, reg, rval, WEIGHTf);
            if (fval == 0) { /* unused group */
                if (lanes_ctrl->group == -1) {
                    lanes_ctrl->group = wt_group;
                }
                continue;
            } else if (fval == lanes_ctrl->weight) {
                if (lanes_ctrl->slot == -1) {
                    /* Find a slot for new group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        if (soc_reg_field_get(unit, reg, rval, MMU_PORTf) ==
                            0x3f) {
                            lanes_ctrl->group = wt_group;
                            lanes_ctrl->slot = slot;
                            break;
                        }
                    }
                }
            } else if (fval == lanes_ctrl->cur_weight) {
                if (lanes_ctrl->cur_slot == -1) {
                    /* Find the slot used by the currnet group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
                    lanes_ctrl->cur_empty = TRUE;
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        id = soc_reg_field_get(unit, reg, rval, MMU_PORTf);
                        if (id == (mmu_port_base & 0x3f)) {
                            lanes_ctrl->cur_group = group;
                            lanes_ctrl->cur_slot = slot;
                        } else if (id != 0x3f) {
                            lanes_ctrl->cur_empty = FALSE;
                        }
                        if (lanes_ctrl->cur_slot != -1 &&
                            !lanes_ctrl->cur_empty) {
                            break;
                        }
                    }
                }
            }
            if (lanes_ctrl->slot != -1 && lanes_ctrl->cur_slot != -1) {
                break;
            }
        }

        if (lanes_ctrl->cur_group == -1) {
            return SOC_E_CONFIG;
        }

        if (lanes_ctrl->group == -1) {
            return SOC_E_FULL;
        }
    }

    /* Figure out new mode */
    if (lanes_ctrl->lanes == 4) {
        lanes_ctrl->mode = SOC_TD2_PORT_MODE_SINGLE;
    } else if (lanes_ctrl->lanes == 2) {
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_023 : SOC_TD2_PORT_MODE_TRI_012;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_DUAL;
        }
    } else{
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_DUAL) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_012 : SOC_TD2_PORT_MODE_TRI_023;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_QUAD;
        }
    }

    lanes_ctrl->phy_ports_len = 0;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* Figure out which port(s) to be removed */
        if (lanes_ctrl->lanes == 4) {
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_012 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 1;
                }
            }
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_023 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 1;
            }
        }
    } else { /* Figure out which port(s) to be added */
        if (lanes_ctrl->lanes == 2) {
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                    phy_port_base + 1;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_SINGLE) {
                if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 2;
                }
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        }
    }

    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        static char *mode_name[] = {
            "QUAD", "TRI_012", "TRI_023", "DUAL", "SINGLE"
        };
        LOG_CLI((BSL_META_U(unit,
                            "port %d physical port %d bindex %d OSG 0x%x\n"),
                 port_base, phy_port_base, lanes_ctrl->bindex, osg_bitmap));
        LOG_CLI((BSL_META_U(unit,
                            "  mode (new:%s cur:%s) lanes (new:%d cur:%d)\n"),
                 mode_name[lanes_ctrl->mode],
                 mode_name[lanes_ctrl->cur_mode],
                 lanes_ctrl->lanes, lanes_ctrl->cur_lanes));
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            LOG_CLI((BSL_META_U(unit,
                                "  %s physical port %d (port %d)\n"),
                     lanes_ctrl->lanes > lanes_ctrl->cur_lanes ?
                     "del" : "add",
                     lanes_ctrl->phy_ports[i],
                     si->port_p2l_mapping[lanes_ctrl->phy_ports[i]]));
        }
        if (lanes_ctrl->group != -1) {
            LOG_CLI((BSL_META_U(unit,
                                "new group %d slot %d\n"),
                     lanes_ctrl->group, lanes_ctrl->slot));
        }
        LOG_CLI((BSL_META_U(unit,
                            "cur group %d slot %d\n"),
                 lanes_ctrl->cur_group, lanes_ctrl->cur_slot));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_port_icc_width_update(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    int num_lanes;
    int count_width = 0;
    int port;

    if (!soc_feature(unit, soc_feature_static_repl_head_alloc)) {
        if (SOC_REG_IS_VALID(unit, PORT_INITIAL_COPY_COUNT_WIDTHr)) {
            port = lanes_ctrl->port_base;
            if (!IS_CPU_PORT(unit, port) && !IS_LB_PORT(unit, port)) {
                num_lanes = lanes_ctrl->lanes;
                switch (num_lanes) {
                    case 1: count_width = 1;
                            break;
                    case 2: count_width = 2;
                            break;
                    case 4: count_width = 3;
                            break;
                    default: count_width = 0;
                             break;
                }
            }
            if (SOC_REG_FIELD_VALID(unit, PORT_INITIAL_COPY_COUNT_WIDTHr, 
                    BIT_WIDTHf)) {
                SOC_IF_ERROR_RETURN(
                    soc_reg_field32_modify(unit, PORT_INITIAL_COPY_COUNT_WIDTHr,
                        port, BIT_WIDTHf, count_width ? (count_width - 1) : 0));                    
            }
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_set
 * Description:
 *      Configure number of lanes used by a port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 * Notes: Caller needs to call soc_trident2_port_lanes_validate to fill
 *        in the control structure.
 */
int
soc_trident2_port_lanes_set(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    int rv;
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    soc_field_t fields[2];
    uint32 values[2];
    int pipe, port_base, phy_port_base, port, mmu_port, i;
    uint32 rval;
    int port_mode;
    egr_enable_entry_t entry;
    uint32 egress_per_port_buffer_entry[SOC_MAX_MEM_WORDS];
    static soc_reg_t mmu_port_credit_regs[] = {
        ES_PIPE0_MMU_PORT_CREDITr, ES_PIPE1_MMU_PORT_CREDITr
    };
    static soc_reg_t egr_reset_regs[] = {
        EGR_XLPORT_BUFFER_SFT_RESET_0_Xr, EGR_XLPORT_BUFFER_SFT_RESET_1_Xr,
        EGR_XLPORT_BUFFER_SFT_RESET_0_Yr, EGR_XLPORT_BUFFER_SFT_RESET_1_Yr
    };
    static soc_field_t egr_reset_fields[] = {
        XLP0_RESETf, XLP1_RESETf, XLP2_RESETf, XLP3_RESETf,
        XLP4_RESETf, XLP5_RESETf, XLP6_RESETf, XLP7_RESETf,
        XLP8_RESETf, XLP9_RESETf, XLP10_RESETf, XLP11_RESETf,
        XLP12_RESETf, XLP13_RESETf, XLP14_RESETf, XLP15_RESETf
    };

    /* Find physical port number and lane index of the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

    /* Update soc_control information */
    SOC_CONTROL_LOCK(unit);
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port);
        }
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, port);
        }
    }

    /* Update num of lanes info which is used by SerDes driver */
    SOC_PORT_NUM_LANES_SET(unit, port_base, lanes_ctrl->lanes);
    for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
        port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
        si->port_num_lanes[port] =
            lanes_ctrl->lanes > lanes_ctrl->cur_lanes ? 0 : lanes_ctrl->lanes;
    }
    SOC_CONTROL_UNLOCK(unit);

    /* De-assert EGR_ENABLE */
    sal_memset(&entry, 0, sizeof(entry));
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    /* Change XLPROT mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_mode_to_portmod(lanes_ctrl->mode, &port_mode));
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_set(unit, port_base, port_mode));
    } else {
        fields[0] = XPORT0_CORE_PORT_MODEf;
        values[0] = lanes_ctrl->mode;
        fields[1] = XPORT0_PHY_PORT_MODEf;
        values[1] = lanes_ctrl->mode;
        SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit, XLPORT_MODE_REGr,
                                                    port_base, 2, fields, values));
    }

    if (lanes_ctrl->phy_ports_len > 0) {
        /* Update TDM */
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_lanes_update_tdm(unit, lanes_ctrl));
    }

    /* Clear MMU port credit before Resetting egress */
    reg = mmu_port_credit_regs[pipe];
    mmu_port = si->port_p2m_mapping[phy_port_base];
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            mmu_port = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]];
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
        }
    }

    if ((SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TITAN2PLUS(unit))) {
        sal_memset(egress_per_port_buffer_entry, 0, SOC_MAX_MEM_WORDS);
        SOC_IF_ERROR_RETURN(
                WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                    phy_port_base, egress_per_port_buffer_entry));
        if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
            for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
                SOC_IF_ERROR_RETURN(
                        WRITE_EGR_PER_PORT_BUFFER_SFT_RESETm(unit, MEM_BLOCK_ALL,
                            lanes_ctrl->phy_ports[i], egress_per_port_buffer_entry));
            }
        }
    }
    else if (SOC_IS_TRIDENT2(unit)) {
        /* Reset egress hardware resource */
        reg = egr_reset_regs[si->port_serdes[port_base] / 8];
        fields[0] = egr_reset_fields[si->port_serdes[port_base] % 16];
        if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
            /* reset all 4 lanes */
            values[0] = 4;
        } else if (lanes_ctrl->bindex == 0) { /* reset lanes 0 and 1 */
            values[0] = 1;
        } else { /* reset lanes 2 and 3 */
            values[0] = 2;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        soc_reg_field_set(unit, reg, &rval, fields[0], values[0]);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
        soc_reg_field_set(unit, reg, &rval, fields[0], 0);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    }

    /* Update PORT_INITIAL_COPY_COUNT_WIDTH registers */
    rv = _soc_trident2_port_icc_width_update(unit, lanes_ctrl);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                    "Update PORT_INITIAL_COPY_COUNT_WIDTH registers fail.")));
        return rv;
    }

    /* Assert EGR_ENABLE */
    soc_mem_field32_set(unit, EGR_ENABLEm, &entry, PRT_ENABLEf, 1);
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_get
 * Description:
 *      Get number of lanes currently used by a port
 * Parameters:
 *      unit          - Device number
 *      port_base     - Port number
 *      cur_lanes     - (OUT) Number of lanes current configured on the port
 */
int
soc_trident2_port_lanes_get(int unit, soc_port_t port_base, int *cur_lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    int cur_mode;
    int phy_port_base, i;
    int block_info_idx, bindex;
    uint32 rval;

    /* Find physical port number and lane index of the specified port */
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }

    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        }
    }

    /* Get the current mode */
    if (SOC_USE_PORTCTRL(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_portctrl_port_mode_get(unit, port_base,
                                        &cur_mode, 
                                        cur_lanes));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
        cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                     XPORT0_CORE_PORT_MODEf);

        /* Figure out the current number of lane from current mode */
        switch (cur_mode) {
            case SOC_TD2_PORT_MODE_QUAD:
                *cur_lanes = 1;
                break;
            case SOC_TD2_PORT_MODE_TRI_012:
                *cur_lanes = bindex == 0 ? 1 : 2;
                break;
            case SOC_TD2_PORT_MODE_TRI_023:
                *cur_lanes = bindex == 0 ? 2 : 1;
                break;
            case SOC_TD2_PORT_MODE_DUAL:
                *cur_lanes = 2;
                break;
            case SOC_TD2_PORT_MODE_SINGLE:
                *cur_lanes = 4;
                break;
            default:
                return SOC_E_FAIL;
        }
    }

    return SOC_E_NONE;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r,
    TOP_PVTMON_RESULT_4r, TOP_PVTMON_RESULT_5r,
    TOP_PVTMON_RESULT_6r, TOP_PVTMON_RESULT_7r,
    TOP_PVTMON_RESULT_8r
};

int
soc_trident2_temperature_monitor_get(int unit, 
            int temperature_max,
            soc_switch_temperature_monitor_t *temperature_array,
            int *temperature_count)
{
    soc_reg_t reg;
    int index;
    uint32 rval;
    int fval, cur, peak;
    int num_entries_out;
    soc_field_t pvtmon_field_data = TEMP_DATAf;
    soc_field_t pvtmon_field_peak = PEAK_TEMP_DATAf;
    soc_field_t top_soft_rst_field = TOP_TEMP_MON_PEAK_RST_Lf;
    int max_value = 4100000;
    int mult = 5424;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        pvtmon_field_data = PVT_DATAf;
        pvtmon_field_peak = MIN_PVT_DATAf;
        top_soft_rst_field = TOP_PVT_MON_MIN_RST_Lf;

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, AVS_REG_HW_MNTR_SW_CONTROLSr,
                REG_PORT_ANY, SW_TAKEOVERf, 1));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                AVS_REG_PVT_MNTR_CONFIG_PVT_MNTR_TP_MODE_ENABLEr,
                REG_PORT_ANY, TP_MODE_ENf, 1));
        max_value = 4100400;
        mult = 4870;
    }
#endif

    if (temperature_count) {
        *temperature_count = 0;
    }
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 0));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                PVTMON_ADC_RESETBf, 1));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 0);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MAX_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  TOP_PVT_MON_MIN_RST_Lf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    }
#endif

    sal_usleep(1000);

    for (index = 0; index < num_entries_out; index++) {
        peak = 0;
        cur = 0;
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        cur = (max_value - (mult * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_peak);
        peak = (max_value - (mult * fval)) / 1000;
        if (temperature_array) {
            (temperature_array + index)->curr = cur;
            (temperature_array + index)->peak = peak;
        }
    }

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                  top_soft_rst_field, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, AVS_REG_HW_MNTR_SW_CONTROLSr,
                REG_PORT_ANY, SW_TAKEOVERf, 0));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                AVS_REG_PVT_MNTR_CONFIG_PVT_MNTR_TP_MODE_ENABLEr,
                REG_PORT_ANY, TP_MODE_ENf, 0));
    }
#endif
    if (temperature_count) {
        *temperature_count=num_entries_out;
    }
    return SOC_E_NONE;
}

int
soc_trident2_show_material_process(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, nmos[COUNTOF(pvtmon_result_reg)], n_avg, p_avg;
    soc_field_t pvtmon_field_data = TEMP_DATAf;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        pvtmon_field_data = PVT_DATAf;
    }
#endif

    READ_TOP_PVTMON_CTRL_1r(unit, &rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 1));
    sal_usleep(1000);

    p_avg = 0;

    /* Read NMOS information */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 5));

    sal_usleep(1000);

    n_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        nmos[index] = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        n_avg += nmos[index];
    }

    /* Read PMOS information and print both NMOS and PMOS value */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 7));

    sal_usleep(1000);

    p_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, pvtmon_field_data);
        p_avg += fval;

        LOG_CLI((BSL_META_U(unit,
                            "Material process location %d: NMOS = %3d PMOS = %3d\n"),
                 index, nmos[index], fval));
    }

    LOG_CLI((BSL_META_U(unit,
                        "Average:                     NMOS = %3d PMOS = %3d\n"),
             n_avg / COUNTOF(pvtmon_result_reg),
             p_avg / COUNTOF(pvtmon_result_reg)));

    return SOC_E_NONE;
}

int
soc_trident2_show_ring_osc(int unit)
{
    static const struct {
        int osc_sel;
        soc_field_t field0;
        int value0;
        soc_field_t field1;
        int value1;
        char *name;
    } osc_tbl[] = {
        { 0, OSC_0_SELf, 0, INVALIDf, -1, "IO ring 0 HVT min" },
        { 0, OSC_0_SELf, 1, INVALIDf, -1, "IO ring 0 HVT mid" },
        { 0, OSC_0_SELf, 2, INVALIDf, -1, "IO ring 0 HVT max" },
        { 0, OSC_0_SELf, 3, INVALIDf, -1, "IO ring 0 SVT min" },
        { 1, OSC_1_SELf, 0, INVALIDf, -1, "IO ring 1 HVT min" },
        { 1, OSC_1_SELf, 1, INVALIDf, -1, "IO ring 1 HVT mid" },
        { 1, OSC_1_SELf, 2, INVALIDf, -1, "IO ring 1 HVT max" },
        { 1, OSC_1_SELf, 3, INVALIDf, -1, "IO ring 1 SVT min" },
        { 2, IROSC_SELf, 0, INVALIDf, -1, "Core ring 0 five stages" },
        { 2, IROSC_SELf, 1, INVALIDf, -1, "Core ring 0 nine stages" },
        { 3, IROSC_SELf, 0, INVALIDf, -1, "Core ring 1 five stages" },
        { 3, IROSC_SELf, 1, INVALIDf, -1, "Core ring 1 nine stages" },
        { 4, SRAM_OSC_0_PENf, 0, SRAM_OSC_0_NENf, 1, "SRAM ring 0 NMOS" },
        { 5, SRAM_OSC_0_PENf, 1, SRAM_OSC_0_NENf, 0, "SRAM ring 0 PMOS" },
        { 6, SRAM_OSC_1_PENf, 0, SRAM_OSC_1_NENf, 1, "SRAM ring 1 NMOS" },
        { 7, SRAM_OSC_1_PENf, 1, SRAM_OSC_1_NENf, 0, "SRAM ring 1 PMOS" },
        { 8, SRAM_OSC_2_PENf, 0, SRAM_OSC_2_NENf, 1, "SRAM ring 2 NMOS" },
        { 9, SRAM_OSC_2_PENf, 1, SRAM_OSC_2_NENf, 0, "SRAM ring 2 PMOS" },
        { 10, SRAM_OSC_3_PENf, 0, SRAM_OSC_3_NENf, 1, "SRAM ring 3 NMOS" },
        { 11, SRAM_OSC_3_PENf, 1, SRAM_OSC_3_NENf, 0, "SRAM ring 3 PMOS" },
        { 12, SRAM_OSC_4_PENf, 0, SRAM_OSC_4_NENf, 1, "SRAM ring 4 NMOS" },
        { 13, SRAM_OSC_4_PENf, 1, SRAM_OSC_4_NENf, 0, "SRAM ring 4 PMOS" },
        { 14, SRAM_OSC_5_PENf, 0, SRAM_OSC_5_NENf, 1, "SRAM ring 5 NMOS" },
        { 15, SRAM_OSC_5_PENf, 1, SRAM_OSC_5_NENf, 0, "SRAM ring 5 PMOS" },
    };
    soc_reg_t ctrl_reg, stat_reg;
    uint32 rval, fval;
    int index, core_clk, quo, rem, frac, retry;

    core_clk = SOC_INFO(unit).frequency * 1024;
    ctrl_reg = TOP_RING_OSC_CTRLr;
    stat_reg = TOP_OSC_COUNT_STATr;

    for (index = 0; index < COUNTOF(osc_tbl); index++) {
        rval = 0;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            if (OSC_0_SELf == osc_tbl[index].field0
                || OSC_1_SELf == osc_tbl[index].field0) {
                continue;
            }
        }
#endif
        /*
         * set OSC_CNT_RSTBf to 0 to do softreset
         * set OSC_CNT_START to 0 to hold the counter until it selects
         * the input signal
         */
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_ENABLEf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_ENf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field0,
                          osc_tbl[index].value0);
        if (osc_tbl[index].field1 != INVALIDf) {
            soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field1,
                              osc_tbl[index].value1);
        }
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_SELf,
                          osc_tbl[index].osc_sel);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_RSTBf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_STARTf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));

        for (retry = 0; retry < 10; retry++) {
            sal_usleep(1000);
            SOC_IF_ERROR_RETURN(READ_TOP_OSC_COUNT_STATr(unit, &rval));
            if (!soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_DONEf)) {
                continue;
            }

            fval = soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_VALUEf);
            quo = core_clk / fval;
            rem = core_clk - quo * fval;
            frac = (rem * 10000) / fval;
            LOG_CLI((BSL_META_U(unit,
                                "%s: %d.%04d Mhz\n"),
                     osc_tbl[index].name, quo, frac));
            break;
        }
    }

    return SOC_E_NONE;
}

void
soc_td2_process_func_intr(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32 rval;

    if (soc_feature(unit, soc_feature_l2_overflow)) {
        if (READ_IL2LU_INTR_STATUSr(unit, &rval)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d: Error reading %s reg !!\n"),
                                  unit, SOC_REG_NAME(unit, IL2LU_INTR_STATUSr)));
            return;
        }
        if (soc_reg_field_get(unit, IL2LU_INTR_STATUSr, rval, L2_LEARN_INSERT_FAILUREf)) {
            soc_td2_l2_overflow_interrupt_handler(unit);
        } 
    } 
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d1 != NULL) {
        (void)soc_cmicm_intr1_enable(unit, PTR_TO_INT(d1));
    }
}

int
soc_td2_port_asf_speed_set(int unit, soc_port_t port, int speed)
{
    uint32 asf_speed_mode;
    uint32 rval; 

    SOC_IF_ERROR_RETURN(READ_ASF_PORT_CFGr(unit, port, &rval));

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit)) {
        switch (speed) {
        case 10:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_10M_FULL;
            break;
        case 100:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_100M_FULL;
            break;
        case 1000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_1000M_FULL;
            break;
        case 2500:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_2500M_FULL;
            break;
        case 10000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_10000M_FULL;
            break;
        case 11000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_11000M_FULL;
            break;
        case 12000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_12000M_FULL;
            break;
        case 13000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_13000M_FULL;
            break;
        case 15000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_15000M_FULL;
            break;
        case 16000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_16000M_FULL;
            break;
        case 20000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_20000M_FULL;
            break;
        case 21000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_21000M_FULL;
            break;
        case 25000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_25000M_FULL;
            break;
        case 30000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_30000M_FULL;
            break;
        case 40000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_40000M_FULL;
            break;
        case 42000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_42000M_FULL;
            break;
        case 100000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_100000M_FULL;
            break;
        case 106000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_106000M_FULL;
            break;
        case 120000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_120000M_FULL;
            break;
        case 127000:
            asf_speed_mode = SOC_TD2P_PORT_CT_SPEED_127000M_FULL;
            break;
        case 0:
            return SOC_E_NONE;
        default:
            return SOC_E_PARAM;
        }
    } else
#endif
    {
        switch (speed) {
        case 10:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10M_FULL;
            break;
        case 100:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100M_FULL;
            break;
        case 1000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_1000M_FULL;
            break;
        case 2500:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_2500M_FULL;
            break;
        case 5000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_5000M_FULL;
            break;
        case 10000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10000M_FULL;
            break;
        case 11000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_11000M_FULL;
            break;
        case 12000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_12000M_FULL;
            break;
        case 13000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_13000M_FULL; 
            break; 
        case 15000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_15000M_FULL;
            break;
        case 16000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_16000M_FULL;
            break;
        case 20000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_20000M_FULL;
            break;
        case 21000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_21000M_FULL;
            break;
        case 24000:
        /* As 24G HG is not supported in TD2, so use 24G value of ASF_PORT_CFG
         * (20 = 24Gbps (full duplex)) for HG 25G case */
        case 25000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_24000M_FULL;
            break;
        case 30000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_30000M_FULL;
            break;
        case 32000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_32000M_FULL;
            break;
        case 40000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_40000M_FULL;
            break;
        case 42000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_42000M_FULL;
            break;
        case 100000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100000M_FULL;
            break;
        case 120000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_120000M_FULL;
            break;
        case 0:
            return SOC_E_NONE;
        default:
            return SOC_E_PARAM;
        }
    }

    soc_reg_field_set(unit, ASF_PORT_CFGr, &rval,
                      ASF_PORT_SPEEDf, asf_speed_mode);
    
    SOC_IF_ERROR_RETURN(WRITE_ASF_PORT_CFGr(unit, port, rval));  
    return SOC_E_NONE;
}

int
soc_trident2_port_speed_update(int unit, soc_port_t port, int speed)
{
    soc_info_t *si;
    soc_reg_t reg;
    soc_field_t field;
    uint16 dev_id;
    uint8 rev_id;
    uint32 rval, fval;
    uint64 rval64;
    int block_info_idx;
    int pipe, xlp, obm_inst, phy_port, mmu_port, index, i;
    int asf_credit_thresh_lo, asf_credit_thresh_hi;
    int max_quad_core_bandwidth, quad_oversub_core_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    egr_edb_xmit_ctrl_entry_t entry;
    int lossless;
    int obm_setting_idx, oversub_ratio_idx;
    int min_threshold, xoff_threshold, xon_threshold, xon_threshold_offset;
    static const struct _obm_setting_s {
        int max_threshold;
        int xoff_threshold[3]; /* for oversub ratio 1.27, 1.43, and above */
    } obm_settings[] = {
        { _TD2_TD2_CELLS_PER_OBM / 4, { 79, 26, 37 } },      /* 10G */
        { _TD2_TD2_CELLS_PER_OBM / 2, { 315, 242, 86 } },    /* 20G */
        { _TD2_TD2_CELLS_PER_OBM, { 707, 584, 339 } },       /* 40G */
        { _TD2_TD2_CELLS_PER_OBM }                           /* 42G */
    };
    static soc_reg_t asf_credit_thresh_lo_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_LOr, ES_PIPE1_ASF_CREDIT_THRESH_LOr
    };
    static soc_reg_t asf_credit_thresh_hi_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_HIr, ES_PIPE1_ASF_CREDIT_THRESH_HIr
    };
    static soc_field_t t2oq_fields[] = {
        IS_MC_T2OQ_PORT0f, IS_MC_T2OQ_PORT1f
    };

    soc_cm_get_id_otp(unit, &dev_id, &rev_id);
    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    si = &SOC_INFO(unit);
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;

    /* Update Edatabuf transmit start count */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit)) {
        int cut_thru_enable = FALSE;

        SOC_IF_ERROR_RETURN(soc_td2p_is_cut_thru_enabled(
                                    unit, port, &cut_thru_enable));
        if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
            SOC_IF_ERROR_RETURN(soc_td2p_egr_edb_xmit_ctrl_set(
                                    unit, phy_port, speed,
                                    1 /*oversub*/, cut_thru_enable));
        } else {
            SOC_IF_ERROR_RETURN(soc_td2p_egr_edb_xmit_ctrl_set(
                                    unit, phy_port, speed,
                                    0 /*oversub*/, cut_thru_enable));
        }
    } else 
#endif
    {
        if (si->frequency == 415 && !SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, EGR_EDB_XMIT_CTRLm,
                                             MEM_BLOCK_ALL, phy_port, &entry));
            soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, &entry, START_CNTf,
                    _TD2_MMU_XMIT_START_CNT_LINERATE(speed));
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                              MEM_BLOCK_ALL, phy_port, &entry));
        }
    }

    /* Updtae VBS (HSP) port multicast T2OQ setting */
    if (SOC_PBMP_MEMBER(si->eq_pbm, port) && si->frequency < 500) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, &rval));
        field = t2oq_fields[pipe];
        fval = soc_reg_field_get(unit, TOQ_MC_CFG1r, rval, field);
        if (speed >= 30000) {
            fval |= 1 << (mmu_port & 0x3f);
        } else {
            fval &= ~(1 << (mmu_port & 0x3f));
        }
        soc_reg_field_set(unit, TOQ_MC_CFG1r, &rval, field, fval);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, rval));

        /* write 0 to Q_NOT_EMPTY field of sister entry locations in MMU_MCQDBx */
        if (speed < 30000) {
            int base;
            int cosq;
            int num;
            mmu_mcqdb0_entry_t mcqdb0_entry;
            mmu_mcqdb1_entry_t mcqdb1_entry;
            base = si->port_cosq_base[port];
            num = si->port_num_cosq[port];
            for (index = 0; index < num; index++) {
                if (pipe == 0) {
                    cosq = base + 360 + index;
                    memset(&mcqdb0_entry, 0, sizeof(mcqdb0_entry));
                    SOC_IF_ERROR_RETURN
                        (READ_MMU_MCQDB0m(unit, MEM_BLOCK_ANY, cosq, &mcqdb0_entry));
                    soc_MMU_MCQDB0m_field32_set(unit, &mcqdb0_entry, Q_NOT_EMPTYf, 0);
                    SOC_IF_ERROR_RETURN
                        (WRITE_MMU_MCQDB0m(unit, MEM_BLOCK_ALL, cosq, &mcqdb0_entry));
                } else {
                    cosq = base - 568 + 360 + index;
                    memset(&mcqdb1_entry, 0, sizeof(mcqdb1_entry));
                    SOC_IF_ERROR_RETURN
                        (READ_MMU_MCQDB1m(unit, MEM_BLOCK_ANY, cosq, &mcqdb1_entry));
                    soc_MMU_MCQDB1m_field32_set(unit, &mcqdb1_entry, Q_NOT_EMPTYf, 0);
                    SOC_IF_ERROR_RETURN
                        (WRITE_MMU_MCQDB1m(unit, MEM_BLOCK_ALL, cosq, &mcqdb1_entry));
                }
            }
        }
    }
    
    if (SOC_PBMP_MEMBER(si->eq_pbm, port)) {
        SOC_IF_ERROR_RETURN(_soc_trident2_mc_toq_cfg(unit, port,
                    (speed >= 40000) ? TRUE : FALSE));
    }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
       /* Update cut through credit threshold */
       if (soc_td2p_use_pfc_optimized_settings(unit)) {
          if (speed > 42000){
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,100G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,100G);
          } else if (speed > 21000){
              if (SOC_PBMP_MEMBER(PBMP_OVERSUB(unit), port)) {
                  asf_credit_thresh_lo =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED_OVERSUB(LO,40G);
                  asf_credit_thresh_hi =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED_OVERSUB(HI,40G);
              } else {
                  asf_credit_thresh_lo =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,40G);
                  asf_credit_thresh_hi =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,40G);
              }
          } else if (speed > 11000) {
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,20G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,20G);
          } else {
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,10G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,10G);
          }
       } else {
          if (speed > 42000){
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,100G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,100G);
          } else if (speed > 21000){
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,40G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,40G);
          } else if (speed > 11000) {
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,20G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,20G);
          } else {
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,10G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,10G);
          }
       }
    } else
#endif
    {
       /* Update cut through credit threshold */
       if (speed > 42000){
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,100G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,100G);
       } else if (speed > 21000){
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,40G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,40G);
       } else if (speed > 11000) {
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,20G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,20G);
       } else {
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,10G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,10G);
       }
    }
    reg = asf_credit_thresh_lo_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_lo);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));
    reg = asf_credit_thresh_hi_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_hi);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));

    SOC_IF_ERROR_RETURN(soc_td2_port_asf_speed_set(unit, port, speed));

    /* Update oversubscription buffer manager (OBM) threshold */
    if (!SOC_IS_TD2P_TT2P(unit) && (rev_id >= BCM56850_A2_REV_ID)) {
        obm_inst = si->port_group[port] | SOC_REG_ADDR_INSTANCE_MASK;

        xlp = 0;
        index = -1;
        for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
            block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port, i);
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_PGW_CL) {
                xlp = SOC_PORT_IDX_BINDEX(unit, phy_port, i) /
                    _TD2_PORTS_PER_XLP;
                index = SOC_PORT_IDX_BINDEX(unit, phy_port, i) %
                    _TD2_PORTS_PER_XLP;
                break;
            }
        }

        reg = td2_pgw_obm_threshold_regs[xlp];
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index, &rval64));

        {
            _soc_trident2_quad_bandwidth_calculate
                (unit, si->port_group[port] / _TD2_PGWS_PER_QUAD,
                 &max_quad_core_bandwidth, &quad_linerate_bandwidth,
                 &quad_oversub_bandwidth);
            quad_oversub_core_bandwidth =
                max_quad_core_bandwidth - quad_linerate_bandwidth;

            if (speed == 42000 && si->port_speed_max[port] > 20000) {
                obm_setting_idx = 3; /* entry 3 in the lookup table */
                xon_threshold_offset = 24; /* xon = xoff - 24 */

            } else if (speed > 20000 && si->port_speed_max[port] > 20000) {
                obm_setting_idx = 2; /* entry 2 in the lookup table */
                xon_threshold_offset = 24; /* xon = xoff - 24 */
            } else if (speed > 10000 && si->port_speed_max[port] > 10000) {
                obm_setting_idx = 1; /* entry 1 in the lookup table */
                xon_threshold_offset = 12; /* xon = xoff - 12 */
            } else {
                obm_setting_idx = 0; /* entry 0 in the lookup table */
                xon_threshold_offset = 6; /* xon = xoff - 6 */
            }

            if (lossless) {
                if (quad_oversub_bandwidth * 2 >
                    quad_oversub_core_bandwidth * 3) {
                    /* oversub ratio greater than 1.5 (3/2) */
                    oversub_ratio_idx = 2;
                } else if (quad_oversub_bandwidth * 3 >
                    quad_oversub_core_bandwidth * 4) {
                    /* oversub ratio greater than 1.33 (4/3) */
                    oversub_ratio_idx = 1;
                } else {
                    oversub_ratio_idx = 0;
                }

                if (speed == 42000) {
                    /* oversub ratio equal to 1.33 (4/3) */
                    xoff_threshold = 632;
                } else {
                    xoff_threshold = obm_settings[obm_setting_idx].
                        xoff_threshold[oversub_ratio_idx];
                }

                xon_threshold = xoff_threshold - xon_threshold_offset;
                min_threshold = xon_threshold + 3;
            } else {
                xoff_threshold = 1023;
                xon_threshold = 1023;
                min_threshold = obm_settings[obm_setting_idx].
                    max_threshold;
            }

            soc_reg64_field32_set(unit, reg, &rval64,
                                  MIN_THRESHOLDf, min_threshold);
            soc_reg64_field32_set
                (unit, reg, &rval64, MAX_THRESHOLDf,
                 obm_settings[obm_setting_idx].max_threshold);
            soc_reg64_field32_set(unit, reg, &rval64,
                                  FLOW_CTRL_XONf, xon_threshold);
            soc_reg64_field32_set(unit, reg, &rval64,
                                  FLOW_CTRL_XOFFf, xoff_threshold);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, obm_inst, index, rval64));
        }

    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            SOC_IF_ERROR_RETURN(soc_td2p_mmu_delay_insertion_set (unit,
                        port, speed));
        }
#endif

    return SOC_E_NONE;
}

int
soc_td2_port_asf_set(int unit, soc_port_t port, int speed)
{
    soc_info_t *si;
    soc_reg_t reg;
    uint32 rval;
    int pipe, phy_port, mmu_port;
    int asf_credit_thresh_lo, asf_credit_thresh_hi;
    static soc_reg_t asf_credit_thresh_lo_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_LOr, ES_PIPE1_ASF_CREDIT_THRESH_LOr
    };
    static soc_reg_t asf_credit_thresh_hi_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_HIr, ES_PIPE1_ASF_CREDIT_THRESH_HIr
    };

    si = &SOC_INFO(unit);
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
       /* Update cut through credit threshold */
       if (soc_td2p_use_pfc_optimized_settings(unit)) {
          if (speed > 42000){
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,100G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,100G);
          } else if (speed > 21000){
              if (SOC_PBMP_MEMBER(PBMP_OVERSUB(unit), port)) {
                  asf_credit_thresh_lo =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED_OVERSUB(LO,40G);
                  asf_credit_thresh_hi =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED_OVERSUB(HI,40G);
              } else {
                  asf_credit_thresh_lo =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,40G);
                  asf_credit_thresh_hi =
                      _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,40G);
              }
          } else if (speed > 11000) {
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,20G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,20G);
          } else {
              asf_credit_thresh_lo = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(LO,10G);
              asf_credit_thresh_hi = _TD2P_MMU_ASF_CREDIT_THRESH_OPTIMIZED(HI,10G);
          }
       } else {
          /* Update cut through credit threshold */
          if (speed > 42000){
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,100G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,100G);
          } else if (speed > 21000){
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,40G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,40G);
          } else if (speed > 11000) {
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,20G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,20G);
          } else {
              asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,10G);
              asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,10G);
          }
       }
    } else 
#endif
    {
       /* Update cut through credit threshold */
       if (speed > 42000){
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,100G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,100G);
       } else if (speed > 21000){
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,40G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,40G);
       } else if (speed > 11000) {
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,20G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,20G);
       } else {
           asf_credit_thresh_lo = _TD2_MMU_ASF_CREDIT_THRESH(LO,10G);
           asf_credit_thresh_hi = _TD2_MMU_ASF_CREDIT_THRESH(HI,10G);
       }
    }
    reg = asf_credit_thresh_lo_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_lo);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));
    reg = asf_credit_thresh_hi_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_hi);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));

    SOC_IF_ERROR_RETURN(soc_td2_port_asf_speed_set(unit, port, speed));

    return SOC_E_NONE;
}

STATIC int
_soc_td2_thdo_hw_get(int unit, soc_port_t port, int *enable)
{
    uint64 rval64;
    int mmu_port, phy_port, i;
    int rv = SOC_E_NONE;
    soc_info_t *si;
    soc_reg_t reg_tmp;
    soc_reg_t reg[3][2] = {
        {
            THDU_OUTPUT_PORT_RX_ENABLE0_64r,
            THDU_OUTPUT_PORT_RX_ENABLE1_64r
        },
        {
            MMU_THDM_DB_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_DB_PORTSP_RX_ENABLE1_64r
        },
        {
            MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r
        }
    };
    int max_reg = 3;

    si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];

    COMPILER_64_ZERO(rval64);

    for (i = 0; i < max_reg; i++) {
        reg_tmp = SOC_TD2_PREG(unit, port, reg[i][0], reg[i][1]);

        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg_tmp, REG_PORT_ANY, 0, &rval64));

        mmu_port &= 0x3f;
        if (COMPILER_64_BITTEST(rval64 , mmu_port)) {
            *enable = TRUE;
        } else {
            *enable = FALSE;
        }
    }
    return rv;
}


STATIC int
_soc_td2_thdo_hw_set(int unit, soc_port_t port, int enable)
{
    uint64 rval64, rval64_tmp;
    int mmu_port, phy_port, i;
    soc_info_t *si;
    soc_reg_t reg_tmp;
    soc_reg_t reg[3][2] = {
        {
            THDU_OUTPUT_PORT_RX_ENABLE0_64r,
            THDU_OUTPUT_PORT_RX_ENABLE1_64r
        },
        {
            MMU_THDM_DB_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_DB_PORTSP_RX_ENABLE1_64r
        },
        {
            MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r,
            MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r
        }
    };

    si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];


    for (i = 0; i < 3; i++) {
        COMPILER_64_ZERO(rval64);
        COMPILER_64_ZERO(rval64_tmp);
        reg_tmp = SOC_TD2_PREG(unit, port, reg[i][0], reg[i][1]);
        
        SOC_IF_ERROR_RETURN(
            soc_reg_get(unit, reg_tmp, REG_PORT_ANY, 0, &rval64));

        mmu_port &= 0x3f;
        if (mmu_port < 32) {
            COMPILER_64_SET(rval64_tmp, 0, 1 << mmu_port);
        } else {
            COMPILER_64_SET(rval64_tmp, 1 << (mmu_port - 32), 0);
        }

        if (enable) {
            COMPILER_64_OR(rval64, rval64_tmp);
        } else {
            COMPILER_64_NOT(rval64_tmp);
            COMPILER_64_AND(rval64, rval64_tmp);
        }

        SOC_IF_ERROR_RETURN(
            soc_reg_set(unit, reg_tmp, REG_PORT_ANY, 0, rval64));
    }
        
    return SOC_E_NONE;    
}


/*
 * Function:
 *      _soc_td2_port_thdo_rx_enable_set
 * Purpose:
 *     enable/disable  the traffic to the port according to
 *     different callers.
 *  the traffic to the port can be enabled only if all of the callers
 *  are to enable it.
 * Parameters:
 *     unit                - (IN) unit number
 *     port                - (IN) local port
 *     enable              - (IN) enable/disable the traffic to the port.
 *     flag                - (IN) different callers.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_soc_td2_port_thdo_rx_enable_set(int unit, soc_port_t port, 
                                 int enable, uint8 flag)
{
    int   rv = SOC_E_NONE;
    uint8 *thdo_drop_bmp;
    _soc_td2_mmu_traffic_ctrl_t *mmu_traffic_ctrl;
    int   cur_enable = 0;

    FWD_CTRL_LOCK(unit);
    
    mmu_traffic_ctrl = _soc_td2_mmu_traffic_ctrl[unit];
    if (mmu_traffic_ctrl ==  NULL) {
        FWD_CTRL_UNLOCK(unit);
        return SOC_E_INIT;
    }
    thdo_drop_bmp = 
        &(mmu_traffic_ctrl->thdo_drop_bmp[port]);
    
    if (!enable) { 
        if (*thdo_drop_bmp & flag) {
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }
        if (*thdo_drop_bmp == 0) {
            rv = _soc_td2_thdo_hw_set(unit, port, enable);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Clear the registers fail.\n")));
                FWD_CTRL_UNLOCK(unit);
                return rv;
            }
        }

        *thdo_drop_bmp |= flag;
        
        FWD_CTRL_UNLOCK(unit);
        return rv;
    } else {
        if (0 == *thdo_drop_bmp) {
            rv = _soc_td2_thdo_hw_get(unit, port, &cur_enable);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Get the registers fail.\n")));
                FWD_CTRL_UNLOCK(unit);
                return rv;
            }
            /* Warmboot: latest value of *thdo_drop_bmp is not sync to WB cache.
            * We execute "sc controlsync=1" when one port is link up. But when we exit SDK,
            * the port is link down, so the conrresponding bit in THDU_OUTPUT_PORT_RX_ENABLE0_64r
            * of the port is zero.  After WarmBoot SDK,
            * we can't set conrresponding bit in THDU_OUTPUT_PORT_RX_ENABLE0_64r
            * for the port when it is link up, because, the value of thdo_drop_bmp is zero.
            */
            if(cur_enable == FALSE) {
                LOG_INFO(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Latest thdo_drop_bmp was not updated to WB cache!!!\n")));
                *thdo_drop_bmp |= flag;
            } 
        }
        if (*thdo_drop_bmp != flag) {
            /*other callers are in thdo drop*/
            *thdo_drop_bmp &= ~flag;
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }

        /*Ok, only self is in thdo drop, enbable it*/
        rv = _soc_td2_thdo_hw_set(unit, port, enable);
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Set the registers fail.\n")));
            FWD_CTRL_UNLOCK(unit);
            return rv;
        }

        *thdo_drop_bmp &= ~flag;

        FWD_CTRL_UNLOCK(unit);
        return rv;
    }

    FWD_CTRL_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 * soc_td2_mmu_rx_enable_set
 * Purpose:
 *     enable/disable mmu rx traffic from the gport.
 * Parameters:
 *     unit       - (IN) unit number
 *     port       - (IN) PORT identifier
 *     enable     - (IN) enable/disable
 * Returns:
 *     BCM_E_XXX
 */
int
soc_td2_mmu_rx_enable_set(int unit, soc_port_t port,
                          int enable)
{
    uint32 rval;

    /* Disable/Enable INPUT_PORT_RX to the port */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, THDI_INPUT_PORT_XON_ENABLESr,
                       port, 0, &rval));

    if (!enable) {
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          INPUT_PORT_RX_ENABLEf,
                          0);
    } else {
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          INPUT_PORT_RX_ENABLEf,
                          1);
    }

    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, THDI_INPUT_PORT_XON_ENABLESr,
                       port, 0, rval));

    return SOC_E_NONE;
}

int
soc_td2_port_traffic_egr_enable_set(int unit, soc_port_t port,
                               int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                            COSQ_SCHED_SET_CTRL);
}

int
soc_td2_port_mmu_tx_enable_set(int unit, soc_port_t port,
                               int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                           MMU_TRAFFIC_EN_CTRL); 
}


int
soc_trident2_port_thdo_rx_enable_set(int unit, soc_port_t port, 
                                     int enable)
{
    return _soc_td2_port_thdo_rx_enable_set(unit, port, enable, 
                                            MAC_ENABLE_SET_CTRL);
}

#if defined(SER_TR_TEST_SUPPORT)

#define MAX_HW_TCAMS 20
typedef struct ser_td2_skipped_mem_s {
    soc_mem_t mem;
    soc_acc_type_t acc_type;
} ser_td2_skipped_mem_t;

const ser_td2_skipped_mem_t td2_skipped_mems[] = {
    {FP_METER_TABLEm, _SOC_ACC_TYPE_PIPE_Y},
    {ING_L3_NEXT_HOPm, _SOC_ACC_TYPE_PIPE_Y},
    {L2MCm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_IPMCm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_X},
    {L2_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_Y},
    {L2_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_LPm, _SOC_ACC_TYPE_PIPE_X},
    {L2Xm, _SOC_ACC_TYPE_PIPE_Y},
    {INVALIDm}
};

#ifdef BCM_TRIDENT2PLUS_SUPPORT
const ser_td2_skipped_mem_t td2p_skipped_mems[] = {
    {FP_METER_TABLEm, _SOC_ACC_TYPE_PIPE_Y},
    {L2MCm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_IPMCm, _SOC_ACC_TYPE_PIPE_Y},
    {L2_BULK_MATCH_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_MATCH_MASKm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_REPLACE_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_BULK_REPLACE_MASKm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_MOD_FIFOm, _SOC_ACC_TYPE_PIPE_ANY},
    {ING_SNAT_ONLYm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_LEARN_INSERT_FAILUREm, _SOC_ACC_TYPE_PIPE_ANY},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_ANY},
    {LMEPm, _SOC_ACC_TYPE_PIPE_ANY},
    {LMEP_DAm, _SOC_ACC_TYPE_PIPE_ANY},
    {MAID_REDUCTIONm, _SOC_ACC_TYPE_PIPE_ANY},
    {MA_INDEXm, _SOC_ACC_TYPE_PIPE_ANY},
    {MA_STATEm, _SOC_ACC_TYPE_PIPE_ANY},
    {RMEPm, _SOC_ACC_TYPE_PIPE_ANY},
    {MPLS_ENTROPY_LABEL_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L2_USER_ENTRY_DATA_ONLYm, _SOC_ACC_TYPE_PIPE_ANY},
    {REPLICATION_FIFO_BANK0m, _SOC_ACC_TYPE_PIPE_ANY},
    {REPLICATION_FIFO_BANK1m, _SOC_ACC_TYPE_PIPE_ANY},
    {INVALIDm}
};
#endif

const soc_ser_overlay_test_t soc_ser_td2_overlay_mems[] = {

    {MODPORT_MAP_M0m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M1m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M2m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},
    {MODPORT_MAP_M3m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_X},

    {MODPORT_MAP_M0m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M1m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M2m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},
    {MODPORT_MAP_M3m, ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf,
     MODPORT_MAP_MIRRORm, _SOC_ACC_TYPE_PIPE_Y},

    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_X},

    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
     L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_Y},

    {EGR_IP_TUNNEL_IPV6m, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_X},
    {EGR_IP_TUNNEL_MPLSm, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_X},
    {EGR_DVP_ATTRIBUTE_1m, EGR_EL3_ECC_PARITY_CONTROLr,
     EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm,
     _SOC_ACC_TYPE_PIPE_X},
     {EGR_IP_TUNNEL_IPV6m, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_Y},
    {EGR_IP_TUNNEL_MPLSm, EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
     EGR_IP_TUNNELm, _SOC_ACC_TYPE_PIPE_Y},
    {EGR_DVP_ATTRIBUTE_1m, EGR_EL3_ECC_PARITY_CONTROLr,
     EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm,
     _SOC_ACC_TYPE_PIPE_Y},
    {INVALIDm}
};


static soc_mem_t _soc_td2_alpm_sram_list[] = {
    L3_DEFIP_ALPM_IPV4m,
    L3_DEFIP_ALPM_IPV4_1m,
    L3_DEFIP_ALPM_IPV6_64m,
    L3_DEFIP_ALPM_IPV6_64_1m,
    L3_DEFIP_ALPM_IPV6_128m,
    INVALIDm
};

STATIC int
_soc_trident2_ser_mem_is_hw_cached (int unit, soc_mem_t mem)
{
    switch (mem) {
    case L3_DEFIP_ALPM_RAWm:
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    case L3_DEFIP_ALPM_ECCm:
    case L2_ENTRY_LPm:
    case L3_ENTRY_LPm:
    case VLAN_XLATE_LPm:
    case EGR_VLAN_XLATE_LPm:
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    case L3_DEFIP_AUX_TABLEm:
    case L3_DEFIP_PAIR_128m:
    case L3_DEFIPm:
    case L3_DEFIP_128_DATA_ONLYm:
    case L3_DEFIP_PAIR_128_DATA_ONLYm:
    case L3_DEFIP_DATA_ONLYm:
        return 1;
    default:
        return 0;
    }
}

STATIC soc_acc_type_t
_soc_trident2_pipe_to_acc_type(int pipe)
{
    soc_acc_type_t rv;
    switch (pipe) {
        case -1:
        case 0:
            rv = _SOC_ACC_TYPE_PIPE_X;
            break;
        case 1:
            rv = _SOC_ACC_TYPE_PIPE_Y;
            break;
        default:
            rv =_SOC_ACC_TYPE_PIPE_ALL;
    };
    return rv;
}

#ifdef BCM_TRIDENT2PLUS_SUPPORT
#define _SER_TEST_MEM_TD2P_ALPM_MASK    0xFFFF
#define _SER_TEST_MEM_TD2P_ALPM_SHIFT   16
int
ser_test_trident2p_mem_index_remap(int unit, ser_test_data_t *test_data,
                                  int *mem_has_ecc)
{
    int uft_bkt_bank = 0;
    int uft_le_fv = 0;
    int uft_le_ecc = 0;
    int remap_status = 0;

    *mem_has_ecc = 0;
    test_data->mem = test_data->mem_fv;
    test_data->index = test_data->index_fv;

    switch (test_data->mem_fv) {
    case VLAN_XLATEm:
    case VLAN_MACm:
        test_data->mem = VLAN_XLATE_ECCm;
        *mem_has_ecc = 1;
        break;
    case EGR_VLAN_XLATEm:
        test_data->mem = EGR_VLAN_XLATE_ECCm;
        *mem_has_ecc = 1;
        break;
    case L2Xm:
    case L2_ENTRY_ONLYm:
        test_data->mem = L2_ENTRY_ONLY_ECCm;
        *mem_has_ecc = 1;
        break;
    case L3_ENTRY_ONLYm:
    case L3_ENTRY_IPV4_UNICASTm:
        test_data->mem = L3_ENTRY_ONLY_ECCm;
        test_data->index = test_data->index_fv;
        *mem_has_ecc = 1;
        break;
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
        test_data->mem = L3_ENTRY_ONLY_ECCm;
        test_data->index = test_data->index_fv*2;
        *mem_has_ecc = 1;
        break;
    case L3_ENTRY_IPV6_MULTICASTm:
        test_data->mem = L3_ENTRY_ONLY_ECCm;
        test_data->index = test_data->index_fv*4;
        *mem_has_ecc = 1;
        break;
    case L3_DEFIP_ALPM_IPV4m: /* 6:4 */
        *mem_has_ecc = 1;
        test_data->mem = L3_DEFIP_ALPM_ECCm;
        uft_bkt_bank = test_data->index_fv & _SER_TEST_MEM_TD2P_ALPM_MASK;
        uft_le_fv = test_data->index_fv >> _SER_TEST_MEM_TD2P_ALPM_SHIFT;
        switch (uft_le_fv) {
        case 0: uft_le_ecc = 0; break;
        case 1: uft_le_ecc = 0; break; /* or 1 */
        case 2: uft_le_ecc = 1; break;
        case 3: uft_le_ecc = 2; break;
        case 4: uft_le_ecc = 2; break; /* or 3 */
        case 5: uft_le_ecc = 3; break;
        default: remap_status = SOC_E_PARAM; uft_le_ecc = uft_le_fv; break;
        }
        test_data->index = (uft_le_ecc <<
            _SER_TEST_MEM_TD2P_ALPM_SHIFT) + uft_bkt_bank;
        break;
    case L3_DEFIP_ALPM_IPV4_1m: /* 4:4 */
    case L3_DEFIP_ALPM_IPV6_64m:
        *mem_has_ecc = 1;
        test_data->mem = L3_DEFIP_ALPM_ECCm;
        test_data->index = test_data->index_fv;
        break;
    case L3_DEFIP_ALPM_IPV6_64_1m: /* 3:4 */
        *mem_has_ecc = 1;
        test_data->mem = L3_DEFIP_ALPM_ECCm;
            uft_bkt_bank = test_data->index_fv & _SER_TEST_MEM_TD2P_ALPM_MASK;
            uft_le_fv = test_data->index_fv >> _SER_TEST_MEM_TD2P_ALPM_SHIFT;
        switch (uft_le_fv) {
        case 0: uft_le_ecc = 0; break; /* or 1 */
        case 1: uft_le_ecc = 1; break; /* or 2 */
        case 2: uft_le_ecc = 2; break; /* or 3 */
        default: remap_status = SOC_E_PARAM; uft_le_ecc = uft_le_fv; break;
        }
        test_data->index = (uft_le_ecc <<
            _SER_TEST_MEM_TD2P_ALPM_SHIFT) + uft_bkt_bank;
        break;
    case L3_DEFIP_ALPM_IPV6_128m: /* 2:4 */
        *mem_has_ecc = 1;
        test_data->mem = L3_DEFIP_ALPM_ECCm;
            uft_bkt_bank = test_data->index_fv & _SER_TEST_MEM_TD2P_ALPM_MASK;
            uft_le_fv = test_data->index_fv >> _SER_TEST_MEM_TD2P_ALPM_SHIFT;
        switch (uft_le_fv) {
        case 0: uft_le_ecc = 0; break; /* or 1 */
        case 1: uft_le_ecc = 2; break; /* or 3 */
        default: remap_status = SOC_E_PARAM; uft_le_ecc = uft_le_fv; break;
        }
        test_data->index = (uft_le_ecc <<
            _SER_TEST_MEM_TD2P_ALPM_SHIFT) + uft_bkt_bank;
        break;
    case L3_DEFIP_ALPM_RAWm: /* 1:4 */
        *mem_has_ecc = 1;
        test_data->mem = L3_DEFIP_ALPM_ECCm;
            uft_bkt_bank = test_data->index_fv & _SER_TEST_MEM_TD2P_ALPM_MASK;
            uft_le_fv = test_data->index_fv >> _SER_TEST_MEM_TD2P_ALPM_SHIFT;
        switch (uft_le_fv) {
        case 0: uft_le_ecc = 0; break; /* or 1,2,3 */
        default: remap_status = SOC_E_PARAM; uft_le_ecc = uft_le_fv; break;
        }
        test_data->index = (uft_le_ecc <<
            _SER_TEST_MEM_TD2P_ALPM_SHIFT) + uft_bkt_bank;
        break;
    default:
        test_data->mem = test_data->mem_fv;
        test_data->index = test_data->index_fv;
        break;
    }
    if ((test_data->mem != test_data->mem_fv) ||
        (test_data->index != test_data->index_fv)) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d, ser_test_mem_index_remap: "
                        "mem_fv %s, index_fv %0d, mem %s, index %0d, "
                        "uft_bkt_bank %0d, uft_le_fv %0d, "
                        "uft_le_ecc %0d, remap_status %0d \n"),
             unit, SOC_MEM_NAME(unit, test_data->mem_fv), test_data->index_fv,
             SOC_MEM_NAME(unit, test_data->mem), test_data->index,
             uft_bkt_bank, uft_le_fv, uft_le_ecc, remap_status));
    }
    return remap_status;
}

int
soc_trident2p_mem_is_eligible_for_scan(int unit, soc_mem_t mem)
{
    switch (mem) {
        case L3_DEFIP_ALPM_ECCm:
        case L2_ENTRY_LPm:
        case L3_ENTRY_LPm:
        case VLAN_XLATE_LPm:
        case EGR_VLAN_XLATE_LPm:
        return 1;
        
        default:
        break;
    }
    return 0;
}
#endif

STATIC int
_soc_td2_refresh_modify(int unit, int enable) {
    struct {
        soc_reg_t ref_reg;
        soc_field_t en_field;
    } rf_list[] = {
        {AUX_ARB_CONTROL_2r, FP_REFRESH_ENABLEf},
        {EFP_METER_CONTROLr, EFP_REFRESH_ENABLEf},
        {MISCCONFIGr, REFRESH_ENf},
        {INVALIDr, INVALIDf}
    };
    uint32 rval;
    int i;
    for (i = 0; rf_list[i].ref_reg != INVALIDr; i++) {
        if (!SOC_REG_IS_VALID(unit, rf_list[i].ref_reg)) {
            continue;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, rf_list[i].ref_reg, REG_PORT_ANY, 0, &rval));
        soc_reg_field_set(unit, rf_list[i].ref_reg, &rval, rf_list[i].en_field,
                          enable ? 1 : 0);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, rf_list[i].ref_reg, REG_PORT_ANY, 0, rval));
    }
    return SOC_E_NONE;
}

int
soc_trident2_ser_test_skip_check (int unit, soc_mem_t mem,
                                   soc_acc_type_t acc_type)
{
    int i;
    
    if (!SOC_MEM_IS_VALID(unit, mem) ||
        ((mem != INVALIDm) && 
         ((SOC_MEM_INFO(unit, mem).flags & 
           SOC_MEM_FLAG_SER_PARITY_ENABLE_SKIP)))) {
        return 1;
    }

    if (soc_mem_index_count(unit, mem) <= 0) {
        return 1;
    }

    if (SOC_IS_TITAN2(unit)) {
        /* Skip the memory if the relevant feature is disabled. */
        if (!soc_feature(unit, soc_feature_l3_defip_map)) {
            /* Skip L3_DEFIP memorys */
            if ((L3_DEFIPm == mem) ||
                (L3_DEFIP_PAIR_128m == mem) ||
                (L3_DEFIP_DATA_ONLYm == mem) ) {
                return 1;
            }
        }
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        for (i = 0; td2p_skipped_mems[i].mem != INVALIDm; i++) {
            if ((td2p_skipped_mems[i].mem == mem) &&
                 ((td2p_skipped_mems[i].acc_type == acc_type) || 
                  (td2p_skipped_mems[i].acc_type == _SOC_ACC_TYPE_PIPE_ANY))) {
                return 1;
            }
        }
        if (!(SOC_MEM_INFO(unit, mem).flags & SOC_MEM_SER_FLAGS)) {
            return 1;
        }
        /* Skip the memory if the relevant feature and memory is disabled. */
        if (!soc_feature(unit, soc_feature_l3)
            || !soc_feature(unit, soc_feature_lpm_tcam) ) {
            /* Skip L3_DEFIP memorys */
            if ((L3_DEFIPm == mem) || (L3_DEFIP_PAIR_128m == mem)) return 1;
        }
        if (!soc_feature(unit, soc_feature_l3) ||
            !soc_feature(unit, soc_feature_ing_l3_next_hop_encoded_dest)) {
            /* Skip ING L3 Next hop memory */
            if ((ING_L3_NEXT_HOPm == mem)
                || (INITIAL_ING_L3_NEXT_HOPm == mem)) return 1;
        }
        if (!soc_feature(unit, soc_feature_l3) ||
            soc_feature(unit, soc_feature_no_tunnel)) {
            /* Skip ING L3 Tunnel memorys */
            if ((L3_TUNNELm == mem) || (L3_TUNNEL_DATA_ONLYm == mem)) return 1;
        }
        if (!soc_feature(unit, soc_feature_nat)) {
            /* Skip NAT  memorys */
            if (ING_SNATm == mem) return 1;
        }
        if (!soc_feature(unit, soc_feature_mpls)) {
            /* Skip MPLS memories */
            if ((MPLS_ENTRYm == mem)
                || (ING_MPLS_EXP_MAPPINGm == mem)
                || (EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm == mem)) {
                return 1;
            }
        }
    } else
#endif
    {
        for (i = 0; td2_skipped_mems[i].mem != INVALIDm; i++) {
            if ((td2_skipped_mems[i].mem == mem) &&
                (td2_skipped_mems[i].acc_type == acc_type)) {
                return 1;
            }
        }
    }
    return 0;
}

STATIC soc_error_t
_soc_trident2_ser_mem_info_get (int unit, soc_mem_t mem,
                                     void** ser_mem_info)
{
    int i, j;
    _soc_td2_fifo_ser_info_t *fifo_parity = NULL;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    _soc_mem_ser_en_info_t *ser_en_info = NULL;
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        /* Search for mems listed in:
         * _soc_bcm56860_a0_ip_mem_ser_info,
         * _soc_bcm56860_a0_ep_mem_ser_info,
         * _soc_bcm56860_a0_mmu_mem_ser_info */
        for (i = 0; _soc_td2p_ser_block_info[i].blocktype != 0; i++) {
            if ((_soc_td2p_ser_block_info[i].type == _SOC_TD2P_SER_TYPE_MEM) &&
                ((_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_IPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_EPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_MMU))) {
                ser_en_info = _soc_td2p_ser_block_info[i].info;
                for (j = 0; ser_en_info[j].mem != INVALIDm; j++) {
                    if (ser_en_info[j].mem == mem) {
                        *ser_mem_info = &ser_en_info[j];
                        return SOC_E_NONE;
                    }
                }
            }
        }
    } else
#endif
    {
        for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
            fifo_parity = _soc_td2_ser_block_info[i].info;
            for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
                if (fifo_parity[j].mem != INVALIDm && fifo_parity[j].mem == mem) {
                    *ser_mem_info = &fifo_parity[j];
                    return SOC_E_NONE;
                }
            }
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_overlay_ser_mem_info_get (int unit, soc_mem_t mem,
                                        int * index)
{
    int i;
    for (i = 0; soc_ser_td2_overlay_mems[i].mem != INVALIDm; i++) {
        if (soc_ser_td2_overlay_mems[i].mem == mem) {
            *index = i;
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_tcam_ser_mem_info_get (int unit, soc_mem_t mem,
                                     int * index_p)
{
    int i;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        if (tcams[i].mem == mem) {
            *index_p = i;
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

STATIC 
soc_error_t
_soc_trident2_sram_ser_mem_info_get (int unit, soc_mem_t mem,
                                     soc_mem_t ** mem_info)
{
    int i;
    for (i = 0; _soc_td2_alpm_sram_list[i] != INVALIDm; i++) {
        if (_soc_td2_alpm_sram_list[i] == mem) {
            *mem_info = &_soc_td2_alpm_sram_list[i];
            return SOC_E_NONE;
        }
    }
    return SOC_E_NOT_FOUND;
}

/*
 * Function:
 *      soc_td2_ser_error_injection_support
 * Purpose:
 *      Checks if a memory is supported by error injection interface
 *
 * Parameters:
 *      unit        - (IN) Device Number
 *      memory      - (IN) Test data required for SER test
 *      pipe        - (IN) How many indices to test for each memory
 *
 * Returns:
 *  SOC_E_NONE if memory / reg is supported, SOC_E_UNAVAIL if unsupported
 *
 */
soc_error_t
soc_td2_ser_error_injection_support (int unit, soc_mem_t mem,
                                     int pipe)
{
    int rv = SOC_E_UNAVAIL;
    void * ser_mem_info = NULL;
    int  tcam_idx = 0;
    int  overlay_mem_idx = 0;
    soc_mem_t * sram_mem_info = NULL;

    
    soc_acc_type_t soc_acc_type_target = _soc_trident2_pipe_to_acc_type(pipe);
    
    /* Check if memory is listed in skipped mems structure */
    if (soc_trident2_ser_test_skip_check(unit, mem, soc_acc_type_target)) {
        return rv;
    }

    rv = _soc_trident2_ser_mem_info_get(unit, mem, &ser_mem_info);
    if (rv == SOC_E_NONE) {
        return rv;
    }
    
    rv = _soc_trident2_tcam_ser_mem_info_get(unit, mem, &tcam_idx);
    if (rv == SOC_E_NONE) {
        return rv;
    }
    
    if(!SOC_IS_TD2P_TT2P(unit)) {
        rv = _soc_trident2_overlay_ser_mem_info_get(unit, mem, &overlay_mem_idx);
        if (rv == SOC_E_NONE) {
            return rv;   
        }
        rv = _soc_trident2_sram_ser_mem_info_get(unit, mem, &sram_mem_info);
        if (rv == SOC_E_NONE) {
            return rv;   
        }
    }
    
    return rv;
}

/*
 * Function:
 *      _soc_trident2_perform_ser_test
 * Purpose:
 *      Performs test operations common to TCAM and FIFO memory tests before
 *      invoking common SER test.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_data   - (IN) Test data required for SER test
 *      test_type   - (IN) How many indices to test for each memory
 *      mem_failed  - (OUT) Incremented when memories fail the test.
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
_soc_trident2_perform_ser_test(int unit, uint32 flags, 
                               ser_test_data_t *test_data,
                               _soc_ser_test_t test_type,
                               int *mem_skipped, int *mem_failed)
{
    int skip_mem = FALSE;
    soc_error_t rv = SOC_E_NONE;
    soc_mem_t mem = INVALIDm;
    mem = test_data->mem;
    
    if (soc_trident2_ser_test_skip_check(unit, mem, test_data->acc_type)) {
        skip_mem = TRUE;
    }
    if (!skip_mem) {
        if (mem == ING_VLAN_VFI_MEMBERSHIPm ||
            mem == MMU_MTRO_EGRMETERINGCONFIG_MEM_0m ||
            mem == MMU_MTRO_EGRMETERINGCONFIG_MEM_1m ||
            mem == MMU_MTRI_BKPMETERINGCONFIG_MEM_0m ||
            mem == MMU_MTRI_BKPMETERINGCONFIG_MEM_1m) {
            flags |= SOC_INJECT_ERROR_2BIT_ECC;
        }
        rv = ser_test_mem(unit, flags, test_data, test_type, mem_failed);
    } else {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Memory %s skipped due to known issues.\n"),
                     SOC_MEM_NAME(unit, mem)));
        (*mem_skipped)++;
    }
    return rv;
}

/*
 * Function:
 *      soc_td2_ser_tcam_test
 * Purpose:
 *      Tests that SER is working for fifo and SRAM memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  the number of tests which are failed
 */
int
soc_td2_ser_tcam_test (int unit, _soc_ser_test_t test_type) {
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    ser_test_data_t test_data;
    int mem_failed = 0, mem_tests = 0, mem_skipped = 0;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int i;
    soc_acc_type_t acc_type;
    soc_field_t test_field = VALIDf;
    
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        mem_tests++;
        if ( i >= MAX_HW_TCAMS) {
            mem_skipped++;
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Memory %s skipped due to lack of test mechanism \
                                    for Software-protected TCAMS.\n"),
                         SOC_MEM_NAME(unit, tcams[i].mem)));
            continue;
        }

        /*
        * Skip EFP_TCAMm for TR144 test since consecutive ipipe and epipe sbus
        * transcations will cause H/W SER engine use incorrect parity bit
        * for checking, which result in false parity error reported, SDK use S/W compare
        * to detect EFP_TCAM parity error in memscan thread.
        */
        if (SOC_IS_TD2P_TT2P(unit) && (tcams[i].mem == EFP_TCAMm)) {
            mem_skipped++;
            LOG_VERBOSE(BSL_LS_SOC_SER,
                        (BSL_META_U(unit,
                                    "Memory %s skipped due to lack of test mechanism \
                                    for Software-protected TCAMS.\n"),
                         SOC_MEM_NAME(unit, tcams[i].mem)));
            continue;
        }

        if (tcams[i].ser_flags & _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y) {
            acc_type = _SOC_ACC_TYPE_PIPE_Y;
        } else {
            acc_type = _SOC_ACC_TYPE_PIPE_X;
        }
        
        if (tcams[i].mem == L3_DEFIPm) {
            test_field = VALID0f;
        } else if (tcams[i].mem == L3_DEFIP_PAIR_128m) {
            test_field = VALID0_LWRf;
        } else {
            test_field = VALIDf;
        }
        
        soc_ser_create_test_data(unit, tmp_entry, field_data, SER_RANGE_ENABLEr,
                                 i, INVALIDf, tcams[i].mem, test_field,
                                 MEM_BLOCK_ANY, REG_PORT_ANY, acc_type, 0,
                                 &test_data);
        _soc_trident2_perform_ser_test(unit, 0, &test_data, test_type,
                                       &mem_skipped, &mem_failed);
    }
    LOG_CLI((BSL_META_U(unit,
                        "\nTCAM memories tested on unit %d: %d\n"), unit, mem_tests));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests passed:\t%d\n"),
             mem_tests - mem_failed - mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests skipped:\t%d (use verbose option to see "
                        "skipped memories)\n"),
             mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "TCAM tests failed:\t%d\n\n"), mem_failed));
    return mem_failed;
}

/*
 * Function:
 *      soc_td2_ser_hardware_test
 * Purpose:
 *      Tests that SER is working for fio and SRAM memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  the number of tests which are failed
 */
STATIC int
soc_td2_ser_hardware_test (int unit, _soc_ser_test_t test_type) {
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    ser_test_data_t test_data;
    int mem_failed = 0, mem_tests = 0, mem_skipped = 0;
    _soc_td2_fifo_ser_info_t *fifo_parity = _soc_td2_ip_ser_info;
    int i, j;
    soc_acc_type_t acc_type;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int k, rv, num_instance_to_test = 0;
    _soc_mem_ser_en_info_t *ser_en_info = NULL;
    soc_acc_type_t mem_acc_type, acc_type_list[SOC_MAX_NUM_PIPES];
#endif
    (void) _soc_td2_refresh_modify(unit, FALSE);
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        for (i = 0; _soc_td2p_ser_block_info[i].blocktype != 0; i++) {
            if ((_soc_td2p_ser_block_info[i].type == _SOC_TD2P_SER_TYPE_MEM) &&
                ((_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_IPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_EPIPE) ||
                 (_soc_td2p_ser_block_info[i].blocktype == SOC_BLK_MMU))) {
                ser_en_info = _soc_td2p_ser_block_info[i].info;
                for (j = 0; ser_en_info[j].mem != INVALIDm; j++) {
                    mem_acc_type = SOC_MEM_ACC_TYPE(unit, ser_en_info[j].mem);
                    sal_memset(acc_type_list, 0, sizeof(acc_type_list));
                    switch (mem_acc_type) {
                    case _SOC_ACC_TYPE_PIPE_BCAST:
                    case _SOC_ACC_TYPE_PIPE_SBS:
                        num_instance_to_test = NUM_PIPE(unit);
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_Y;
                        acc_type_list[1] = _SOC_ACC_TYPE_PIPE_X;
                        break;
                    case _SOC_ACC_TYPE_PIPE_Y:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_Y;
                        break;
                    case _SOC_ACC_TYPE_PIPE_X:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_X;
                        break;
                    default:
                        num_instance_to_test = 1;
                        acc_type_list[0] = _SOC_ACC_TYPE_PIPE_X;
                        break;
                    }
                    mem_tests += num_instance_to_test;
                    for (k = 0; k < num_instance_to_test; k++) {
                        test_data.test_field = EVEN_PARITYf;
                        acc_type = acc_type_list[k];
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 ser_en_info[j].en_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 ser_en_info[j].en_fld,
                                                 ser_en_info[j].mem,
                                                 test_data.test_field, 
                                                 MEM_BLOCK_ANY,
                                                 REG_PORT_ANY, acc_type, 0, 
                                                 &test_data);
                        if ((test_data.mem_info == NULL) || 
                            (!(soc_mem_index_count(unit, ser_en_info[j].mem) > 0))) {
                            mem_skipped++;
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "Memory %s skipped due to lack of"
                                                " mem_info structure or being disabled.\n"),
                                     SOC_MEM_NAME(unit,test_data.mem)));
                            continue;
                        }
                        rv = _soc_trident2_perform_ser_test(unit, 0, &test_data,
                                                            test_type, &mem_skipped,
                                                            &mem_failed);
                        if (SOC_FAILURE(rv)) {
                             LOG_CLI((BSL_META_U(unit,
                                      " SER test fail for mem: \t %s\n\n"),
                                      SOC_MEM_NAME(unit,test_data.mem)));
                        }
                    }
                }
            }
        }
    } else
#endif    
    {
        for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
            fifo_parity = _soc_td2_ser_block_info[i].info;
            for (j = 0; fifo_parity[j].enable_reg != INVALIDr; j++) {
                if (fifo_parity[j].mem != INVALIDm) {
                    mem_tests += 2;
                    test_data.test_field = EVEN_PARITYf;
                    acc_type = _SOC_ACC_TYPE_PIPE_Y;
                    soc_ser_create_test_data(unit, tmp_entry, field_data,
                                             fifo_parity[j].enable_reg,
                                             SOC_INVALID_TCAM_PARITY_BIT,
                                             fifo_parity[j].enable_field,
                                             fifo_parity[j].mem,
                                             test_data.test_field, MEM_BLOCK_ANY,
                                             REG_PORT_ANY, acc_type, 0, &test_data);
                    if ((test_data.mem_info == NULL) || 
                        (!(soc_mem_index_count(unit, fifo_parity[j].mem) > 0))) {
                        mem_skipped += 2;
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "Memory %s skipped due to lack of"
                                                " mem_info structure.\n"),
                                     SOC_MEM_NAME(unit,test_data.mem)));
                        continue;
                    }
                    _soc_trident2_perform_ser_test(unit, 0, &test_data, test_type,
                                                   &mem_skipped, &mem_failed);
                    test_data.acc_type = _SOC_ACC_TYPE_PIPE_X;
                    _soc_trident2_perform_ser_test(unit, 0, &test_data, test_type,
                                                   &mem_skipped, &mem_failed);
                }
            }
        }
        /* Perform SER test for SRAM memories */
        for (i = 0; _soc_td2_alpm_sram_list[i] != INVALIDm; i++) {
            soc_ser_create_test_data(unit, tmp_entry, field_data,
                                     ILPM_SER_CONTROLr,
                                     SOC_INVALID_TCAM_PARITY_BIT,
                                     L3_DEFIP_ALPM_PARITY_ENf,
                                     _soc_td2_alpm_sram_list[i],
                                     EVEN_PARITYf, MEM_BLOCK_ANY,
                                     REG_PORT_ANY, _SOC_ACC_TYPE_PIPE_Y, 0,
                                     &test_data);
            if ((test_data.mem_info == NULL) || 
                (!(soc_mem_index_count(unit, _soc_td2_alpm_sram_list[i]) > 0))) {
                mem_skipped += 2;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Memory %s skipped due to lack of"
                                        " mem_info structure.\n"),
                             SOC_MEM_NAME(unit,test_data.mem)));
                continue;
            }
            _soc_trident2_perform_ser_test(unit, 0, &test_data, test_type,
                                           &mem_skipped, &mem_failed);
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_X;
            _soc_trident2_perform_ser_test(unit, 0, &test_data, test_type,
                                           &mem_skipped, &mem_failed);
            mem_tests += 2;
        }
    }
    (void) _soc_td2_refresh_modify(unit, TRUE);
    LOG_CLI((BSL_META_U(unit,
                        "\nH/W memories tested on unit %d: %d\n"), unit, mem_tests));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests passed:\t%d\n"),
             mem_tests - mem_failed - mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests skipped:\t%d (use verbose option to see "
                        "skipped memories)\n"),
             mem_skipped));
    LOG_CLI((BSL_META_U(unit,
                        "H/W tests failed:\t%d\n\n"), mem_failed));
    return mem_failed;
}


/*
 * Function:
 *      soc_td2_ser_test
 * Purpose:
 *      Tests that SER is working for all supported memories.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
soc_td2_ser_test (int unit, _soc_ser_test_t test_type) {
    int errors = 0;
    /* Test for overlay memories */
    if (!SOC_IS_TD2P_TT2P(unit))
    {
        soc_ser_test_long_sleep = TRUE;
        errors += soc_td2_ser_test_overlay(unit, test_type);
        soc_ser_test_long_sleep = FALSE;
    }
    
    /* Test TCAM memories */
    errors += soc_td2_ser_tcam_test(unit, test_type);
    /* Test for FIFO memories */
    errors += soc_td2_ser_hardware_test(unit, test_type);

    if (errors == 0) {
        return SOC_E_NONE;
    } else {    
        LOG_CLI((BSL_META_U(unit,
                    "TR 144 test failed, failed cases:%d.\n"), errors));
        return SOC_E_FAIL;
    }
}

#define TR_MEM_NAME_SIZE_MAX    100

#ifdef SOC_MEM_NAME
#define TR_TEST_MEM_NAME_GET(_unit, _msg, _mem) do {                    \
        const char *_mem_name = SOC_MEM_NAME(_unit_, _mem);             \
        if (sal_strlen(_mem_name) < TR_MEM_NAME_SIZE_MAX) {             \
            sal_strcpy(_msg, _mem_name);                                \
        }                                                               \
    } while (0)
#else
#define TR_TEST_MEM_NAME_GET(_unit, _msg, _mem)
#endif

#define TR_TEST_MEM_PRINT(_unit, _msg, _mem) do {                       \
        sal_sprintf(_msg, "Mem ID: %d", _mem);                          \
        TR_TEST_MEM_NAME_GET(_unit, _msg, _mem);                        \
        LOG_CLI((BSL_META_U(_unit,                                      \
                            "Memory %s is valid, but not currently testable.\n"), \
                 _msg));                                                \
    } while (0)


/*
 * Function:
 *      soc_td2_ser_test_overlay
 * Purpose:
 *      performs a test of all overlay memories along with their base memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) how to test memories
 */
int
soc_td2_ser_test_overlay (int unit, _soc_ser_test_t test_type)
{
    int rv = 0;
    int numOverlays = COUNTOF(soc_ser_td2_overlay_mems) - 1;

    rv = soc_ser_test_overlays(unit, test_type, soc_ser_td2_overlay_mems,
                              NULL);

    if (rv >= 0) {
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories tested: \t %d\n"),
                 numOverlays));
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories passed: \t %d\n"),
                 numOverlays - rv));
        LOG_CLI((BSL_META_U(unit,
                            " Overlay memories failed: \t %d\n\n"),
                 rv));
    } else {
        LOG_INFO(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "Internal Error during overlay test.\n")));
    }
    return rv;
}

STATIC int
soc_td2_ser_pipe_check(int pipe)
{
    int rv = SOC_E_NONE;

    if (pipe != SOC_PIPE_SELECT_X_COMMON &&
        pipe != SOC_PIPE_SELECT_Y_COMMON &&
        pipe != SOC_PIPE_SELECT_ANY &&
        pipe != _SOC_ACC_TYPE_PIPE_ALL) {
        rv = SOC_E_PARAM;
    }

    return rv;
}

/*
 * Function:
 *      soc_ser_inject_or_test_mem
 * Purpose:
 *      Provide a common function for injecting errors and testing single
 *      single memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_ser_inject_or_test_mem (int unit, soc_mem_t mem, int pipe_target, int block,
                            int index, _soc_ser_test_t test_type,
                            int inject_only, int cmd, uint32 flags)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    uint32 read_flags = 0;
    ser_test_data_t test_data;
    int tcam_idx = 0;
    void * ser_mem_info = NULL;
    int overlay_mem_idx = 0;
    soc_mem_t * sram_mem_info = NULL;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int error_count = 0, skip_count = 0, found_mem = FALSE;
    char fail_message[TR_MEM_NAME_SIZE_MAX + 1];

    soc_error_t rv = SOC_E_NONE;
    soc_acc_type_t soc_acc_type_target = _soc_trident2_pipe_to_acc_type(pipe_target);
    soc_field_t test_field = INVALIDf;

    SOC_IF_ERROR_RETURN(soc_td2_ser_pipe_check(pipe_target));

    /* Search for TCAM memories */
    rv = _soc_trident2_tcam_ser_mem_info_get(unit, mem, &tcam_idx);
    if (rv == SOC_E_NONE) {
        if (tcams[tcam_idx].mem == L3_DEFIPm) {
            test_field = VALID0f;
        } else if (tcams[tcam_idx].mem == L3_DEFIP_PAIR_128m) {
            test_field = VALID0_LWRf;
        } else {
            test_field = VALIDf;
        }
        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                     SER_RANGE_ENABLEr, tcam_idx, INVALIDf, mem,
                                     test_field, block, REG_PORT_ANY,
                                     soc_acc_type_target, index, &test_data);
        found_mem = TRUE;
    }    

    if (!found_mem) {
        rv = _soc_trident2_ser_mem_info_get (unit, mem, &ser_mem_info);
        if (rv == SOC_E_NONE) {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (SOC_IS_TD2P_TT2P(unit)) {
                int mem_has_ecc = 0;

                if (mem == ING_L3_NEXT_HOPm) {
                    test_field= ECC_1f;
                } else {
                    test_field = EVEN_PARITYf;
                }
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ((_soc_mem_ser_en_info_t*)ser_mem_info)->en_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         ((_soc_mem_ser_en_info_t*)ser_mem_info)->en_fld,
                                         mem, test_field, block,
                                         REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                if (SOC_REG_IS_VALID(unit, ((_soc_mem_ser_en_info_t*)ser_mem_info)->ecc_1b_report_en_reg) &&
                    (INVALIDf != ((_soc_mem_ser_en_info_t*)ser_mem_info)->ecc_1b_report_en_fld)) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
                SOC_IF_ERROR_RETURN
                    (ser_test_mem_index_remap(unit, &test_data, &mem_has_ecc));
                if (mem_has_ecc) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
                /* ING_VLAN_VFI_MEMBERSHIP is ECC protected, however
                 * there is no 1bit error reporting control register for it.
                 */
                if (mem == ING_VLAN_VFI_MEMBERSHIPm) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
            } else
#endif
            {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ((_soc_td2_fifo_ser_info_t*)ser_mem_info)->enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         ((_soc_td2_fifo_ser_info_t*)ser_mem_info)->enable_field,
                                         mem, EVEN_PARITYf, block,
                                         REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
            }
            found_mem = TRUE;
        }
    }

    if (!SOC_IS_TD2P_TT2P(unit)) {
        if (!found_mem) {
            rv = _soc_trident2_overlay_ser_mem_info_get(unit, mem, &overlay_mem_idx);
            if (rv == SOC_E_NONE) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].parity_enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].parity_enable_field,
                                         soc_ser_td2_overlay_mems[overlay_mem_idx].mem, EVEN_PARITYf,
                                         block, REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                found_mem = TRUE;
            }
        }
        if (!found_mem) {
            rv = _soc_trident2_sram_ser_mem_info_get(unit, mem, &sram_mem_info);
            if (rv == SOC_E_NONE) {
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         ILPM_SER_CONTROLr,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         L3_DEFIP_ALPM_PARITY_ENf,
                                         mem, EVEN_PARITYf,
                                         block, REG_PORT_ANY, soc_acc_type_target,
                                         index, &test_data);
                found_mem = TRUE;
            }
        }
    }
    
    if (found_mem) {
        if ((pipe_target == _SOC_ACC_TYPE_PIPE_ANY) &&
            (!_soc_trident2_ser_mem_is_hw_cached(unit, test_data.mem))) {
            test_data.acc_type = SOC_MEM_ACC_TYPE(unit, test_data.mem);
        }
        if (inject_only) {
            if (soc_trident2_ser_test_skip_check(unit, mem, test_data.acc_type)) {
                TR_TEST_MEM_PRINT(unit, fail_message, mem);
                return SOC_E_UNAVAIL;
            }
            /* Disable parity */
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
            /* Read the memory (required for successful injection) */
            if (flags & SOC_INJECT_ERROR_DONT_MAP_INDEX) {
                read_flags = SER_TEST_MEM_F_DONT_MAP_INDEX;
            }
            SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, read_flags, &test_data));
            /* Inject error */
            SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
            /* Enable parity */
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
        } else {
            if (cmd) {
                ser_test_cmd_generate(unit, &test_data);
            } else {
                _soc_td2_refresh_modify(unit, FALSE);
                rv = _soc_trident2_perform_ser_test(unit, flags, &test_data, test_type,
                                                    &skip_count, &error_count);
                _soc_td2_refresh_modify(unit, TRUE);
                if (error_count == 0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "SER test PASSED for memory %s\n"),
                             test_data.mem_name));
                }
                if (skip_count !=0) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Test skipped due to known issues with "
                                        "this memory.\n")));
                }
            }
        }
    } else {
        TR_TEST_MEM_PRINT(unit, fail_message, mem);
        rv = SOC_E_UNAVAIL;
    }
    return rv;
}
#undef TR_TEST_MEM_PRINT

/*
 * Function:
 *      soc_td2_ser_inject_error
 * Purpose:
 *      Injects an error into a single td2 memory
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 *      test_tcam   - (IN) If the memory is a TCAM, test the KEY/MASK portion,
 *                         not the DATA portion
 */
soc_error_t
soc_td2_ser_inject_error (int unit, uint32 flags, soc_mem_t mem,
                          int pipe_target, int block, int index)
{
    /* Check if memory needs to be skipped */
    if (ser_trident2_test_fun.injection_support) {
        SOC_IF_ERROR_RETURN(
            soc_td2_ser_error_injection_support(unit, mem, pipe_target));
    }

    return soc_ser_inject_or_test_mem(unit, mem, pipe_target, block, index,
                                      SER_SINGLE_INDEX, TRUE, FALSE, flags);
}

/*
 * Function:
 *      soc_td2_ser_test_mem
 * Purpose:
 *      Perform SER test on a single memory, or generate a test the user can
 *      enter by the command line.
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_td2_ser_test_mem(int unit, soc_mem_t mem, _soc_ser_test_t test_type,
                     int cmd)
{
    soc_acc_type_t mem_acc_type;
    soc_error_t rv = SOC_E_NONE;
    
    if ((!SOC_MEM_IS_VALID(unit, mem)) ||
        (!(soc_mem_index_count(unit, mem) > 0))) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }
    mem_acc_type = SOC_MEM_ACC_TYPE(unit, mem);
    
    if (mem_acc_type == _SOC_ACC_TYPE_PIPE_BCAST ||
    	  mem_acc_type == _SOC_ACC_TYPE_PIPE_SBS) {
        /* Test X-pipe memory instance */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_ANY,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
        /* Test Y-pipe memory instance */
        if (SOC_SUCCESS(rv)) {
            rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_Y_COMMON,
                                            MEM_BLOCK_ANY, 0, test_type,
                                            FALSE, cmd, FALSE);
        }
        
    } else if (mem_acc_type == _SOC_ACC_TYPE_PIPE_X) {
        /* Only X-pipe access is allowed */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_X_COMMON,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    } else if (mem_acc_type == _SOC_ACC_TYPE_PIPE_Y) {
        /* Only Y-pipe access is allowed */
        rv = soc_ser_inject_or_test_mem(unit, mem, SOC_PIPE_SELECT_Y_COMMON,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    } else {
        rv = soc_ser_inject_or_test_mem(unit, mem, _SOC_ACC_TYPE_PIPE_ANY,
                                        MEM_BLOCK_ANY, 0, test_type,
                                        FALSE, cmd, FALSE);
    }
    return rv;
}
#endif /*defined(SER_TR_TEST_SUPPORT)*/

int
soc_td2_reg_cpu_write_control(int unit, int enable)
{
    uint32 intfo_dis = 0;

    if (enable) {
        /* Disable HW updates */
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          EG_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          ING_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          CONGST_STf, 1);
    }
    SOC_IF_ERROR_RETURN(WRITE_INTFO_HW_UPDATE_DISr(unit, intfo_dis));

    return SOC_E_NONE;
}

/*
 * Trident2 chip driver functions.
 */
soc_functions_t soc_trident2_drv_funs = {
    _soc_trident2_misc_init,
    _soc_trident2_mmu_init,
    _soc_trident2_age_timer_get,
    _soc_trident2_age_timer_max_get,
    _soc_trident2_age_timer_set,
    _soc_trident2_tsc_firmware_set
};

uint32* soc_td2_mmu_params_arr_get (uint16 dev_id, uint8 rev_id)
{
    return soc_mmu_pkt_buf_size_arr[_MMU_PKT_BUF_SIZE_12MB];
}

void
soc_cm_get_id_otp(int unit, uint16 *dev_id, uint8 *rev_id)
{

    soc_cm_get_id(unit, dev_id, rev_id);

}

int soc_td2_is_blk_valid(int unit, int blk)
{
    int valid = 1;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    int blktype;
    int instance;

    if (SOC_IS_TD2P_TT2P(unit)) {
        blktype = SOC_BLOCK_INFO(unit, blk).type;
        if ( blktype == SOC_BLK_PGW_CL ) {
            if (!soc_td2p_if_full_chip(unit)) {
                instance = SOC_BLOCK_INFO(unit, blk).number;
                if ( instance >= _TD2_PGWS_PER_PIPE ) {
                    valid = 0;
                    LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                               (BSL_META_U(unit,
                                           "Unit %d half chip config block is not valid %d\n"),
                                                unit, valid));
                }
            }
        }
    }
#endif

    return valid;
}

int soc_td2x_ser_dlb_parity_set(int unit, int enable)
{
    uint32 reg_data;
    
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, DLB_HGT_SER_CONTROLr, 
                REG_PORT_ANY, 0, &reg_data));
    soc_reg_field_set(unit, DLB_HGT_SER_CONTROLr, &reg_data,
                DLB_HGT_FLOWSET_PARITY_ENf, enable);
    SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, DLB_HGT_SER_CONTROLr, 
                    REG_PORT_ANY, 0, reg_data));

    return SOC_E_NONE;
}

STATIC int
soc_trident2_ser_single_bit_error_set(int unit, int enable)
{
    int i, value;
    soc_reg_t ecc_reg;
    soc_field_t ecc_fld;
    _soc_mem_ser_en_info_t *mem_ser_info;

    value = enable ? 1:0;
    mem_ser_info = _soc_trident2_mmu_ecc_mem_ser_info;

    for (i = 0; mem_ser_info[i].mem != INVALIDm; i++) {
        if (!SOC_MEM_IS_VALID(unit, mem_ser_info[i].mem)) {
            continue;
        }

        ecc_reg = mem_ser_info[i].ecc_1b_report_en_reg;
        ecc_fld = mem_ser_info[i].ecc_1b_report_en_fld;

        if (!soc_reg_field_valid(unit, ecc_reg, ecc_fld)) {
            continue;
        }

        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "unit %d, MEM %50s REG %30s FIELD %40s\n"),
                     unit, SOC_MEM_NAME(unit, mem_ser_info[i].mem),
                     SOC_REG_NAME(unit, ecc_reg),
                     SOC_FIELD_NAME(unit, ecc_fld)));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ecc_reg, REG_PORT_ANY,
                                    ecc_fld, value));
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_ser_single_bit_error_get(int unit, int *enable)
{
    soc_reg_t ecc_reg;
    soc_field_t ecc_fld;
    _soc_mem_ser_en_info_t *mem_ser_info;
    uint32 rval = 0, fld_value = 0, i;

    mem_ser_info = _soc_trident2_mmu_ecc_mem_ser_info;

    for (i = 0; mem_ser_info[i].mem != INVALIDm; i++) {
        if (!SOC_MEM_IS_VALID(unit, mem_ser_info[i].mem)) {
            continue;
        }

        ecc_reg = mem_ser_info[i].ecc_1b_report_en_reg;
        ecc_fld = mem_ser_info[i].ecc_1b_report_en_fld;

        if (soc_reg_field_valid(unit, ecc_reg, ecc_fld)) {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, ecc_reg, REG_PORT_ANY, 0, &rval));
            fld_value = soc_reg_field_get(unit, ecc_reg, rval, ecc_fld);
            break;
        }
    }

    *enable = fld_value ? TRUE:FALSE;
    return SOC_E_NONE;
}


#ifdef BCM_TRIDENT2PLUS_SUPPORT
#define MEM_SER_INFO_COUNT 3
STATIC int
soc_trident2p_ser_single_bit_error_set(int unit, int enable)
{
#ifdef BCM_56860_A0
    int i, value, k;
    soc_reg_t ecc_reg;
    soc_field_t ecc_fld;
    _soc_mem_ser_en_info_t *mem_ser_info, *mem_ser_info_all[MEM_SER_INFO_COUNT];

    value = enable ? 1:0;
    mem_ser_info_all[0] = _soc_bcm56860_a0_ip_mem_ser_info;
    mem_ser_info_all[1] = _soc_bcm56860_a0_ep_mem_ser_info;
    mem_ser_info_all[2] = _soc_bcm56860_a0_mmu_mem_ser_info;

    for (k = 0; k < MEM_SER_INFO_COUNT; k++) {
        mem_ser_info = mem_ser_info_all[k];
        for (i = 0; mem_ser_info[i].mem != INVALIDm; i++) {
            /* Skip the memory whose SER_RESPONSE not equal SER_NONE*/
            if (SOC_MEM_SER_CORRECTION_TYPE(unit, mem_ser_info[i].mem) != 0) {
                continue;
            }

            ecc_reg = mem_ser_info[i].ecc_1b_report_en_reg;
            ecc_fld = mem_ser_info[i].ecc_1b_report_en_fld;

            if (!soc_reg_field_valid(unit, ecc_reg, ecc_fld)) {
                continue;
            }

            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "unit %d, MEM %50s REG %30s FIELD %40s\n"),
                         unit, SOC_MEM_NAME(unit, mem_ser_info[i].mem),
                         SOC_REG_NAME(unit, ecc_reg),
                         SOC_FIELD_NAME(unit, ecc_fld)));

            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, ecc_reg, REG_PORT_ANY,
                                        ecc_fld, value));
        }
    }
    return SOC_E_NONE;
#else
    return SOC_E_UNAVAIL;
#endif
}

STATIC int
soc_trident2p_ser_single_bit_error_get(int unit, int *enable)
{
#ifdef BCM_56860_A0
    soc_reg_t ecc_reg;
    soc_field_t ecc_fld;
    _soc_mem_ser_en_info_t *mem_ser_info;
    uint32 rval = 0, fld_value = 0, i;

    mem_ser_info = _soc_bcm56860_a0_mmu_mem_ser_info;

    for (i = 0; mem_ser_info[i].mem != INVALIDm; i++) {
        /* Skip the memory whose SER_RESPONSE not equal SER_NONE*/
        if (SOC_MEM_SER_CORRECTION_TYPE(unit, mem_ser_info[i].mem) != 0) {
            continue;
        }

        ecc_reg = mem_ser_info[i].ecc_1b_report_en_reg;
        ecc_fld = mem_ser_info[i].ecc_1b_report_en_fld;

        if (soc_reg_field_valid(unit, ecc_reg, ecc_fld)) {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, ecc_reg, REG_PORT_ANY, 0, &rval));
            fld_value = soc_reg_field_get(unit, ecc_reg, rval, ecc_fld);
            break;
        }
    }

    *enable = fld_value ? TRUE:FALSE;
    return SOC_E_NONE;
#else
    return SOC_E_UNAVAIL;
#endif
}


#endif

/*
 * Function:
 *      soc_td2x_ser_single_bit_error_enable_set
 * Purpose:
 *      Enable/Disable single bit eror reporting for the memories which are
 *      protected by ECC logic and whoes SER_RESPONSE is SER_NONE on TD2/TD2p chips
 * Parameters:
 *      unit        - (IN) Device Number
 *      enable         - (IN) Enable/Disable
 * Returns:
 *      SOC_E_NONE if set successfully, an error otherwise
 */
int soc_td2x_ser_single_bit_error_enable_set(int unit, int enable)
{
    int rv = SOC_E_NONE;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        rv = soc_trident2p_ser_single_bit_error_set(unit, enable);
    } else
#endif
    {
        rv = soc_trident2_ser_single_bit_error_set(unit, enable);
    }
    return rv;
}

/*
 * Function:
 *      soc_td2x_ser_single_bit_error_enable_get
 * Purpose:
 *      Get the status of single bit eror reporting for the memories which are
 *      protected by ECC logic and whoes SER_RESPONSE is SER_NONE on TD2/TD2p chips
 * Parameters:
 *      unit        - (IN) Device Number
 *      enable         - (OUT) Enable/Disable
 * Returns:
 *      SOC_E_NONE if get successfully, an error otherwise
 */
int soc_td2x_ser_single_bit_error_enable_get(int unit, int *enable)
{
    int rv = SOC_E_NONE;

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit)) {
        rv = soc_trident2p_ser_single_bit_error_get(unit, enable);
    } else
#endif
    {
        rv = soc_trident2_ser_single_bit_error_get(unit, enable);
    }
    return rv;
}

#endif /* BCM_TRIDENT2_SUPPORT */
