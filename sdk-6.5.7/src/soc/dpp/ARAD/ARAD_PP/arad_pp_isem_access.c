#include <shared/bsl.h>

#include <soc/mcm/memregs.h>
#if defined(BCM_88650_A0)
/*
 * $Id: arad_pp_isem_access.c,v 1.162 Broadcom SDK $
 *
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 */

#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_SOC_LIF
#include <soc/mem.h>

/*************
 * INCLUDES  *
 *************/
/* { */

#include <shared/swstate/access/sw_state_access.h>

#include <soc/dcmn/error.h>
#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_error_code.h>
#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_low_level.h>
#include <soc/dpp/SAND/Utils/sand_os_interface.h>

#include <soc/dpp/ARAD/arad_tbl_access.h>
#include <soc/dpp/ARAD/arad_reg_access.h>
#include <soc/dpp/ARAD/arad_api_ports.h>
#include <soc/dpp/ARAD/arad_init.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_vsi.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_isem_access.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_ce_instruction.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_sw_db.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_port.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_frwrd_fcf.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_mpls_term.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_vtt.h>
#include <soc/dpp/drv.h>

#ifdef CRASH_RECOVERY_SUPPORT
#include <soc/hwstate/hw_log.h>
#include <soc/dcmn/dcmn_crash_recovery.h>
#endif /* CRASH_RECOVERY_SUPPORT */

#include <soc/dpp/PPD/ppd_api_port.h>

#ifdef PLISIM
    #include <sim/dpp/ChipSim/chip_sim_em.h>
#else
    #include <soc/dpp/ARAD/arad_sim_em.h>
#endif

/* } */
/*************
 * DEFINES   *
 *************/
/* { */

#define ARAD_PP_ISEM_ACCESS_DEBUG                                     (0)

#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB                        (0)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB                        (2)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB                         (11)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB                         (SOC_IS_JERICHO(unit)? 60:51)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB                     (SOC_IS_JERICHO(unit)? 61:52)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_MSB                     (SOC_IS_JERICHO(unit)? 77:67)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE                            (3)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(bos_key_feature)       (bos_key_feature ? 1:0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_MSB(bos_key_feature)       (bos_key_feature ? 20:19)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(bos_key_feature)  (ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(bos_key_feature) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_LSB                   1
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_MSB                   20
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_MSB - ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_LSB + 1) 

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB                    (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_MSB                    (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS               (ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_MSB - ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_LSB               (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_MSB               (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_NOF_BITS          (ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_MSB - ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_LSB                    (0)
#define ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_MSB                    (15)
#define ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_NOF_BITS               (ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_MSB - ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB                    		  (0)
#define ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_MSB                    		  (3)
#define ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_NOF_BITS               		  (ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_MSB - ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB                    	  (4)
#define ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_MSB                    	  (7)
#define ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_NOF_BITS               	  (ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_MSB - ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB                    		  (0)
#define ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_MSB                    		  (3)
#define ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_NOF_BITS               		  (ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_MSB - ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(bos_key_feature)         (bos_key_feature ? 21:20)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_MSB(bos_key_feature)         (bos_key_feature ? 32:31)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(bos_key_feature)    (ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(bos_key_feature) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(bos_key_feature)   (bos_key_feature ? 33:32)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_MSB(bos_key_feature)   (bos_key_feature ? 33:32)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_NOF_BITS(bos_key_feature)(ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(bos_key_feature) + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB                  (12)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_MSB                  (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS             (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB                  (44)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_MSB                  (63)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS             (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB              (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MSB              (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB + 1)

/* MASK */
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END            (11)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_START   (32)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_END     (39)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_START   (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_END     (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_START   (41)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_END     (43)

/* 
 * AC lookups look as:
 * [MSB-LSB] Bridge-Prefix, ... , [Inner], [Outer/Initial], 2bits, VD
 * 2bits indication stand for:
 * 00 : Initial-VID
 * 01 : Invalid (Inner-VID)
 * 10 : Outer-VID
 * 11 : Double-Tag
 */
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB            (0)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB            (SOC_IS_JERICHO(unit) ? (8):(7))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS       (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB       (SOC_IS_JERICHO(unit)? (9) :(8))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_MSB       (SOC_IS_JERICHO(unit)? (10) :(9))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS  (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB              (SOC_IS_JERICHO(unit)? (11) :(10))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_MSB              (SOC_IS_JERICHO(unit)? (22) :(21))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB              (SOC_IS_JERICHO(unit)? (23) :(22))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_MSB              (SOC_IS_JERICHO(unit)? (34) :(33))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB              (SOC_IS_JERICHO(unit)? (23) :(22))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_MSB              (SOC_IS_JERICHO(unit)? (23) :(22))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB               (SOC_IS_JERICHO(unit)? (24):(23))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_MSB               (SOC_IS_JERICHO(unit)? (26):(25))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB        (12)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB    (SOC_IS_JERICHO(unit)? (21):(20))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_MSB    (SOC_IS_JERICHO(unit)? (22): (21))
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_NOF_BITS  (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_MSB          (11)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB          (22)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_MSB          (33)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB          (34)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_MSB          (34)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB          (35)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_MSB          (37)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB                     (0)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_MSB                     (31)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS                (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB + 1)

/* my-vtep-index, SIP, VRF in TT:
   Note: DIP -> my-vtep-index at VT.
   We cannot access the result of DIP lookup in TT without the bit: lookup-found.
   (because they're not nibble aligned in the internal buffer)              
   So, we must configure it in our isem entry as well:
   the entry is actually:
    vt-lookup-found, my-vtep-index, SIP, VRF
   */

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_LSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_MSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_NOF_BITS (1)


#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_NOF_BITS(unit) ((SOC_DPP_CONFIG(unit))->pp.vxlan_tunnel_term_in_sem_my_vtep_index_nof_bits)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_LSB (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_MSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_LSB + ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_NOF_BITS(unit) - 1)


#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_NOF_BITS (32)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_LSB(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_MSB(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_LSB(unit) + ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_NOF_BITS - 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_NOF_BITS(unit) ((SOC_DPP_CONFIG(unit))->pp.vxlan_tunnel_term_in_sem_vrf_nof_bits)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_LSB(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_MSB (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_LSB(unit) + ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_NOF_BITS(unit) - 1)


#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB                (12)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB                (43)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB                (44)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB                (75)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB      (76)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MSB      (83)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB      (84)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_MSB      (87)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB + 1)

/*DIP MASK,SIP MASK and Next Protocol mask used for TCAM sw db*/
/*The mask and tcam_db_id are folded into unused key bits in the TCAM sw db*/
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_LSB           (88)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_MSB           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_LSB + 7)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_LSB           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_MSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_MSB           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_LSB + 7)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_LSB      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_MSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_MSB      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_LSB + 8)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_LSB + 1)

/*DIP, SIP, VRF ip tunnel */
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_LSB      (0)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MSB      (31)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_LSB      (32)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MSB      (63)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_LSB            (64)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_LSB + SOC_DPP_DEFS_GET(unit, vrf_nof_bits) - 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_NOF_BITS(unit) (SOC_DPP_DEFS_GET(unit, vrf_nof_bits))

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit))
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_LSB(unit)    (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MSB(unit)    (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_LSB(unit) + 7)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MSB(unit) \
                                                                                     - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_LSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_LSB(unit) + 15)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MSB(unit) \
                                                                                       - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_LSB(unit) + 1)

/* Note: The is IP-GRE tunnel qualifier in the key of the DB is 4b field, MSB is IP-GRE tunnel. 3 LSBs must be ignored */
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MSB(unit) + 3 + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit))
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit) + 3)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_MSB(unit) \
                                                                                       - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit) + 1)

/* Note: ARAD_PP_ISEM_ACCESS_KEY_XXX_MASK_LSB/MSB/NOF_BITS defines are used for sw hash table entry. They are not used for the TCAM mask.
   TCAM mask is built using ARAD_PP_ISEM_ACCESS_KEY_XXX_LSB/MSB/NOF_BITS defines */
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_LSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_LSB(unit) + 5)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_LSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_LSB(unit) + 5)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_LSB(unit) + 1) 

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_LSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_LSB(unit) + 3)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_LSB(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_MSB(unit)      (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_LSB(unit))
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_LSB(unit)    (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_MSB(unit)    (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_LSB(unit) + 3)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_MSB(unit) \
                                                                                          - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_LSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_LSB(unit) + 4)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_MSB(unit) \
                                                                                            - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_LSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_MSB(unit) + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_MSB(unit)  (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_LSB(unit))
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_NOF_BITS(unit) (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_MSB(unit)  \
                                                                                            - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_LSB(unit) + 1)



#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB                   (24)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_MSB                   (29)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB                          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_MSB                          (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TEST1_ISID_MSB                        (15)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS                     (ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TEST1_ISID_NOF_BITS                   (ARAD_PP_ISEM_ACCESS_KEY_TEST1_ISID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB                   (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_MSB                   (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB      (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_MSB      (14)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB      (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_MSB      (22)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_MSB             (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB + 1)

/* Trill VSI */
/* Pad first 8bits with zeros */
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB                   (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_MSB                   (SOC_IS_JERICHO(unit)? 8 : 7)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB + ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_NOF_BITS)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_MSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB + ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_MSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB + 11)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB + ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_MSB        (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB + 11)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB        (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_MSB        (11)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB + 1)


/* GRE {*/
/* vpn key */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB + 1)

/* flags  */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB             (24)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB             (27)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB + 1)
/* gre flags value */
/* checksum=0,routing = 0,key = 1 , SeqN = 0 */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL             (2)

/* local port vlan domain */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_LSB             (28)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_MSB             (35)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_LSB + 1)
/* GRE }*/

/* IPv6 tunnel DIP {*/
/* DIP */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB             127
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB + 1)
/* IPv6 tunnel }*/

/* PON { */
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB               (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_MSB(unit)         (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 5 : (SOC_IS_JERICHO(unit) ? 3 : 2))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS(unit)    (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB + 1)
                
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB(unit)              (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit)? 6 : (SOC_IS_JERICHO(unit) ? 4 : 3))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_MSB(unit)              (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 21: (SOC_IS_JERICHO(unit) ? 19: 13))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS(unit)         (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 22: (SOC_IS_JERICHO(unit) ? 20 : 14))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 33: (SOC_IS_JERICHO(unit) ? 31 : 25))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 34 : (SOC_IS_JERICHO(unit) ? 32 : 26))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 45 : (SOC_IS_JERICHO(unit) ? 43 : 37))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB(unit) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB               (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB(unit)         (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 5: (SOC_IS_JERICHO(unit) ? 3 : 2))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS(unit)    (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB + 1)
   
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB(unit)              (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 6 : (SOC_IS_JERICHO(unit) ? 4 : 3))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB(unit)              (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 21 : (SOC_IS_JERICHO(unit) ? 19 : 13))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS(unit)         (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB(unit) + 1)
      
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 22 : (SOC_IS_JERICHO(unit) ? 20 : 14))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 37 : (SOC_IS_JERICHO(unit) ? 35 : 29))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB(unit) + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 38 : (SOC_IS_JERICHO(unit) ? 36 : 30))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 49 : (SOC_IS_JERICHO(unit) ? 47 : 41))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB(unit) + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 50 : (SOC_IS_JERICHO(unit) ? 48 : 42))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 50 : (SOC_IS_JERICHO(unit) ? 48 : 42))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB(unit) + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 51 : (SOC_IS_JERICHO(unit) ? 49 : 43))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 53 : (SOC_IS_JERICHO(unit) ? 51 : 45))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB(unit) + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 54 : (SOC_IS_JERICHO(unit) ? 52 : 46))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB(unit)           (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit) ? 65 : (SOC_IS_JERICHO(unit) ? 63 : 57))
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS(unit)      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB(unit) - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB(unit) + 1)   
/* PON } */

/* Spoof { */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_MSB (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB (32)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_MSB (39)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_MSB (127)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB (128)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_MSB (134)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB (40)
#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_MSB (47)
#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_MSB - ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB + 1)
/* Spoof } */


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB             (24)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB             (27)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL             (2)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB             127
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_LSB              (24)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_MSB              (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_MSB             (7)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_LSB             (8)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_MSB             (20)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_LSB + 1)


/* SIP OVERLAY for learn info */
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB                 (0)
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_MSB                 (31)
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB + 1)

/* RPA */
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB                 (0)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_MSB                 (27)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB                 (28)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_MSB                 (36)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_MSB - ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB + 1)

/* Flexible QinQ */
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_MSB          (11)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB         (SOC_IS_JERICHO(unit)? (13):(12))
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_MSB         (SOC_IS_JERICHO(unit)? (20):(19))
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB           (SOC_IS_JERICHO(unit)? (21):(20))
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_MSB           (SOC_IS_JERICHO(unit)? (32):(31))
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB + 1)

/* TST */
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB         (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_MSB        (SOC_IS_JERICHO(unit)? (8):(7))
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB          (SOC_IS_JERICHO(unit)? (9):(8))
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_MSB          (SOC_IS_JERICHO(unit)? (20):(19))
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB + 1)                             
                               
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB          (SOC_IS_JERICHO(unit)? (21):(20))
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_MSB          (SOC_IS_JERICHO(unit)? (32):(31))
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB + 1)


/* 
 * Defines for 2 bits indication
 */
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID (0)
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID   (2)
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG  (3)

/* Access profile ID being concat to Key */
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB       (161)
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_MSB       (166)
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_NOF_BITS  (ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_MSB - ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB + 1)


/* VTT KBR get defines { */
/* { */

/* Field Selectors */
/* 32BITS CE: [15:11] num of bits, [10:4] offset, [3] sel, [2:0] offset select
   16BITS CE: [15:12] num of bits, [11:4] offset, [3] sel, [2:0] offset select */
#define ARAD_PP_FS_INST_OFFSET_SELECT_OFF   0
#define ARAD_PP_FS_INST_OFFSET_SELECT_SIZE  3
#define ARAD_PP_FS_INST_OFFSET_SELECT_MASK  0x3
#define ARAD_PP_FS_INST_INPUT_SELECT_OFF    (ARAD_PP_FS_INST_OFFSET_SELECT_OFF + ARAD_PP_FS_INST_OFFSET_SELECT_SIZE)
#define ARAD_PP_FS_INST_INPUT_SELECT_SIZE   1
#define ARAD_PP_FS_INST_INPUT_SELECT_MASK   0x1
#define ARAD_PP_16B_FS_INST_SHIFT_OFF       (ARAD_PP_FS_INST_INPUT_SELECT_OFF + ARAD_PP_FS_INST_INPUT_SELECT_SIZE)
#define ARAD_PP_16B_FS_INST_SHIFT_SIZE      8
#define ARAD_PP_16B_FS_INST_SHIFT_MASK      0xff
#define ARAD_PP_32B_FS_INST_SHIFT_OFF       (ARAD_PP_FS_INST_INPUT_SELECT_OFF + ARAD_PP_FS_INST_INPUT_SELECT_SIZE)
#define ARAD_PP_32B_FS_INST_SHIFT_SIZE      7
#define ARAD_PP_32B_FS_INST_SHIFT_MASK      0x7f
#define ARAD_PP_16B_FS_INST_SIZE_OFF        (ARAD_PP_16B_FS_INST_SHIFT_OFF + ARAD_PP_16B_FS_INST_SHIFT_SIZE)
#define ARAD_PP_16B_FS_INST_SIZE_SIZE       4
#define ARAD_PP_16B_FS_INST_SIZE_MASK       0xf
#define ARAD_PP_32B_FS_INST_SIZE_OFF        (ARAD_PP_32B_FS_INST_SHIFT_OFF + ARAD_PP_32B_FS_INST_SHIFT_SIZE)
#define ARAD_PP_32B_FS_INST_SIZE_SIZE       5
#define ARAD_PP_32B_FS_INST_SIZE_MASK       0x1f


/* only should be used in VT */
#define ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(X) ((SOC_IS_JERICHO(unit)? 0x0088: 0x0088) | ((X-1) << 11))
#define ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(X)  ((SOC_IS_JERICHO(unit)? 0x0048: 0x0048) | ((X-1) << 11))

#define ARAD_PP_ISEM_ACCESS_16B_INST_PP_TT_PORT_KEY_VAR                                                          (0xf448)
#define ARAD_PP_ISEM_ACCESS_16B_INST_PP_TT_PORT_KEY_VAR_X_LSBS(X)                                                (0x448 | ((X-1) << 12))
 
#define ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(X) ((SOC_IS_JERICHO(unit)? 0x0148: 0x0148) | ((X-1) << 12))
#define ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(X)  ((SOC_IS_JERICHO(unit)? 0x00C8: 0x00C8) | ((X-1) << 12))
#define ARAD_PP_ISEM_ACCESS_32B_INST_32_ONES    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(32))
#define ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES     (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(2))
#define ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES     (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(1))
#define ARAD_PP_ISEM_ACCESS_32B_INST_2_ZEROS    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(2))
#define ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(1))
#define ARAD_PP_ISEM_ACCESS_16B_INST_2_ONES     (ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(2))
#define ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES     (ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(1))
#define ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS    (ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(2)) 
#define ARAD_PP_ISEM_ACCESS_16B_INST_1_ZEROS    (ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(1))


/* Offset of first MPLS Label in MPLS-key-Array */
#define ARAD_PP_16B_INST_OFFSET_0_ENH_MPLS_KEY0    0x66
#define ARAD_PP_32B_INST_OFFSET_0_ENH_MPLS_KEY0    0x31

/* Building MPLS instructions */
#define ARAD_PP_16B_INST_MPLS(mpls_lbl, offset, num_of_bits) \
	                            ((((num_of_bits-1) & ARAD_PP_16B_FS_INST_SIZE_MASK ) << ARAD_PP_16B_FS_INST_SIZE_OFF) | \
	                            ((((ARAD_PP_16B_INST_OFFSET_0_ENH_MPLS_KEY0 + ((mpls_lbl-1) * 12)) - offset/4) & ARAD_PP_16B_FS_INST_SHIFT_MASK) << ARAD_PP_16B_FS_INST_SHIFT_OFF) | \
	                               ( 1 << ARAD_PP_FS_INST_INPUT_SELECT_OFF) | \
	                               ( 0 << ARAD_PP_FS_INST_OFFSET_SELECT_OFF))

#define ARAD_PP_32B_INST_MPLS(mpls_lbl, offset, num_of_bits) \
	                            ((((num_of_bits-1) & ARAD_PP_32B_FS_INST_SIZE_MASK ) << ARAD_PP_32B_FS_INST_SIZE_OFF) | \
	                            ((((ARAD_PP_32B_INST_OFFSET_0_ENH_MPLS_KEY0 + ((mpls_lbl-1) * 6)) - offset/8) & ARAD_PP_32B_FS_INST_SHIFT_MASK) << ARAD_PP_32B_FS_INST_SHIFT_OFF) | \
	                               ( 1 << ARAD_PP_FS_INST_INPUT_SELECT_OFF) | \
	                               ( 0 << ARAD_PP_FS_INST_OFFSET_SELECT_OFF))

#define ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VSI_12_BIT           (SOC_IS_JERICHO_PLUS(unit) ? 0xbae8 : (SOC_IS_JERICHO(unit)?(0xb9E8) : (0xb5e8)))

#define ARAD_PP_MPLS_1_19_16   (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(1,16,4): (ARAD_PP_CE_MPLS_1_19_16))
#define ARAD_PP_MPLS_1_15_0    (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(1,0,16): (ARAD_PP_CE_MPLS_1_15_0))
#define ARAD_PP_MPLS_2_19_16   (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(2,16,4): (ARAD_PP_CE_MPLS_2_19_16))
#define ARAD_PP_MPLS_2_15_0    (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(2,0,16): (ARAD_PP_CE_MPLS_2_15_0))
#define ARAD_PP_MPLS_3_19_16   (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(3,16,4): (ARAD_PP_CE_MPLS_3_19_16))
#define ARAD_PP_MPLS_3_15_0    (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(3,0,16): (ARAD_PP_CE_MPLS_3_15_0))
#define ARAD_PP_MPLS_4_19_16   (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(4,16,4): (ARAD_PP_CE_MPLS_4_19_16))
#define ARAD_PP_MPLS_4_15_0    (SOC_IS_JERICHO(unit)? ARAD_PP_16B_INST_MPLS(4,0,16): (ARAD_PP_CE_MPLS_4_15_0))

#define ARAD_PP_MPLS_1_31_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(1,0,32): (ARAD_PP_CE_MPLS_1_31_0))
#define ARAD_PP_MPLS_2_31_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(2,0,32): (ARAD_PP_CE_MPLS_2_31_0))
#define ARAD_PP_MPLS_3_31_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(3,0,32): (ARAD_PP_CE_MPLS_3_31_0))
#define ARAD_PP_MPLS_4_31_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(4,0,32): (ARAD_PP_CE_MPLS_4_31_0))
#define ARAD_PP_MPLS_1_19_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(1,0,20): (ARAD_PP_CE_MPLS_1_19_0))
#define ARAD_PP_MPLS_2_19_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(2,0,20): (ARAD_PP_CE_MPLS_2_19_0))
#define ARAD_PP_MPLS_3_19_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(3,0,20): (ARAD_PP_CE_MPLS_3_19_0))
#define ARAD_PP_MPLS_4_19_0    (SOC_IS_JERICHO(unit)? ARAD_PP_32B_INST_MPLS(4,0,20): (ARAD_PP_CE_MPLS_4_19_0))

/* kbr defines } */
/* VTT KBR get defines } */


#define  ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK   (0x3)
#define  ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS (0x2)

/* priority of each key field in TCAM */
#define ARAD_PP_ISEM_ACCESS_PON_ETHERTYPE_PRIO    (1)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_DEI_PRIO    (1)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_PCP_PRIO    (10)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_VID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_INNER_VID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_TUNNEL_ID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_VD_PRIO           (50)



/* } */
/*************
 * MACROS    *
 *************/
/* { */
          
/* } */
/*************
 * TYPE DEFS *
 *************/
/* { */

typedef enum
{
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DELETE = 0,
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_INSERT = 1,
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DEFRAG = 4
}ARAD_PP_ISEM_ACCESS_ACTION_TYPE;


ARAD_PP_ISEM_ACCESS_PROGRAM_INFO vt_programs[SOC_MAX_NUM_DEVICES][PROG_VT_NOF_PROGS];
ARAD_PP_ISEM_ACCESS_PROGRAM_INFO tt_programs[SOC_MAX_NUM_DEVICES][PROG_TT_NOF_PROGS];

#define SET_VT_PROGRAM_ID(unit, program_name) \
  { \
    if (last_vt_program_id > (SOC_DPP_DEFS_GET(unit, nof_vtt_programs) -1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8100, exit); \
    } \
    vt_programs[unit][program_name].prog_used = last_vt_program_id++; \
  }

#define SET_TT_PROGRAM_ID(program_name) \
  { \
    if (last_tt_program_id > (SOC_DPP_DEFS_GET(unit, nof_vtt_programs)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8110, exit); \
    } \
    tt_programs[unit][program_name].prog_used = last_tt_program_id++; \
  }

#define SET_VT_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8120, exit); \
    } \
  }

#define SET_VT_2_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx+1 > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8130, exit); \
    } \
  }


#define SET_TT_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8140, exit); \
    } \
  }


#define ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(valid_prog) \
  ((valid_prog != -1) ? (tmp+1):tmp)
   

CONST STATIC SOC_PROCEDURE_DESC_ELEMENT
  Arad_pp_procedure_desc_element_isem_access[] =
{
  /*
   * Auto generated. Do not edit following section {
   */
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_ISEM_ACCESS_GET_PROCS_PTR),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_ISEM_ACCESS_GET_ERRS_PTR),
  /*
   * } Auto generated. Do not edit previous section.
   */

  /*
   * Last element. Do no touch.
   */
  SOC_PROCEDURE_DESC_ELEMENT_DEF_LAST
};

CONST STATIC SOC_ERROR_DESC_ELEMENT
  Arad_pp_error_desc_element_isem_access[] =
{
  /*
   * Auto generated. Do not edit following section {
   */
  /*
   * } Auto generated. Do not edit previous section.
   */

  {
    ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR,
    "ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR",
    "Unknown key type. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_NOT_READY_ERR,
    "ARAD_PP_ISEM_ACCESS_NOT_READY_ERR",
    "Sem is not ready. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_MPLS_IN_RIF_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_MPLS_IN_RIF_NOT_SUPPORTED_ERR",
    "MPLS_IN_RIF entries are not supported when working in mpls core mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_LABEL_INDEX_OUT_OF_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_LABEL_INDEX_OUT_OF_RANGE_ERR",
    "label_index is out of range. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_LABEL_INDEX_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_LABEL_INDEX_NOT_SUPPORTED_ERR",
    "label_index is not supported when working in mpls labels share mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_INCORRECT_DEF_ALLOCATION_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_INCORRECT_DEF_ALLOCATION_ERR",
    "default allocation of program selection excess nof entries. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR",
    "user define entry index excess nof entries. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR",
    "invalid convertion lif key from , to program selection. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_AC_KEY_SET_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_AC_KEY_SET_NOT_SUPPORTED_ERR",
    "ac map key is not supported when working in simple vlan translation mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR,
    "ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR",
    "Illegal configuration of vlan translation programs in vtt: inmatch soc properties. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR,
    "ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR",
    "Trying to add entry in TCAM when key type is not supported for TCAM. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR,
    "ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR",
    "Number of allocated VT, TT programs is over the possible number of programs. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },

  /*
   * Last element. Do no touch.
   */
SOC_ERR_DESC_ELEMENT_DEF_LAST
};

/* } */
/*************
 * GLOBALS   *
 *************/
/* { */

ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES g_prog_soc_prop[BCM_MAX_NUM_UNITS] = {{0}};
int                                         is_g_prog_soc_prop_initilized[BCM_MAX_NUM_UNITS] = {0};   

extern ARAD_PP_DBAL_VTT_PROGRAM_INFO           vt_dbal_programs[ARAD_PP_DBAL_VT_NOF_PROGRAMS];
extern ARAD_PP_DBAL_VT_PROGRAM_SELECTION_INFO  vt_dbal_program_selection[ARAD_PP_DBAL_VT_NOF_PROGRAM_SELECTION];
extern ARAD_PP_DBAL_VTT_PROGRAM_INFO           tt_dbal_programs[ARAD_PP_DBAL_TT_NOF_PROGRAMS];
extern ARAD_PP_DBAL_TT_PROGRAM_SELECTION_INFO  tt_dbal_program_selection[ARAD_PP_DBAL_TT_NOF_PROGRAM_SELECTION];



/* Result to use values */

/* Priority decoter bitmap enable set */

/* } */
/*************
 * FUNCTIONS *
 *************/

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set(
     int unit,     
     int prog_indx,
     int prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: all packets with the following port profile, up until now we tried to match double and single tag */
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* UnTagged and priority packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL;  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */  
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY); /* also SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID*/ 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID); 
                                                                    /* SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID,
                                                                       SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY */  
  prog_selection_1st_cam_tbl.llvp_prog_sel                 = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set", prog_indx, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(
     int unit,
     uint32 prog_indx0, /* PROG_VT_VD_OUTER_RULE */
     uint32 prog_indx1, 
     uint32 port_profile,
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);

  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  }

  
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  }
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set", prog_indx0, prog_sel);
}



STATIC
uint32
  arad_pp_vtt_prog_sel_cam_key_program_1st_set(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32
    res,
    prog_indx = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* In tst2 case program selection will be set in arad_pp_vtt.c file */
  if(prog_soc_prop->custom_feature_vt_tst2)
  {
      ARAD_DO_NOTHING_AND_EXIT;
  }

  if (vt_programs[unit][PROG_VT_TM_PROG].prog_used != -1)
  {
      if (SOC_IS_ARADPLUS_A0(unit) && SOC_DPP_CONFIG(unit)->pp.oam_statistics)
     {
          vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TM_STAT].priority[unit]  = prog_indx;
          vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TM_STAT].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_TM_STAT;
      }
      else
      {
          vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TM].priority[unit]  = prog_indx;
          vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TM].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_TM;
      }
  }

  /* Exit here in case of TM init */
  if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) 
  {
    ARAD_DO_NOTHING_AND_EXIT;
  }

  if (SOC_DPP_CONFIG_CUSTOM_PP_PORT_IS_VENDOR2()) {
      SET_VT_2_PROGRAM_SELECTION(prog_indx);
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_CUSTOM_PP_PORT_TUNNEL].priority[unit]  = prog_indx;
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_CUSTOM_PP_PORT_TUNNEL].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VT_CUSTOM_PP_PORT_TUNNEL;
      
      prog_indx++;     
  }

  if (vt_programs[unit][PROG_VT_TEST2].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TEST2].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_TEST2].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VT_TEST2;

    prog_indx++; 
  }


  /* 
   * Ethernet logic in general: 
   * 1. One-tag packets and no priority (2 program selection per program) 
   * 2. Untagged, priority tag and Initial-VID port (2 program selection per program)
   * 3. Double-tag packets and no priority (1 program selection per program)    
   */

  /* 
   * PON logic: 
   * Special Port profile
   * 1. Untagged packet
   * 2. One tag packet
   * 3. Double tag packets under different PonPortprofile. 
   * {
   */
   
   
  /* Untagged and priority-tag */
  if (vt_programs[unit][PROG_VT_PON_UNTAGGED].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_UNTAGGED].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_UNTAGGED].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_UNTAGGED;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_PRIORITY_TAG].priority[unit]  = (prog_indx+1);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_PRIORITY_TAG].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_UNTAGGED;

    prog_indx++;
  }

  /* one-tag */
  if (vt_programs[unit][PROG_VT_PON_ONE_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_ONE_TAG_1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_ONE_TAG_1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_ONE_TAG;

    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_ONE_TAG_2].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_ONE_TAG_2].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_ONE_TAG;
  }

  /* Double tags */
  if (vt_programs[unit][PROG_VT_PON_TWO_TAGS].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_TWO_TAGS].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_TWO_TAGS].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_TWO_TAGS;
  }

  if (vt_programs[unit][PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_TWO_TAGS_VS_TUNNEL_ID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_TWO_TAGS_VS_TUNNEL_ID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_TWO_TAGS_VS_TUNNEL_ID;
  }

  if (vt_programs[unit][PROG_VT_PON_ONE_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_IGNORE_2ND_TAG].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_PON_IGNORE_2ND_TAG].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_PON_ONE_TAG;
  }
  
  /* VT MPLS Port termination */
  if (vt_programs[unit][PROG_VT_INDX_MPLS_PORT_L1].prog_used != -1) {
      SET_VT_PROGRAM_SELECTION(prog_indx);
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_MPLS_PORT_L1].priority[unit] = prog_indx;
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_MPLS_PORT_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_MPLS_PORT_L1;
  }

  
  
  /* 
   * PON logic 
   * }
   */
   
  /* 
   * FRR logic: 
   * Special Port profile 
   * 1. Outer tag
   * 2. Untagged + priority + initial-VID
   * Note : no support for double-tag.
   * {   
   */
  if (vt_programs[unit][PROG_VT_VD_OUTERVID_L1FRR].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_L1FRR].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_L1FRR].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_OUTERVID_L1FRR;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_INDX_VD_OUTERVID_FRR_L1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_INDX_VD_OUTERVID_FRR_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDX_VD_OUTERVID_FRR_L1;
    prog_indx++; /* adding 2 program selections in one call */
  }  
  
  if (vt_programs[unit][PROG_VT_VD_INITIALVID_L1FRR].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_L1FRR].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_L1FRR].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_L1FRR;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_INDX_VD_INITIALVID_FRR_L1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_INDX_VD_INITIALVID_FRR_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDX_VD_INITIALVID_FRR_L1;
    prog_indx++; /* adding 2 program selections in one call */
  }

  /* 
   * FRR logic
   * }   
   */
      
  /*
   * EVB logic:
   * Special port profile
   * 1. Stag 
   * 2. Ctag or untagged
   * {
   */
  
  if (vt_programs[unit][PROG_VT_EVB_S_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EVB_S_TAG].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EVB_S_TAG].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_EVB_S_TAG;
  }  

  if (vt_programs[unit][PROG_VT_EVB_UN_C_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EVB_UN_C_TAG].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EVB_UN_C_TAG].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_EVB_UN_C_TAG;
  }
  
  /*
   * EVB logic
   * }   
   */


  if (vt_programs[unit][PROG_VT_EXTENDER_PE].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EXTENDER_PE].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EXTENDER_PE].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_EXTENDER_PE;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_EXTENDER_PE_UT].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EXTENDER_PE_UT].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_EXTENDER_PE_UT].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_EXTENDER_PE_UT;
  }

  /* 
   * 5 tuple logic 
   * Special port profile 
   * 1. Untagged + Initial-VID 
   * 2. Double-tag 
   */
  if (vt_programs[unit][PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_SINGLE_TAG_5_TUPLE_QINQ].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_SINGLE_TAG_5_TUPLE_QINQ].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_SINGLE_TAG_5_TUPPLE_QINQ;

  }

  if (vt_programs[unit][PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_5_TUPLE_QINQ].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_5_TUPLE_QINQ].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_5_TUPPLE_QINQ;
  }


  /*
   * Trill logic:
   * Special port profile
   * 1. Designate-VID
   * 2. Outer tag
   * 3. Untagged + initial-VID
   * 4. Double-tag   
   * {
   */
  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][PROG_VT_VD_DESIGNATED_VID_TRILL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_DESIGNATED_VID_TRILL].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_DESIGNATED_VID_TRILL].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_DESIGNATED_VID_TRILL;

    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][PROG_VT_VD_OUTER_TRILL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_TRILL].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_TRILL].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_TRILL;

    prog_indx++; /* adding 2 program selections in one call */
  }
   
  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][PROG_VT_VD_INITIALVID_TRILL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_TRILL].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_TRILL].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_TRILL;

    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][PROG_VT_VD_OUTER_INNER_TRILL].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID_TRILL].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID_TRILL].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_TRILL;

  }  
  /*
   * Trill logic
   * }
   */

  /*
   * Double-lookup logic:
   * Special port profile.
   * 1. In case packet is double-tagged then two lookups
   * 2. Otherwise one lookup (needed only in case MPLS database in ISEM-B, 
   * in case MPLS database is in ISEM-A then we already have matched programs for that. 
   * {
   */
  if (vt_programs[unit][PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID_OR_OUTER_VID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID_OR_OUTER_VID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_OR_OUTER_VID_L1;

    prog_indx++; /* adding 2 program selections in one call */
  } 

  if (vt_programs[unit][PROG_VT_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER;
    prog_indx++; /* adding 2 program selections in one call */
  }
  
  if (vt_programs[unit][PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_PRIORITY_INITIAL_VID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_PRIORITY_INITIAL_VID;
    prog_indx++; /* adding 2 program selections in one call */
  } 

  /*
   * Defaults in case of no match in double lookup. 
   * Two cases: 
   * 1. Single-tag and Untagged packets which dont match Double tag special programs. 
   *  Note: Only needed in case MPLS deafults located in ISEM-B then we dont have existed program
   *  that can use Bridge database in ISEM-B.
   *  Note2: Double lookup port will support MPLS only in case MPLS database is located in SEM-A.
   */      
  if (prog_soc_prop->mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
       vt_programs[unit][PROG_VT_VD_OUTER_TRILL].prog_used != -1)
  {
    /* Add new program selections for outer vid in SEM-B */    
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY,
                                                                   vt_programs[unit][PROG_VT_VD_OUTER_TRILL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, PROG_VT_VD_OUTER_TRILL, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
      vt_programs[unit][PROG_VT_VD_INITIALVID_TRILL].prog_used != -1)
  {    
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set(unit,prog_indx,                                                                        
                                                                      vt_programs[unit][PROG_VT_VD_INITIALVID_TRILL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, PROG_VT_VD_INITIALVID_TRILL, exit);
  }      

  /*
   * Double-lookup logic
   * }
   */
  
  /*
   * Logic for special PCP programs 
   * 1. Tagged 
   * 2. Untag 
   * 3. Double-tag 
   * Note: In case PCP programs are set no IP , MPLS tunnels can be used
   * {
   */ 
  if (vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    /*res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used);*/
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_OR_VD_OUTER_PCP].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_OR_VD_OUTER_PCP].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_OUTER_OR_VD_OUTER_PCP;
    prog_indx++; /* adding 2 program selections in one call */

  }

  if (prog_soc_prop->port_vlan_pcp_lookup &&
      vt_programs[unit][PROG_VT_VDxINITIALVID_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);

    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1;
    prog_indx++; /* adding 2 program selections in one call */
  }    

  if (vt_programs[unit][PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP;
  }    
  
  /*
   * Logic for special PCP programs
   * }
   */  
   
  /*
   * Logic for special 64K programs 
   * 1. Tagged 
   * 2. Untag 
   * 3. Double-tag
   * Note: In case 64K programs are set no IP , MPLS tunnels can be used
   */
  if (vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    /*res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used);*/
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_OR_VD_OUTER].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_OR_VD_OUTER].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_OUTER_OR_VD_OUTER;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_OR_VD_INITIALVID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_OR_VD_INITIALVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_OR_VD_INITIALVID;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_OR_VD_OUTER_INNER].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_OUTER_INNER_OR_VD_OUTER_INNER;
  }
  
  /*
   * Logic for special 64K programs
   * }
   */
    /*
     * Logic for IP-LIF-DUMMY
     * 1. Outer tag
     * 2. Untagged + priority + initial-VID
     * Note : no support for double-tag.
     * {
     */
  if (vt_programs[unit][PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxOUTERVID_AFTER_RCY].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxOUTERVID_AFTER_RCY].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_IPV4_VDxOUTERVID_AFTER_RCY;
    prog_indx++; /* adding 2 program selections in one call */

  }
  
  if (vt_programs[unit][PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxINITIALVID_AFTER_RCY].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxINITIALVID_AFTER_RCY].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_IPV4_VDxINITIALVID_AFTER_RCY;
    prog_indx++; /* adding 2 program selections in one call */
  }
  
  
  /*
 * Logic for port termination of IP tunnels 
 * 1. Outer tag
 * 2. Untagged + priority + initial-VID
 * Note : no support for double-tag.
 * {
 */
  if (vt_programs[unit][PROG_VT_IPV4_PORT].prog_used != -1) {
      SET_VT_PROGRAM_SELECTION(prog_indx);
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_PORT_TERMINATION].priority[unit] = prog_indx;
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_PORT_TERMINATION].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_IPV4_PORT;
  }

  /*
   * Logic for IP tunnels
   * 1. Outer tag
   * 2. Untagged + priority + initial-VID
   * Note : no support for double-tag.
   * {
   */
  if (vt_programs[unit][PROG_VT_IPV4_OUTER_VID].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxOUTERVID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxOUTERVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_IPV4_VDxOUTERVID;

    prog_indx++; /* adding 2 program selections in one call */
  }
  
  if (vt_programs[unit][PROG_VT_IPV4_INITIAL_VID].prog_used != -1)
  {
      SET_VT_2_PROGRAM_SELECTION(prog_indx);
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxINITIALVID].priority[unit]  = prog_indx;
      vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_IPV4_VDxINITIALVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_IPV4_VDxINITIALVID;

      prog_indx++; /* adding 2 program selections in one call */
  }  
  /*
   * Logic for IP tunnels
   * }
   */
  
  /* 
   * MPLS logic 
   * 1. ELI valid for Unindex and Indexed - second MPLS label is ELI.     
   *  a. In case tagged
   *  b. In case untagged or priority or Initial-VID
   * Note: ELI is not valid when MPLS context include RIF. 
   * 2. MPLS context RIF 
   *  a. In case tagged
   *  b. In case untagged or priority or Initial-VID
   * Note: Also used as default programs in case there is not match so far
   * {
   */



  /* ELI logic { */
  if (vt_programs[unit][PROG_VT_VDxOUTERVID_L1_L2ELI].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_L1_L2ELI].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID_L1_L2ELI].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_L1_L2ELI;

    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VDxINITIALVID_L1_L2ELI].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_L1_L2ELI].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_L1_L2ELI].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1_L2ELI;

    prog_indx++; /* adding 2 program selections in one call */
  } 
  
  /* ELI logic } */ 

  /* MPLS context RIF logic { */

  if (vt_programs[unit][PROG_VT_INDX_VD_OUTERVID_L3].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxOUTERVID_L3].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxOUTERVID_L3].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDEXED_VDxOUTERVID_L3;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_L3].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxINITIALVID_L3].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxINITIALVID_L3].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDEXED_VDxINITIALVID_L3;
    prog_indx++; /* adding 2 program selections in one call */
  }
  /* MPLS context RIF logic } */

  if (vt_programs[unit][PROG_VT_VD_INITIALVID_VLAN_DOMAIN_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_VLAN_DOMAIN_L1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID_VLAN_DOMAIN_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_VLAN_DOMAIN_L1;

  }
  /* MPLS Defaults Unindex { */
  if (vt_programs[unit][PROG_VT_VDxOUTERVID_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTERVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_L1;

    prog_indx++; /* adding 2 program selections in one call */
  }  

  
  
  if (vt_programs[unit][PROG_VT_VDxINITIALVID_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INITIALVID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1;

    prog_indx++; /* adding 2 program selections in one call */
  }     
  /* MPLS Defaults Unindex } */


  /* MPLS Defaults Indexed { */
  if (vt_programs[unit][PROG_VT_INDX_VD_OUTERVID_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxOUTERVID_L1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxOUTERVID_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDEXED_VDxOUTERVID_L1;

    prog_indx++; /* adding 2 program selections in one call */
  }    

  if (vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_L1].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxINITIALVID_L1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_INDEXED_VDxINITIALVID_L1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_INDEXED_VDxINITIALVID_L1;
    prog_indx++; /* adding 2 program selections in one call */
  }
  /* MPLS Defaults Indexed } */  

  /* Double-tag packets which dont match MAC termination programs. */
  /* Double tag defaults { */
  if (vt_programs[unit][PROG_VT_VD_OUTER_INNER].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_VD_OUTER_INNER_VID].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_L1;
  }  
  /* Double tag defaults } */  

  /* Test programs Untagged then Double-tag then Single-tag { */
  if (vt_programs[unit][PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_EXP_NULL_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_EXP_NULL_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_UNTAGGED_EXP_NULL_TST1;
    prog_indx++; /* adding 2 program selections in one call */
  }  
 
  if (vt_programs[unit][PROG_VT_VD_INITIALVID_VRRP].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_VRRP].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_VRRP].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_UNTAGGED_VRRP;
  }  

  if (vt_programs[unit][PROG_VT_VD_INITIALVID].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_UNTAGGED_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_UNTAGGED_TST1;
  }  

  if (vt_programs[unit][PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_EXP_NULL_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_EXP_NULL_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_EXP_NULL_TST1;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VD_DOUBLE_TAG_VRRP].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_VRRP].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_VRRP].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_VRRP;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VD_DOUBLE_TAG].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_DOUBLE_TAG_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_TST1;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_EXP_NULL_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_EXP_NULL_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_ONE_TAG_EXP_NULL_TST1;
    prog_indx++; /* adding 2 program selections in one call */    
  } 

  if (vt_programs[unit][PROG_VT_VD_SINGLE_TAG_VRRP].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_VRRP].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_VRRP].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_ONE_TAG_VRRP;
  } 

  if (vt_programs[unit][PROG_VT_VD_SINGLE_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_TST1].priority[unit]  = prog_indx;
    vt_dbal_program_selection[ARAD_PP_DBAL_VT_PROG_SELECTION_ONE_TAG_TST1].prog_name[unit] = ARAD_PP_DBAL_VT_PROG_ONE_TAG_TST1;
  } 
  /* Test programs Untagged > Double-tag > Single-tag } */

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_set()", prog_indx, 0);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IP_ROUTER_CompatibleMc_2ND_RULE_NUM */
     uint32 prog_sel,
     uint32 ipv4_comp_mc_disable,
	 uint32 is_bridging_program
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4/ipv6 header & ip compatible mc is on */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.enable_routing_mask              = 1;
  prog_selection_2nd_cam_tbl.packet_format_code               = 0x3;/*6b00_0011; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = (ipv4_comp_mc_disable) ? 0x38:0x39;/*6b11_1001;*/ /* Include or not IPV4 */
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;/*1b0;*/
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  if (is_bridging_program) {
	  prog_selection_2nd_cam_tbl.ptc_tt_profile          = ARAD_PORTS_TT_PROFILE_PON; /* (rcy port) PTC */
	  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask     = 0x00;
  }
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set", prog_indx, prog_sel);
}

static int ipmc_second_pass_caused_by_rpf_fail(int unit){
	int result = 0;
	int port_ndx=0;

	for(port_ndx=0; port_ndx< ARAD_PORT_NOF_PP_PORTS ; port_ndx++ ) {
		if (soc_property_port_suffix_num_get(unit, port_ndx, -1,spn_CUSTOM_FEATURE,"rpf_failing_recycle_enable", FALSE)==1) {
			result = 1;
		}
	}
	return result; 
}


STATIC
uint32
  arad_pp_isem_prog_sel_cam_key_program_2nd(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32
    prog_indx = 0,
    res;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if (tt_programs[unit][PROG_TT_BFD_STAT_PROG].prog_used != -1)
  {
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BFD_STAT].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BFD_STAT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BFD_STAT;
  }

  if (tt_programs[unit][PROG_TT_OAM_STAT_PROG].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_OAM_STAT].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_OAM_STAT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_OAM_STAT;
  }

  if (tt_programs[unit][PROG_TT_TM_PROG].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TM].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TM].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TM;
  }
  /* TT MPLS Port termination */
  if (tt_programs[unit][PROG_TT_INDX_MPLS_PORT_L3_L2].prog_used != -1) {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_PORT_L3_L2].priority[unit] = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_PORT_L3_L2].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_MPLS_PORT_L3_L2;
  }

  /* Exit here in case of TM init */
  if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) {
      ARAD_DO_NOTHING_AND_EXIT;
  }

  /* 
     Port Extender
  */

  /* Routing + Compatible MC */
  if (SOC_IS_JERICHO(unit) && tt_programs[unit][PROG_TT_EXTENDER_UNTAG_CHECK_IP_MC].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK_IP_MC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK_IP_MC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK_IP_MC;
  }

  if (SOC_IS_JERICHO(unit) && tt_programs[unit][PROG_TT_EXTENDER_IP_MC_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB_IP_MC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB_IP_MC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_CB_IP_MC;
  }

  /* Routing UC */
  if (SOC_IS_JERICHO(unit) && tt_programs[unit][PROG_TT_EXTENDER_UNTAG_CHECK_IP_UC].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK_IP_UC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK_IP_UC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK_IP_UC;
  }

  if (SOC_IS_JERICHO(unit) && tt_programs[unit][PROG_TT_EXTENDER_IP_UC_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB_IP_UC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB_IP_UC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_CB_IP_UC;
  }

  /* Bridging */
  if (tt_programs[unit][PROG_TT_EXTENDER_UNTAG_CHECK].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_UNTAG_CHECK].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK;
  }
  if (tt_programs[unit][PROG_TT_EXTENDER_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_EXTENDER_CB].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_EXTENDER_CB;
  }

  if (tt_programs[unit][PROG_TT_IPV4_FOR_EXPLICIT_NULL_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_FOR_EXPLICIT_NULL].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_FOR_EXPLICIT_NULL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_FOR_EXPLICIT_NULL;
    prog_indx++; /* adding 2 program selections in one call */
    prog_indx++; /* adding 3 program selections in one call */
  }

  if (tt_programs[unit][PROG_TT_VLAN_DOMAIN_L1].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_VLAN_DOMAIN_L1].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_VLAN_DOMAIN_L1].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_VLAN_DOMAIN_L1;

    if (SOC_DPP_CONFIG(unit)->pp.ingress_full_mymac_1) 
      prog_indx++;
  }


  if (tt_programs[unit][PROG_TT_TUNNEL_FOR_TWO_EXPLICIT_NULL_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TUNNEL_FOR_TWO_EXPLICIT_NULL].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TUNNEL_FOR_TWO_EXPLICIT_NULL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TUNNEL_TWO_EXPLICIT_NULL;    
  }
  if (tt_programs[unit][PROG_TT_TUNNEL_FOR_THREE_EXPLICIT_NULL_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TUNNEL_FOR_THREE_EXPLICIT_NULL].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TUNNEL_FOR_THREE_EXPLICIT_NULL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TUNNEL_THREE_EXPLICIT_NULL;    
  }


  if (tt_programs[unit][PROG_TT_MLDP_AFTER_RECYCLE].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MLDP_OVERLAY_AFTER_RCY].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MLDP_OVERLAY_AFTER_RCY].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MLDP_OVERLAY_AFTER_RCY;
    prog_indx++; /* adding 2 program selections in one call */

  }

  if (tt_programs[unit][PROG_TT_L3].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L3].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L3].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MPLS_L3;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;
      /*arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,1,tt_programs[unit][PROG_TT_L3].prog_used);*/
  }

  if (tt_programs[unit][PROG_TT_INDX_L3_L4].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_L3_L4].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_L3_L4].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L4;

    if (prog_soc_prop->mpls_tp_mac_address) 
        prog_indx++;
      /*res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,1,tt_programs[unit][PROG_TT_INDX_L3_L4].prog_used);*/
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L2ELI_INRIF].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2ELI_INRIF].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2ELI_INRIF].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2ELI_INRIF;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;

      if (prog_soc_prop->port_raw_mpls)
          prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_L2_L3ELI].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L2_L3_ELI].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L2_L3_ELI].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MPLS_L2_L3_ELI;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;

      if (prog_soc_prop->port_raw_mpls)
          prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_L3ELI_INRIF].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_L3ELI_INRIF].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_L3ELI_INRIF;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L2_L3ELI].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L3_ELI].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L3_ELI].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L3_ELI;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;

      if (prog_soc_prop->port_raw_mpls)
          prog_indx++;
  }
  
  if (tt_programs[unit][PROG_TT_L2].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L2].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNINDEXED_MPLS_L2].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MPLS_L2;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L2_INRIF].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_INRIF].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_INRIF].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_INRIF;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
        prog_indx++;
  }  

  if (tt_programs[unit][PROG_TT_INDX_L1_L1].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L1].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L1].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L1;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L1_GAL].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L1_GAL].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L1_GAL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L1_GAL;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls)
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L2_GAL].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_GAL].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2_GAL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_GAL;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L2_L3_GAL].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L3_GAL].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L3_GAL].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L3_GAL;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;

  }


   if (tt_programs[unit][PROG_TT_INDX_L1_GAL_ONLY].prog_used != -1)
   {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_GAL_ONLY].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_GAL_ONLY].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_GAL_ONLY;
      
   }

   if (tt_programs[unit][PROG_TT_INDX_L2_GAL_ONLY].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_GAL_ONLY].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_GAL_ONLY].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L2_GAL_ONLY;

   }


  if (tt_programs[unit][PROG_TT_INDX_L3_L2].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_L3_L2].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_MPLS_L3_L2].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L2;

    if (SOC_DPP_CONFIG(unit)->pp.ingress_full_mymac_1) 
      prog_indx++;

    if (prog_soc_prop->mpls_tp_mac_address) 
      prog_indx++;

    if (prog_soc_prop->port_raw_mpls) 
      prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L2_L2].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L2].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L2_L2].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L2;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_INDX_L1_L2].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_INDEXED_L1_L2].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2;

      if (prog_soc_prop->mpls_tp_mac_address)
        prog_indx++;

      if (prog_soc_prop->port_raw_mpls)
          prog_indx++;
  }   

  
  if (SOC_IS_ARADPLUS_AND_BELOW(unit) && tt_programs[unit][PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_PWE_GRE_IPMC_RCY].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_PWE_GRE_IPMC_RCY].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_PWE_GRE_DIP_FOUND;
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_DIP_FOUND_IPMC_RCY].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_DIP_FOUND_IPMC_RCY].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_DIP_FOUND;
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_PORT_VXLAN_PROG].prog_used != -1) {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_VXLAN_PORT].priority[unit] = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_VXLAN_PORT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_VXLAN_PORT;
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_PORT_L2_GRE_PROG].prog_used != -1) {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_L2_GRE_PORT].priority[unit] = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_L2_GRE_PORT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_L2_GRE_PORT;
  }
  
  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_L3_GRE_PORT_PROG].prog_used != -1) {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_L3_GRE_PORT].priority[unit] = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_L3_GRE_PORT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_L3_GRE_PORT;
      prog_indx++; /* adding 2 program selections in one call */
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_DIP_SIP_VRF_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_UC_DIP_SIP_VRF].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_UC_DIP_SIP_VRF].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_DIP_SIP_VRF;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (tt_programs[unit][PROG_TT_MAC_IN_MAC_MC_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MIM_MC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MIM_MC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MIM_MC;
  }

  if (tt_programs[unit][PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MIM_WITH_BTAG].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_MIM_WITH_BTAG].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_MIM_WITH_BTAG;
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (tt_programs[unit][PROG_TT_ARP_2ND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_ARP].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_ARP].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_ARP;
  }

  if (tt_programs[unit][PROG_TT_IP_ROUTER_2ND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER;

      if (prog_soc_prop->custom_feature_vrrp_scaling_tcam)/* adding another selection */
          prog_indx++;
  } 

  if (tt_programs[unit][PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used != -1 && ipmc_second_pass_caused_by_rpf_fail(unit) )
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set(unit,prog_indx,tt_programs[unit][PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used,prog_soc_prop->ipv4mc_bidir_enable,1);
    SOC_SAND_CHECK_FUNC_RESULT(res, PROG_TT_BRIDGE_STAR_2ND_PROG, exit);
  }

  if (tt_programs[unit][PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_COMPATIBLE_MC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_COMPATIBLE_MC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_COMPATIBLE_MC;
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_MC_DIP_NOT_FOUND].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_MC_DIP_NOT_FOUND].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_MC_DIP_NOT_FOUND;
  }

  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_UC_DIP_NOT_FOUND].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_UC_DIP_NOT_FOUND].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_UC_DIP_NOT_FOUND;
  }

  if (tt_programs[unit][PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV6_ROUTER].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV6_ROUTER].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV6_ROUTER;
  }

  if (SOC_IS_ARADPLUS_AND_BELOW(unit) && tt_programs[unit][PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_PWE_GRE_DIP_FOUND].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_PWE_GRE_DIP_FOUND].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_PWE_GRE_DIP_FOUND;
  }


  if (tt_programs[unit][PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_DIP_FOUND].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_DIP_FOUND].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_DIP_FOUND;

      if (prog_soc_prop->custom_feature_vrrp_scaling_tcam)/* adding another selection */
          prog_indx++;
  }
  
  if (tt_programs[unit][PROG_TT_IP_ROUTER_2ND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_TUNNELS].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_IPV4_ROUTER_TUNNELS].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER;

    if (prog_soc_prop->custom_feature_vrrp_scaling_tcam)/* adding another selection */
          prog_indx++;
  } 

  if (tt_programs[unit][PROG_TT_TRILL_2ND_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_ONE_TAG].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_ONE_TAG].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TRILL_ONE_TAG;
    prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used != -1)
  {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_TWO_TAGS].priority[unit]  = prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_TWO_TAGS].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TRILL_TWO_TAGS;
      prog_indx++;
  }

  if (tt_programs[unit][PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_TRAP].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_TRILL_TRAP].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TRILL_TRAP;

  }

  if (tt_programs[unit][PROG_TT_FC_WITH_VFT_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_FC_WITH_VFT].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_FC_WITH_VFT].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_FC_WITH_VFT;

    if (soc_property_get(unit, spn_FCOE_NPV_BRIDGE_MODE, 0)) {
        prog_indx++;    /* adding 2 program selections in one call */
    }
  }

  if (tt_programs[unit][PROG_TT_FC_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_FC].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_FC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_FC;

    if (soc_property_get(unit, spn_FCOE_NPV_BRIDGE_MODE, 0)) {
        prog_indx++;    /* adding 2 program selections in one call */
    }
  }

  if (tt_programs[unit][PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used != -1)
  {

    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_STAR].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_STAR].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;

    if(SOC_IS_JERICHO_PLUS(unit)) {
        SET_TT_PROGRAM_SELECTION(prog_indx);
        tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_STAR_ROUTE_DISABLE].priority[unit]  = prog_indx;
        tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_STAR_ROUTE_DISABLE].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
    }

    /* Program Selection line,that used for OAM packets
     * This is used for cases that My-CFM-MAC is equal to My-MAC in this case originally packets supposed to go to routing program and  Forwarding-Code is other that Ethernet,
     * In Jericho and above one of conditions to identify packet as OAM is Forwarding code should be Ethernet,so in Jericho and above we will forward OAM packets to Bridge program*/
    if(SOC_IS_JERICHO(unit) && prog_soc_prop->oam_enable){
        SET_TT_PROGRAM_SELECTION(prog_indx);
        tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_OAM].priority[unit]  = prog_indx;
        tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_BRIDGE_OAM].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
    }


	/* Disable IPMC, IPv4 UC and IPv6 UC upstream for PON ports */
    if (SOC_DPP_CONFIG(unit)->pp.custom_pon_ipmc) {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IP_BRIDGE_COMPATIBLE_MC].priority[unit]	= prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IP_BRIDGE_COMPATIBLE_MC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV4_BRIDGE_UC].priority[unit]	= prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV4_BRIDGE_UC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV6_BRIDGE_UC].priority[unit]	= prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV6_BRIDGE_UC].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
      SET_TT_PROGRAM_SELECTION(prog_indx);
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV4_BRIDGE_DIP_FOUND].priority[unit]	= prog_indx;
      tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_PON_IPV4_BRIDGE_DIP_FOUND].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR;
    }
  }

  if (tt_programs[unit][PROG_TT_DIP6_COMPRESSION_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_DIPV6_COMPRESSED].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_DIPV6_COMPRESSED].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_DIPV6_COMPRESSED;
  }

  if (tt_programs[unit][PROG_TT_UNKNOWN_L3_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNKNOWN_L3].priority[unit]  = prog_indx;
    tt_dbal_program_selection[ARAD_PP_DBAL_TT_PROG_SELECTION_UNKNOWN_L3].prog_name[unit] = ARAD_PP_DBAL_TT_PROG_TT_UNKNOWN_L3;
  }

  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_sel_cam_key_program_2nd()", prog_indx, 0);
}


uint32 arad_pp_isem_prog_programs_init(int unit)
{
  uint32
    i,
    tmp,
    last_tt_program_id = 0,
    last_vt_program_id = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

#define prog_soc_prop g_prog_soc_prop[unit]
  
  for (i = 0; i < PROG_VT_NOF_PROGS; i++) {
      vt_programs[unit][i].prog_used = -1;
  }

  for (i = 0; i < PROG_TT_NOF_PROGS; i++) {
      tt_programs[unit][i].prog_used = -1;
  }

  /* VT  { */ 
  /* Always enabled */
  if(SOC_DPP_CONFIG(unit)->pp.custom_feature_vt_tst2)
  {
      SET_VT_PROGRAM_ID(unit, PROG_VT_TM_PROG);
      if(SOC_IS_ARADPLUS_A0(unit) && (SOC_DPP_CONFIG(unit)->pp.oam_statistics))
        vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_TM_STAT].prog_used[unit] = (last_vt_program_id - 1);
      else
        vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_TM                       ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_INNER_PCP_1_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_INNER_PCP_1_TST2].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_INNER_PCP_2_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_INNER_PCP_2_TST2].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_PCP_1_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_PCP_1_TST2      ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_PCP_2_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_PCP_2_TST2      ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_INNER_1_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_INNER_1_TST2    ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_INNER_2_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_INNER_2_TST2    ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_1_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_1_TST2          ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_OUTER_2_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_OUTER_2_TST2          ].prog_used[unit] = (last_vt_program_id - 1);

      SET_VT_PROGRAM_ID(unit, PROG_VT_UNTAGGED_TST2);
      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_UNTAGGED_TST2         ].prog_used[unit] = (last_vt_program_id - 1);

      if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "EoE_test2_enable", 0)) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_TEST2);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VT_TEST2                 ].prog_used[unit] = (last_vt_program_id - 1);
      }
      

  }
  else
  {
      SET_VT_PROGRAM_ID(unit, PROG_VT_TM_PROG);
      if(!(SOC_IS_ARADPLUS_A0(unit) && (SOC_DPP_CONFIG(unit)->pp.oam_statistics)))
      {
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_TM].prog_used[unit] = (last_vt_program_id - 1);
      }
      /* VT MPLS Port termination */
      if(SOC_DPP_CONFIG(unit)->pp.custom_feature_mpls_port_termination_lif_id)
      {
         SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_MPLS_PORT_L1);
         vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_MPLS_PORT_L1].prog_used[unit] = (last_vt_program_id - 1);
      }

      if(SOC_IS_ARADPLUS_A0(unit) && (SOC_DPP_CONFIG(unit)->pp.oam_statistics))
      {
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_TM_STAT].prog_used[unit] = (last_vt_program_id - 1);
      }

      if (SOC_DPP_CONFIG_CUSTOM_PP_PORT_IS_VENDOR2()) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_CUSTOM_PP_PORT_TUNNEL);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VT_CUSTOM_PP_PORT_TUNNEL].prog_used[unit] = (last_vt_program_id - 1);
      }
      
      /* Bridge, Q-in-Q */
      if (!prog_soc_prop.port_vlan_pcp_lookup && !prog_soc_prop.match_port_vlan_critiria_64K && !prog_soc_prop.custom_feature_vt_tst1)
      {
          /* Defaults */
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_INNER);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_L1].prog_used[unit] = (last_vt_program_id - 1);
          if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
          {
              SET_VT_PROGRAM_ID(unit, PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_OR_OUTER_VID_L1].prog_used[unit] = (last_vt_program_id - 1);
          }
          if (SOC_DPP_CONFIG(unit)->pp.port_use_initial_vlan_only_enabled)
          {
              SET_VT_PROGRAM_ID(unit, PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used[unit] = (last_vt_program_id - 1);
          }

          /* Optimization: Instead of new programs , use trill programs in case it is a must and not added before */
          if (!prog_soc_prop.trill_mode && prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B)
          {
              SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_TRILL);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
              if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) {
                  SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_TRILL);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
              }
          }
      }
      else if ((prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K))
      {
          /* PCP is set but not 64K */
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_OR_VD_OUTER_PCP);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_OUTER_OR_VD_OUTER_PCP].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VDxINITIALVID_L1); /* Initial-VID */
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1].prog_used[unit] = (last_vt_program_id - 1);
      }
      else if ((!prog_soc_prop.port_vlan_pcp_lookup) && (prog_soc_prop.match_port_vlan_critiria_64K))
      {
          /* PCP is unset but 64K set */
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_OR_VD_INITIALVID);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_OR_VD_INITIALVID].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_OR_VD_OUTER);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_OUTER_OR_VD_OUTER].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used[unit] = (last_vt_program_id - 1);
      }
      else if (prog_soc_prop.custom_feature_vt_tst1) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_UNTAGGED_TST1].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_SINGLE_TAG);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_ONE_TAG_TST1].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_DOUBLE_TAG);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_TST1].prog_used[unit] = (last_vt_program_id - 1);
          if (prog_soc_prop.explicit_null_arad_plus_support) {
              SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_EXPLICIT_NULL);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_UNTAGGED_EXP_NULL_TST1].prog_used[unit] = (last_vt_program_id - 1);
              SET_VT_PROGRAM_ID(unit, PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_ONE_TAG_EXP_NULL_TST1].prog_used[unit] = (last_vt_program_id - 1);
              SET_VT_PROGRAM_ID(unit, PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_EXP_NULL_TST1].prog_used[unit] = (last_vt_program_id - 1);
          }
          if (prog_soc_prop.custom_feature_vrrp_scaling_tcam)
          {
            SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_VRRP);
            vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_UNTAGGED_VRRP].prog_used[unit] = (last_vt_program_id - 1);
            SET_VT_PROGRAM_ID(unit, PROG_VT_VD_SINGLE_TAG_VRRP);
            vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_ONE_TAG_VRRP].prog_used[unit] = (last_vt_program_id - 1);
            SET_VT_PROGRAM_ID(unit, PROG_VT_VD_DOUBLE_TAG_VRRP);
            vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_VRRP].prog_used[unit] = (last_vt_program_id - 1);
           }
      }
      else
      {
          /* Error: both 64k and pcp are set */
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 60, exit);
      }

      /* MPLS */
      /* MPLS is valid only in case we are not in a special Q-in-Q world */
      if ((!prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K) && (!prog_soc_prop.custom_feature_vt_tst1))
      {
          if (!prog_soc_prop.mpls_use_in_rif)
          {
              if (prog_soc_prop.eli_enable)
              {
                  /* ELI is valid only in case MPLS context is not per RIF */
                  SET_VT_PROGRAM_ID(unit, PROG_VT_VDxINITIALVID_L1_L2ELI);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1_L2ELI].prog_used[unit] = (last_vt_program_id - 1);
                  if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
                  {
                      SET_VT_PROGRAM_ID(unit, PROG_VT_VDxOUTERVID_L1_L2ELI);
                      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_L1_L2ELI].prog_used[unit] = (last_vt_program_id - 1);
                  }
              }
          }
          if (!prog_soc_prop.mpls_index && !prog_soc_prop.mpls_use_in_rif)
          {
              /* Unindex MPLS. No MPLS context RIF */
              SET_VT_PROGRAM_ID(unit, PROG_VT_VDxINITIALVID_L1);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_L1].prog_used[unit] = (last_vt_program_id - 1);
              if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
              {
                  SET_VT_PROGRAM_ID(unit, PROG_VT_VDxOUTERVID_L1);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_L1].prog_used[unit] = (last_vt_program_id - 1);
              }
              if (prog_soc_prop.fast_reroute_labels_enable)
              {
                  /* FRR */
                  SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_L1FRR);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_L1FRR].prog_used[unit] = (last_vt_program_id - 1);
                  if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
                  {
                      SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTERVID_L1FRR);
                      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_OUTERVID_L1FRR].prog_used[unit] = (last_vt_program_id - 1);
                  }
              }
          }
          else if (prog_soc_prop.mpls_index && (!prog_soc_prop.mpls_use_in_rif))
          {
              /* MPLS indexed. No MPLS context RIF */
              SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_INITIALVID_L1);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDEXED_VDxINITIALVID_L1].prog_used[unit] = (last_vt_program_id - 1);
              if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
              {
                  SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_OUTERVID_L1);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDEXED_VDxOUTERVID_L1].prog_used[unit] = (last_vt_program_id - 1);
              }
              if (prog_soc_prop.fast_reroute_labels_enable)
              {
                  /* FRR */
                  SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_INITIALVID_FRR_L1);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDX_VD_INITIALVID_FRR_L1].prog_used[unit] = (last_vt_program_id - 1);
                  if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
                  {
                      SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_OUTERVID_FRR_L1);
                      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDX_VD_OUTERVID_FRR_L1].prog_used[unit] = (last_vt_program_id - 1);
                  }
              }
          }
          else
          {
              /* MPLS indexed includes MPLS context RIF */
              SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_INITIALVID_L3);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDEXED_VDxINITIALVID_L3].prog_used[unit] = (last_vt_program_id - 1);
              if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
              {
                  SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_OUTERVID_L3);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDEXED_VDxOUTERVID_L3].prog_used[unit] = (last_vt_program_id - 1);
              }
              if (prog_soc_prop.fast_reroute_labels_enable)
              {
                  /* FRR */
                  SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_INITIALVID_FRR_L1);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDX_VD_INITIALVID_FRR_L1].prog_used[unit] = (last_vt_program_id - 1);
                  if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
                  {
                      SET_VT_PROGRAM_ID(unit, PROG_VT_INDX_VD_OUTERVID_FRR_L1);
                      vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_INDX_VD_OUTERVID_FRR_L1].prog_used[unit] = (last_vt_program_id - 1);
                  }
              }
          }
      }

    if (soc_property_get(unit, spn_PWE_TERMINATION_PORT_MODE_ENABLE, 0) ){
	    /* vlan domain + mpls L1,this program just match vd+initialvid */
	    SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_VLAN_DOMAIN_L1);
	    vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_INITIALVID_VLAN_DOMAIN_L1].prog_used[unit] = (last_vt_program_id - 1);
    }
      /* Trill */
      if (prog_soc_prop.trill_mode)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_INITIALVID_TRILL);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxINITIALVID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
          if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
          {
              if (!prog_soc_prop.trill_disable_designated_vlan_check && prog_soc_prop.designated_vlan_inlif_enable) {
                  SET_VT_PROGRAM_ID(unit, PROG_VT_VD_DESIGNATED_VID_TRILL);
                  vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VD_DESIGNATED_VID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
              }
              SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_TRILL);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTERVID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
          }
          SET_VT_PROGRAM_ID(unit, PROG_VT_VD_OUTER_INNER_TRILL);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VDxOUTER_INNER_VID_TRILL].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* PON */
      if (prog_soc_prop.pon_enable)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_PON_UNTAGGED);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_PON_UNTAGGED].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_PON_ONE_TAG);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_PON_ONE_TAG].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_PON_TWO_TAGS);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_PON_TWO_TAGS].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* IP-LIF-DUMMY */
      if (SOC_DPP_CONFIG(unit)->pp.ip_lif_dummy_id) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_IPV4_VDxINITIALVID_AFTER_RCY].prog_used[unit] = (last_vt_program_id - 1);
          if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
          {
              SET_VT_PROGRAM_ID(unit, PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_IPV4_VDxOUTERVID_AFTER_RCY].prog_used[unit] = (last_vt_program_id - 1);
          }
      }

      /* IP-LIF-DUMMY for port termination*/
      if (SOC_DPP_CONFIG(unit)->pp.custom_feature_ip_port_termination_lif_id) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_IPV4_PORT);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_IPV4_PORT].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* IP */
      if (prog_soc_prop.ipv4_term_enable) {
          SET_VT_PROGRAM_ID(unit, PROG_VT_IPV4_INITIAL_VID);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_IPV4_VDxINITIALVID].prog_used[unit] = (last_vt_program_id - 1);
          if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
          {
              SET_VT_PROGRAM_ID(unit, PROG_VT_IPV4_OUTER_VID);
              vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_IPV4_VDxOUTERVID].prog_used[unit] = (last_vt_program_id - 1);
          }
      }
      


      /* EVB */
      if (prog_soc_prop.evb_enable)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_EVB_UN_C_TAG);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_EVB_UN_C_TAG].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_EVB_S_TAG);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_EVB_S_TAG].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* Extender */
      if (prog_soc_prop.extender_cb_enable)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_EXTENDER_PE);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_EXTENDER_PE].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_EXTENDER_PE_UT);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_EXTENDER_PE_UT].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* Q-in-Q 5-IP-tuple */
      if (prog_soc_prop.q_in_q_ip_5_tuple)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_DOUBLE_TAG_5_TUPPLE_QINQ].prog_used[unit] = (last_vt_program_id - 1);
          SET_VT_PROGRAM_ID(unit, PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_SINGLE_TAG_5_TUPPLE_QINQ].prog_used[unit] = (last_vt_program_id - 1);
      }

      if (SOC_DPP_CONFIG(unit)->pp.test2)
      {
          SET_VT_PROGRAM_ID(unit, PROG_VT_TEST2);
          vt_dbal_programs[ARAD_PP_DBAL_VT_PROG_VT_TEST2].prog_used[unit] = (last_vt_program_id - 1);
      }

      /* VT Self-check { */
      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VDxINITIALVID_L1].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_L1].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_L3].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_INITIALVID].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 300, exit); /* only one of the VT programs above can be set */
      }

      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTER_INNER].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_DOUBLE_TAG].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 310, exit); /* only one of the VT programs above can be set */
      }

      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VDxOUTERVID_L1].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_INDX_VD_OUTERVID_L1].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_SINGLE_TAG].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
      }

      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_OUTERVID_L1FRR].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 330, exit); /* only one of the VT programs above can be set */
      }

      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
      }

      tmp = 0;
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_VD_INITIALVID_L1FRR].prog_used);
      tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used);
      if (tmp > 1)
      {
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
      }
  }
  /* VT Self-check } */

  /* VT  } */ 

  /* TT  { */ 

  /* Always enabled */
  SET_TT_PROGRAM_ID(PROG_TT_TM_PROG);
  tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TM].prog_used[unit] = (last_tt_program_id - 1);
   /* TT MPLS Port termination */
  if (SOC_DPP_CONFIG(unit)->pp.custom_feature_mpls_port_termination_lif_id) {
      SET_TT_PROGRAM_ID(PROG_TT_INDX_MPLS_PORT_L3_L2);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_MPLS_PORT_L3_L2].prog_used[unit] = (last_tt_program_id - 1);
  }

  /*OAM statistics*/
  if (SOC_IS_ARADPLUS_A0(unit) && SOC_DPP_CONFIG(unit)->pp.oam_statistics){
      SET_TT_PROGRAM_ID(PROG_TT_OAM_STAT_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_OAM_STAT].prog_used[unit] = (last_tt_program_id - 1);
      SET_TT_PROGRAM_ID(PROG_TT_BFD_STAT_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_BFD_STAT].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* Bridge */
  SET_TT_PROGRAM_ID(PROG_TT_BRIDGE_STAR_2ND_PROG);
  tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_BRIDGE_STAR].prog_used[unit] = (last_tt_program_id - 1);
  if (prog_soc_prop.compression_ip6_enable) {
    SET_TT_PROGRAM_ID(PROG_TT_DIP6_COMPRESSION_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_DIPV6_COMPRESSED].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* MPLS */
  /* MPLS is valid only in case we are not in a special Q-in-Q world */
  if ((!prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K))
  {
    if ((!prog_soc_prop.mpls_index) && (!prog_soc_prop.mpls_use_in_rif)) 
    {
      /* Unindex MPLS. No MPLS context RIF. NO MPLS context VRF */
      SET_TT_PROGRAM_ID(PROG_TT_L2);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MPLS_L2].prog_used[unit] = (last_tt_program_id - 1);
      if (prog_soc_prop.eli_enable) 
      {      
        SET_TT_PROGRAM_ID(PROG_TT_L2_L3ELI);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MPLS_L2_L3_ELI].prog_used[unit] = (last_tt_program_id - 1);
      }

      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_TT_PROGRAM_ID(PROG_TT_L3);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MPLS_L3].prog_used[unit] = (last_tt_program_id - 1);
      }
    }
    else if (prog_soc_prop.mpls_index && prog_soc_prop.mpls_use_in_rif)
    {
      /* MPLS index. MPLS context RIF. */ 
      SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L2_INRIF);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_INRIF].prog_used[unit] = (last_tt_program_id - 1);
      if (prog_soc_prop.eli_enable) 
      {
        SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L2_L3ELI_INRIF);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_L3ELI_INRIF].prog_used[unit] = (last_tt_program_id - 1);
        SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L2ELI_INRIF);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2ELI_INRIF].prog_used[unit] = (last_tt_program_id - 1);
      }
      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_TT_PROGRAM_ID(PROG_TT_INDX_L3_L4);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L4].prog_used[unit] = (last_tt_program_id - 1);
      }     
    }
    else if (prog_soc_prop.mpls_index && (!prog_soc_prop.mpls_use_in_rif)) {
      if (prog_soc_prop.tunnel_termination_in_tt_only) 
      {
          SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L2);
          tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2].prog_used[unit] = (last_tt_program_id - 1);
          SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L1);
          tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L1].prog_used[unit] = (last_tt_program_id - 1);
          if (prog_soc_prop.explicit_null_arad_plus_support) 
          {
            SET_TT_PROGRAM_ID(PROG_TT_INDX_L2_L2);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L2].prog_used[unit] = (last_tt_program_id - 1);
            SET_TT_PROGRAM_ID(PROG_TT_INDX_L3_L2);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L2].prog_used[unit] = (last_tt_program_id - 1);
          }
          if (prog_soc_prop.pwe_gal_support) 
          {
            SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L2_GAL);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L2_GAL].prog_used[unit] = (last_tt_program_id - 1);
            SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_L1_GAL);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_L1_GAL].prog_used[unit] = (last_tt_program_id - 1);
            if (prog_soc_prop.explicit_null_arad_plus_support) 
            {
                SET_TT_PROGRAM_ID(PROG_TT_INDX_L2_L3_GAL);
                tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L3_GAL].prog_used[unit] = (last_tt_program_id - 1);
            }
          }
      } 
      else 
      {
        /* MPLS index. No MPLS context RIF. */
        SET_TT_PROGRAM_ID(PROG_TT_INDX_L3_L2);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L2].prog_used[unit] = (last_tt_program_id - 1);

        /* {Walkaround inlif data hw errata, For mpls packet with GAL, do lookup exactly*/
        if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "gal_lookup_exactly", 1)) {
            SET_TT_PROGRAM_ID(PROG_TT_INDX_L1_GAL_ONLY);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L1_GAL_ONLY].prog_used[unit] = (last_tt_program_id - 1);

            SET_TT_PROGRAM_ID(PROG_TT_INDX_L2_GAL_ONLY);
            tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L2_GAL_ONLY].prog_used[unit] = (last_tt_program_id - 1);
        }
        /*}*/
        if (prog_soc_prop.eli_enable) 
        {
          SET_TT_PROGRAM_ID(PROG_TT_INDX_L2_L3ELI);
          tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L2_L3_ELI].prog_used[unit] = (last_tt_program_id - 1);
        }
        if (prog_soc_prop.fast_reroute_labels_enable) 
        {
          /* FRR */
          SET_TT_PROGRAM_ID(PROG_TT_INDX_L3_L4);
          tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_INDEXED_L3_L4].prog_used[unit] = (last_tt_program_id - 1);
        } 
      }
    }
  }

    if (soc_property_get(unit, spn_PWE_TERMINATION_PORT_MODE_ENABLE, 0) ){
        /* vlan domain + mpls L1,this program just match vd+mpls l1 */
        SET_TT_PROGRAM_ID(PROG_TT_VLAN_DOMAIN_L1);
        tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_VLAN_DOMAIN_L1].prog_used[unit] = (last_tt_program_id - 1);
    }

  
  /* Routing , IP termination */
  /* in case port termination dummy lif is enabled: identify the processing of the dummy lif */
  if (SOC_DPP_CONFIG(unit)->pp.custom_feature_l2_gre_port_termination)
  {
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_PORT_L2_GRE_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_L2_GRE_PORT].prog_used[unit] = (last_tt_program_id - 1);
  }

 if (SOC_DPP_CONFIG(unit)->pp.custom_feature_vxlan_port_termination)
  {
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_PORT_VXLAN_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_VXLAN_PORT].prog_used[unit] = (last_tt_program_id - 1);
  }


  /* Routing , IP termination */
  /* in case dummy lif is enabled: identify the processing of the dummy lif */
  if (prog_soc_prop.ipv4_term_enable || SOC_DPP_CONFIG(unit)->pp.ip_lif_dummy_id)
  {
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_DIP_FOUND].prog_used[unit] = (last_tt_program_id - 1);
  }
  
  if (prog_soc_prop.ipv6_term_enable) {
      SET_TT_PROGRAM_ID(PROG_TT_IPV6_ROUTER_2ND_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV6_ROUTER].prog_used[unit] = (last_tt_program_id - 1);
  }
  /* Disable IP compatible MC program when PON application is enabled. Because it has the higher priority than PON IP6 SAV program. */
  if (!prog_soc_prop.compression_ip6_enable) {
    SET_TT_PROGRAM_ID(PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_COMPATIBLE_MC].prog_used[unit] = (last_tt_program_id - 1);
  }
  SET_TT_PROGRAM_ID(PROG_TT_IP_ROUTER_2ND_PROG);
  tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER].prog_used[unit] = (last_tt_program_id - 1);

  
  if (SOC_IS_ARADPLUS_AND_BELOW(unit) && prog_soc_prop.nvgre_enable) 
  {
    /* Support also PWEoGRE */
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_PWE_GRE_DIP_FOUND].prog_used[unit] = (last_tt_program_id - 1);
  }

  if (prog_soc_prop.ipv4mc_bidir_enable) 
  {
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_MC_DIP_NOT_FOUND].prog_used[unit] = (last_tt_program_id - 1);
    SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_UC_DIP_NOT_FOUND].prog_used[unit] = (last_tt_program_id - 1);
  }
  /* Unknown L3 */
  if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vtt_unknown_l3", 1) ) {
      SET_TT_PROGRAM_ID(PROG_TT_UNKNOWN_L3_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TT_UNKNOWN_L3].prog_used[unit] = (last_tt_program_id - 1);
  }
  /* in case of port termination dummy DIP,SIP,VRF program */
  if (SOC_DPP_CONFIG(unit)->pp.custom_feature_ip_l3_gre_port_termination_lif_id) {
      SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_L3_GRE_PORT_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_L3_GRE_PORT].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* DIP,SIP,VRF program */
  if (prog_soc_prop.ipv4_term_dip_sip_enable == 3) {
      SET_TT_PROGRAM_ID(PROG_TT_IPV4_ROUTER_DIP_SIP_VRF_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_ROUTER_DIP_SIP_VRF].prog_used[unit] = (last_tt_program_id - 1);
  }
  
  /* Jericho Explicit NULL WA program , ASIC fixed this issue on QAX_B0 and Jericho_plus and above*/
  if (SOC_IS_JERICHO(unit) && (!SOC_IS_JERICHO_PLUS(unit) || SOC_IS_QAX_A0(unit)) && SOC_DPP_CONFIG(unit)->pp.explicit_null_support)
  {
      SET_TT_PROGRAM_ID(PROG_TT_IPV4_FOR_EXPLICIT_NULL_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_IPV4_FOR_EXPLICIT_NULL].prog_used[unit] = (last_tt_program_id - 1);
      SET_TT_PROGRAM_ID(PROG_TT_TUNNEL_FOR_TWO_EXPLICIT_NULL_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TUNNEL_TWO_EXPLICIT_NULL].prog_used[unit] = (last_tt_program_id - 1);
      SET_TT_PROGRAM_ID(PROG_TT_TUNNEL_FOR_THREE_EXPLICIT_NULL_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TUNNEL_THREE_EXPLICIT_NULL].prog_used[unit] = (last_tt_program_id - 1);
  }
  

 /* Mac-in-MAC */
  if (prog_soc_prop.mim_enable) 
  {
      SET_TT_PROGRAM_ID(PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG);
      tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MIM_WITH_BTAG].prog_used[unit] = (last_tt_program_id - 1);
      if (SOC_IS_ARAD_B0_AND_ABOVE(unit)) 
      {
          SET_TT_PROGRAM_ID(PROG_TT_MAC_IN_MAC_MC_PROG);
          tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MIM_MC].prog_used[unit] = (last_tt_program_id - 1);
      }
  }

  /* ARP */
  SET_TT_PROGRAM_ID(PROG_TT_ARP_2ND_PROG);
  tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_ARP].prog_used[unit] = (last_tt_program_id - 1);

  /* Trill */
  if (prog_soc_prop.trill_mode) 
  {
    SET_TT_PROGRAM_ID(PROG_TT_TRILL_2ND_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TRILL_ONE_TAG].prog_used[unit] = (last_tt_program_id - 1);
    SET_TT_PROGRAM_ID(PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TRILL_TWO_TAGS].prog_used[unit] = (last_tt_program_id - 1);
    SET_TT_PROGRAM_ID(PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_TRILL_TRAP].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* FCoE */
  if (prog_soc_prop.fcoe_enable) 
  {
    SET_TT_PROGRAM_ID(PROG_TT_FC_WITH_VFT_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_FC_WITH_VFT].prog_used[unit] = (last_tt_program_id - 1);
    SET_TT_PROGRAM_ID(PROG_TT_FC_PROG);
    tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_FC].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* mLDP */
  if (SOC_DPP_CONFIG(unit)->pp.mldp_support) {
       SET_TT_PROGRAM_ID(PROG_TT_MLDP_AFTER_RECYCLE);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_MLDP_OVERLAY_AFTER_RCY].prog_used[unit] = (last_tt_program_id - 1);

   }

  /* Port extender */
  if (SOC_DPP_CONFIG(unit)->extender.port_extender_init_status) {
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_UNTAG_CHECK_IP_MC);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK_IP_MC].prog_used[unit] = (last_tt_program_id - 1);
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_IP_MC_PROG);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_CB_IP_MC].prog_used[unit] = (last_tt_program_id - 1);
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_UNTAG_CHECK_IP_UC);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK_IP_UC].prog_used[unit] = (last_tt_program_id - 1);
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_IP_UC_PROG);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_CB_IP_UC].prog_used[unit] = (last_tt_program_id - 1);
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_UNTAG_CHECK);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_UNTAG_CHECK].prog_used[unit] = (last_tt_program_id - 1);
       SET_TT_PROGRAM_ID(PROG_TT_EXTENDER_PROG);
       tt_dbal_programs[ARAD_PP_DBAL_TT_PROG_EXTENDER_CB].prog_used[unit] = (last_tt_program_id - 1);
  }

  /* TT Self check { */
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_L3].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_INDX_L3_L4].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 400, exit); /* only one of the TT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_L2_L3ELI].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_INDX_L2_L3ELI].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 410, exit); /* only one of the TT programs above can be set */
  }
  
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_L2].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_INDX_L1_L2_INRIF].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][PROG_TT_INDX_L3_L2].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 420, exit); /* only one of the TT programs above can be set */
  }
  /* TT Self check } */
   
  /* TT  } */   

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_programs_init()", last_vt_program_id, last_tt_program_id);
}

STATIC 
uint32
  arad_pp_isem_prog_sel_cam_init(
    int unit
  )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;
  uint32
    data[SOC_SAND_MAX(ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE,ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
    
  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);
  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  prog_selection_1st_cam_tbl.valid = 0;
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask     = 0x7FF;
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask     = 0x7FF;
  prog_selection_1st_cam_tbl.packet_format_code_mask            = 0x3F;
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask                = 0x3;
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK;
  prog_selection_1st_cam_tbl.parser_leaf_context_mask           = 0xF;
  if(SOC_IS_JERICHO(unit))
  {      
      prog_selection_1st_cam_tbl.incoming_tag_structure_mask    = 0xF;
      prog_selection_1st_cam_tbl.packet_format_qualifier_0_mask = 0x7;
  }

  res = arad_pp_ihp_isem_1st_program_selection_convert_tbl_data_to_data(unit,&prog_selection_1st_cam_tbl,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);


  /* Clear all program selection and programs tables */
  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, MEM_BLOCK_ANY, data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);

  prog_selection_2nd_cam_tbl.valid                                          = 0x0;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask                 = 0x7FF;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask                 = 0x7FF;
  if (SOC_IS_ARADPLUS_AND_BELOW(unit))
  {  
      prog_selection_2nd_cam_tbl.packet_format_qualifier_3_outer_vid_bits_mask  = 0x7;
  }
  prog_selection_2nd_cam_tbl.packet_format_code_mask                        = 0x3F;
  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask                            = 0x3;
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                     = 0x7;
  prog_selection_2nd_cam_tbl.parser_leaf_context_mask                       = 0xF;
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask                          = 0x1;
  prog_selection_2nd_cam_tbl.isb_lookup_found_mask                          = 0x1;
  prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                         = 0x1;
  prog_selection_2nd_cam_tbl.vt_processing_profile_mask                     = 0x7;
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                       = 0x1;
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask                   = 0x1;
  prog_selection_2nd_cam_tbl.my_mac_mask                                    = 0x1;
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask                        = 0x1;
  if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
  {
      prog_selection_2nd_cam_tbl.my_b_mac_mc_mask                           = 0x1;
  }
  if(SOC_IS_JERICHO(unit))
  {
      prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                 = 0x1F;
      prog_selection_2nd_cam_tbl.vt_in_lif_profile_mask                     = 0xF; 
      prog_selection_2nd_cam_tbl.packet_format_qualifier_3_mask             = 0x7FF;
  }

  res = arad_pp_ihp_isem_2nd_program_selection_convert_tbl_data_to_data(unit,&prog_selection_2nd_cam_tbl,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 140, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, MEM_BLOCK_ANY, data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 150, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_sel_cam_init()", 0, 0);
}

#define ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(field_1,field_2) \
{ \
  uint32 __tmp; \
  __tmp = field_1; \
  field_1 = field_2; \
  field_2 = __tmp; \
}

#define ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(new,old,value_1,value_2) \
{ \
  if (old & value_1) \
  { \
    new |= value_2; \
    new &= ~value_1; \
  } \
  if (old & value_2) \
  { \
    new |= value_1; \
    new &= ~value_2; \
  } \
}

/* 
 * Swap between ISEM-A and ISEM-B data.
 */

uint32
  arad_pp_vtt_1st_lookup_program_swap_sem(
    int unit,
    uint32 swap,
    ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA* tbl_data
  )
{
  uint32
    tmp;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(swap)
  {
      ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_1,tbl_data->isb_key_valids_1);
      ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_2,tbl_data->isb_key_valids_2);
  }
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_and_mask,tbl_data->isb_and_mask);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_lookup_enable,tbl_data->isb_lookup_enable);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_or_mask,tbl_data->isb_or_mask);
  tmp = tbl_data->vlan_translation_0_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_0_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_0_pd_bitmap,tmp,0x10,0x8);
  tmp = tbl_data->vlan_translation_1_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_1_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_1_pd_bitmap,tmp,0x10,0x8);

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_swap_sem()", 0, 0);
}


STATIC
uint32
  arad_pp_vtt_find_namespace_database(
    int unit,
    SOC_PPC_MPLS_TERM_NAMESPACE_TYPE namespace_required,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace,
    SOC_PPC_MPLS_TERM_NAMESPACE_TYPE *namespace,
    uint32 *database
  )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  *namespace = mpls_3_namespace;
  *database  = mpls_3_database;

  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L1)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L1(mpls_1_namespace)) {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } else if (ARAD_PP_VTT_FIND_NAMESPACE_L1(mpls_2_namespace)) {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */
  }

  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L2)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L2(mpls_1_namespace)) 
    {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } 
    else if (ARAD_PP_VTT_FIND_NAMESPACE_L2(mpls_2_namespace)) 
    {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */   
  }
  
  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L3)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L3(mpls_1_namespace)) 
    {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } 
    else if (ARAD_PP_VTT_FIND_NAMESPACE_L3(mpls_2_namespace)) 
    {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */   
  }

  ARAD_DO_NOTHING_AND_EXIT;
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_find_namespace_database()", namespace_required, 0);
}



/* End of 1st lookup programs */

/* Start of 2nd lookup programs*/

uint32
   arad_pp_isem_access_tcam_callback(
      SOC_SAND_IN int unit,
      SOC_SAND_IN uint32  user_data
    )
{  
  uint32
    res = SOC_SAND_OK;
  uint32
    tcam_db_id,
    access_profile_id;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  /* Set access_profile id depending on TCAM DB ID */
  tcam_db_id = user_data;

  res = sw_state_access[unit].dpp.soc.arad.tm.tcam.tcam_db.access_profile_id.get(unit,tcam_db_id,0, /* No 320b DB */&access_profile_id);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

  switch (user_data) /* tcam DB ID */
  {
  case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_TT_IPV6_SPOOF_COMPRESSION:
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_SRC_PORT_DA_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_VRRP_VSI_DA_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_TST2_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_TEST2_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_TT_DIP_COMPRESSION_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_DIP_SIP_VRF_PROFILE:
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE :
  case ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP :
  case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE :
  case ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE:
    break;

  case ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE:
  
    break;

  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 300, exit);
  }

  ARAD_DO_NOTHING_AND_EXIT;
exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_callback()", 0, 0);
}

STATIC 
uint32
  arad_pp_isem_tcam_init_unsafe(
    int unit,
    uint8 fast_reroute_labels_enable,
    uint8 spoof_ipv6_enable,
    uint8 trill_mode,    
    uint8 ipv4_term_dip_sip_enable,
    uint8 ipv6_term_enable,
    uint8 port_vlan_pcp_lookup_enable,
    uint8 use_pon_tcam_lkup,
    uint8 q_in_q_ip_5_tuple_enable,
    uint8 custom_feature_vt_tst1,
    uint8 trill_transparent_service,
    uint8 explicit_null_arad_plus_support,
    uint8 compression_ip6_enable,
    uint8 compression_spoof_ip6_enable,
    uint8 custom_feature_vt_tst2,
    uint8 custom_feature_vrrp_scaling_tcam
  )
{
  uint32
    res = SOC_SAND_OK;
  SOC_SAND_SUCCESS_FAILURE
    success;
  ARAD_TCAM_ACCESS_INFO
    tcam_access_info;
  int use_small_banks_mode_vrrp =  soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "use_small_banks_mode_vrrp", 0);
  int use_small_banks_mode_efp  =  soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE,  "use_small_banks_mode_efp", 0);
  int use_small_banks_mode_null =  soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "use_small_banks_mode_null", 0);

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /*
   *  Create TCAM databases
   */                                                                

  if (custom_feature_vrrp_scaling_tcam)
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                ARAD_TCAM_BANK_OWNER_VT, 
                                                ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS, 
                                                ARAD_PP_ISEM_ACCESS_TCAM_VRRP_VSI_DA_PROFILE);    

    if ( use_small_banks_mode_vrrp == 1) { /* use only small banks */
      tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
    } else if (use_small_banks_mode_vrrp == 2) { /* use only big banks */
      tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORBID;
    }

    res = arad_tcam_access_create_unsafe(unit, ARAD_PP_ISEM_ACCESS_TCAM_VRRP_VSI_DA_PROFILE, &tcam_access_info, &success);
    SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
  }

  if (SOC_DPP_CONFIG(unit)->pp.ingress_full_mymac_1)
  {
      arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_SRC_PORT_DA_DB_PROFILE); 

      res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_SRC_PORT_DA_DB_PROFILE,&tcam_access_info,&success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);
  }

  if(custom_feature_vt_tst2)
  {
      arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_TST2_PROFILE);

      res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_TST2_PROFILE,&tcam_access_info,&success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 9, exit);
  }
  else
  {
      if (fast_reroute_labels_enable) /* Enable when FRR is enabled */
      {
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE);

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
      }

      if (SOC_DPP_CONFIG(unit)->pp.test2) {

          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_TEST2_PROFILE);

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_TEST2_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 9, exit);
      }

      if (port_vlan_pcp_lookup_enable) { /* Enabled when PCP lookup is set */
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE);               

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 55, exit);
      }

      if (use_pon_tcam_lkup) { /* Enabled when PON TCAM application is enabled */
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE);

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);
      }

      if (q_in_q_ip_5_tuple_enable) { /* Enabled when flexible QinQ application is enabled */
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE);

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
      }

      if (custom_feature_vt_tst1) {
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP);          

          if (use_small_banks_mode_efp == 1){
            tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
          } else if (use_small_banks_mode_efp == 2) {
            tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORBID;
          }

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
      }
      if (trill_transparent_service) { /* Enabled when trill transparent service is enabled */
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE);          

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
      }

      if (explicit_null_arad_plus_support) {
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_VT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE);          

          if (use_small_banks_mode_null == 1){
            tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
          } else if (use_small_banks_mode_null == 2){
            tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORBID;
          }

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

      }
  }

  if (ipv4_term_dip_sip_enable) /* Enabled when Required IPV4 Tunnel Termination by SIP & DIP */  {

      /* dip sip vrf */
      if ((ipv4_term_dip_sip_enable == 3) || (ipv4_term_dip_sip_enable == 4)) {
          arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info,
                                              ARAD_TCAM_BANK_OWNER_TT,
                                              ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS,
                                              ARAD_PP_ISEM_ACCESS_TCAM_DIP_SIP_VRF_PROFILE);

          if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_ip_term_use_small_banks",0) ){
              tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
          }

          res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_DIP_SIP_VRF_PROFILE,&tcam_access_info,&success);
          SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
      } else {
          if(!custom_feature_vt_tst2) {
              arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

              tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
              tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
              tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
              if (ipv4_term_dip_sip_enable == 2){
                  /* In case of IPV4 next protocol we pass 80 bits per entry */
                  tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS;
              }
              else{
                  tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
              }
              tcam_access_info.is_direct                           = FALSE;
              tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
              tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
              tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;

              if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_ip_term_use_small_banks",0) ){
                  tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
              }

              res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE,&tcam_access_info,&success);
              SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
          }
      }
  }

  if (spoof_ipv6_enable && (!compression_spoof_ip6_enable)) /* Enable when IPV6 spoof application is enabled */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_TT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE);    

    res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE,&tcam_access_info,&success);
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  }

  if (ipv6_term_enable) /* Enabled when Required IPV6 Tunnel Termination */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_TT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE);    

    res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE,&tcam_access_info,&success);
    SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
  }

  if (compression_ip6_enable) {
      arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_TT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_TT_DIP_COMPRESSION_DB_PROFILE);      

      res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_TT_DIP_COMPRESSION_DB_PROFILE,&tcam_access_info,&success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    
  }


  if (spoof_ipv6_enable && compression_spoof_ip6_enable) {
      arad_ARAD_TCAM_ACCESS_INFO_clear_and_update(&tcam_access_info, 
                                                  ARAD_TCAM_BANK_OWNER_TT, 
                                                  ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS, 
                                                  ARAD_PP_ISEM_ACCESS_TCAM_TT_IPV6_SPOOF_COMPRESSION);

      res = arad_tcam_access_create_unsafe(unit,ARAD_PP_ISEM_ACCESS_TCAM_TT_IPV6_SPOOF_COMPRESSION,&tcam_access_info,&success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_tcam_init_unsafe()", 0, 0);
}

void 
arad_pp_isem_access_deinit(int unit)
{
    is_g_prog_soc_prop_initilized[unit] = 0;   
}
uint32
  arad_pp_isem_access_init_unsafe(
    SOC_SAND_IN  int                                 unit
  )
{
  uint32
    res = SOC_SAND_OK;
  uint64 
    failure;
  uint32
      core_id,
    table_data[6] = {0};
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

#define prog_soc_prop g_prog_soc_prop[unit]


  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_LOOKUP_PROGRAM_0m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_LOOKUP_PROGRAM_1m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);
  
  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_LOOKUP_PROGRAM_0m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_LOOKUP_PROGRAM_1m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);


  /* VTT PTC config */
  res = arad_fill_table_with_entry(unit, IHP_VTT_PTC_CONFIGm, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);  

  if (prog_soc_prop.compression_spoof_ip6_enable ||
      prog_soc_prop.compression_ip6_enable ||
      prog_soc_prop.custom_pon_ipmc) {
    arad_mgmt_pon_init(unit);
  }

  if(SOC_IS_QAX(unit))
  {
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, PPDB_A_ISEM_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISEM_MNGMNT_UNIT_ENABLEf,  0x1));
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  11,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, PPDB_B_ISEM_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISEM_MNGMNT_UNIT_ENABLEf,  0x1));

      /* Clear failure indication of ISEM */
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1015, exit, READ_PPDB_A_ISEM_MANAGEMENT_UNIT_FAILUREr(unit, &failure));
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1016, exit, READ_PPDB_B_ISEM_MANAGEMENT_UNIT_FAILUREr(unit, &failure));

  }
  else
  {
      if (SOC_IS_JERICHO(unit)) {
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHB_ISEM_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISEM_MNGMNT_UNIT_ENABLEf,  0x1));

          /* Clear failure indication of ISEM */
          for (core_id = 0; core_id < SOC_DPP_DEFS_GET(unit, nof_cores); core_id++) {
              SOC_SAND_SOC_IF_ERROR_RETURN(res, 1000 + core_id, exit, READ_IHB_ISEM_MANAGEMENT_UNIT_FAILUREr(unit, core_id, &failure));
          }
      } else {
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHP_ISA_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISA_MNGMNT_UNIT_ENABLEf,  0x1));
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHP_ISB_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISB_MNGMNT_UNIT_ENABLEf,  0x1));

          /* Clear failure indication of ISEM */
          SOC_SAND_SOC_IF_ERROR_RETURN(res, 1000, exit, READ_IHP_ISA_MANAGEMENT_UNIT_FAILUREr(unit, &failure));
          SOC_SAND_SOC_IF_ERROR_RETURN(res, 1010, exit, READ_IHP_ISB_MANAGEMENT_UNIT_FAILUREr(unit, &failure));
      }
  }


  if ((prog_soc_prop.nvgre_enable && prog_soc_prop.e_o_ip_enable) ||
      (prog_soc_prop.nvgre_enable && prog_soc_prop.vxlan_enable) ||
      (prog_soc_prop.e_o_ip_enable && prog_soc_prop.vxlan_enable) ||
      (prog_soc_prop.custom_pon_enable && (!prog_soc_prop.tls_in_tcam_enable))) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 5055, exit); /* only one OVERLAY can be enabled */
  }

  /* Init isem program selection */
  res = arad_pp_isem_prog_sel_cam_init(
          unit
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);

  /* Program selection { */
  /* set deafult programs 2nd lookup */
   res = arad_pp_vtt_prog_sel_cam_key_program_1st_set(
           unit,
           &prog_soc_prop
    );
      SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

  /* set deafult programs 2nd lookup */
  res = arad_pp_isem_prog_sel_cam_key_program_2nd(
          unit,
          &prog_soc_prop
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

  /* Program selection } */

  /* VTT TCAM initial settings { */  
  res = arad_pp_isem_tcam_init_unsafe(
          unit,
          prog_soc_prop.fast_reroute_labels_enable, /* Enable when FRR */
          prog_soc_prop.spoof_ipv6_enable,
          prog_soc_prop.trill_mode,     
          prog_soc_prop.ipv4_term_dip_sip_enable,  
          prog_soc_prop.ipv6_term_enable,
          prog_soc_prop.port_vlan_pcp_lookup,
          prog_soc_prop.use_pon_tcam_lkup,
          prog_soc_prop.q_in_q_ip_5_tuple,
          prog_soc_prop.custom_feature_vt_tst1,
          prog_soc_prop.trill_transparent_service,
          prog_soc_prop.explicit_null_arad_plus_support,
          prog_soc_prop.compression_ip6_enable,
          prog_soc_prop.compression_spoof_ip6_enable,
          prog_soc_prop.custom_feature_vt_tst2,
          prog_soc_prop.custom_feature_vrrp_scaling_tcam
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

  /* VTT TCAM initial settings } */


exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_init_unsafe()", 0, 0);
}

uint32 arad_pp_isem_access_programs_soc_properties_get( SOC_SAND_IN int  unit)
{
    uint32
       res = SOC_SAND_OK;

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

#define  prog_soc_prop     (&(g_prog_soc_prop[unit]))

    ARAD_CLEAR(prog_soc_prop, ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES, 1);

    if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) {
        ARAD_DO_NOTHING_AND_EXIT;
    }

    res = sw_state_access[unit].dpp.soc.arad.pp.oper_mode.mpls_info.fast_reroute_labels_enable.get(unit,&(prog_soc_prop->fast_reroute_labels_enable));
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

    res = sw_state_access[unit].dpp.soc.arad.pp.oper_mode.mpls_info.mpls_termination_label_index_enable.get(unit,&(prog_soc_prop->mpls_index));
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

    res = sw_state_access[unit].dpp.soc.arad.pp.oper_mode.mpls_info.lookup_include_inrif.get(unit,&(prog_soc_prop->mpls_use_in_rif));
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    prog_soc_prop->port_vlan_pcp_lookup = (SOC_DPP_CONFIG(unit)->pp.vlan_match_db_mode == SOC_DPP_VLAN_DB_MODE_PCP);
    prog_soc_prop->match_port_vlan_critiria_64K = (SOC_DPP_CONFIG(unit)->pp.vlan_match_db_mode == SOC_DPP_VLAN_DB_MODE_FULL_DB);
    prog_soc_prop->spoof_enable = ((SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IPV4)
                                   ||(SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IP)); /* IPV4 Spoof enable */
    prog_soc_prop->trill_mode = SOC_DPP_CONFIG(unit)->trill.mode;
    prog_soc_prop->trill_appointed_fwd = FALSE;
	prog_soc_prop->trill_transparent_service = SOC_DPP_CONFIG(unit)->trill.transparent_service;
    prog_soc_prop->spoof_ipv6_enable = ((SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IPV6)
                                        ||(SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IP)); /* IPV6 Spoof enable */
    prog_soc_prop->ipv4_term_dip_sip_enable = ((SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_DIP_SIP)
                                               ||(SOC_DPP_CONFIG(unit)->pp.ingress_ipv4_tunnel_term_mode == SOC_DPP_IP_TUNNEL_L2_LKUP_MODE_SIP_DIP_JOIN));
    if (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_DIP_SIP_NEXT_PROTOCOL) {
        prog_soc_prop->ipv4_term_dip_sip_enable = 2; /* IPV4 Next protocol is enabled */
    } else if (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_DIP_SIP_VRF) { /* VRF is enabled */
        prog_soc_prop->ipv4_term_dip_sip_enable = 3; 
    } else if (SOC_DPP_CONFIG(unit)->pp.ingress_ipv4_tunnel_term_mode == SOC_DPP_IP_TUNNEL_L2_LKUP_MODE_DIP_SIP_VRF_SEM_ONLY_AND_DEFAULT_TCAM) { /* my-vtep-index SIP VRF in ISEM. DIP SIP VRF in TCAM */
        prog_soc_prop->ipv4_term_dip_sip_enable = 4; 
    }
    prog_soc_prop->nvgre_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_NVGRE);
    prog_soc_prop->vxlan_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_VXLAN);
    prog_soc_prop->e_o_ip_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_ETHER);
    prog_soc_prop->ipv4_term_enable = ((SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_TUNNEL_MASK)
                                       || prog_soc_prop->nvgre_enable || prog_soc_prop->vxlan_enable || prog_soc_prop->e_o_ip_enable);
    prog_soc_prop->ipv6_term_enable = SOC_DPP_CONFIG(unit)->pp.ipv6_tunnel_enable;
    if (SOC_IS_ARAD_B1_AND_BELOW(unit) && (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "mpls_termination_check_bos_disable", 0) == 1)) {
        prog_soc_prop->is_bos_in_key_enable = FALSE;
    } else {
        prog_soc_prop->is_bos_in_key_enable = TRUE;
    }
#ifdef BCM_88660_A0
    if (SOC_IS_ARADPLUS(unit) && soc_property_get(unit, spn_BCM886XX_MPLS_TERMINATION_KEY_MODE, 1)) {
        prog_soc_prop->is_bos_in_key_enable = FALSE;
    }
#endif /* BCM_88660_A0 */
    prog_soc_prop->pon_enable = SOC_DPP_CONFIG(unit)->pp.pon_application_enable;
    prog_soc_prop->use_pon_tcam_lkup = SOC_DPP_CONFIG(unit)->pp.pon_tcam_lkup_enable;
    prog_soc_prop->tls_db_enable = 1;
    prog_soc_prop->custom_pon_enable = SOC_DPP_CONFIG(unit)->pp.pon_custom_enable;
    prog_soc_prop->tls_in_tcam_enable = SOC_DPP_CONFIG(unit)->pp.pon_tls_in_tcam; /* */
    prog_soc_prop->evb_enable = SOC_DPP_CONFIG(unit)->pp.evb_enable;
    prog_soc_prop->fcoe_enable = SOC_DPP_CONFIG(unit)->pp.fcoe_enable;
    prog_soc_prop->ipv4mc_bidir_enable = SOC_DPP_CONFIG(unit)->l3.nof_rps != 0;
    prog_soc_prop->mim_enable = SOC_DPP_CONFIG(unit)->arad->pp_op_mode.mim_enable;
    prog_soc_prop->eli_enable = SOC_DPP_CONFIG(unit)->pp.mpls_eli_enable;
    prog_soc_prop->mpls_1_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[0];
    prog_soc_prop->mpls_2_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[1];
    prog_soc_prop->mpls_3_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[2];
    prog_soc_prop->mpls_1_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[0];
    prog_soc_prop->mpls_2_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[1];
    prog_soc_prop->mpls_3_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[2];
    prog_soc_prop->mpls_tp_mac_address = soc_property_get(unit, spn_MPLS_TP_MYMAC_RESERVED_ADDRESS, 0);
    prog_soc_prop->trill_disable_designated_vlan_check = soc_property_get(unit, spn_TRILL_DESIGNATED_VLAN_CHECK_DISABLE, 0);
    prog_soc_prop->designated_vlan_inlif_enable = SOC_DPP_CONFIG(unit)->trill.designated_vlan_inlif_enable;
    prog_soc_prop->q_in_q_ip_5_tuple = soc_property_get(unit, spn_VLAN_TRANSLATION_MATCH_IPV4, 0);
    prog_soc_prop->custom_feature_vt_tst1 = SOC_DPP_CONFIG(unit)->pp.custom_feature_vt_tst1;
    prog_soc_prop->custom_feature_vt_tst2 = SOC_DPP_CONFIG(unit)->pp.custom_feature_vt_tst2;
    prog_soc_prop->custom_feature_vrrp_scaling_tcam =  SOC_DPP_CONFIG(unit)->pp.custom_feature_vrrp_scaling_tcam;
    prog_soc_prop->ingress_full_mymac_1 = SOC_DPP_CONFIG(unit)->pp.ingress_full_mymac_1;
    prog_soc_prop->tunnel_termination_in_tt_only = SOC_DPP_CONFIG(unit)->pp.tunnel_termination_in_tt_only; 
    prog_soc_prop->pwe_gal_support = SOC_DPP_CONFIG(unit)->pp.gal_support;
    prog_soc_prop->explicit_null_arad_plus_support = SOC_DPP_CONFIG(unit)->pp.explicit_null_support && SOC_IS_ARADPLUS_AND_BELOW(unit);
    prog_soc_prop->port_raw_mpls = soc_property_get(unit, spn_PORT_RAW_MPLS_ENABLE, 0); 
    prog_soc_prop->compression_spoof_ip6_enable = SOC_DPP_CONFIG(unit)->pp.compression_spoof_ip6_enable;
    prog_soc_prop->compression_ip6_enable = SOC_DPP_CONFIG(unit)->pp.compression_ip6_enable;
    prog_soc_prop->test1 = SOC_DPP_CONFIG(unit)->pp.test1;
    prog_soc_prop->extender_cb_enable = SOC_DPP_CONFIG(unit)->extender.port_extender_init_status;
    prog_soc_prop->evpn_enable = soc_property_get(unit, spn_EVPN_ENABLE, 0);
    prog_soc_prop->custom_pon_ipmc = SOC_DPP_CONFIG(unit)->pp.custom_pon_ipmc;
    prog_soc_prop->oam_enable = SOC_DPP_CONFIG(unit)->pp.oam_enable;
    prog_soc_prop->oam_statistics_enable = (SOC_DPP_CONFIG(unit)->pp.oam_statistics != 0) ? 1 : 0;
    is_g_prog_soc_prop_initilized[unit] = 1;    
exit:

#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_programs_soc_properties_get()", 0, 0);    
}


uint32
  arad_pp_sem_key_extend(
     SOC_SAND_IN  int                        unit,
     SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY             *key,
     SOC_SAND_IN  uint32                              insert_index,
     SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY             *extnd_key
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* copy key */
  sal_memcpy(extnd_key,key, sizeof(ARAD_PP_ISEM_ACCESS_KEY));

  /* Special case VD_PCP_VID once add with DEI is on, once add with DEI off */
  if (extnd_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID) {
    extnd_key->key_info.l2_eth.outer_dei = (insert_index) ? 1:0;
  }

  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_sem_key_extend()", 0, 0);
}

/*
 * Returns the requested table to be insert into .
 */
uint32
  arad_pp_isem_access_sem_tables_get(
    SOC_SAND_IN  int                                  unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                 *isem_key,
    SOC_SAND_OUT uint32                                  *nof_tables,
    SOC_SAND_OUT uint32                                  *tables_access_ids,
    SOC_SAND_OUT uint8                                   *is_duplicate_entry
  )
{
  uint8
    found;
  SOC_PPC_MPLS_TERM_NAMESPACE_TYPE
    namespace = SOC_PPC_MPLS_TERM_NOF_NAMESPACE_TYPES;
  uint32
    res = 0;
  uint8
    vt_profile = 0;
  SOC_PPC_PORT
    port_i;
  SOC_PPC_PORT_INFO
    port_info;
  uint8
    is_trill = FALSE,
    pon_double_lookup_enable = FALSE;
  int           core;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);  

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(nof_tables);
  SOC_SAND_CHECK_NULL_INPUT(tables_access_ids);
  SOC_SAND_CHECK_NULL_INPUT(is_duplicate_entry);

  /*
   * Decision is depended on soc properties and vlan domain. 
   * When decision to add is arbitrary between A & B tables, 
   *    algorithm will always try first table A (Can be changed).
   */
  found = FALSE;
  *nof_tables = 1;
  *is_duplicate_entry = 0;

  /* L2 { */
  /* Matching table in case of L2, depends on VT port profile */
  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:  
    found = TRUE;
    /* Location depends on VT profile and global parameters */
    /* Support up to 64K Key can be located on either A or B */
    if (prog_soc_prop.match_port_vlan_critiria_64K) 
    {
      /* Match both ISEM-A,B */
      *nof_tables = 2;
      *is_duplicate_entry = 0;
    } 
    else if (prog_soc_prop.port_vlan_pcp_lookup) /* PCP lookups */
    {
      /* Static mapping not depended on port */
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD || 
          isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID || 
          isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID) {
        /* Duplicate twice */
        *nof_tables = 2;
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
        tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
        *is_duplicate_entry = 1;
      }
    }    
    else 
    { /* Default lookups : !pcp, !64K */   
      
      /* 
       * Retrieve VT profile and then decide
       * Find port that match vlan domain and take accordingly vt_profile
       * Assumption: all ports on the same vlan domain share same vt_profile
       */
        res = 
        sw_state_access[unit].dpp.soc.arad.pp.vt_profile_info.vlan_translation_profile.get(unit, isem_key->key_info.l2_eth.vlan_domain, &vt_profile);
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

        /* Check if Trill port */
        if (prog_soc_prop.trill_mode) 
        {
          is_trill = (vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_TRILL || vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_TRILL_USE_INITIAL_VID);
        }
        else
        {
          is_trill = FALSE;
        }

      if (is_trill)
      {
        /* Trill lookups of bridges: Does not support Double lookup */  
        /* All lookups are done in ISEM-B */
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      }
      else if (vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY ||
               vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID)
      {
        /* Special case: VDxVIDxVID (ISA) and VDxVID (ISB) both lookups */
        tables_access_ids[0] = (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_A:ARAD_PP_ISEM_ACCESS_ID_ISEM_B;        
      }
      else if (prog_soc_prop.fast_reroute_labels_enable &&
               (vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_FRR_COUPLING || vt_profile == SOC_PPC_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID)) /* Port support FRR - L2 in TCAM */
      {
        tables_access_ids[0] = (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
      else /* Default: PortxOuter/Initial, Double */
      {
        tables_access_ids[0] = (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID) ? prog_soc_prop.mpls_1_database:
                               (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
    }
    
    break;
  default:
    break;
  }
  /* L2 } */

  /*OAM stat*/
  if (SOC_IS_ARADPLUS_A0(unit) && SOC_DPP_CONFIG(unit)->pp.oam_statistics) {
	  switch (isem_key->key_type) {
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_TT:
		  found = TRUE;
		  /* Duplicate twice */
		  *nof_tables = 2;
		  tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
		  tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
		  *is_duplicate_entry = 1;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_VT:
		  found = TRUE;
		  *nof_tables = 1;
		  tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_VT:
		  found = TRUE;
		  *nof_tables = 1;
		  tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISA:
		  found = TRUE;
		  *nof_tables = 1;
		  tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISB:
		  found = TRUE;
		  *nof_tables = 1;
		  tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
		  break;
	  default:
		  break;
	  }
	  
  }
 

  /* PON { */
  switch (isem_key->key_type) {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    found = TRUE;
    /* PON extend lookup used only in case property tcam lookup is enable */
    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID)
    {
      if (!prog_soc_prop.use_pon_tcam_lkup) 
      {
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 40, exit);
      }

      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
    }
    else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL) 
    {
      /* ISEM-A or ISEM-B depends on flags */
      tables_access_ids[0] = (isem_key->key_info.l2_pon.flags & ARAD_PP_ISEM_ACCESS_L2_PON_TLS) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
    }
    else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID) 
    {
      /* ISEM-A  or ISEM-B depends on soc properties */
      tables_access_ids[0] = (prog_soc_prop.custom_pon_enable ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A);
    }
    else 
    {
	  for (core = 0; core < SOC_DPP_DEFS_GET(unit, nof_cores); core++) {
          for (port_i = 0; port_i < ARAD_PP_NOF_PORTS; ++port_i)
          {

              res = arad_pp_port_info_get_unsafe(
                  unit,
                  core,
                  port_i,
                  &port_info
                );
            SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
            if (port_info.vlan_domain == isem_key->key_info.l2_eth.vlan_domain) 
            {        
              /* Check if VlanPortDoubleLookupEnable */
              ARAD_PP_PON_DOUBLE_LOOKUP_PORT_GET(port_i, pon_double_lookup_enable);
              break;
            }
          }
      }

      /* In case of Double lookup require to add to only ISEM_B for ARAD+ and comton_pon_enable, and both DBs ISEM_A and ISEM_B for other */
      if (pon_double_lookup_enable)
      {
        if (SOC_IS_ARADPLUS(unit) && prog_soc_prop.custom_pon_enable) {
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;  
        } else {
          /* Duplicate twice */
          *nof_tables = 2;
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
          tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
          *is_duplicate_entry = 1;
        }
      }
      else
      {
        /* Only add to ISEM-A */
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }     
    }
  default:
    /* Other key types will be checked later */
    break;
  }
  /* PON } */
   

  /* MPLS { */
  
  /* Unindexed: Label in ISEM-B */
  /* Indexed: L1 and L3 in ISEM-B. L2 in ISEM-B */
  
  switch(isem_key->key_type)
  {
  /* MPLS */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:
      found = TRUE;
      if(isem_key->key_info.mpls.flags == SOC_PPC_MPLS_TERM_FLAG_DUMMY_LABEL)
      {
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }else{
          tables_access_ids[0] = prog_soc_prop.mpls_1_database; /* Assume database 1 always refer to L1 */
      }
      break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L2,
                                        prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace,
                                        prog_soc_prop.mpls_2_database, prog_soc_prop.mpls_2_namespace,
                                        prog_soc_prop.mpls_3_database, prog_soc_prop.mpls_3_namespace,
                                        &namespace,
                                        &tables_access_ids[0]);
    SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);
        
    found = TRUE;    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
    found = TRUE;
    res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L3,
                                        prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace,
                                        prog_soc_prop.mpls_2_database, prog_soc_prop.mpls_2_namespace,
                                        prog_soc_prop.mpls_3_database, prog_soc_prop.mpls_3_namespace,
                                        &namespace,
                                        &tables_access_ids[0]);
    SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VLAN_DOMAIN_MPLS_L1:
    found = TRUE;
    *nof_tables = 1;
     tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
    break;
  default:
    /* Other key types will be checked later */
    break;
  }
  
  /* MPLS } */
  
  /* Check other key types */
  if (!found)
  {
    *is_duplicate_entry = 0;
    /* General without specific logic */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF:
      /*
       * All of this key types are located in A
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      found = TRUE;
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
     /*
      * All of this key types can be located in A or B or both.
      */
      *nof_tables = 2;      
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:        
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
      /*
       * All of this key types are located in B
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      if ((isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI) &&
          ((isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS) != 0)) {
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      }
      found = TRUE;
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_EoIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
      /*
       * All of this key types are located in TCAM
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP: /* special case DIP same as MPLS 1 database */
      *nof_tables = 1;
      tables_access_ids[0] = (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
      found = TRUE;
      /* Trill lookups of bridges: Does not support Double lookup */  
      /* All lookups are done in ISEM-B */
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:
      /*
       * The key types are located in TCAM 
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      found = TRUE;
      break;

    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
      /*
       * The key types are located in TCAM
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      found = TRUE;
      break;
    default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 60, exit);
      break;
    }
  }
  
  if ((*nof_tables) == 2 && !(*is_duplicate_entry))
  {
     /* Dump Algorithm. Always fill Table A first */
    tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
    tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_sem_tables_get()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_key_type_to_prefix(
    SOC_SAND_IN int                                  unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY_TYPE           isem_key_in,
    SOC_SAND_IN  uint32                                 table_access_id,
    SOC_SAND_OUT uint32                                 *isem_prefix    
  )
{
  uint32
    res = SOC_SAND_OK;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  *isem_prefix = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]
  
  switch(isem_key_in)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS: 
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:     
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX:
        ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX /* ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX */;
    break;         
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX /* ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX, ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX */;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
    *isem_prefix = (table_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX:ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:  
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
    *isem_prefix = prog_soc_prop.pon_enable ? ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX:ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4: 
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IPV4_SPOOF_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:  
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FC_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_TT:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_OAM_STAT_TT_PREFIX;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_VT:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_OAM_STAT_VT_PREFIX;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_VT:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_BFD_STAT_VT_PREFIX;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISA:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_BFD_STAT_TT_ISA_PREFIX;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISB:
	  *isem_prefix = ARAD_PP_ISEM_ACCESS_BFD_STAT_TT_ISB_PREFIX;
	  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF:
      *isem_prefix = ARAD_PP_ISEM_ACCESS_VTEP_INDEX_SIP_VRF_MY_PREFIX;
      break; 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VLAN_DOMAIN_MPLS_L1:
      *isem_prefix = ARAD_PP_ISEM_ACCESS_VLAN_DOMAIN_MPLS_L1_PREFIX;
      break; 
  default:
    break;
  }


  if (SOC_DPP_CONFIG(unit)->pp.vtt_pwe_vid_search) {
	  switch (isem_key_in) {
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
		  *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX_4bit;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
		  *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX_4bit;
		  break;
	  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
		  *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX_4bit;
		  break;
	  default:
		  break;
	  }
  }

  /* PON ports take 6 bits and 2 prefix bits are used to construct vtt key */
  if (_BCM_PPD_PON_PP_PORT_MAPPING_BY_PASS_IN_JER(unit)) {
	  switch (*isem_prefix) {
	  case ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX:
	  case ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX:
	  case ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX:
      case ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX:
          *isem_prefix = (*isem_prefix << 2);
		  break;
	  default:
		  break;
	  }
  }

  ARAD_DO_NOTHING_AND_EXIT;

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_key_type_to_prefix()", 0, 0);    
}

uint32
  arad_pp_isem_access_prefix_to_key_type(
    SOC_SAND_IN int                                  unit,
    SOC_SAND_IN uint32                                  isem_prefix,
    SOC_SAND_IN uint32                                  lookup_num,
    SOC_SAND_IN uint32                                  tables_access_id,
    SOC_SAND_IN uint32                                  *buffer,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY_TYPE           *isem_key_in
  )
{
  uint32
    res = SOC_SAND_OK,
    two_bits_indicate = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  /* Pick default */
  *isem_key_in = ARAD_PP_ISEM_ACCESS_NOF_KEY_TYPES;
  
  if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A || tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B)
  {

    /* special case for PON , ISEM-A prefix cover several databases (only 2 bits prefix) */
    if (prog_soc_prop.pon_enable && (!prog_soc_prop.custom_pon_enable) && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A && 
        ((isem_prefix >> (4 - ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS) == (ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX >> (4-ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS))))) 
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID;
    }
    else if (prog_soc_prop.pon_enable && prog_soc_prop.custom_pon_enable && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B && 
        ((isem_prefix >> (4 - ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS) == (ARAD_PP_ISEM_ACCESS_CUS_PON_TWO_TAGS_PREFIX >> (4-ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS))))) 
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID;
    }
    else if (prog_soc_prop.pon_enable && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
             ((isem_prefix >> (3) == (ARAD_PP_ISEM_ACCESS_IPV4_SPOOF_PREFIX >> (3)))))
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4;
    }
    else if(prog_soc_prop.custom_feature_vt_tst2 && lookup_num == 0)
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_AC_TST2;
    else
    {
      switch(isem_prefix)
      {
      case ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX:     
        {        
          /* Bridge prefix share more than one logical DB. In that case dont include prefix */
          /* Take 2 bits indication */
          res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS, &two_bits_indicate);
          SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

          switch (two_bits_indicate)
          {
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID;
            break;
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID;
            break;
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID;
            break;
          default: /* invalid indication */
            SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit); 
          }
        }
        break;
      case ARAD_PP_ISEM_ACCESS_IP_PREFIX: /* ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX or ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX if pon is enabled */       
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL;
        }
        else
        {
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP;
        }
        break;
      case ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX: /* ARAD_PP_ISEM_ACCESS_FC_PREFIX, ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX or ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX if pon is enabled */
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX;  
        }
        else
        {
			*isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB : ((prog_soc_prop.trill_mode == 2 /* FGL enabled */) ? ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX : ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE);
		}
		break;
		
		case ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX:
			*isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER;
		break;
		case ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX:
			*isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID;  
        break;          
        /* 
         * ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX,
         * ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX,
         * ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX
         */
      case ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX: 
        if (prog_soc_prop.mpls_index) 
        {
          if (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) 
          {
            if (prog_soc_prop.mpls_1_database == tables_access_id)
            {
              /* MPLS L1 or L3 */
              *isem_key_in = (prog_soc_prop.mpls_use_in_rif) ? ((lookup_num == 0 /* VT */) ? 
                                                                ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1):
                                                               ((lookup_num == 0 /* VT */) ? 
                                                                ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3);
            }
            else
            {
              *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2;
            }
          }
          else
          {
            *isem_key_in = (prog_soc_prop.mpls_2_database == tables_access_id) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3;  
          }
        } else {
          /* Unindexed */
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS;
        }          
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX, ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX */
        if (prog_soc_prop.mpls_index) 
        {
          *isem_key_in = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX;
        }
        else
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
        }        
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX:       
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI;
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX,  ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX */          
        *isem_key_in = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
                       ((prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2 && lookup_num == 0 /* VT */) ? 
                        ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI);
        break;
      case ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID;
        break;
      case ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA;
        break;
      case ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL */
        if (prog_soc_prop.pwe_gal_support) 
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL;                       
        } 
        else 
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK; 
        }
        break;
      case ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX:
        *isem_key_in = (prog_soc_prop.vxlan_enable ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE);    
        break;      
      case ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID;
        break;
      case ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE: /* ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE or TST or ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX if pon is enabled */
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID;
        }
        else if (prog_soc_prop.custom_feature_vt_tst1) {          
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? 
              ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG;

          if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
              /* DT prefix share more than one logical DB. In that case dont include prefix */
              /* Take inner bits Value 0 indication */
              res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, &two_bits_indicate);
              SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
              if (two_bits_indicate) {
                  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &two_bits_indicate);
                  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
                  *isem_key_in = (two_bits_indicate) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG : ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG; 
              }              
          }
        }
        else
        {
				*isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ?
					ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG : ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG;
			}
			break;
		  case ARAD_PP_ISEM_ACCESS_VLAN_DOMAIN_MPLS_L1_PREFIX:
			  *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VLAN_DOMAIN_MPLS_L1;
			  break;
		default: /* Includes ARAD_PP_ISEM_ACCESS_NULL_PREFIX: */
			SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit);
			break;
		}
	}
	if (SOC_IS_ARADPLUS_A0(unit) && SOC_DPP_CONFIG(unit)->pp.oam_statistics) {
		switch (isem_prefix) {
		case ARAD_PP_ISEM_ACCESS_OAM_STAT_TT_PREFIX:
			*isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_TT;
			break; 
		  case ARAD_PP_ISEM_ACCESS_OAM_STAT_VT_PREFIX:
			  *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_VT;
			  break;
		  case ARAD_PP_ISEM_ACCESS_BFD_STAT_VT_PREFIX:
			  *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_VT;
			  break;
		  case ARAD_PP_ISEM_ACCESS_BFD_STAT_TT_ISA_PREFIX:
			  *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISA;
			  break;
		  case ARAD_PP_ISEM_ACCESS_BFD_STAT_TT_ISB_PREFIX:
			  *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISB;
			  break;
		  default:
			  break;
		  }
	  }
  }
  else
  {
    switch(isem_prefix) /* TCAM db profile ID */
    {
    case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_TT_DIP_COMPRESSION_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_TT_IPV6_SPOOF_COMPRESSION:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_TST2_PROFILE:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST2_TCAM;
        break;
    case ARAD_PP_ISEM_ACCESS_TCAM_VRRP_VSI_DA_PROFILE:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VSI_DA_DB_VRRP_TCAM;
        break;
    case ARAD_PP_ISEM_ACCESS_TCAM_SRC_PORT_DA_DB_PROFILE:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SRC_PORT_DA_DB_TCAM;
        break;
    case ARAD_PP_ISEM_ACCESS_TCAM_DIP_SIP_VRF_PROFILE:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF;
        break;
    default: /* Includes ARAD_PP_ISEM_ACCESS_NULL_PREFIX, ARAD_PP_ISEM_ACCESS_MY_B_MAC_MC_PREFIX: */
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 100, exit);
    }
  }
  
  ARAD_DO_NOTHING_AND_EXIT;

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prefix_to_key_type()", isem_prefix, tables_access_id);    
}

uint32
  arad_pp_isem_access_key_to_buffer(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                *isem_key_in,
    SOC_SAND_IN  uint32                                 table_access_id,
    SOC_SAND_IN  uint32                                 insert_index, /* Inseration iteration */
    SOC_SAND_OUT uint32                                 *buffer
  )
{
  uint32
    res = SOC_SAND_OK,
    tmp;
  uint32
    prefix,clean_prefix=0;
  ARAD_PP_ISEM_ACCESS_KEY
    *isem_key, isem_key_s;
  SOC_PPC_PORT_INFO
    port_info;
  uint32
    mac_U32[SOC_SAND_PP_MAC_ADDRESS_NOF_UINT32S] = {0};
  uint32 ip6_address[SOC_SAND_PP_IPV6_ADDRESS_NOF_UINT32S] = {0};
  uint32 label_offset = 0, label_nof_bits = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_KEY_SIZE);  

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  isem_key = &isem_key_s;

  res = arad_pp_sem_key_extend(unit,isem_key_in,insert_index,isem_key);
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);

  /* Retrieve prefix */
  if (table_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) {
      res = arad_pp_isem_access_key_type_to_prefix(unit,isem_key_in->key_type,table_access_id,&prefix);
      SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

      res = soc_sand_bitstream_set_any_field(&prefix, ARAD_PP_ISEM_ACCESS_LSB_PREFIX, ARAD_PP_ISEM_ACCESS_NOF_BITS_PREFIX, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
  } else {      
      uint8 prefix_fixed[ARAD_PP_SW_DB_HASH_KEY_TABLE_PART_LEN_BYTES] = {0};      

      /*this prefix is actually tcam_db_id in this case*/
      prefix = arad_pp_isem_access_tcam_db_id_get(isem_key->key_type);

      /*the function U32_to_U8 is reordering the bytes  (probably because of endianity)
        in DBAL we are using the stream directly so to be unify with DBAL we reordering it back*/
      res = soc_sand_U32_to_U8(&prefix, ARAD_PP_SW_DB_HASH_KEY_TABLE_PART_LEN_BYTES, prefix_fixed);
      
      SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
      sal_memcpy(&(prefix), prefix_fixed, 4);

      res = soc_sand_bitstream_set_any_field(&prefix, (ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES*2)*8, ARAD_PP_SW_DB_HASH_KEY_TABLE_PART_LEN_BYTES*8, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);
  }
  

  switch(isem_key->key_type)
  {
  /* MPLS / PWE */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
      if (isem_key->key_info.mpls.flags & SOC_PPC_MPLS_TERM_FLAG_DUMMY_LABEL){
            /* MPLS-LIF-Dummy, make all 21 bits as 1 */
            tmp = 0x1FFFFF;
            res = soc_sand_bitstream_set_any_field(&tmp, 1, 21, buffer);
            SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
            res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, buffer);
            SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

      }
      else{
          /* in EVPN application, the key is expected bos || label*/
          if (prog_soc_prop.evpn_enable) {
              label_offset = ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_LSB;
              label_nof_bits = ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_NOF_BITS;
          } else {
              label_offset = ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable);
              label_nof_bits = ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable);
          }
	        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, label_offset, label_nof_bits, buffer);
            SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);


            if (SOC_DPP_CONFIG(unit)->pp.vtt_pwe_vid_search)
            {
              /* key structure: {prefix:4bits, inner_vid:12bits, inner_vid_valid:1bit, outer_vid:12bits, outer_vid_valid:1bit, label:20bits} */
              switch (isem_key->key_type)
              {
              case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
              case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
              case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
                /* write 4 bit prefix */
                res = soc_sand_bitstream_set_any_field(&clean_prefix, 44, 6, buffer); /* clean the 6 bit prefix */
                SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);

                res = soc_sand_bitstream_set_any_field(&prefix, 46, 4, buffer); /* write a new 4 bit prefix */
                SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);

                /* write {inner_vid:12bits, inner_vid_valid:1bit, outer_vid:12bits, outer_vid_valid:1bit} to buffer */
                res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label2, 20, 26, buffer);
                SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
              default:
                break;
              }
            }


            /* Include BOS: in evpn, expect bos is indicated with 2 bits */
            if (prog_soc_prop.evpn_enable)
            {
                uint32 is_bos = 0;
                /* is_bos indication is needed only for IML labels; otherwise, is_bos == 0 */
                if (isem_key->key_info.mpls.flags & SOC_PPC_MPLS_TERM_FLAG_EVPN_IML) {
                    is_bos = isem_key->key_info.mpls.is_bos;
                    /* bos is indicated in bit 1; bit 0 is required as lost bit: This is because in the vtt lookup, the bos signal (taken from inner vid valid signal)
                       is taken with a lost bit due to nibble alignment issues */
                }
                res = soc_sand_bitstream_set_any_field(&is_bos, ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_EVPN_LABEL_BOS_NOF_BITS, buffer);
                SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
            } else if (prog_soc_prop.is_bos_in_key_enable) {
                res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, buffer);
                SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
            }
      }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_TT:
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.cfm_eth_type, ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_VT:
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.opaque, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.pph_type, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_VT:
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.opaque, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.pph_type, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISA:
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.bfd_format, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISB:
	   res = soc_sand_bitstream_set_any_field(&isem_key->key_info.oam_stat.bfd_format, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_NOF_BITS, buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.in_rif, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(prog_soc_prop.is_bos_in_key_enable) , ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(prog_soc_prop.is_bos_in_key_enable) , buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
    /* Inrif valid should be always */
    tmp = 1;
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 39, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);    
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);    

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label2, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 43, exit);    

    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);
    
    /* 2 bits indication */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      break;
    default:
      tmp = 0;
    }
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 49, exit);    

    /* Other special fields */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 441, exit);
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);
      break;
    default:
      break;
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4444, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4446, exit);

      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4449, exit);    

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 443, exit);
      
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 444, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 445, exit);

      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:    
      /* 
       * Retrieve VLAN domain
       */
      res = arad_pp_port_info_get_unsafe(unit, isem_key->key_info.l2_pon.core, isem_key->key_info.l2_pon.port, &port_info);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5440, exit);

      res = soc_sand_bitstream_set_any_field(&port_info.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5445, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.tunnel_id, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5450, exit);
      
      /* Other special fields */
      switch (isem_key->key_type)
      {
      case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5455, exit);
        break;    
      case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5460, exit);

        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5465, exit);
        break;      
      default:
        break;
      }       
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
      if (isem_key->key_info.l2_pon.port_valid) 
      {
        /* 
         * Retrieve VLAN domain
         */
        res = arad_pp_port_info_get_unsafe(unit, isem_key->key_info.l2_pon.core, isem_key->key_info.l2_pon.port, &port_info);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6440, exit);

        res = soc_sand_bitstream_set_any_field(&port_info.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6445, exit);
      }
      
      if (isem_key->key_info.l2_pon.tunnel_id_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.tunnel_id, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6450, exit);
      }
      
      if (isem_key->key_info.l2_pon.outer_vid_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6455, exit);      
      }
      
      if (isem_key->key_info.l2_pon.inner_vid_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6460, exit);
      }

      if (isem_key->key_info.l2_pon.outer_pcp_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6465, exit);
      }

      if (isem_key->key_info.l2_pon.outer_dei_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6470, exit);
      }

      if (isem_key->key_info.l2_pon.ether_type_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.ether_type, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS(unit), buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6475, exit);
      }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.pbb.isid_domain, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);
    if (SOC_DPP_CONFIG(unit)->pp.test1 == 0 ){
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.pbb.isid, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);
    } else {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.pbb.isid, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TEST1_ISID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);
    }

    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:
      if (isem_key->key_info.ip_tunnel.flags & SOC_PPC_RIF_IP_TERM_FLAG_USE_DIP_DUMMY) {
          if (isem_key->key_info.ip_tunnel.flags & SOC_PPC_RIF_IP_TERM_FLAG_IP_GRE_TUNNEL_IS_VALID && SOC_DPP_CONFIG(unit)->pp.custom_feature_ip_l3_gre_port_termination_lif_id) {
              /* LIF-Dummy, make  32 bits 1 and 2 MSB = 0x2f, this way no other IP packet will hit this entry. only GRE packet with L3_GRE_PORT program can hit this entry  */
              tmp = 0xffffffff; 
              res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, buffer);
              SOC_SAND_CHECK_FUNC_RESULT(res, 55, exit);
              tmp = 0x2f; /*ipv4_next_prtcl=GRE(0x2f)*/
              res = soc_sand_bitstream_set_any_field(&tmp, 32, 8, buffer);
              SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
          } else {
              /* IP-LIF-Dummy, make all 33 bits as 1 */
              tmp = 0xFFFFFFFF;
              res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, buffer);
              SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
              tmp = 0x1;
              res = soc_sand_bitstream_set_any_field(&tmp, 32, 1, buffer);
              SOC_SAND_CHECK_FUNC_RESULT(res, 57, exit);
          }
      } else {
          res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, buffer);
          SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);
      }
      break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 59, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF:
    tmp = 1; /* vt lookup found */
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VT_LOOKUP_FOUND_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 810, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.my_vtep_index, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_NOF_BITS(unit), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 811, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 812, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.vrf, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_NOF_BITS(unit), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 813, exit);
    break; 

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

     res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 61, exit);

    if (prog_soc_prop.ipv4_term_dip_sip_enable == 2 /* IPV4 next protocol enable */) {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ipv4_next_protocol, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 362, exit);

        soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.port_property, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 364, exit);

        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 363, exit);
    }
  break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF:   
      
          
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 780, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 781, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.vrf, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 782, exit);
      /* vrf valid */
      tmp = (isem_key->key_info.ip_tunnel.vrf_prefix_len > 0);  
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 783, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ipv4_next_protocol, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 784, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.gre_ethertype, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 785, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ip_gre_tunnel, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 786, exit);
      /* port property */
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.port_property, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 794, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 787, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 788, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.vrf_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 789, exit);

      /* for vrf valid only, mask the vrf valid bit.
         For vrf invalid, we don't mask the vrf and the vrf valid bit */
      if (isem_key->key_info.ip_tunnel.vrf_prefix_len > 0) { 
          /* vrf valid mask */
          tmp = 1;  
          res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_MASK_NOF_BITS(unit), buffer);
          SOC_SAND_CHECK_FUNC_RESULT(res, 790, exit);
      }

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 791, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.gre_ethertype_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 792, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ip_gre_tunnel_en, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_MASK_NOF_BITS(unit), buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 793, exit);

      break; 

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:       
    res = soc_sand_bitstream_set_any_field(isem_key->key_info.ip_tunnel.dip6.ipv6_address.address, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.nick_name, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.vsi, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.port, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.native_inner_tpid, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 78, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_gre.gre_key, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);
    tmp = ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL;
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 81, exit);
    if (SOC_IS_L2GRE_VDC_ENABLE(unit)) {
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_gre.match_port_class, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 82, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_vni.vni_key, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 85, exit);
    if (SOC_IS_VXLAN_VDC_ENABLE(unit)) {
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_vni.match_port_class, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 86, exit);
    }
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    tmp = ARAD_PP_FRWRD_FCF_GET_DOMAIN(isem_key->key_info.fcoe.d_id);
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

    isem_key->key_info.fcoe.vsan = isem_key->key_info.fcoe.vsan<<1;/* adding one zero to the VFT, alligment with the VFT taken from the packet */
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.fcoe.vsan, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 92, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:
    /* The function soc_sand_pp_mac_address_struct_to_long writes to indecies 0 and 1 of the second parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_struct_to_long(
            &(isem_key->key_info.spoof_v4.smac),
            mac_U32
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 190, exit);

    tmp = 0;
    res = soc_sand_bitstream_get_any_field(mac_U32, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 192, exit);

    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 195, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.spoof_v4.sip, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 200, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    /* The function soc_sand_pp_mac_address_struct_to_long writes to indecies 0 and 1 of the second parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_struct_to_long(
            &(isem_key->key_info.spoof_v6.smac),
            mac_U32
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 290, exit);

    tmp = 0;
    res = soc_sand_bitstream_get_any_field(mac_U32, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 292, exit);

    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 295, exit);

    res = soc_sand_bitstream_set_any_field(isem_key->key_info.spoof_v6.sip6.ipv6_address.address, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 210, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    if ((isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS) == 0) {
      tmp = 0;
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit); 
  
      /* 2 bits indication */
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_VL) {
          /* VL */
          tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID;
      } else {
          /* FGL ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL */
          tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      }
  
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit); 
      
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.high_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit); 
  
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL)  
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.low_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 530, exit); 
      }
    } else {
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.high_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit); 
    }      

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.rpa.dip, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 610, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.rpa.vrf, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 620, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain,ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);                                                                                                                
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);                                                                                                                
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:
    /* TCAM */
    res = soc_sand_bitstream_get_any_field(isem_key->key_info.ip6_compression.ip6.ipv6_address.address, 56, 72, ip6_address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 760, exit);
    res = soc_sand_bitstream_set_any_field(ip6_address, 0, 72, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 761, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
    res = soc_sand_bitstream_get_any_field(isem_key->key_info.spoof_v6.sip6.ipv6_address.address, 64, 64, ip6_address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 770, exit);
    res = soc_sand_bitstream_set_any_field(ip6_address, 0, 64, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 771, exit);
    /* Prefix value */
    tmp = isem_key->key_info.spoof_v6.vsi;
    res = soc_sand_bitstream_set_any_field(&tmp, 64, 8, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 773, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VLAN_DOMAIN_MPLS_L1:
    res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.vlan_domain), 0, 9,buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 780, exit);
    res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.label), 9, 20, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 781, exit);
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit);
    break;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_key_to_buffer()", 0, 0);
}

STATIC uint32
  arad_pp_isem_access_entry_to_buffer(
    SOC_SAND_IN  int                          unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY   *isem_entry,
    SOC_SAND_OUT uint32                      *buffer
  )
{
  uint32 res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  ARAD_PP_CLEAR(buffer, uint32, SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32));

  res = soc_sand_bitstream_set_any_field(&isem_entry->sem_result_ndx, 0 , SOC_DPP_DEFS_GET(unit, isem_payload_nof_bits), buffer);
  SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_to_buffer()", 0, 0);
}

uint32
  arad_pp_isem_access_entry_from_buffer(
    SOC_SAND_IN  int                         unit,
    SOC_SAND_IN  uint32                     *buffer,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY  *isem_entry
  )
{
  uint32 res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  ARAD_PP_CLEAR(isem_entry, ARAD_PP_ISEM_ACCESS_ENTRY, 1);

  res = soc_sand_bitstream_get_any_field(buffer, 0 , SOC_DPP_DEFS_GET(unit, isem_payload_nof_bits), &isem_entry->sem_result_ndx);
  SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_from_buffer()", 0, 0);
}

uint32
    arad_pp_isem_access_tcam_db_id_get(SOC_SAND_IN ARAD_PP_ISEM_ACCESS_KEY_TYPE key_type)
{
  uint32
    tcam_db_id;

  switch (key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR: 
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_DIP_SIP_VRF_PROFILE; 
    break; 

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TT_DIP_COMPRESSION_DB_PROFILE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TT_IPV6_SPOOF_COMPRESSION;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST2_TCAM:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TST2_PROFILE;
    break;
 case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TEST2_TCAM:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TEST2_PROFILE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SRC_PORT_DA_DB_TCAM:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_SRC_PORT_DA_DB_PROFILE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV4_MATCH_VT_DB_PROFILE: 
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_EFP: 
    tcam_db_id = ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VSI_DA_DB_VRRP_TCAM:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_VRRP_VSI_DA_PROFILE;
    break;
  default:
    tcam_db_id = ARAD_TCAM_MAX_NOF_LISTS;
    break;
  }

  return tcam_db_id;
}


STATIC
uint32
  arad_pp_isem_access_tcam_isem_key_to_stream(
      SOC_SAND_IN  int                 unit,
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY  *key,
      SOC_SAND_OUT uint8                  stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES]
  )
{
  uint32
    long_stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES/4];
  uint32
    res;
  

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);


  res = SOC_SAND_OK; sal_memset(long_stream, 0x0, sizeof(uint32) * ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES/4);
  SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

  switch(key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:   
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
      res = arad_pp_isem_access_key_to_buffer(unit, key, ARAD_PP_ISEM_ACCESS_ID_TCAM, 0, long_stream); /* Same as other VTT */
      SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);     
      break;
  default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 80, exit);      
      break;
  }

  res = soc_sand_U32_to_U8(
          long_stream,
          ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES,
          stream
        );
  SOC_SAND_CHECK_FUNC_RESULT(res,  100, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_key_to_stream()",0,0);
}

STATIC
  uint32
    arad_pp_isem_access_tcam_entry_mask_build(
      SOC_SAND_IN  int                    unit,
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY   *isem_key,
      SOC_SAND_OUT ARAD_TCAM_ENTRY           *entry
  )
{
  uint32
    res;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    /* set DIP mask*/
    soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB + 1 - isem_key->key_info.ip_tunnel.dip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB); 
    /* set SIP mask*/
    soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB + 1 - isem_key->key_info.ip_tunnel.sip_prefix_len, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB); 
    /* set Next protocol mask */
    if (prog_soc_prop.ipv4_term_dip_sip_enable == 2)
    {
      soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB+isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len-1); 
      if (isem_key->key_info.ip_tunnel.port_property_en) 
      {
        soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, 
                                         ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB+ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS-1); 
      }
      
    }
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF: 
      /* set DIP mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MSB + 1 - isem_key->key_info.ip_tunnel.dip_prefix_len, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MSB); 
      /* set SIP mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MSB + 1 - isem_key->key_info.ip_tunnel.sip_prefix_len, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MSB ); 
      /* set VRF mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MSB(unit) + 1 - isem_key->key_info.ip_tunnel.vrf_prefix_len, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MSB(unit)); 
      /* add VRF VALID BIT mask only if vrf is part of the key */
      if (isem_key->key_info.ip_tunnel.vrf_prefix_len > 0) {
          soc_sand_bitstream_set_bit_range(entry->mask, 
                                           ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit), 
                                           ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_VALID_LSB(unit)); 
      }
      /* set IP.protocol mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MSB(unit) + 1 - isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_PROTOCOL_MSB(unit)); 

      /* set GRE.etherype mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MSB(unit) + 1 - isem_key->key_info.ip_tunnel.gre_ethertype_len, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_GRE_ETHERTYPE_MSB(unit)); 

      /* set is IP-GRE tunnel mask */
      soc_sand_bitstream_set_bit_range(entry->mask, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit), 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_IP_GRE_TUNNEL_LSB(unit)); 

      /* set port_property mask */
      if (isem_key->key_info.ip_tunnel.port_property_en) {
          soc_sand_bitstream_set_bit_range(entry->mask,
                                           ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit),
                                           ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_MSB(unit));
      }

      break; 

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 127); /* Mask all , take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 135); /* Mask all , take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    /* UnMask DEI bit */
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all , except DEI, take into account all entry */     
    soc_sand_bitstream_reset_bit(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB); /* Mask all , except DEI, take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all , except VID, MSBs MPLS 2 take into account all entry */     
    /* UnMask VID LSBs [0:11] */
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END); /* except VID */         
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_END); /* except MPLS EXP */         
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_END); /* except MPLS TTL */             

    if (!prog_soc_prop.is_bos_in_key_enable) {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_END); /* except MPLS BOS */         
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* start by Mask all  */     
    /* On each invalid Unmask related field */
    if (!isem_key->key_info.l2_pon.port_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB(unit)); /* No Vlan-domain */         
    }
    if (!isem_key->key_info.l2_pon.inner_vid_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB(unit)); /* No inner-vlan */         
    }
    if (!isem_key->key_info.l2_pon.outer_vid_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB(unit)); /* No outer-vid */         
    }
    if (!isem_key->key_info.l2_pon.outer_dei_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB(unit)); /* No outer-dei */         
    }
    if (!isem_key->key_info.l2_pon.outer_pcp_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB(unit)); /* No outer-pcp */         
    }
    if (!isem_key->key_info.l2_pon.tunnel_id_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB(unit)); /* No tunnel-id */         
    }
    if (!isem_key->key_info.l2_pon.ether_type_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB(unit)); /* No ethertype */         
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* start by Mask all  */  
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all  */  
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END); /* except VID */         
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 71); /* Mask all , take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 71);
    if (isem_key->key_info.spoof_v6.sip6.prefix_len && 
        (SOC_SAND_PP_IPV6_ADDRESS_NOF_BITS != isem_key->key_info.spoof_v6.sip6.prefix_len)) {
      soc_sand_bitstream_reset_bit_range(entry->mask, 0,  (isem_key->key_info.spoof_v6.sip6.prefix_len-1));
    }
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 80, exit);      
    break;
  }  

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_mask_build()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_isem_entry_from_action(
      SOC_SAND_IN  ARAD_TCAM_ACTION           *action,
      SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY  *entry
  )
{
  uint32
    res;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);

  res = SOC_SAND_OK;
  sal_memset(
          entry,
          0x0,
          sizeof(ARAD_PP_ISEM_ACCESS_ENTRY)
        );
  SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

  entry->sem_result_ndx = action->value[0];

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_entry_from_action()",0,0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_entry_get_unsafe(
    SOC_SAND_IN  int               unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY *isem_key,
    SOC_SAND_IN  uint8               exact_match,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY *isem_entry,
    SOC_SAND_OUT uint8               *found
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint8
      hit_bit,            
    stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES] = {0};
  uint32
    entry_id;
  SOC_SAND_HASH_TABLE_PTR
    hash_tbl;
  uint32
    tcam_db_id;
  uint32
    priority;
  ARAD_TCAM_ENTRY
    entry;
  ARAD_TCAM_ACTION
    action;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_DRIVER_AND_DEVICE;

  ARAD_TCAM_ENTRY_clear(&entry);
  ARAD_TCAM_ACTION_clear(&action);
  /*
   *  Determine the database ID
   */
  tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                 isem_key->key_type
               );

  if (exact_match)
  {
    /*
     *  Search for the route_key in the route_key -> entry_id hash table
     */
    res = sw_state_access[unit].dpp.soc.arad.pp.vtt.isem_key_to_entry_id.get(
                 unit,
                 &hash_tbl
               );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);
    res = arad_pp_isem_access_tcam_isem_key_to_stream(
                 unit,
                 isem_key,
                 stream
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
    res = soc_sand_hash_table_entry_lookup(
            unit,
            hash_tbl,
            stream,
            &data_indx,
            found
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
    entry_id = data_indx;
  }
  else
  {
    /*
     *  Search the TCAM for the first match
     */
    res = arad_pp_isem_access_tcam_isem_key_to_stream(
                 unit,
                 isem_key,
                 stream
               );
    SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

    /* Set the valid bit */
    entry.valid = TRUE;

    /*
     * COVERITY
     *
     * Static array "entry.value" is not overrun
     */
    /* coverity[overrun-buffer-arg : FALSE] */
    res = soc_sand_U8_to_U32(
          stream,
          ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
          entry.value
        );
    SOC_SAND_CHECK_FUNC_RESULT(res,  15, exit);

    res = arad_pp_isem_access_tcam_entry_mask_build(
      unit,
      isem_key,
      &entry
    );
    SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

    res = arad_tcam_db_entry_search_unsafe(
            unit,
            tcam_db_id,
            &entry,
            &entry_id,
            found
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }

  if (*found)
  {
    res = arad_tcam_db_entry_get_unsafe(
            unit,
            tcam_db_id,
            entry_id,
            TRUE, /* hit_bit_clear */
            &priority,
            &entry,
            &action,
            found,
            &hit_bit
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

    res = arad_pp_isem_access_tcam_isem_entry_from_action(
            &action,
            isem_entry
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_get_unsafe()", 0, 0);
}



uint32 
    arad_pp_isem_access_isem_entry_get_unsafe(int unit, uint32 key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE], uint32 entry_buffer[SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32)], uint32 tbl_access_id, uint8* success)
{
    uint32 res = SOC_SAND_OK;
#if defined(CRASH_RECOVERY_SUPPORT) || defined(USING_CHIP_SIM)
    uint32 access_addr; 
#endif

#ifndef USING_CHIP_SIM
    uint32      block_port_id, temp; 
    soc_field_t tmp_fld_name;
    uint64      key_buffer_64b;
    soc_reg_t   tmp_reg_name;
#endif

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);


#ifdef CRASH_RECOVERY_SUPPORT
       if (SOC_IS_DONE_INIT(unit))
        {
            if (BCM_UNIT_DO_HW_READ_WRITE(unit))
            {
/*                LOG_ERROR(BSL_LS_SOC_HWLOG, (BSL_META_U(unit, "arad_pp_isem_access_entry_get_unsafe!!!!!!!!!!!!!!!!\n")));*/

                access_addr = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
/*                    COMPILER_64_SET(key_buffer_64b, key_buffer[1], key_buffer[0]);*/
                res = chip_sim_exact_match_entry_get_unsafe(
                        unit,
                        access_addr,
                        key_buffer,
                        ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
                        entry_buffer,
                        SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32),
                        success
                      );
                SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);

                return SOC_SAND_OK;

            }
        }
#endif /* CRASH_RECOVERY_SUPPORT */

    #ifndef USING_CHIP_SIM
          COMPILER_64_SET(key_buffer_64b, key_buffer[1], key_buffer[0]);
          if(SOC_IS_QAX(unit))
          {
              block_port_id = REG_PORT_ANY;
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? PPDB_A_ISEM_DIAGNOSTICS_KEYr : PPDB_B_ISEM_DIAGNOSTICS_KEYr;
          } else {
              if (SOC_IS_JERICHO(unit)) {
                  block_port_id = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? 0 : 1 ;
                  tmp_reg_name = IHB_ISEM_DIAGNOSTICS_KEYr;
              } else {
                  block_port_id = REG_PORT_ANY;
                  tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_DIAGNOSTICS_KEYr: IHP_ISB_DIAGNOSTICS_KEYr;
              }
          }
          SOC_SAND_SOC_IF_ERROR_RETURN(res, 1120, exit, soc_reg_set(unit, tmp_reg_name, block_port_id, 0, key_buffer_64b));

          if(SOC_IS_QAX(unit))
          {
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_DIAGNOSTICSr : PPDB_B_ISEM_DIAGNOSTICSr;
              tmp_fld_name = ISEM_DIAGNOSTICS_LOOKUPf;
          } else
          {
              if (SOC_IS_JERICHO(unit)) {
                  tmp_reg_name = IHB_ISEM_DIAGNOSTICSr;
                  tmp_fld_name = ISEM_DIAGNOSTICS_LOOKUPf;
              } else {
                  tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_DIAGNOSTICSr:IHP_ISB_DIAGNOSTICSr;
                  tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ISA_DIAGNOSTICS_LOOKUPf:ISB_DIAGNOSTICS_LOOKUPf;
              }
          }
          
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  0x1));
          
          res = arad_polling(
                  unit,
                  ARAD_TIMEOUT,
                  ARAD_MIN_POLLS,
                  tmp_reg_name,
                  block_port_id,
                  0,
                  tmp_fld_name,
                  0
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
          
          temp = 0;
          
          if(SOC_IS_QAX(unit)){
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_DIAGNOSTICS_LOOKUP_RESULTr : PPDB_B_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = ISEM_ENTRY_FOUNDf;
          } else {
              if (SOC_IS_JERICHO(unit)) {
                  tmp_reg_name = IHB_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
                  tmp_fld_name = ISEM_ENTRY_FOUNDf;
              } else {
                  tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_DIAGNOSTICS_LOOKUP_RESULTr:IHP_ISB_DIAGNOSTICS_LOOKUP_RESULTr;
                  tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ISA_ENTRY_FOUNDf:ISB_ENTRY_FOUNDf;
              }
          }
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
          *success = SOC_SAND_NUM2BOOL(temp);
          
          if(SOC_IS_QAX(unit)){
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_DIAGNOSTICS_LOOKUP_RESULTr : PPDB_B_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = ISEM_ENTRY_PAYLOADf;
          } else {
              if (SOC_IS_JERICHO(unit)) {
                  tmp_reg_name = IHB_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
                  tmp_fld_name = ISEM_ENTRY_PAYLOADf;
              } else {
                  tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_DIAGNOSTICS_LOOKUP_RESULTr:IHP_ISB_DIAGNOSTICS_LOOKUP_RESULTr;
                  tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ISA_ENTRY_PAYLOADf:ISB_ENTRY_PAYLOADf;
              }
          }
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &entry_buffer[0]));
#else /* PLISIM*/
          access_addr = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
            ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
          res = chip_sim_exact_match_entry_get_unsafe(
                  unit,
                  access_addr,
                  key_buffer,
                  ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
                  entry_buffer,
                  SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32),
                  success
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
#endif

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_isem_entry_get_unsafe()", 0, 0);
}


uint32
  arad_pp_isem_access_entry_get_unsafe(
    SOC_SAND_IN  int                        unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY    *isem_key,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY  *isem_entry,
    SOC_SAND_OUT uint8                      *success
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];
  uint32
    entry_buffer[SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32)];

  uint32
    nof_tables,
    tbl_access_idx,
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES];
  uint8
      is_duplicate_entry,
      found;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(isem_entry);
  SOC_SAND_CHECK_NULL_INPUT(success);

  ARAD_CLEAR(isem_entry, uint32, SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32));

  sal_memset(entry_buffer, 0x0, sizeof(uint32));

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

  *success = FALSE;
  /* Run over all tables that the entry might be there */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    if (tbl_access_idx > 0 && *success == TRUE)
    {
      /* Entry already found, no need to check more tables */
      break;
    }

    if (tables_access_ids[tbl_access_idx] != ARAD_PP_ISEM_ACCESS_ID_TCAM) {

        res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tables_access_ids[tbl_access_idx], tbl_access_idx, key_buffer);        
        SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

        res = arad_pp_isem_access_isem_entry_get_unsafe(unit, key_buffer, entry_buffer, tables_access_ids[tbl_access_idx], success);
        SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
      
        res = arad_pp_isem_access_entry_from_buffer(unit, entry_buffer, isem_entry);
        SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
    }
    else
    {
      /* TCAM */
      res = arad_pp_isem_access_tcam_entry_get_unsafe(unit,isem_key,TRUE,isem_entry,&found);
      SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
      *success = SOC_SAND_NUM2BOOL(found);
    }
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_get_unsafe()", 0, 0);
}

uint32
  arad_pp_isem_access_isem_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 *key_buffer,
    SOC_SAND_IN  uint32                                 *entry_buffer,
    SOC_SAND_IN  uint32                                 tables_access_id,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE               *success
  )
{
  uint32
    res;
  uint32
    buffer[ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE];
  uint32
    temp,  
    reason;
  uint32 access_addr;
#if SOC_DPP_IS_EM_HW_ENABLE
  uint32
    is_failed,
      block_id;    
  soc_mem_t
    tmp_mem_name;
  soc_reg_t
    tmp_reg_name;
  soc_field_t
    tmp_fld_name;
#endif
  uint32
      block_port_id;
  uint8 is_success = TRUE;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE);

  if (SOC_IS_JERICHO(unit)) {
      block_port_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? 0 : 1 ;
  } else {
      block_port_id = REG_PORT_ANY;
  }




  temp = ARAD_PP_ISEM_ACCESS_ACTION_TYPE_INSERT;
  reason = 0;
  res = SOC_SAND_OK;

  res = soc_sand_bitstream_set_any_field(
          &temp,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

  res = soc_sand_bitstream_set_any_field(
          key_buffer,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 27, exit);

  res = soc_sand_bitstream_set_any_field(
          entry_buffer,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
#if SOC_DPP_IS_EM_HW_ENABLE
/* this code should improve the HW access performance if we want to use it we need to port it to all devices */
/*#ifdef ARAD_FAST_REGISTERS_AND_FIELDS_ACCESS
      {
          int tmp_fld_id, tmp_reg_id;
          soc_reg_above_64_val_t data, fld_value;      
          tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ARAD_FAST_REG_IHP_ISA_INTERRUPT_REGISTER:ARAD_FAST_REG_IHP_ISB_INTERRUPT_REGISTER;
          tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ARAD_FAST_FIELD_IHP_ISA_INTERRUPT_REGISTER_ONE_ISA_MANAGEMENT_COMPLETED:ARAD_FAST_FIELD_IHP_ISB_INTERRUPT_REGISTER_ONE_ISB_MANAGEMENT_COMPLETED;
          SOC_REG_ABOVE_64_CLEAR(fld_value);
          ARAD_FAST_REGISER_GET(tmp_reg_id, data);
          ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
          temp = fld_value[0];
      }
#else*/
      if (SOC_IS_QAX(unit)) {
          tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_INTERRUPT_REGISTER_ONEr : PPDB_B_ISEM_INTERRUPT_REGISTER_ONEr;
          tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;
      } else {
          if (SOC_IS_JERICHO(unit)) {
              tmp_reg_name = IHB_ISEM_INTERRUPT_REGISTER_ONEr;
              tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;
          } else {
              tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_INTERRUPT_REGISTER_ONEr:IHP_ISB_INTERRUPT_REGISTER_ONEr;
              tmp_fld_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ISA_MANAGEMENT_COMPLETEDf:ISB_MANAGEMENT_COMPLETEDf;
          }
      }

      if(SOC_IS_QAX(unit)) {
          block_id = MEM_BLOCK_ALL;
          tmp_mem_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_MANAGEMENT_REQUESTm : PPDB_B_ISEM_MANAGEMENT_REQUESTm ;
      } else {
          if(SOC_IS_JERICHO(unit)) {
              block_id =  IHB_BLOCK(unit, block_port_id);
              tmp_mem_name = IHB_ISEM_MANAGEMENT_REQUESTm;
          } else {
              block_id = MEM_BLOCK_ALL;
              tmp_mem_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_REQUESTm: IHP_ISB_MANAGEMENT_REQUESTm;
          }
      }
/*#endif*/


      /* DON'T Check the "Readiness field" if HW LOG is activated */
      if (! SOC_IS_DONE_INIT(unit) &&  
#ifdef CRASH_RECOVERY_SUPPORT
          BCM_UNIT_DO_HW_READ_WRITE(unit)
#else
          (0)
#endif /* CRASH_RECOVERY_SUPPORT */
          )
      {
        SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  110,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
        if (temp)
        {
            SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_NOT_READY_ERR, 120, exit);
        }
      }

      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1230, exit, soc_mem_write(unit, tmp_mem_name, block_id, 0, buffer));

      res = arad_polling(
              unit,
              ARAD_TIMEOUT,
              ARAD_MIN_POLLS,
              tmp_reg_name,
              block_port_id,
              0,
              tmp_fld_name,
              1
            );
          SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);


#ifdef CRASH_RECOVERY_SUPPORT
         if (SOC_IS_DONE_INIT(unit))
          {
              if (BCM_UNIT_DO_HW_READ_WRITE(unit))
              {
                /* Update cache memory */
                access_addr = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ?
                             ARAD_CHIP_SIM_ISEM_A_BASE : ARAD_CHIP_SIM_ISEM_B_BASE;
                res = chip_sim_exact_match_entry_add_unsafe(
                      unit,
                      access_addr,
                      key_buffer,
                      ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
                      entry_buffer,
                      SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32) * sizeof(uint32),
                      &is_success
                      );
                SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

                *success = is_success ? SOC_SAND_SUCCESS : SOC_SAND_FAILURE_OUT_OF_RESOURCES;
                return SOC_SAND_OK;
              }
          }
#endif /* CRASH_RECOVERY_SUPPORT */

      /* clear management_completed by writing 1*/
temp = 1;
/* this code should improve the HW access performance if we want to use it we need to port it to all devices */
/*#ifdef ARAD_FAST_REGISTERS_AND_FIELDS_ACCESS
    {
        soc_reg_above_64_val_t data, fld_value;
        int tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_FAST_REG_IHP_ISA_INTERRUPT_REGISTER:ARAD_FAST_REG_IHP_ISB_INTERRUPT_REGISTER;
        int tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_FAST_FIELD_IHP_ISA_INTERRUPT_REGISTER_ONE_ISA_MANAGEMENT_COMPLETED:ARAD_FAST_FIELD_IHP_ISB_INTERRUPT_REGISTER_ONE_ISB_MANAGEMENT_COMPLETED;        
        ARAD_FAST_REGISER_GET(tmp_reg_id, data);
        fld_value[0] = temp;
        ARAD_FAST_FIELD_SET(tmp_fld_id, data, fld_value);
        ARAD_FAST_REGISER_SET(tmp_reg_id, data);

        tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
          ARAD_FAST_REG_IHP_ISA_MANAGEMENT_UNIT_FAILURE:ARAD_FAST_REG_IHP_ISB_MANAGEMENT_UNIT_FAILURE;              
        ARAD_FAST_REGISER_GET(tmp_reg_id, data);            
        
        *success = SOC_SAND_SUCCESS;

        tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
          ARAD_FAST_FIELD_IHP_ISA_MANAGEMENT_UNIT_FAILURE_ISA_MNGMNT_UNIT_FAILURE_VALID:ARAD_FAST_FIELD_IHP_ISB_MANAGEMENT_UNIT_FAILURE_ISB_MNGMNT_UNIT_FAILURE_VALID;  
        ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
        is_failed = fld_value[0];

        if (is_failed)
        {
            tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
            ARAD_FAST_FIELD_IHP_ISA_MANAGEMENT_UNIT_FAILURE_ISA_MNGMNT_UNIT_FAILURE_REASON:ARAD_FAST_FIELD_IHP_ISB_MANAGEMENT_UNIT_FAILURE_ISB_MNGMNT_UNIT_FAILURE_REASON; 
            SOC_REG_ABOVE_64_CLEAR(fld_value);
            ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
            reason = fld_value[0];
        }
    }

#else*/
 {
     uint64 failure;

      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  150,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  temp));

      if (SOC_IS_QAX(unit)) {
          tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_MANAGEMENT_UNIT_FAILUREr : PPDB_B_ISEM_MANAGEMENT_UNIT_FAILUREr;

      } else {
          if (SOC_IS_JERICHO(unit)) {
              tmp_reg_name = IHB_ISEM_MANAGEMENT_UNIT_FAILUREr;
          } else {
              tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_UNIT_FAILUREr: IHP_ISB_MANAGEMENT_UNIT_FAILUREr;
          }
      }
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1240, exit, soc_reg_get(unit, tmp_reg_name, block_port_id, 0, &failure));

      *success = SOC_SAND_SUCCESS;

      tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_VALIDf: 
          ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_VALIDf: ISB_MNGMNT_UNIT_FAILURE_VALIDf);
      is_failed = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
      if (is_failed)
      {
          tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_REASONf: 
              ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_REASONf: ISB_MNGMNT_UNIT_FAILURE_REASONf);

        reason = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
      }
 }
/*#endif*/
      if (is_failed)
      {        
        switch(reason)
        {
        case 0x001:/*Notice: Change non-exist from self  */
        case 0x002:/*Notice: Change non-exist from other */
        case 0x004:/*Notice: Change request over static  */
        case 0x008:/*Notice: Change-fail non exist       */
        case 0x080:/*Notice: Reached max entry limit     */
        case 0x200:/*Notice: Table coherence             */
        case 0x400:/*Notice: Cam table full*/
          *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES_2;
        break;
        default:
        break;
        }
      }
  #if ARAD_PP_ISEM_ACCESS_DEBUG
      if (reason)
      {
        switch(reason)
        {
        case 0x001:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change non-exist from self  ")));
          break;
        case 0x002:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change non-exist from other ")));
          break;
        case 0x004:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change request over static  ")));
          break;
        case 0x008:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change-fail non exist       ")));
          break;
        case 0x010:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Learn over existing         ")));
          break;
        case 0x020:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Learn request over static   ")));
          break;
        case 0x040:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Inserted existing           ")));
          break;
        case 0x080:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Reached max entry limit     ")));
          break;
        case 0x100:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Delete unknown key          ")));
          break;
        case 0x200:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Table coherence             ")));
          break;
        case 0x400:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Cam table full              ")));
          break;
        }
      }
  #endif
#endif
      if (SOC_DPP_IS_EM_SIM_ENABLE(unit)) {
          access_addr = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
          res = chip_sim_exact_match_entry_add_unsafe(
                  unit,
                  access_addr,
                  key_buffer,
                  ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
                  entry_buffer,
                  SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32) * sizeof(uint32),
                  &is_success
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

          *success = is_success ? SOC_SAND_SUCCESS : SOC_SAND_FAILURE_OUT_OF_RESOURCES;
      }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_isem_entry_add_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_isem_entry_to_action(
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY  *entry,
      SOC_SAND_OUT ARAD_TCAM_ACTION           *action
  )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);

  ARAD_TCAM_ACTION_clear(action);

  action->value[0] = entry->sem_result_ndx;

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_entry_to_action()",0,0);
}

/* Currently no use for priority as it is always exact match */
STATIC uint32
  arad_pp_isem_access_tcam_to_prio(
    SOC_SAND_IN  int                                      unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                     *isem_key
  )
{
  uint32
    prio = SOC_SAND_U32_MAX;

  if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID) /* Special case of PON extend TCAM */
  {
    /* VD */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_VD_PRIO * isem_key->key_info.l2_pon.port_valid);
    
    /* Tunnel */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_TUNNEL_ID_PRIO * isem_key->key_info.l2_pon.tunnel_id_valid);

    /* Inner-VID */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_INNER_VID_PRIO * isem_key->key_info.l2_pon.inner_vid_valid);

    /* Outer-VID */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_VID_PRIO * isem_key->key_info.l2_pon.outer_vid_valid);

    /* Outer-DEI */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_DEI_PRIO * isem_key->key_info.l2_pon.outer_dei_valid);

    /* Outer-PCP */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_PCP_PRIO * isem_key->key_info.l2_pon.outer_pcp_valid);

    /* Ethertype */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_ETHERTYPE_PRIO * isem_key->key_info.l2_pon.ether_type_valid);
  }
  else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP) {
      prio -= isem_key->key_info.ip_tunnel.sip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.dip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.port_property_en;
  }
  else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF) {
      prio -= isem_key->key_info.ip_tunnel.sip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.dip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.vrf_prefix_len; 

  }
  else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION) {
    prio -= isem_key->key_info.spoof_v6.sip6.prefix_len;
  }
  else
  {
    prio = 0; /* always 0 , all other TCAM insertions are exact match */
  }
   
  return prio;
}

STATIC
uint32
  arad_pp_isem_access_tcam_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                *isem_key,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY              *isem_entry,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE               *success
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint32
    priority;
  uint8
    stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES] = {0};
  SOC_SAND_HASH_TABLE_PTR
    hash_tbl;
  uint8
    found,
    entry_added;
  uint32
    tcam_db_id;
  ARAD_TCAM_ENTRY
    entry;
  ARAD_TCAM_ACTION
    action;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* TCAM */
  ARAD_TCAM_ENTRY_clear(&entry);
  ARAD_TCAM_ACTION_clear(&action);

  /*
   *  Search for the vtt_key -> entry_id hash table
   */
  res = sw_state_access[unit].dpp.soc.arad.pp.vtt.isem_key_to_entry_id.get(
               unit,
               &hash_tbl
             );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  res = arad_pp_isem_access_tcam_isem_key_to_stream(
               unit,
               isem_key,
               stream
             );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = arad_pp_isem_access_tcam_isem_entry_to_action(
               isem_entry,
               &action
             );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);


  res = soc_sand_hash_table_entry_lookup(
          unit,
          hash_tbl,
          stream,
          &data_indx,
          &found
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (!found)
  {
    /*
     *  Insert the rule to the route_key -> entry_id table
     */
    res = soc_sand_hash_table_entry_add(
            unit,
            hash_tbl,
            stream,
            &data_indx,
            &entry_added
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else
  {
    entry_added = TRUE;
  }

  if (entry_added)
  {
    /*
     *  Remove the old entry, if applicable
     */
    tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                   isem_key->key_type
                 );
    res = arad_tcam_db_entry_remove_unsafe(
            unit,
            FALSE /* is_bank_freed_if_no_entry */,
            tcam_db_id,
            data_indx
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);

    /*
     *  Insert the new rule to the TCAM
     */
    priority = arad_pp_isem_access_tcam_to_prio(
                 unit,
                 isem_key
               );

    /* Set the valid bit */
    entry.valid = TRUE;

/*
 * COVERITY
 *
 * Static array "entry.value" is not overrun
 */
/* coverity[overrun-buffer-arg] */
    res = soc_sand_U8_to_U32(
          stream,
          ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
          entry.value
        );
    SOC_SAND_CHECK_FUNC_RESULT(res,  100, exit);

    res = arad_pp_isem_access_tcam_entry_mask_build(
      unit,
      isem_key,      
      &entry
    );
    SOC_SAND_CHECK_FUNC_RESULT(res,  200, exit);


    res = arad_tcam_managed_db_entry_add_unsafe(
            unit,
            tcam_db_id,
            data_indx,
            FALSE,
            priority,
            &entry,
            &action,
            success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

    if ((*success != SOC_SAND_SUCCESS) && (!found))
    {
      res = soc_sand_hash_table_entry_remove_by_index(
              unit,
              hash_tbl,
              data_indx
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
    }
  }
  else
  {
    *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES;
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_add_unsafe()", 0, 0);
}


/*
 * given a location in tcam bank, search for the entry in SW database.
 * If exists get the value+mask from from hash table and write it,
 * otherwise, write an empty entry.
 * the argument global_location is only valid if entry_exists is true
 */
uint32
  arad_pp_isem_access_tcam_rewrite_entry(
     SOC_SAND_IN  int                        unit,
     SOC_SAND_IN  uint8                      entry_exists,
     SOC_SAND_IN  ARAD_TCAM_GLOBAL_LOCATION  *global_location,
     SOC_SAND_IN  ARAD_TCAM_LOCATION         *location
  )
{
    uint32 res = SOC_SAND_OK;
    uint32 prefix = 0;
    SOC_SAND_HASH_TABLE_PTR
        hash_tbl;
    uint8
        found;
    uint8
      stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES];
    ARAD_TCAM_ENTRY
        entry;
    ARAD_TCAM_BANK_ENTRY_SIZE
        entry_size;
    ARAD_PP_ISEM_ACCESS_KEY
        isem_key;
    
    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

    SOC_SAND_CHECK_NULL_INPUT(global_location);
    SOC_SAND_CHECK_NULL_INPUT(location);

    /*
     * In case VT/TT is the owner of the TCAM bank, the handling of the
     * error is different for TCAM banks and action tables (SRAM memory).
     * The reason for the different handling is that TCAM entries (keys)
     * are saved in SW, however  the actions aren't. When it is needed
     * to read the action, then the route key is supplied and action is
     * retrieved from HW.
     */
    found = FALSE;
    ARAD_TCAM_ENTRY_clear(&entry);

    if(entry_exists)
    {
        /* get the hash table for specific tcam database */
        res = sw_state_access[unit].dpp.soc.arad.pp.vtt.isem_key_to_entry_id.get(unit, &hash_tbl);
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);
        
        /* if entry exists get its value */
        res = soc_sand_hash_table_get_by_index(unit, hash_tbl, global_location->entry_id, stream, &found);
        SOC_SAND_CHECK_FUNC_RESULT(res, 7, exit);

        if(found)
        {
            res = soc_sand_U8_to_U32(
                  stream,
                  ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
                  entry.value
                );
            SOC_SAND_CHECK_FUNC_RESULT(res,  10, exit);

            res = arad_pp_isem_access_key_from_buffer(unit, entry.value, 0, ARAD_PP_ISEM_ACCESS_ID_TCAM, &isem_key);
            SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);     

            /* taking value from stream!*/      
            sal_memcpy(&(stream[ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES*2]),&prefix ,ARAD_PP_SW_DB_HASH_KEY_TABLE_PART_LEN_BYTES); 

            res = arad_pp_isem_access_prefix_to_key_type(unit, prefix, 0, ARAD_PP_ISEM_ACCESS_ID_TCAM, entry.value, &(isem_key.key_type));
            SOC_SAND_CHECK_FUNC_RESULT(res,  25, exit);

            entry.valid = TRUE;

            res = arad_pp_isem_access_tcam_entry_mask_build(unit, &isem_key, &entry);
            SOC_SAND_CHECK_FUNC_RESULT(res,  30, exit);
        }
        else
        {
            /* error if entry was not found - entry_exists indicates otherwise */
            SOC_SAND_SET_ERROR_CODE(SOC_SAND_GEN_ERR, 40, exit);
        }
    }
    /* else :
     * In case entry does not exist then rewrite a cleared
     * entry in order to refresh the key, mask and parity
     */

    res = sw_state_access[unit].dpp.soc.arad.tm.tcam.bank.entry_size.get(unit, location->bank_id, &entry_size);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 12, exit);

    /* write entry to specific location in HW without SW management */
    res = arad_tcam_entry_rewrite(unit, entry_exists, global_location->tcam_db_id, location, entry_size, &entry);
    SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

exit:
    SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ip_tcam_rewrite_entry()", 0, 0);
}

uint32
  arad_pp_isem_access_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                     *isem_key,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY                   *isem_entry,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE                      *success
  )
{
  uint32
    res = SOC_SAND_OK;  
  uint32
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];
  uint32     
    nof_tables,   
    tbl_access_idx,
    tables_access_id,
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES],
    entry_buffer[SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32)];  
  uint8
    is_duplicate_entry;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(isem_entry);
  SOC_SAND_CHECK_NULL_INPUT(success);

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

  *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES;

  /* Run over all tables that the entry should be insert */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    /* If insertion is on arbitrary table, exit on success after first iteration*/
    if (!is_duplicate_entry && tbl_access_idx > 0 && *success == SOC_SAND_SUCCESS)
    {
      break;
    }
    tables_access_id = tables_access_ids[tbl_access_idx];
    if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A ||
        tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B)
    {
      /* add ISEM entry */
      res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tables_access_id, tbl_access_idx, key_buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

      res = arad_pp_isem_access_entry_to_buffer(unit, isem_entry, entry_buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
      
      res = arad_pp_isem_access_isem_entry_add_unsafe(unit,key_buffer,entry_buffer,tables_access_id,success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
    }
    else
    {
      /* add TCAM entry */
      res = arad_pp_isem_access_tcam_entry_add_unsafe(unit,isem_key,isem_entry,success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
    }
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_add_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_remove_unsafe(
    SOC_SAND_IN  int                                     unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                       *isem_key
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint8
    found;
  uint8
	  stream[ARAD_PP_SW_DB_HASH_KEY_LEN_BYTES] = {0};
  SOC_SAND_HASH_TABLE_PTR
    hash_tbl;
  uint32
    tcam_db_id;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_DRIVER_AND_DEVICE;

  /*
   *  Search for the route_key in the route_key -> entry_id hash table
   */
  res = sw_state_access[unit].dpp.soc.arad.pp.vtt.isem_key_to_entry_id.get(
               unit,
               &hash_tbl
             );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  res = arad_pp_isem_access_tcam_isem_key_to_stream(
               unit,
	        isem_key,
	        stream
	      );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  res = soc_sand_hash_table_entry_lookup(
          unit,
          hash_tbl,
          stream,
          &data_indx,
          &found
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (!found)
  {
    /* Nothing to do */
    SOC_SAND_SET_ERROR_CODE(SOC_PPD_ERR_NOT_EXIST, 30, exit);
  }

  res = soc_sand_hash_table_entry_remove_by_index(
          unit,
          hash_tbl,
          data_indx
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  /*
   *  Determine the database ID
   */
  tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                 isem_key->key_type
               );

  res = arad_tcam_managed_db_entry_remove_unsafe(
          unit,
          tcam_db_id,
          data_indx
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_remove_unsafe()", 0, 0);
}



uint32 
    arad_pp_isem_access_isem_entry_remove_unsafe(int unit, uint32 key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE], uint32 tables_access_id)
{
    uint32 temp, res, block_port_id, access_addr;
    uint32 buffer[ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE];
    uint64 failure;
    uint32 is_failed;
    uint32 reason = 0;

    
#if SOC_DPP_IS_EM_HW_ENABLE
    uint32      block_id;
    soc_mem_t   tmp_mem_name;
#endif

    soc_reg_t   tmp_reg_name;
    soc_field_t tmp_fld_name;



    SOC_SAND_INIT_ERROR_DEFINITIONS(0);
    ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE);

    temp = ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DELETE;
    res = soc_sand_bitstream_set_any_field(
            &temp,
            ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB,
            ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB + 1,
            buffer
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);

    res = soc_sand_bitstream_set_any_field(
            key_buffer,
            ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB,
            ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB + 1,
            buffer
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

#if SOC_DPP_IS_EM_HW_ENABLE
    if(SOC_IS_QAX(unit)) {
        block_port_id = REG_PORT_ANY;
        tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_INTERRUPT_REGISTER_ONEr : PPDB_B_ISEM_INTERRUPT_REGISTER_ONEr;
        tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;
    } else {
        if (SOC_IS_JERICHO(unit)) {
            block_port_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)?  0 : 1 ;
            tmp_reg_name = IHB_ISEM_INTERRUPT_REGISTER_ONEr;
            tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;
        } else {
            block_port_id = REG_PORT_ANY;
            tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_INTERRUPT_REGISTER_ONEr:IHP_ISB_INTERRUPT_REGISTER_ONEr;
            tmp_fld_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ISA_MANAGEMENT_COMPLETEDf:ISB_MANAGEMENT_COMPLETEDf;
        }
    }


    if (! ((SOC_IS_DONE_INIT(unit)) && 
#ifdef CRASH_RECOVERY_SUPPORT
           (BCM_UNIT_DO_HW_READ_WRITE(unit))
#else
           (0)
#endif /* CRASH_RECOVERY_SUPPORT */
           ))        /* Skip the read if HW LOG is activated. It doesn't reflect the 'ready' state anyway because all the read/writes are postponed if HwLog is activated */
    {
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
      if (temp)
      {
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_NOT_READY_ERR, 10, exit);
      }
    }

    if(SOC_IS_QAX(unit)) {
        block_id = MEM_BLOCK_ALL;
        tmp_mem_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? PPDB_A_ISEM_MANAGEMENT_REQUESTm : PPDB_B_ISEM_MANAGEMENT_REQUESTm;
    } else {
        if (SOC_IS_JERICHO(unit)) {
            tmp_mem_name = IHB_ISEM_MANAGEMENT_REQUESTm;
            block_id = IHB_BLOCK(unit, block_port_id);
        } else {
            tmp_mem_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_REQUESTm: IHP_ISB_MANAGEMENT_REQUESTm;
            block_id = MEM_BLOCK_ALL;
        }
    }
    SOC_SAND_SOC_IF_ERROR_RETURN(res, 1230, exit, soc_mem_write(unit, tmp_mem_name, block_id, 0, buffer));

    res = arad_polling(
            unit,
            ARAD_TIMEOUT,
            ARAD_MIN_POLLS,
            tmp_reg_name,
            block_port_id,
            0,
            tmp_fld_name,
            1
    );
    SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
    /* clear management_completed by writing 1*/
      temp = 1;
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  19,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  temp));
#endif
       if (SOC_DPP_IS_EM_SIM_ENABLE(unit)) {
          access_addr = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
             ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
          res = chip_sim_exact_match_entry_remove_unsafe(
                  unit,
                  access_addr,
                  key_buffer,
                  ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32)
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
       }

       if(SOC_IS_QAX(unit)) {
           block_port_id = REG_PORT_ANY;
           tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? PPDB_A_ISEM_MANAGEMENT_UNIT_FAILUREr : PPDB_B_ISEM_MANAGEMENT_UNIT_FAILUREr;
       } else {
           if(SOC_IS_JERICHO(unit)){
               block_port_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)?  0 : 1 ;
               tmp_reg_name = IHB_ISEM_MANAGEMENT_UNIT_FAILUREr;
           } else {
               block_port_id = REG_PORT_ANY;
               tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? IHP_ISA_MANAGEMENT_UNIT_FAILUREr: IHP_ISB_MANAGEMENT_UNIT_FAILUREr;
           }
       }
       SOC_SAND_SOC_IF_ERROR_RETURN(res, 1240, exit, soc_reg_get(unit, tmp_reg_name, block_port_id, 0, &failure));

       tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_VALIDf:
           ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_VALIDf: ISB_MNGMNT_UNIT_FAILURE_VALIDf);
       is_failed = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
       if (is_failed)
       {
           tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_REASONf:
               ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_REASONf: ISB_MNGMNT_UNIT_FAILURE_REASONf);

         reason = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
       }

       if (reason)
       {
#if ARAD_PP_ISEM_ACCESS_DEBUG
           switch(reason)
           {
           case 0x001:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Change non-exist from self  ")));
             break;
           case 0x002:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Change non-exist from other ")));
             break;
           case 0x004:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Change request over static  ")));
             break;
           case 0x008:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Change-fail non exist       ")));
             break;
           case 0x010:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Learn over existing         ")));
             break;
           case 0x020:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Learn request over static   ")));
             break;
           case 0x040:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Inserted existing           ")));
             break;
           case 0x080:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Reached max entry limit     ")));
             break;
           case 0x100:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Delete unknown key          ")));
             break;
           case 0x200:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Table coherence             ")));
             break;
           case 0x400:
             LOG_INFO(BSL_LS_SOC_LIF,
                      (BSL_META_U(unit,
                                  "Notice: Cam table full              ")));
             break;
           }
#endif
       }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_isem_entry_remove_unsafe()", 0, 0);
}


uint32
  arad_pp_isem_access_entry_remove_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY             *isem_key    
  )
{
  uint8  is_duplicate_entry;

  uint32
    nof_tables,
    tbl_access_idx,
    res = SOC_SAND_OK,    
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES],
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
    
  /* Run over all tables that the entry might appear */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    if (tables_access_ids[tbl_access_idx] != ARAD_PP_ISEM_ACCESS_ID_TCAM) 
    {
        res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tables_access_ids[tbl_access_idx], tbl_access_idx, key_buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

        res = arad_pp_isem_access_isem_entry_remove_unsafe(unit, key_buffer, tables_access_ids[tbl_access_idx]);
        SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);        
    }
    else
    {
      /* TCAM */
      res = arad_pp_isem_access_tcam_remove_unsafe(unit,isem_key);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
    }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_remove_unsafe()", 0, 0);
}

uint32
  arad_pp_isem_access_prog_sel_in_rif_key_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_OUT uint8                               *with_in_rif
  )
{
  uint32
    res = SOC_SAND_OK;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  SOC_SAND_CHECK_NULL_INPUT(with_in_rif);
  
  *with_in_rif = prog_soc_prop.mpls_use_in_rif; 

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_remove_unsafe()", 0, 0);
}

STATIC
uint32
    arad_pp_isem_access_ac_map_key_type_to_prog_sel(
     int                            unit,
     SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE       key_mapping,
     uint32                            *llvp_prog_sel_val
   )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch(key_mapping)
  {
  case SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN:
    *llvp_prog_sel_val = PROG_VT_VDxOUTERVID_L1;
    break;
  case SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN_VLAN:
    *llvp_prog_sel_val = PROG_VT_VD_OUTER_INNER;
    break;
  case SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_INITIAL_VLAN:
    *llvp_prog_sel_val = PROG_VT_VDxINITIALVID_L1;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR, 14590, exit);
    break;
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_ac_map_key_type_to_prog_sel()", key_mapping, 0);
}

STATIC
uint32
    arad_pp_isem_access_prog_sel_to_ac_map_key_type(
     int                            unit,
     uint32                            llvp_prog_sel_val,
     SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE       *key_mapping    
   )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch(llvp_prog_sel_val)
  {
  case PROG_VT_VDxOUTERVID_L1:
    *key_mapping = SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN;
    break;
  case PROG_VT_VD_OUTER_INNER:
    *key_mapping = SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN_VLAN;
    break;
  case PROG_VT_VDxINITIALVID_L1:
    *key_mapping = SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_PORT_INITIAL_VLAN;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR, 10, exit);
    break;
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_to_ac_map_key_type()", llvp_prog_sel_val, 0);
}

uint32
  arad_pp_isem_access_prog_sel_ac_key_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 entry_ndx,
    SOC_SAND_IN  SOC_PPC_L2_LIF_AC_KEY_QUALIFIER           *qual_key,
    SOC_SAND_IN  SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE            *key_mapping
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  uint32
    llvp_prog_sel_val = 0;
  ARAD_PP_MGMT_OPERATION_MODE
    *oper_mode = NULL;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  ARAD_ALLOC(oper_mode, ARAD_PP_MGMT_OPERATION_MODE, 1, "arad_pp_isem_access_prog_sel_ac_key_set_unsafe.oper_mode");
  ARAD_PP_MGMT_OPERATION_MODE_clear(oper_mode);

  res = sw_state_access[unit].dpp.soc.arad.pp.oper_mode.get(unit,oper_mode);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 2, exit);  

  SOC_SAND_CHECK_NULL_INPUT(qual_key);
  SOC_SAND_CHECK_NULL_INPUT(key_mapping);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  if (entry_ndx > DPP_PP_ISEM_PROG_SEL_1ST_CAM_USR_LAST_ENTRY(unit))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR, 10, exit);
  }

  res = arad_pp_isem_access_ac_map_key_type_to_prog_sel(unit,*key_mapping,&llvp_prog_sel_val);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  

  if (*key_mapping == SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_DEFAULT)
  {
    prog_selection_1st_cam_tbl.valid = 0;
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask     = 0x7FF;
    prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask     = 0x7FF;
    prog_selection_1st_cam_tbl.packet_format_code_mask            = 0x3F;
    prog_selection_1st_cam_tbl.ptc_vt_profile_mask                = 0x3;
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK;
    prog_selection_1st_cam_tbl.parser_leaf_context_mask           = 0xF;
  }
  else
  {
    prog_selection_1st_cam_tbl.packet_format_qualifier_1      = ((qual_key->pkt_parse_info.outer_tpid << 3) | (qual_key->pkt_parse_info.is_outer_prio << 2) | (qual_key->pkt_parse_info.inner_tpid << 0)); 
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = 0x7e0;/*{11b111_1110_0000}; only ethernet tag format */
    prog_selection_1st_cam_tbl.packet_format_code             = 0x0;/*{6b000000};  (PacketFormatCode[5]==0) ==> starts with ethernet */
    prog_selection_1st_cam_tbl.packet_format_code_mask        = 0x1f;/*6b01_1111*/
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = qual_key->port_profile;
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;/*3b000*/
    prog_selection_1st_cam_tbl.llvp_prog_sel                  = llvp_prog_sel_val;
    prog_selection_1st_cam_tbl.valid                          = 0x1; /*1b1*/
  }
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  ARAD_FREE(oper_mode);
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_ac_key_set_unsafe()", entry_ndx, 0);
}

uint32
  arad_pp_isem_access_prog_sel_ac_key_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 entry_ndx,
    SOC_SAND_IN  SOC_PPC_L2_LIF_AC_KEY_QUALIFIER           *qual_key,
    SOC_SAND_OUT SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE            *key_mapping    
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  ARAD_PP_MGMT_OPERATION_MODE
    *oper_mode = NULL;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_ALLOC(oper_mode, ARAD_PP_MGMT_OPERATION_MODE, 1, "arad_pp_isem_access_prog_sel_ac_key_get_unsafe.oper_mode");
  ARAD_PP_MGMT_OPERATION_MODE_clear(oper_mode);

  res = sw_state_access[unit].dpp.soc.arad.pp.oper_mode.get(unit,oper_mode);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 3, exit);

  SOC_SAND_CHECK_NULL_INPUT(qual_key);
  SOC_SAND_CHECK_NULL_INPUT(key_mapping);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1); 

  if (entry_ndx > DPP_PP_ISEM_PROG_SEL_1ST_CAM_USR_LAST_ENTRY(unit))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR, 10, exit);
  }

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (prog_selection_1st_cam_tbl.valid)
  {
    res = arad_pp_isem_access_prog_sel_to_ac_map_key_type(unit,prog_selection_1st_cam_tbl.llvp_prog_sel,key_mapping);
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else
  {
    /* Entry not valid , return key type default - since no match */
    *key_mapping = SOC_PPC_L2_LIF_AC_MAP_KEY_TYPE_DEFAULT;   
  }
  

exit:
  ARAD_FREE(oper_mode);
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_ac_key_get_unsafe()", entry_ndx, 0);
}

/*********************************************************************
*     Get the pointer to the list of procedures of the
 *     arad_pp_api_isem_access module.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
CONST SOC_PROCEDURE_DESC_ELEMENT*
  arad_pp_isem_access_get_procs_ptr(void)
{
  return Arad_pp_procedure_desc_element_isem_access;
}
/*********************************************************************
*     Get the pointer to the list of errors of the
 *     arad_pp_api_isem_access module.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
CONST SOC_ERROR_DESC_ELEMENT*
  arad_pp_isem_access_get_errs_ptr(void)
{
  return Arad_pp_error_desc_element_isem_access;
}

uint32 arad_pp_isem_prefix_from_buffer(SOC_SAND_IN  int       unit,
                                       SOC_SAND_IN  uint32   *buffer,
                                       SOC_SAND_IN  uint32    lookup_num,
                                       SOC_SAND_IN  uint32    tables_access_id,
                                       SOC_SAND_OUT uint32   *prefix )
{
    uint8 valid = 0;
    uint32 tcam_db_id = 0;
    uint32 access_profile_id = 0;
    uint32 access_profile_from_buffer = 0;
    uint32 res = SOC_SAND_OK;

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

    if (tables_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM)
    {

       res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_LSB_PREFIX, ARAD_PP_ISEM_ACCESS_NOF_BITS_PREFIX, prefix);
       SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
    }
    else
    {
       res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB, ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_NOF_BITS, &access_profile_from_buffer);
       SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);

       for (tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_BASE; tcam_db_id <= ARAD_PP_ISEM_ACCESS_TCAM_END; tcam_db_id++)
       {
          res = sw_state_access[unit].dpp.soc.arad.tm.tcam.tcam_db.valid.get(unit, tcam_db_id, &valid);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 13, exit);
          if (valid)
          {
            res = sw_state_access[unit].dpp.soc.arad.tm.tcam.tcam_db.access_profile_id.get(
                    unit,
                    tcam_db_id,
                    0, /* No 320b DB */
                    &access_profile_id
                  );
            SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 13, exit);

            if (access_profile_id == access_profile_from_buffer)
            {
               break;
            }
          }
       }

       if (tcam_db_id > ARAD_PP_ISEM_ACCESS_TCAM_END)
       {
          /* No match */
          SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 300, exit);
       }

       *prefix = tcam_db_id;
    }

exit:
    SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prefix_from_buffer()", 0, 0);
}
uint32
  arad_pp_isem_access_key_from_buffer(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 *buffer,
    SOC_SAND_IN  uint32                                 lookup_num,
    SOC_SAND_IN  uint32                                 tables_access_id,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY                *isem_key
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    tmp = 0,
    prefix=0;
  ARAD_PP_ISEM_ACCESS_KEY_TYPE
    key_type = 0;
  uint32
    mac_U32[SOC_SAND_PP_MAC_ADDRESS_NOF_UINT32S] = {0};
  uint32
    ip6_address[SOC_SAND_PP_IPV6_ADDRESS_NOF_UINT32S] = {0};

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_PP_CLEAR(isem_key,ARAD_PP_ISEM_ACCESS_KEY,1);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]
  res = arad_pp_isem_prefix_from_buffer(unit,buffer,lookup_num,tables_access_id, &prefix);
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);
  
  res = arad_pp_isem_access_prefix_to_key_type(unit, prefix, lookup_num, tables_access_id, buffer, &key_type);
  SOC_SAND_CHECK_FUNC_RESULT(res, 14, exit);

  isem_key->key_type = (ARAD_PP_ISEM_ACCESS_KEY_TYPE)key_type;

  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

    /* Other special fields */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, &isem_key->key_info.l2_eth.outer_pcp);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);
      break;
    default:
      break;
    }        
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 5532, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 5538, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, &isem_key->key_info.l2_eth.outer_pcp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 443, exit);
    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 445, exit);
      
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS(unit), &isem_key->key_info.l2_pon.port); /* Returns VLAN domain */
    SOC_SAND_CHECK_FUNC_RESULT(res, 700, exit);

    isem_key->key_info.l2_pon.port_valid = TRUE;

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS(unit), &isem_key->key_info.l2_pon.tunnel_id); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 705, exit);
    
    isem_key->key_info.l2_pon.tunnel_id_valid = TRUE;

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL &&
        tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) {
        /* TLS service */
        isem_key->key_info.l2_pon.flags = ARAD_PP_ISEM_ACCESS_L2_PON_TLS;
    }

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID || 
        isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID ) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS(unit), &isem_key->key_info.l2_pon.outer_vid); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

      isem_key->key_info.l2_pon.outer_vid_valid = TRUE;
    }

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID) 
    { 
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS(unit), &isem_key->key_info.l2_pon.inner_vid); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 715, exit);

      isem_key->key_info.l2_pon.inner_vid_valid = TRUE;
    }    

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    /* In case of only key all attributes are valid */
    isem_key->key_info.l2_pon.port_valid = TRUE; /* Assumed to be always valid */
    isem_key->key_info.l2_pon.tunnel_id_valid = TRUE;
    isem_key->key_info.l2_pon.ether_type_valid = TRUE;
    isem_key->key_info.l2_pon.outer_dei_valid = TRUE;
    isem_key->key_info.l2_pon.outer_pcp_valid = TRUE;
    isem_key->key_info.l2_pon.outer_vid_valid = TRUE;
    isem_key->key_info.l2_pon.inner_vid_valid = TRUE;
    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS(unit), &isem_key->key_info.l2_pon.port); /* Returns VLAN domain */
    SOC_SAND_CHECK_FUNC_RESULT(res, 700, exit);  

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS(unit), &isem_key->key_info.l2_pon.tunnel_id); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 705, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS(unit), &isem_key->key_info.l2_pon.outer_vid); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS(unit), &isem_key->key_info.l2_pon.inner_vid); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 715, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS(unit), &isem_key->key_info.l2_pon.ether_type); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS(unit), &isem_key->key_info.l2_pon.outer_dei); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 725, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS(unit), &isem_key->key_info.l2_pon.outer_pcp); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);

    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS, &isem_key->key_info.pbb.isid_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
    
    if (SOC_DPP_CONFIG(unit)->pp.test1 == 0 ){
        res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS, &isem_key->key_info.pbb.isid);
        SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);
    } else {
        res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TEST1_ISID_NOF_BITS, &isem_key->key_info.pbb.isid);
        SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);
    }
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, &isem_key->key_info.ip_tunnel.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 59, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 800, exit); 
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_MY_VTEP_INDEX_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.my_vtep_index);
    SOC_SAND_CHECK_FUNC_RESULT(res, 801, exit); 
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_MY_VTEP_INDEX_SIP_VRF_VRF_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.vrf);
    SOC_SAND_CHECK_FUNC_RESULT(res, 802, exit); 
    break; 

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS, &isem_key->key_info.ip_tunnel.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 362, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MASK_NOF_BITS, &isem_key->key_info.ip_tunnel.dip_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 61, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MASK_NOF_BITS, &isem_key->key_info.ip_tunnel.sip_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS, &isem_key->key_info.ip_tunnel.ipv4_next_protocol);
    SOC_SAND_CHECK_FUNC_RESULT(res, 364, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS, &isem_key->key_info.ip_tunnel.port_property);
    SOC_SAND_CHECK_FUNC_RESULT(res, 366, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MASK_NOF_BITS, &isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 366, exit);

    isem_key->key_info.ip_tunnel.port_property_en = (isem_key->key_info.ip_tunnel.port_property) ? 1:0;     
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP_VRF:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_NOF_BITS, &isem_key->key_info.ip_tunnel.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 61, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.vrf);
    SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

    res = soc_sand_bitstream_set_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_PORT_PROPERTY_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.port_property);
    SOC_SAND_CHECK_FUNC_RESULT(res, 65, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_DIP_MASK_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.dip_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_SIP_MASK_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.sip_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_LSB(unit), ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_SIP_VRF_TCAM_VRF_MASK_NOF_BITS(unit), &isem_key->key_info.ip_tunnel.vrf_prefix_len);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

    isem_key->key_info.ip_tunnel.port_property_en = (isem_key->key_info.ip_tunnel.port_property) ? 1:0;

    break; 
 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS, isem_key->key_info.ip_tunnel.dip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS, &isem_key->key_info.trill.nick_name);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS, &isem_key->key_info.trill.vsi);
    SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS, &isem_key->key_info.trill.port);
    SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS, &isem_key->key_info.trill.native_inner_tpid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 78, exit);
    break;


  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS, &isem_key->key_info.l2_gre.gre_key);
    SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);
    if (SOC_IS_L2GRE_VDC_ENABLE(unit)) {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_VD_NOF_BITS, &isem_key->key_info.l2_vni.match_port_class);
      SOC_SAND_CHECK_FUNC_RESULT(res, 81, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS, &isem_key->key_info.l2_vni.vni_key);
    SOC_SAND_CHECK_FUNC_RESULT(res, 85, exit);
    if (SOC_IS_VXLAN_VDC_ENABLE(unit)) {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VD_NOF_BITS, &isem_key->key_info.l2_vni.match_port_class);
      SOC_SAND_CHECK_FUNC_RESULT(res, 86, exit);
    }
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 93, exit);    
    ARAD_PP_FRWRD_FCF_SET_DOMAIN(isem_key->key_info.fcoe.d_id,tmp);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_VSAN_NOF_BITS, &isem_key->key_info.fcoe.vsan);
    SOC_SAND_CHECK_FUNC_RESULT(res, 93, exit);
    break;


  /* MPLS / PWE */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);    
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_TT:
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_CFM_ETHER_TYPE_NOF_BITS, &isem_key->key_info.oam_stat.cfm_eth_type);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_VT:
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_NOF_BITS, &isem_key->key_info.oam_stat.opaque);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_NOF_BITS, &isem_key->key_info.oam_stat.pph_type);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_OAM_STAT_VT:
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_LSB, ARAD_PP_ISEM_ACCESS_KEY_OPAQUE_NOF_BITS, &isem_key->key_info.oam_stat.opaque);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PPH_TYPE_NOF_BITS, &isem_key->key_info.oam_stat.pph_type);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISA:
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_NOF_BITS, &isem_key->key_info.oam_stat.bfd_format);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_BFD_STAT_TT_ISB:
	  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_LSB, ARAD_PP_ISEM_ACCESS_KEY_BFD_FORMAT_NOF_BITS, &isem_key->key_info.oam_stat.bfd_format);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
  break;

  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.in_rif);
    SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
    SOC_SAND_CHECK_FUNC_RESULT(res, 39, exit);    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 140, exit);    

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS, &isem_key->key_info.mpls.label2);
    SOC_SAND_CHECK_FUNC_RESULT(res, 142, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
      SOC_SAND_CHECK_FUNC_RESULT(res, 143, exit);    
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:   

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS, mac_U32);
    SOC_SAND_CHECK_FUNC_RESULT(res, 145, exit);    

    /* The function soc_sand_pp_mac_address_long_to_struct reads from indecies 0 and 1 of the first parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_long_to_struct(
          mac_U32,
          &isem_key->key_info.spoof_v4.smac
        );
    SOC_SAND_CHECK_FUNC_RESULT(res, 146, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS, &isem_key->key_info.spoof_v4.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 147, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS, mac_U32);
    SOC_SAND_CHECK_FUNC_RESULT(res, 245, exit);    

    res = soc_sand_pp_mac_address_long_to_struct(
          mac_U32,
          &isem_key->key_info.spoof_v6.smac
        );
    SOC_SAND_CHECK_FUNC_RESULT(res, 246, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS, isem_key->key_info.spoof_v6.sip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 153, exit);

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    isem_key->key_info.trill.flags = 0x0;
    tmp = 0;

    if (tables_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS, &tmp);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  
      if (tmp == ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID) {
          isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_VL; 
      } else {
          isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL; 
      }
      
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS, &isem_key->key_info.trill.high_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit);
      
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL) 
      {
        res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS, &isem_key->key_info.trill.low_vid);
        SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit);
      }
    } else {
      isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS; 
      
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS, &isem_key->key_info.trill.high_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit);
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS, &isem_key->key_info.rpa.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 610, exit);    

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS, &isem_key->key_info.rpa.vrf);
    SOC_SAND_CHECK_FUNC_RESULT(res, 620, exit); 
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);                            
                                                                           
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);                            
                                                                           
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 760, exit);        
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_DIP6_TCAM_COMPRESSION:   
    res = soc_sand_bitstream_get_any_field(buffer, 0, 72, ip6_address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 770, exit);
    res = soc_sand_bitstream_set_any_field(ip6_address, 56, 72, isem_key->key_info.ip6_compression.ip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 771, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_SIP6_TCAM_COMPRESSION:
    res = soc_sand_bitstream_get_any_field(buffer, 0, 64, ip6_address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 780, exit);
    res = soc_sand_bitstream_set_any_field(ip6_address, 64, 64, isem_key->key_info.spoof_v6.sip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 781, exit);

    res = soc_sand_bitstream_get_any_field(buffer, 64, 8, &isem_key->key_info.spoof_v6.vsi);
    SOC_SAND_CHECK_FUNC_RESULT(res, 783, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST2_TCAM:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_AC_TST2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SRC_PORT_DA_DB_TCAM:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VSI_DA_DB_VRRP_TCAM:
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VLAN_DOMAIN_MPLS_L1:
    res = soc_sand_bitstream_get_any_field(buffer, 0, 8, &(isem_key->key_info.mpls.vlan_domain));  
    SOC_SAND_CHECK_FUNC_RESULT(res, 784, exit);
    res = soc_sand_bitstream_get_any_field(buffer, 8, 20, &(isem_key->key_info.mpls.label));  
    SOC_SAND_CHECK_FUNC_RESULT(res, 785, exit);
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit); 
    break;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_key_from_buffer()", 0, 0);
}

uint32
  arad_pp_isem_access_print_vt_program_look_info(int unit, int prog_id)
{

  int program_id;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA ihp_vtt1st_key_construction_tbl_data;
  uint32 res;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if (vt_programs[unit][prog_id].prog_used == -1) {        
    goto exit;
  }
  program_id = vt_programs[unit][prog_id].prog_used;

  soc_sand_os_memset(&ihp_vtt1st_key_construction_tbl_data, 0x0, sizeof(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA));

  ihp_vtt1st_key_construction_tbl_data.dbal = 1;
  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(unit, program_id, &ihp_vtt1st_key_construction_tbl_data );  
  SOC_SAND_CHECK_FUNC_RESULT(res, 780, exit);

  LOG_CLI((BSL_META("  LOOKUPS:")));

  if(ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable == 1) {
      LOG_CLI((BSL_META("\tSEM A enabled ")));
  }else{
      LOG_CLI((BSL_META("\tSEM A disabled")));
  }

  if(ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable == 1) {
      LOG_CLI((BSL_META("\tSEM B enabled ")));
  }else{
      LOG_CLI((BSL_META("\tSEM B disabled")));
  }
  if(ihp_vtt1st_key_construction_tbl_data.tcam_db_profile != 0x3F) {
      LOG_CLI((BSL_META("\tTCAM enabled %d"), ihp_vtt1st_key_construction_tbl_data.tcam_db_profile));
  }else{
      LOG_CLI((BSL_META("\tTCAM disabled")));
  }

  LOG_CLI((BSL_META("\n\n")));

exit:

  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_print_vt_program_look_info()", prog_id, 0);
}


uint32
  arad_pp_isem_access_print_tt_program_look_info(int unit, int prog_id)
{

  int program_id;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA  ihp_vtt2nd_key_construction_tbl_data;
  uint32 res;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if (tt_programs[unit][prog_id].prog_used == -1) {        
    goto exit;
  }
  program_id = tt_programs[unit][prog_id].prog_used;

  soc_sand_os_memset(&ihp_vtt2nd_key_construction_tbl_data, 0x0, sizeof(ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA));

  ihp_vtt2nd_key_construction_tbl_data.dbal = 1;
  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(unit, program_id, &ihp_vtt2nd_key_construction_tbl_data);  
  SOC_SAND_CHECK_FUNC_RESULT(res, 780, exit);

  LOG_CLI((BSL_META("  LOOKUPS:")));

  if(ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable == 1) {
      LOG_CLI((BSL_META("\tSEM A enabled ")));
  }else{
      LOG_CLI((BSL_META("\tSEM A disabled")));
  }

  if(ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable == 1) {
      LOG_CLI((BSL_META("\tSEM B enabled ")));
  }else{
      LOG_CLI((BSL_META("\tSEM B disabled")));
  }
  if(ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile != 0x3F) {
      LOG_CLI((BSL_META("\tTCAM enabled %d"), ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile));
  }else{
      LOG_CLI((BSL_META("\tTCAM disabled")));
  }

  LOG_CLI((BSL_META("\n\n")));

exit:

  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_print_tt_program_look_info()", prog_id, 0);
}


char*
  arad_pp_isem_access_print_vt_program_data(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 program_id,
    SOC_SAND_IN  uint32                                 to_print
  )
{
    char* prog_name;

    switch(program_id)
    {
    case PROG_VT_TM_PROG:
        prog_name = "PROG_VT_TM_PROG";
        break;
    case PROG_VT_VDxINITIALVID_L1:
        prog_name = "PROG_VT_VDxINITIALVID_L1";
        break;
    case PROG_VT_VDxOUTERVID_L1:
        prog_name = "PROG_VT_VDxOUTERVID_L1";
        break;
    case PROG_VT_VD_OUTER_INNER:
        prog_name = "PROG_VT_VD_OUTER_INNER";
        break;
    case PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER:
        prog_name = "PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER";
        break;
    case PROG_VT_VDxINITIALVID_L1_L2ELI:
        prog_name = "PROG_VT_VDxINITIALVID_L1_L2ELI";
        break;
    case PROG_VT_VDxOUTERVID_L1_L2ELI:
        prog_name = "PROG_VT_VDxOUTERVID_L1_L2ELI";
        break;
    case PROG_VT_VD_INITIALVID_TRILL:
        prog_name = "PROG_VT_VD_INITIALVID_TRILL";
        break;
    case PROG_VT_VD_DESIGNATED_VID_TRILL:
        prog_name = "PROG_VT_VD_DESIGNATED_VID_TRILL";
        break;
    case PROG_VT_VD_OUTER_TRILL:
        prog_name = "PROG_VT_VD_OUTER_TRILL";
        break;
    case PROG_VT_VD_OUTER_INNER_TRILL:
        prog_name = "PROG_VT_VD_OUTER_INNER_TRILL";
        break;
    case PROG_VT_VD_INITIALVID_L1FRR:
        prog_name = "PROG_VT_VD_INITIALVID_L1FRR";
        break;
    case PROG_VT_VD_OUTERVID_L1FRR:
        prog_name = "PROG_VT_VD_OUTERVID_L1FRR";
        break;
    case PROG_VT_VD_OUTER_OR_VD_OUTER_PCP:
        prog_name = "PROG_VT_VD_OUTER_OR_VD_OUTER_PCP";
        break;
    case PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP:
        prog_name = "PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP";
        break;
    case PROG_VT_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER:
        prog_name = "PROG_VT_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER";
        break;
    case PROG_VT_VD_INITIALVID_OR_VD_INITIALVID:
        prog_name = "PROG_VT_VD_INITIALVID_OR_VD_INITIALVID";
        break;
    case PROG_VT_VD_OUTER_OR_VD_OUTER:
        prog_name = "PROG_VT_VD_OUTER_OR_VD_OUTER";
        break;
    case PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER:
        prog_name = "PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER";
        break;
    case PROG_VT_INDX_VD_INITIALVID_L1:
        prog_name = "PROG_VT_INDX_VD_INITIALVID_L1";
        break;
    case PROG_VT_INDX_VD_OUTERVID_L1:
        prog_name = "PROG_VT_INDX_VD_OUTERVID_L1";
        break;
    case PROG_VT_INDX_MPLS_PORT_L1:
        prog_name = "PROG_VT_INDX_MPLS_PORT_L1";
        break;            
    case PROG_VT_INDX_VD_INITIALVID_FRR_L1:
        prog_name = "PROG_VT_INDX_VD_INITIALVID_FRR_L1";
        break;
    case PROG_VT_INDX_VD_OUTERVID_FRR_L1:
        prog_name = "PROG_VT_INDX_VD_OUTERVID_FRR_L1";
        break;                
    case PROG_VT_INDX_VD_INITIALVID_L3:
        prog_name = "PROG_VT_INDX_VD_INITIALVID_L3";
        break;        
    case PROG_VT_INDX_VD_OUTERVID_L3:
        prog_name = "PROG_VT_INDX_VD_OUTERVID_L3";
        break;                
    case PROG_VT_PON_UNTAGGED:
        prog_name = "PROG_VT_PON_UNTAGGED";
        break;        
    case PROG_VT_PON_ONE_TAG:
        prog_name = "PROG_VT_PON_ONE_TAG";
        break;        
    case PROG_VT_PON_TWO_TAGS:
        prog_name = "PROG_VT_PON_TWO_TAGS";
        break;        
    case PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID:
        prog_name = "PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID";
        break;        
    case PROG_VT_IPV4_INITIAL_VID:
        prog_name = "PROG_VT_IPV4_INITIAL_VID";
        break;        
    case PROG_VT_IPV4_OUTER_VID:
        prog_name = "PROG_VT_IPV4_OUTER_VID";
        break;
     case PROG_VT_IPV4_PORT:
        prog_name = "PROG_VT_IPV4_PORT";
        break;     
    case PROG_VT_EVB_S_TAG:
        prog_name = "PROG_VT_EVB_S_TAG";
        break;     
    case PROG_VT_EVB_UN_C_TAG:
        prog_name = "PROG_VT_EVB_UN_C_TAG";
        break;
    case PROG_VT_EXTENDER_PE:
        prog_name = "PROG_VT_EXTENDER_PE";
        break;
    case PROG_VT_EXTENDER_PE_UT:
        prog_name = "PROG_VT_EXTENDER_PE_UT";
        break;
    case PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID:
        prog_name = "PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID";
        break;        
    case PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q:
        prog_name = "PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q";
        break;
    case PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q:
        prog_name = "PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q";
        break;
    case PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE:
        prog_name = "PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE";
        break;
    case PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE:
        prog_name = "PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE";
        break;
    case PROG_VT_VD_INITIALVID:
        prog_name = "PROG_VT_VD_INITIALVID";
        break;
    case PROG_VT_VD_INITIALVID_VRRP:
        prog_name = "PROG_VT_VD_INITIALVID_VRRP";
        break;
    case PROG_VT_VD_DOUBLE_TAG:
        prog_name = "PROG_VT_VD_DOUBLE_TAG";
        break;
    case PROG_VT_VD_DOUBLE_TAG_VRRP:
        prog_name = "PROG_VT_VD_DOUBLE_TAG_VRRP";
        break;       
    case PROG_VT_VD_SINGLE_TAG:
        prog_name = "PROG_VT_VD_SINGLE_TAG";
        break;
    case PROG_VT_VD_SINGLE_TAG_VRRP:
        prog_name = "PROG_VT_VD_SINGLE_TAG_VRRP";
        break;  
    case PROG_VT_VD_INITIALVID_EXPLICIT_NULL:
        prog_name = "PROG_VT_VD_INITIALVID_EXPLICIT_NULL";
        break;
    case PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL:
        prog_name = "PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL";
        break;       
    case PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL:
        prog_name = "PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL";
        break;
    case PROG_VT_OUTER_INNER_PCP_1_TST2:
        prog_name = "PROG_VT_OUTER_INNER_PCP_1_TST2";
        break;
    case PROG_VT_OUTER_INNER_PCP_2_TST2:
        prog_name = "PROG_VT_OUTER_INNER_PCP_2_TST2";
        break;
    case PROG_VT_OUTER_PCP_1_TST2:
        prog_name = "PROG_VT_OUTER_PCP_1_TST2";
        break;
    case PROG_VT_OUTER_PCP_2_TST2:
        prog_name = "PROG_VT_OUTER_PCP_2_TST2";
        break;
    case PROG_VT_OUTER_INNER_1_TST2:
        prog_name = "PROG_VT_OUTER_INNER_1_TST2";
        break;
    case PROG_VT_OUTER_INNER_2_TST2:
        prog_name = "PROG_VT_OUTER_INNER_2_TST2";
        break;
    case PROG_VT_OUTER_1_TST2:
        prog_name = "PROG_VT_OUTER_1_TST2";
        break;
    case PROG_VT_OUTER_2_TST2:
        prog_name = "PROG_VT_OUTER_2_TST2";
        break;
    case PROG_VT_UNTAGGED_TST2:
        prog_name = "PROG_VT_UNTAGGED_TST2";
        break;
    case PROG_VT_TEST2:
        prog_name = "PROG_VT_TEST2";
        break;
    case PROG_VT_CUSTOM_PP_PORT_TUNNEL:
        prog_name = "PROG_VT_CUSTOM_PP_PORT_TUNNEL";
        break;
    case PROG_VT_VD_INITIALVID_VLAN_DOMAIN_L1:
        prog_name = "PROG_VT_VD_INITIALVID_VLAN_DOMAIN_L1";
        break;
    default:
        prog_name = "Unknown program";
    }

    if (to_print)
    {
        if (vt_programs[unit][program_id].prog_used != -1) {        
            LOG_CLI((BSL_META_U(unit,
                                "Program %s ID: %d\n"), prog_name,vt_programs[unit][program_id].prog_used));          
        }
    }

    return prog_name;
}

char*
  arad_pp_isem_access_print_tt_program_data(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 program_id,
    SOC_SAND_IN  uint32                                 to_print

  )
{
    char* prog_name;

    switch(program_id)
    {
    case PROG_TT_TM_PROG:
        prog_name = "PROG_TT_TM_PROG";
        break;
	case PROG_TT_OAM_STAT_PROG:
        prog_name = "PROG_TT_OAM_STAT_PROG";
        break;
	case PROG_TT_BFD_STAT_PROG:
        prog_name = "PROG_TT_BFD_STAT_PROG";
        break;
    case PROG_TT_L2:
        prog_name = "PROG_TT_L2";
        break;
    case PROG_TT_L3:
        prog_name = "PROG_TT_L3";
        break;
    case PROG_TT_L2_L3ELI:
        prog_name = "PROG_TT_L2_L3ELI";
        break;
    case PROG_TT_ARP_2ND_PROG:
        prog_name = "PROG_TT_ARP_2ND_PROG";
        break;
    case PROG_TT_BRIDGE_STAR_2ND_PROG:
        prog_name = "PROG_TT_BRIDGE_STAR_2ND_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_PORT_VXLAN_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_PORT_VXLAN_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_PORT_L2_GRE_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_PORT_L2_GRE_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG";
        break;
    case PROG_TT_IP_ROUTER_2ND_PROG:
        prog_name = "PROG_TT_IP_ROUTER_2ND_PROG";
        break;
    case PROG_TT_IPV6_ROUTER_2ND_PROG:
        prog_name = "PROG_TT_IPV6_ROUTER_2ND_PROG";
        break;
    case PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG:
        prog_name = "PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG";
        break;
    case PROG_TT_UNKNOWN_L3_PROG:
        prog_name = "PROG_TT_UNKNOWN_L3_PROG";
        break;
    case PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG:
        prog_name = "PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG";
        break;
    case PROG_TT_MAC_IN_MAC_MC_PROG:
        prog_name = "PROG_TT_MAC_IN_MAC_MC_PROG";
        break;
    case PROG_TT_FC_WITH_VFT_PROG:
        prog_name = "PROG_TT_FC_WITH_VFT_PROG";
        break;
    case PROG_TT_FC_PROG:
        prog_name = "PROG_TT_FC_PROG";
        break;
    case PROG_TT_INDX_L1_L2_INRIF:
        prog_name = "PROG_TT_INDX_L1_L2_INRIF";
        break;
    case PROG_TT_INDX_L1_L2_L3ELI_INRIF:
        prog_name = "PROG_TT_INDX_L1_L2_L3ELI_INRIF";
        break;
    case PROG_TT_INDX_L1_L2ELI_INRIF:
        prog_name = "PROG_TT_INDX_L1_L2ELI_INRIF";
        break;
    case PROG_TT_INDX_L3_L2:
        prog_name = "PROG_TT_INDX_L3_L2";
        break;
    case PROG_TT_INDX_MPLS_PORT_L3_L2:
        prog_name = "PROG_TT_INDX_MPLS_PORT_L3_L2";
        break;
    case PROG_TT_INDX_L3_L4:
        prog_name = "PROG_TT_INDX_L3_L4";
        break;
    case PROG_TT_INDX_L2_L3ELI:
        prog_name = "PROG_TT_INDX_L2_L3ELI";
        break;
    case PROG_TT_TRILL_2ND_PROG:
        prog_name = "PROG_TT_TRILL_2ND_PROG";
        break;
    case PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH:
        prog_name = "PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH";
        break;
    case PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG:
        prog_name = "PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG";
        break;   
    case PROG_TT_INDX_L1_L1:
        prog_name = "PROG_TT_INDX_L1_L1";
        break;
    case PROG_TT_INDX_L1_L2:
        prog_name = "PROG_TT_INDX_L1_L2";
        break;
    case PROG_TT_INDX_L1_L1_GAL:
        prog_name = "PROG_TT_INDX_L1_L1_GAL";
        break;
    case PROG_TT_INDX_L1_L2_GAL:
        prog_name = "PROG_TT_INDX_L1_L2_GAL";
        break;
    case PROG_TT_INDX_L2_L2:
        prog_name = "PROG_TT_INDX_L2_L2";
        break;
    case PROG_TT_INDX_L2_L3_GAL:
        prog_name = "PROG_TT_INDX_L2_L3_GAL";
        break;
    case PROG_TT_MLDP_AFTER_RECYCLE:
        prog_name = "PROG_TT_MLDP_AFTER_RECYCLE";
        break;
    case PROG_TT_DIP6_COMPRESSION_PROG:
      prog_name = "PROG_TT_DIP6_COMPRESSION_PROG";
      break;
    case PROG_TT_EXTENDER_UNTAG_CHECK_IP_MC:
        prog_name = "PROG_TT_EXTENDER_UNTAG_CHECK_IP_MC";
        break;
    case PROG_TT_EXTENDER_UNTAG_CHECK_IP_UC:
        prog_name = "PROG_TT_EXTENDER_UNTAG_CHECK_IP_UC";
        break;
    case PROG_TT_EXTENDER_UNTAG_CHECK:
        prog_name = "PROG_TT_EXTENDER_UNTAG_CHECK";
        break;
    case PROG_TT_IPV4_ROUTER_L3_GRE_PORT_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_L3_GRE_PORT_PROG";
        break;
    case PROG_TT_IPV4_ROUTER_DIP_SIP_VRF_PROG:
        prog_name = "PROG_TT_IPV4_ROUTER_DIP_SIP_VRF_PROG";
        break; 
    case PROG_TT_IPV4_FOR_EXPLICIT_NULL_PROG:
        prog_name = "PROG_TT_IPV4_FOR_EXPLICIT_NULL_PROG";
        break;
    case PROG_TT_TUNNEL_FOR_TWO_EXPLICIT_NULL_PROG:
        prog_name = "PROG_TT_TUNNEL_FOR_TWO_EXPLICIT_NULL_PROG";
        break;
    case PROG_TT_TUNNEL_FOR_THREE_EXPLICIT_NULL_PROG:
        prog_name = "PROG_TT_TUNNEL_FOR_THREE_EXPLICIT_NULL_PROG";
        break;
    case PROG_TT_EXTENDER_IP_MC_PROG:
        prog_name = "PROG_TT_EXTENDER_IP_MC_PROG";
        break;
    case PROG_TT_EXTENDER_IP_UC_PROG:
        prog_name = "PROG_TT_EXTENDER_IP_UC_PROG";
        break;
    case PROG_TT_EXTENDER_PROG:
        prog_name = "PROG_TT_EXTENDER_PROG";
        break;
    case PROG_TT_INDX_L1_GAL_ONLY:
        prog_name = "PROG_TT_INDX_L1_GAL_ONLY";
        break;
    case PROG_TT_INDX_L2_GAL_ONLY:
        prog_name = "PROG_TT_INDX_L2_GAL_ONLY";
        break;
    case PROG_TT_VLAN_DOMAIN_L1:
        prog_name = "PROG_TT_VLAN_DOMAIN_L1";
        break;

    default:
        prog_name = "Unknown program";
    }
    
    if (to_print)
    {
        if (tt_programs[unit][program_id].prog_used != -1) {
            LOG_CLI((BSL_META_U(unit,
                                "Program %s ID: %d\n"), prog_name,tt_programs[unit][program_id].prog_used));                       
        }
    }
    return prog_name;
}


void
  arad_pp_isem_access_print_all_programs_data(
    SOC_SAND_IN  int                                 unit
  )
{
    int program_id;

    LOG_CLI((BSL_META_U(unit,"\nVT programs:\n")));
    LOG_CLI((BSL_META_U(unit,"------------\n\n")));
    for (program_id = 0; program_id < PROG_VT_NOF_PROGS; program_id++) {
        arad_pp_isem_access_print_vt_program_data(unit, program_id, 1);
        arad_pp_isem_access_print_vt_program_look_info(unit, program_id);
    }
    LOG_CLI((BSL_META_U(unit,"\nTT programs:\n")));
    LOG_CLI((BSL_META_U(unit,"------------\n\n")));
    for (program_id = 0; program_id < PROG_TT_NOF_PROGS; program_id++) {
        arad_pp_isem_access_print_tt_program_data(unit, program_id, 1);
        arad_pp_isem_access_print_tt_program_look_info(unit, program_id);
    }
}



void
  arad_pp_isem_access_program_sel_line_to_program_id(
    SOC_SAND_IN   int                 unit,
    SOC_SAND_IN   int                 line,    
    SOC_SAND_IN   int                 is_vt,/* if 1 give vt program if 0 give tt program*/
    SOC_SAND_OUT  uint8               *prog_id
  ) 
{

    uint8 found = FALSE;
    int program_id;
    
    if (is_vt)
    {
        for (program_id = 0; program_id < PROG_VT_NOF_PROGS; program_id++){
            if (vt_programs[unit][program_id].prog_used == line)
            {
                *prog_id = program_id;
                found = TRUE;
                break;
            }
        }
    } else {

        for (program_id = 0; program_id < PROG_TT_NOF_PROGS; program_id++){
            if (tt_programs[unit][program_id].prog_used == line)
            {
                found = TRUE;
                *prog_id = program_id;
                break;
            }
        }
    }

    if (!found){
        *prog_id = -1;
    }
}
/*********************************************************************
*     Dump last VT&TT program invoked.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
uint32
  arad_pp_isem_access_print_last_vtt_program_data(
    SOC_SAND_IN   int                 unit,
    SOC_SAND_IN   int                 core_id,
    SOC_SAND_IN   int                 to_print,
    SOC_SAND_OUT  int                 *prog_id_vt,
    SOC_SAND_OUT  int                 *prog_id_tt,
    SOC_SAND_OUT  int                 *num_of_progs_vt,
    SOC_SAND_OUT  int                 *num_of_progs_tt
  )
{
    uint8 found = FALSE;
    uint32 fld_val, 
        vt_progs_bmp,
        tt_progs_bmp,
        pgm_ndx,
        program_id,
        res = SOC_SAND_OK;
    uint64 reg_val64;
    

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

    /* 
     * 1. Read and print all invoked programs
     * 2. Clear the register
     */

    *prog_id_vt = -1;
    *prog_id_tt = -1;
	(*num_of_progs_vt) = 0;
	(*num_of_progs_tt) = 0;

    SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, READ_IHP_VTT_PROGRAM_ENCOUNTEREDr(unit, core_id ,&reg_val64));
    fld_val = soc_reg64_field32_get(unit, IHP_VTT_PROGRAM_ENCOUNTEREDr, reg_val64, SOC_IS_JERICHO(unit) ? VLAN_TRANSLATION_PROGRAM_ENCOUNTEREDf : VTT_PROGRAM_FIRST_LOOKUPf);
    vt_progs_bmp = fld_val;
    fld_val = soc_reg64_field32_get(unit, IHP_VTT_PROGRAM_ENCOUNTEREDr, reg_val64, SOC_IS_JERICHO(unit) ? TUNNEL_TERMINATION_PROGRAM_ENCOUNTEREDf : VTT_PROGRAM_SECOND_LOOKUPf);
    tt_progs_bmp = fld_val;

    if (to_print){
        LOG_CLI((BSL_META_U(unit,"Last invoked VT program:\n")));
    }
    for (pgm_ndx = 0; pgm_ndx < SOC_DPP_DEFS_GET(unit, nof_vtt_programs); pgm_ndx++)
    {
        if (SOC_SAND_GET_BIT(vt_progs_bmp, pgm_ndx))
        {
            /* Program found */
            found = TRUE;            
            for (program_id = 0; program_id < PROG_VT_NOF_PROGS; program_id++)
            {
                if (vt_programs[unit][program_id].prog_used == pgm_ndx)
                {
                    *prog_id_vt = pgm_ndx;
                    (*num_of_progs_vt)++;
                    arad_pp_isem_access_print_vt_program_data(unit, program_id, to_print);
                    break;
                }
            }
        }
    }

    if (!found)
    {
        if(to_print){
            LOG_CLI((BSL_META_U(unit,"No program invoked\n")));
        }
    }

    found = FALSE;
    if (to_print){
        LOG_CLI((BSL_META_U(unit,"Last invoked TT program:\n")));
    }

    for (pgm_ndx = 0; pgm_ndx < SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines); pgm_ndx++)
    {
        if (SOC_SAND_GET_BIT(tt_progs_bmp, pgm_ndx))
        {
            /* Program found */
            found = TRUE;
            for (program_id = 0; program_id < PROG_TT_NOF_PROGS; program_id++)
            {
                if (tt_programs[unit][program_id].prog_used == pgm_ndx)
                {
                    *prog_id_tt = pgm_ndx;
                    (*num_of_progs_tt)++;
                    arad_pp_isem_access_print_tt_program_data(unit, program_id, to_print);
                    break;
                }
            }
        }
    }


    if (!found)
    {
        if (to_print){
            LOG_CLI((BSL_META_U(unit,"No program invoked\n")));
        }
    }

    /* Set all bits as ones to clear it. */
    COMPILER_64_ALLONES(reg_val64);
    SOC_SAND_SOC_IF_ERROR_RETURN(res, 20, exit, WRITE_IHP_VTT_PROGRAM_ENCOUNTEREDr(unit,core_id, reg_val64));


exit:
    SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_print_last_vtt_program_data()", 0, 0);
}

/* } */
#include <soc/dpp/SAND/Utils/sand_footer.h>


#endif /* of #if defined(BCM_88650_A0) */
