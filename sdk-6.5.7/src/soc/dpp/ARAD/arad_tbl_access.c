#include <shared/bsl.h>

#include <soc/mcm/memregs.h>
#if defined(BCM_88650_A0)
/*
 * $Id: arad_tbl_access.c,v 1.186 Broadcom SDK $
 *
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 */


#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_SOC_MEM

/*************
 * INCLUDES  *
 *************/
/* { */
#include <soc/dcmn/error.h>
#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/mem.h>
#include <soc/error.h>

#include <bcm_int/dpp/alloc_mngr.h>
#include <soc/dpp/ARAD/arad_tbl_access.h>
#include <soc/dpp/ARAD/arad_chip_tbls.h>
#include <soc/dpp/ARAD/arad_reg_access.h>
#include <soc/dpp/ARAD/arad_api_mgmt.h>
#include <soc/dpp/ARAD/arad_general.h>
#include <soc/dpp/ARAD/arad_pmf_low_level_fem_tag.h>
#include <soc/dpp/ARAD/arad_ports.h>
#include <soc/dpp/ARAD/arad_cnm.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_sw_db.h>
#include <soc/dpp/SAND/Utils/sand_os_interface.h>
#include <soc/dpp/drv.h> /* for assert() */
#include <soc/dpp/mbcm.h> 
#include <soc/dcmn/dcmn_mem.h> 
#include <soc/dcmn/utils.h>
#include <soc/hwstate/hw_log.h>
#include <shared/swstate/access/sw_state_access.h>

#if defined(BCM_88675_A0)
#include <soc/dpp/JER/jer_sbusdma_desc.h>
#endif /* defined(BCM_88675_A0) */

/* } */

/*************
 * DEFINES   *
 *************/
/* { */

#define ARAD_WRED_NOF_DROP_PRECEDENCE   (ARAD_NOF_DROP_PRECEDENCE)


#define ARAD_QDR_QDR_DLL_MEM_TBL_ENTRY_SIZE 1


#define ARAD_IHB_TCAM_HIT_INDICATION_NOF_TCAM_ENTRIES_PER_LINE  (8)
#define ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_BIT(line)    (line % ARAD_IHB_TCAM_HIT_INDICATION_NOF_TCAM_ENTRIES_PER_LINE)
#define ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_LINE(line)   (line / ARAD_IHB_TCAM_HIT_INDICATION_NOF_TCAM_ENTRIES_PER_LINE)

#define ARAD_IRE_NIF_CTXT_MAP_TBL_ENTRY_SIZE                                               1
#define ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_ENTRY_SIZE                                   7
#define ARAD_IRE_RCY_CTXT_MAP_TBL_ENTRY_SIZE                                               1
#define ARAD_IRE_CPU_CTXT_MAP_TBL_ENTRY_SIZE                                               1
#define ARAD_IRE_TDM_CONFIG_TBL_ENTRY_SIZE                                                 5
#define ARAD_IDR_CONTEXT_MRU_TBL_ENTRY_SIZE                                                2
#define ARAD_IRR_SNOOP_MIRROR_TABLE0_TBL_ENTRY_SIZE                                        2
#define ARAD_IRR_SNOOP_MIRROR_TABLE1_TBL_ENTRY_SIZE                                        4
#define ARAD_IRR_DESTINATION_TABLE_TBL_ENTRY_SIZE                                          1
#define ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE                                           1
#define ARAD_IRR_LAG_MAPPING_TBL_ENTRY_SIZE                                                1
#define ARAD_IRR_SMOOTH_DIVISION_TBL_ENTRY_SIZE                                            1
#define ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_ENTRY_SIZE                                      1
#define ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_ENTRY_SIZE                                        1
#define ARAD_IRR_STACK_FEC_RESOLVE_TBL_ENTRY_SIZE                                          1
#define ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_ENTRY_SIZE                                    2
#define ARAD_QDR_QDR_DLL_MEM_TBL_ENTRY_SIZE                                                1
#define ARAD_IQM_STATIC_TBL_ENTRY_SIZE                                                     1
#define ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_ENTRY_SIZE                              1
#define ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_ENTRY_SIZE                                      1
#define ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE                          4
#define ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_ENTRY_SIZE                          1
#define ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_ENTRY_SIZE                          1
#define ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_ENTRY_SIZE                          1
#define ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_ENTRY_SIZE                          1
#define ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_A_TBL_ENTRY_SIZE                         3
#define ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE                                1
#define ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_ENTRY_SIZE                         1
#define ARAD_IQM_SYSTEM_RED_TBL_ENTRY_SIZE                                                 6
#define ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_ENTRY_SIZE                                       5
#define ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE                          2
#define ARAD_IPS_DESTINATION_DEVICE_AND_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE                   2
#define ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_ENTRY_SIZE                                       1
#define ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_ENTRY_SIZE                                    1
#define ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_ENTRY_SIZE                                  1
#define ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_ENTRY_SIZE                                  2
#define ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE                          2
#define ARAD_IPS_SLOW_FACTOR_THRESHOLDS_TABLE_TBL_ENTRY_SIZE                               6
#define ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE                      2
#define ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_ENTRY_SIZE                           2
#define ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_ENTRY_SIZE                           1
#define ARAD_EGQ_CCM_TBL_ENTRY_SIZE                                                        1
#define ARAD_EGQ_PMC_TBL_ENTRY_SIZE                                                        1
#define ARAD_EGQ_DWM_TBL_ENTRY_SIZE                                                        1
#define ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_ENTRY_SIZE                                           1
#define ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_ENTRY_SIZE                                           1
#define ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE                                                  2
#define ARAD_IHB_HEADER_PROFILE_TBL_ENTRY_SIZE                                             1
#define ARAD_IHB_FEM0_4B_1ST_PASS_MAP_INDEX_TABLE_TBL_ENTRY_SIZE                           1
#define ARAD_IHB_FEM0_4B_1ST_PASS_MAP_TABLE_TBL_ENTRY_SIZE                                 ((139/32) + 1) /* 19b FEM case*/
#define ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE                                                  2
#define ARAD_IHB_HEADER_PROFILE_TBL_ENTRY_SIZE                                             1
#define ARAD_CFC_CALRX_TBL_ENTRY_SIZE                                                      1
#define ARAD_CFC_OOB_SCH_MAP_TBL_ENTRY_SIZE                                                1
#define ARAD_CFC_CALTX_TBL_ENTRY_SIZE                                                      1
#define ARAD_CFC_CALRX_TBL_ENTRY_SIZE                                                1
#define ARAD_CFC_OOB_SCH_MAP_TBL_ENTRY_SIZE                                              1
#define ARAD_CFC_OOB_SCH_MAP_TBL_ENTRY_SIZE                                              1
#define ARAD_CFC_CALTX_TBL_ENTRY_SIZE                                                1
#define ARAD_SCH_DRM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_DSM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_FDMS_TBL_ENTRY_SIZE                                                       2
#define ARAD_SCH_SHDS_TBL_ENTRY_SIZE                                                       2
#define ARAD_SCH_SEM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_FSF_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_FGM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_SHC_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_SCC_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_SCT_TBL_ENTRY_SIZE                                                        2
#define ARAD_SCH_FQM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_FFM_TBL_ENTRY_SIZE                                                        1
#define ARAD_SCH_SCHEDULER_INIT_TBL_ENTRY_SIZE                                             1
#define ARAD_SCH_FORCE_STATUS_MESSAGE_TBL_ENTRY_SIZE                                       1


#define ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_ENTRY_SIZE                              ( 1)
#define ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_ENTRY_SIZE                                   ( 1)
#define ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE                           ( 1)
#define ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE                            ( 1)
#define ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE                           ( 4)
#define ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE                        ( 4)
#define ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE                 ( 1)
#define ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE                  ( 1)
#define ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE                 ( 1)
#define ARAD_PP_IHP_PARSER_PROGRAM_TBL_ENTRY_SIZE                                              ( 1)
#define ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE                                        ( 5)
#define ARAD_PP_IHP_SEM_RESULT_TABLE_TBL_ENTRY_SIZE                                            ( 2)
#define ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE                                    ( 5)
#define ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE                                    ( 6)
#define ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE                                    ( 5)
#define ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE                                    ( 6)
#define ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_ENTRY_SIZE                                                ( 2)
#define ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_ENTRY_SIZE                                   ( 1)
#define ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_ENTRY_SIZE                                   ( 1)
#define ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_ENTRY_SIZE                                          ( 1)
#define ARAD_PP_IHB_PATH_SELECT_TBL_ENTRY_SIZE                                                 ( 1)
#define ARAD_PP_IHB_TCAM_ACTION_TBL_ENTRY_SIZE                                                 ( 1)
#define ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE                               ( 1)
#define ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE                                              ( 9)
#define ARAD_PP_EPNI_TX_TAG_TABLE_TBL_ENTRY_SIZE                                               ( 9)
#define ARAD_PP_EPNI_PCP_DEI_MAP_TBL_ENTRY_SIZE                                                ( 2)
#define ARAD_PP_EPNI_DP_MAP_TBL_ENTRY_SIZE                                                     ( 1)
#define ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE                                            ( 2)
#define ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE                              ( 1)
#define ARAD_PP_EPNI_ISID_TABLE_TBL_ENTRY_SIZE                                                    ( 1)
#define ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_ENTRY_SIZE                                       ( 1)
#define ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE                             ( 1) 
#define ARAD_PP_IHB_FLP_PROCESS_TBL_ENTRY_SIZE 3
#define ARAD_PP_IHB_LPM_TBL_ENTRY_SIZE 1
#define ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_ENTRY_SIZE 1

#define ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_EN_2_BIT     4
#define ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_LSB  5
#define ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_MSB  7

#define ARAD_IQM_CRDTDIS_DATA_NOF_BITS 0x7


#define ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS  4
#define ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS  7

#define ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE 4

static const int irr_snoop_mirror_table_0_backup = IRR_SNOOP_MIRROR_TABLE_0m;
static const int irr_snoop_mirror_table_1_backup = IRR_SNOOP_MIRROR_TABLE_1m;
#undef IRR_SNOOP_MIRROR_TABLE_0m
#define IRR_SNOOP_MIRROR_TABLE_0m \
    (SOC_IS_JERICHO(unit) ? IRR_SNOOP_MIRROR_DEST_TABLEm : irr_snoop_mirror_table_0_backup)
#undef IRR_SNOOP_MIRROR_TABLE_1m
#define IRR_SNOOP_MIRROR_TABLE_1m \
    (SOC_IS_JERICHO(unit) ? IRR_SNOOP_MIRROR_TM_TABLEm : irr_snoop_mirror_table_1_backup)

#define ARAD_PP_LAG_BY_CHIP(_unit, _name)   \
        ((SOC_IS_QAX(unit)) ?  TAR_##_name##m : IRR_##_name##m)

/* } */

/*************
 *  MACROS   *
 *************/
/* { */

#define SOC_DPP_MEM_FIELD32_GET(field_get,table_name,field_name,exit_num) \
{ \
    res=SOC_E_NONE;\
  if(SOC_E_NONE == res) { \
      field_get = soc_mem_field32_get( \
                      unit, \
                      table_name, \
                      data, \
                      field_name); \
   } \
   SOC_SAND_CHECK_FUNC_RESULT(res, exit_num, exit); \
}

#define SOC_DPP_MEM_FIELD32_SET(field_set,table_name,field_name,exit_num) \
{ \
          res=SOC_E_NONE;\
    if(SOC_E_NONE == res) { \
        soc_mem_field32_set( \
          unit, \
          table_name, \
          data, \
          field_name, \
          field_set ); \
        } \
    SOC_SAND_CHECK_FUNC_RESULT(res, exit_num, exit); \
}


/* for odd entry jump to odd table*/

#define ARAD_PP_TBL_FEC_ARRAY_INDEX(_entry_index) ((_entry_index)%2)
#define ARAD_PP_TBL_FEC_ENTRY_INDEX(_entry_index) ((_entry_index)/2)

#define ARAD_PP_SUPER_FEC_ENTRY_INDEX(fec_ndx) ((fec_ndx)/2)

/* Layout is: 8 banks, each has (FEC_NUM / 8 * 2) lines with 2 fields - data0 and data1. */
#define JERICHO_PP_SUPER_FEC_SZ                                 (2)
#define JERICHO_PP_SUPER_FEC_BANK_SIZE(unit)                    (SOC_DPP_DEFS_GET(unit, nof_fecs) / (SOC_DPP_DEFS_GET(unit, nof_fec_banks) * JERICHO_PP_SUPER_FEC_SZ))
#define JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, _entry_index)    (((_entry_index) / JERICHO_PP_SUPER_FEC_SZ) / JERICHO_PP_SUPER_FEC_BANK_SIZE(unit))
#define JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, _entry_index)    (((_entry_index) / JERICHO_PP_SUPER_FEC_SZ) % JERICHO_PP_SUPER_FEC_BANK_SIZE(unit))
#define JERICHO_PP_FEC_ENTRY_OFFSET(unit, _entry_index)         ((_entry_index) % JERICHO_PP_SUPER_FEC_SZ)

/* Simple TCAM print */
#define ARAD_PP_TBL_ACC_TCAM_DEBUG_PRINT 0
/*#define ARAD_PP_TBL_ACC_TCAM_DEBUG_PRINT 1*/

/* Low-Level TCAM print for all the transaction */
#define ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT 0
/*#define ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT 1*/

#define ARAD_PP_TBL_ACC_TCAM_DEBUG_ACTION_PRINT 0
/*#define ARAD_PP_TBL_ACC_TCAM_DEBUG_ACTION_PRINT 1*/

/* Conversation from entry offset to lif bank id (0-3 in arad, 0-7 in Jericho).
   In Arad it's simply the MSBs, in Jericho it's 2 MSBs + 1 LSB */

#define ARAD_MBMP_SET_DYNAMIC(_mem)      _SHR_PBMP_PORT_ADD(arad_mem_is_dynamic_bmp[_mem/32], _mem%32)
#define ARAD_MBMP_IS_DYNAMIC(_mem)       _SHR_PBMP_MEMBER(arad_mem_is_dynamic_bmp[_mem/32], _mem%32)

/* Conversion FLP instruction valid bitmap from ARAD to Jericho
 * - during Jericho porting, use instruction 0-2 similarly, 
 * and instructions 3-5 as Jericho instructions 4-6. */
#define FLP_INSTR_VALID_BMP_ARAD_TO_JER(inst_valid_bitmap)  \
  (((inst_valid_bitmap & 0x38) << 1) | ((inst_valid_bitmap) & 7))


/* Default mask for TCAM entry field */
#define ARAD_TBL_ACCESS_DEFAULT_TCAM_ENTRY_FIELD_MASK(_unit, _mem, _field) \
           ((1 << soc_mem_field_length((_unit), (_mem), (_field)))-1)

/* Default PRGE Program Selection TCAM entry field mask */
#define ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(_unit, _field) \
           (ARAD_TBL_ACCESS_DEFAULT_TCAM_ENTRY_FIELD_MASK((_unit), EPNI_PRGE_PROGRAM_SELECTION_CAMm, (_field)))
/* } */

/*************
 * TYPE DEFS *
 *************/
/* { */

/* } */

/*************
 * GLOBALS   *
 *************/
/* { */

static _shr_pbmp_t arad_mem_is_dynamic_bmp[NUM_SOC_MEM/32];
static uint32 *_arad_fill_table_with_variable_values_by_caching_buffer[BCM_MAX_NUM_UNITS];
static sal_mutex_t _arad_fill_table_with_variable_values_by_caching_buffer_lock[BCM_MAX_NUM_UNITS];
/* 64KB buffer */
static const uint32 _arad_fill_table_with_variable_values_by_caching_buffer_len = (1 << 16) / sizeof(_arad_fill_table_with_variable_values_by_caching_buffer[0][0]);

static uint8 arad_tbl_super_fec_utilize_desc_dma[SOC_SAND_MAX_DEVICE];

/* } */
soc_mem_t soc_arad_predefined_cached_mem_list[] = {
    CFC_CAT_2_TC_MAP_HCFCm,
    CFC_CAT_2_TC_MAP_NIFm,
    CFC_ILKN_RX_0_CALm,
    CFC_ILKN_RX_1_CALm,
    CFC_ILKN_TX_0_CALm,
    CFC_ILKN_TX_1_CALm,
    CFC_NIF_PFC_MAPm,
    CFC_RCL_VSQ_MAPm,
    CFC_SPI_OOB_RX_0_CALm,
    CFC_SPI_OOB_RX_1_CALm,
    CFC_SPI_OOB_TX_0_CALm,
    CFC_SPI_OOB_TX_1_CALm,
    EGQ_CCMm,
    EGQ_CH_0_SCMm,
    EGQ_CH_1_SCMm,
    EGQ_CH_2_SCMm,
    EGQ_CH_3_SCMm,
    EGQ_CH_4_SCMm,
    EGQ_CH_5_SCMm,
    EGQ_CH_6_SCMm,
    EGQ_CH_7_SCMm,
    EGQ_CH_8_SCMm,
    EGQ_CH_9_SCMm,
    EGQ_DSP_PTR_MAPm,
    EGQ_DWM_8Pm,
    EGQ_DWMm,
    EGQ_HEADER_MAPm,
    EGQ_MAP_OUTLIF_TO_DSPm,
    EGQ_NONCH_SCMm,
    EGQ_PDCT_TABLEm,
    EGQ_PMCm,
    EGQ_PPCTm,
    EGQ_PQST_TABLEm,
    EGQ_QDCT_TABLEm,
    EGQ_QP_PMCm,
    EGQ_QP_SCMm,
    EGQ_QQST_TABLEm,
    EGQ_TCG_PMCm,
    EGQ_TCG_SCMm,
    EGQ_VLAN_TABLEm,
    EGQ_VSI_MEMBERSHIPm,
    EPNI_ACE_TABLEm,
    EPNI_ACE_TO_FHEIm,
    EPNI_ACE_TO_OUT_LIFm,
    EPNI_ACE_TO_OUT_PP_PORTm,
    EPNI_DSCP_EXP_TO_PCP_DEIm,
    EPNI_NATIVE_DSCP_EXP_TO_PCP_DEIm,
    EPNI_DSCP_REMARKm,
    EPNI_EVEC_TABLEm,
    EPNI_NATIVE_EVEC_TABLEm,
    EPNI_EXP_REMARKm,
    EPNI_HEADER_MAPm,
    EPNI_ISID_TABLEm,
    EPNI_MIRROR_PROFILE_TABLEm,
    EPNI_MY_CFM_MAC_TABLEm,
    EPNI_PP_COUNTER_TABLEm,
    EPNI_PRGE_DATAm,
    EPNI_REMARK_IPV4_TO_DSCPm,
    EPNI_REMARK_IPV4_TO_EXPm,
    EPNI_REMARK_IPV6_TO_DSCPm,
    EPNI_REMARK_IPV6_TO_EXPm,
    EPNI_TX_TAG_TABLEm,
    FDT_IN_BAND_MEMm,
    IDR_CONTEXT_MRUm,
    IDR_ETHERNET_METER_CONFIGm,
    IHB_DESTINATION_STATUSm,
    IHB_FEC_ECMPm,
    IHB_FEC_SUPER_ENTRYm,
    IHB_FLP_KEY_CONSTRUCTIONm,
    IHB_FLP_PROCESSm,
    IHB_FWD_ACT_PROFILEm,
    IHB_IN_PORT_KEY_GEN_VARm,
    IHB_IPP_LAG_TO_LAG_RANGEm,
    IHB_LB_PFC_PROFILEm,
    IHB_LPM_2m,
    IHB_LPM_3m,
    IHB_LPM_4m,
    IHB_LPM_5m,
    IHB_LPM_6m,
    IHB_LPMm,
    IHB_OAMAm,
    IHB_OAMBm,
    IHB_PATH_SELECTm,
    IHB_PINFO_COUNTERSm,
    IHB_PINFO_FERm,
    IHB_PINFO_FLPm,
    IHB_PINFO_LBPm,
    IHB_PINFO_PMFm,
    IHB_PMF_FEM_PROGRAMm,
    IHB_PMF_FES_PROGRAMm,
    IHB_PMF_INITIAL_KEY_2ND_PASSm,
    IHB_PMF_PASS_1_KEY_GEN_LSBm,
    IHB_PMF_PASS_1_KEY_GEN_MSBm,
    IHB_PMF_PASS_1_LOOKUPm,
    IHB_PMF_PASS_2_KEY_GEN_LSBm,
    IHB_PMF_PASS_2_KEY_GEN_MSBm,
    IHB_PMF_PASS_2_LOOKUPm,
    IHB_PMF_PROGRAM_COUNTERSm,
    IHB_PMF_PROGRAM_GENERALm,
    IHB_PROGRAM_KEY_GEN_VARm,
    IHB_PTC_INFO_PMFm,
    IHB_PTC_KEY_GEN_VARm,
    IHB_SNOOP_ACTIONm,
    IHB_VRF_CONFIGm,
    IHP_BVD_CFGm,
    IHP_BVD_FID_CLASSm,
    IHP_BVD_TOPOLOGY_IDm,
    IHP_DEFAULT_COUNTER_SOURCEm,
    IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm,
    IHP_IN_RIF_CONFIG_TABLEm,
    IHP_LLR_LLVPm,
    IHP_LL_MIRROR_PROFILEm,
    IHP_PACKET_FORMAT_TABLEm,
    IHP_PINFO_LLRm,
    IHP_PORT_PROTOCOLm,
    IHP_PP_PORT_INFOm,
    IHP_PTC_INFOm,
    IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
    IHP_PTC_PFQ_0_CONFIGm,
    IHP_PTC_SYS_PORT_CONFIGm,
    IHP_PTC_VIRTUAL_PORT_CONFIGm,
    IHP_RECYCLE_COMMANDm,
    IHP_RESERVED_MCm,
    IHP_STP_TABLEm,
    IHP_TC_DP_MAP_TABLEm,
    IHP_TOS_2_COSm,
    IHP_VIRTUAL_PORT_TABLEm,
    IHP_VLAN_EDIT_PCP_DEI_MAPm,
    IHP_VRID_MY_MAC_MAPm,
    IHP_VRID_TO_VRF_MAPm,
    IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATIONm,
    IHP_VSI_HIGH_MY_MACm,
    IHP_VSI_HIGH_PROFILEm,
    IHP_VSI_LOW_CFG_1m,
    IHP_VSI_LOW_CFG_2m,
    IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
    IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
    IHP_VTT_IN_PP_PORT_CONFIGm,
    IHP_VTT_IN_PP_PORT_VLAN_CONFIGm,
    IHP_VTT_LLVPm,
    IHP_VTT_PP_PORT_TT_KEY_VARm,
    IHP_VTT_PP_PORT_VSI_PROFILESm,
    IHP_VTT_PP_PORT_VT_KEY_VARm,
    IHP_VTT_PTC_CONFIGm,
    IPS_CRBALTHm,
    IPS_EMPTYQCRBALm,
    IPS_QPRISELm,
    IPS_QSZTHm,
    IPS_QTYPEm,
    IPT_SNP_MIR_CMD_MAPm,
    IQM_CNREDm,
    IQM_CPDMSm,
    IQM_OCBPRMm,
    IQM_PQDMSm,
    IQM_PQREDm,
    IQM_PQWQm,
    IQM_SCRBUFFTHm,
    IQM_SPRDPRMm,
    IQM_SRCQRNGm,
    IQM_VQFCPR_MAm,
    IQM_VQFCPR_MBm,
    IQM_VQFCPR_MCm,
    IQM_VQFCPR_MDm,
    IQM_VQFCPR_MEm,
    IQM_VQFCPR_MFm,
    IQM_VQPR_MAm,
    IQM_VQPR_MBm,
    IQM_VQPR_MCm,
    IQM_VQPR_MDm,
    IQM_VQPR_MEm,
    IQM_VQPR_MFm,
    IRE_CPU_CTXT_MAPm,
    IRE_NIF_CTXT_MAPm,
    IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
    IRE_RCY_CTXT_MAPm,
    IRE_TDM_CONFIGm,
    IRR_DESTINATION_TABLEm,
    IRR_FLOW_TABLEm,
    IDR_IRDBm,
    IRR_LAG_MAPPINGm,
    IRR_LAG_TO_LAG_RANGEm,
    IRR_SMOOTH_DIVISIONm,
    IRR_STACK_FEC_RESOLVEm,
    IRR_STACK_TRUNK_RESOLVEm,
    OAMP_MEP_DB_BFD_CC_ON_MPLSTPm,
    
    /*OAMP_MEP_DB_BFD_ON_PWEm,*/
    OAMP_PE_PROGRAMm,
    OAMP_UMC_TABLEm,
    SCH_CIR_SHAPERS_STATIC_TABEL_CSSTm,
    SCH_CL_SCHEDULERS_CONFIGURATION_SCCm,
    SCH_CL_SCHEDULERS_TYPE_SCTm,
    SCH_SHARED_DEVICE_RATE_SHARED_DRMm,
    SCH_DUAL_SHAPER_MEMORY_DSMm,
    SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
    SCH_FLOW_GROUP_MEMORY_FGMm,
    SCH_FLOW_SUB_FLOW_FSFm,
    SCH_FLOW_TO_FIP_MAPPING_FFMm,
    SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
    SCH_HR_SCHEDULER_CONFIGURATION_SHCm,
    SCH_PIR_SHAPERS_STATIC_TABEL_PSSTm,
    SCH_PORT_SCHEDULER_WEIGHTS_PSWm,
    SCH_SCHEDULER_CREDIT_GENERATION_CALENDAR__CALm,
    SCH_SCHEDULER_ENABLE_MEMORY_SEMm,
    /* parity multi element memories. */
    IDR_MCDA_PRFSELm,
    IDR_MCDB_PRFSELm,
    IHB_FEC_ENTRYm,
    IHP_PARSER_PROGRAMm,

    /* parity multi element memories with alias*/
    EPNI_EEDB_BANKm,
    IHB_TCAM_ACTIONm,
    IHP_LIF_TABLEm,
    IHP_VLAN_PORT_MEMBERSHIP_TABLEm,

    NUM_SOC_MEM
};/*************
 * FUNCTIONS *
 *************/
/* { */

/*
 * Determining dynamic memories
 */
void arad_tbl_default_dynamic_set(void) {

    sal_memset(arad_mem_is_dynamic_bmp, 0, sizeof(arad_mem_is_dynamic_bmp));
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_0_CNTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_0_OVTH_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_1_CNTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_1_OVTH_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_2_CNTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_2_OVTH_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_3_CNTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(CRPS_CRPS_3_OVTH_MEMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_CBMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_DCMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_FBMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_FDMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_PDCMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_PDCMAXm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_PQSMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_PQSMAXm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QDCMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QDCMAXm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QM_0m);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QM_1m);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QM_2m);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QM_3m);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QP_CBMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QQSMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_QQSMAXm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_RDMMCm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_RDMUCm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_RPDMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_RRDMm);
    ARAD_MBMP_SET_DYNAMIC(EGQ_TCG_CBMm);
    ARAD_MBMP_SET_DYNAMIC(EDB_ESEM_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(FCR_FCR_CRM_Am);
    ARAD_MBMP_SET_DYNAMIC(FCR_FCR_CRM_Bm);
    ARAD_MBMP_SET_DYNAMIC(IDR_COMPLETE_PCm);
    ARAD_MBMP_SET_DYNAMIC(IDR_CONTEXT_COLORm);
    ARAD_MBMP_SET_DYNAMIC(IDR_CONTEXT_SIZEm);
    ARAD_MBMP_SET_DYNAMIC(IDR_GLOBAL_METER_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(IDR_MCDA_DYNAMICm);
    ARAD_MBMP_SET_DYNAMIC(IDR_MCDB_DYNAMICm);
    ARAD_MBMP_SET_DYNAMIC(IDR_MCDA_PCUCm);
    ARAD_MBMP_SET_DYNAMIC(IDR_MCDB_PCUCm);
    ARAD_MBMP_SET_DYNAMIC(IHB_CPU_TRAP_CODE_CTRm);
    ARAD_MBMP_SET_DYNAMIC(IHB_FEC_ENTRY_ACCESSEDm);
    ARAD_MBMP_SET_DYNAMIC(IHB_OAM_COUNTER_FIFOm);
    ARAD_MBMP_SET_DYNAMIC(PPDB_A_OEMA_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(PPDB_A_OEMB_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ACTION_HIT_INDICATIONm);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ACTION_HIT_INDICATION_24m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ACTION_HIT_INDICATION_25m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ACTION_HIT_INDICATION_26m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ACTION_HIT_INDICATION_27m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_BANKm);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ENTRY_PARITYm);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ENTRY_PARITY_12m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TCAM_ENTRY_PARITY_13m);
    ARAD_MBMP_SET_DYNAMIC(IHB_TIME_STAMP_FIFOm);
    ARAD_MBMP_SET_DYNAMIC(IHP_ISA_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(IHP_ISB_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(IHP_LIF_ACCESSEDm);
    ARAD_MBMP_SET_DYNAMIC(IPS_CRBALm);
    ARAD_MBMP_SET_DYNAMIC(IPS_MAXQSZm);
    ARAD_MBMP_SET_DYNAMIC(IPS_QDESCm);
    ARAD_MBMP_SET_DYNAMIC(IPS_QDESC_TABLEm);
    ARAD_MBMP_SET_DYNAMIC(IPS_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IPT_BDQm);
    ARAD_MBMP_SET_DYNAMIC(IPT_EGQCTLm);
    ARAD_MBMP_SET_DYNAMIC(IPT_EGQDATAm);
    ARAD_MBMP_SET_DYNAMIC(IPT_EGQ_TXQ_RD_ADDRm);
    ARAD_MBMP_SET_DYNAMIC(IPT_EGQ_TXQ_WR_ADDRm);
    ARAD_MBMP_SET_DYNAMIC(IPT_FDTCTLm);
    ARAD_MBMP_SET_DYNAMIC(IPT_FDTDATAm);
    ARAD_MBMP_SET_DYNAMIC(IPT_FDT_TXQ_RD_ADDRm);
    ARAD_MBMP_SET_DYNAMIC(IPT_FDT_TXQ_WR_ADDRm);
    ARAD_MBMP_SET_DYNAMIC(IPT_MOP_MMUm);
    ARAD_MBMP_SET_DYNAMIC(IPT_PCQm);
    ARAD_MBMP_SET_DYNAMIC(IPT_SOP_MMUm);
    ARAD_MBMP_SET_DYNAMIC(IQM_BDBLLm);
    ARAD_MBMP_SET_DYNAMIC(IQM_CNG_QUE_SETm);
    ARAD_MBMP_SET_DYNAMIC(IQM_CPDMDm);
    ARAD_MBMP_SET_DYNAMIC(IQM_DBFFMm);
    ARAD_MBMP_SET_DYNAMIC(IQM_DELFFMm);
    ARAD_MBMP_SET_DYNAMIC(IQM_FLUSCNTm);
    ARAD_MBMP_SET_DYNAMIC(IQM_MNUSCNTm);
    ARAD_MBMP_SET_DYNAMIC(IQM_PDMm);
    ARAD_MBMP_SET_DYNAMIC(IQM_PQDMDm);
    ARAD_MBMP_SET_DYNAMIC(IQM_TAILm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_A_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_B_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_C_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_D_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_E_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VSQ_F_MX_OCm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QA_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QA_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QB_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QB_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QC_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QC_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QD_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QD_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QE_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QE_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QF_AVGm);
    ARAD_MBMP_SET_DYNAMIC(IQM_VS_QF_QSZm);
    ARAD_MBMP_SET_DYNAMIC(IRE_CTXT_MEM_CONTROLm);
    ARAD_MBMP_SET_DYNAMIC(IRR_FREE_PCB_MEMORYm);
    ARAD_MBMP_SET_DYNAMIC(IRR_ISF_MEMORYm);
    ARAD_MBMP_SET_DYNAMIC(IRR_IS_FREE_PCB_MEMORYm);
    ARAD_MBMP_SET_DYNAMIC(IRR_IS_PCB_LINK_TABLEm);
    ARAD_MBMP_SET_DYNAMIC(IRR_LAG_NEXT_MEMBERm);
    ARAD_MBMP_SET_DYNAMIC(IRR_MCR_MEMORYm);
    ARAD_MBMP_SET_DYNAMIC(IRR_PCB_LINK_TABLEm);
    ARAD_MBMP_SET_DYNAMIC(MMU_DRAM_ADDRESS_SPACEm);
    ARAD_MBMP_SET_DYNAMIC(MMU_FDFm);
    ARAD_MBMP_SET_DYNAMIC(MMU_IDFm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFC_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFD_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFE_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFF_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFG_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAFH_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RAF_WADDRm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFA_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFB_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFC_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFD_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFE_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFF_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFG_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDFH_WADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_RDF_RADDRm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFA_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFA_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFB_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFB_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFC_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFC_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFD_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFD_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFE_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFE_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFF_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFF_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFG_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFG_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFH_HALFA_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAFH_HALFB_RADDR_STATUSm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAF_HALFA_WADDRm);
    ARAD_MBMP_SET_DYNAMIC(MMU_WAF_HALFB_WADDRm);
    ARAD_MBMP_SET_DYNAMIC(NBI_MLF_RX_MEM_A_CTRLm);
    ARAD_MBMP_SET_DYNAMIC(NBI_MLF_RX_MEM_B_CTRLm);
    ARAD_MBMP_SET_DYNAMIC(NBI_MLF_TX_MEM_CTRLm);
    ARAD_MBMP_SET_DYNAMIC(NBI_RBINS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_RLENG_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_RPKTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_RTYPE_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_TBINS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_TLENG_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_TPKTS_MEMm);
    ARAD_MBMP_SET_DYNAMIC(NBI_TTYPE_MEMm);
    ARAD_MBMP_SET_DYNAMIC(OAMP_MEP_DBm);
    ARAD_MBMP_SET_DYNAMIC(OAMP_RMEP_DBm);
    ARAD_MBMP_SET_DYNAMIC(OAMP_RMAPEM_MANAGEMENT_REQUESTm);
    ARAD_MBMP_SET_DYNAMIC(OCB_OCBM_EVENm);
    ARAD_MBMP_SET_DYNAMIC(OCB_OCBM_ODDm);
    ARAD_MBMP_SET_DYNAMIC(RTP_UNICAST_DISTRIBUTION_MEMORY_FOR_CTRL_CELLSm);
    ARAD_MBMP_SET_DYNAMIC(RTP_UNICAST_DISTRIBUTION_MEMORY_FOR_DATA_CELLSm);
    ARAD_MBMP_SET_DYNAMIC(RTP_UNICAST_DISTRIBUTION_MEMORYm);
    ARAD_MBMP_SET_DYNAMIC(SCH_BUCKET_DEFICIT__BDFm);
    ARAD_MBMP_SET_DYNAMIC(SCH_FLOW_INSTALLED_MEMORY__FIMm);
    ARAD_MBMP_SET_DYNAMIC(SCH_FLOW_STATUS_MEMORY__FSMm);
    ARAD_MBMP_SET_DYNAMIC(SCH_PORT_QUEUE_SIZE__PQSm);
    ARAD_MBMP_SET_DYNAMIC(SCH_TOKEN_MEMORY_CONTROLLER__TMCm);
}

/*
 * Returns TRUE if the memory is dynamic
 */
int dpp_tbl_is_dynamic(int unit, soc_mem_t mem) {
    soc_mem_t origin_mem = mem;
    SOC_MEM_ALIAS_TO_ORIG(unit,mem);

    return ((ARAD_MBMP_IS_DYNAMIC(origin_mem) || ARAD_MBMP_IS_DYNAMIC(mem) || SOC_MEM_IS_INTERNAL(unit, mem)) 
    && SOC_IS_ARADPLUS_AND_BELOW(unit))
    || soc_mem_is_readonly(unit, mem) || soc_mem_is_writeonly (unit, mem) || soc_mem_is_signal(unit, mem) ;
}


/* 
 * Mark all cacheable tables
 */
void arad_tbl_mark_cachable(int unit) {
    soc_mem_t mem;
    for (mem = 0; mem < NUM_SOC_MEM; mem++) {
        if (!SOC_MEM_IS_VALID(unit, mem)) {
            continue;
        };
        /* Skip the Read-only/Write-Only/Signal tables */
        if (dpp_tbl_is_dynamic(unit, mem))
        {
            continue;
        }

        /* uncacheable memories*/
        switch (mem) {
            /* TCAM */
            case IHB_TCAM_BANK_COMMANDm:
            case PPDB_A_TCAM_BANK_COMMANDm:
            case IHB_TCAM_BANK_REPLYm:
            case PPDB_A_TCAM_BANK_REPLYm:
            case IHB_TCAM_BANKm:
            case PPDB_A_TCAM_BANKm:
            case KAPS_TCMm: 
/*
            case IHB_TCAM_ACTIONm:
            case PPDB_A_TCAM_ACTIONm:
*/

           /* IRR (accordint to SDK-74576(Gili)  should not be cached*/
           /**
            * we will used the cached of the multicast 
            * for shadow fix 
            */
            case IRR_MCDBm:


            /* READ ONLY memories */
            case EPNI_MEM_760000m:
            case FSRD_FSRD_WL_EXT_MEMm:
            case IDR_MEM_1B0000m:
            case IDR_MEM_1F0000m:
            case IHB_MEM_10E0000m:
            case IHB_MEM_16E0000m:
            case IHP_MACT_FLUSH_DBm:
            case IHP_MEM_740000m:
            case IHP_MEM_9E0000m:
            case IHP_MEM_C50000m:
            case OAMP_MEM_340000m:
            case PPDB_B_LARGE_EM_FLUSH_DBm:

            /* Skip Signal tables */
            case CRPS_MEM_0080000m:
            case CRPS_MEM_0090000m:
            case CRPS_MEM_00A0000m:
            case CRPS_MEM_00B0000m:
            case ECI_MBU_MEMm:
            case IPS_MEM_180000m:
            case IPS_MEM_1A0000m:
            case IPS_MEM_200000m:
            case IPS_MEM_220000m:
            case IPS_MEM_240000m:
            case IQM_MEM_7E00000m:
            case PORT_WC_UCMEM_DATAm:
            case SCH_MEM_01F00000m:
            case SCH_MEM_30000000m:

            /* Skip Signal tables - Arad Only */
            case IRR_MEM_300000m:
            case IRR_MEM_340000m:
            case IRR_MEM_3C0000m:

            /*Skip SER tables */
            case SER_ACC_TYPE_MAPm:
            case SER_MEMORYm:
            case SER_RESULT_0m:
            case SER_RESULT_1m:
            case SER_RESULT_DATA_0m:
            case SER_RESULT_DATA_1m:
            case SER_RESULT_EXPECTED_0m:
            case SER_RESULT_EXPECTED_1m:
            continue;

                             
            case IRE_PPLB_CFGm:
            case OAMP_FLOW_STAT_10_SEC_ENTRY_1m:
            case OAMP_FLOW_STAT_10_SEC_ENTRY_2m:
            case OAMP_FLOW_STAT_10_SEC_ENTRY_3m:
            case OAMP_FLOW_STAT_1_SEC_ENTRY_1m:
            case OAMP_FLOW_STAT_1_SEC_ENTRY_2m:
            case OAMP_FLOW_STAT_1_SEC_ENTRY_3m:
            case OAMP_FLOW_STAT_ACCUM_ENTRY_1m:
            case OAMP_FLOW_STAT_ACCUM_ENTRY_2m:
            case OAMP_FLOW_STAT_ACCUM_ENTRY_3m:
            case OAMP_FLOW_STAT_ACCUM_ENTRY_34m:
            case OAMP_SAT_TX_EVC_PARAMS_ENTRY_1m:
            case OAMP_SAT_TX_EVC_PARAMS_ENTRY_2m:
            case OAMP_SAT_TX_GEN_PARAMSm:

            /*This table is internal OAMP table, so it should nt being cached*/
            case OAMP_MEM_20000m:

            /* this memories are not real memories and should not being cached*/
            case ILKN_PMH_PORT_0_CPU_ACCESSm:
            case ILKN_PMH_PORT_1_CPU_ACCESSm:
            case ILKN_PML_PORT_0_CPU_ACCESSm:
            case ILKN_PML_PORT_1_CPU_ACCESSm:
            case CLPORT_WC_UCMEM_DATAm:
            case XLPORT_WC_UCMEM_DATAm:

            /*Skip TMC dynamic tables*/
            case SCH_TOKEN_MEMORY_CONTROLLER_TMCm:
            case SCH_TOKEN_MEMORY_CONTROLLER_TMC_MSBm:

                if(SOC_IS_JERICHO(unit)) {
                    continue;
                } else {
                    break;
                }

            case NBI_EGR_MEM_DATAm:
                if(SOC_IS_ARDON(unit)) {
                        continue;
                    } else {
                        break;
                    }
            case PPDB_A_TCAM_ACTIONm:

                if(SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                    continue;
                }

            default:
                break;
        }
        SOC_MEM_INFO(unit, mem).flags |= SOC_MEM_FLAG_CACHABLE;
        LOG_DEBUG(BSL_LS_SOC_MEM, (BSL_META_U(unit, "caching %s \n"), SOC_MEM_NAME(unit, mem)));
    }
}

/* Fill the whole table with the given entry, uses fast DMA filling when run on real hardware */
uint32
  arad_fill_table_with_entry(
    SOC_SAND_IN int       unit,
    SOC_SAND_IN soc_mem_t mem,
    SOC_SAND_IN int       copyno,
    SOC_SAND_IN void      *data
  )
{
  uint32    res = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  res = dcmn_fill_table_with_entry(unit, mem, copyno, data);

  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 222, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_fill_table_with_entry()",0,0);
}

/* Fill the specified part of the table with the given entry, uses fast DMA filling when run on real hardware */
uint32
  arad_fill_partial_table_with_entry(
    SOC_SAND_IN int       unit,
    SOC_SAND_IN soc_mem_t mem,
    SOC_SAND_IN unsigned  array_index_start,
    SOC_SAND_IN unsigned  array_index_end,
    SOC_SAND_IN int       copyno,
    SOC_SAND_IN int       index_start,
    SOC_SAND_IN int       index_end,
    SOC_SAND_IN void      *data
  )
{
  uint32 err = 0;
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if ((!soc_mem_slamable(unit, mem, copyno)
#ifdef CRASH_RECOVERY_SUPPORT 
       ||  (SOC_IS_DONE_INIT(unit) && BCM_UNIT_DO_HW_READ_WRITE(unit))
#endif /* CRASH_RECOVERY_SUPPORT */
       )
#ifdef PLISIM
      || (SAL_BOOT_PLISIM)
#endif
   )
  {
    int index, blk;
    unsigned array_index;

    SOC_MEM_BLOCK_ITER(unit, mem, blk) 
    {
      if (copyno != COPYNO_ALL && copyno != blk) {
        continue;
      }
      for (array_index = array_index_start; array_index <= array_index_end; ++array_index) 
      {
        for (index = index_start; index <= index_end; ++index) 
        {
          err = soc_mem_array_write(unit, mem, array_index, blk, index, (void*)data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);
        }
      }
    }
  }
else {
#ifdef BCM_SBUSDMA_SUPPORT
    err = _soc_mem_sbusdma_clear_specific(unit, mem, array_index_start, array_index_end, copyno, index_start, index_end, (void*)data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);
#endif
    }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_fill_partial_table_with_entry()",0,0);
}

#ifdef PALLADIUM_BACKDOOR

#include <sal/appl/io.h>
#include <stdlib.h>

#define _PALLADIUM_BACKDOOR_ROOT                        "/projects/ntsw-sw/home/tomerma"
#define _PALLADIUM_BACKDOOR_SCRIPT_DIR                  _PALLADIUM_BACKDOOR_ROOT "/palladium_backdoor/"
#define _PALLADIUM_BACKDOOR_JERICHO_ALL_MEMS_FILE       _PALLADIUM_BACKDOOR_SCRIPT_DIR "/palladium_backdoor_jericho_mem_list.txt"
#define _PALLADIUM_BACKDOOR_DUMP_FILE_TEMPLATE          _PALLADIUM_BACKDOOR_ROOT "/tmpdir/tempXXXXXX"
#define _PALLADIUM_BACKDOOR_FULL_TABLE_WRITE_SCRIPT     _PALLADIUM_BACKDOOR_SCRIPT_DIR "/palladium_backdoor_dispatch_full_table_write.py"
#define _PALLADIUM_BACKDOOR_PARTIAL_TABLE_WRITE_SCRIPT  _PALLADIUM_BACKDOOR_SCRIPT_DIR "/palladium_backdoor_dispatch_partial_table_write.py"
#define _PALLADIUM_BACKDOOR_MAX_STRING_LEN              (1024)
#define _PALLADIUM_BACKDOOR_MAX_SW_MEM_NAME             (256)
#define _PALLADIUM_BACKDOOR_MAX_LOGICAL_WRAPPERS        (128)
#define _PALLADIUM_BACKDOOR_NOF_CORE_IDS                (2)

/* Copy at most max_len chars from src. If src has less characters then stop at the end of src. */
STATIC void _palladium_backdoor_safe_strncpy(char *dst, const char *src, int max_len)
{
  /* One always reserved for the terminating 0 */
  for (max_len--; *src && max_len; src++, dst++, max_len--) {
      *dst = *src;
  }

  *dst = 0;
}

STATIC int _palladium_backdoor_safe_strnlen(const char *str, int max_len)
{
  int i;

  for (i = 0; str[i] && i < max_len; i++);

  return i;
}

#define _PALLADIUM_BACKDOOR_SAFE_SPRINTF(str, format, args...)  do { int __rv = snprintf((str), _PALLADIUM_BACKDOOR_MAX_STRING_LEN, (format), args); SOCDNX_VERIFY(__rv > 0); SOCDNX_VERIFY(__rv < _PALLADIUM_BACKDOOR_MAX_STRING_LEN); } while (0)
#define _PALLADIUM_BACKDOOR_SAFE_STRCPY(dst, src)           _palladium_backdoor_safe_strncpy((dst), (src), _PALLADIUM_BACKDOOR_MAX_STRING_LEN)
#define _PALLADIUM_BACKDOOR_SAFE_STRLEN(str)                _palladium_backdoor_safe_strnlen((str), _PALLADIUM_BACKDOOR_MAX_STRING_LEN)

/** 
 * Given an instance of a HW name, transform it to a format. 
 *  
 * General structure is: 
 * {pre-sw-name}{sw-name}{post-sw-name} 
 *  
 * if there is a core_id then {pre-sw-name} looks like {str}%u{str}, otherwise like {str}. 
 * if there is a logical_wrapper then {post-sw-name} looks like {str}%u{str}, otherwise like {str}. 
 *  
 * Parameters: 
 * @block_name - Name of the block (e.g. "EGQ" or "IPT"). 
 * @sw_name - The software name for the table. 
 * @hw_name - A matching HW name. 
 * @hw_format - The HW format will be returned here. 
 * @is_logical_wrapper - An indication of whether there is a logical_wrapper or not is returned here. 
 * @is_logical_wrapper - An indication of whether there is a hw_name per core is returned here.  
 */
soc_error_t _arad_palladium_backdoor_hw_name_to_hw_format(
   int unit,
   SOC_SAND_IN char *block_name,
   SOC_SAND_IN char *sw_name,
   SOC_SAND_IN char hw_name[_PALLADIUM_BACKDOOR_MAX_STRING_LEN],
   SOC_SAND_OUT char hw_format[_PALLADIUM_BACKDOOR_MAX_STRING_LEN],
   SOC_SAND_OUT uint32 *is_logical_wrapper,
   SOC_SAND_OUT uint32 *is_per_core
   )
{
  int nof_scanned_elems;
  int sw_name_len;
  int hw_format_len;
  char *sw_name_begin;
  char *core_digit_begin;
  char *logical_wrapper_begin;
  char *logical_wrapper_post_num;
  char *curr_hw_format = hw_format;
  char *curr_hw_name;
  char hw_name_copy[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  char *logical_wrapper_str;

  SOCDNX_INIT_FUNC_DEFS;

  sw_name_len = _PALLADIUM_BACKDOOR_SAFE_STRLEN(sw_name);
  _PALLADIUM_BACKDOOR_SAFE_STRCPY(hw_name_copy, hw_name);
  curr_hw_name = hw_name_copy;
  sw_name_begin = strstr(hw_name_copy, sw_name);

  assert(sw_name_begin != NULL);

  /* pre sw_name part. */
  sw_name_begin[0] = 0;

  *is_per_core = FALSE;

  /* Exceptions */
  if (strcmp(block_name, "epni") == 0 ||
      strcmp(block_name, "edb") == 0 ||
      (strcmp(block_name, "egq") == 0 && strcmp(sw_name, "tc_dp_map_table") != 0)) {
      core_digit_begin = hw_name_copy + strlen("jericho_chip.egq_epni_dbf_2x");
  } else {
      core_digit_begin = hw_name_copy;
  }

  /* Try to find a digit before {sw_name} */
  if (core_digit_begin != NULL) {
    core_digit_begin = (char*)core_digit_begin + strcspn(core_digit_begin, "0123456789");
    *is_per_core = core_digit_begin[0] != 0 ? TRUE : FALSE;
  }

  /* {pre_core_id}%u{post_core_id}{sw_name} */
  if (*is_per_core) {
    uint32 core_id;

    nof_scanned_elems = sscanf(core_digit_begin, "%u", &core_id);
    SOCDNX_VERIFY(nof_scanned_elems == 1);
    if (core_id > 1) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Illegal core_id %u for HW memory %s.\n"), core_id, sw_name));
    }
    
    core_digit_begin[0] = 0;
    _PALLADIUM_BACKDOOR_SAFE_SPRINTF(curr_hw_format, "%s%%u%s", hw_name_copy, core_digit_begin + 1);

  /* {pre_sw_name}{sw_name}*/
  } else {
    _PALLADIUM_BACKDOOR_SAFE_STRCPY(curr_hw_format, hw_name_copy);
  }

  curr_hw_format += _PALLADIUM_BACKDOOR_SAFE_STRLEN(curr_hw_format);
  _PALLADIUM_BACKDOOR_SAFE_STRCPY(curr_hw_format, sw_name);
  curr_hw_format += sw_name_len;
  curr_hw_name = sw_name_begin + sw_name_len;

  /* post sw_name part */

  /* Check whether there is a logical wrapper. */
  logical_wrapper_str = "logical_wrapper_";
  logical_wrapper_begin = strstr(curr_hw_name, "logical_wrapper_");
  *is_logical_wrapper = logical_wrapper_begin != NULL ? TRUE : FALSE;

  if (logical_wrapper_begin != NULL) {
    logical_wrapper_post_num = logical_wrapper_begin + _PALLADIUM_BACKDOOR_SAFE_STRLEN(logical_wrapper_str);

    /* Find this char:       x     */
    /* ***logical_wrapper_ddd****  */
    if (!('0' <= *logical_wrapper_post_num && *logical_wrapper_post_num <= '9')) {
      SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Illegal character %c after logical_wrapper_ for HW memory %s.\n"), *logical_wrapper_post_num, hw_name));
    }

    for (; '0' <= *logical_wrapper_post_num && *logical_wrapper_post_num <= '9'; logical_wrapper_post_num++); 

    logical_wrapper_begin[0] = 0;

    _PALLADIUM_BACKDOOR_SAFE_SPRINTF(curr_hw_format, "%s%s%%u%s", curr_hw_name, logical_wrapper_str, logical_wrapper_post_num);
  } else {
    _PALLADIUM_BACKDOOR_SAFE_STRCPY(curr_hw_format, curr_hw_name);
  }

  hw_format_len = _PALLADIUM_BACKDOOR_SAFE_STRLEN(hw_format);

  /* Remove \r\n at end of line. */
  if (strcmp(hw_format + hw_format_len - 2, "\r\n") == 0) {
    hw_format[hw_format_len - 2] = '\0';
  }

exit:
  SOCDNX_FUNC_RETURN;
}

/**
 * Given a software table name, return the emulation hardware name(s) of the table. 
 * In case the SW table corresponds to several HW tables, a format is returned containing one or more occurences of %u. 
 * More specifically: 
 * If the SW memory has an instance per core (at most 2), this will correspond to one %u. 
 * If the SW memory is split among several HW tables (i.e. the entries are split evenly to several HW "logical wrapper"s), this will correspond to one %u. 
 * If both the above are present, then the first %u will correspond to the core, and the second to the "logical wrapper".
 *  
 * Parmeters:
 * @sw_name - The software name to get the HW name for (if array, then the array index must be appended at the end). 
 * @hw_mem_format - The returned HW name (or format). 
 * @nof_logical_wrappers - If the SW table is split to several HW tables, then this will contain the number of logical wrappers (otherwise 0).
 *                         The entries are split evenly between these HW tables, and hw_mem_format will contain an %u for this.
 * @is_per_core - If the SW table has one HW table per core, then this will be 1 (otherwise 0), and hw_mem_format will contain one %u for this.
 */
soc_error_t _jericho_palladium_backdoor_sw_mem_to_hw_name(
   int unit,
   SOC_SAND_IN char *sw_name,
   SOC_SAND_OUT char hw_mem_format[_PALLADIUM_BACKDOOR_MAX_STRING_LEN],
   SOC_SAND_OUT uint32 *nof_logical_wrappers,
   SOC_SAND_OUT uint32 *is_per_core
   )
{
  int i;
  int nof_scanned_elems;
  uint32 name_matched = FALSE;
  uint32 is_logical_wrapper;
  uint32 scanned_logical_wrapper;
  uint32 scanned_core_id;
  /* logical wrappers (per core). */
  /* used to check there are no core_id/logical_wrapper/(core_id,logical_wrapper) duplicates. */
  uint32 expected_items_seen[_PALLADIUM_BACKDOOR_NOF_CORE_IDS][_PALLADIUM_BACKDOOR_MAX_LOGICAL_WRAPPERS];
  /* Buffer for lines read from the file. */
  char line_buffer[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  /* The sw_name in lower case. */
  char lower_case_sw_name[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  /* Will hold the first possible match - .i_{fixed_sw_name}.*/
  char match_string_1[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  /* Will hold the second possible match - .{fixed_sw_name}.*/
  char match_string_2[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  /* The lower case sw_name without the block. */
  char *fixed_sw_name = lower_case_sw_name;
  /* The block name. */
  char *block_name;
  uint32 sw_name_len;
  FILE *all_mems_file;
  soc_error_t rv;
  struct {
    const char *sw_name;
    const char *hw_format;
    uint32 nof_logical_wrappers;
    uint32 is_per_core;
  } exceptions[] = {
    { "EPNI_REMARK_MPLS_TO_EXP", "jericho_chip.egq_epni_dbf_2x.egq_epni%u.epni_dft.epni.epni_ind_regs.remark_mpls_to_exp.cpu_data_in", 0, TRUE },
    { "EPNI_REMARK_MPLS_TO_DSCP", "jericho_chip.egq_epni_dbf_2x.egq_epni%u.epni_dft.epni.epni_ind_regs.remark_mpls_to_dscp.cpu_data_in", 0, TRUE }
  };
  int exception_idx;

  SOCDNX_INIT_FUNC_DEFS;

  SOCDNX_VERIFY(exceptions == exceptions);

  for (exception_idx = 0; exception_idx < sizeof(exceptions) / sizeof(exceptions[0]); exception_idx++) {
    if (strcmp(sw_name, exceptions[exception_idx].sw_name) == 0) {
      *nof_logical_wrappers = exceptions[exception_idx].nof_logical_wrappers;
      *is_per_core = exceptions[exception_idx].is_per_core;
      _PALLADIUM_BACKDOOR_SAFE_STRCPY(hw_mem_format, exceptions[exception_idx].hw_format);
      SOC_EXIT;
    }
  }

  if (strcmp(sw_name, "EPNI_REMARK_MPLS_TO_EXP") == 0) {
    *nof_logical_wrappers = 0;
  }

  all_mems_file = fopen(_PALLADIUM_BACKDOOR_JERICHO_ALL_MEMS_FILE, "r");
  if (!all_mems_file) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Could not open the palladium all memories file (%s).\n"), _PALLADIUM_BACKDOOR_JERICHO_ALL_MEMS_FILE)); 
  }
  *nof_logical_wrappers = 0;

  memset(expected_items_seen, 0, sizeof(expected_items_seen));

  line_buffer[_PALLADIUM_BACKDOOR_MAX_STRING_LEN - 1] = 0;

  sw_name_len = _PALLADIUM_BACKDOOR_SAFE_STRLEN(sw_name);

  for (i = 0; i < sw_name_len; i++) {
    lower_case_sw_name[i] = tolower(sw_name[i]);
  }

  lower_case_sw_name[i] = 0;

  /* Exception: EGQ_TC_DP_MAP - The name is egq_tc_dp_map_table. */
  if (strcmp(sw_name, "EGQ_TC_DP_MAP") == 0) {
      strcpy(lower_case_sw_name + i, "_table");
  }

  
  /* Remove the block name (first word ending with underscore) */
  fixed_sw_name = strchr(lower_case_sw_name, '_');
  block_name = lower_case_sw_name;
  /* Exception: PPDB_A and PPDB_B - the block name has an underscore in it. */
  if (
      strncmp(sw_name, "PPDB_A", 6) == 0 ||
      strncmp(sw_name, "PPDB_B", 6) == 0
     ) {
      
    /* Correct for the extra _A or _B */
    fixed_sw_name += 2;
  }

  fixed_sw_name[0] = 0;
  fixed_sw_name++; 

  _PALLADIUM_BACKDOOR_SAFE_SPRINTF(match_string_1, ".i_%s.", fixed_sw_name);
  _PALLADIUM_BACKDOOR_SAFE_SPRINTF(match_string_2, ".%s.", fixed_sw_name);

  while (fgets(line_buffer, _PALLADIUM_BACKDOOR_MAX_STRING_LEN, all_mems_file) == line_buffer) {
    char *sw_name_begin; 
    int core_id = 0;
    int logical_wrapper_id = 0;

    /* Make sure the line is shorter than _PALLADIUM_BACKDOOR_MAX_STRING_LEN. */
    assert(line_buffer[_PALLADIUM_BACKDOOR_MAX_STRING_LEN - 1] == 0);

    /* First search for the name. */
    sw_name_begin = strstr(line_buffer, fixed_sw_name);
    
    if (sw_name_begin != NULL) {

      /* Next check that either it is either of the form .i_{name}. or .{name} and has mem.mem in the name. */
      if ((strstr(line_buffer, match_string_1) != NULL || strstr(line_buffer, match_string_1) != NULL) &&
          (strstr(line_buffer, "mem.mem") != NULL)) {
        uint32 match_error = FALSE;

        /* For some memories, there are matching names that are actually signals and not hw memories. */
        /* For these also search for a mem.mem */       
        if (name_matched == FALSE) {
          name_matched = TRUE;
          /* If this is the first match then create the hw name format. */
          rv = _arad_palladium_backdoor_hw_name_to_hw_format(unit, block_name, fixed_sw_name, line_buffer, hw_mem_format, &is_logical_wrapper, is_per_core);
          SOCDNX_IF_ERR_EXIT(rv);
        } 

        /* Now check that the current name matches our pattern (and possible scan the logical wrapper number). */
        if (!is_logical_wrapper && !*is_per_core) {
          if (strstr(line_buffer, hw_mem_format) == NULL) {
            match_error = TRUE;
          }
        } else if (is_logical_wrapper && !*is_per_core) {
          nof_scanned_elems = sscanf(line_buffer, hw_mem_format, &scanned_logical_wrapper);
          if (nof_scanned_elems != 1) {
            match_error = TRUE;
          }
        } else if (!is_logical_wrapper && *is_per_core) {
          nof_scanned_elems = sscanf(line_buffer, hw_mem_format, &scanned_core_id);
          if (nof_scanned_elems != 1) {
            match_error = TRUE;
          }
        } else if (is_logical_wrapper && *is_per_core) {
          nof_scanned_elems = sscanf(line_buffer, hw_mem_format, &scanned_core_id, &scanned_logical_wrapper);
          if (nof_scanned_elems != 2) {
            match_error = TRUE;
          }
        }

        if (match_error) {
          SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL,(_BSL_SOCDNX_MSG("HW memory %s expected to match format %s, but it does not (memory %s).\n"), 
                                            line_buffer, hw_mem_format, sw_name));
        }

        if (*is_per_core) {
          if (scanned_core_id > _PALLADIUM_BACKDOOR_NOF_CORE_IDS) {
            /* Check the scanned core id is in bounds. */
            SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("HW memory %s has an illegal core_id (%d > %s) (memory %s).\n"), 
                                              line_buffer, scanned_core_id, _PALLADIUM_BACKDOOR_NOF_CORE_IDS, sw_name));
          }
          core_id = scanned_core_id;
        }

        if (is_logical_wrapper) {
          /* Check the scanned logical wrapper is in bounds. */
          assert(scanned_logical_wrapper < _PALLADIUM_BACKDOOR_MAX_LOGICAL_WRAPPERS);

          /* Update the max if needed. */
          if (scanned_logical_wrapper > *nof_logical_wrappers) {
            *nof_logical_wrappers = scanned_logical_wrapper;
          }

          logical_wrapper_id = scanned_logical_wrapper;
        }

        /* Make sure there are no duplicate items (logical_wrapper/core_id) */
        if (expected_items_seen[core_id][logical_wrapper_id]) {
          char details_str[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
          
          if (*is_per_core && is_logical_wrapper) {
            _PALLADIUM_BACKDOOR_SAFE_SPRINTF(details_str, "logical_wrapper %d, core %d", logical_wrapper_id, core_id);
          } else if (!*is_per_core && is_logical_wrapper) {
            _PALLADIUM_BACKDOOR_SAFE_SPRINTF(details_str, "logical_wrapper %d, no core_id", logical_wrapper_id);
          } else if (*is_per_core && !is_logical_wrapper) {
            _PALLADIUM_BACKDOOR_SAFE_SPRINTF(details_str, "no logical_wrapper, core %d", core_id);
          } else if (!*is_per_core && is_logical_wrapper) {
            _PALLADIUM_BACKDOOR_SAFE_STRCPY(details_str, "no logical_wrapper, no core_id");
          }

          SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("There are duplicate HW memory instances for memory %s (%s).\n"), 
                                            sw_name, details_str));
        }
        expected_items_seen[core_id][logical_wrapper_id] = TRUE;
      }
    }
  }

  if (!name_matched) {
      SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Could not match SW name %s to a HW name.\n"), sw_name));
  }
  if (is_logical_wrapper) {
    if (*nof_logical_wrappers <= 1) {
      SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Expected a logical_wrapper for format %s (memory %s), but only one logical_wrapper instance found.\n"), 
                                                          hw_mem_format, sw_name));
    }

    /* Currently *nof_logical_wrappers is max, not nof. */
    (*nof_logical_wrappers)++;
  }

  sal_fclose(all_mems_file);

exit:
  SOCDNX_FUNC_RETURN;
}

extern int close(int);
#include <sys/wait.h>
#include <sys/stat.h>

/**
 * Dispatch a write command to palladium, causing it to do a backdoor write of the supplied file to the supplied HW table. 
 * The same entry data is written to all entries of the table. 
 * 
 * @sw_mem_name - The SW memory table to write to (if memory array then append the index at the end).
 * @entry_data - The entry data to write to each entry in the table.
 * @nof_entries - The length (in 32-bit entries) of entry_data.
 */
soc_error_t _arad_palladium_backdoor_dispatch_full_table_write(
   SOC_SAND_IN int unit, 
   SOC_SAND_IN char *sw_mem_name,
   SOC_SAND_IN uint32 entry_data[],
   SOC_SAND_IN uint32 entry_data_len
   )
{
  char cmd[_PALLADIUM_BACKDOOR_MAX_STRING_LEN]; 
  char hw_mem_format[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  char hw_mem_name[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  int hw_mem_names_len = 1;
  uint32 nof_logical_wrappers;
  uint32 is_per_core;
  int int_ret;
  int logical_wrapper_idx;
  int core_idx;
  soc_error_t rv;

  SOCDNX_INIT_FUNC_DEFS;
  
  /* Get the HW memory format. */  
  rv = _jericho_palladium_backdoor_sw_mem_to_hw_name(unit, sw_mem_name, hw_mem_format, &nof_logical_wrappers, &is_per_core );  
  SOCDNX_IF_ERR_EXIT(rv);

  if (is_per_core) {
    hw_mem_names_len = 2;
  }

  /* If nof_logical_wrappers then there is exactly 1 instance.*/
  nof_logical_wrappers = nof_logical_wrappers == 0 ? 1 : nof_logical_wrappers;
  
  /* Loop over all logical wrappers and core ids and write the entries. */
  for (logical_wrapper_idx = 0; logical_wrapper_idx < nof_logical_wrappers; logical_wrapper_idx++) {
    for (core_idx = 0; core_idx < hw_mem_names_len; core_idx++) {
      int entry_data_idx;
      char *curr_cmd;
      int child_exit_status = 0;

      /* Get the current HW name from the format and indices. */
      if (!is_per_core && nof_logical_wrappers == 1) {
        _PALLADIUM_BACKDOOR_SAFE_STRCPY(hw_mem_name, hw_mem_format);
      } else if (!is_per_core && nof_logical_wrappers > 1) {
        _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_name, hw_mem_format, logical_wrapper_idx);
      } else if (is_per_core && nof_logical_wrappers == 1) {
        _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_name, hw_mem_format, core_idx);
      } else {
        _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_name, hw_mem_format, core_idx, logical_wrapper_idx);
      }
      
      /* Construct the command. */
      /* Format is: "python {script} 0x{entry_in_hex} {hw_mem_name}" */
      /* entry_in_hex may be longer than 8 chars. */
      curr_cmd = cmd;
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(curr_cmd, "python %s ", _PALLADIUM_BACKDOOR_FULL_TABLE_WRITE_SCRIPT); 
      curr_cmd += strlen(curr_cmd);

      _PALLADIUM_BACKDOOR_SAFE_STRCPY(curr_cmd, "0x");
      curr_cmd += strlen(curr_cmd);

      for (entry_data_idx = 0; entry_data_idx < entry_data_len; entry_data_idx++) {
        _PALLADIUM_BACKDOOR_SAFE_SPRINTF(curr_cmd, "%08X", entry_data[entry_data_len - 1 - entry_data_idx]); 
        curr_cmd += strlen(curr_cmd);
      }

      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(curr_cmd, " %s", hw_mem_name); 
     
      /* Execute the command. */
      int_ret = system(cmd);

      child_exit_status = WEXITSTATUS(int_ret);

      if (int_ret == -1 || child_exit_status != 0) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("There was an error executing the command \"%s\".\n"), cmd));
      }
    }
  }

exit:
  SOCDNX_FUNC_RETURN;
}

STATIC int _arad_tbl_access_get_entry_bit_len(int unit, soc_mem_t mem)
{
  int field_idx;
  int entry_bit_len = -1;

  /* Find the biggest field length. */
  for (field_idx = 0; field_idx < SOC_MEM_INFO(unit, mem).nFields; field_idx++) {
    uint16 cur_len = SOC_MEM_INFO(unit, mem).fields[field_idx].bp + SOC_MEM_INFO(unit, mem).fields[field_idx].len;
    entry_bit_len = SOC_SAND_MAX(entry_bit_len, cur_len);
  }

  return entry_bit_len;
}

/**
 * Given a memory print the given entries to the supplied file in a format that is recognized by the palladium backdoor commands. 
 *  
 * @mem - The memory instance to dump. 
 * @entry_data - The data to dump. 
 * @nof_entries - The length (in entries (32 bit)) of entry_data. 
 * @file_name - The name of the file to dump the buffer to.
 */ 
STATIC soc_error_t _palladium_backdoor_write_memory_file(
   SOC_SAND_IN int unit, 
   SOC_SAND_IN soc_mem_t mem,
   SOC_SAND_IN uint32 *entry_data,
   SOC_SAND_IN uint32 nof_entries,
   SOC_SAND_IN char *file_name
   )
{
  int entry_idx;
     int entry_word_index;
    int entry_size_in_words;
     int entry_bit_len = -1;
     int entry_hex_digit_len;
     int entry_last_word_index;
  int n;
  FILE *dump_file;

  SOCDNX_INIT_FUNC_DEFS;
  
     /* Size of entry in words. */
     entry_size_in_words = soc_mem_entry_words(unit, mem);
    /* Length of entry in bits. */
     entry_bit_len = _arad_tbl_access_get_entry_bit_len(unit, mem);
     /* Length of entry in hex digits, equal to length in bits divided by 4 and rounded up. */
     entry_hex_digit_len = (entry_bit_len + 3) / 4;
    /* Index of the most significant word in the entry. */
     entry_last_word_index = entry_size_in_words - 1;

  dump_file = fopen(file_name, "w");  /* this file will contain the buffer content so we can pass it to the Emulation*/
  if (!dump_file) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Could not open the dump file (%s).\n"), file_name)); 
  }

  for (entry_idx = 0; entry_idx < nof_entries; entry_idx++) {
    /* 
     * For each entry print words from last to first.
     * In the last word print only hex digits with mask != 0 (i.e. at least a single bit is used in the hex digit boundary).
     * Example: If the entry is 9 bits, then print 3 hex digits.
     *
     * The rest of the words are printed in full.
     */
    for (entry_word_index = entry_last_word_index; entry_word_index >= 0; entry_word_index--) {
      int hex_digit_num;
      int bit_num;
      uint32 word_bit_mask;

      /* How many hex digits to print in this word? */
      hex_digit_num = entry_hex_digit_len - entry_word_index * 8;
      hex_digit_num = SOC_SAND_MIN(hex_digit_num, 8);

      bit_num = entry_bit_len - entry_word_index * 32;
      bit_num = SOC_SAND_MIN(bit_num, 32);

      word_bit_mask = bit_num == 32 ? ~(uint32)0 : (1 << bit_num) - 1;

      n = fprintf(dump_file, "%0*X", hex_digit_num, entry_data[entry_idx * entry_size_in_words + entry_word_index] & word_bit_mask);
      SOCDNX_VERIFY(n == hex_digit_num);
    }

    n = fprintf(dump_file, "\n");
    SOCDNX_VERIFY(n == 1);
    
  }

  fclose(dump_file);

exit:
  SOCDNX_FUNC_RETURN;
}

/**
 * This function uses the backdoor mechanism to write a buffer to part of a table. 
 * The buffer is dumped to a file and the backdoor mechanism is used to issue a load 
 * buffer command for the right memory and the right offset. 
 * 
 * @mem - The memory to dump. 
 * @array_index - The array index of the memory (if not memory array then this is ignored).
 * @index_start - The index to start at.
 * @index_end - The index to stop at.
 * @entry_data - The buffer to dump to file.
 */
STATIC soc_error_t _arad_palladium_backdoor_dispatch_partial_table_write(
    SOC_SAND_IN int       unit,
    SOC_SAND_IN soc_mem_t mem,
    SOC_SAND_IN unsigned  array_index,
    SOC_SAND_IN int       index_start,
    SOC_SAND_IN int       index_end,
    SOC_SAND_IN uint32 *  entry_data
  )
{
  int int_ret; 
  char sw_mem_name[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  char hw_mem_format[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
  uint32 nof_logical_wrappers;
  uint32 is_per_core;
  uint32 entries_per_logical_wrapper;
  uint32 nof_entries_to_write;
  uint32 curr_entry_index;
  const int max_core_ids = 2;
  soc_error_t rv;
  int fd;
  char fname[sizeof(_PALLADIUM_BACKDOOR_DUMP_FILE_TEMPLATE)];

  SOCDNX_INIT_FUNC_DEFS;
       
  /* Assert the name length is under the expected maximal length. */
  SOCDNX_VERIFY(_PALLADIUM_BACKDOOR_SAFE_STRLEN(SOC_MEM_NAME(unit, mem)) < _PALLADIUM_BACKDOOR_MAX_SW_MEM_NAME);

  /* For memory arrays we add the array index at the end of the name. */
  if (SOC_MEM_IS_ARRAY(unit, mem)) {
    _PALLADIUM_BACKDOOR_SAFE_SPRINTF(sw_mem_name, "%s%d", SOC_MEM_NAME(unit, mem), array_index);
  } else {
    _PALLADIUM_BACKDOOR_SAFE_STRCPY(sw_mem_name, SOC_MEM_NAME(unit, mem));
  }

  /* Get the HW name format. */
  rv = _jericho_palladium_backdoor_sw_mem_to_hw_name(unit, sw_mem_name, hw_mem_format, &nof_logical_wrappers, &is_per_core);
  SOCDNX_IF_ERR_EXIT(rv);

  entries_per_logical_wrapper = SOC_MEM_INFO(unit, mem).index_max - SOC_MEM_INFO(unit, mem).index_min + 1;
  if (nof_logical_wrappers > 0) {
    entries_per_logical_wrapper /= nof_logical_wrappers; 
  }
   
  nof_entries_to_write = index_end - index_start + 1;
  curr_entry_index = index_start;


  strcpy(fname, _PALLADIUM_BACKDOOR_DUMP_FILE_TEMPLATE);
  fd = mkstemp(fname);
  if (fd == -1) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("There was an error opening a random file with template \"%s\".\n"), _PALLADIUM_BACKDOOR_DUMP_FILE_TEMPLATE));
  }
  close(fd);
  int_ret = chmod(fname, S_IRGRP | S_IROTH);
  if (int_ret != 0) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Could not change permissions for file \"%s\".\n"), fname));
  }

  while (nof_entries_to_write > 0) {
    uint32 logical_wrapper_idx = curr_entry_index / entries_per_logical_wrapper;
    uint32 logical_wrapper_offset = curr_entry_index % entries_per_logical_wrapper;
    uint32 curr_nof_entries_to_write = SOC_SAND_MIN(nof_entries_to_write, entries_per_logical_wrapper - logical_wrapper_offset);
    char hw_mem_names[_PALLADIUM_BACKDOOR_NOF_CORE_IDS][_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
    int hw_mem_names_len = 1;
    int core_idx;

    SOCDNX_VERIFY(logical_wrapper_idx <= nof_logical_wrappers);
    SOCDNX_VERIFY(curr_nof_entries_to_write > 0);


    /* Dump the current buffer part to a file. */
    rv = _palladium_backdoor_write_memory_file(unit, mem, entry_data + curr_entry_index, curr_nof_entries_to_write, fname);
    SOCDNX_IF_ERR_EXIT(rv);

    if (is_per_core) {
      hw_mem_names_len = max_core_ids;
    }

    /* Construct the specific HW instance given the indices and format. */
    if (!is_per_core && nof_logical_wrappers == 0) {
      _PALLADIUM_BACKDOOR_SAFE_STRCPY(hw_mem_names[0], hw_mem_format);
    } else if (!is_per_core && nof_logical_wrappers > 0) {
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_names[0], hw_mem_format, logical_wrapper_idx);
    } else if (is_per_core && nof_logical_wrappers == 0) {
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_names[0], hw_mem_format, 0);
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_names[1], hw_mem_format, 1);
    } else {
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_names[0], hw_mem_format, 0, logical_wrapper_idx);
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(hw_mem_names[1], hw_mem_format, 1, logical_wrapper_idx);
    }

    for (core_idx = 0; core_idx < hw_mem_names_len; core_idx++) {
      char cmd[_PALLADIUM_BACKDOOR_MAX_STRING_LEN];
      int child_exit_status = 0;

      /* Construct the command */
      /* Format: "python {script} {dump-file} {hw-mem-name} {first-index} {last-index}" */
      _PALLADIUM_BACKDOOR_SAFE_SPRINTF(cmd, "python %s %s %s %d %d", 
                                              _PALLADIUM_BACKDOOR_PARTIAL_TABLE_WRITE_SCRIPT, 
                                              fname, 
                                              hw_mem_names[core_idx], 
                                              logical_wrapper_offset, 
                                              curr_nof_entries_to_write + logical_wrapper_offset - 1); 
      /* Execute the command. */
      int_ret = system(cmd); 

      child_exit_status = WEXITSTATUS(int_ret);

      if (int_ret == -1 || (child_exit_status) != 0) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("There was an error executing the command \"%s\".\n"), cmd));
      }
    }

    nof_entries_to_write -= curr_nof_entries_to_write;
    curr_entry_index += curr_nof_entries_to_write;
  }

  /* Delete the file. */
  int_ret = sal_remove(fname);
  if (int_ret != 0) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_FAIL, (_BSL_SOCDNX_MSG("Could not delete file %s.\n"), fname));
  }
    
exit:
  SOCDNX_FUNC_RETURN;
}

#else /* #if defined(__linux) && !defined(__KERNEL__) */

soc_error_t _arad_palladium_backdoor_dispatch_full_table_write(
   SOC_SAND_IN int unit, 
   SOC_SAND_IN char *sw_mem_name,
   SOC_SAND_IN uint32 entry_data[],
   SOC_SAND_IN uint32 entry_data_len
   )
{
      
  SOCDNX_INIT_FUNC_DEFS;

  SOCDNX_VERIFY(FALSE);
  SOC_EXIT;

exit:
  SOCDNX_FUNC_RETURN;
}
  
STATIC soc_error_t _arad_palladium_backdoor_dispatch_partial_table_write(
    SOC_SAND_IN int       unit,
    SOC_SAND_IN soc_mem_t mem,
    SOC_SAND_IN unsigned  array_index,
    SOC_SAND_IN int       index_start,
    SOC_SAND_IN int       index_end,
    SOC_SAND_IN uint32 *  entry_data
  )
{
      
  SOCDNX_INIT_FUNC_DEFS;

  SOCDNX_VERIFY(FALSE);
  SOC_EXIT;

exit:
  SOCDNX_FUNC_RETURN;
}

#endif /* PALLADIUM_BACKDOOR */

soc_error_t arad_tbl_access_deinit(SOC_SAND_IN int unit)
{

  SOCDNX_INIT_FUNC_DEFS;

  /* If it is PCID, the function returns. */
#ifdef PLISIM
  if (SAL_BOOT_PLISIM) {
    SOCDNX_FUNC_RETURN;
  }
#endif

  if (_arad_fill_table_with_variable_values_by_caching_buffer[unit]) {
    if (soc_mem_dmaable(unit, IRR_MCDBm, SOC_MEM_BLOCK_ANY(unit, IRR_MCDBm))) { /* check if we can use DMA */
      soc_cm_sfree(unit, _arad_fill_table_with_variable_values_by_caching_buffer[unit]);
    } else {
      soc_sand_os_free(_arad_fill_table_with_variable_values_by_caching_buffer[unit]);
    }
    _arad_fill_table_with_variable_values_by_caching_buffer[unit] = NULL;
  }

  if (_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit]) {
    sal_mutex_destroy(_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit]);
    _arad_fill_table_with_variable_values_by_caching_buffer_lock[unit] = NULL;
  }

  SOCDNX_FUNC_RETURN;
}

soc_error_t arad_tbl_access_init_unsafe(SOC_SAND_IN int unit)
{

  SOCDNX_INIT_FUNC_DEFS;

  /* If it is PCID, the function returns. */
#ifdef PLISIM
  if (SAL_BOOT_PLISIM) {
    SOCDNX_FUNC_RETURN;
  }
#endif

  /* For arad_tbl_access_init_unsafe() maybe called by several times, so check the memory whether it has been allocated */
  if (_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit] == NULL) {
    _arad_fill_table_with_variable_values_by_caching_buffer_lock[unit] = sal_mutex_create("_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit]");
    if (_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit] == NULL) {
      SOCDNX_EXIT_WITH_ERR(SOC_E_MEMORY, (_BSL_SOCDNX_MSG("Could not allocate memory for a mutex.\n")));
    }
  }

  /* Allocate 64KB of DMA memory. */
  if (_arad_fill_table_with_variable_values_by_caching_buffer[unit] == NULL) {
    _arad_fill_table_with_variable_values_by_caching_buffer[unit] = soc_mem_dmaable(unit, IRR_MCDBm, SOC_MEM_BLOCK_ANY(unit, IRR_MCDBm)) ? /* check if we can use DMA */
      soc_cm_salloc(unit, _arad_fill_table_with_variable_values_by_caching_buffer_len * sizeof(*_arad_fill_table_with_variable_values_by_caching_buffer[0]), 
        "_arad_fill_table_with_variable_values_by_caching_buffer[unit]") :
      (uint32*)soc_sand_os_malloc_any_size(_arad_fill_table_with_variable_values_by_caching_buffer_len * sizeof(*_arad_fill_table_with_variable_values_by_caching_buffer[0]), 
        "_arad_fill_table_with_variable_values_by_caching_buffer[unit]");
  
    if (_arad_fill_table_with_variable_values_by_caching_buffer[unit] == NULL) {
      SOCDNX_EXIT_WITH_ERR(SOC_E_MEMORY, (_BSL_SOCDNX_MSG("Could not allocate a DMA buffer of length %d bytes.\n"), 
                                            _arad_fill_table_with_variable_values_by_caching_buffer_len * 
                                                                        sizeof(*_arad_fill_table_with_variable_values_by_caching_buffer[0])));
    }
  }

exit:
  SOCDNX_FUNC_RETURN;
}

int arad_update_table_with_cache(int unit, soc_mem_t mem) {
    void *buffer;
    void *buf;
    uint8 orig_read_through_flag;
    int index;
    int entry_min = soc_mem_index_min(unit, mem);
    int entry_dw  = soc_mem_entry_words(unit, mem);
    int index_cnt = soc_mem_index_count(unit, mem);
    int entry_max = soc_mem_index_max(unit, mem);
    int copyno = SOC_MEM_BLOCK_MIN(unit, mem);
    soc_error_t rv = SOC_E_NONE;

    SOCDNX_INIT_FUNC_DEFS;

    /* update table only if cache available and buffer allocation succeeded */
    if ((soc_mem_cache_get(unit, mem, copyno)) && (buffer = soc_cm_salloc(unit, index_cnt * entry_dw * 4, "dma")) != NULL) {
        orig_read_through_flag = SOC_MEM_FORCE_READ_THROUGH(unit);
        SOC_MEM_FORCE_READ_THROUGH_SET(unit, 0); /* read from cache */
        for (index = entry_min; index <= entry_max; index++) {
            buf = soc_mem_table_idx_to_pointer(unit, mem, void *, buffer, index);
            rv = soc_mem_array_read(unit, mem, 0, copyno, index, buf);
            if(SOC_FAILURE(rv)) {
                SOC_MEM_FORCE_READ_THROUGH_SET(unit, orig_read_through_flag);
                SOCDNX_EXIT_WITH_ERR_NO_MSG(rv);
            }
        }
        rv = soc_mem_write_range(unit, mem, COPYNO_ALL, entry_min, entry_max, buffer);
        soc_cm_sfree(unit, buffer);
        SOC_MEM_FORCE_READ_THROUGH_SET(unit, orig_read_through_flag);
        SOCDNX_IF_ERR_EXIT(rv);
    } else {
        LOG_ERROR(BSL_LS_SOC_INIT,
                    (BSL_META_U(unit,
                                "%s table is not updated with cache\n"), SOC_MEM_NAME(unit, mem)));
        SOCDNX_EXIT_WITH_ERR_NO_MSG(SOC_E_FAIL);
    }
exit:
    SOCDNX_FUNC_RETURN;  
}

/*
 * BRIEF 
 *   Use DMA to write consecutive entries to a memory by first filling a
 *   buffer with the entries, and then writing from the buffer using DMA.
 * DESCRIPTION 
 *   The function uses a big DMA buffer to buffer writes to a table, and then write
 *   them to HW using DMA.
 *   The user specifies the values using a callback for each entry.
 *   It is assumed that all entries are 32 bits or less.
 *   Each entry is a uint32 (even when in hardware it is less than 32 bits)
 *   and can be used like an entry read or written to HW.
 * PARAMS 
 *   unit
 *   mem - The memory to write to.
 *   array_index - Index of the memory array to write to.
 *   copyno - The block to write to (MEM_BLOCK_ANY can be used).
 *   index_start - The index to start writing at. If -1 then the minimal index of the memory is used.
 *   index_end - The index to stop writing at (inclusive - this index will be written). If -1 then the maximal index of the memory is used.
 *   callback - This callback should set the value of each entry to be written.
 *              For more info see arad_fill_table_with_variable_values_by_caching_callback.
 *   opaque - User data to be passed back untouched to the callback.
 * REMARKS 
 *   The entry contents are not read before writing currently.
 *   Therefore the entry passed to the callback is 0, and should be filled completely.
 * POSSIBLE IMPROVEMENTS 
 *   1. The array_index should be used to enable specifying array_index.
 *   2. There should be an option to instruct the mechanism to read the table contents
 *      before writing.
 * EXAMPLE 
 *    
 */
soc_error_t 
  arad_fill_table_with_variable_values_by_caching(
    SOC_SAND_IN int       unit,
                          soc_mem_t mem,
    SOC_SAND_IN unsigned  array_index,
    SOC_SAND_IN int       copyno,
    SOC_SAND_IN int       index_start,
    SOC_SAND_IN int       index_end,
    SOC_SAND_IN arad_fill_table_with_variable_values_by_caching_callback callback,
    SOC_SAND_IN void *    opaque
  )
{
  int index;
  /* Index inside buffer */
  unsigned int buf_idx = 0;
  /* Index to first entry of the buffer. */
  unsigned int buf_start_entry_idx;
  uint32 *buf = _arad_fill_table_with_variable_values_by_caching_buffer[unit];
  uint32 old_rv;
  soc_error_t new_rv;
  uint8 do_emul = SOC_DPP_CONFIG(unit)->emulation_system && (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "no_backdoor", 0) != 1);
  uint8 do_dma = TRUE;
  int real_index_start;
  int real_index_end;
  int entry_size_in_words;
  int buffer_len_in_words = _arad_fill_table_with_variable_values_by_caching_buffer_len;
  
  SOCDNX_INIT_FUNC_DEFS;

  if (strcmp(SOC_MEM_NAME(unit, mem), "EPNI_REMARK_MPLS_TO_EXP") == 0 || 
      strcmp(SOC_MEM_NAME(unit, mem), "EPNI_REMARK_MPLS_TO_DSCP") == 0)
  {
    do_emul = FALSE;
  }

  if (!soc_mem_is_valid(unit, mem)) {
    SOCDNX_EXIT_WITH_ERR(SOC_E_MEMORY, (_BSL_SOCDNX_MSG("%d: Invalid memory specified for unit %d.\n"),  mem, unit));
  }

  if (callback == NULL) {
    SOC_EXIT;
  }

  SOC_MEM_ALIAS_TO_ORIG(unit,mem);
  entry_size_in_words = soc_mem_entry_words(unit, mem);
  SOCDNX_VERIFY(entry_size_in_words <= buffer_len_in_words);
  
  real_index_start = index_start == -1 ? SOC_MEM_INFO(unit, mem).index_min : index_start;
  real_index_end = index_end == -1 ? SOC_MEM_INFO(unit, mem).index_max : index_end;
  
  /* If no DMA we use direct write. */
  if (!soc_mem_slamable(unit, mem, copyno)
#ifdef PLISIM
      || (SAL_BOOT_PLISIM)
#endif
      )
  {
    int index, blk;
    uint32 buf[SOC_MAX_MEM_WORDS];

    SOC_MEM_BLOCK_ITER(unit, mem, blk) 
    {
      if (copyno != COPYNO_ALL && copyno != blk) {
        continue;
      }
      for (index = real_index_start; index <= real_index_end; ++index) 
      {
        sal_memset(buf, 0, sizeof(buf[0]) * entry_size_in_words);

        if (callback(unit, copyno, array_index, index, buf, entry_size_in_words, opaque) != 0) {
          SOC_EXIT;
        }

        old_rv = soc_mem_array_write(unit, mem, array_index, blk, index, (void*)&buf);
        SOCDNX_SAND_IF_ERR_EXIT(old_rv);
      }
    }

    SOCDNX_FUNC_RETURN;
  }

  SOCDNX_VERIFY(buf != NULL);

  sal_mutex_take(_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit], sal_mutex_FOREVER);
    
  for (index = real_index_start, buf_start_entry_idx = real_index_start; index <= real_index_end; ++index) 
  {
    /* First clear the entry and then fill it. */
    sal_memset(buf + buf_idx, 0, sizeof(buf[0]) * entry_size_in_words);
    if (callback(unit, copyno, array_index, index, buf + buf_idx, entry_size_in_words, opaque) != 0) {
      SOC_EXIT;
    }

    buf_idx += entry_size_in_words;
    /* In case entry_sz == 1, last (fillable) entry is len - 1. */
    /* In case entry_sz > 1, last (fillable) entry is len - entry_sz. */
    /* Therefore if (buf_idx > len - entry_sz) we must flush the buffer.*/
    if (buf_idx > buffer_len_in_words - entry_size_in_words) {
      /* Flush the buffer. */
      if (do_emul) {
        do_dma = FALSE;
        new_rv = _arad_palladium_backdoor_dispatch_partial_table_write(unit, mem, array_index,  buf_start_entry_idx, index, buf);
        SOCDNX_IF_ERR_EXIT(new_rv);
      } 
      if (do_dma) {
        old_rv = soc_mem_array_write_range(unit, 0, mem, array_index, copyno, buf_start_entry_idx, index, buf);
        SOCDNX_SAND_IF_ERR_EXIT(old_rv);
      }

      buf_start_entry_idx = index + 1;
      buf_idx = 0;
      
    }
  }

  if (buf_start_entry_idx <= real_index_end) {
    /* Flush the buffer. */
    if (do_emul) {
      do_dma = FALSE;
      new_rv = _arad_palladium_backdoor_dispatch_partial_table_write(unit, mem,array_index, buf_start_entry_idx, index - 1, buf);
      SOCDNX_IF_ERR_EXIT(new_rv);
    } 
    if (do_dma) {
      old_rv = soc_mem_array_write_range(unit, 0, mem, array_index, copyno, buf_start_entry_idx, index - 1, buf);
      SOCDNX_SAND_IF_ERR_EXIT(old_rv);
    }
  }

  sal_mutex_give(_arad_fill_table_with_variable_values_by_caching_buffer_lock[unit]);

exit:
  SOCDNX_FUNC_RETURN;
}

int
arad_fill_memory_with_incremental_field(const int unit, const soc_mem_t mem, const soc_field_t field,
                                unsigned array_index_min, unsigned array_index_max,
                                const int copyno,
                                int index_min, int index_max,
                                const void *initial_entry)
{
    int    rv = 0, mem_words, mem_size, entry_words, indices_num;
    int    index, blk, tmp;
    unsigned array_index;
    uint32 *buf;
    uint32 *buf2;
    const uint32 *input_entry = initial_entry;
    uint32 field_buf[4] = {0}; /* To hold the field, max size 128 bits */
    int dmaable = soc_mem_dmaable(unit, mem, SOC_MEM_BLOCK_ANY(unit, mem)); /* check if we can use DMA */

    if (initial_entry == NULL) {
        return SOC_E_PARAM;
    }

    /* get legal values for indices, if too small/big use the memory's boundaries */
    tmp = soc_mem_index_min(unit, mem);
    if (index_min < soc_mem_index_min(unit, mem)) {
      index_min = tmp;
    }
    if (index_max < index_min) {
        index_max = index_min;
    } else {
         tmp = soc_mem_index_max(unit, mem);
         if (index_max > tmp) {
             index_max = tmp;
         }
    }

    entry_words = soc_mem_entry_words(unit, mem);
    indices_num = index_max - index_min + 1;
    mem_words = indices_num * entry_words;
    mem_size = mem_words * 4;

    /* get the initial field from the input */
    soc_mem_field_get(unit, mem, initial_entry, field, field_buf);

    if (dmaable) {
        buf = soc_cm_salloc(unit, mem_size, "mem_clear_buf"); /* allocate DMA memory buffer */
    } else {
        buf = (uint32*)soc_sand_os_malloc_any_size(mem_size, "mem_clear_buf");
    }
    if (buf == NULL) {
        return SOC_E_MEMORY;
    }

    /* get legal values for memory array indices */
    if (SOC_MEM_IS_ARRAY(unit, mem)) {
        soc_mem_array_info_t *maip = SOC_MEM_ARRAY_INFOP(unit, mem);
        if (maip) {
            if (array_index_max >= maip->numels) {
                array_index_max = maip->numels - 1;
            }
        } else {
            array_index_max = 0;
        }
        if (array_index_min > array_index_max) {
            array_index_min = array_index_max;
        }
    } else {
        array_index_min = array_index_max = 0;
    }

    /* fill the allocated memory with the input entry */
    for (index = 0; index < mem_words; ++index) {
        buf[index] = input_entry[index % entry_words];
    }

    SOC_MEM_BLOCK_ITER(unit, mem, blk) {
        if (copyno != COPYNO_ALL && copyno != blk) {
            continue;
        }
        for (array_index = array_index_min; array_index <= array_index_min; ++array_index) {
            /* update the field of all the entries in the buffer */
            for (index = 0, buf2 = buf; index < indices_num; ++index, buf2+=entry_words) {
                soc_mem_field_set(unit, mem, buf2, field, field_buf); /* set the index */
                /* increment the field, to be used in next entry */
                if (!++field_buf[0]) {
                    if (!++field_buf[1]) {
                        if (!++field_buf[2]) {
                            ++field_buf[3];
                        }
                    }
                }
            }

#ifdef PLISIM
            if (SAL_BOOT_PLISIM) {
                for (index = index_min, buf2 = buf; index <= index_max; ++index, buf2+=entry_words) {
                    if ((rv = soc_mem_array_write(unit, mem, array_index, blk, index, buf2)) < 0) {
                        LOG_INFO(BSL_LS_SOC_MEM,
                                 (BSL_META_U(unit,
                                             "Write ERROR: table %s.%d[%d]: %s\n"),
                                             SOC_MEM_UFNAME(unit, mem), copyno==COPYNO_ALL ? 0 : copyno, index,
                                  soc_errmsg(rv)));
                    }
                }
            }
            else 
#endif
            {
                if ((rv = soc_mem_array_write_range(unit, 0, mem, array_index, blk, index_min, index_max, buf)) < 0) {
                    LOG_INFO(BSL_LS_SOC_MEM,
                             (BSL_META_U(unit,
                                         "Write ERROR: table %s.%d[%d-%d]: %s\n"),
                                         SOC_MEM_UFNAME(unit, mem), copyno==COPYNO_ALL ? 0 : copyno, index_min, index_max,
                              soc_errmsg(rv)));
                }
            }
        }
    }
    if (dmaable) {
        soc_cm_sfree(unit, buf);
    } else  {
        soc_sand_os_free(buf);
    }
    return rv;
}



void arad_tbl_access_tcam_print(SOC_SAND_IN ARAD_PP_IHB_TCAM_BANK_TBL_DATA *data)
{
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
    uint32
        indx;
    char
        string_to_print[10*ARAD_PP_IHB_TCAM_DATA_WIDTH + 20];

    if(!data->valid) {
        LOG_DEBUG(BSL_LS_SOC_MEM,
                  (BSL_META(SOC_DPP_MSG("      "
"Entry is invalid \n\r"))));
        return;
    }

    sal_sprintf(string_to_print, "      ");
    sal_sprintf(string_to_print + sal_strlen(string_to_print) , " ");
    for(indx = 0; indx < ARAD_PP_IHB_TCAM_DATA_WIDTH; ++indx) {
        sal_sprintf(string_to_print + sal_strlen(string_to_print) ,"%08x:", data->value[ARAD_PP_IHB_TCAM_DATA_WIDTH-indx-1]);
    }
    LOG_DEBUG(BSL_LS_SOC_MEM,
              (BSL_META(SOC_DPP_MSG("%s\n\r"), string_to_print)));
    
    sal_sprintf(string_to_print, "      ");
    sal_sprintf(string_to_print + sal_strlen(string_to_print) ," ");
    for(indx = 0; indx < ARAD_PP_IHB_TCAM_DATA_WIDTH; ++indx) {
        sal_sprintf(string_to_print + sal_strlen(string_to_print) ,"%08x:", data->mask[ARAD_PP_IHB_TCAM_DATA_WIDTH-indx-1]);
    }
    LOG_DEBUG(BSL_LS_SOC_MEM,
              (BSL_META(SOC_DPP_MSG("%s\n\r"), string_to_print)));
#endif
    return;
}
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
STATIC 
void arad_tbl_access_buffer_print(uint32 *data, uint32 len)
{
    uint32
        indx;

    for(indx = 0; indx < len; ++indx) {
        LOG_CLI((BSL_META("%08x:"), data[len-indx-1]));
    }
    LOG_CLI((BSL_META("\n\r")));
    return;
}

#endif

/*
 * Read indirect table nif_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_nif_ctxt_map_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IRE_NIF_CTXT_MAP_TBL_DATA* IRE_nif_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_NIF_CTXT_MAP_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_NIF_CTXT_MAP_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IRE_nif_ctxt_map_tbl_data,
          0x0,
          sizeof(ARAD_IRE_NIF_CTXT_MAP_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IRE_NIF_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IRE_nif_ctxt_map_tbl_data->reassembly_context = soc_mem_field32_get(
                  unit,
                  IRE_NIF_CTXT_MAPm,
                  data,
                  REASSEMBLY_CONTEXTf);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

    if(SOC_E_NONE == err) {
          IRE_nif_ctxt_map_tbl_data->port_termination_context = soc_mem_field32_get(
                  unit,
                  IRE_NIF_CTXT_MAPm,
                  data,
                  PORT_TERMINATION_CONTEXTf);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_nif_ctxt_map_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table nif_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_nif_ctxt_map_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IRE_NIF_CTXT_MAP_TBL_DATA* IRE_nif_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_NIF_CTXT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_NIF_CTXT_MAP_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(
          unit,
          IRE_NIF_CTXT_MAPm,
          data,
          REASSEMBLY_CONTEXTf,
          IRE_nif_ctxt_map_tbl_data->reassembly_context );

  soc_mem_field32_set(
          unit,
          IRE_NIF_CTXT_MAPm,
          data,
          PORT_TERMINATION_CONTEXTf,
          IRE_nif_ctxt_map_tbl_data->port_termination_context );

  err = soc_mem_write(
          unit,
          IRE_NIF_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_nif_ctxt_map_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table rcy_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_rcy_ctxt_map_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IRE_RCY_CTXT_MAP_TBL_DATA* IRE_rcy_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_RCY_CTXT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_RCY_CTXT_MAP_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IRE_rcy_ctxt_map_tbl_data,
          0x0,
          sizeof(ARAD_IRE_RCY_CTXT_MAP_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IRE_RCY_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);


  IRE_rcy_ctxt_map_tbl_data->reassembly_context   = soc_mem_field32_get(
                  unit,
                  IRE_RCY_CTXT_MAPm,
                  data,
                  REASSEMBLY_CONTEXTf            );

  IRE_rcy_ctxt_map_tbl_data->port_termination_context   = soc_mem_field32_get(
                  unit,
                  IRE_RCY_CTXT_MAPm,
                  data,
                  PORT_TERMINATION_CONTEXTf            );

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_rcy_ctxt_map_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table rcy_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_rcy_ctxt_map_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IRE_RCY_CTXT_MAP_TBL_DATA* IRE_rcy_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_RCY_CTXT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_RCY_CTXT_MAP_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(
          unit,
          IRE_RCY_CTXT_MAPm,
          data,
          PORT_TERMINATION_CONTEXTf,
          IRE_rcy_ctxt_map_tbl_data->port_termination_context );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  soc_mem_field32_set(
          unit,
          IRE_RCY_CTXT_MAPm,
          data,
          REASSEMBLY_CONTEXTf,
          IRE_rcy_ctxt_map_tbl_data->reassembly_context );

  err = soc_mem_write(
          unit,
          IRE_RCY_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_rcy_ctxt_map_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table rcy_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_cpu_ctxt_map_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IRE_CPU_CTXT_MAP_TBL_DATA* IRE_cpu_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_CPU_CTXT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_CPU_CTXT_MAP_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IRE_cpu_ctxt_map_tbl_data,
          0x0,
          sizeof(ARAD_IRE_CPU_CTXT_MAP_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IRE_CPU_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);


    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IRE_cpu_ctxt_map_tbl_data->reassembly_context   = soc_mem_field32_get(
                  unit,
                  IRE_CPU_CTXT_MAPm,
                  data,
                  REASSEMBLY_CONTEXTf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

    if(SOC_E_NONE == err) {
          IRE_cpu_ctxt_map_tbl_data->port_termination_context   = soc_mem_field32_get(
                  unit,
                  IRE_CPU_CTXT_MAPm,
                  data,
                  PORT_TERMINATION_CONTEXTf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_cpu_ctxt_map_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table rcy_ctxt_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ire_cpu_ctxt_map_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IRE_CPU_CTXT_MAP_TBL_DATA* IRE_cpu_ctxt_map_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IRE_CPU_CTXT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_CPU_CTXT_MAP_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IRE_CPU_CTXT_MAPm,
          data,
          PORT_TERMINATION_CONTEXTf,
          IRE_cpu_ctxt_map_tbl_data->port_termination_context );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IRE_CPU_CTXT_MAPm,
          data,
          REASSEMBLY_CONTEXTf,
          IRE_cpu_ctxt_map_tbl_data->reassembly_context );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IRE_CPU_CTXT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_cpu_ctxt_map_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table dynamic_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

int
  arad_iqm_dynamic_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_DYNAMIC_TBL_DATA* IQM_dynamic_tbl_data
  )
{
    uint32 err;
    uint32 data[ARAD_IQM_DYNAMIC_TBL_ENTRY_SIZE];
    int core_index = (core == SOC_CORE_ALL) ? 0 : core;
 
    SOCDNX_INIT_FUNC_DEFS;

    err = soc_sand_os_memset(&(data[0]),0x0,sizeof(data));
    SOCDNX_SAND_IF_ERR_EXIT(err);

    err = soc_sand_os_memset(IQM_dynamic_tbl_data, 0x0, sizeof(ARAD_IQM_DYNAMIC_TBL_DATA));
    SOCDNX_SAND_IF_ERR_EXIT(err);

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IQM_PQDMDm, IQM_BLOCK(unit, core_index), entry_offset, data));

    IQM_dynamic_tbl_data->pq_head_ptr   = soc_mem_field32_get(unit, IQM_PQDMDm, data, PQ_HEAD_PTRf);

    IQM_dynamic_tbl_data->que_not_empty   = soc_mem_field32_get(unit, IQM_PQDMDm, data, QUE_NOT_EMPTYf);

    IQM_dynamic_tbl_data->pq_inst_que_size   = soc_mem_field32_get(unit, IQM_PQDMDm, data, PQ_INST_QUE_SIZEf);

    IQM_dynamic_tbl_data->pq_inst_que_buff_size   = soc_mem_field32_get(unit, IQM_PQDMDm, data, PQ_INST_QUE_BUFF_SIZEf);

    IQM_dynamic_tbl_data->pq_avrg_szie   = soc_mem_field32_get(unit, IQM_PQDMDm, data, PQ_AVRG_SIZEf);

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table dynamic_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_dynamic_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_DYNAMIC_TBL_DATA* IQM_dynamic_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_DYNAMIC_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_DYNAMIC_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_MEM_8000000m,
          data,
          ITEM_0_20f /* PQ_HEAD_PTRf */,
          IQM_dynamic_tbl_data->pq_head_ptr );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_MEM_8000000m,
          data,
          ITEM_21_21f /* QUE_NOT_EMPTYf */,
          IQM_dynamic_tbl_data->que_not_empty );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_MEM_8000000m,
          data,
          ITEM_22_48f /* PQ_INST_QUE_SIZEf */,
          IQM_dynamic_tbl_data->pq_inst_que_size );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_MEM_8000000m,
          data,
          ITEM_49_69f /* PQ_INST_QUE_BUFF_SIZE */,
          IQM_dynamic_tbl_data->pq_inst_que_buff_size );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_MEM_8000000m,
          data,
          ITEM_70_81f /* PQ_AVRG_SZIEf */,
          IQM_dynamic_tbl_data->pq_avrg_szie );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

  err = soc_mem_write(
          unit,
          IQM_MEM_8000000m,
          IQM_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_dynamic_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table static_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

int
  arad_iqm_static_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_STATIC_TBL_DATA* IQM_static_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_STATIC_TBL_ENTRY_SIZE];
  int core_index = (core == SOC_CORE_ALL) ? 0 : core;
 
  SOCDNX_INIT_FUNC_DEFS;

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOCDNX_SAND_IF_ERR_EXIT(err);

  err = soc_sand_os_memset(IQM_static_tbl_data, 0x0, sizeof(ARAD_IQM_STATIC_TBL_DATA));
  SOCDNX_SAND_IF_ERR_EXIT(err);
 
  SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IQM_PQDMSm, IQM_BLOCK(unit, core_index), entry_offset, data));

  IQM_static_tbl_data->credit_class   = soc_mem_field32_get(unit, IQM_PQDMSm, data, CREDIT_CLASSf);

  IQM_static_tbl_data->rate_class   = soc_mem_field32_get(unit, IQM_PQDMSm, data, RATE_CLASSf);

  IQM_static_tbl_data->connection_class   = soc_mem_field32_get(unit, IQM_PQDMSm, data, CONNECTION_CLASSf);

  IQM_static_tbl_data->traffic_class   = soc_mem_field32_get(unit, IQM_PQDMSm, data, TRAFFIC_CLASSf);

  IQM_static_tbl_data->que_signature   = soc_mem_field32_get(unit, IQM_PQDMSm, data, QUE_SIGNATUREf);

exit:
  SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table static_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

int
  arad_iqm_static_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_STATIC_TBL_DATA* IQM_static_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_STATIC_TBL_ENTRY_SIZE];
 
  SOCDNX_INIT_FUNC_DEFS;

  err = soc_sand_os_memset(&(data[0]), 0x0,sizeof(data));
  SOCDNX_SAND_IF_ERR_EXIT(err);

  soc_mem_field32_set(unit,IQM_PQDMSm, data, CREDIT_CLASSf, IQM_static_tbl_data->credit_class);

  soc_mem_field32_set(unit, IQM_PQDMSm, data, RATE_CLASSf, IQM_static_tbl_data->rate_class);

  soc_mem_field32_set(unit,IQM_PQDMSm, data, CONNECTION_CLASSf, IQM_static_tbl_data->connection_class);

  soc_mem_field32_set(unit, IQM_PQDMSm, data, TRAFFIC_CLASSf, IQM_static_tbl_data->traffic_class);

  soc_mem_field32_set(unit, IQM_PQDMSm, data, QUE_SIGNATUREf, IQM_static_tbl_data->que_signature);

  err = soc_mem_write(unit, IQM_PQDMSm, MEM_BLOCK_ANY, entry_offset,data);
  SOCDNX_SAND_IF_ERR_EXIT(err);

exit:
  SOCDNX_FUNC_RETURN;
}

/*
 * Read indirect table packet_queue_red_weight_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_packet_queue_red_weight_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_DATA* IQM_packet_queue_red_weight_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_packet_queue_red_weight_table_tbl_data,
          0x0,
          sizeof(ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

   err = soc_mem_read(
          unit,
          IQM_PQWQm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err=SOC_E_NONE;
  if(SOC_E_NONE == err) {
          IQM_packet_queue_red_weight_table_tbl_data->pq_weight   = soc_mem_field32_get(
                  unit,
                  IQM_PQWQm,
                  data,
                  PQ_WEIGHTf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

  if(SOC_E_NONE == err) {
          IQM_packet_queue_red_weight_table_tbl_data->avrg_en   = soc_mem_field32_get(
                  unit,
                  IQM_PQWQm,
                  data,
                  PQ_AVRG_ENf);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_weight_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table packet_queue_red_weight_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_packet_queue_red_weight_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_DATA* IQM_packet_queue_red_weight_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_WEIGHT_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err=SOC_E_NONE;
  if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_PQWQm,
          data,
          PQ_WEIGHTf,
          IQM_packet_queue_red_weight_table_tbl_data->pq_weight );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_PQWQm,
          data,
          PQ_AVRG_ENf,
          IQM_packet_queue_red_weight_table_tbl_data->avrg_en );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  err = soc_mem_write(
          unit,
          IQM_PQWQm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_weight_table_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table credit_discount_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_credit_discount_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_DATA* IQM_credit_discount_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_ENTRY_SIZE];
  uint32 fld_val;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  if (!SOC_IS_QAX(unit)) {
  err = soc_sand_os_memset(
          IQM_credit_discount_table_tbl_data,
          0x0,
          sizeof(ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IQM_CRDTDISm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);

  err=SOC_E_NONE;
  if (SOC_IS_JERICHO(unit)) {
      int val, sign;
      /*There is only one field in jerticho discout value, where the sign value should be the MSB*/
      fld_val = soc_mem_field32_get(
                    unit,
                    IQM_CRDTDISm,
                    data,
                    DATAf);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
      /* Fld_val is represented in 2's complement */
      sign =  fld_val >> ARAD_IQM_CRDTDIS_DATA_NOF_BITS;
      val = fld_val;
      if (sign) {
          val = ~(val - 1);
      }
      IQM_credit_discount_table_tbl_data->crdt_disc_val = val;
      IQM_credit_discount_table_tbl_data->discnt_sign = sign;
  } else {
      if(SOC_E_NONE == err) {
            IQM_credit_discount_table_tbl_data->crdt_disc_val = soc_mem_field32_get(
                    unit,
                    IQM_CRDTDISm,
                    data,
                    CRDT_DISC_VALf);
          }
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
      if(SOC_E_NONE == err) {
            IQM_credit_discount_table_tbl_data->discnt_sign = soc_mem_field32_get(
                    unit,
                    IQM_CRDTDISm,
                    data,
                    DISCNT_SIGNf);
          }
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
  }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_credit_discount_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table credit_discount_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_credit_discount_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_DATA* IQM_credit_discount_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CREDIT_DISCOUNT_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
 
err=SOC_E_NONE;
if (!SOC_IS_QAX(unit)) {
  if (SOC_IS_JERICHO(unit)) {
      int sign =  (IQM_credit_discount_table_tbl_data->discnt_sign & 1) << ARAD_IQM_CRDTDIS_DATA_NOF_BITS;
      int val = (IQM_credit_discount_table_tbl_data->crdt_disc_val & 0x7F);
      if (sign) {
          val = ((~val & 0x7F) + 1) | sign;
      }
      /*There is only one field in jerticho discout value, where the sign value should be the MSB*/
      soc_mem_field32_set(
        unit,
        IQM_CRDTDISm,
        data,
        DATAf,
        val);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);
  } else {
      if(SOC_E_NONE == err) {
            soc_mem_field32_set(
              unit,
              IQM_CRDTDISm,
              data,
              CRDT_DISC_VALf,
              IQM_credit_discount_table_tbl_data->crdt_disc_val );
            }
        SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
      if(SOC_E_NONE == err) {
            soc_mem_field32_set(
              unit,
              IQM_CRDTDISm,
              data,
              DISCNT_SIGNf,
              IQM_credit_discount_table_tbl_data->discnt_sign );
      }
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
  }
  err = soc_mem_write(
          unit,
          IQM_CRDTDISm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);
}
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_credit_discount_table_tbl_set_unsafe()",0,0);
}

/* 
 * This procedure is meant to determine the number of bits in the mantissa for 
 * max queue size, 
 * and max queue size in BDs. 
 *  
 * Arad and Jericho share this code, 
 * But they have different values in the mantissa exponnent, for taildrop configuration
 * Moreover the CNRED/PQRED configuartion are different in Jericho.
 */
uint32
    arad_iqm_packet_queue_red_parameters_tail_drop_mantissa_nof_bits (
       SOC_SAND_IN   int             unit,
       SOC_SAND_IN   uint32             drop_precedence_ndx,
       SOC_SAND_OUT  uint32*            max_mantissa_size,
       SOC_SAND_OUT  uint32*            max_bds_mantissa_size
       )
{
    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TAIL_DROP_MANTISSA_NOF_BITS);
    if (drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE) {
        /* 
         * If receives drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE will read from the ECN (IQM_CNREDm) configuration.
         */
        if (SOC_IS_JERICHO(unit)){
            *max_mantissa_size = JERICHO_IQM_CNRED_PQ_MAX_QUE_SIZE_MANTISSA;
            *max_bds_mantissa_size = JERICHO_IQM_CNRED_PQ_MAX_QUE_BUFF_SIZE_MANTISSA;
        } else {
            *max_mantissa_size = ARAD_IQM_CNRED_PQ_MAX_QUE_SIZE_MANTISSA;
            *max_bds_mantissa_size = ARAD_IQM_CNRED_PQ_MAX_QUE_BUFF_SIZE_MANTISSA;
        }
    } else {
        /* 
         * If receives drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE will read from the IQM_PQRED configuration.
         */
        if (SOC_IS_JERICHO(unit)){
            *max_mantissa_size = JERICHO_IQM_PQRED_PQ_MAX_QUE_SIZE_MANTISSA;
            *max_bds_mantissa_size = JERICHO_IQM_PQRED_PQ_MAX_QUE_BUFF_SIZE_MANTISSA;
        } else {
            *max_mantissa_size = ARAD_IQM_PQRED_PQ_MAX_QUE_SIZE_MANTISSA;
            *max_bds_mantissa_size = ARAD_IQM_PQRED_PQ_MAX_QUE_BUFF_SIZE_MANTISSA;
         }
    }
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_parameters_tail_drop_mantissa_nof_bits()",0, drop_precedence_ndx);
}
/*
 * Read indirect table packet_queue_red_parameters_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 *
 * If receives drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE will read from the ECN (IQM_CNREDm) configuration.
 */
uint32
  arad_iqm_packet_queue_red_parameters_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32             rt_cls_ndx,
    SOC_SAND_IN   uint32             drop_precedence_ndx,
    SOC_SAND_OUT  ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_DATA* IQM_packet_queue_red_parameters_table_tbl_data
  )
{
  uint32 exp_man, err;
  uint32 entry_offset, data[ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE] = {0};
  soc_mem_t mem;
  int32 
      core_id = 0;
  uint32 
      max_mantissa_size,
      max_bds_mantissa_size ;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_GET_UNSAFE);

  SOC_SAND_CHECK_FUNC_RESULT(soc_sand_os_memset(IQM_packet_queue_red_parameters_table_tbl_data, 0x0,
    sizeof(ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_DATA)), 15, exit);
  if (drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE) {
    mem = IQM_CNREDm;
    entry_offset = rt_cls_ndx;
  } else { 
    mem = IQM_PQREDm;
    entry_offset = (rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;
  }
  err = arad_iqm_packet_queue_red_parameters_tail_drop_mantissa_nof_bits(unit,
                                                                         drop_precedence_ndx,
                                                                         &max_mantissa_size,
                                                                         &max_bds_mantissa_size);
  SOC_SAND_CHECK_FUNC_RESULT(err, 20, exit);
  
  err = soc_mem_read(unit, mem, IQM_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  exp_man = soc_mem_field32_get(unit, mem, data, PQ_MAX_QUE_SIZEf);
  arad_iqm_mantissa_exponent_get(unit, exp_man, max_mantissa_size,
    &(IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_mnt),
    &(IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_exp));

  exp_man = soc_mem_field32_get(unit, mem, data, PQ_MAX_QUE_BUFF_SIZEf);
  arad_iqm_mantissa_exponent_get(unit, exp_man, max_bds_mantissa_size,
    &(IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_bds_mnt),
    &(IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_bds_exp));

  IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_en = soc_mem_field32_get(unit, mem, data, PQ_WRED_ENf);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_c2 = soc_mem_field32_get(unit, mem, data, PQ_C_2f);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_c3 = soc_mem_field32_get(unit, mem, data, PQ_C_3f);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_c1 = soc_mem_field32_get(unit, mem, data, PQ_C_1f);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_max_th = soc_mem_field32_get(unit, mem, data, PQ_AVRG_MAX_THf);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_min_th = soc_mem_field32_get(unit, mem, data, PQ_AVRG_MIN_THf);
  IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_pckt_sz_ignr = soc_mem_field32_get(unit, mem, data, PQ_WRED_PCKT_SZ_IGNRf);
  IQM_packet_queue_red_parameters_table_tbl_data->addmit_logic =
    drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE ? 0 :
    soc_mem_field32_get(unit, IQM_PQREDm, data, ADDMIT_LOGICf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_parameters_table_tbl_get_unsafe()", rt_cls_ndx, drop_precedence_ndx);
}

/*
 * Write indirect table packet_queue_red_parameters_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 *
 * If receives drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE will read from the ECN (IQM_CNREDm) configuration.
 */

uint32
  arad_iqm_packet_queue_red_parameters_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32             rt_cls_ndx,
    SOC_SAND_IN   uint32             drop_precedence_ndx,
    SOC_SAND_IN   ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_DATA* IQM_packet_queue_red_parameters_table_tbl_data
  )
{
  uint32 exp_man, err, entry_offset, data[ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE] = {0};
  soc_mem_t mem;
  int32 
      core_id = SOC_CORE_ALL;
  uint32 
      max_mantissa_size,
      max_bds_mantissa_size;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_SET_UNSAFE);

  if (drop_precedence_ndx == SOC_TMC_NOF_DROP_PRECEDENCE) {
    mem = IQM_CNREDm;
    entry_offset = rt_cls_ndx;
  } else { 
    mem = IQM_PQREDm;
    entry_offset = (rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;
  }
  err = arad_iqm_packet_queue_red_parameters_tail_drop_mantissa_nof_bits(unit,
                                                                   drop_precedence_ndx,
                                                                   &max_mantissa_size,
                                                                   &max_bds_mantissa_size);
  SOC_SAND_CHECK_FUNC_RESULT(err, 20, exit);
  
  arad_iqm_mantissa_exponent_set(unit,
      IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_mnt,
      IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_exp,
      max_mantissa_size, &exp_man);
  soc_mem_field32_set(unit, mem, data, PQ_MAX_QUE_SIZEf, exp_man);

  arad_iqm_mantissa_exponent_set( unit,
      IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_bds_mnt,
      IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_bds_exp,
      max_bds_mantissa_size, &exp_man);
  soc_mem_field32_set(unit, mem, data, PQ_MAX_QUE_BUFF_SIZEf, exp_man);

  soc_mem_field32_set(unit, mem, data, PQ_WRED_ENf, IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_en);
  soc_mem_field32_set(unit, mem, data, PQ_C_2f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c2);
  soc_mem_field32_set(unit, mem, data, PQ_C_3f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c3);
  soc_mem_field32_set(unit, mem, data, PQ_C_1f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c1);
  soc_mem_field32_set(unit, mem, data, PQ_AVRG_MAX_THf, IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_max_th);
  soc_mem_field32_set(unit, mem, data, PQ_AVRG_MIN_THf, IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_min_th);
  soc_mem_field32_set(unit, mem, data, PQ_WRED_PCKT_SZ_IGNRf, IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_pckt_sz_ignr);
  if (drop_precedence_ndx != SOC_TMC_NOF_DROP_PRECEDENCE) {
    soc_mem_field32_set(unit, IQM_PQREDm, data, ADDMIT_LOGICf, IQM_packet_queue_red_parameters_table_tbl_data->addmit_logic);
  }

  err = soc_mem_write(unit, mem, IQM_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_parameters_table_tbl_set_unsafe()",0,0);
}

/*
 * Fill indirect table packet_queue_red_parameters_table_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_packet_queue_red_parameters_table_tbl_fill_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_DATA* IQM_packet_queue_red_parameters_table_tbl_data
  )
{
  uint32 exp_man, err;
  uint32 data[ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_PACKET_QUEUE_RED_PARAMETERS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);

  arad_iqm_mantissa_exponent_set(unit, IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_mnt,
                                 IQM_packet_queue_red_parameters_table_tbl_data->pq_max_que_size_exp, 6, &exp_man);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_MAX_QUE_SIZEf, exp_man);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_WRED_ENf, IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_en);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_C_2f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c2);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_C_3f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c3);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_C_1f, IQM_packet_queue_red_parameters_table_tbl_data->pq_c1);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_AVRG_MAX_THf, IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_max_th);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_AVRG_MIN_THf, IQM_packet_queue_red_parameters_table_tbl_data->pq_avrg_min_th);
  soc_mem_field32_set(unit, IQM_PQREDm, data, PQ_WRED_PCKT_SZ_IGNRf, IQM_packet_queue_red_parameters_table_tbl_data->pq_wred_pckt_sz_ignr);
  soc_mem_field32_set(unit, IQM_PQREDm, data, ADDMIT_LOGICf, IQM_packet_queue_red_parameters_table_tbl_data->addmit_logic);

  err = arad_fill_table_with_entry(unit, IQM_PQREDm, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_packet_queue_red_parameters_table_tbl_fill_unsafe()",0,0);
}

uint32
  arad_ihb_fem_map_index_table_table_tbl_fill_unsafe(
    SOC_SAND_IN   int                                             unit,
    SOC_SAND_IN   ARAD_IHB_FEM_MAP_INDEX_TABLE_TBL_DATA* ihb_fem0_4b_1st_pass_map_index_table_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IHB_FEM0_4B_1ST_PASS_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(unit, IHB_FEM_MAP_INDEX_TABLEm, data, MAP_INDEXf, ihb_fem0_4b_1st_pass_map_index_table_tbl_data->map_index);
  soc_mem_field32_set(unit, IHB_FEM_MAP_INDEX_TABLEm, data, MAP_DATAf, ihb_fem0_4b_1st_pass_map_index_table_tbl_data->map_data);
  soc_mem_field32_set(unit, IHB_FEM_MAP_INDEX_TABLEm, data, VALIDf, ihb_fem0_4b_1st_pass_map_index_table_tbl_data->is_action_valid);

  err = arad_fill_table_with_entry(unit, IHB_FEM_MAP_INDEX_TABLEm, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_fem_map_index_table_table_tbl_fill_unsafe()",0,0);
}

uint32
  arad_ihb_fem_map_table_table_tbl_fill_unsafe(
    SOC_SAND_IN   int                                             unit,
    SOC_SAND_IN   ARAD_IHB_FEM_MAP_TABLE_TBL_DATA* arad_ihb_fem_map_table_table_tbl_fill_unsafe
  )
{
    uint32 tbl_ndx, bit_ndx, fem_id, output_size_in_bits;
  uint32 err, 
      fem_map_tbl_reference_index,
      res;
  uint32 tbl_data[ARAD_IHB_FEM0_4B_1ST_PASS_MAP_TABLE_TBL_ENTRY_SIZE];
  ARAD_PMF_FEM_NDX   
      fem_ndx;
  soc_mem_t
      fem_map_table_reference,
      fem_map_table;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  err = soc_sand_os_memset(&(tbl_data[0]), 0x0, sizeof(tbl_data));
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);

  ARAD_PMF_FEM_NDX_clear(&fem_ndx);
  for (fem_id = 0; fem_id <= ARAD_PMF_LOW_LEVEL_FEM_ID_MAX; fem_id++) {
      fem_ndx.id = fem_id;
        res = arad_pmf_fem_output_size_get(
              unit,
              &fem_ndx,
              &output_size_in_bits
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

      /*
       *    Init the table data - set all the values to '0'
       */
      tbl_ndx = fem_id;
      fem_map_table = Arad_pmf_fem_map_tbl[tbl_ndx];
      fem_map_tbl_reference_index = (output_size_in_bits == ARAD_PMF_FEM_SIZE_1ST_SIZE)? 0:((output_size_in_bits == ARAD_PMF_FEM_SIZE_2ND_SIZE)? 1:2);
      res = arad_pmf_fem_map_tbl_reference(
              unit,
              fem_map_tbl_reference_index,
              &fem_map_table_reference
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

      for (bit_ndx = 0; bit_ndx < output_size_in_bits; ++bit_ndx)
      {
        soc_mem_field32_set(unit, fem_map_table_reference, tbl_data, Arad_pmf_fem_map_field_select_field[bit_ndx], 0x3e);
      }

      /*
       *    Set the table entry data
       */
      soc_mem_field32_set(unit, fem_map_table_reference, tbl_data, ACTION_TYPEf, 0x3c);

      if (output_size_in_bits != ARAD_PMF_FEM_SIZE_1ST_SIZE)
      {
        soc_mem_field32_set(unit, fem_map_table_reference, tbl_data, OFFSETf, 0x0);
      }

      err = arad_fill_table_with_entry(unit, fem_map_table, MEM_BLOCK_ANY, tbl_data); /* fill memory with the entry in data */
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_fem_map_table_table_tbl_fill_unsafe()",0,0);
}

/*
 * Read indirect table vsq_descriptor_rate_class_group_a_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_a_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_DATA* IQM_vsq_descriptor_rate_class_group_a_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_descriptor_rate_class_group_a_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IQM_VSQDRC_Am,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_descriptor_rate_class_group_a_tbl_data->vsq_rc_a   = soc_mem_field32_get(
                  unit,
                  IQM_VSQDRC_Am,
                  data,
                  VSQ_RC_Af            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_a_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_descriptor_rate_class_group_a_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_a_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_DATA* IQM_vsq_descriptor_rate_class_group_a_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_A_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_VSQDRC_Am,
          data,
          VSQ_RC_Af,
          IQM_vsq_descriptor_rate_class_group_a_tbl_data->vsq_rc_a );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IQM_VSQDRC_Am,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_a_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table vsq_descriptor_rate_class_group_b_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_b_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_DATA* IQM_vsq_descriptor_rate_class_group_b_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_descriptor_rate_class_group_b_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IQM_VSQDRC_Bm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_descriptor_rate_class_group_b_tbl_data->vsq_rc_b   = soc_mem_field32_get(
                  unit,
                  IQM_VSQDRC_Bm,
                  data,
                  VSQ_RC_Bf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_b_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_descriptor_rate_class_group_b_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_b_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_DATA* IQM_vsq_descriptor_rate_class_group_b_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_B_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_VSQDRC_Bm,
          data,
          VSQ_RC_Bf,
          IQM_vsq_descriptor_rate_class_group_b_tbl_data->vsq_rc_b );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IQM_VSQDRC_Bm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_b_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table vsq_descriptor_rate_class_group_c_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_c_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_DATA* IQM_vsq_descriptor_rate_class_group_c_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_descriptor_rate_class_group_c_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IQM_VSQDRC_Cm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_descriptor_rate_class_group_c_tbl_data->vsq_rc_c   = soc_mem_field32_get(
                  unit,
                  IQM_VSQDRC_Cm,
                  data,
                  VSQ_RC_Cf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_c_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_descriptor_rate_class_group_c_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_c_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_DATA* IQM_vsq_descriptor_rate_class_group_c_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_C_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_VSQDRC_Cm,
          data,
          VSQ_RC_Cf,
          IQM_vsq_descriptor_rate_class_group_c_tbl_data->vsq_rc_c );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IQM_VSQDRC_Cm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_c_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table vsq_descriptor_rate_class_group_d_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_d_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_DATA* IQM_vsq_descriptor_rate_class_group_d_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_descriptor_rate_class_group_d_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IQM_VSQDRC_Dm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_descriptor_rate_class_group_d_tbl_data->vsq_rc_d   = soc_mem_field32_get(
                  unit,
                  IQM_VSQDRC_Dm,
                  data,
                  VSQ_RC_Df            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_d_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_descriptor_rate_class_group_d_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_descriptor_rate_class_group_d_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_DATA* IQM_vsq_descriptor_rate_class_group_d_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_DESCRIPTOR_RATE_CLASS_GROUP_D_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_VSQDRC_Dm,
          data,
          VSQ_RC_Df,
          IQM_vsq_descriptor_rate_class_group_d_tbl_data->vsq_rc_d );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IQM_VSQDRC_Dm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_descriptor_rate_class_group_d_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table vsq_flow_control_parameters_table_group_a_tbl from block IQM,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */


void
  arad_iqm_mantissa_exponent_get(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              reg_val,
    SOC_SAND_IN   uint32              mantissa_size,
    SOC_SAND_OUT  uint32              *mantissa,
    SOC_SAND_OUT  uint32              *exponent
  )
{
    *mantissa = SOC_SAND_GET_BITS_RANGE(reg_val, mantissa_size - 1, 0);
    *exponent = reg_val >> mantissa_size;
}


void
  arad_iqm_mantissa_exponent_set(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              mantissa,
    SOC_SAND_IN   uint32              exponent,
    SOC_SAND_IN   uint32              mantissa_size,
    SOC_SAND_OUT  uint32              *reg_val
  )
{
    *reg_val = mantissa + (exponent << mantissa_size);
}

/* abstraction of the IQM_VQFCPR_M tables */
const soc_mem_t mem_arr_IQM_VQFCPR_M[ARAD_NOF_VSQ_GROUPS] = {IQM_VQFCPR_MAm, IQM_VQFCPR_MBm, IQM_VQFCPR_MCm, IQM_VQFCPR_MDm, IQM_VQFCPR_MEm, IQM_VQFCPR_MFm};

uint32
  arad_iqm_vsq_flow_control_parameters_table_group_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              group_id,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_DATA* IQM_vsq_flow_control_parameters_table_group_tbl_data
  )
{
  uint32
      mnt_exp = 0,
    err;
  uint32
    data[ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_GET_UNSAFE);

  SOC_SAND_ERR_IF_ABOVE_MAX(
    group_id, ARAD_NOF_VSQ_GROUPS-1,
    ARAD_ITM_VSQ_GROUP_ID_OUT_OF_RANGE_ERR, 5, exit
  );

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_flow_control_parameters_table_group_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_flow_control_parameters_table_group_tbl_data->wred_en   = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  WRED_ENf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_flow_control_parameters_table_group_tbl_data->avrg_size_en   = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  AVRG_SIZE_ENf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_flow_control_parameters_table_group_tbl_data->red_weight_q   = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  RED_WEIGHT_Qf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

    if(SOC_E_NONE == err) {
        mnt_exp = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  SET_THRESHOLD_WORDSf            );

    arad_iqm_mantissa_exponent_get(
        unit,
        mnt_exp,
        5,
        &(IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_mnt),
        &(IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_exp));
    
            
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

    if(SOC_E_NONE == err) {
        mnt_exp = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  CLEAR_THRESHOLD_WORDSf            );
        arad_iqm_mantissa_exponent_get(
            unit,
            mnt_exp,
            5,
            &(IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_mnt),
            &(IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_exp));
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);

    if(SOC_E_NONE == err) {
          mnt_exp = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  SET_THRESHOLD_BDf            );
          arad_iqm_mantissa_exponent_get(
              unit,
              mnt_exp,
              4,
              &(IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_mnt),
              &(IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_exp));
             
                 
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 47, exit);


    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
            mnt_exp = soc_mem_field32_get(
                  unit,
                  mem_arr_IQM_VQFCPR_M[group_id],
                  data,
                  CLEAR_THRESHOLD_BDf            );
            arad_iqm_mantissa_exponent_get(
                unit,
                mnt_exp,
                4,
                &(IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_mnt),
                &(IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_exp));
             }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 49, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_flow_control_parameters_table_group_a_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_flow_control_parameters_table_group_a_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_flow_control_parameters_table_group_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              group_id,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_DATA* IQM_vsq_flow_control_parameters_table_group_tbl_data
  )
{
  uint32
    mnt_exp,
    err;
  uint32
    data[ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_SET_UNSAFE);

  SOC_SAND_ERR_IF_ABOVE_MAX(
    group_id, ARAD_NOF_VSQ_GROUPS-1,
    ARAD_ITM_VSQ_GROUP_ID_OUT_OF_RANGE_ERR, 5, exit
  );

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          WRED_ENf,
          IQM_vsq_flow_control_parameters_table_group_tbl_data->wred_en );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          AVRG_SIZE_ENf,
          IQM_vsq_flow_control_parameters_table_group_tbl_data->avrg_size_en );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          RED_WEIGHT_Qf,
          IQM_vsq_flow_control_parameters_table_group_tbl_data->red_weight_q );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_mnt,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_exp,
      5,
      &mnt_exp);


if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          SET_THRESHOLD_WORDSf,
          mnt_exp );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_mnt,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_exp,
      5,
      &mnt_exp);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          CLEAR_THRESHOLD_WORDSf,
          mnt_exp);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);


  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_mnt,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_exp,
      4,
      &mnt_exp);
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          SET_THRESHOLD_BDf,
          mnt_exp );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 37, exit);

  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_mnt,
      IQM_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_exp,
      4,
      &mnt_exp);
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          data,
          CLEAR_THRESHOLD_BDf,
          mnt_exp);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 39, exit);

  err = soc_mem_write(
          unit,
          mem_arr_IQM_VQFCPR_M[group_id],
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 37, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_flow_control_parameters_table_group_a_tbl_set_unsafe()",0,0);
}

/* abstraaction of the IQM_VQPR_M? tables */
const soc_mem_t mem_arr_IQM_VQPR_M[ARAD_NOF_VSQ_GROUPS] = {IQM_VQPR_MAm, IQM_VQPR_MBm,IQM_VQPR_MCm,IQM_VQPR_MDm,IQM_VQPR_MEm,IQM_VQPR_MFm};
/*
 * Read indirect table vsq_queue_parameters_table_group_a_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_queue_parameters_table_group_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              group_id,
    SOC_SAND_IN   uint32              vsq_rt_cls_ndx,
    SOC_SAND_IN   uint32             drop_precedence_ndx,
    SOC_SAND_OUT  ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_DATA* IQM_vsq_queue_parameters_table_group_tbl_data
  )
{
  uint32
      exp_man,
    err;
  uint32
    entry_offset,
    data[ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_A_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_GET_UNSAFE);

  SOC_SAND_ERR_IF_ABOVE_MAX(
    group_id, ARAD_NOF_VSQ_GROUPS-1,
    ARAD_ITM_VSQ_GROUP_ID_OUT_OF_RANGE_ERR, 5, exit
  );

  /* since IQM_VQPR_M[A-F] have the same fields in hardware, but currently in the description
     IQM_VQPR_M[E-F] have different fields, we use mem_arr_IQM_VQPR_M[group_id] for memory
     access and IQM_VQPR_MAm for filed access */
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_vsq_queue_parameters_table_group_tbl_data,
          0x0,
          sizeof(ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  entry_offset =
    (vsq_rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;



  err = soc_mem_read(
          unit,
          mem_arr_IQM_VQPR_M[group_id],
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->c2   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  C_2f            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->c3   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  C_3f            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->c1   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  C_1f            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->max_avrg_th   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  MAX_AVRG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->min_avrg_th   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  MIN_AVRG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);
    if(SOC_E_NONE == err) {
          IQM_vsq_queue_parameters_table_group_tbl_data->vq_wred_pckt_sz_ignr   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  VQ_WRED_PCKT_SZ_IGNRf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);

    if(SOC_E_NONE == err) {
          exp_man = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  VQ_MAX_SIZE_BDSf            );

          arad_iqm_mantissa_exponent_get(
              unit,
              exp_man,
              7,
              &(IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_mnt),
              &(IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_exp)
              );

        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 46, exit);

    if(SOC_E_NONE == err) {
          exp_man   = soc_mem_field32_get(
                  unit,
                  IQM_VQPR_MAm,
                  data,
                  VQ_MAX_SIZE_WORDSf            );
          arad_iqm_mantissa_exponent_get(
              unit,
              exp_man,
              7,
              &(IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_mnt),
              &(IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_exp)
              );

        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 48, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_queue_parameters_table_group_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table vsq_queue_parameters_table_group_a_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_queue_parameters_table_group_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              group_id,
    SOC_SAND_IN   uint32              vsq_rt_cls_ndx,
    SOC_SAND_IN   uint32             drop_precedence_ndx,
    SOC_SAND_IN   ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_DATA* IQM_vsq_queue_parameters_table_group_tbl_data
  )
{
  uint32
    err;
  uint32
    entry_offset,
      exp_man,
    data[ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_A_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_SET_UNSAFE);

  SOC_SAND_ERR_IF_ABOVE_MAX(
    group_id, ARAD_NOF_VSQ_GROUPS-1,
    ARAD_ITM_VSQ_GROUP_ID_OUT_OF_RANGE_ERR, 5, exit
  );

  /* since IQM_VQPR_M[A-F] have the same fields in hardware, but currently in the description
     IQM_VQPR_M[E-F] have different fields, we use mem_arr_IQM_VQPR_M[group_id] for memory
     access and IQM_VQPR_MAm for filed access */
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  entry_offset =
    (vsq_rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;



  err=SOC_E_NONE;
  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          C_2f,
          IQM_vsq_queue_parameters_table_group_tbl_data->c2 );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          C_3f,
          IQM_vsq_queue_parameters_table_group_tbl_data->c3 );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          C_1f,
          IQM_vsq_queue_parameters_table_group_tbl_data->c1 );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          MAX_AVRG_THf,
          IQM_vsq_queue_parameters_table_group_tbl_data->max_avrg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          MIN_AVRG_THf,
          IQM_vsq_queue_parameters_table_group_tbl_data->min_avrg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);
  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          VQ_WRED_PCKT_SZ_IGNRf,
          IQM_vsq_queue_parameters_table_group_tbl_data->vq_wred_pckt_sz_ignr );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_mnt,
      IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_exp,
      7,
      &exp_man
     );

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          VQ_MAX_SIZE_BDSf,
          exp_man);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 36, exit);

  arad_iqm_mantissa_exponent_set(
      unit,
      IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_mnt,
      IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_exp,
      7,
      &exp_man
     );

  if(SOC_E_NONE == err) {
          soc_mem_field32_set(
          unit,
          IQM_VQPR_MAm,
          data,
          VQ_MAX_SIZE_WORDSf,
          exp_man);
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 38, exit);

  err = soc_mem_write(
          unit,
          mem_arr_IQM_VQPR_M[group_id],
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_queue_parameters_table_group_a_tbl_set_unsafe()",0,0);
}


/*
 * Init indirect table vsq_queue_parameters_table_group_a_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_vsq_queue_parameters_table_group_tbl_fill_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_DATA* IQM_vsq_queue_parameters_table_group_tbl_data
  )
{
  uint32 err;
  uint32 exp_man, data[ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_A_TBL_ENTRY_SIZE];
  unsigned group_id;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_SET_UNSAFE);
  /* since IQM_VQPR_M[A-F] have the same fields in hardware, but currently in the description
     IQM_VQPR_M[E-F] have different fields, we use mem_arr_IQM_VQPR_M[group_id] for memory
     access and IQM_VQPR_MAm for filed access */

  err = soc_sand_os_memset( &(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, C_2f, IQM_vsq_queue_parameters_table_group_tbl_data->c2);
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, C_3f, IQM_vsq_queue_parameters_table_group_tbl_data->c3);
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, C_1f, IQM_vsq_queue_parameters_table_group_tbl_data->c1 );
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, MAX_AVRG_THf, IQM_vsq_queue_parameters_table_group_tbl_data->max_avrg_th );
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, MIN_AVRG_THf, IQM_vsq_queue_parameters_table_group_tbl_data->min_avrg_th );
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, VQ_WRED_PCKT_SZ_IGNRf, IQM_vsq_queue_parameters_table_group_tbl_data->vq_wred_pckt_sz_ignr );

  arad_iqm_mantissa_exponent_set(unit, IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_mnt,
                                 IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_szie_bds_exp, 7, &exp_man);
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, VQ_MAX_SIZE_BDSf, exp_man);
  arad_iqm_mantissa_exponent_set(unit, IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_mnt,
                                 IQM_vsq_queue_parameters_table_group_tbl_data->vq_max_size_words_exp, 7, &exp_man);
  soc_mem_field32_set(unit, IQM_VQPR_MAm, data, VQ_MAX_SIZE_WORDSf, exp_man);


  for (group_id = 0; group_id < ARAD_NOF_VSQ_GROUPS; ++group_id) { /* loop over the 6 memories */
      err = arad_fill_table_with_entry(unit, mem_arr_IQM_VQPR_M[group_id] , MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_queue_parameters_table_group_a_tbl_fill_unsafe()",0,0);
}


uint32
  arad_iqm_vsq_flow_control_parameters_table_group_tbl_fill_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_DATA* iqm_vsq_flow_control_parameters_table_group_tbl_data
  )
{
  uint32 err;
  uint32 exp_man, data[ARAD_IQM_VSQ_FLOW_CONTROL_PARAMETERS_TABLE_GROUP_TBL_ENTRY_SIZE];
  unsigned group_id;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_VSQ_QUEUE_PARAMETERS_TABLE_GROUP_TBL_SET_UNSAFE);
  /* since IQM_VQPR_M[A-F] have the same fields in hardware, but currently in the description
     IQM_VQPR_M[E-F] have different fields, we use mem_arr_IQM_VQPR_M[group_id] for memory
     access and IQM_VQPR_MAm for filed access */

  err = soc_sand_os_memset( &(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);


  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, WRED_ENf, iqm_vsq_flow_control_parameters_table_group_tbl_data->wred_en);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, AVRG_SIZE_ENf, iqm_vsq_flow_control_parameters_table_group_tbl_data->avrg_size_en);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, RED_WEIGHT_Qf, iqm_vsq_flow_control_parameters_table_group_tbl_data->red_weight_q);

  arad_iqm_mantissa_exponent_set(unit, iqm_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_mnt,
                                 iqm_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_words_exp, 5, &exp_man);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, SET_THRESHOLD_WORDSf, exp_man);
  arad_iqm_mantissa_exponent_set(unit, iqm_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_mnt,
                                 iqm_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_words_exp, 5, &exp_man);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, CLEAR_THRESHOLD_WORDSf, exp_man);
  arad_iqm_mantissa_exponent_set(unit, iqm_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_mnt,
                                 iqm_vsq_flow_control_parameters_table_group_tbl_data->set_threshold_bd_exp, 4, &exp_man);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, SET_THRESHOLD_BDf, exp_man);
  arad_iqm_mantissa_exponent_set(unit, iqm_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_mnt,
                                 iqm_vsq_flow_control_parameters_table_group_tbl_data->clear_threshold_bd_exp, 4, &exp_man);
  soc_mem_field32_set(unit, IQM_VQFCPR_MAm, data, CLEAR_THRESHOLD_BDf, exp_man);


  for (group_id = 0; group_id < ARAD_NOF_VSQ_GROUPS; ++group_id) { /* loop over the 6 memories */
      err = arad_fill_table_with_entry(unit, mem_arr_IQM_VQFCPR_M[group_id] , MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_vsq_flow_control_parameters_table_group_tbl_fill_unsafe()",0,0);
}

/*
 * Read indirect table system_red_parameters_table_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_parameters_table_tbl_get_unsafe(
    SOC_SAND_IN   int                                       unit,
    SOC_SAND_IN   uint32                                        rt_cls_ndx,
    SOC_SAND_IN   uint32                                       drop_precedence_ndx,
    SOC_SAND_OUT  ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_DATA* IQM_system_red_parameters_table_tbl_data
  )
{
  uint32
    err;
  uint32
    entry_offset,
    data[ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_system_red_parameters_table_tbl_data,
          0x0,
          sizeof(ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 

  if (!SOC_IS_QAX(unit)) {
  entry_offset =
    (rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;



  err = soc_mem_read(
          unit,
          IQM_SPRDPRMm,
          MEM_BLOCK_ANY,
          entry_offset,
    data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

    err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_system_red_parameters_table_tbl_data->adm_th   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                  data,
                  ADM_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
        IQM_system_red_parameters_table_tbl_data->sys_red_en   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                data,
                  SRED_ENf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IQM_system_red_parameters_table_tbl_data->prob_th   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                  data,
                  PROB_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

    if(SOC_E_NONE == err) {
          IQM_system_red_parameters_table_tbl_data->drp_th   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                  data,
                  DRP_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

    if(SOC_E_NONE == err) {
          IQM_system_red_parameters_table_tbl_data->drp_prob_indx1   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                  data,
                  DRP_PROB_INDX_1f            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);

    if(SOC_E_NONE == err) {
          IQM_system_red_parameters_table_tbl_data->drp_prob_indx2   = soc_mem_field32_get(
                  unit,
                  IQM_SPRDPRMm,
                  data,
                  DRP_PROB_INDX_2f            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_parameters_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table system_red_parameters_table_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_parameters_table_tbl_set_unsafe(
    SOC_SAND_IN   int                                       unit,
    SOC_SAND_IN   uint32                                        rt_cls_ndx,
    SOC_SAND_IN   uint32                                       drop_precedence_ndx,
    SOC_SAND_IN   ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_DATA* IQM_system_red_parameters_table_tbl_data
  )
{
  uint32
    err;
  uint32
    entry_offset,
    data[ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_PARAMETERS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 
  if (!SOC_IS_QAX(unit)) {

  entry_offset =
    (rt_cls_ndx * ARAD_WRED_NOF_DROP_PRECEDENCE) + drop_precedence_ndx;



err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
        data,
          SRED_ENf,
        IQM_system_red_parameters_table_tbl_data->sys_red_en );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
          data,
          ADM_THf,
          IQM_system_red_parameters_table_tbl_data->adm_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
          data,
          PROB_THf,
          IQM_system_red_parameters_table_tbl_data->prob_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
          data,
          DRP_THf,
          IQM_system_red_parameters_table_tbl_data->drp_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
          data,
          DRP_PROB_INDX_1f,
          IQM_system_red_parameters_table_tbl_data->drp_prob_indx1 );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SPRDPRMm,
          data,
          DRP_PROB_INDX_2f,
          IQM_system_red_parameters_table_tbl_data->drp_prob_indx2 );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

  err = soc_mem_write(
          unit,
          IQM_SPRDPRMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_parameters_table_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table system_red_drop_probability_values_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_drop_probability_values_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_DATA* IQM_system_red_drop_probability_values_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_system_red_drop_probability_values_tbl_data,
          0x0,
          sizeof(ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 


  if (!SOC_IS_QAX(unit)) {

  err = soc_mem_read(
          unit,
          IQM_SRDPRBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IQM_system_red_drop_probability_values_tbl_data->drp_prob   = soc_mem_field32_get(
                  unit,
                  IQM_SRDPRBm,
                  data,
                  DRP_PROBf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_drop_probability_values_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table system_red_drop_probability_values_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_drop_probability_values_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_DATA* IQM_system_red_drop_probability_values_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_DROP_PROBABILITY_VALUES_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 

  if (!SOC_IS_QAX(unit)) {


err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IQM_SRDPRBm,
          data,
          DRP_PROBf,
          IQM_system_red_drop_probability_values_tbl_data->drp_prob );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IQM_SRDPRBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_drop_probability_values_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table system_red_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IQM_SYSTEM_RED_TBL_DATA* IQM_system_red_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_SYSTEM_RED_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IQM_system_red_tbl_data,
          0x0,
          sizeof(ARAD_IQM_SYSTEM_RED_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);
  if (!SOC_IS_QAX(unit)) {
   err = soc_mem_read(
          unit,
          IQM_SRCQRNGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  IQM_system_red_tbl_data->qsz_rng_th[0] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_0f);
  IQM_system_red_tbl_data->qsz_rng_th[1] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_1f);
  IQM_system_red_tbl_data->qsz_rng_th[2] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_2f);
  IQM_system_red_tbl_data->qsz_rng_th[3] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_3f);
  IQM_system_red_tbl_data->qsz_rng_th[4] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_4f);
  IQM_system_red_tbl_data->qsz_rng_th[5] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_5f);
  IQM_system_red_tbl_data->qsz_rng_th[6] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_6f);
  IQM_system_red_tbl_data->qsz_rng_th[7] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_7f);
  IQM_system_red_tbl_data->qsz_rng_th[8] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_8f);
  IQM_system_red_tbl_data->qsz_rng_th[9] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_9f);
  IQM_system_red_tbl_data->qsz_rng_th[10] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_10f);
  IQM_system_red_tbl_data->qsz_rng_th[11] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_11f);
  IQM_system_red_tbl_data->qsz_rng_th[12] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_12f);
  IQM_system_red_tbl_data->qsz_rng_th[13] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_13f);
  IQM_system_red_tbl_data->qsz_rng_th[14] = soc_mem_field32_get(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_14f);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table system_red_tbl from block IQM,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_iqm_system_red_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IQM_SYSTEM_RED_TBL_DATA* IQM_system_red_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IQM_SYSTEM_RED_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_SYSTEM_RED_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  if (!SOC_IS_QAX(unit)) {
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_0f, IQM_system_red_tbl_data->qsz_rng_th[0]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_1f, IQM_system_red_tbl_data->qsz_rng_th[1]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_2f, IQM_system_red_tbl_data->qsz_rng_th[2]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_3f, IQM_system_red_tbl_data->qsz_rng_th[3]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_4f, IQM_system_red_tbl_data->qsz_rng_th[4]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_5f, IQM_system_red_tbl_data->qsz_rng_th[5]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_6f, IQM_system_red_tbl_data->qsz_rng_th[6]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_7f, IQM_system_red_tbl_data->qsz_rng_th[7]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_8f, IQM_system_red_tbl_data->qsz_rng_th[8]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_9f, IQM_system_red_tbl_data->qsz_rng_th[9]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_10f, IQM_system_red_tbl_data->qsz_rng_th[10]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_11f, IQM_system_red_tbl_data->qsz_rng_th[11]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_12f, IQM_system_red_tbl_data->qsz_rng_th[12]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_13f, IQM_system_red_tbl_data->qsz_rng_th[13]);
  soc_mem_field32_set(unit, IQM_SRCQRNGm, data, QSZ_RNG_TH_14f, IQM_system_red_tbl_data->qsz_rng_th[14]);

  err = soc_mem_write(
          unit,
          IQM_SRCQRNGm,
          MEM_BLOCK_ANY,
          entry_offset,
            data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_system_red_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table system_physical_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_indirect_base_queue_to_system_physical_port_tbl_get_unsafe(
    SOC_SAND_IN  int unit,
    SOC_SAND_IN  int core,
    SOC_SAND_IN  uint32 entry_offset,
    SOC_SAND_OUT ARAD_BASE_Q_TO_SYS_PORT_TABLE_TBL_DATA* system_physical_port_tbl_data
  )
{
  uint32 err;
  int core_index = (core == SOC_CORE_ALL) ? 0 : core;
  uint32 data[ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE];
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_GET_UNSAFE);
  /* assert(ARAD_IS_VOQ_MAPPING_INDIRECT(unit)); */

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(system_physical_port_tbl_data, 0x0, sizeof(ARAD_BASE_Q_TO_SYS_PORT_TABLE_TBL_DATA));
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(unit, IPS_QPM_1_SYS_REDm, IPS_BLOCK(unit, core_index), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  system_physical_port_tbl_data->sys_phy_port = soc_mem_field32_get(unit, IPS_QPM_1_SYS_REDm, data, SYS_PHY_PORTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_indirect_base_queue_to_system_physical_port_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table system_physical_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_indirect_base_queue_to_system_physical_port_tbl_set_unsafe(
    SOC_SAND_IN   int           unit,
    SOC_SAND_IN   int           core,
    SOC_SAND_IN   uint32        entry_offset,
    SOC_SAND_IN   ARAD_BASE_Q_TO_SYS_PORT_TABLE_TBL_DATA* system_physical_port_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE];
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_SET_UNSAFE);
  /* assert(ARAD_IS_VOQ_MAPPING_INDIRECT(unit)); */

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(unit, IPS_QPM_1_SYS_REDm, data, SYS_PHY_PORTf, system_physical_port_tbl_data->sys_phy_port);

  err = soc_mem_write(unit, IPS_QPM_1_SYS_REDm, IPS_BLOCK(unit, core), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  if (SOC_IS_QAX(unit)) {
      err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
      SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

      soc_mem_field32_set(unit, CGM_QSPMm, data, SYSTEM_PORTf, system_physical_port_tbl_data->sys_phy_port);

      err = soc_mem_write(unit, CGM_QSPMm, CGM_BLOCK(unit, core), entry_offset, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit); 
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_indirect_base_queue_to_system_physical_port_tbl_set_unsafe()",0,0);
}


/*
 * Write indirect table system_physical_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_indirect_base_queue_to_system_physical_port_tbl_region_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   uint32              region_size,
    SOC_SAND_IN   ARAD_BASE_Q_TO_SYS_PORT_TABLE_TBL_DATA* system_physical_port_tbl_data
  )
{
  uint32 err;
  uint32 *data = NULL, *cur_data;
  uint32 flags=0;
  int index_max, index_min;
  int i; 
  int dmaable = soc_mem_dmaable(unit, IPS_QPM_1_SYS_REDm, SOC_MEM_BLOCK_ANY(unit, IPS_QPM_1_SYS_REDm)); /* check if we can use DMA */
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_SET_UNSAFE);
  index_min=entry_offset;
  index_max=entry_offset+region_size-1;

  /* assert(ARAD_IS_VOQ_MAPPING_INDIRECT(unit)); */
  if (dmaable) {
      data = (uint32 *)soc_cm_salloc(unit, region_size*ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE*sizeof(uint32), "IPS_QPM_1_SYS_REDm"); /* allocate DMA memory buffer */
  } else {
      data = (uint32*)soc_sand_os_malloc_any_size(region_size*ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE*sizeof(uint32), "IPS_QPM_1}");
  }
  if (data == NULL) {
      SOC_SAND_SET_ERROR_CODE(SOC_SAND_MALLOC_FAIL, 10, exit);
  }
  err = soc_sand_os_memset(data, 0x0, region_size*ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE*sizeof(uint32));
  SOC_SAND_CHECK_FUNC_RESULT(err, 20, exit);

  for (i=0, cur_data=data; i<region_size; i++, cur_data++) {
      soc_mem_field32_set(unit, IPS_QPM_1_SYS_REDm, cur_data, SYS_PHY_PORTf, system_physical_port_tbl_data->sys_phy_port);
  }
  err = soc_mem_array_write_range(unit, flags, IPS_QPM_1_SYS_REDm, 0, IPS_BLOCK(unit, core), index_min, index_max, data);
  SOC_SAND_CHECK_FUNC_RESULT(err, 30, exit);

exit:
    if (data != NULL) {
        if (dmaable) {
            soc_cm_sfree(unit, data);
        } else  {
            soc_sand_os_free(data);
        }
    }
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_indirect_base_queue_to_system_physical_port_tbl_region_set_unsafe()",0,0);
}
const soc_field_t qpm2_field_per_base_queue[BASE_QUEUES_PER_QPM_2_ENTRY] = {DEST_PORT_0f, DEST_PORT_1f, DEST_PORT_2f, DEST_PORT_3f};

/*
 * Read direct tables QPM_1,QPM_2 to get a mapping from a base queue to fap module x port
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_direct_base_queue_to_system_physical_port_tbl_get_unsafe(
    SOC_SAND_IN  int unit,
    SOC_SAND_IN  int core,
    SOC_SAND_IN  uint32 base_queue,
    SOC_SAND_OUT ARAD_BASE_Q_TO_MOD_PORT_TABLE_TBL_DATA* mod_port_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE] = {0};
  int core_index = (core == SOC_CORE_ALL) ? 0 : core;
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  /* assert(ARAD_IS_VOQ_MAPPING_DIRECT(unit)); */

  err = READ_IPS_QPM_1_NO_SYS_REDm(unit, IPS_BLOCK(unit, core_index), base_queue, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);

  mod_port_tbl_data->fap_id = soc_mem_field32_get(unit, IPS_QPM_1_NO_SYS_REDm, data, DEST_DEVf);
  mod_port_tbl_data->fap_port_id = soc_mem_field32_get(unit, IPS_QPM_1_NO_SYS_REDm, data, DEST_PORT_MSBf) << BASE_QUEUES_PER_QPM_FAP_PORT_MSB_OFFSET;

  data[0] = 0;
  data[1] = 0;
  err = READ_IPS_QPM_2_NO_SYS_REDm(unit, IPS_BLOCK(unit, core_index), base_queue / BASE_QUEUES_PER_QPM_2_ENTRY, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);
  mod_port_tbl_data->fap_port_id |= soc_mem_field32_get(unit, IPS_QPM_2_NO_SYS_REDm, &data, qpm2_field_per_base_queue[base_queue % BASE_QUEUES_PER_QPM_2_ENTRY]);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_direct_base_queue_to_system_physical_port_tbl_get_unsafe()",base_queue ,0);
}

/*
 * Write direct tables QPM_1,QPM_2 to set a mapping from a base queue to fap module x port
 * Write indirect table system_physical_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_direct_base_queue_to_system_physical_port_tbl_set_unsafe(
    SOC_SAND_IN int unit,
    SOC_SAND_IN int core,
    SOC_SAND_IN uint32 base_queue,
    SOC_SAND_IN ARAD_BASE_Q_TO_MOD_PORT_TABLE_TBL_DATA* mod_port_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IPS_SYSTEM_PHYSICAL_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE] = {0};
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  /* assert(ARAD_IS_VOQ_MAPPING_DIRECT(unit)); */

  soc_mem_field32_set(unit, IPS_QPM_1_NO_SYS_REDm, data, DEST_DEVf, mod_port_tbl_data->fap_id);
  soc_mem_field32_set(unit, IPS_QPM_1_NO_SYS_REDm, data, DEST_PORT_MSBf, mod_port_tbl_data->fap_port_id >> BASE_QUEUES_PER_QPM_FAP_PORT_MSB_OFFSET);
  err = WRITE_IPS_QPM_1_NO_SYS_REDm(unit, IPS_BLOCK(unit, core), base_queue, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 10, exit);

  data[0] = 0;
  data[1] = 0;
  err = READ_IPS_QPM_2_NO_SYS_REDm(unit, IPS_BLOCK(unit, core), base_queue / BASE_QUEUES_PER_QPM_2_ENTRY, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);

  soc_mem_field32_set(unit, IPS_QPM_2_NO_SYS_REDm, data, qpm2_field_per_base_queue[base_queue % BASE_QUEUES_PER_QPM_2_ENTRY], mod_port_tbl_data->fap_port_id & BASE_QUEUES_PER_QPM_FAP_PORT_NO_MSB_MASK );

  err = WRITE_IPS_QPM_2_NO_SYS_REDm(unit, IPS_BLOCK(unit, core), base_queue / BASE_QUEUES_PER_QPM_2_ENTRY, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_direct_base_queue_to_system_physical_port_tbl_set_unsafe()",base_queue ,0);
}

/*
 * Write direct tables QPM_1,QPM_2 to set a mapping from a base queue to fap module x port
 * Write indirect table system_physical_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_direct_base_queue_to_system_physical_port_tbl_region_set_unsafe(
    SOC_SAND_IN int unit,
    SOC_SAND_IN int core,
    SOC_SAND_IN uint32 entry_offset,
    SOC_SAND_IN uint32 region_size,
    SOC_SAND_IN ARAD_BASE_Q_TO_MOD_PORT_TABLE_TBL_DATA* mod_port_tbl_data
  )
{
  uint32 err;
  uint32 *data = NULL, *cur_data;
  uint32 flags=0;
  int index_max, index_min;
  int i; 
  int dmaable = soc_mem_dmaable(unit, IPS_QPM_2_NO_SYS_REDm, SOC_MEM_BLOCK_ANY(unit, IPS_QPM_2_NO_SYS_REDm)); /* check if we can use DMA */
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  index_min=entry_offset;
  index_max=entry_offset+region_size-1;

  if (dmaable) {
      data = (uint32 *)soc_cm_salloc(unit, region_size*sizeof(uint32), "IPS_QPM_2_NO_SYS_REDm"); /* allocate DMA memory buffer */
  } else {
      data = (uint32*)soc_sand_os_malloc_any_size(region_size*sizeof(uint32), "IPS_QPM_2_NO_SYS_REDm");
  }
  if (data == NULL) {
      SOC_SAND_SET_ERROR_CODE(SOC_SAND_MALLOC_FAIL, 10, exit);
  }
  err = soc_sand_os_memset(data, 0x0, region_size*sizeof(uint32));
  SOC_SAND_CHECK_FUNC_RESULT(err, 20, exit);

  /* assert(ARAD_IS_VOQ_MAPPING_DIRECT(unit)); */

  for (i=0, cur_data=data; i<region_size; i++, cur_data++) {
    soc_mem_field32_set(unit, IPS_QPM_1_NO_SYS_REDm, cur_data, DEST_DEVf, mod_port_tbl_data->fap_id);
    soc_mem_field32_set(unit, IPS_QPM_1_NO_SYS_REDm, cur_data, DEST_PORT_MSBf, mod_port_tbl_data->fap_port_id >> BASE_QUEUES_PER_QPM_FAP_PORT_MSB_OFFSET);
  }
  err = soc_mem_array_write_range(unit, flags, IPS_QPM_1_NO_SYS_REDm, 0, IPS_BLOCK(unit, core), index_min , index_max, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);


  err = soc_sand_os_memset(data, 0x0, region_size*sizeof(uint32));
  SOC_SAND_CHECK_FUNC_RESULT(err, 40, exit);


  err = soc_mem_array_read_range(unit, IPS_QPM_2_NO_SYS_REDm, 0, IPS_BLOCK(unit, core), index_min / BASE_QUEUES_PER_QPM_2_ENTRY, index_max / BASE_QUEUES_PER_QPM_2_ENTRY, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 50, exit);

  for (i=0, cur_data=data; i<region_size; i++, cur_data++) {
      soc_mem_field32_set(unit, IPS_QPM_2_NO_SYS_REDm, cur_data, qpm2_field_per_base_queue[(entry_offset+i)% BASE_QUEUES_PER_QPM_2_ENTRY], mod_port_tbl_data->fap_port_id & BASE_QUEUES_PER_QPM_FAP_PORT_NO_MSB_MASK );
  }
  err = soc_mem_array_write_range(unit, flags, IPS_QPM_2_NO_SYS_REDm, 0, IPS_BLOCK(unit, core), index_min / BASE_QUEUES_PER_QPM_2_ENTRY , index_max / BASE_QUEUES_PER_QPM_2_ENTRY, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 60, exit);

exit:
    if (data != NULL) {
        if (dmaable) {
            soc_cm_sfree(unit, data);
        } else  {
            soc_sand_os_free(data);
        }
    }
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_direct_base_queue_to_system_physical_port_tbl_region_set_unsafe()",entry_offset ,0);
}


/*
 * Read indirect table destination_device_and_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_indirect_sysport_to_modport_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_MOD_PORT_TBL_DATA* IPS_destination_device_and_port_lookup_table_tbl_data
  )
{
  uint32 err;
  uint32 data[SOC_MAX_MEM_WORDS];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_DESTINATION_DEVICE_AND_PORT_LOOKUP_TABLE_TBL_GET_UNSAFE);
  /* assert(ARAD_IS_VOQ_MAPPING_INDIRECT(unit)); */

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(IPS_destination_device_and_port_lookup_table_tbl_data, 0x0, sizeof(ARAD_MOD_PORT_TBL_DATA));
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(unit, IPS_QPM_2_SYS_REDm, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  IPS_destination_device_and_port_lookup_table_tbl_data->dest_port = soc_mem_field32_get(unit, IPS_QPM_2_SYS_REDm, data, DEST_PORTf);
  IPS_destination_device_and_port_lookup_table_tbl_data->dest_dev = soc_mem_field32_get(unit, IPS_QPM_2_SYS_REDm, data, DEST_DEVf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_indirect_sysport_to_modport_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table destination_device_and_port_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_indirect_sysport_to_modport_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_MOD_PORT_TBL_DATA* IPS_destination_device_and_port_lookup_table_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IPS_DESTINATION_DEVICE_AND_PORT_LOOKUP_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_DESTINATION_DEVICE_AND_PORT_LOOKUP_TABLE_TBL_SET_UNSAFE);
  /* assert(ARAD_IS_VOQ_MAPPING_INDIRECT(unit)); */

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(unit, IPS_QPM_2_SYS_REDm, data, DEST_PORTf, IPS_destination_device_and_port_lookup_table_tbl_data->dest_port);
  soc_mem_field32_set(unit, IPS_QPM_2_SYS_REDm, data, DEST_DEVf, IPS_destination_device_and_port_lookup_table_tbl_data->dest_dev);

  err = soc_mem_write(unit, IPS_QPM_2_SYS_REDm, IPS_BLOCK(unit, SOC_CORE_ALL), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_indirect_sysport_to_modport_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table flow_id_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_flow_id_lookup_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_DATA* IPS_flow_id_lookup_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_ENTRY_SIZE];
  int core_index = (core == SOC_CORE_ALL) ? 0 : core;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  err = soc_sand_os_memset(IPS_flow_id_lookup_table_tbl_data, 0x0, sizeof(ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_DATA));
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(unit, IPS_FLWIDm, IPS_BLOCK(unit, core_index), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  IPS_flow_id_lookup_table_tbl_data->base_flow = soc_mem_field32_get(unit, IPS_FLWIDm, data, BASE_FLOWf);
  IPS_flow_id_lookup_table_tbl_data->sub_flow_mode = soc_mem_field32_get(unit, IPS_FLWIDm, data, SUB_FLOW_MODEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_flow_id_lookup_table_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table flow_id_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_flow_id_lookup_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_DATA* IPS_flow_id_lookup_table_tbl_data
  )
{
  uint32 err;
  uint32 data[ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(&(data[0]), 0x0, sizeof(data));
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(unit, IPS_FLWIDm, data, BASE_FLOWf, IPS_flow_id_lookup_table_tbl_data->base_flow);
  soc_mem_field32_set(unit, IPS_FLWIDm, data, SUB_FLOW_MODEf, IPS_flow_id_lookup_table_tbl_data->sub_flow_mode);

  err = soc_mem_write(unit, IPS_FLWIDm, IPS_BLOCK(unit, core), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_flow_id_lookup_table_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table queue_type_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_type_lookup_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_DATA* IPS_queue_type_lookup_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_ENTRY_SIZE];
  int core_index = (core == SOC_CORE_ALL) ? 0 : core;
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_queue_type_lookup_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IPS_QTYPEm,
          IPS_BLOCK(unit, core_index),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_queue_type_lookup_table_tbl_data->queue_type_lookup_table   = soc_mem_field32_get(
                  unit,
                  IPS_QTYPEm,
                  data,
                  QTYPEf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_type_lookup_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table flow_id_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_flow_id_lookup_table_tbl_region_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   uint32              region_size,
    SOC_SAND_IN   ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_DATA* IPS_flow_id_lookup_table_tbl_data
  )
{
  uint32 err;
  uint32 *data = NULL, *cur_data;
  uint32 flags=0;
  int index_max, index_min;
  int i; 
  int dmaable = soc_mem_dmaable(
                 unit, 
                 IPS_FLWIDm, 
                 SOC_MEM_BLOCK_ANY(unit, IPS_FLWIDm)); /* check if we can use DMA */
   
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_FLOW_ID_LOOKUP_TABLE_TBL_SET_UNSAFE);

  index_min=entry_offset;
  index_max=entry_offset+region_size-1;
  if (dmaable) {
      data = (uint32 *)soc_cm_salloc(unit, region_size*sizeof(uint32), "IPS_FLWIDm"); /* allocate DMA memory buffer */
  } else {
      data = (uint32*)soc_sand_os_malloc_any_size(region_size*sizeof(uint32), "IPS_FLWIDm}");
  }
  if (data == NULL) {
      SOC_SAND_SET_ERROR_CODE(SOC_SAND_MALLOC_FAIL, 10, exit);
  }

  err = soc_sand_os_memset(data, 0x0, region_size*sizeof(uint32));
  SOC_SAND_CHECK_FUNC_RESULT(err, 20, exit);

  for (i=0, cur_data=data; i<region_size; i++, cur_data++) {
      *cur_data = 0;
      soc_mem_field32_set(unit, IPS_FLWIDm, cur_data, BASE_FLOWf, IPS_flow_id_lookup_table_tbl_data->base_flow);
      soc_mem_field32_set(unit, IPS_FLWIDm, cur_data, SUB_FLOW_MODEf, IPS_flow_id_lookup_table_tbl_data->sub_flow_mode);
  }

  err = soc_mem_array_write_range(unit, flags, IPS_FLWIDm, 0, IPS_BLOCK(unit, core), index_min , index_max, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);


exit:
    if (data != NULL) {
        if (dmaable) {
            soc_cm_sfree(unit, data);
        } else  {
            soc_sand_os_free(data);
        }
    }
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_flow_id_lookup_table_tbl_region_set_unsafe()",0,0);
}

/*
 * Write indirect table queue_type_lookup_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_type_lookup_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_DATA* IPS_queue_type_lookup_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_TYPE_LOOKUP_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QTYPEm,
          data,
          QTYPEf,
          IPS_queue_type_lookup_table_tbl_data->queue_type_lookup_table );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IPS_QTYPEm,
          IPS_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_type_lookup_table_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table queue_priority_map_select_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_priority_map_select_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_DATA* IPS_queue_priority_map_select_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_queue_priority_map_select_tbl_data,
          0x0,
          sizeof(ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IPS_QPRISELm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_queue_priority_map_select_tbl_data->queue_priority_map_select   = soc_mem_field32_get(
                  unit,
                  IPS_QPRISELm,
                  data,
                  QPRISELf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_priority_map_select_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table queue_priority_map_select_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_priority_map_select_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_DATA* IPS_queue_priority_map_select_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_PRIORITY_MAP_SELECT_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QPRISELm,
          data,
          QPRISELf,
          IPS_queue_priority_map_select_tbl_data->queue_priority_map_select );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IPS_QPRISELm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_priority_map_select_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table queue_priority_maps_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_priority_maps_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_DATA* IPS_queue_priority_maps_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_queue_priority_maps_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

 
 




  err = soc_mem_read(
          unit,
          IPS_Q_PRIORITY_BIT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
             soc_mem_field_get(
                  unit,
                  IPS_Q_PRIORITY_BIT_MAPm,
                  data,
                  Q_PRIORITY_BIT_MAPf,
                IPS_queue_priority_maps_table_tbl_data->queue_priority_maps_table            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_priority_maps_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table queue_priority_maps_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_priority_maps_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_DATA* IPS_queue_priority_maps_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_PRIORITY_MAPS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 
 




err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field_set(
          unit,
          IPS_Q_PRIORITY_BIT_MAPm,
          data,
          Q_PRIORITY_BIT_MAPf,
          (uint32*)&(IPS_queue_priority_maps_table_tbl_data->queue_priority_maps_table[0]) );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          IPS_Q_PRIORITY_BIT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_priority_maps_table_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table queue_size_based_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ips_queue_size_based_thresholds_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_DATA* IPS_queue_size_based_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_queue_size_based_thresholds_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IPS_QSZTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_queue_size_based_thresholds_table_tbl_data->off_to_slow_msg_th   = soc_mem_field32_get(
                  unit,
                  IPS_QSZTHm,
                  data,
                  OFF_TO_SLOW_MSG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IPS_queue_size_based_thresholds_table_tbl_data->off_to_norm_msg_th   = soc_mem_field32_get(
                  unit,
                  IPS_QSZTHm,
                  data,
                  OFF_TO_NORM_MSG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
          IPS_queue_size_based_thresholds_table_tbl_data->slow_to_norm_msg_th   = soc_mem_field32_get(
                  unit,
                  IPS_QSZTHm,
                  data,
                  SLOW_TO_NORM_MSG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

    if(SOC_E_NONE == err) {
          IPS_queue_size_based_thresholds_table_tbl_data->norm_to_slow_msg_th   = soc_mem_field32_get(
                  unit,
                  IPS_QSZTHm,
                  data,
                  NORM_TO_SLOW_MSG_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

    if(SOC_E_NONE == err) {
          IPS_queue_size_based_thresholds_table_tbl_data->fsm_th_mul   = soc_mem_field32_get(
                  unit,
                  IPS_QSZTHm,
                  data,
                  FSM_TH_MULf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_size_based_thresholds_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table queue_size_based_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_queue_size_based_thresholds_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_DATA* IPS_queue_size_based_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_QUEUE_SIZE_BASED_THRESHOLDS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);


err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QSZTHm,
          data,
          OFF_TO_SLOW_MSG_THf,
          IPS_queue_size_based_thresholds_table_tbl_data->off_to_slow_msg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QSZTHm,
          data,
          OFF_TO_NORM_MSG_THf,
          IPS_queue_size_based_thresholds_table_tbl_data->off_to_norm_msg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QSZTHm,
          data,
          SLOW_TO_NORM_MSG_THf,
          IPS_queue_size_based_thresholds_table_tbl_data->slow_to_norm_msg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QSZTHm,
          data,
          NORM_TO_SLOW_MSG_THf,
          IPS_queue_size_based_thresholds_table_tbl_data->norm_to_slow_msg_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_QSZTHm,
          data,
          FSM_TH_MULf,
          IPS_queue_size_based_thresholds_table_tbl_data->fsm_th_mul );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);

  err = soc_mem_write(
          unit,
          IPS_QSZTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_queue_size_based_thresholds_table_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table credit_balance_based_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_credit_balance_based_thresholds_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_DATA* IPS_credit_balance_based_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_credit_balance_based_thresholds_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IPS_CRBALTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_credit_balance_based_thresholds_table_tbl_data->backoff_enter_qcr_bal_th   = soc_mem_field32_get(
                  unit,
                  IPS_CRBALTHm,
                  data,
                  BACKOFF_ENTER_Q_CR_BAL_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IPS_credit_balance_based_thresholds_table_tbl_data->backoff_exit_qcr_bal_th   = soc_mem_field32_get(
                  unit,
                  IPS_CRBALTHm,
                  data,
                  BACKOFF_EXIT_Q_CR_BAL_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
          IPS_credit_balance_based_thresholds_table_tbl_data->backlog_enter_qcr_bal_th   = soc_mem_field32_get(
                  unit,
                  IPS_CRBALTHm,
                  data,
                  BACKLOG_ENTER_Q_CR_BAL_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

    if(SOC_E_NONE == err) {
          IPS_credit_balance_based_thresholds_table_tbl_data->backlog_exit_qcr_bal_th   = soc_mem_field32_get(
                  unit,
                  IPS_CRBALTHm,
                  data,
                  BACKLOG_EXIT_Q_CR_BAL_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      IPS_credit_balance_based_thresholds_table_tbl_data->backslow_enter_qcr_bal_th = soc_mem_field32_get(
                    unit,
                    IPS_CRBALTHm,
                    data,
                    BACKSLOW_ENTER_Q_CR_BAL_THf);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

      IPS_credit_balance_based_thresholds_table_tbl_data->backslow_exit_qcr_bal_th = soc_mem_field32_get(
                    unit,
                    IPS_CRBALTHm,
                    data,
                    BACKSLOW_EXIT_Q_CR_BAL_THf);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_credit_balance_based_thresholds_table_tbl_get_unsafe()",0,0);
}
/*
 * Write indirect table credit_balance_based_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_credit_balance_based_thresholds_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_DATA* IPS_credit_balance_based_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_CREDIT_BALANCE_BASED_THRESHOLDS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);


err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRBALTHm,
          data,
          BACKOFF_ENTER_Q_CR_BAL_THf,
          IPS_credit_balance_based_thresholds_table_tbl_data->backoff_enter_qcr_bal_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRBALTHm,
          data,
          BACKOFF_EXIT_Q_CR_BAL_THf,
          IPS_credit_balance_based_thresholds_table_tbl_data->backoff_exit_qcr_bal_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRBALTHm,
          data,
          BACKLOG_ENTER_Q_CR_BAL_THf,
          IPS_credit_balance_based_thresholds_table_tbl_data->backlog_enter_qcr_bal_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRBALTHm,
          data,
          BACKLOG_EXIT_Q_CR_BAL_THf,
          IPS_credit_balance_based_thresholds_table_tbl_data->backlog_exit_qcr_bal_th );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(
         unit,
         IPS_CRBALTHm,
         data,
         BACKSLOW_ENTER_Q_CR_BAL_THf, 
         IPS_credit_balance_based_thresholds_table_tbl_data->backslow_enter_qcr_bal_th);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);

      soc_mem_field32_set(
         unit,
         IPS_CRBALTHm,
         data,
         BACKSLOW_EXIT_Q_CR_BAL_THf,
         IPS_credit_balance_based_thresholds_table_tbl_data->backslow_exit_qcr_bal_th);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);
  }

  err = soc_mem_write(
          unit,
          IPS_CRBALTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_credit_balance_based_thresholds_table_tbl_set_unsafe()",0,0);
}
/*
 * Read indirect table empty_queue_credit_balance_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_empty_queue_credit_balance_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_DATA* IPS_empty_queue_credit_balance_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_empty_queue_credit_balance_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IPS_EMPTYQCRBALm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_empty_queue_credit_balance_table_tbl_data->empty_qsatisfied_cr_bal   = soc_mem_field32_get(
                  unit,
                  IPS_EMPTYQCRBALm,
                  data,
                  EMPTY_Q_SATISFIED_CR_BALf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IPS_empty_queue_credit_balance_table_tbl_data->max_empty_qcr_bal   = soc_mem_field32_get(
                  unit,
                  IPS_EMPTYQCRBALm,
                  data,
                  MAX_EMPTY_Q_CR_BALf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

    if(SOC_E_NONE == err) {
          IPS_empty_queue_credit_balance_table_tbl_data->exceed_max_empty_qcr_bal   = soc_mem_field32_get(
                  unit,
                  IPS_EMPTYQCRBALm,
                  data,
                  EXCEED_MAX_EMPTY_Q_CR_BALf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_empty_queue_credit_balance_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table empty_queue_credit_balance_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_empty_queue_credit_balance_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_DATA* IPS_empty_queue_credit_balance_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_EMPTY_QUEUE_CREDIT_BALANCE_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);


err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_EMPTYQCRBALm,
          data,
          EMPTY_Q_SATISFIED_CR_BALf,
          IPS_empty_queue_credit_balance_table_tbl_data->empty_qsatisfied_cr_bal );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_EMPTYQCRBALm,
          data,
          MAX_EMPTY_Q_CR_BALf,
          IPS_empty_queue_credit_balance_table_tbl_data->max_empty_qcr_bal );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_EMPTYQCRBALm,
          data,
          EXCEED_MAX_EMPTY_Q_CR_BALf,
          IPS_empty_queue_credit_balance_table_tbl_data->exceed_max_empty_qcr_bal );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

  err = soc_mem_write(
          unit,
          IPS_EMPTYQCRBALm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_empty_queue_credit_balance_table_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table credit_watchdog_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_credit_watchdog_thresholds_table_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_DATA* IPS_credit_watchdog_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          IPS_credit_watchdog_thresholds_table_tbl_data,
          0x0,
          sizeof(ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          IPS_CRWDTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          IPS_credit_watchdog_thresholds_table_tbl_data->wd_status_msg_gen_period   = soc_mem_field32_get(
                  unit,
                  IPS_CRWDTHm,
                  data,
                  WD_STATUS_MSG_GEN_PERIODf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          IPS_credit_watchdog_thresholds_table_tbl_data->wd_delete_qth   = soc_mem_field32_get(
                  unit,
                  IPS_CRWDTHm,
                  data,
                  WD_DELETE_Q_THf            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_credit_watchdog_thresholds_table_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table credit_watchdog_thresholds_table_tbl from block IPS,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_ips_credit_watchdog_thresholds_table_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_DATA* IPS_credit_watchdog_thresholds_table_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IPS_CREDIT_WATCHDOG_THRESHOLDS_TABLE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

err=SOC_E_NONE;
if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRWDTHm,
          data,
          WD_STATUS_MSG_GEN_PERIODf,
          IPS_credit_watchdog_thresholds_table_tbl_data->wd_status_msg_gen_period );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          IPS_CRWDTHm,
          data,
          WD_DELETE_Q_THf,
          IPS_credit_watchdog_thresholds_table_tbl_data->wd_delete_qth );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  err = soc_mem_write(
          unit,
          IPS_CRWDTHm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ips_credit_watchdog_thresholds_table_tbl_set_unsafe()",0,0);
}

soc_mem_t
  arad_egq_scm_chan_arb_id2scm_id(
    SOC_SAND_IN  int unit,
    SOC_SAND_IN  uint32 chan_arb_id
  )
{  
  soc_mem_t
    egq_scm_name;
  /*
   *  Go to the correct table
   */
  switch (chan_arb_id)
  {
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_00:
    egq_scm_name = EGQ_CH_0_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_01:
    egq_scm_name = EGQ_CH_1_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_02:
    egq_scm_name = EGQ_CH_2_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_03:
    egq_scm_name = EGQ_CH_3_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_04:
    egq_scm_name = EGQ_CH_4_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_05:
    egq_scm_name = EGQ_CH_5_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_06:
    egq_scm_name = EGQ_CH_6_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_07:
    egq_scm_name = EGQ_CH_7_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_CPU:
    egq_scm_name = EGQ_CH_8_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_RCY:
    egq_scm_name = EGQ_CH_9_SCMm;
    break;
  case ARAD_OFP_RATES_EGQ_CHAN_ARB_NON_CHAN:
    egq_scm_name = EGQ_NONCH_SCMm;
    break;
  default:
    egq_scm_name = EGQ_CH_0_SCMm;
  }

  return egq_scm_name;
}

/*
 * Read indirect table scm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_egq_scm_tbl_get_unsafe(
    SOC_SAND_IN   int                       unit,
    SOC_SAND_IN   int                       core,
    SOC_SAND_IN   ARAD_OFP_RATES_CAL_INFO   *cal_info,
    SOC_SAND_IN   uint32                    entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_SCM_TBL_DATA*    EGQ_nif_scm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_NIF_SCM_TBL_ENTRY_SIZE];
  soc_mem_t
    egq_scm_name;
  soc_field_t
    egq_cr_field_name,
    egq_index_field_name;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_SCM_TBL_GET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(cal_info);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          EGQ_nif_scm_tbl_data,
          0x0,
          sizeof(ARAD_EGQ_SCM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  switch (cal_info->cal_type)
  {
  case ARAD_OFP_RATES_EGQ_CAL_CHAN_ARB:
    if (cal_info->chan_arb_id > (SOC_DPP_DEFS_GET(unit, nof_channelized_calendars) - 1))
    {
      SOC_SAND_SET_ERROR_CODE(ARAD_OFP_RATES_CHAN_ARB_INVALID_ERR, 20, exit);
    }
    egq_scm_name = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ofp_rates_egq_scm_chan_arb_id2scm_id, (unit, cal_info->chan_arb_id));
    egq_cr_field_name = PORT_CR_TO_ADDf;
    egq_index_field_name = OFP_INDEXf;
    break;
  case ARAD_OFP_RATES_EGQ_CAL_PORT_PRIORITY:
    egq_scm_name = EGQ_QP_SCMm;
    egq_cr_field_name = QPAIR_CR_TO_ADDf;
    egq_index_field_name = QPAIR_INDEXf;
    break;
  case ARAD_OFP_RATES_EGQ_CAL_TCG:
    egq_scm_name = EGQ_TCG_SCMm;
    egq_cr_field_name = TCG_CR_TO_ADDf;
    egq_index_field_name = TCG_INDEXf;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_OFP_RATES_EGQ_CAL_INVALID_ERR, 25, exit);
  }
  
  ARAD_DEVICE_CHECK(unit, exit);
  err = soc_mem_read(
          unit,
          egq_scm_name,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          EGQ_nif_scm_tbl_data->port_cr_to_add = soc_mem_field32_get(
                  unit,
                  egq_scm_name,
                  data,
                  egq_cr_field_name    );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

    if(SOC_E_NONE == err) {
          EGQ_nif_scm_tbl_data->ofp_index = soc_mem_field32_get(
                  unit,
                  egq_scm_name,
                  data,
                egq_index_field_name );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_scm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table scm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_scm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   ARAD_OFP_RATES_CAL_INFO *cal_info,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_EGQ_SCM_TBL_DATA* EGQ_nif_scm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_NIF_SCM_TBL_ENTRY_SIZE];
  soc_mem_t
    egq_scm_name;
  soc_field_t
    egq_cr_field_name,
    egq_index_field_name;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_SCM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  switch (cal_info->cal_type)
  {
  case ARAD_OFP_RATES_EGQ_CAL_CHAN_ARB:
    if (cal_info->chan_arb_id > (SOC_DPP_DEFS_GET(unit, nof_channelized_calendars) - 1))
    {
      SOC_SAND_SET_ERROR_CODE(ARAD_OFP_RATES_CHAN_ARB_INVALID_ERR, 20, exit);
    }
     /*
      *  Go to the correct table, per chan arb id
      */
    egq_scm_name = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ofp_rates_egq_scm_chan_arb_id2scm_id, (unit, cal_info->chan_arb_id));
    egq_cr_field_name = PORT_CR_TO_ADDf;
    egq_index_field_name = OFP_INDEXf;
    break;
  case ARAD_OFP_RATES_EGQ_CAL_PORT_PRIORITY:
    egq_scm_name = EGQ_QP_SCMm;
    egq_cr_field_name = QPAIR_CR_TO_ADDf;
    egq_index_field_name = QPAIR_INDEXf;
    break;
  case ARAD_OFP_RATES_EGQ_CAL_TCG:
    egq_scm_name = EGQ_TCG_SCMm;
    egq_cr_field_name = TCG_CR_TO_ADDf;
    egq_index_field_name = TCG_INDEXf;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_OFP_RATES_EGQ_CAL_INVALID_ERR, 25, exit);
  }  

  err=SOC_E_NONE;
  ARAD_DEVICE_CHECK(unit, exit);
  if(SOC_E_NONE == err) {
    soc_mem_field32_set(
          unit,
          egq_scm_name,
          data,
          egq_cr_field_name,
          EGQ_nif_scm_tbl_data->port_cr_to_add);
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  if(SOC_E_NONE == err) {
    soc_mem_field32_set(
          unit,
          egq_scm_name,
          data,
          egq_index_field_name,
          EGQ_nif_scm_tbl_data->ofp_index );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  err = soc_mem_write(
          unit,
          egq_scm_name,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_scm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table ccm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_ccm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_CCM_TBL_DATA* EGQ_ccm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_CCM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_CCM_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          EGQ_ccm_tbl_data,
          0x0,
          sizeof(ARAD_EGQ_CCM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          EGQ_CCMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          EGQ_ccm_tbl_data->interface_select   = soc_mem_field32_get(
              unit,
                  EGQ_CCMm,
                  data,
                  INTERFACE_SELECTf
          );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_ccm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table ccm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_ccm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32          entry_offset,
    SOC_SAND_IN   ARAD_EGQ_CCM_TBL_DATA* EGQ_ccm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_CCM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_CCM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err=SOC_E_NONE;
  if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          EGQ_CCMm,
          data,
          INTERFACE_SELECTf,
          EGQ_ccm_tbl_data->interface_select
      );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          EGQ_CCMm,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_ccm_tbl_set_unsafe()",0,0);
}

STATIC
  uint32
    arad_egq_pmc_names_get(
      SOC_SAND_IN   int             unit,
      SOC_SAND_IN   ARAD_OFP_RATES_CAL_INFO *cal_info,
      SOC_SAND_OUT  soc_mem_t             *egq_pmc_name,
      SOC_SAND_OUT  soc_field_t           *egq_cr_field_name
    )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(cal_info);
  SOC_SAND_CHECK_NULL_INPUT(egq_pmc_name);
  SOC_SAND_CHECK_NULL_INPUT(egq_cr_field_name);

  switch (cal_info->cal_type)
  {
  case ARAD_OFP_RATES_EGQ_CAL_CHAN_ARB:
    *egq_pmc_name = EGQ_PMCm;
    *egq_cr_field_name = PORT_MAX_CREDITf;    
    break;
  case ARAD_OFP_RATES_EGQ_CAL_PORT_PRIORITY:
    *egq_pmc_name = EGQ_QP_PMCm;
    *egq_cr_field_name = QPAIR_MAX_CREDITf;
    break;
  case ARAD_OFP_RATES_EGQ_CAL_TCG:
    *egq_pmc_name = EGQ_TCG_PMCm;
    *egq_cr_field_name = TCG_MAX_CREDITf;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_OFP_RATES_EGQ_CAL_INVALID_ERR, 25, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_pmc_names_get()",0,0);
}

/*
 * Read indirect table pmc_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_pmc_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   ARAD_OFP_RATES_CAL_INFO *cal_info,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_PMC_TBL_DATA* EGQ_pmc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_PMC_TBL_ENTRY_SIZE];
  soc_mem_t
    egq_pmc_name;
  soc_field_t
    egq_max_credit_field_name;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_PMC_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          EGQ_pmc_tbl_data,
          0x0,
          sizeof(ARAD_EGQ_PMC_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = arad_egq_pmc_names_get(
          unit,
          cal_info,
          &egq_pmc_name,
          &egq_max_credit_field_name
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          egq_pmc_name,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

err=SOC_E_NONE;
    if(SOC_E_NONE == err) {
          EGQ_pmc_tbl_data->port_max_credit   = soc_mem_field32_get(
                  unit,
                  egq_pmc_name,
                  data,
                  egq_max_credit_field_name            );
        }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_pmc_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table pmc_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_pmc_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   ARAD_OFP_RATES_CAL_INFO *cal_info,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_EGQ_PMC_TBL_DATA* EGQ_pmc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_PMC_TBL_ENTRY_SIZE];
  soc_mem_t
    egq_pmc_name;
  soc_field_t
    egq_max_credit_field_name;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_PMC_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = arad_egq_pmc_names_get(
          unit,
          cal_info,
          &egq_pmc_name,
          &egq_max_credit_field_name
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

err=SOC_E_NONE;
  if(SOC_E_NONE == err) {
            soc_mem_field32_set(
          unit,
          egq_pmc_name,
          data,
          egq_max_credit_field_name,
          EGQ_pmc_tbl_data->port_max_credit
      );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          egq_pmc_name,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_pmc_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table dwm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_dwm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_DWM_TBL_DATA* EGQ_dwm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_DWM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_DWM_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          EGQ_dwm_tbl_data,
          0x0,
          sizeof(ARAD_EGQ_DWM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          EGQ_DWMm,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  EGQ_dwm_tbl_data->mc_or_mc_low_queue_weight = soc_mem_field32_get(
                  unit,
                  EGQ_DWMm,
                  data,
                  MC_OR_MC_LOW_QUEUE_WEIGHTf);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);


  EGQ_dwm_tbl_data->uc_or_uc_low_queue_weight   = soc_mem_field32_get(
          unit,
          EGQ_DWMm,
          data,
          UC_OR_UC_LOW_QUEUE_WEIGHTf);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_dwm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table dwm_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_dwm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_EGQ_DWM_TBL_DATA* EGQ_dwm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_DWM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EGQ_DWM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);


  soc_mem_field32_set(
          unit,
          EGQ_DWMm,
          data,
          MC_OR_MC_LOW_QUEUE_WEIGHTf,
          EGQ_dwm_tbl_data->mc_or_mc_low_queue_weight );



  soc_mem_field32_set(
          unit,
          EGQ_DWMm,
          data,
          UC_OR_UC_LOW_QUEUE_WEIGHTf,
          EGQ_dwm_tbl_data->uc_or_uc_low_queue_weight );

  err = soc_mem_write(
          unit,
          EGQ_DWMm,
          EGQ_BLOCK(unit, core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_dwm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table ppct_tbl from block EGQ,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

int
  arad_egq_ppct_tbl_get_unsafe(
    SOC_SAND_IN   int                       unit,
    SOC_SAND_IN   int                       core_id,
    SOC_SAND_IN   uint32                    base_q_pair,
    SOC_SAND_OUT  ARAD_EGQ_PPCT_TBL_DATA*   EGQ_ppct_tbl_data
  )
{
    uint32
        rv, tmp = 0;
    uint32
        data[SOC_DPP_IMP_DEFS_MAX(EGQ_PPCT_NOF_LONGS)];
 
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(EGQ_ppct_tbl_data, 0x0, sizeof(ARAD_EGQ_PPCT_TBL_DATA));

    rv = READ_EGQ_PPCTm(unit, EGQ_BLOCK(unit, core_id), base_q_pair, data);
    SOCDNX_IF_ERR_EXIT(rv);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        EGQ_ppct_tbl_data->base_q_pair_num = soc_mem_field32_get(unit, EGQ_PPCTm, data, BASE_Q_PAIR_NUMf);
    } else {
        EGQ_ppct_tbl_data->base_q_pair_num = base_q_pair;
    }
    EGQ_ppct_tbl_data->cgm_interface = soc_mem_field32_get(unit, EGQ_PPCTm, data, CGM_INTERFACEf);
    EGQ_ppct_tbl_data->cgm_port_profile = soc_mem_field32_get(unit, EGQ_PPCTm, data, CGM_PORT_PROFILEf);
    EGQ_ppct_tbl_data->cnm_intrcpt_drop_en = soc_mem_field32_get(unit, EGQ_PPCTm, data, CNM_INTRCPT_DROP_ENf);
    EGQ_ppct_tbl_data->cnm_intrcpt_fc_en = soc_mem_field32_get(unit, EGQ_PPCTm, data, CNM_INTRCPT_FC_ENf);

    tmp = soc_mem_field32_get(unit, EGQ_PPCTm, data, CNM_INTRCPT_FC_VEC_INDEXf);
    if(SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        SHR_BITCOPY_RANGE(&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_llfc),0,&tmp,0,5);
        SHR_BITCOPY_RANGE(&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_pfc),0,&tmp,5,8);
    } else {
        SHR_BITCOPY_RANGE(&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_llfc),0,&tmp,0,8);
        SHR_BITCOPY_RANGE(&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_pfc),0,&tmp,8,7);
    }

    EGQ_ppct_tbl_data->disable_filtering = soc_mem_field32_get(unit, EGQ_PPCTm, data, DISABLE_FILTERINGf);
    EGQ_ppct_tbl_data->cos_map_profile = soc_mem_field32_get(unit, EGQ_PPCTm, data, COS_MAP_PROFILEf);
    EGQ_ppct_tbl_data->ad_count_out_port_flag = soc_mem_field32_get(unit, EGQ_PPCTm, data, ADVA_COUNT_OUT_PORT_FLAGf);
    EGQ_ppct_tbl_data->is_stacking_port = soc_mem_field32_get(unit, EGQ_PPCTm, data, IS_STACKING_PORTf);
    EGQ_ppct_tbl_data->lb_key_min = soc_mem_field32_get(unit, EGQ_PPCTm, data, LB_KEY_MINf);
    EGQ_ppct_tbl_data->lb_key_max = soc_mem_field32_get(unit, EGQ_PPCTm, data, LB_KEY_MAXf);
    EGQ_ppct_tbl_data->pmf_data = soc_mem_field32_get(unit, EGQ_PPCTm, data, PMF_DATAf);
    EGQ_ppct_tbl_data->peer_tm_domain_id = soc_mem_field32_get(unit, EGQ_PPCTm, data, PEER_TM_DOMAIN_IDf);
    EGQ_ppct_tbl_data->port_type = soc_mem_field32_get(unit, EGQ_PPCTm, data, PORT_TYPEf);

    if (SOC_IS_JERICHO(unit)) {
        EGQ_ppct_tbl_data->second_range_lb_key_min = soc_mem_field32_get(unit, EGQ_PPCTm, data, SECOND_RANGE_LB_KEY_MINf);
        EGQ_ppct_tbl_data->second_range_lb_key_max = soc_mem_field32_get(unit, EGQ_PPCTm, data, SECOND_RANGE_LB_KEY_MAXf);
    }


exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table ppct_tbl from block EGQ,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

int
  arad_egq_ppct_tbl_set_unsafe(
    SOC_SAND_IN   int                       unit,
    SOC_SAND_IN   int                       core_id,
    SOC_SAND_IN   uint32                    base_q_pair,
    SOC_SAND_IN   ARAD_EGQ_PPCT_TBL_DATA*   EGQ_ppct_tbl_data
  )
{
    uint32 tmp = 0;
    uint32 data[SOC_DPP_IMP_DEFS_MAX(EGQ_PPCT_NOF_LONGS)];
    int rv;
 
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32) * SOC_DPP_IMP_DEFS_MAX(EGQ_PPCT_NOF_LONGS));

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        soc_mem_field32_set(unit, EGQ_PPCTm, data, BASE_Q_PAIR_NUMf, EGQ_ppct_tbl_data->base_q_pair_num);
    }

    soc_mem_field32_set(unit, EGQ_PPCTm, data, CGM_INTERFACEf, EGQ_ppct_tbl_data->cgm_interface);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, CGM_PORT_PROFILEf, EGQ_ppct_tbl_data->cgm_port_profile);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, CNM_INTRCPT_DROP_ENf, EGQ_ppct_tbl_data->cnm_intrcpt_drop_en);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, CNM_INTRCPT_FC_ENf, EGQ_ppct_tbl_data->cnm_intrcpt_fc_en);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        SHR_BITCOPY_RANGE(&tmp,0,&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_llfc),0,5);
        SHR_BITCOPY_RANGE(&tmp,5,&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_pfc),0,8);
    } else {
        SHR_BITCOPY_RANGE(&tmp,0,&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_llfc),0,8);
        SHR_BITCOPY_RANGE(&tmp,8,&(EGQ_ppct_tbl_data->cnm_intrcpt_fc_vec_pfc),0,7);
    }
    soc_mem_field32_set(unit, EGQ_PPCTm, data, CNM_INTRCPT_FC_VEC_INDEXf, tmp);

    soc_mem_field32_set(unit, EGQ_PPCTm, data, DISABLE_FILTERINGf, EGQ_ppct_tbl_data->disable_filtering);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, COS_MAP_PROFILEf, EGQ_ppct_tbl_data->cos_map_profile);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, ADVA_COUNT_OUT_PORT_FLAGf, EGQ_ppct_tbl_data->ad_count_out_port_flag);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, IS_STACKING_PORTf, EGQ_ppct_tbl_data->is_stacking_port);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, LB_KEY_MINf, EGQ_ppct_tbl_data->lb_key_min);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, LB_KEY_MAXf, EGQ_ppct_tbl_data->lb_key_max);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, PMF_DATAf, EGQ_ppct_tbl_data->pmf_data);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, PEER_TM_DOMAIN_IDf, EGQ_ppct_tbl_data->peer_tm_domain_id);
    soc_mem_field32_set(unit, EGQ_PPCTm, data, PORT_TYPEf, EGQ_ppct_tbl_data->port_type);

    if (SOC_IS_JERICHO(unit)) {
        soc_mem_field32_set(unit, EGQ_PPCTm, data, SECOND_RANGE_LB_KEY_MINf, EGQ_ppct_tbl_data->second_range_lb_key_min);
        soc_mem_field32_set(unit, EGQ_PPCTm, data, SECOND_RANGE_LB_KEY_MAXf, EGQ_ppct_tbl_data->second_range_lb_key_max);
    }

    rv = WRITE_EGQ_PPCTm(unit, EGQ_BLOCK(unit, core_id), base_q_pair, data);
    SOCDNX_IF_ERR_EXIT(rv);

exit:
    SOCDNX_FUNC_RETURN;
}


#ifdef BCM_88660_A0

/*
 * Read indirect table egq_per_port_lb_range from block EGQ,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_per_port_lb_range_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32             entry_offset,
    SOC_SAND_OUT  ARAD_PER_PORT_LB_RANGE_TBL_DATA* EGQ_per_port_lb_range_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_EGQ_PER_PORT_LB_RANGE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(EGQ_per_port_lb_range_tbl_data);

  err = soc_sand_os_memset(
          EGQ_per_port_lb_range_tbl_data,
          0x0,
          sizeof(ARAD_PER_PORT_LB_RANGE_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_mem_read(
          unit,
          EGQ_PER_PORT_LB_RANGEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  SHR_BITCOPY_RANGE(&(EGQ_per_port_lb_range_tbl_data->lb_key_min), 0, data, 0, 8);
  SHR_BITCOPY_RANGE(&(EGQ_per_port_lb_range_tbl_data->lb_key_max), 0, data, 8, 8);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_per_port_lb_range_get_unsafe()",0,0);
}

/*
 * Write indirect table egq_per_port_lb_range from block EGQ,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_egq_per_port_lb_range_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_PER_PORT_LB_RANGE_TBL_DATA* EGQ_per_port_lb_range_tbl_data
  )
{
  uint32
    res, err;
  uint32    
    data[ARAD_EGQ_PER_PORT_LB_RANGE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(EGQ_per_port_lb_range_tbl_data);

  ARAD_CLEAR(data, uint32, ARAD_EGQ_PER_PORT_LB_RANGE_TBL_ENTRY_SIZE);
  
  SHR_BITCOPY_RANGE(data, 0, &(EGQ_per_port_lb_range_tbl_data->lb_key_min), 0, 8);
  SHR_BITCOPY_RANGE(data, 8, &(EGQ_per_port_lb_range_tbl_data->lb_key_max), 0, 8);          

  err = soc_mem_write(
          unit,
          EGQ_PER_PORT_LB_RANGEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_per_port_lb_range_tbl_set_unsafe()",0,0);
}

#endif /*BCM_88660_A0*/

/*
 * CAL table read and write: 
 *  
 * All scheduler calendars share the same table.
 *  The order is:
 *  MAL0-CALA
 *  MAL0-CALB
 *  MAL1-CALA
 *  MAL1-CALB
 *  ...
 *  CPU-CALA
 *  CPU-CALB
 *  RCY-CALA
 *  RCY-CALB
 */ 

#define ARAD_OFP_RATES_CAL_CHAN_ARB_BASE_SCH_OFFSET          0x0800
#define ARAD_OFP_RATES_CAL_LEN_SCH_OFFSET                    0x1000

int
  arad_sch_cal_tbl_get(
    SOC_SAND_IN   int                    unit,
    SOC_SAND_IN   int                    core_id,
    SOC_SAND_IN   uint32                 sch_offset,
    SOC_SAND_IN   uint32                 sch_to_get /*A (0) or B (1)*/,
    SOC_SAND_IN   uint32                 slots_count,
    SOC_SAND_OUT  uint32*                slots
  )
{
    uint32
        cal_offset,
        slot,
        entry;

    SOCDNX_INIT_FUNC_DEFS;

    cal_offset = ARAD_OFP_RATES_CAL_CHAN_ARB_BASE_SCH_OFFSET * (sch_offset / 8) + ((sch_offset % 8) * ARAD_OFP_NOF_RATES_CAL_SETS + sch_to_get) * ARAD_OFP_RATES_CAL_LEN_SCH_OFFSET;

    for(slot=0; slot < slots_count; slot++) {
        entry = 0;
        SOCDNX_IF_ERR_EXIT(READ_SCH_SCHEDULER_CREDIT_GENERATION_CALENDAR__CALm(unit, MEM_BLOCK_ALL, cal_offset+slot, &entry));
        soc_mem_field_get(unit, SCH_SCHEDULER_CREDIT_GENERATION_CALENDAR__CALm, &entry, HR_SELf, &(slots[slot]));
    }

exit:
    SOCDNX_FUNC_RETURN;
}

int
  arad_sch_cal_max_size_get(
    SOC_SAND_IN   int                    unit,
    SOC_SAND_IN   uint32                 sch_offset,
    SOC_SAND_OUT  uint32*                max_cal_size
   )
{
    SOCDNX_INIT_FUNC_DEFS;

    *max_cal_size = ARAD_OFP_RATES_CAL_LEN_SCH_MAX;

    SOCDNX_FUNC_RETURN;
}

int
  arad_sch_cal_tbl_set(
    SOC_SAND_IN   int                    unit,
    SOC_SAND_IN   int                    core_id,
    SOC_SAND_IN   uint32                 sch_offset,
    SOC_SAND_IN   uint32                 sch_to_set /*A (0) or B (1)*/,
    SOC_SAND_IN   uint32                 slots_count,
                  uint32*                slots
  )
{
    uint32
        cal_offset,
        slot,
        entry;

    SOCDNX_INIT_FUNC_DEFS;

    cal_offset = ARAD_OFP_RATES_CAL_CHAN_ARB_BASE_SCH_OFFSET * (sch_offset / 8) + ((sch_offset % 8) * ARAD_OFP_NOF_RATES_CAL_SETS + sch_to_set) * ARAD_OFP_RATES_CAL_LEN_SCH_OFFSET;

    for (slot=0; slot < slots_count; slot++) {
        entry = 0;
        soc_mem_field_set(unit, SCH_SCHEDULER_CREDIT_GENERATION_CALENDAR__CALm, &entry, HR_SELf, &(slots[slot]));
        SOCDNX_IF_ERR_EXIT(WRITE_SCH_SCHEDULER_CREDIT_GENERATION_CALENDAR__CALm(unit, MEM_BLOCK_ALL, cal_offset+slot, &entry));
    }

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Read indirect table drm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_drm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_DRM_TBL_DATA* SCH_drm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_DRM_TBL_ENTRY_SIZE];
  soc_mem_t mem ;
  soc_field_t field ;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_DRM_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(&(data[0]),0x0,sizeof(data)) ;
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err =soc_sand_os_memset(SCH_drm_tbl_data,0x0,sizeof(ARAD_SCH_DRM_TBL_DATA));
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  /*
   * Note that for Arad:
   * mem = (soc_mem_t)SCH_DEVICE_RATE_MEMORY__DRMm ;
   * field = (soc_field_t)DEVICE_RATEf ;
   * They are aliased in regs_alias.pm
   */
  mem = (soc_mem_t)SCH_SHARED_DEVICE_RATE_SHARED_DRMm ;
  field = (soc_field_t)SHARED_DRMf ;
  /*
   * Use SCH0 although, apparently, any of the two may be used.
   */
  err =soc_mem_read(unit,mem,SCH_BLOCK(unit, 0),entry_offset,data) ;
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  SCH_drm_tbl_data->device_rate = soc_mem_field32_get(unit,mem,data,field);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_drm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table drm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_drm_tbl_set_unsafe(
    SOC_SAND_IN   int                   unit,
    SOC_SAND_IN   uint32                entry_offset,
    SOC_SAND_IN   ARAD_SCH_DRM_TBL_DATA *SCH_drm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_DRM_TBL_ENTRY_SIZE];
  soc_mem_t mem ;
  soc_field_t field ;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_DRM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(&(data[0]),0x0,sizeof(data)) ;
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  /*
   * Note that for Arad:
   * mem = (soc_mem_t)SCH_DEVICE_RATE_MEMORY__DRMm ;
   * field = (soc_field_t)DEVICE_RATEf ;
   * They are aliased in regs_alias.pm
   */
  mem = (soc_mem_t)SCH_SHARED_DEVICE_RATE_SHARED_DRMm ;
  field = (soc_field_t)SHARED_DRMf ;
  /*
   * Use SCH0 although, apparently, any of the two may be used.
   */
  soc_mem_field32_set(unit,mem,data,field,SCH_drm_tbl_data->device_rate);
  err = soc_mem_write(unit,mem,SCH_BLOCK(unit, 0),entry_offset,data) ;
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_drm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table dsm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_dsm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_DSM_TBL_DATA* SCH_dsm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_DSM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_DSM_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_dsm_tbl_data,
          0x0,
          sizeof(ARAD_SCH_DSM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_DUAL_SHAPER_MEMORY_DSMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
    SCH_dsm_tbl_data->dual_shaper_ena   = soc_mem_field32_get(
            unit,
            SCH_DUAL_SHAPER_MEMORY_DSMm,
            data,
            DUAL_SHAPER_ENAf
    );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_dsm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table dsm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_dsm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_DSM_TBL_DATA* SCH_dsm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_DSM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_DSM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  {
    soc_mem_field32_set(
          unit,
          SCH_DUAL_SHAPER_MEMORY_DSMm,
          data,
          DUAL_SHAPER_ENAf,
          SCH_dsm_tbl_data->dual_shaper_ena
    ) ;
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          SCH_DUAL_SHAPER_MEMORY_DSMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_dsm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table fdms_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fdms_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_OUT  ARAD_SCH_FDMS_TBL_DATA* SCH_fdms_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FDMS_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FDMS_TBL_GET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FDMS_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FDMS_OFFSET;
  }
  
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_fdms_tbl_data,
          0x0,
          sizeof(ARAD_SCH_FDMS_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);
  err = soc_mem_read(
          unit,
          SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  SCH_fdms_tbl_data->sch_number   = soc_mem_field32_get(
      unit,SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data,SCH_NUMBERf            );
  SCH_fdms_tbl_data->cos   = soc_mem_field32_get(
      unit,SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data,COSf            );
  SCH_fdms_tbl_data->hrsel_dual   = soc_mem_field32_get(
      unit, SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data,HR_SEL_DUALf            );    
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fdms_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table fdms_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fdms_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_IN   ARAD_SCH_FDMS_TBL_DATA* SCH_fdms_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FDMS_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FDMS_TBL_SET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FDMS_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FDMS_OFFSET;
  }

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  soc_mem_field32_set(
      unit,SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data,SCH_NUMBERf,
      SCH_fdms_tbl_data->sch_number );
  soc_mem_field32_set(
      unit,SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data,COSf,
      SCH_fdms_tbl_data->cos );
  soc_mem_field32_set(
      unit, SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
      data, HR_SEL_DUALf,
      SCH_fdms_tbl_data->hrsel_dual );
  err = soc_mem_write(
          unit,
          SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fdms_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table shds_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_shds_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_SHDS_TBL_DATA* SCH_shds_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SHDS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SHDS_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_shds_tbl_data,
          0x0,
          sizeof(ARAD_SCH_SHDS_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
    SCH_shds_tbl_data->peak_rate_man_even   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  PEAK_RATE_MAN_EVENf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  {
    SCH_shds_tbl_data->peak_rate_exp_even   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  PEAK_RATE_EXP_EVENf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
  {
    SCH_shds_tbl_data->max_burst_even   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  MAX_BURST_EVENf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);
  {
    SCH_shds_tbl_data->slow_rate2_sel_even   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  SLOW_RATE_2_SEL_EVENf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);
  {
    SCH_shds_tbl_data->peak_rate_man_odd   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  PEAK_RATE_MAN_ODDf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);
  {
    SCH_shds_tbl_data->peak_rate_exp_odd   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  PEAK_RATE_EXP_ODDf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);
  {
    SCH_shds_tbl_data->max_burst_odd   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  MAX_BURST_ODDf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 46, exit);
  {
    SCH_shds_tbl_data->slow_rate2_sel_odd   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  SLOW_RATE_2_SEL_ODDf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 47, exit);
  /*
   * The following clause is for Arad only (not for Jericho).
   */
  {
    SCH_shds_tbl_data->max_burst_update_even   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  MAX_BURST_UPDATE_EVENf            );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 48, exit);
    SCH_shds_tbl_data->max_burst_update_odd   = soc_mem_field32_get(
                  unit,
                  SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
                  data,
                  MAX_BURST_UPDATE_ODDf            );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 49, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_shds_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table shds_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_shds_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_SHDS_TBL_DATA* SCH_shds_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SHDS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SHDS_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          PEAK_RATE_MAN_EVENf,
          SCH_shds_tbl_data->peak_rate_man_even );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          PEAK_RATE_EXP_EVENf,
          SCH_shds_tbl_data->peak_rate_exp_even );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          MAX_BURST_EVENf,
          SCH_shds_tbl_data->max_burst_even );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          SLOW_RATE_2_SEL_EVENf,
          SCH_shds_tbl_data->slow_rate2_sel_even );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          PEAK_RATE_MAN_ODDf,
          SCH_shds_tbl_data->peak_rate_man_odd );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          PEAK_RATE_EXP_ODDf,
          SCH_shds_tbl_data->peak_rate_exp_odd );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          MAX_BURST_ODDf,
          SCH_shds_tbl_data->max_burst_odd );
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          SLOW_RATE_2_SEL_ODDf,
          SCH_shds_tbl_data->slow_rate2_sel_odd );
  }
  /*
   * The following clause is for Arad only (not for Jericho).
   */
  {
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          MAX_BURST_UPDATE_EVENf,
          SCH_shds_tbl_data->max_burst_update_even );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 38, exit);
    soc_mem_field32_set(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          data,
          MAX_BURST_UPDATE_ODDf,
          SCH_shds_tbl_data->max_burst_update_odd );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 39, exit);
  }
  err = soc_mem_write(
          unit,
          SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_shds_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table sem_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_sch_sem_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_SEM_TBL_DATA* SCH_sem_tbl_data
  )
{
  uint32
    res;
  uint32
    data[ARAD_SCH_SEM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SEM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_SCH_SEM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(SCH_sem_tbl_data, ARAD_SCH_SEM_TBL_DATA, 1);

  res = soc_mem_read(unit, SCH_SCHEDULER_ENABLE_MEMORY_SEMm, SCH_BLOCK(unit,core), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  SCH_sem_tbl_data->sch_enable = soc_mem_field32_get(unit, SCH_SCHEDULER_ENABLE_MEMORY_SEMm, data, SCH_ENABLEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_sem_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table sem_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_sem_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_SEM_TBL_DATA* SCH_sem_tbl_data
  )
{
  uint32
    res;
  uint32
    data[ARAD_SCH_SEM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SEM_TBL_SET_UNSAFE);
  ARAD_CLEAR(data, uint32, ARAD_SCH_SEM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, SCH_SCHEDULER_ENABLE_MEMORY_SEMm, data, SCH_ENABLEf, SCH_sem_tbl_data->sch_enable);

  res = soc_mem_write(
          unit,
          SCH_SCHEDULER_ENABLE_MEMORY_SEMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );


  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      if (SOC_IS_QUX(unit)) {
        soc_mem_field32_set(unit, SCH_MEM_07100000m, data, ITEM_0_7f ,SCH_sem_tbl_data->sch_enable);
        res = soc_mem_write(unit, SCH_MEM_07100000m, SCH_BLOCK(unit, core), entry_offset, data);
      }
      else {
        soc_mem_field32_set(unit, SCH_SCHEDULER_ENABLE_MEMORY_SEM_Bm, data, SCH_ENABLEf ,SCH_sem_tbl_data->sch_enable);
        res = soc_mem_write(unit, SCH_SCHEDULER_ENABLE_MEMORY_SEM_Bm, SCH_BLOCK(unit, core), entry_offset, data);
      }
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 37, exit);
  }

  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_sem_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table fsf_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fsf_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_OUT  ARAD_SCH_FSF_TBL_DATA* SCH_fsf_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FSF_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FSF_TBL_GET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FSF_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FSF_OFFSET;
  }
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_fsf_tbl_data,
          0x0,
          sizeof(ARAD_SCH_FSF_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

   err = soc_mem_read(
          unit,
          SCH_FLOW_SUB_FLOW_FSFm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
      SCH_fsf_tbl_data->sfenable   = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_SUB_FLOW_FSFm,
                  data,
                  SF_ENABLEf            
      );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fsf_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table fsf_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fsf_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_IN   ARAD_SCH_FSF_TBL_DATA* SCH_fsf_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FSF_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FSF_TBL_SET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FSF_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FSF_OFFSET;
  }

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  {
    soc_mem_field32_set(
          unit,
          SCH_FLOW_SUB_FLOW_FSFm,
          data,
          SF_ENABLEf,
          SCH_fsf_tbl_data->sfenable
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          SCH_FLOW_SUB_FLOW_FSFm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fsf_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table fgm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fgm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_FGM_TBL_DATA* SCH_fgm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FGM_TBL_ENTRY_SIZE];
 
 
 
  uint32
    fld_idx = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FGM_TBL_GET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_fgm_tbl_data,
          0x0,
          sizeof(ARAD_SCH_FGM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_FLOW_GROUP_MEMORY_FGMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  for (fld_idx = 0; fld_idx < ARAD_TBL_FGM_NOF_GROUPS_ONE_LINE; fld_idx++)
  {
    {
          SCH_fgm_tbl_data->flow_group[fld_idx]     = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_GROUP_MEMORY_FGMm,
                  data,
                  FLOW_GROUP_0f + fld_idx            
        );
    }
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fgm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table fgm_tbl from block SCH,
 * doesn't take semaphore!
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fgm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_FGM_TBL_DATA* SCH_fgm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FGM_TBL_ENTRY_SIZE];
  uint32
    fld_idx = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FGM_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  for (fld_idx = 0; fld_idx < ARAD_TBL_FGM_NOF_GROUPS_ONE_LINE; fld_idx++)
  {
    {
      soc_mem_field32_set(
          unit,
          SCH_FLOW_GROUP_MEMORY_FGMm,
          data,
          FLOW_GROUP_0f + fld_idx,
            SCH_fgm_tbl_data->flow_group[fld_idx]
          );
    }
    SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 20, exit);
  }
  err = soc_mem_write(
          unit,
          SCH_FLOW_GROUP_MEMORY_FGMm,
          SCH_BLOCK(unit,core),
          entry_offset,
            data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fgm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table shc_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_sch_shc_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_SHC_TBL_DATA* SCH_shc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SHC_TBL_ENTRY_SIZE];
 
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SHC_TBL_GET_UNSAFE);

  SOC_SAND_ERR_IF_ABOVE_MAX(core, SOC_DPP_DEFS_GET(unit, nof_cores) , ARAD_CORE_INDEX_OUT_OF_RANGE_ERR,15,exit);
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_shc_tbl_data,
          0x0,
          sizeof(ARAD_SCH_SHC_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_HR_SCHEDULER_CONFIGURATION_SHCm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
    SCH_shc_tbl_data->hrmode =
      soc_mem_field32_get(
        unit,
        SCH_HR_SCHEDULER_CONFIGURATION_SHCm,
        data,
        HR_MODEf
      );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

  SOC_SAND_CHECK_FUNC_RESULT(err, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_shc_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table shc_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_shc_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_SHC_TBL_DATA* SCH_shc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SHC_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SHC_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

 {
    soc_mem_field32_set(
          unit,
          SCH_HR_SCHEDULER_CONFIGURATION_SHCm,
          data,
          HR_MODEf,
          SCH_shc_tbl_data->hrmode );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);

  err = soc_mem_write(
          unit,
          SCH_HR_SCHEDULER_CONFIGURATION_SHCm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_shc_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table scc_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_scc_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_OUT  ARAD_SCH_SCC_TBL_DATA* SCH_scc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SCC_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SCC_TBL_GET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_SCC_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_SCC_OFFSET;
  }
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_scc_tbl_data,
          0x0,
          sizeof(ARAD_SCH_SCC_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_CL_SCHEDULERS_CONFIGURATION_SCCm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
    SCH_scc_tbl_data->clsch_type =
      soc_mem_field32_get(
                  unit,
                  SCH_CL_SCHEDULERS_CONFIGURATION_SCCm,
                  data,
                  CL_SCH_TYPEf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_scc_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table scc_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_scc_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_IN   ARAD_SCH_SCC_TBL_DATA* SCH_scc_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SCC_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SCC_TBL_SET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_SCC_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_SCC_OFFSET;
  }

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_CONFIGURATION_SCCm,
          data,
          CL_SCH_TYPEf,
          SCH_scc_tbl_data->clsch_type
    );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  err = soc_mem_write(
          unit,
          SCH_CL_SCHEDULERS_CONFIGURATION_SCCm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_scc_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table sct_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_sct_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_OUT  ARAD_SCH_SCT_TBL_DATA* SCH_sct_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SCT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SCT_TBL_GET_UNSAFE);
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_sct_tbl_data,
          0x0,
          sizeof(ARAD_SCH_SCT_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);
  err = soc_mem_read(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  {
    SCH_sct_tbl_data->clconfig   = soc_mem_field32_get(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          CL_CONFIGf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  {
    SCH_sct_tbl_data->af0_inv_weight   = soc_mem_field32_get(
            unit,
            SCH_CL_SCHEDULERS_TYPE_SCTm,
            data,
            AF_0_INV_WEIGHTf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
  {
    SCH_sct_tbl_data->af1_inv_weight   = soc_mem_field32_get(
         unit,
         SCH_CL_SCHEDULERS_TYPE_SCTm,
         data,
         AF_1_INV_WEIGHTf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);
  {
    SCH_sct_tbl_data->af2_inv_weight   = soc_mem_field32_get(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          AF_2_INV_WEIGHTf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 43, exit);
  {
    SCH_sct_tbl_data->af3_inv_weight   = soc_mem_field32_get(
         unit,
         SCH_CL_SCHEDULERS_TYPE_SCTm,
         data,
         AF_3_INV_WEIGHTf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 44, exit);
  {
    SCH_sct_tbl_data->wfqmode   = soc_mem_field32_get(
         unit,
         SCH_CL_SCHEDULERS_TYPE_SCTm,
         data,
         WFQ_MODEf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 45, exit);
  {
    SCH_sct_tbl_data->enh_clen   = soc_mem_field32_get(
        unit,
        SCH_CL_SCHEDULERS_TYPE_SCTm,
        data,
        ENH_CL_ENf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 46, exit);
  {
    SCH_sct_tbl_data->enh_clsphigh   = soc_mem_field32_get(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          ENH_CL_SP_HIGHf            
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 47, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_sct_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table sct_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_sct_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_SCT_TBL_DATA* SCH_sct_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_SCT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SCT_TBL_SET_UNSAFE);
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit) ;
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          CL_CONFIGf,
          SCH_sct_tbl_data->clconfig );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          AF_0_INV_WEIGHTf,
          SCH_sct_tbl_data->af0_inv_weight
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          AF_1_INV_WEIGHTf,
          SCH_sct_tbl_data->af1_inv_weight
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          AF_2_INV_WEIGHTf,
          SCH_sct_tbl_data->af2_inv_weight
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          AF_3_INV_WEIGHTf,
          SCH_sct_tbl_data->af3_inv_weight
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 34, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          WFQ_MODEf,
          SCH_sct_tbl_data->wfqmode
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 35, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          ENH_CL_ENf,
          SCH_sct_tbl_data->enh_clen
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 36, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          data,
          ENH_CL_SP_HIGHf,
          SCH_sct_tbl_data->enh_clsphigh
        );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 37, exit);

  err = soc_mem_write(
          unit,
          SCH_CL_SCHEDULERS_TYPE_SCTm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 38, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_sct_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table fqm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_fqm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_OUT  ARAD_SCH_FQM_TBL_DATA* SCH_fqm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FQM_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FQM_TBL_GET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FQM_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FQM_OFFSET;
  }
  
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_fqm_tbl_data,
          0x0,
          sizeof(ARAD_SCH_FQM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);

  err = soc_mem_read(
          unit,
          SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  {
    SCH_fqm_tbl_data->base_queue_num   = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
                  data,
                  BASE_QUEUE_NUMf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
  {
    SCH_fqm_tbl_data->sub_flow_mode   = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
                  data,
                  SUB_FLOW_MODEf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
  {
    SCH_fqm_tbl_data->flow_slow_enable   = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
                  data,
                  FLOW_SLOW_ENABLEf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 42, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fqm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table fqm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_sch_fqm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_IN   ARAD_SCH_FQM_TBL_DATA* SCH_fqm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FQM_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FQM_TBL_SET_UNSAFE);

  if (SOC_IS_QUX(unit)) {
      entry_offset -= QUX_SCH_FQM_OFFSET;
  }
  else if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FQM_OFFSET;
  }

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
          data,
          BASE_QUEUE_NUMf,
          SCH_fqm_tbl_data->base_queue_num );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
          data,
          SUB_FLOW_MODEf,
          SCH_fqm_tbl_data->sub_flow_mode );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
          data,
          FLOW_SLOW_ENABLEf,
          SCH_fqm_tbl_data->flow_slow_enable );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);
  err = soc_mem_write(
          unit,
          SCH_FLOW_TO_QUEUE_MAPPING_FQMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 33, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_fqm_tbl_set_unsafe()",0,0);
}

/*
 * Read indirect table ffm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_ffm_tbl_get_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_OUT  ARAD_SCH_FFM_TBL_DATA* SCH_ffm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FFM_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FFM_TBL_GET_UNSAFE);
  if (SOC_IS_QUX(unit)) {
    SOC_EXIT;
  }
  if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FFM_OFFSET;
  }

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  err = soc_sand_os_memset(
          SCH_ffm_tbl_data,
          0x0,
          sizeof(ARAD_SCH_FFM_TBL_DATA)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 15, exit);
  err = soc_mem_read(
          unit,
          SCH_FLOW_TO_FIP_MAPPING_FFMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  {
    SCH_ffm_tbl_data->device_number   = soc_mem_field32_get(
                  unit,
                  SCH_FLOW_TO_FIP_MAPPING_FFMm,
                  data,
                  DEVICE_NUMBERf            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_ffm_tbl_get_unsafe()",0,0);
}

/*
 * Write indirect table ffm_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_ffm_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              offset,
    SOC_SAND_IN   ARAD_SCH_FFM_TBL_DATA* SCH_ffm_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FFM_TBL_ENTRY_SIZE];
  uint32
    entry_offset = offset;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FFM_TBL_SET_UNSAFE);
  if (SOC_IS_QUX(unit)) {
      SOC_EXIT;
  }
  if (SOC_IS_QAX(unit)) {
      entry_offset -= QAX_SCH_FFM_OFFSET;
  }
  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);
  {
    soc_mem_field32_set(
          unit,
          SCH_FLOW_TO_FIP_MAPPING_FFMm,
          data,
          DEVICE_NUMBERf,
          SCH_ffm_tbl_data->device_number );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);
  err = soc_mem_write(
          unit,
          SCH_FLOW_TO_FIP_MAPPING_FFMm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 31, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_ffm_tbl_set_unsafe()",0,0);
}
/*
 * Write indirect table scheduler_init_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */


uint32
  arad_sch_scheduler_init_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_SCHEDULER_INIT_TBL_DATA* SCH_scheduler_init_tbl_data
  )
{
  uint32 err, res, reg_val,i;
  uint32 data[ARAD_SCH_SCHEDULER_INIT_TBL_ENTRY_SIZE] = {0};
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_SCHEDULER_INIT_TBL_SET_UNSAFE);

  /* clear on set to all the sch memory error interrupts */  
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  30,  exit, ARAD_REG_ACCESS_ERR,WRITE_SCH_PAR_ERR_INTERRUPT_REGISTERr(unit,  0xffffffff));
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  31,  exit, ARAD_REG_ACCESS_ERR,WRITE_SCH_ECC_1B_ERR_INTERRUPT_REGISTERr(unit,  0xffffffff));
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  32,  exit, ARAD_REG_ACCESS_ERR,WRITE_SCH_ECC_2B_ERR_INTERRUPT_REGISTERr(unit,  0xffffffff));

  soc_mem_field32_set(unit, SCH_SCHEDULER_INITm, data, SCH_INITf, SCH_scheduler_init_tbl_data->schinit);

  /* keep current timeout and set a new timeout needed for writing this special table */
  SOC_SAND_CHECK_FUNC_RESULT(READ_CMIC_SBUS_TIMEOUTr(unit, &reg_val), 10, exit);
  SOC_SAND_CHECK_FUNC_RESULT(WRITE_CMIC_SBUS_TIMEOUTr(unit, 0xffffffff), 20, exit);

   if (!SOC_IS_ARADPLUS(unit)) {
      /* write the table entry */
      err = WRITE_SCH_SCHEDULER_INITm(unit, MEM_BLOCK_ANY, entry_offset, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 40, exit);
   } else {
       
        for (i=0; i<5; i++) {
            err = WRITE_SCH_SCHEDULER_INITm(unit, MEM_BLOCK_ANY, entry_offset, data);
            if (SOC_E_NONE == err) {
                break;
            } else {
                sal_sleep(1);
            }
        }
        SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 41, exit);
   }
  
  /* restore original timeout */
  SOC_SAND_CHECK_FUNC_RESULT(WRITE_CMIC_SBUS_TIMEOUTr(unit, reg_val), 50, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_scheduler_init_tbl_set_unsafe()",0,0);
}

/*
 * Write indirect table force_status_message_tbl from block SCH,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_sch_force_status_message_tbl_set_unsafe(
    SOC_SAND_IN   int             unit,
    SOC_SAND_IN   int             core,
    SOC_SAND_IN   uint32              entry_offset,
    SOC_SAND_IN   ARAD_SCH_FORCE_STATUS_MESSAGE_TBL_DATA* SCH_force_status_message_tbl_data
  )
{
  uint32
    err;
  uint32
    data[ARAD_SCH_FORCE_STATUS_MESSAGE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_SCH_FORCE_STATUS_MESSAGE_TBL_SET_UNSAFE);

  err = soc_sand_os_memset(
          &(data[0]),
          0x0,
          sizeof(data)
        );
  SOC_SAND_CHECK_FUNC_RESULT(err, 10, exit);

  soc_mem_field32_set(
          unit,
          SCH_FORCE_STATUS_MESSAGEm,
          data,
          MESSAGE_FLOW_IDf,
          SCH_force_status_message_tbl_data->message_flow_id );
  soc_mem_field32_set(
          unit,
          SCH_FORCE_STATUS_MESSAGEm,
          data,
          MESSAGE_TYPEf,
          SCH_force_status_message_tbl_data->message_type );
  err = soc_mem_write(
          unit,
          SCH_FORCE_STATUS_MESSAGEm,
          SCH_BLOCK(unit,core),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 32, exit);
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_sch_force_status_message_tbl_set_unsafe()",0,0);
}


/*
 * Get the number of banks and number of Drams
 */
uint32
  arad_mmu_dram_address_space_info_get_unsafe(
    SOC_SAND_IN    int                               unit,
    SOC_SAND_OUT   uint32                                *nof_drams,
    SOC_SAND_OUT   uint32                                *nof_banks,
    SOC_SAND_OUT   uint32                                *nof_cols
  )
{
  uint32
    res;
  uint32
    reg_val,
    tmp_val;
   
    

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_MMU_DRAM_ADDRESS_SPACE_INFO_GET_UNSAFE);


  
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  30,  exit, ARAD_REG_ACCESS_ERR,READ_MMU_GENERAL_CONFIGURATION_REGISTER_2r(unit, &reg_val ));

  ARAD_FLD_FROM_REG(MMU_GENERAL_CONFIGURATION_REGISTER_2r, DRAM_NUMf, tmp_val, reg_val, 40, exit);

 /*
  * check IF DRAM ID in range.
  */
  switch(tmp_val) {
  case 0x3:
    *nof_drams = 2;
    break;
  case 0x2:
    *nof_drams = 3;
    break;
  case 0x1:
    *nof_drams = 4;
    break;
  case 0x0:
      *nof_drams = 6;
    break;
  case 0x4:
  default:
    *nof_drams = 8;
    break;
  }
 /*
  * check If BANK ID in range.
  */
  ARAD_FLD_FROM_REG(MMU_GENERAL_CONFIGURATION_REGISTERr, DRAM_BANK_NUMf, tmp_val, reg_val, 60, exit);

  switch(tmp_val)
  {
    case 0x0:
      *nof_banks = ARAD_DRAM_NUM_BANKS_4;
      break;
    case 0x1:
    default:
      *nof_banks = ARAD_DRAM_NUM_BANKS_8;
      break;
  }

  ARAD_FLD_FROM_REG(MMU_GENERAL_CONFIGURATION_REGISTERr, DRAM_COL_NUMf, tmp_val, reg_val, 80, exit);

  switch(tmp_val) {
  case 0x0:
    *nof_cols = 256;
    break;
  case 0x1:
    *nof_cols = 512;
    break;
  case 0x2:
    *nof_cols = 1024;
    break;
  case 0x3:
    *nof_cols = 2048;
    break;
  case 0x4:
    *nof_cols = 4096;
    break;
  default:
    *nof_cols = 8192;
    break;
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_mmu_dram_address_space_info_get()",0,0);
}

/* 
 *  TM-Tables - B
 */ 

/*
 * Read indirect table nif_port_to_ctxt_bit_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ire_nif_port_to_ctxt_bit_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_DATA  *IRE_nif_port_to_ctxt_bit_map_tbl_data
  )
{
  uint32
    res, err = SOC_SAND_OK;
  uint32
    data[ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(IRE_nif_port_to_ctxt_bit_map_tbl_data, ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_DATA, 1);

  err = soc_mem_read(
          unit,
          IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(err, 30, exit);

  soc_mem_field_get(
            unit,
            IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
            data,
            CONTEXTS_BIT_MAPPINGf,
            (uint32*)&(IRE_nif_port_to_ctxt_bit_map_tbl_data->contexts_bit_mapping[0]) );  
  
  IRE_nif_port_to_ctxt_bit_map_tbl_data->parity   = soc_mem_field32_get(
                  unit,
                  IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
                  data,
                  PARITYf            );
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_nif_port_to_ctxt_bit_map_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table nif_port_to_ctxt_bit_map_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ire_nif_port_to_ctxt_bit_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_DATA  *IRE_nif_port_to_ctxt_bit_map_tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRE_NIF_PORT_TO_CTXT_BIT_MAP_TBL_ENTRY_SIZE);

 
            soc_mem_field_set(
          unit,
          IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
          data,
          CONTEXTS_BIT_MAPPINGf,
          (uint32*)&(IRE_nif_port_to_ctxt_bit_map_tbl_data->contexts_bit_mapping[0]));
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IRE_NIF_PORT_TO_CTXT_BIT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_nif_port_to_ctxt_bit_map_tbl_set_unsafe()", entry_offset, 0);
}

/*
 * Read indirect table tdm_config_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ire_tdm_config_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IRE_TDM_CONFIG_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_MAX_MEM_WORDS];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_TDM_CONFIG_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRE_TDM_CONFIG_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRE_TDM_CONFIG_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRE_TDM_CONFIGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->mode = soc_mem_field32_get(
          unit,
          IRE_TDM_CONFIGm,
          data,
          MODEf );

  tbl_data->cpu   = soc_mem_field32_get(
          unit,
          IRE_TDM_CONFIGm,
          data,
          CPUf );

  soc_mem_field_get(
                  unit,
                  IRE_TDM_CONFIGm,
                  data,
                  HEADERf,
              tbl_data->header);

  
  if (!SOC_IS_QAX(unit)) {
      tbl_data->add_packet_crc  = soc_mem_field32_get(
                      unit,
                      IRE_TDM_CONFIGm,
                      data,
                      ADD_PACKET_CRCf );
  }

  if (SOC_IS_JERICHO(unit)) {
      tbl_data->mc_replication  = soc_mem_field32_get(
                          unit,
                          IRE_TDM_CONFIGm,
                          data,
                          MC_REPLICATIONf );
  }

  tbl_data->link_mask_ptr = soc_mem_field32_get(
                  unit,
                  IRE_TDM_CONFIGm,
                  data,
                  LINK_MASK_PTRf );
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_tdm_config_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table tdm_config_tbl from block IRE,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ire_tdm_config_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRE_TDM_CONFIG_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_MAX_MEM_WORDS];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRE_TDM_CONFIG_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRE_TDM_CONFIG_TBL_ENTRY_SIZE);

      soc_mem_field32_set(
          unit,
          IRE_TDM_CONFIGm,
          data,
          MODEf,
          tbl_data->mode );

            soc_mem_field32_set(
          unit,
          IRE_TDM_CONFIGm,
          data,
          CPUf,
          tbl_data->cpu );

            soc_mem_field_set(
          unit,
          IRE_TDM_CONFIGm,
          data,
          HEADERf,
          (uint32*)&(tbl_data->header[0]));

  soc_mem_field32_set(
          unit,
          IRE_TDM_CONFIGm,
          data,
          LINK_MASK_PTRf,
          tbl_data->link_mask_ptr );

  
  if (!SOC_IS_QAX(unit)) {
       soc_mem_field32_set(
              unit,
              IRE_TDM_CONFIGm,
              data,
              ADD_PACKET_CRCf,
              tbl_data->add_packet_crc );
  }

  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(
            unit,
            IRE_TDM_CONFIGm,
            data,
            MC_REPLICATIONf,
            tbl_data->mc_replication );
  }

  res = soc_mem_write(
          unit,
          IRE_TDM_CONFIGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ire_tdm_config_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table context_mru_tbl from block IDR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_idr_context_mru_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IDR_CONTEXT_MRU_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IDR_CONTEXT_MRU_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IDR_CONTEXT_MRU_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IDR_CONTEXT_MRU_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IDR_CONTEXT_MRU_TBL_DATA, 1);

 
 



  

  res = soc_mem_read(
          unit,
          IDR_CONTEXT_MRUm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->org_size   = soc_mem_field32_get(
                  unit,
                  IDR_CONTEXT_MRUm ,
                  data,
                  MAX_ORG_SIZEf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->size   = soc_mem_field32_get(
                  unit,
                  IDR_CONTEXT_MRUm,
                  data,
                  MAX_SIZEf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

          tbl_data->parity   = soc_mem_field32_get(
                  unit,
                  IDR_CONTEXT_MRUm,
                  data,
                  PARITYf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_idr_context_mru_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table context_mru_tbl from block IDR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_idr_context_mru_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IDR_CONTEXT_MRU_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IDR_CONTEXT_MRU_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IDR_CONTEXT_MRU_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IDR_CONTEXT_MRU_TBL_ENTRY_SIZE);

 
 



  

            soc_mem_field32_set(
          unit,
          IDR_CONTEXT_MRUm,
          data,
          MAX_ORG_SIZEf,
          tbl_data->org_size );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          IDR_CONTEXT_MRUm,
          data,
          MAX_SIZEf,
          tbl_data->size );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);


  res = soc_mem_write(
          unit,
          IDR_CONTEXT_MRUm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 33, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_idr_context_mru_tbl_set_unsafe()", entry_offset, 0);
}

/*
 * Read indirect table destination_table_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_destination_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IRR_DESTINATION_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  soc_mem_t mem;
  soc_field_t valid_field;
  uint32 data[ARAD_IRR_DESTINATION_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_DESTINATION_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_DESTINATION_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_DESTINATION_TABLE_TBL_DATA, 1);

  if (SOC_IS_QAX(unit)) {
      mem = TAR_DESTINATION_TABLEm; 
      valid_field = VALIDf;
  } else {
      mem = IRR_DESTINATION_TABLEm; 
      valid_field = VALID_0f;
  }

  res = soc_mem_read(unit, mem, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->queue_number = soc_mem_field32_get(unit, mem, data, QUEUE_NUMBERf);
  tbl_data->tc_profile   = soc_mem_field32_get(unit, mem, data, TC_PROFILEf);

  if ((SOC_IS_JERICHO(unit))) {
      tbl_data->valid[0] = soc_mem_field32_get(unit, mem, data, valid_field);

      if (!SOC_DPP_CORE_MODE_IS_SINGLE_CORE(unit)) {
          tbl_data->valid[1] = soc_mem_field32_get(unit, mem, data, VALID_1f);
      } else {
          tbl_data->valid[1] = 0x0;
      }
  } else {
      tbl_data->valid[0] = 0x1;
      tbl_data->valid[1] = 0x0;
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_destination_table_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table destination_table_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_destination_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRR_DESTINATION_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;

  soc_mem_t mem;
  soc_field_t valid_field;
  uint32 data[ARAD_IRR_DESTINATION_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_DESTINATION_TABLE_TBL_SET_UNSAFE);

  if (SOC_IS_QAX(unit)) {
      mem = TAR_DESTINATION_TABLEm; 
      valid_field = VALIDf;
  } else {
      mem = IRR_DESTINATION_TABLEm; 
      valid_field = VALID_0f;
  }

  ARAD_CLEAR(data, uint32, ARAD_IRR_DESTINATION_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, mem, data, QUEUE_NUMBERf, tbl_data->queue_number);
  soc_mem_field32_set(unit, mem, data, TC_PROFILEf, tbl_data->tc_profile);

  if ((SOC_IS_JERICHO(unit))) {
      soc_mem_field32_set(unit, mem, data, valid_field, (uint32)tbl_data->valid[0]);
      if (!SOC_DPP_CORE_MODE_IS_SINGLE_CORE(unit)) {
          soc_mem_field32_set(unit, mem, data, VALID_1f, (uint32)tbl_data->valid[1]);
      }
  }

  res = soc_mem_write(unit, mem, MEM_BLOCK_ALL, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 34, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_destination_table_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table lag_to_lag_range_tbl from block IRR,
 * doesn't take semaphore. 
 *  
 * Arad+: 
 *   Also read the (IHB)IPP_LAG_TO_LAG_RANGE table which is
 *   duplicated from the TM, with the Mode field changed to
 *   IsStateful (if 1 then the LAG is stateful).
 *   For get, we only use the IsStateful bit.
 *   Specifically, the Range and Parity fields are ignored.
 *  
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_lag_to_lag_range_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IRR_LAG_TO_LAG_RANGE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_LAG_TO_LAG_RANGE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_LAG_TO_LAG_RANGE_TBL_DATA, 1);

  mem = ARAD_PP_LAG_BY_CHIP(unit, LAG_TO_LAG_RANGE);

  res = soc_mem_read(unit, mem, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  tbl_data->range   = soc_mem_field32_get(unit, mem, data, RANGEf);
  tbl_data->mode    = soc_mem_field32_get(unit, mem, data, MODEf);

#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE);

    res = READ_IHB_IPP_LAG_TO_LAG_RANGEm(unit, MEM_BLOCK_ANY, entry_offset, data);
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

    tbl_data->is_stateful = soc_mem_field32_get(unit, IHB_IPP_LAG_TO_LAG_RANGEm, data, IS_STATEFULf);
  }  
#endif /* BCM_88660_A0 */

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_lag_to_lag_range_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table lag_to_lag_range_tbl from block IRR,
 * doesn't take semaphore. 
 * 
 * Arad+: 
 *   Also update the (IHB)IPP_LAG_TO_LAG_RANGE table which is
 *   duplicated from the TM, with the Mode field changed to
 *   IsStateful (if 1 then the LAG is stateful).
 *  
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_lag_to_lag_range_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRR_LAG_TO_LAG_RANGE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_LAG_TO_LAG_RANGE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE);

  mem = ARAD_PP_LAG_BY_CHIP(unit, LAG_TO_LAG_RANGE);

  soc_mem_field32_set(unit, mem, data, RANGEf, tbl_data->range);
  soc_mem_field32_set(unit, mem, data, MODEf, tbl_data->mode);

  res = soc_mem_write(unit, mem, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_TO_LAG_RANGE_TBL_ENTRY_SIZE);

    soc_mem_field32_set(unit, IHB_IPP_LAG_TO_LAG_RANGEm, data, RANGEf, tbl_data->range);
    soc_mem_field32_set(unit, IHB_IPP_LAG_TO_LAG_RANGEm, data, IS_STATEFULf, tbl_data->is_stateful);

    res = soc_mem_write(unit, IHB_IPP_LAG_TO_LAG_RANGEm, MEM_BLOCK_ANY, entry_offset, data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);
  }  
#endif /* BCM_88660_A0 */

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_lag_to_lag_range_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table lag_mapping_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_lag_mapping_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN   uint32              lag_ndx,
    SOC_SAND_IN   uint32              port_ndx,
    SOC_SAND_OUT ARAD_IRR_LAG_MAPPING_TBL_DATA  *tbl_data
  )
{
  uint32 entry_offset,
  res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_LAG_MAPPING_TBL_ENTRY_SIZE];
  soc_mem_t mem;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_LAG_MAPPING_TBL_GET_UNSAFE);

  entry_offset = (lag_ndx * arad_ports_lag_nof_lag_entries_get_unsafe(unit)) | port_ndx;

  ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_MAPPING_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_LAG_MAPPING_TBL_DATA, 1);

  mem = ARAD_PP_LAG_BY_CHIP(unit, LAG_MAPPING);

  res = soc_mem_read(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->destination   = soc_mem_field32_get(
                  unit,
                  mem,
                  data,
                  DESTINATIONf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_lag_mapping_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table lag_mapping_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_lag_mapping_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN   uint32              lag_ndx,
    SOC_SAND_IN   uint32              port_ndx,
    SOC_SAND_IN  ARAD_IRR_LAG_MAPPING_TBL_DATA  *tbl_data
  )
{
  uint32 entry_offset,
  res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_LAG_MAPPING_TBL_ENTRY_SIZE];
  soc_mem_t mem;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_LAG_MAPPING_TBL_SET_UNSAFE);

  entry_offset = (lag_ndx * arad_ports_lag_nof_lag_entries_get_unsafe(unit)) | port_ndx;

  ARAD_CLEAR(data, uint32, ARAD_IRR_LAG_MAPPING_TBL_ENTRY_SIZE);

  mem = ARAD_PP_LAG_BY_CHIP(unit, LAG_MAPPING);
 
   soc_mem_field32_set(
          unit,
          mem,
          data,
          DESTINATIONf,
          tbl_data->destination );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_lag_mapping_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table smooth_division_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_smooth_division_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN   uint32              lag_size,
    SOC_SAND_IN   uint32              hash_val,
    SOC_SAND_OUT ARAD_IRR_SMOOTH_DIVISION_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 entry_offset,
         data[ARAD_IRR_SMOOTH_DIVISION_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_SMOOTH_DIVISION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_SMOOTH_DIVISION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_SMOOTH_DIVISION_TBL_DATA, 1);

  mem = ARAD_PP_LAG_BY_CHIP(unit, SMOOTH_DIVISION);

  entry_offset = lag_size << ARAD_IRR_GLAG_DEVISION_HASH_NOF_BITS;
  entry_offset |= hash_val;

  res = soc_mem_read(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->member   = soc_mem_field32_get(
                  unit,
                  mem,
                  data,
                  MEMBER_0f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_smooth_division_tbl_get_unsafe()", lag_size, hash_val);
}

/*
 * Write indirect table smooth_division_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_smooth_division_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN   uint32              lag_size,
    SOC_SAND_IN   uint32              hash_val,
    SOC_SAND_IN  ARAD_IRR_SMOOTH_DIVISION_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 entry_offset,
         data[ARAD_IRR_SMOOTH_DIVISION_TBL_ENTRY_SIZE];
  soc_mem_t mem;
 
 
 SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_SMOOTH_DIVISION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_SMOOTH_DIVISION_TBL_ENTRY_SIZE);

  mem = ARAD_PP_LAG_BY_CHIP(unit, SMOOTH_DIVISION);

 entry_offset = lag_size << (ARAD_IRR_GLAG_DEVISION_HASH_NOF_BITS-1);
 entry_offset |= (hash_val/2);

  res = soc_mem_read(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

  if(hash_val%2 == 0) {
      soc_mem_field32_set(
              unit,
              mem,
              data,
              MEMBER_0f,
              tbl_data->member );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else{
      soc_mem_field32_set(
              unit,
              mem,
              data,
              MEMBER_1f,
              tbl_data->member );
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
  }

  res = soc_mem_write(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_smooth_division_tbl_set_unsafe()", lag_size, hash_val);
}

/*
 * Read indirect table traffic_class_mapping_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_traffic_class_mapping_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_ENTRY_SIZE];
  int32
    tc_ndx = 0;
  uint32
    tmp = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_DATA, 1);
  if (SOC_IS_JERICHO(unit)) {
      if (core_id == 0 || core_id == SOC_CORE_ALL) {
          res = READ_IRR_TRAFFIC_CLASS_MAPPING_0m(unit, MEM_BLOCK_ANY, entry_offset, data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

          for (tc_ndx = 0; tc_ndx < ARAD_NOF_TRAFFIC_CLASSES; ++tc_ndx) {
              tmp = soc_mem_field32_get(unit, IRR_TRAFFIC_CLASS_MAPPING_0m, data, TCf);
              SHR_BITCOPY_RANGE(&(tbl_data->traffic_class_mapping[tc_ndx]), 0, &tmp, (tc_ndx*3), 3);
          }
      } else if (core_id == 1) {
          res = READ_IRR_TRAFFIC_CLASS_MAPPING_1m(unit, MEM_BLOCK_ANY, entry_offset, data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

          for (tc_ndx = 0; tc_ndx < ARAD_NOF_TRAFFIC_CLASSES; ++tc_ndx) {
              tmp = soc_mem_field32_get(unit, IRR_TRAFFIC_CLASS_MAPPING_1m, data, TCf);
              SHR_BITCOPY_RANGE(&(tbl_data->traffic_class_mapping[tc_ndx]), 0, &tmp, (tc_ndx*3), 3);
          }
      } 
  } else {
      res = READ_IRR_TRAFFIC_CLASS_MAPPINGm(unit, MEM_BLOCK_ANY, entry_offset, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

      for (tc_ndx = 0; tc_ndx < ARAD_NOF_TRAFFIC_CLASSES; ++tc_ndx) {
        tmp = soc_mem_field32_get(unit, IRR_TRAFFIC_CLASS_MAPPINGm, data, TRAFFIC_CLASS_MAPPINGf);
        SHR_BITCOPY_RANGE(&(tbl_data->traffic_class_mapping[tc_ndx]), 0, &tmp, (tc_ndx*3), 3);
      }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_traffic_class_mapping_tbl_get_unsafe()", entry_offset, tc_ndx);
}

/*
 * Write indirect table traffic_class_mapping_tbl from block IRR,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_irr_traffic_class_mapping_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_E_NONE,
    tmp = 0;
  uint32
    data[ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_ENTRY_SIZE];
 int32
    tc_ndx = 0;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_SET_UNSAFE);
  ARAD_CLEAR(data, uint32, ARAD_IRR_TRAFFIC_CLASS_MAPPING_TBL_ENTRY_SIZE);
  for (tc_ndx = 0; tc_ndx < ARAD_NOF_TRAFFIC_CLASSES; ++tc_ndx) {
      SHR_BITCOPY_RANGE(&tmp,(tc_ndx*3),&(tbl_data->traffic_class_mapping[tc_ndx]),0,3);
  }
  if (SOC_IS_JERICHO(unit)) {
      if (core_id == 0 || core_id == SOC_CORE_ALL) {
          soc_mem_field32_set(unit, IRR_TRAFFIC_CLASS_MAPPING_0m, data, TCf, tmp);
          res = WRITE_IRR_TRAFFIC_CLASS_MAPPING_0m(unit, MEM_BLOCK_ANY, entry_offset, data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 11, exit);
      }
      if (core_id == 1 || core_id == SOC_CORE_ALL) {
          soc_mem_field32_set(unit, IRR_TRAFFIC_CLASS_MAPPING_1m, data, TCf, tmp);
          res = WRITE_IRR_TRAFFIC_CLASS_MAPPING_1m(unit, MEM_BLOCK_ANY, entry_offset, data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 21, exit);
      }
  } else {
      soc_mem_field32_set(unit, IRR_TRAFFIC_CLASS_MAPPINGm, data, TRAFFIC_CLASS_MAPPINGf, tmp);
      res = WRITE_IRR_TRAFFIC_CLASS_MAPPINGm(unit, MEM_BLOCK_ANY, entry_offset, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_traffic_class_mapping_tbl_set_unsafe()", entry_offset, tc_ndx);
}

uint32
  arad_irr_stack_fec_resolve_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32             entry_offset,
    SOC_SAND_OUT ARAD_IRR_STACK_FEC_RESOLVE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_STACK_FEC_RESOLVE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_IRR_STACK_FEC_RESOLVE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_STACK_FEC_RESOLVE_TBL_DATA, 1);

  res = soc_mem_read(unit, IRR_STACK_FEC_RESOLVEm, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->stack_lag = soc_mem_field32_get(unit, IRR_STACK_FEC_RESOLVEm, data, STACK_LAGf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_stack_fec_resolve_table_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_irr_stack_fec_resolve_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRR_STACK_FEC_RESOLVE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_STACK_FEC_RESOLVE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_IRR_STACK_FEC_RESOLVE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_STACK_FEC_RESOLVEm, data, STACK_LAGf, tbl_data->stack_lag);

  res = soc_mem_write(unit, IRR_STACK_FEC_RESOLVEm, MEM_BLOCK_ALL, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 34, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_stack_fec_resolve_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_irr_stack_trunk_resolve_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32             entry_offset,
    SOC_SAND_OUT ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_DATA, 1);

  res = soc_mem_read(unit, IRR_STACK_TRUNK_RESOLVEm, MEM_BLOCK_ANY, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->base_queue = soc_mem_field32_get(unit, IRR_STACK_TRUNK_RESOLVEm, data, BASE_QUEUEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_stack_trunk_resolve_table_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_irr_stack_trunk_resolve_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_IRR_STACK_TRUNK_RESOLVE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_STACK_TRUNK_RESOLVEm, data, BASE_QUEUEf, tbl_data->base_queue);

  res = soc_mem_write(unit, IRR_STACK_TRUNK_RESOLVEm, MEM_BLOCK_ALL, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 34, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_irr_stack_trunk_resolve_table_tbl_set_unsafe()", entry_offset, 0);
}

/*
 * Read indirect table tm_port_sys_port_config_tbl from block IHP,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_ihp_tm_port_sys_port_config_tbl_get_unsafe(
    SOC_SAND_IN  int                    unit,
    SOC_SAND_IN  int                    core_id,
    SOC_SAND_IN  uint32                 entry_offset,
    SOC_SAND_OUT ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_ENTRY_SIZE];
 
    SOCDNX_INIT_FUNC_DEFS;
 
    sal_memset(data, 0, sizeof(uint32)*ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_DATA));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IHP_PTC_SYS_PORT_CONFIGm, IHP_BLOCK(unit, core_id), entry_offset, data));
    tbl_data->system_port_offset1 =         soc_mem_field32_get(unit, IHP_PTC_SYS_PORT_CONFIGm, data, OFFSETf);
    tbl_data->system_port_value =           soc_mem_field32_get(unit, IHP_PTC_SYS_PORT_CONFIGm, data, VALUEf);
    tbl_data->system_port_profile =         soc_mem_field32_get(unit, IHP_PTC_SYS_PORT_CONFIGm, data, PROFILEf);
    tbl_data->system_port_value_to_use =    soc_mem_field32_get(unit, IHP_PTC_SYS_PORT_CONFIGm, data, VALUE_TO_USEf);

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table tm_port_sys_port_config_tbl from block IHP,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_ihp_tm_port_sys_port_config_tbl_set_unsafe(
    SOC_SAND_IN  int                unit,
    SOC_SAND_IN  int                core_id,
    SOC_SAND_IN  uint32             entry_offset,
    SOC_SAND_IN  ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_ENTRY_SIZE];
    SOCDNX_INIT_FUNC_DEFS;
 
    sal_memset(data, 0, sizeof(uint32)*ARAD_IHP_TM_PORT_SYS_PORT_CONFIG_TBL_ENTRY_SIZE);

    soc_mem_field32_set(unit, IHP_PTC_SYS_PORT_CONFIGm, data, OFFSETf, tbl_data->system_port_offset1);
    soc_mem_field32_set(unit, IHP_PTC_SYS_PORT_CONFIGm, data, VALUEf, tbl_data->system_port_value);
    soc_mem_field32_set(unit, IHP_PTC_SYS_PORT_CONFIGm, data, PROFILEf, tbl_data->system_port_profile);
    soc_mem_field32_set(unit, IHP_PTC_SYS_PORT_CONFIGm, data, VALUE_TO_USEf, tbl_data->system_port_value_to_use);

    SOCDNX_IF_ERR_EXIT(soc_mem_write(unit, IHP_PTC_SYS_PORT_CONFIGm, IHP_BLOCK(unit, core_id), entry_offset, data));

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Read indirect table pct_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_egq_pct_tbl_get_unsafe(
    SOC_SAND_IN  int                    unit,
    SOC_SAND_IN  int                    core_id,
    SOC_SAND_IN  uint32                 q_pair,
    SOC_SAND_OUT ARAD_EGQ_PCT_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_EGQ_PCT_TBL_ENTRY_SIZE];

    SOCDNX_INIT_FUNC_DEFS;
 
    sal_memset(data, 0, sizeof(uint32)*ARAD_EGQ_PCT_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_EGQ_PCT_TBL_DATA));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(
            unit,
            EGQ_PCTm,
            EGQ_BLOCK(unit, core_id),
            q_pair,
            data
    ));

    tbl_data->prog_editor_value = soc_mem_field32_get(unit, EGQ_PCTm, data, PRGE_VARf);
    tbl_data->prog_editor_value = soc_mem_field32_get(unit, EGQ_PCTm, data, PRGE_VARf);
    tbl_data->prog_editor_profile = soc_mem_field32_get(unit, EGQ_PCTm, data, PRGE_PROFILEf);
    /* tbl_data->outbound_mirr = soc_mem_field32_get(unit, EGQ_PCTm, data, OUTBOUND_MIRRf); */
    tbl_data->port_profile = soc_mem_field32_get(unit, EGQ_PCTm, data, CGM_PORT_PROFILEf);
    tbl_data->port_ch_num = soc_mem_field32_get(unit, EGQ_PCTm, data, PORT_CH_NUMf);
    tbl_data->port_type = soc_mem_field32_get(unit, EGQ_PCTm, data, PORT_TYPEf);
    tbl_data->cr_adjust_type = soc_mem_field32_get(unit, EGQ_PCTm, data, CR_ADJUST_TYPEf);
    if (soc_mem_field_valid(unit, EGQ_PCTm, EGRESS_TCf)){
        tbl_data->cos_map_profile = soc_mem_field32_get(unit, EGQ_PCTm, data, EGRESS_TCf);
    } else {
        tbl_data->cos_map_profile = soc_mem_field32_get(unit, EGQ_PCTm, data, COS_MAP_PROFILEf);
    }

    tbl_data->mirror_enable = soc_mem_field32_get(unit, EGQ_PCTm, data, MIRROR_ENABLEf);
    /* tbl_data->mirror_cmd = soc_mem_field32_get(unit, EGQ_PCTm, data, MIRROR_CMDf); */
    tbl_data->mirror_channel = soc_mem_field32_get(unit, EGQ_PCTm, data, MIRROR_CHANNELf);
    tbl_data->ecc = soc_mem_field32_get(unit, EGQ_PCTm, data, ECCf);

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table pct_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_egq_pct_tbl_set_unsafe(
    SOC_SAND_IN  int                    unit,
    SOC_SAND_IN  int                    core_id,
    SOC_SAND_IN  uint32                 q_pair,
    SOC_SAND_IN  ARAD_EGQ_PCT_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_EGQ_PCT_TBL_ENTRY_SIZE];
 
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_EGQ_PCT_TBL_ENTRY_SIZE);
    SOCDNX_IF_ERR_EXIT(soc_mem_read(
            unit,
            EGQ_PCTm,
            EGQ_BLOCK(unit, core_id),
            q_pair,
            data
    ));

    soc_mem_field32_set(unit, EGQ_PCTm, data, PRGE_VARf, tbl_data->prog_editor_value);
    soc_mem_field32_set(unit, EGQ_PCTm, data, PRGE_PROFILEf, tbl_data->prog_editor_profile);
    /* soc_mem_field32_set(unit, EGQ_PCTm, data, OUTBOUND_MIRRf, tbl_data->outbound_mirr); */
    soc_mem_field32_set(unit, EGQ_PCTm, data, CGM_PORT_PROFILEf, tbl_data->port_profile);
    soc_mem_field32_set(unit, EGQ_PCTm, data, PORT_CH_NUMf, tbl_data->port_ch_num);
    soc_mem_field32_set(unit, EGQ_PCTm, data, PORT_TYPEf, tbl_data->port_type);
    soc_mem_field32_set(unit, EGQ_PCTm, data, CR_ADJUST_TYPEf, tbl_data->cr_adjust_type);
    if (soc_mem_field_valid(unit, EGQ_PCTm, EGRESS_TCf)){
        soc_mem_field32_set(unit, EGQ_PCTm, data, EGRESS_TCf, tbl_data->cos_map_profile);
    } else {
        soc_mem_field32_set(unit, EGQ_PCTm, data, COS_MAP_PROFILEf, tbl_data->cos_map_profile);
    }
    soc_mem_field32_set(unit, EGQ_PCTm, data, MIRROR_ENABLEf, tbl_data->mirror_enable);
    /* soc_mem_field32_set(unit, EGQ_PCTm, data, MIRROR_CMDf, tbl_data->mirror_cmd); */
    soc_mem_field32_set(unit, EGQ_PCTm, data, MIRROR_CHANNELf, tbl_data->mirror_channel);
    soc_mem_field32_set(unit, EGQ_PCTm, data, ECCf, tbl_data->ecc);

    SOCDNX_IF_ERR_EXIT(soc_mem_write(
            unit,
            EGQ_PCTm,
            EGQ_BLOCK(unit, core_id),
            q_pair,
            data
    ));
exit:
    SOCDNX_FUNC_RETURN;
}
/*
 * Read indirect table tc_dp_map_table_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
STATIC
  void
    arad_egq_tc_dp_map_table_entry_translate_unsafe(
      SOC_SAND_IN  int             unit,
      SOC_SAND_IN  ARAD_EGQ_TC_DP_MAP_TBL_ENTRY       *entry,
      SOC_SAND_OUT uint32                         *entry_offset
    )
{
  uint32
    offset = 0;

  offset |= SOC_SAND_SET_BITS_RANGE(entry->dp, 1, 0);
  offset |= SOC_SAND_SET_BITS_RANGE(entry->tc, 4, 2);  
  offset |= SOC_SAND_SET_BITS_RANGE(entry->is_egr_mc, 5, 5);
  offset |= SOC_SAND_SET_BITS_RANGE(entry->map_profile, 8, 6);

  *entry_offset = offset;
}

void
  ARAD_EGQ_TC_DP_MAP_TBL_ENTRY_clear(
    SOC_SAND_OUT ARAD_EGQ_TC_DP_MAP_TBL_ENTRY       *info
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

  soc_sand_os_memset(info, 0x0, sizeof(ARAD_EGQ_TC_DP_MAP_TBL_ENTRY));
  info->tc = 0;
  info->dp = 0;  
  info->is_egr_mc = 0;
  info->map_profile = 0;

  SOC_SAND_MAGIC_NUM_SET;
exit:
  SOC_SAND_VOID_EXIT_AND_SEND_ERROR(0, 0, 0);
}
void 
  ARAD_PP_IHP_MACT_FLUSH_DB_TBL_DATA_clear(
     ARAD_PP_IHP_MACT_FLUSH_DB_TBL_DATA *info
     )
{
    SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
    SOC_SAND_CHECK_NULL_INPUT(info);

   info->compare_valid = 0;
   info->compare_key_data_location= 0;
   info->compare_key_20_data= 0;
   info->compare_key_20_mask=0;
   COMPILER_64_ZERO(info->compare_payload_data);
   COMPILER_64_ZERO(info->compare_payload_mask);
   info->compare_accessed_data= 0;
   info->compare_accessed_mask= 0;
   info->action_drop= 0;
   COMPILER_64_ZERO(info->action_transplant_payload_data);
   COMPILER_64_ZERO(info->action_transplant_payload_mask);
   info->action_transplant_accessed_clear= 0;

exit:
    SOC_SAND_VOID_EXIT_AND_SEND_ERROR(0, 0, 0);

}


int
  arad_egq_tc_dp_map_tbl_get_unsafe(
    SOC_SAND_IN  int                            unit,
    SOC_SAND_IN  int                            core_id,
    SOC_SAND_IN  ARAD_EGQ_TC_DP_MAP_TBL_ENTRY   *entry,
    SOC_SAND_OUT ARAD_EGQ_TC_DP_MAP_TBL_DATA    *tbl_data
  )
{
    uint32 entry_offset = 0;
    uint32 data = 0;
    SOCDNX_INIT_FUNC_DEFS;
 
    sal_memset(tbl_data, 0, sizeof(ARAD_EGQ_TC_DP_MAP_TBL_DATA));

    arad_egq_tc_dp_map_table_entry_translate_unsafe(unit, entry, &entry_offset);

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, EGQ_TC_DP_MAPm, EGQ_BLOCK(unit, core_id), entry_offset, &data));

    tbl_data->tc = soc_mem_field32_get(unit, EGQ_TC_DP_MAPm, &data, EGRESS_TCf);
    tbl_data->dp = soc_mem_field32_get(unit, EGQ_TC_DP_MAPm, &data, CGM_MC_DPf);

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table tc_dp_map_table_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_egq_tc_dp_map_tbl_set_unsafe(
    SOC_SAND_IN  int                            unit,
    SOC_SAND_IN  int                            core_id,
    SOC_SAND_IN  ARAD_EGQ_TC_DP_MAP_TBL_ENTRY   *entry,
    SOC_SAND_IN  ARAD_EGQ_TC_DP_MAP_TBL_DATA    *tbl_data
  )
{
    uint32 entry_offset = 0;
    uint32 data = 0;

    SOCDNX_INIT_FUNC_DEFS;

    arad_egq_tc_dp_map_table_entry_translate_unsafe(unit, entry, &entry_offset);

    soc_mem_field32_set(unit, EGQ_TC_DP_MAPm, &data, EGRESS_TCf, tbl_data->tc);
    soc_mem_field32_set(unit, EGQ_TC_DP_MAPm, &data, CGM_MC_DPf, tbl_data->dp);

    SOCDNX_IF_ERR_EXIT(soc_mem_write(unit, EGQ_TC_DP_MAPm, EGQ_BLOCK(unit, core_id), entry_offset, &data));

exit:
    SOCDNX_FUNC_RETURN;
}

/*
 * Write indirect table fqp_nif_port_mux_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_egq_fqp_nif_port_mux_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_ENTRY_SIZE];
    int rv;
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32) * ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_ENTRY_SIZE);
  
    soc_mem_field32_set(
          unit,
          EGQ_FQP_NIF_PORT_MUXm,
          data,
          FQP_NIF_PORT_MUXf,
          tbl_data->fqp_nif_port_mux);

    rv = soc_mem_write(
          unit,
          EGQ_FQP_NIF_PORT_MUXm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
    SOCDNX_IF_ERR_EXIT(rv);

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
  arad_egq_fqp_nif_port_mux_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_EGQ_FQP_NIF_PORT_MUX_TBL_ENTRY_SIZE);
  
    res = soc_mem_read(
          unit,
          EGQ_FQP_NIF_PORT_MUXm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

   tbl_data->fqp_nif_port_mux = soc_mem_field32_get(
          unit,
          EGQ_FQP_NIF_PORT_MUXm,
          data,
          FQP_NIF_PORT_MUXf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_fqp_nif_port_mux_tbl_set_unsafe()", entry_offset, 0);
}


/*
 * Write indirect table fqp_nif_port_mux_tbl from block EGQ,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
int
  arad_egq_pqp_nif_port_mux_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_ENTRY_SIZE];
    int rv;
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_ENTRY_SIZE);
  
    soc_mem_field32_set(
          unit,
          EGQ_PQP_NIF_PORT_MUXm,
          data,
          PQP_NIF_PORT_MUXf,
          tbl_data->pqp_nif_port_mux );

    rv = soc_mem_write(
          unit,
          EGQ_PQP_NIF_PORT_MUXm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
    SOCDNX_IF_ERR_EXIT(rv);

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
  arad_egq_pqp_nif_port_mux_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT  ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_EGQ_PQP_NIF_PORT_MUX_TBL_ENTRY_SIZE);
  
    res = soc_mem_read(
          unit,
          EGQ_PQP_NIF_PORT_MUXm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

   tbl_data->pqp_nif_port_mux = soc_mem_field32_get(
          unit,
          EGQ_PQP_NIF_PORT_MUXm,
          data,
          PQP_NIF_PORT_MUXf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_egq_fqp_nif_port_mux_tbl_set_unsafe()", entry_offset, 0);
}

/*
 * Read indirect table pinfo_pmf_tbl from block IHB,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ihb_pinfo_lbp_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IHB_PINFO_LBP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PINFO_LBP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_IHB_PINFO_LBP_TBL_DATA, 1);

 
 



  

  res = soc_mem_read(
          unit,
          IHB_PINFO_LBPm,
          IHB_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->counter_compension   = soc_mem_field32_get(
                  unit,
                  IHB_PINFO_LBPm,
                  data,
                  COUNTER_COMPENSIONf            );

exit:
SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_pinfo_lbp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_ihb_pinfo_lbp_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IHB_PINFO_LBP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PINFO_LBP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IHB_PINFO_LBP_TBL_ENTRY_SIZE);

 
 



  

            soc_mem_field32_set(
          unit,
          IHB_PINFO_LBPm,
          data,
          COUNTER_COMPENSIONf,
          tbl_data->counter_compension );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IHB_PINFO_LBPm,
          IHB_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_pinfo_lbp_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_ihb_pinfo_pmf_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,   
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IHB_PINFO_PMF_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PINFO_PMF_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PINFO_PMF_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PINFO_PMF_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_IHB_PINFO_PMF_TBL_DATA, 1);

  res = soc_mem_read(unit, IHB_PINFO_PMFm, IHB_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->port_pmf_profile = soc_mem_field32_get(unit, IHB_PINFO_PMFm, data, PROGRAM_SELECTION_PROFILEf); 
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_pinfo_pmf_tbl_get_unsafe()", entry_offset, 0);
}



uint32
  arad_ihb_ptc_info_pmf_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,   
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_IHB_PTC_INFO_PMF_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PTC_INFO_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PTC_INFO_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PTC_INFO_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_IHB_PTC_INFO_PMF_TBL_DATA, 1);

  res = soc_mem_read(unit, IHB_PTC_INFO_PMFm, IHB_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->interface_port_pmf_profile = soc_mem_field32_get(unit, IHB_PTC_INFO_PMFm, data, PROGRAM_SELECTION_PROFILEf); 
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_ptc_info_pmf_tbl_get_unsafe()", entry_offset, 0);
}



/*
 * Write indirect table pinfo_pmf_tbl from block IHB,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ihb_pinfo_pmf_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IHB_PINFO_PMF_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32               
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PINFO_PMF_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PINFO_PMF_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PINFO_PMF_NOF_LONGS));

  res = soc_mem_read(unit, IHB_PINFO_PMFm, IHB_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 29, exit);

  soc_mem_field32_set(unit, IHB_PINFO_PMFm, data, PROGRAM_SELECTION_PROFILEf, tbl_data->port_pmf_profile); 
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(unit, IHB_PINFO_PMFm, IHB_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_pinfo_pmf_tbl_set_unsafe()", entry_offset, 0);
}





/*
 * Write indirect table ptc_info_pmf_tbl from block IHB,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_ihb_ptc_info_pmf_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_IHB_PTC_INFO_PMF_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PTC_INFO_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IHB_PTC_INFO_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PTC_INFO_NOF_LONGS));

  soc_mem_field32_set(unit, IHB_PTC_INFO_PMFm, data, PROGRAM_SELECTION_PROFILEf, tbl_data->interface_port_pmf_profile); 
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(unit, IHB_PTC_INFO_PMFm, IHB_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_ihb_ptc_info_pmf_tbl_set_unsafe()", entry_offset, 0);
}





uint32
  arad_pp_ihb_pmf_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_PMF_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PARSER_LEAF_CONTEXTf);
  tbl_data->in_port_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_PORT_PROFILEf);
  tbl_data->ptc_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PTC_PROFILEf);
  tbl_data->packet_format_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_CODEf);
  tbl_data->packet_format_qualifier_0 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_QUALIFIER_0f);
  tbl_data->packet_format_qualifier_fwd = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_QUALIFIER_FWDf);
  tbl_data->forwarding_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_CODEf);
  tbl_data->forwarding_offset_index = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_OFFSET_INDEXf);
  tbl_data->forwarding_offset_index_ext = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_OFFSET_INDEX_EXTf);
  tbl_data->cpu_trap_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, CPU_TRAP_CODEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_LIF_PROFILEf);
  tbl_data->out_lif_range = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, OUT_LIF_RANGEf);
  tbl_data->llvp_incoming_tag_structure = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LLVP_INCOMING_TAG_STRUCTUREf);
  tbl_data->vt_processing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_PROCESSING_PROFILEf);
  tbl_data->vt_lookup_0_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_LOOKUP_0_FOUNDf);
  tbl_data->vt_lookup_1_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_LOOKUP_1_FOUNDf);
  tbl_data->tt_processing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_PROCESSING_PROFILEf);
  tbl_data->tt_lookup_0_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_LOOKUP_0_FOUNDf);
  tbl_data->tt_lookup_1_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_LOOKUP_1_FOUNDf);
  tbl_data->fwd_prcessing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FWD_PRCESSING_PROFILEf);
  tbl_data->lem_1st_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LEM_1ST_LKP_FOUNDf);
  tbl_data->lem_2nd_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LEM_2ND_LKP_FOUNDf);
  tbl_data->lpm_1st_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LPM_1ST_LKP_FOUNDf);
  tbl_data->lpm_2nd_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LPM_2ND_LKP_FOUNDf);
  tbl_data->tcam_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? TCAM_0_FOUNDf: TCAM_FOUNDf);
  tbl_data->tcam_traps_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? TCAM_TRAPS_0_FOUNDf: TCAM_TRAPS_FOUNDf);
  tbl_data->elk_error = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, ELK_ERRORf);
  tbl_data->elk_found_result = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, ELK_FOUND_RESULTf);
  tbl_data->mask_parser_leaf_context = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PARSER_LEAF_CONTEXTf);
  tbl_data->mask_in_port_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_PORT_PROFILEf);
  tbl_data->mask_ptc_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PTC_PROFILEf);
  tbl_data->mask_packet_format_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_CODEf);
  tbl_data->mask_packet_format_qualifier_0 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_QUALIFIER_0f);
  tbl_data->mask_packet_format_qualifier_fwd = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_QUALIFIER_FWDf);
  tbl_data->mask_forwarding_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_CODEf);
  tbl_data->mask_forwarding_offset_index = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_OFFSET_INDEXf);
  tbl_data->mask_forwarding_offset_index_ext = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_OFFSET_INDEX_EXTf);
  tbl_data->mask_cpu_trap_code = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_CPU_TRAP_CODEf);
  tbl_data->mask_in_lif_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_LIF_PROFILEf);
  tbl_data->mask_out_lif_range = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_OUT_LIF_RANGEf);
  tbl_data->mask_llvp_incoming_tag_structure = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LLVP_INCOMING_TAG_STRUCTUREf);
  tbl_data->mask_vt_processing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_PROCESSING_PROFILEf);
  tbl_data->mask_vt_lookup_0_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_LOOKUP_0_FOUNDf);
  tbl_data->mask_vt_lookup_1_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_LOOKUP_1_FOUNDf);
  tbl_data->mask_tt_processing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_PROCESSING_PROFILEf);
  tbl_data->mask_tt_lookup_0_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_LOOKUP_0_FOUNDf);
  tbl_data->mask_tt_lookup_1_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_LOOKUP_1_FOUNDf);
  tbl_data->mask_fwd_prcessing_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FWD_PRCESSING_PROFILEf);
  tbl_data->mask_lem_1st_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LEM_1ST_LKP_FOUNDf);
  tbl_data->mask_lem_2nd_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LEM_2ND_LKP_FOUNDf);
  tbl_data->mask_lpm_1st_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LPM_1ST_LKP_FOUNDf);
  tbl_data->mask_lpm_2nd_lkp_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LPM_2ND_LKP_FOUNDf);
  tbl_data->mask_tcam_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? MASK_TCAM_0_FOUNDf: MASK_TCAM_FOUNDf);
  tbl_data->mask_tcam_traps_found = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? MASK_TCAM_TRAPS_0_FOUNDf: MASK_TCAM_TRAPS_FOUNDf);
  tbl_data->mask_elk_error = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_ELK_ERRORf);
  tbl_data->mask_elk_found_result = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_ELK_FOUND_RESULTf);
  tbl_data->valid = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VALIDf);
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      tbl_data->program = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAM_DATAf);
  }
  else
  {
      tbl_data->program = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAMf);
  }



#ifdef BCM_88660_A0
  /* Additional field */
  if (SOC_IS_ARADPLUS(unit)) {
        tbl_data->stamp_native_vsi = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, STAMP_NATIVE_VSIf);
        tbl_data->mask_stamp_native_vsi = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_STAMP_NATIVE_VSIf);
    }
#endif /* BCM_88660_A0 */

  if (SOC_IS_JERICHO(unit)) {
    tbl_data->in_rif_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_RIF_PROFILEf);
    tbl_data->mask_in_rif_profile = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_RIF_PROFILEf);
    tbl_data->tcam_found_1 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TCAM_1_FOUNDf);
    tbl_data->mask_tcam_found_1 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_1_FOUNDf);
    tbl_data->tcam_traps_found_1 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TCAM_TRAPS_1_FOUNDf);
    tbl_data->mask_tcam_traps_found_1 = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_TRAPS_1_FOUNDf);
    tbl_data->rpf_stamp_native_vsi = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, RPF_STAMP_NATIVE_VSIf);
    tbl_data->mask_rpf_stamp_native_vsi = soc_mem_field32_get(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_RPF_STAMP_NATIVE_VSIf);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->program_selection_profile = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAM_SELECTION_PROFILEf);
  tbl_data->tcam_action_0_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_0_LSBf);
  tbl_data->tcam_action_1_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_1_LSBf);
  tbl_data->tcam_action_2_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_2_LSBf);
  tbl_data->tcam_action_3_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_3_LSBf);
  tbl_data->kaps_payload_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, KAPS_PAYLOAD_LSBf);
  tbl_data->oamp_payload_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, OAMP_PAYLOAD_LSBf);
  tbl_data->lem_result_found = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, LEM_RESULT_FOUNDf);
  tbl_data->lem_result_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, LEM_RESULT_LSBf);
  tbl_data->mask_program_selection_profile = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAM_SELECTION_PROFILE_MASKf);
  tbl_data->mask_tcam_action_0_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_0_LSBf);
  tbl_data->mask_tcam_action_1_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_1_LSBf);
  tbl_data->mask_tcam_action_2_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_2_LSBf);
  tbl_data->mask_tcam_action_3_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_3_LSBf);
  tbl_data->mask_kaps_payload_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_KAPS_PAYLOAD_LSBf);
  tbl_data->mask_oamp_payload_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_OAMP_PAYLOAD_LSBf);
  tbl_data->mask_lem_result_found = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_LEM_RESULT_FOUNDf);
  tbl_data->mask_lem_result_lsb = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_LEM_RESULT_LSBf);
  tbl_data->valid = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, VALIDf);
  tbl_data->program = soc_mem_field32_get(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAMf);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

/* Fill only the buffer */
uint32
  arad_pp_ihb_pmf_program_selection_cam_tbl_data_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT  uint32 data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)]
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS));

  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_PORT_PROFILEf, tbl_data->in_port_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PTC_PROFILEf, tbl_data->ptc_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_QUALIFIER_0f, tbl_data->packet_format_qualifier_0);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PACKET_FORMAT_QUALIFIER_FWDf, tbl_data->packet_format_qualifier_fwd);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_CODEf, tbl_data->forwarding_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_OFFSET_INDEXf, tbl_data->forwarding_offset_index);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FORWARDING_OFFSET_INDEX_EXTf, tbl_data->forwarding_offset_index_ext);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, CPU_TRAP_CODEf, tbl_data->cpu_trap_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, OUT_LIF_RANGEf, tbl_data->out_lif_range);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LLVP_INCOMING_TAG_STRUCTUREf, tbl_data->llvp_incoming_tag_structure);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_PROCESSING_PROFILEf, tbl_data->vt_processing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_LOOKUP_0_FOUNDf, tbl_data->vt_lookup_0_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VT_LOOKUP_1_FOUNDf, tbl_data->vt_lookup_1_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_PROCESSING_PROFILEf, tbl_data->tt_processing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_LOOKUP_0_FOUNDf, tbl_data->tt_lookup_0_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TT_LOOKUP_1_FOUNDf, tbl_data->tt_lookup_1_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, FWD_PRCESSING_PROFILEf, tbl_data->fwd_prcessing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LEM_1ST_LKP_FOUNDf, tbl_data->lem_1st_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LEM_2ND_LKP_FOUNDf, tbl_data->lem_2nd_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LPM_1ST_LKP_FOUNDf, tbl_data->lpm_1st_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, LPM_2ND_LKP_FOUNDf, tbl_data->lpm_2nd_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? TCAM_0_FOUNDf: TCAM_FOUNDf, tbl_data->tcam_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? TCAM_TRAPS_0_FOUNDf: TCAM_TRAPS_FOUNDf, tbl_data->tcam_traps_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, ELK_ERRORf, tbl_data->elk_error);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, ELK_FOUND_RESULTf, tbl_data->elk_found_result);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PARSER_LEAF_CONTEXTf, tbl_data->mask_parser_leaf_context);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_PORT_PROFILEf, tbl_data->mask_in_port_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PTC_PROFILEf, tbl_data->mask_ptc_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_CODEf, tbl_data->mask_packet_format_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_QUALIFIER_0f, tbl_data->mask_packet_format_qualifier_0);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_PACKET_FORMAT_QUALIFIER_FWDf, tbl_data->mask_packet_format_qualifier_fwd);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_CODEf, tbl_data->mask_forwarding_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_OFFSET_INDEXf, tbl_data->mask_forwarding_offset_index);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FORWARDING_OFFSET_INDEX_EXTf, tbl_data->mask_forwarding_offset_index_ext);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_CPU_TRAP_CODEf, tbl_data->mask_cpu_trap_code);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_LIF_PROFILEf, tbl_data->mask_in_lif_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_OUT_LIF_RANGEf, tbl_data->mask_out_lif_range);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LLVP_INCOMING_TAG_STRUCTUREf, tbl_data->mask_llvp_incoming_tag_structure);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_PROCESSING_PROFILEf, tbl_data->mask_vt_processing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_LOOKUP_0_FOUNDf, tbl_data->mask_vt_lookup_0_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_VT_LOOKUP_1_FOUNDf, tbl_data->mask_vt_lookup_1_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_PROCESSING_PROFILEf, tbl_data->mask_tt_processing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_LOOKUP_0_FOUNDf, tbl_data->mask_tt_lookup_0_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TT_LOOKUP_1_FOUNDf, tbl_data->mask_tt_lookup_1_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_FWD_PRCESSING_PROFILEf, tbl_data->mask_fwd_prcessing_profile);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LEM_1ST_LKP_FOUNDf, tbl_data->mask_lem_1st_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LEM_2ND_LKP_FOUNDf, tbl_data->mask_lem_2nd_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LPM_1ST_LKP_FOUNDf, tbl_data->mask_lpm_1st_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_LPM_2ND_LKP_FOUNDf, tbl_data->mask_lpm_2nd_lkp_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? MASK_TCAM_0_FOUNDf: MASK_TCAM_FOUNDf, tbl_data->mask_tcam_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, SOC_IS_JERICHO(unit)? MASK_TCAM_TRAPS_0_FOUNDf: MASK_TCAM_TRAPS_FOUNDf, tbl_data->mask_tcam_traps_found);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_ELK_ERRORf, tbl_data->mask_elk_error);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_ELK_FOUND_RESULTf, tbl_data->mask_elk_found_result);
  soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, VALIDf, tbl_data->valid);
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAM_DATAf, tbl_data->program);
  }
  else
  {
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAMf, tbl_data->program);
  }

#ifdef BCM_88660_A0
  /* Additional field */
    if (SOC_IS_ARADPLUS(unit)) {
        soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, STAMP_NATIVE_VSIf, tbl_data->stamp_native_vsi);
        soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_STAMP_NATIVE_VSIf, tbl_data->mask_stamp_native_vsi);
    }
#endif /* BCM_88660_A0 */

    if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, IN_RIF_PROFILEf, tbl_data->in_rif_profile);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_IN_RIF_PROFILEf, tbl_data->mask_in_rif_profile);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TCAM_1_FOUNDf, tbl_data->tcam_found_1);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_1_FOUNDf, tbl_data->mask_tcam_found_1);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, TCAM_TRAPS_1_FOUNDf, tbl_data->tcam_traps_found_1);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_TRAPS_1_FOUNDf, tbl_data->mask_tcam_traps_found_1);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, RPF_STAMP_NATIVE_VSIf, tbl_data->rpf_stamp_native_vsi);
      soc_mem_field32_set(unit, IHB_PMF_PROGRAM_SELECTION_CAMm, data, MASK_RPF_STAMP_NATIVE_VSIf, tbl_data->mask_rpf_stamp_native_vsi);
    }

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_program_selection_cam_tbl_data_set_unsafe()", 0, 0);
}

/* Fill only the buffer */
uint32
  arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_data_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT  uint32 data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)]
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS));

  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAM_SELECTION_PROFILEf, tbl_data->program_selection_profile);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_0_LSBf, tbl_data->tcam_action_0_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_1_LSBf, tbl_data->tcam_action_1_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_2_LSBf, tbl_data->tcam_action_2_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, TCAM_ACTION_3_LSBf, tbl_data->tcam_action_3_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, KAPS_PAYLOAD_LSBf, tbl_data->kaps_payload_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, OAMP_PAYLOAD_LSBf, tbl_data->oamp_payload_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, LEM_RESULT_FOUNDf, tbl_data->lem_result_found);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, LEM_RESULT_LSBf, tbl_data->lem_result_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAM_SELECTION_PROFILE_MASKf, tbl_data->mask_program_selection_profile);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_0_LSBf, tbl_data->mask_tcam_action_0_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_1_LSBf, tbl_data->mask_tcam_action_1_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_2_LSBf, tbl_data->mask_tcam_action_2_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_TCAM_ACTION_3_LSBf, tbl_data->mask_tcam_action_3_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_KAPS_PAYLOAD_LSBf, tbl_data->mask_kaps_payload_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_OAMP_PAYLOAD_LSBf, tbl_data->mask_oamp_payload_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_LEM_RESULT_FOUNDf, tbl_data->mask_lem_result_found);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, MASK_LEM_RESULT_LSBf, tbl_data->mask_lem_result_lsb);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, PROGRAMf, tbl_data->program);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm, data, VALIDf, tbl_data->valid);
 
  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_data_set_unsafe()", 0, 0);
}

uint32
  arad_pp_ihb_slb_program_selection_cam_tbl_data_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT  uint32 data[ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE]
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VSI_PROFILEf, tbl_data->vsi_profile);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, SELECTED_FLP_PROGRAMf, tbl_data->flp_program);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_NEXT_PROTOCOLf, tbl_data->pfq_next_protocol_fwd);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_PLUS_ONE_NEXT_PROTOCOLf, tbl_data->pfq_next_protocol_fwd_next);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_CODEf, tbl_data->forwarding_code);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_OFFSET_INDEXf, tbl_data->forwarding_offset_index);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, DESTINAITON_MSBSf, tbl_data->destination_msbs);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, UNKNOWN_ADDRf, tbl_data->unknown_addr);

  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PARSER_LEAF_CONTEXT_MASKf, tbl_data->parser_leaf_context_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VSI_PROFILE_MASKf, tbl_data->vsi_profile_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, IN_LIF_PROFILE_MASKf, tbl_data->in_lif_profile_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FLP_PROGRAM_MASKf, tbl_data->flp_program_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PACKET_FORMAT_CODE_MASKf, tbl_data->packet_format_code_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_NEXT_PROTOCOL_MASKf, tbl_data->pfq_next_protocol_fwd_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_PLUS_ONE_NEXT_PROTOCOL_MASKf, tbl_data->pfq_next_protocol_fwd_next_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_CODE_MASKf, tbl_data->forwarding_code_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_OFFSET_INDEX_MASKf, tbl_data->forwarding_offset_index_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, DESTINAITON_MSBS_MASKf, tbl_data->destination_msbs_mask);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, UNKNOWN_ADDR_MASKf, tbl_data->unknown_addr_mask);

  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PROGRAMf, tbl_data->program);
  soc_mem_field32_set(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VALIDf, tbl_data->valid);

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_slb_program_selection_cam_tbl_data_set_unsafe()", 0, 0);
}

uint32
  arad_pp_ihb_slb_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_SLB_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PARSER_LEAF_CONTEXTf);
  tbl_data->vsi_profile = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VSI_PROFILEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, IN_LIF_PROFILEf);
  tbl_data->flp_program = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, SELECTED_FLP_PROGRAMf);
  tbl_data->packet_format_code = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PACKET_FORMAT_CODEf);
  tbl_data->pfq_next_protocol_fwd = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_NEXT_PROTOCOLf);
  tbl_data->pfq_next_protocol_fwd_next = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_PLUS_ONE_NEXT_PROTOCOLf);
  tbl_data->forwarding_code = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_CODEf);
  tbl_data->forwarding_offset_index = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_OFFSET_INDEXf);
  tbl_data->destination_msbs = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, DESTINAITON_MSBSf);
  tbl_data->unknown_addr = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, UNKNOWN_ADDRf);

  tbl_data->parser_leaf_context_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PARSER_LEAF_CONTEXT_MASKf);
  tbl_data->vsi_profile_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VSI_PROFILE_MASKf);
  tbl_data->in_lif_profile_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, IN_LIF_PROFILE_MASKf);
  tbl_data->flp_program_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FLP_PROGRAM_MASKf);
  tbl_data->packet_format_code_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PACKET_FORMAT_CODE_MASKf);
  tbl_data->pfq_next_protocol_fwd_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_NEXT_PROTOCOL_MASKf);
  tbl_data->pfq_next_protocol_fwd_next_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_HEADER_PLUS_ONE_NEXT_PROTOCOL_MASKf);
  tbl_data->forwarding_code_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_CODE_MASKf);
  tbl_data->forwarding_offset_index_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, FORWARDING_OFFSET_INDEX_MASKf);
  tbl_data->destination_msbs_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, DESTINAITON_MSBS_MASKf);
  tbl_data->unknown_addr_mask = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, UNKNOWN_ADDR_MASKf);

  tbl_data->program = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, PROGRAMf);
  tbl_data->valid = soc_mem_field32_get(unit, IHP_CONSISTENT_HASHING_PROGRAM_SEL_TCAMm, data, VALIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_slb_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_pmf_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  res = arad_pp_ihb_pmf_program_selection_cam_tbl_data_set_unsafe(
            unit,
            tbl_data,
            data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = soc_mem_write(
          unit,
          IHB_PMF_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHB_PMF_PROGRAM_SELECTION_CAM_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_2ND_PASS_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  res = arad_pp_ihb_pmf_2nd_pass_program_selection_cam_tbl_data_set_unsafe(
            unit,
            tbl_data,
            data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = soc_mem_write(
          unit,
          IHB_PMF_PASS_2_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}


/*
 * Read indirect table copy_engine1_program_tbl from block EPNI,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_epni_lfem_field_select_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              tbl_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_EPNI_LFEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EPNI_LFEM0_FIELD_SELECT_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(tbl_data, ARAD_EPNI_LFEM_FIELD_SELECT_MAP_TBL_DATA, 1);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 30, exit, READ_EPNI_LFEM_FIELD_SELECT_MAPm(unit, tbl_ndx, MEM_BLOCK_ANY, entry_offset, tbl_data->lfem_field_select_map));

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_epni_lfem_field_select_map_tbl_get_unsafe()", tbl_ndx, entry_offset);
}

uint32
  arad_epni_lfem_field_select_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              tbl_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_EPNI_LFEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_EPNI_LFEM0_FIELD_SELECT_MAP_TBL_SET_UNSAFE);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 35, exit, WRITE_EPNI_LFEM_FIELD_SELECT_MAPm(unit, tbl_ndx, MEM_BLOCK_ANY, entry_offset, (void*)(tbl_data->lfem_field_select_map)));

  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit); 

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_epni_lfem_field_select_map_tbl_set_unsafe()", tbl_ndx, entry_offset);
}

uint32
  arad_pp_egq_pmf_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EGQ_PMF_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->egress_pmf_profile = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, EGRESS_PMF_PROFILEf);
  tbl_data->format_code = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, FORMAT_CODEf);
  tbl_data->value_1 = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_1f);
  tbl_data->value_2 = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_2f);
  tbl_data->header_code = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, HEADER_CODEf);
  tbl_data->qualifier = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, QUALIFIERf);
  tbl_data->ethernet_tag_format = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, ETHERNET_TAG_FORMATf);
  tbl_data->egress_pmf_profile_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, EGRESS_PMF_PROFILE_MASKf);
  tbl_data->format_code_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, FORMAT_CODE_MASKf);
  tbl_data->value_1_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_1_MASKf);
  tbl_data->value_2_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_2_MASKf);
  tbl_data->header_code_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, HEADER_CODE_MASKf);
  tbl_data->qualifier_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, QUALIFIER_MASKf);
  tbl_data->ethernet_tag_format_mask = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, ETHERNET_TAG_FORMAT_MASKf);
  tbl_data->program = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAMf);
  tbl_data->valid = soc_mem_field32_get(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_pmf_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_pmf_program_selection_cam_tbl_data_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT uint32   data[ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE]
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, EGRESS_PMF_PROFILEf, tbl_data->egress_pmf_profile);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, FORMAT_CODEf, tbl_data->format_code);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_1f, tbl_data->value_1);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_2f, tbl_data->value_2);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, HEADER_CODEf, tbl_data->header_code);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, QUALIFIERf, tbl_data->qualifier);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, ETHERNET_TAG_FORMATf, tbl_data->ethernet_tag_format);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, EGRESS_PMF_PROFILE_MASKf, tbl_data->egress_pmf_profile_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, FORMAT_CODE_MASKf, tbl_data->format_code_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_1_MASKf, tbl_data->value_1_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALUE_2_MASKf, tbl_data->value_2_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, HEADER_CODE_MASKf, tbl_data->header_code_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, QUALIFIER_MASKf, tbl_data->qualifier_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, ETHERNET_TAG_FORMAT_MASKf, tbl_data->ethernet_tag_format_mask);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, PROGRAMf, tbl_data->program);
  soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, VALIDf, tbl_data->valid);
  if (SOC_IS_JERICHO_PLUS(unit) && !SOC_IS_QAX(unit)) {
      soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, IP_MC_FALL_TO_BRIDGEf, tbl_data->fall_to_bridge);
      soc_mem_field32_set(unit, EGQ_PMF_PROGRAM_SELECTION_CAMm, data, IP_MC_FALL_TO_BRIDGE_MASKf, tbl_data->fall_to_bridge_mask);
  }

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_pmf_program_selection_cam_tbl_data_set_unsafe()", 0, 0);
}



uint32
  arad_pp_egq_pmf_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_PMF_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  res = arad_pp_egq_pmf_program_selection_cam_tbl_data_set_unsafe(
            unit,
            tbl_data,
            data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  

  res = soc_mem_write(
          unit,
          EGQ_PMF_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_pmf_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}


/*
 * Read indirect table calrx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_oob_calrx_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_CFC_CALRX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALRX_TBL_ENTRY_SIZE];
 
 uint32
   tbl;
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALRX_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_CFC_CALRX_TBL_DATA, 1);

   tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_SPI_OOB_RX_0_CALm : CFC_SPI_OOB_RX_1_CALm);
 



  

  res = soc_mem_read(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->fc_index   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->fc_dest_sel   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_DST_SELf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_oob_calrx_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table calrx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_oob_calrx_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_CFC_CALRX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALRX_TBL_ENTRY_SIZE];
 uint32
   tbl;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALRX_TBL_ENTRY_SIZE);

  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_SPI_OOB_RX_0_CALm : CFC_SPI_OOB_RX_1_CALm);

 



  

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_INDEXf,
          tbl_data->fc_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_DST_SELf,
          tbl_data->fc_dest_sel );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_write(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_oob_calrx_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table caltx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_oob_caltx_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID                   if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_CFC_CALTX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALTX_TBL_ENTRY_SIZE];
  uint32
    tbl;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALTX_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_CFC_CALTX_TBL_DATA, 1);

 
  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_SPI_OOB_TX_0_CALm : CFC_SPI_OOB_TX_1_CALm);




  

  res = soc_mem_read(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);


          tbl_data->fc_index   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->fc_source_sel   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_SRC_SELf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_oob_caltx_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table caltx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_oob_caltx_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_CFC_CALTX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALTX_TBL_ENTRY_SIZE];
  uint32
    tbl;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALTX_TBL_ENTRY_SIZE);

  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_SPI_OOB_TX_0_CALm : CFC_SPI_OOB_TX_1_CALm);

 



  

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_INDEXf,
          tbl_data->fc_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_SRC_SELf,
          tbl_data->fc_source_sel );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_write(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_oob_caltx_tbl_set_unsafe()", entry_offset, 0);
}

/*
 * Read indirect table ilkn_calrx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_ilkn_calrx_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_CFC_CALRX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALRX_TBL_ENTRY_SIZE];
  uint32
    tbl = 0;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALRX_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_CFC_CALRX_TBL_DATA, 1);

  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_ILKN_RX_0_CALm : CFC_ILKN_RX_1_CALm);
 



  

  res = soc_mem_read(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->fc_index   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->fc_dest_sel   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_DST_SELf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_ilkn_calrx_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_cfc_hcfc_bitmap_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32  entry_offset,
    SOC_SAND_IN  ARAD_CFC_HCFC_BITMAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    i;
  uint32
    data[ARAD_CFC_HCFC_BITMAP_TBL_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  for(i=0; i<ARAD_CFC_HCFC_BITMAP_TBL_SIZE; i++)
  {
    data[i] = tbl_data->bitmap[i];
  }

  res = soc_mem_write(
          unit,
          CFC_CAT_2_TC_MAP_HCFCm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_hcfc_bitmap_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_cfc_hcfc_bitmap_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32  entry_offset,
    SOC_SAND_OUT ARAD_CFC_HCFC_BITMAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    i;
  uint32
    data[ARAD_CFC_HCFC_BITMAP_TBL_SIZE + 1];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  res = soc_sand_os_memset(
        data,
        0x0,
        sizeof(uint32) * ARAD_CFC_HCFC_BITMAP_TBL_SIZE
      );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 5, exit);
  
  res = soc_mem_read(
          unit,
          CFC_CAT_2_TC_MAP_HCFCm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  for(i=0; i<ARAD_CFC_HCFC_BITMAP_TBL_SIZE; i++)
  {
    tbl_data->bitmap[i] = data[i];
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_hcfc_bitmap_tbl_get_unsafe()", entry_offset, 0);
}


/*
 * Write indirect table ilkn_calrx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_ilkn_calrx_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_CFC_CALRX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALRX_TBL_ENTRY_SIZE];
  uint32
    tbl = 0;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALRX_TBL_ENTRY_SIZE);

 
  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_ILKN_RX_0_CALm : CFC_ILKN_RX_1_CALm);




  

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_INDEXf,
          tbl_data->fc_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_DST_SELf,
          tbl_data->fc_dest_sel );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  /*
  soc_mem_field32_set(
    unit,
    tbl,
    data,
    PARITYf,
    tbl_data->parity );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
*/
  res = soc_mem_write(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_ilkn_calrx_tbl_set_unsafe()", entry_offset, 0);
}
/*
 * Read indirect table ilkn_caltx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_ilkn_caltx_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_CFC_CALTX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALTX_TBL_ENTRY_SIZE];
 uint32
   tbl;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALTX_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_CFC_CALTX_TBL_DATA, 1);

  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_ILKN_TX_0_CALm : CFC_ILKN_TX_1_CALm); 



  

  res = soc_mem_read(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->fc_index   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->fc_source_sel   = soc_mem_field32_get(
                  unit,
                  tbl,
                  data,
                  FC_SRC_SELf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_ilkn_caltx_tbl_get_unsafe()", entry_offset, 0);
}

/*
 * Write indirect table ilkn_caltx_tbl from block CFC,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */
uint32
  arad_cfc_ilkn_caltx_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  SOC_TMC_FC_OOB_ID          if_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_CFC_CALTX_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_CFC_CALTX_TBL_ENTRY_SIZE];
 uint32
   tbl;
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_CFC_CALTX_TBL_ENTRY_SIZE);

  tbl = (if_ndx == SOC_TMC_FC_OOB_ID_A ? CFC_ILKN_TX_0_CALm : CFC_ILKN_TX_1_CALm); 

 



  

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_INDEXf,
          tbl_data->fc_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          tbl,
          data,
          FC_SRC_SELf,
          tbl_data->fc_source_sel );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_write(
          unit,
          tbl,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_cfc_ilkn_caltx_tbl_set_unsafe()", entry_offset, 0);
}

/* 
 *  PP-Tables - B
 */ 


uint32
  arad_pp_ihp_flush_db_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_FLUSH_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(PPDB_LARGE_EM_FLUSH_DB_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FLUSH_DB_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(PPDB_LARGE_EM_FLUSH_DB_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_MACT_FLUSH_DB_TBL_DATA, 1);

  /* read from SW as it HW has no read 
  res = soc_mem_read(
          unit,
          PPDB_B_LARGE_EM_FLUSH_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);*/

  res = arad_pp_sw_db_mact_flush_db_get(unit,entry_offset,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->compare_valid = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_VALIDf);
  tbl_data->compare_key_data_location = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_DATA_LOCATIONf);
  tbl_data->compare_key_20_data = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_20_DATAf);
  tbl_data->compare_key_20_mask = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_20_MASKf);
  soc_mem_field64_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_PAYLOAD_DATAf, &tbl_data->compare_payload_data);
  soc_mem_field64_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_PAYLOAD_MASKf, &tbl_data->compare_payload_mask);
  tbl_data->compare_accessed_data = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_ACCESSED_DATAf);
  tbl_data->compare_accessed_mask = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_ACCESSED_MASKf);
  tbl_data->action_drop = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_DROPf);
  soc_mem_field64_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_PAYLOAD_DATAf, &tbl_data->action_transplant_payload_data);
  soc_mem_field64_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_PAYLOAD_MASKf, &tbl_data->action_transplant_payload_mask);
  tbl_data->action_transplant_accessed_clear = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_ACCESSED_CLEARf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_flush_db_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_flush_db_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_MACT_FLUSH_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(PPDB_LARGE_EM_FLUSH_DB_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FLUSH_DB_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(PPDB_LARGE_EM_FLUSH_DB_NOF_LONGS));

  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_VALIDf, tbl_data->compare_valid);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_DATA_LOCATIONf, tbl_data->compare_key_data_location);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_20_DATAf, tbl_data->compare_key_20_data);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_KEY_20_MASKf, tbl_data->compare_key_20_mask);
  soc_mem_field64_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_PAYLOAD_DATAf, tbl_data->compare_payload_data);
  soc_mem_field64_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_PAYLOAD_MASKf, tbl_data->compare_payload_mask);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_ACCESSED_DATAf, tbl_data->compare_accessed_data);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, COMPARE_ACCESSED_MASKf, tbl_data->compare_accessed_mask);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_DROPf, tbl_data->action_drop);
  soc_mem_field64_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_PAYLOAD_DATAf, tbl_data->action_transplant_payload_data);
  soc_mem_field64_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_PAYLOAD_MASKf, tbl_data->action_transplant_payload_mask);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FLUSH_DBm, data, ACTION_TRANSPLANT_ACCESSED_CLEARf, tbl_data->action_transplant_accessed_clear);

  res = soc_mem_write(
          unit,
          PPDB_B_LARGE_EM_FLUSH_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  res = arad_pp_sw_db_mact_flush_db_set(unit,entry_offset,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_flush_db_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_mact_aging_configuration_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->aging_cfg_info_delete_entry = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_DELETE_ENTRYf);
  tbl_data->aging_cfg_info_create_aged_out_event = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_CREATE_AGED_OUT_EVENTf);
  tbl_data->aging_cfg_info_create_refresh_event = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_CREATE_REFRESH_EVENTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_aging_configuration_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_mact_aging_configuration_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_AGING_CONFIGURATION_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_DELETE_ENTRYf, tbl_data->aging_cfg_info_delete_entry);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_CREATE_AGED_OUT_EVENTf, tbl_data->aging_cfg_info_create_aged_out_event);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm, data, AGING_CFG_INFO_CREATE_REFRESH_EVENTf, tbl_data->aging_cfg_info_create_refresh_event);

  res = soc_mem_write(
          unit,
          PPDB_B_LARGE_EM_AGING_CONFIGURATION_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_aging_configuration_table_tbl_set_unsafe()", entry_offset, 0);
}


int
  arad_pp_ihp_tm_port_parser_program_pointer_config_tbl_get_unsafe(
    SOC_SAND_IN  int                    unit,
    SOC_SAND_IN  int                    core_id,
    SOC_SAND_IN  uint32                 entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_ENTRY_SIZE];
 
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32) * ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_DATA));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        ));

    tbl_data->parser_program_pointer_offset = soc_mem_field32_get(
                  unit,
                  IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
                  data,
                  OFFSETf);

    tbl_data->parser_program_pointer_value = soc_mem_field32_get(
                  unit,
                  IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
                  data,
                  VALUEf);

    tbl_data->parser_program_pointer_profile = soc_mem_field32_get(
                  unit,
                  IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
                  data,
                  PROFILEf);

    tbl_data->parser_program_pointer_value_to_use = soc_mem_field32_get(
                  unit,
                  IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
                  data,
                  VALUE_TO_USEf);

exit:
    SOCDNX_FUNC_RETURN;
}

int
  arad_pp_ihp_tm_port_parser_program_pointer_config_tbl_set_unsafe(
    SOC_SAND_IN  int                    unit,
    SOC_SAND_IN  int                    core_id,
    SOC_SAND_IN  uint32                 entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_DATA  *tbl_data
  )
{
    uint32 data[ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_ENTRY_SIZE];
 
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_IHP_TM_PORT_PARSER_PROGRAM_POINTER_CONFIG_TBL_ENTRY_SIZE);

    soc_mem_field32_set(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          data,
          OFFSETf,
          tbl_data->parser_program_pointer_offset);

    soc_mem_field32_set(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          data,
          VALUEf,
          tbl_data->parser_program_pointer_value);

    soc_mem_field32_set(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          data,
          PROFILEf,
          tbl_data->parser_program_pointer_profile);

    soc_mem_field32_set(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          data,
          VALUE_TO_USEf,
          tbl_data->parser_program_pointer_value_to_use);

    SOCDNX_IF_ERR_EXIT(soc_mem_write(
          unit,
          IHP_PTC_PARSER_PROGRAM_POINTER_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        ));

exit:
    SOCDNX_FUNC_RETURN;
}
uint32
  arad_pp_ihp_virtual_port_fem_bit_select_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->virtual_port_fem_bit_select   = soc_mem_field32_get(
                  unit,
                  IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLEm,
                  data,
                  VIRTUAL_PORT_FEM_BIT_SELECTf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_bit_select_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_virtual_port_fem_bit_select_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);

 
 



            soc_mem_field32_set(
          unit,
          IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLEm,
          data,
          VIRTUAL_PORT_FEM_BIT_SELECTf,
          tbl_data->virtual_port_fem_bit_select );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IHP_VIRTUAL_PORT_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_bit_select_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_virtual_port_fem_map_index_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              pgm_ndx,
   SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->virtual_port_fem_map_index   = soc_mem_field32_get(
                  unit,
                  IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
                  data,
                  VIRTUAL_PORT_FEM_MAP_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->virtual_port_fem_map_data   = soc_mem_field32_get(
                  unit,
                  IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
                  data,
                  VIRTUAL_PORT_FEM_MAP_DATAf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_map_index_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_virtual_port_fem_map_index_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              pgm_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);

 
 



            soc_mem_field32_set(
          unit,
          IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
          data,
          VIRTUAL_PORT_FEM_MAP_INDEXf,
          tbl_data->virtual_port_fem_map_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
          data,
          VIRTUAL_PORT_FEM_MAP_DATAf,
          tbl_data->virtual_port_fem_map_data );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_write(
          unit,
          IHP_VIRTUAL_PORT_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_map_index_table_tbl_set_unsafe()", entry_offset, 0);
}

static
    soc_field_t
        Arad_virtual_port_fem_field_select_field[SOC_DPP_DEFS_MAX(VIRTUAL_PORT_NOF_BITS)] = {
            VIRTUAL_PORT_FEM_FIELD_SELECT_0f, VIRTUAL_PORT_FEM_FIELD_SELECT_1f, VIRTUAL_PORT_FEM_FIELD_SELECT_2f, 
            VIRTUAL_PORT_FEM_FIELD_SELECT_3f, VIRTUAL_PORT_FEM_FIELD_SELECT_4f, VIRTUAL_PORT_FEM_FIELD_SELECT_5f, 
            VIRTUAL_PORT_FEM_FIELD_SELECT_6f, VIRTUAL_PORT_FEM_FIELD_SELECT_7f, VIRTUAL_PORT_FEM_FIELD_SELECT_8f, 
            VIRTUAL_PORT_FEM_FIELD_SELECT_9f, VIRTUAL_PORT_FEM_FIELD_SELECT_10f, VIRTUAL_PORT_FEM_FIELD_SELECT_11f, 
            VIRTUAL_PORT_FEM_FIELD_SELECT_12f, VIRTUAL_PORT_FEM_FIELD_SELECT_13f
#ifdef BCM_JERICHO_SUPPORT
          , VIRTUAL_PORT_FEM_FIELD_SELECT_14f
#endif /* BCM_JERICHO_SUPPORT */
        };
static
    soc_field_t
        Arad_src_system_port_fem_field_select_field[ARAD_PORTS_FEM_SYSTEM_PORT_SIZE] = {
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_0f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_1f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_2f, 
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_3f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_4f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_5f, 
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_6f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_7f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_8f, 
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_9f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_10f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_11f, 
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_12f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_13f, SRC_SYSTEM_PORT_FEM_FIELD_SELECT_14f, 
            SRC_SYSTEM_PORT_FEM_FIELD_SELECT_15f
        };

static
    soc_field_t
        Arad_parser_program_pointer_fem_field_select_field[ARAD_PORTS_FEM_PARSER_PROGRAM_POINTER_SIZE] = {
            PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_0f, PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_1f, 
            PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_2f, PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_3f, 
        };

uint32
  arad_pp_ihp_virtual_port_fem_field_select_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
  uint32
    field_ndx;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  for (field_ndx = 0; field_ndx < SOC_DPP_DEFS_GET(unit, virtual_port_nof_bits); ++field_ndx)
  {
            tbl_data->virtual_port_fem_field_select[field_ndx]     = soc_mem_field32_get(
                  unit,
                  IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAPm,
                    data,
                  Arad_virtual_port_fem_field_select_field[field_ndx]            );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40 + field_ndx, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_field_select_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_virtual_port_fem_field_select_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
  uint32
    field_ndx;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);

 
 



  for (field_ndx = 0; field_ndx < SOC_DPP_DEFS_GET(unit, virtual_port_nof_bits); ++field_ndx)
  {
            soc_mem_field32_set(
          unit,
          IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAPm,
            data,
          Arad_virtual_port_fem_field_select_field[field_ndx],
            tbl_data->virtual_port_fem_field_select[field_ndx] );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30 + field_ndx, exit);
  }

  res = soc_mem_write(
          unit,
          IHP_VIRTUAL_PORT_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
            data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 36, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_virtual_port_fem_field_select_map_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_src_system_port_fem_field_select_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
  uint32
    field_ndx;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  for (field_ndx = 0; field_ndx < ARAD_PORTS_FEM_SYSTEM_PORT_SIZE; ++field_ndx)
  {
            tbl_data->src_system_port_fem_field_select[field_ndx]     = soc_mem_field32_get(
                  unit,
                  IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAPm,
                    data,
                  Arad_src_system_port_fem_field_select_field[field_ndx]            );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40 + field_ndx, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_field_select_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_src_system_port_fem_field_select_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
  uint32
    field_ndx;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);

 
 



  for (field_ndx = 0; field_ndx < ARAD_PORTS_FEM_SYSTEM_PORT_SIZE; ++field_ndx)
  {
            soc_mem_field32_set(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAPm,
            data,
          Arad_src_system_port_fem_field_select_field[field_ndx],
            tbl_data->src_system_port_fem_field_select[field_ndx] );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30 + field_ndx, exit);
  }


  res = soc_mem_write(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
            data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 43, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_field_select_map_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_bit_select_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
            data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->parser_program_pointer_fem_bit_select   = soc_mem_field32_get(
                  unit,
                  IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLEm,
                  data,
                  PARSER_PROGRAM_POINTER_FEM_BIT_SELECTf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_bit_select_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_bit_select_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);

 
 



            soc_mem_field32_set(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLEm,
          data,
          PARSER_PROGRAM_POINTER_FEM_BIT_SELECTf,
          tbl_data->parser_program_pointer_fem_bit_select );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_bit_select_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_map_index_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              pgm_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->parser_program_pointer_fem_map_index   = soc_mem_field32_get(
                  unit,
                  IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
                  data,
                  PARSER_PROGRAM_POINTER_FEM_MAP_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->parser_program_pointer_fem_map_data   = soc_mem_field32_get(
                  unit,
                  IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
                  data,
                  PARSER_PROGRAM_POINTER_FEM_MAP_DATAf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_map_index_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_map_index_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              pgm_ndx,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);

 
 



            soc_mem_field32_set(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
          data,
          PARSER_PROGRAM_POINTER_FEM_MAP_INDEXf,
          tbl_data->parser_program_pointer_fem_map_index );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
          data,
          PARSER_PROGRAM_POINTER_FEM_MAP_DATAf,
          tbl_data->parser_program_pointer_fem_map_data );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_write(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_map_index_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_field_select_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
      field_ndx,
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_DATA, 1);

 
 



  res = soc_mem_read(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  for (field_ndx = 0; field_ndx < ARAD_PORTS_FEM_PARSER_PROGRAM_POINTER_SIZE; ++field_ndx)
  {
      tbl_data->parser_program_pointer_fem_field_select[field_ndx]   = soc_mem_field32_get(
            unit,
            IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAPm,
              data,
              Arad_parser_program_pointer_fem_field_select_field[field_ndx]            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_field_select_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_pointer_fem_field_select_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
      field_ndx,
    data[ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE];
 
 
 

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAP_TBL_ENTRY_SIZE);

 
 


  for (field_ndx = 0; field_ndx < ARAD_PORTS_FEM_PARSER_PROGRAM_POINTER_SIZE; ++field_ndx)
  {
      soc_mem_field32_set(
            unit,
            IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAPm,
            data,
            Arad_parser_program_pointer_fem_field_select_field[field_ndx],
            tbl_data->parser_program_pointer_fem_field_select[field_ndx] );
     SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }

  res = soc_mem_write(
          unit,
          IHP_PARSER_PROGRAM_POINTER_FEM_FIELD_SELECT_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 36, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_pointer_fem_field_select_map_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_program_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              array_index,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_PROGRAM_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_PROGRAM_TBL_DATA, 1); 

  res = soc_mem_array_read(
          unit,
          IHP_PARSER_PROGRAMm,
          array_index,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->next_addr_base   = soc_mem_field32_get(
                  unit,
                  IHP_PARSER_PROGRAMm,
                  data,
                  NEXT_ADDR_BASEf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->macro_sel   = soc_mem_field32_get(
                  unit,
                  IHP_PARSER_PROGRAMm,
                  data,
                  MACRO_SELf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_tbl_get_unsafe()", array_index, entry_offset);
}

uint32
  arad_pp_ihp_parser_program_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              array_index,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_PROGRAM_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_PROGRAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_PROGRAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_PROGRAM_TBL_ENTRY_SIZE);

    soc_mem_field32_set(
          unit,
          IHP_PARSER_PROGRAMm,
          data,
          NEXT_ADDR_BASEf,
          tbl_data->next_addr_base );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          IHP_PARSER_PROGRAMm,
          data,
          MACRO_SELf,
          tbl_data->macro_sel );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  res = soc_mem_array_write(
          unit,
          IHP_PARSER_PROGRAMm,
          array_index,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_program_tbl_set_unsafe()", array_index, entry_offset);
}

uint32
  arad_pp_ihp_lif_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  soc_reg_above_64_val_t
    data;
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)?PPDB_B_LIF_TABLEm:IHP_LIF_TABLEm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_TBL_DATA, 1);
  SOC_REG_ABOVE_64_CLEAR(data);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  if(SOC_IS_JERICHO_PLUS_A0(unit)){
      res = READ_PPDB_B_LIF_TABLEm(unit, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  }
  else{
      res = READ_IHP_LIF_TABLEm(unit, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  }

  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);

  soc_mem_field_get(unit, mem_var, data, LIF_TABLE_ENTRYf, tbl_data->lif_table_entry);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_sem_result_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32             entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  soc_reg_above_64_val_t
    data;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SEM_RESULT_TABLE_TBL_ENTRY_SIZE);
  SOC_REG_ABOVE_64_CLEAR(data);

  if(SOC_IS_JERICHO_PLUS_A0(unit)){
      soc_mem_field32_set(unit, PPDB_B_LIF_TABLEm, data, TYPEf, tbl_data->type);
      soc_mem_field_set(unit, PPDB_B_LIF_TABLEm, data, LIF_TABLE_ENTRYf, (uint32*)tbl_data->lif_table_entry);
  }
  else{
      soc_mem_field32_set(unit, IHP_LIF_TABLEm, data, TYPEf, tbl_data->type);
      soc_mem_field_set(unit, IHP_LIF_TABLEm, data, LIF_TABLE_ENTRYf, (uint32*)tbl_data->lif_table_entry);
  }


  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  if(SOC_IS_JERICHO_PLUS_A0(unit)){
      res = WRITE_PPDB_B_LIF_TABLEm(unit, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  }
  else{
      res = WRITE_IHP_LIF_TABLEm(unit, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  }

  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 50, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_sem_result_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt_pp_port_vsi_profiles_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT_PP_PORT_VSI_PROFILES_TBL_DATA  *tbl_data
  )
{
   uint32
    res = SOC_SAND_OK,
    data;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_PP_PORT_VSI_PROFILES_TBL_GET_UNSAFE);

  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT_PP_PORT_VSI_PROFILES_TBL_DATA, 1);

  res = READ_IHP_VTT_PP_PORT_VSI_PROFILESm(unit, IHP_BLOCK(unit, core_id),  entry_offset, &data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 11, exit);

  tbl_data->ac_p2p_to_ac_vsi_profile = soc_mem_field32_get(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_AC_VSI_PROFILEf);
  tbl_data->ac_p2p_to_pwe_vsi_profile = soc_mem_field32_get(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_PWE_VSI_PROFILEf);
  tbl_data->ac_p2p_to_pbb_vsi_profile = soc_mem_field32_get(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_PBB_VSI_PROFILEf);
  tbl_data->label_pwe_p2p_vsi_profile = soc_mem_field32_get(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, LABEL_PWEP2P_VSI_PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_pp_port_vsi_profiles_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt_pp_port_vsi_profiles_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32             entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT_PP_PORT_VSI_PROFILES_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    data = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_PP_PORT_VSI_PROFILES_TBL_SET_UNSAFE);

  soc_mem_field32_set(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_AC_VSI_PROFILEf, tbl_data->ac_p2p_to_ac_vsi_profile);
  soc_mem_field32_set(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_PWE_VSI_PROFILEf, tbl_data->ac_p2p_to_pwe_vsi_profile);
  soc_mem_field32_set(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, AC_P2P_TO_PBB_VSI_PROFILEf, tbl_data->ac_p2p_to_pbb_vsi_profile);
  soc_mem_field32_set(unit, IHP_VTT_PP_PORT_VSI_PROFILESm, &data, LABEL_PWEP2P_VSI_PROFILEf, tbl_data->label_pwe_p2p_vsi_profile);

  res = WRITE_IHP_VTT_PP_PORT_VSI_PROFILESm(unit, IHP_BLOCK(unit, core_id), entry_offset, &data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 22, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_pp_port_vsi_profiles_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_stp_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_STP_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[SOC_DPP_IMP_DEFS_MAX(IHP_STP_TABLE_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_STP_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_STP_TABLE_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_STP_TABLE_TBL_DATA, 1);

  res = READ_IHP_STP_TABLEm(unit, IHP_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);
  soc_mem_field_get(unit, IHP_STP_TABLEm, data, PER_PORT_STP_STATEf, tbl_data->per_port_stp_state);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_stp_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_stp_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
     SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_STP_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[SOC_DPP_IMP_DEFS_MAX(IHP_STP_TABLE_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_STP_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_STP_TABLE_NOF_LONGS));
 
  /* the casting below is because soc_mem_field_set mistakenly does not define its constant input as const */
  soc_mem_field_set(unit, IHP_STP_TABLEm, data, PER_PORT_STP_STATEf, (uint32*)(tbl_data->per_port_stp_state));
  res = WRITE_IHP_STP_TABLEm(unit, IHP_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_stp_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vrid_my_mac_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VRID_MY_MAC_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VRID_MY_MAC_MAP_TBL_GET_UNSAFE);

  SOC_REG_ABOVE_64_CLEAR(tbl_data->vrid_my_mac_map);

  res = READ_IHP_VRID_MY_MAC_MAPm(unit, MEM_BLOCK_ANY, entry_offset, tbl_data->vrid_my_mac_map);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vrid_my_mac_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vrid_my_mac_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VRID_MY_MAC_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VRID_MY_MAC_MAP_TBL_SET_UNSAFE);

  res = WRITE_IHP_VRID_MY_MAC_MAPm(unit, MEM_BLOCK_ANY, entry_offset, (void*)tbl_data->vrid_my_mac_map);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vrid_my_mac_map_tbl_set_unsafe()", entry_offset, 0);
}
uint32
  arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ISEM_1ST_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_1ST_KEY_PROG_SEL_TCAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->in_pp_port_vt_profile = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_VT_PROFILEf);         
  tbl_data->in_pp_port_vt_profile_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_VT_PROFILE_MASKf);    
  tbl_data->packet_format_code = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODEf);            
  tbl_data->packet_format_code_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODE_MASKf);       
  tbl_data->packet_format_qualifier_1 = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1f);     
  tbl_data->packet_format_qualifier_1_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1_MASKf);
  tbl_data->packet_format_qualifier_2 = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2f);     
  tbl_data->packet_format_qualifier_2_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2_MASKf);
  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXTf);           
  tbl_data->parser_leaf_context_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXT_MASKf);      
  tbl_data->ptc_vt_profile = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PTC_VT_PROFILEf);                
  tbl_data->ptc_vt_profile_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PTC_VT_PROFILE_MASKf);           
  tbl_data->valid = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, VALIDf);                         
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      tbl_data->llvp_prog_sel = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PROGRAM_DATAf);
  }
  else
  {
      tbl_data->llvp_prog_sel = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PROGRAMf);
  }
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->incoming_tag_structure = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, INCOMING_TAG_STRUCTUREf);
      tbl_data->incoming_tag_structure_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, INCOMING_TAG_STRUCTURE_MASKf);
      tbl_data->packet_format_qualifier_0 = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_0f);
      tbl_data->packet_format_qualifier_0_mask = soc_mem_field32_get(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_0_MASKf);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_isem_1st_program_selection_convert_tbl_data_to_data(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT uint32 *data
  )
{
  uint32
    res = SOC_SAND_OK;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_VT_PROFILEf, tbl_data->in_pp_port_vt_profile);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_VT_PROFILE_MASKf, tbl_data->in_pp_port_vt_profile_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODE_MASKf, tbl_data->packet_format_code_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1f, tbl_data->packet_format_qualifier_1);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1_MASKf, tbl_data->packet_format_qualifier_1_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2f, tbl_data->packet_format_qualifier_2);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2_MASKf, tbl_data->packet_format_qualifier_2_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXT_MASKf, tbl_data->parser_leaf_context_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PTC_VT_PROFILEf, tbl_data->ptc_vt_profile);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PTC_VT_PROFILE_MASKf, tbl_data->ptc_vt_profile_mask);
  soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, VALIDf, tbl_data->valid);
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PROGRAM_DATAf, tbl_data->llvp_prog_sel);
  }
  else
  {
      soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PROGRAMf, tbl_data->llvp_prog_sel);
  }
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, INCOMING_TAG_STRUCTURE_MASKf, tbl_data->incoming_tag_structure_mask);
      soc_mem_field32_set(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_0_MASKf, tbl_data->packet_format_qualifier_0_mask);
  }
  ARAD_DO_NOTHING_AND_EXIT; 

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_1st_program_selection_convert_tbl_data_to_data()", 0, 0);
}

uint32
  arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ISEM_1ST_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  res = arad_pp_ihp_isem_1st_program_selection_convert_tbl_data_to_data(
          unit,
          tbl_data,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_1ST_KEY_PROG_SEL_TCAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ISEM_2ND_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_2ND_KEY_PROG_SEL_TCAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->in_pp_port_tt_profile = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,IN_PP_PORT_TT_PROFILEf);
  tbl_data->in_pp_port_tt_profile_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,IN_PP_PORT_TT_PROFILE_MASKf);
  tbl_data->packet_format_code = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_CODEf);
  tbl_data->packet_format_code_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_CODE_MASKf);
  tbl_data->packet_format_qualifier_1 = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_QUALIFIER_1f);
  tbl_data->packet_format_qualifier_1_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_QUALIFIER_1_MASKf);
  tbl_data->packet_format_qualifier_2 = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2f);
  tbl_data->packet_format_qualifier_2_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_QUALIFIER_2_MASKf);
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->packet_format_qualifier_3_outer_vid_bits = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_QUALIFIER_3_OUTER_VID_BITSf);
      tbl_data->packet_format_qualifier_3_outer_vid_bits_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3_OUTER_VID_BITS_MASKf);
  }
  tbl_data->my_mac = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,MY_MACf);
  tbl_data->my_mac_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_MAC_MASKf);
  if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
  {
      tbl_data->my_b_mac_mc = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_B_MAC_MCf);
      tbl_data->my_b_mac_mc_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_B_MAC_MC_MASKf);
  }
  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PARSER_LEAF_CONTEXTf);
  tbl_data->parser_leaf_context_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PARSER_LEAF_CONTEXT_MASKf);
  tbl_data->ptc_tt_profile = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PTC_TT_PROFILEf);
  tbl_data->ptc_tt_profile_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PTC_TT_PROFILE_MASKf);
  tbl_data->da_is_all_r_bridges = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,DA_IS_ALL_R_BRIDGESf);
  tbl_data->da_is_all_r_bridges_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,DA_IS_ALL_R_BRIDGES_MASKf);
  tbl_data->isa_lookup_found = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,ISA_LOOKUP_FOUNDf);
  tbl_data->isa_lookup_found_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,ISA_LOOKUP_FOUND_MASKf);
  tbl_data->isb_lookup_found = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,ISB_LOOKUP_FOUNDf);
  tbl_data->isb_lookup_found_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,ISB_LOOKUP_FOUND_MASKf);
  tbl_data->tcam_lookup_match = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,TCAM_LOOKUP_MATCHf);
  tbl_data->tcam_lookup_match_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,TCAM_LOOKUP_MATCH_MASKf);
  tbl_data->packet_is_compatible_mc = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_IS_COMPATIBLE_MCf);
  tbl_data->packet_is_compatible_mc_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_IS_COMPATIBLE_MC_MASKf);
  tbl_data->vlan_is_designated = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,VLAN_IS_DESIGNATEDf);
  tbl_data->vlan_is_designated_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,VLAN_IS_DESIGNATED_MASKf);
  tbl_data->vt_processing_profile = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,VT_PROCESSING_PROFILEf);
  tbl_data->vt_processing_profile_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,VT_PROCESSING_PROFILE_MASKf);
  tbl_data->valid = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,VALIDf);
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      tbl_data->enable_routing_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,ENABLE_ROUTING_MASKf);      
      tbl_data->enable_routing = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ENABLE_ROUTINGf);
      tbl_data->llvp_prog_sel = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PROGRAM_DATAf);
  }
  else
  {
      tbl_data->llvp_prog_sel = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PROGRAMf);
  }
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->vt_in_lif_profile = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VT_IN_LIF_PROFILEf);
      tbl_data->vt_in_lif_profile_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VT_IN_LIF_PROFILE_MASKf);
      tbl_data->packet_format_qualifier_3 = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3f);
      tbl_data->packet_format_qualifier_3_mask = soc_mem_field32_get(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data,PACKET_FORMAT_QUALIFIER_3_MASKf);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_isem_2nd_program_selection_convert_tbl_data_to_data(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data,
    SOC_SAND_OUT uint32 *data
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_TT_PROFILEf,tbl_data->in_pp_port_tt_profile);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, IN_PP_PORT_TT_PROFILE_MASKf, tbl_data->in_pp_port_tt_profile_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_CODE_MASKf, tbl_data->packet_format_code_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1f, tbl_data->packet_format_qualifier_1);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_1_MASKf, tbl_data->packet_format_qualifier_1_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2f, tbl_data->packet_format_qualifier_2);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_2_MASKf, tbl_data->packet_format_qualifier_2_mask);
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3_OUTER_VID_BITSf, tbl_data->packet_format_qualifier_3_outer_vid_bits);
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3_OUTER_VID_BITS_MASKf, tbl_data->packet_format_qualifier_3_outer_vid_bits_mask);
  }
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_MACf, tbl_data->my_mac);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_MAC_MASKf, tbl_data->my_mac_mask);
  if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
  {
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_B_MAC_MCf, tbl_data->my_b_mac_mc);
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, MY_B_MAC_MC_MASKf, tbl_data->my_b_mac_mc_mask);
  }

  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PARSER_LEAF_CONTEXT_MASKf, tbl_data->parser_leaf_context_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PTC_TT_PROFILEf, tbl_data->ptc_tt_profile);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PTC_TT_PROFILE_MASKf, tbl_data->ptc_tt_profile_mask );
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, DA_IS_ALL_R_BRIDGESf, tbl_data->da_is_all_r_bridges );
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, DA_IS_ALL_R_BRIDGES_MASKf, tbl_data->da_is_all_r_bridges_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ISA_LOOKUP_FOUNDf, tbl_data->isa_lookup_found);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ISA_LOOKUP_FOUND_MASKf, tbl_data->isa_lookup_found_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ISB_LOOKUP_FOUNDf, tbl_data->isb_lookup_found);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ISB_LOOKUP_FOUND_MASKf, tbl_data->isb_lookup_found_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, TCAM_LOOKUP_MATCHf, tbl_data->tcam_lookup_match);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, TCAM_LOOKUP_MATCH_MASKf, tbl_data->tcam_lookup_match_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_IS_COMPATIBLE_MCf, tbl_data->packet_is_compatible_mc);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_IS_COMPATIBLE_MC_MASKf, tbl_data->packet_is_compatible_mc_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VLAN_IS_DESIGNATEDf, tbl_data->vlan_is_designated);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VLAN_IS_DESIGNATED_MASKf, tbl_data->vlan_is_designated_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VT_PROCESSING_PROFILEf, tbl_data->vt_processing_profile);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VT_PROCESSING_PROFILE_MASKf, tbl_data->vt_processing_profile_mask);
  soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VALIDf, tbl_data->valid);
  if(SOC_IS_JERICHO_PLUS(unit))
  {
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ENABLE_ROUTING_MASKf, tbl_data->enable_routing_mask);
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, ENABLE_ROUTINGf     , tbl_data->enable_routing );

      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PROGRAM_DATAf, tbl_data->llvp_prog_sel);
  }
  else
  {
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PROGRAMf, tbl_data->llvp_prog_sel);
  }
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, VT_IN_LIF_PROFILE_MASKf, tbl_data->vt_in_lif_profile_mask);
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3f, tbl_data->packet_format_qualifier_3);
      soc_mem_field32_set(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, data, PACKET_FORMAT_QUALIFIER_3_MASKf, tbl_data->packet_format_qualifier_3_mask);
  }
  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_2nd_program_selection_convert_tbl_data_to_data()", 0, 0);
}

uint32
  arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ISEM_2ND_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  res = arad_pp_ihp_isem_2nd_program_selection_convert_tbl_data_to_data(
          unit,
          tbl_data,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_2ND_KEY_PROG_SEL_TCAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}

/* 
 * in jericho, 2 new copy engines in both IHP_VTT_1ST_LOOKUP_PROGRAM_0/1 
 * Temporary bypass to work on Arad microcode: 
 * - do not use the 2 new copy engines 
 * - encode differently key_valids_1 accordingly 
 */
uint32
  arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(
    SOC_SAND_IN  uint32              key_valids_1
  )
{
    /* Move bits 3:2 to bits 5:4 instead */
    return ((key_valids_1 & 0x3) + (((key_valids_1 & 0xC) >> 2) << 4));
}

uint32
  arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(
    SOC_SAND_IN  uint32              key_valids_1
  )
{
    /* Take bits 3:2 from bits 5:4 instead */
    return ((key_valids_1 & 0x3) + (((key_valids_1 & 0x30) >> 4) << 2));
}


uint32
  arad_pp_ihp_vtt1st_key_construction0_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_DATA  *tbl_data
  )
{
  uint32 dbal;
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_GET_UNSAFE);

  dbal = tbl_data->dbal;

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->key_16b_inst0 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_16B_INST_0f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  tbl_data->key_16b_inst1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_16B_INST_1f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  tbl_data->key_32b_inst0 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_32B_INST_0f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  tbl_data->key_32b_inst1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_32B_INST_1f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  tbl_data->isa_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  ISA_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  tbl_data->isb_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  ISB_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

  tbl_data->tcam_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  TCAM_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

  if (SOC_IS_JERICHO(unit) )
  {

      if(dbal)
      {
          tbl_data->key_16b_inst2 = soc_mem_field32_get(
                            unit,
                            IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                            data,
                            KEY_16B_INST_2f    );
            SOC_SAND_CHECK_FUNC_RESULT(res, 59, exit);

            tbl_data->key_16b_inst3 = soc_mem_field32_get(
                            unit,
                            IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                            data,
                            KEY_16B_INST_3f    );
            SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

      }
      else
      {
          /* Temp WA to work on Arad microcode */
          tbl_data->isa_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isa_key_valids_1);
          tbl_data->isb_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isb_key_valids_1);
          tbl_data->tcam_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->tcam_key_valids_1);
      }
  }

  tbl_data->key_program_variable = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_PROGRAM_VARIABLEf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction0_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt1st_key_construction0_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_DATA  *tbl_data
  )
{
  uint32
      isa_key_valids_1,
      isb_key_valids_1,
      tcam_key_valids_1,
    res = SOC_SAND_OK;
  uint32    
    data[ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          KEY_16B_INST_0f,
          tbl_data->key_16b_inst0 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          KEY_16B_INST_1f,
          tbl_data->key_16b_inst1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          KEY_32B_INST_0f,
          tbl_data->key_32b_inst0 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          KEY_32B_INST_1f,
          tbl_data->key_32b_inst1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  if (SOC_IS_JERICHO(unit) && !tbl_data->dbal) {
      /* Temp WA to work on Arad microcode */
      isa_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isa_key_valids_1);
      isb_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isb_key_valids_1);
      tcam_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->tcam_key_valids_1);
  } else {
      if(SOC_IS_JERICHO(unit))
      {
          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_16B_INST_2f,
                  tbl_data->key_16b_inst2 );
          SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);

            soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
                  data,
                  KEY_16B_INST_3f,
                  tbl_data->key_16b_inst3 );
          SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
      }
      isa_key_valids_1 = tbl_data->isa_key_valids_1;
      isb_key_valids_1 = tbl_data->isb_key_valids_1;
      tcam_key_valids_1 = tbl_data->tcam_key_valids_1;
  }

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          ISA_KEY_VALIDSf,
          isa_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          ISB_KEY_VALIDSf,
          isb_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          TCAM_KEY_VALIDSf,
          tcam_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          data,
          KEY_PROGRAM_VARIABLEf,
          tbl_data->key_program_variable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 55, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction0_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_strength_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint8              is_for_flp, 
    SOC_SAND_IN  uint32             fld_ndx,
    SOC_SAND_OUT uint32            *fld_location,
    SOC_SAND_OUT uint32            *fld_strength
  )
{
  uint32
    fld_location_vtt[ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {2,5,4,3}, /* TCAM-LP, TCAM-HP, ISEM-A, ISEM-B*/
    fld_strength_vtt[ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {1,3,2,2}, /* TCAM-LP, TCAM-HP, ISEM-A, ISEM-B*/
    fld_location_flp[ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS] = {0,0,0,0,0,0,0}, /* ELK-FWD, LEM-2, TCAM, LPM-2, ELK-Ext, LEM-1, LPM-1 */
    fld_strength_flp[ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS] = {1,1,1,1,1,1,1}; /* ELK-FWD, LEM-2, TCAM, LPM-2, ELK-Ext, LEM-1, LPM-1 */

 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  *fld_location = (is_for_flp)? fld_location_flp[fld_ndx]: fld_location_vtt[fld_ndx];
  *fld_strength = (is_for_flp)? fld_strength_flp[fld_ndx]: fld_strength_vtt[fld_ndx];

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_strength_get_unsafe()", 0, 0);
}


uint32
  arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint8              is_for_flp,
    SOC_SAND_IN  uint32             *data,
    SOC_SAND_IN  soc_mem_t          mem_id, 
    SOC_SAND_IN  soc_field_t        *field_array, /* VTT: TCAM-LP, TCAM-HP, ISEM-A, ISEM-B */
    SOC_SAND_OUT uint32            *pd_bitmap
  )
{
  uint32
    fld_val,
    fld_ndx,
    fld_location_lcl,
    fld_strength_lcl,
    res = SOC_SAND_OK;

 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);


  *pd_bitmap = 0;

  for (fld_ndx = 0; fld_ndx < ((is_for_flp)? ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS: ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS); fld_ndx++) {
      fld_val = soc_mem_field32_get(
                      unit,
                      mem_id,
                      data,
                      field_array[fld_ndx]);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10 + fld_ndx, exit);

      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_strength_get_unsafe(
                unit,
                is_for_flp,
                fld_ndx,
                &fld_location_lcl,
                &fld_strength_lcl
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30 + fld_ndx, exit);

      if (fld_val == fld_strength_lcl) {
          SHR_BITSET(pd_bitmap, fld_location_lcl);
      }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe()", 0, 0);
}

uint32
  arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint8              is_for_flp,
    SOC_SAND_INOUT  uint32             *data,
    SOC_SAND_IN  soc_mem_t          mem_id, 
    SOC_SAND_IN  soc_field_t        *field_array, /* VTT: TCAM-LP, TCAM-HP, ISEM-A, ISEM-B */
    SOC_SAND_IN  uint32             pd_bitmap
  )
{
  uint32
    fld_val,
    fld_ndx,
    fld_location_lcl,
    fld_strength_lcl,
    pd_bitmap_lcl[1],
    res = SOC_SAND_OK;

 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* 
   * Since the TCAM appears twice in pd_bitmap, prefer: 
   * 1. Set to 0 all the field values 
   * 2. Change their value only if the bit in pd_bitmap is set 
   */
  for (fld_ndx = 0; fld_ndx < ((is_for_flp)? ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS: ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS); fld_ndx++) {
      fld_val = 0;

      soc_mem_field32_set(
              unit,
              mem_id,
              data,
              field_array[fld_ndx],
              fld_val);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }

  for (fld_ndx = 0; fld_ndx < ((is_for_flp)? ARAD_PP_FLP_PD_BITMAP_NOF_FIELDS: ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS); fld_ndx++) {
      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_strength_get_unsafe(
                unit,
                is_for_flp,
                fld_ndx,
                &fld_location_lcl,
                &fld_strength_lcl
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30 + fld_ndx, exit);

      *pd_bitmap_lcl = pd_bitmap;
      if (SHR_BITGET(pd_bitmap_lcl, fld_location_lcl)) {
          fld_val = fld_strength_lcl;
          soc_mem_field32_set(
                  unit,
                  mem_id,
                  data,
                  field_array[fld_ndx],
                  fld_val);
          SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);
      }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe()", 0, 0);
}


uint32
  arad_pp_ihp_vtt1st_key_construction1_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_DATA  *tbl_data
  )
{
  uint32 dbal;
  uint32
    res = SOC_SAND_OK;
  uint32    
    data[ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE];
 
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_GET_UNSAFE);

  dbal = tbl_data->dbal;

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_DATA, 1);

 
  res = soc_mem_read(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  if (SOC_IS_JERICHO(unit) && dbal)
  {
      tbl_data->key_16b_inst4   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      KEY_16B_INST_4f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

      tbl_data->key_16b_inst5   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      KEY_16B_INST_5f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

      tbl_data->key_16b_inst6   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      KEY_16B_INST_6f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

      tbl_data->key_16b_inst7   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      KEY_16B_INST_7f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);

  }
  else
  {
      tbl_data->key_16b_inst2   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      SOC_IS_JERICHO(unit)? KEY_16B_INST_4f: KEY_16B_INST_2f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

      tbl_data->key_16b_inst3   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      SOC_IS_JERICHO(unit)? KEY_16B_INST_5f: KEY_16B_INST_3f );
      SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);
  }
  tbl_data->key_32b_inst2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  KEY_32B_INST_2f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  tbl_data->key_32b_inst3   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  KEY_32B_INST_3f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 43, exit);

  tbl_data->isa_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISA_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  tbl_data->isb_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISB_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  tbl_data->tcam_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  TCAM_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);
  
  if (SOC_IS_JERICHO(unit) && !dbal) {
      /* Temp WA to work on Arad microcode */
      tbl_data->isa_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isa_key_valids_2);
      tbl_data->isb_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isb_key_valids_2);
      tbl_data->tcam_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->tcam_key_valids_2);
  } 


  tbl_data->isa_and_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISA_AND_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  tbl_data->isa_or_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISA_OR_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  tbl_data->isa_lookup_enable   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISA_LOOKUP_ENABLEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

  tbl_data->isb_and_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISB_AND_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

  tbl_data->isb_or_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISB_OR_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

  tbl_data->isb_lookup_enable   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  ISB_LOOKUP_ENABLEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

  tbl_data->tcam_db_profile   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  TCAM_DB_PROFILEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

  if (!SOC_IS_ARADPLUS(unit)) {
      tbl_data->vlan_translation_0_pd_bitmap   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_0_PD_BITMAPf);
      SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

      tbl_data->vlan_translation_1_pd_bitmap   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_1_PD_BITMAPf);
      SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);
  }
  else {
      /* 
       * In ARAD+: 
       * - Skip looking at the 2 LSBs of vlan_translation_0_pd_bitmap: 
       * it seems unused in arad_pp_isem_access.c in any program. Return an error if set in Arad+
       * - Translation table from enable->strength with assumption the order in same strength 
       * is identical to Arad-A0/B0: 
       *   for TCAM low-priority: 0<->0 and 1<-> strength 1
       *   for ISEM-A/B: 0<->0 and 1<->strength 2
       *   for TCAM high-priority: 0<->0 and 1<->strength 3
       */
      soc_field_t 
          strength_fields[2][ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {
              {VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_0_PD_ISA_STRENGTHf, VLAN_TRANSLATION_0_PD_ISB_STRENGTHf},
              {VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_1_PD_ISA_STRENGTHf, VLAN_TRANSLATION_1_PD_ISB_STRENGTHf}
          };
      /* 
       * In case in_use_strength == 0 then use pd_bitmap and convert it to strength (ARAD compatible mode)
       */
      if (tbl_data->vlan_translation_is_use_strength == 0) {
          res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe(
                    unit,
                    FALSE, /* is_for_flp */
                    data,
                    IHP_VTT_1ST_LOOKUP_PROGRAM_1m, 
                    strength_fields[0],
                    &(tbl_data->vlan_translation_0_pd_bitmap)
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

          res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe(
                    unit,
                    FALSE, /* is_for_flp */
                    data,
                    IHP_VTT_1ST_LOOKUP_PROGRAM_1m, 
                    strength_fields[1],
                    &(tbl_data->vlan_translation_1_pd_bitmap)
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);
      } else {
          tbl_data->vlan_translation_0_pd_tcam_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

          tbl_data->vlan_translation_0_pd_isa_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_0_PD_ISA_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);

          tbl_data->vlan_translation_0_pd_isb_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_0_PD_ISB_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 68, exit);

          tbl_data->vlan_translation_1_pd_tcam_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

          tbl_data->vlan_translation_1_pd_isa_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_1_PD_ISA_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 72, exit);

          tbl_data->vlan_translation_1_pd_isb_strength   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                      data,
                      VLAN_TRANSLATION_1_PD_ISB_STRENGTHf);
          SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);
      }
  }

  tbl_data->processing_profile   = soc_mem_field32_get(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              PROCESSING_PROFILEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction1_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt1st_key_construction1_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_DATA  *tbl_data
  )
{
  uint32
    isa_key_valids_2,
    isb_key_valids_2,
    tcam_key_valids_2,
    res = SOC_SAND_OK;
  uint32    
    data[ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE);

  if(SOC_IS_JERICHO(unit) && tbl_data->dbal)
  {
      soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              KEY_16B_INST_4f,
              tbl_data->key_16b_inst4 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

        soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              KEY_16B_INST_5f,
              tbl_data->key_16b_inst5 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

      soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              KEY_16B_INST_6f,
              tbl_data->key_16b_inst6 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

        soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              KEY_16B_INST_7f,
              tbl_data->key_16b_inst7 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);
  }
  else
  {
      soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              SOC_IS_JERICHO(unit)? KEY_16B_INST_4f: KEY_16B_INST_2f,
              tbl_data->key_16b_inst2 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

        soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              SOC_IS_JERICHO(unit)? KEY_16B_INST_5f: KEY_16B_INST_3f,
              tbl_data->key_16b_inst3 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);
  }
    soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          KEY_32B_INST_2f,
          tbl_data->key_32b_inst2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          KEY_32B_INST_3f,
          tbl_data->key_32b_inst3 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
 
  if (SOC_IS_JERICHO(unit) && !tbl_data->dbal) {
      /* Temp WA to work on Arad microcode */
      isa_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isa_key_valids_2);
      isb_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isb_key_valids_2);
      tcam_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->tcam_key_valids_2);
  } else {
      isa_key_valids_2 = tbl_data->isa_key_valids_2;
      isb_key_valids_2 = tbl_data->isb_key_valids_2;
      tcam_key_valids_2 = tbl_data->tcam_key_valids_2;
  } 

    soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISA_KEY_VALIDSf,
          isa_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISB_KEY_VALIDSf,
          isb_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          TCAM_KEY_VALIDSf,
          tcam_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISA_AND_MASKf,
          tbl_data->isa_and_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISA_OR_MASKf,
          tbl_data->isa_or_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISA_LOOKUP_ENABLEf,
          tbl_data->isa_lookup_enable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISB_AND_MASKf,
          tbl_data->isb_and_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISB_OR_MASKf,
          tbl_data->isb_or_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          ISB_LOOKUP_ENABLEf,
          tbl_data->isb_lookup_enable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          TCAM_DB_PROFILEf,
          tbl_data->tcam_db_profile );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);


  if (!SOC_IS_ARADPLUS(unit)) {
      soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              VLAN_TRANSLATION_0_PD_BITMAPf,
              tbl_data->vlan_translation_0_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

      soc_mem_field32_set(
              unit,
              IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
              data,
              VLAN_TRANSLATION_1_PD_BITMAPf,
              tbl_data->vlan_translation_1_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
  }
  else {
      /* 
       * In ARAD+: 
       * - Skip looking at the 2 LSBs of vlan_translation_0_pd_bitmap: 
       * it seems unused in arad_pp_isem_access.c in any program. Return an error if set in Arad+
       * - Translation table from enable->strength with assumption the order in same strength 
       * is identical to Arad-A0/B0: 
       *   for TCAM low-priority: 0<->0 and 1<-> strength 1
       *   for ISEM-A/B: 0<->0 and 1<->strength 2
       *   for TCAM high-priority: 0<->0 and 1<->strength 3
       */
      soc_field_t 
          strength_fields[2][ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {
              {VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_0_PD_ISA_STRENGTHf, VLAN_TRANSLATION_0_PD_ISB_STRENGTHf},
              {VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf, VLAN_TRANSLATION_1_PD_ISA_STRENGTHf, VLAN_TRANSLATION_1_PD_ISB_STRENGTHf}
          };

      /* 
       * In case in_use_strength == 0 then use pd_bitmap and convert it to strength (ARAD compatible mode)
       */
      if (tbl_data->vlan_translation_is_use_strength == 0) {
          res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe(
                  unit,
                  FALSE, /* is_for_flp */
                  data,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m, 
                  strength_fields[0],
                  tbl_data->vlan_translation_0_pd_bitmap );
          SOC_SAND_CHECK_FUNC_RESULT(res, 53, exit);

          res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe(
                  unit,
                  FALSE, /* is_for_flp */
                  data,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m, 
                  strength_fields[1],
                  tbl_data->vlan_translation_1_pd_bitmap );
          SOC_SAND_CHECK_FUNC_RESULT(res, 55, exit);
      } else {
          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_0_PD_TCAM_STRENGTHf,
                  tbl_data->vlan_translation_0_pd_tcam_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_0_PD_ISA_STRENGTHf,
                  tbl_data->vlan_translation_0_pd_isa_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_0_PD_ISB_STRENGTHf,
                  tbl_data->vlan_translation_0_pd_isb_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_1_PD_TCAM_STRENGTHf,
                  tbl_data->vlan_translation_1_pd_tcam_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_1_PD_ISA_STRENGTHf,
                  tbl_data->vlan_translation_1_pd_isa_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

          soc_mem_field32_set(
                  unit,
                  IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
                  data,
                  VLAN_TRANSLATION_1_PD_ISB_STRENGTHf,
                  tbl_data->vlan_translation_1_pd_isb_strength );
          SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);
      }      
  }

  soc_mem_field32_set(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          data,
          PROCESSING_PROFILEf,
          tbl_data->processing_profile );
  SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_1ST_LOOKUP_PROGRAM_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 66, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction1_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_INOUT ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA  *tbl_data
  )
{
   uint32 dbal;
   uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_DATA
    data0;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_DATA
    data1;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_GET_UNSAFE);

  dbal = tbl_data->dbal;

  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  data0.dbal = dbal;
  res = arad_pp_ihp_vtt1st_key_construction0_tbl_get_unsafe(
          unit,
          entry_offset,
          &data0
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  data1.dbal = dbal;
  res = arad_pp_ihp_vtt1st_key_construction1_tbl_get_unsafe(
          unit,
          entry_offset,
          &data1
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  tbl_data->key_16b_inst0 = data0.key_16b_inst0;
  tbl_data->key_16b_inst1 = data0.key_16b_inst1;

  if(SOC_IS_JERICHO(unit) && dbal)
  {
      tbl_data->key_16b_inst2 = data0.key_16b_inst2;
      tbl_data->key_16b_inst3 = data0.key_16b_inst3;
      tbl_data->key_16b_inst4 = data1.key_16b_inst4;
      tbl_data->key_16b_inst5 = data1.key_16b_inst5;
      tbl_data->key_16b_inst6 = data1.key_16b_inst6;
      tbl_data->key_16b_inst7 = data1.key_16b_inst7;
  }
  else
  {
      tbl_data->key_16b_inst2 = data1.key_16b_inst2;
      tbl_data->key_16b_inst3 = data1.key_16b_inst3;
  }
  tbl_data->key_32b_inst0 = data0.key_32b_inst0;
  tbl_data->key_32b_inst1 = data0.key_32b_inst1;
  tbl_data->isa_key_valids_1 = data0.isa_key_valids_1;
  tbl_data->isb_key_valids_1 = data0.isb_key_valids_1;
  tbl_data->tcam_key_valids_1 = data0.tcam_key_valids_1;
  tbl_data->key_program_variable = data0.key_program_variable;
  tbl_data->key_32b_inst2 = data1.key_32b_inst2;
  tbl_data->key_32b_inst3 = data1.key_32b_inst3;
  tbl_data->isa_key_valids_2 = data1.isa_key_valids_2;
  tbl_data->isb_key_valids_2 = data1.isb_key_valids_2;
  tbl_data->tcam_key_valids_2 = data1.tcam_key_valids_2;
  tbl_data->isa_and_mask = data1.isa_and_mask;
  tbl_data->isa_or_mask = data1.isa_or_mask;
  tbl_data->isa_lookup_enable = data1.isa_lookup_enable;
  tbl_data->isb_and_mask = data1.isb_and_mask;
  tbl_data->isb_or_mask = data1.isb_or_mask;
  tbl_data->isb_lookup_enable = data1.isb_lookup_enable;
  tbl_data->tcam_db_profile = data1.tcam_db_profile;
  tbl_data->vlan_translation_0_pd_bitmap = data1.vlan_translation_0_pd_bitmap;
  tbl_data->vlan_translation_1_pd_bitmap = data1.vlan_translation_1_pd_bitmap;
  tbl_data->processing_profile = data1.processing_profile;

#ifdef BCM_88660_A0
  if (tbl_data->vlan_translation_is_use_strength) {
      tbl_data->vlan_translation_0_pd_tcam_strength = data1.vlan_translation_0_pd_tcam_strength;
      tbl_data->vlan_translation_0_pd_isa_strength = data1.vlan_translation_0_pd_isa_strength; 
      tbl_data->vlan_translation_0_pd_isb_strength = data1.vlan_translation_0_pd_isb_strength; 
      tbl_data->vlan_translation_1_pd_tcam_strength = data1.vlan_translation_1_pd_tcam_strength;
      tbl_data->vlan_translation_1_pd_isa_strength = data1.vlan_translation_1_pd_isa_strength; 
      tbl_data->vlan_translation_1_pd_isb_strength = data1.vlan_translation_1_pd_isb_strength; 
  }
#endif

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION0_TBL_DATA
    data0;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION1_TBL_DATA
    data1;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_SET_UNSAFE);

  data0.dbal = tbl_data->dbal;
  data1.dbal = tbl_data->dbal;
  data0.key_16b_inst0 = tbl_data->key_16b_inst0;
  data0.key_16b_inst1 = tbl_data->key_16b_inst1;
  data0.key_32b_inst0 = tbl_data->key_32b_inst0;
  data0.key_32b_inst1 = tbl_data->key_32b_inst1;
  if(SOC_IS_JERICHO(unit) && tbl_data->dbal)
  {
      data0.key_16b_inst2 = tbl_data->key_16b_inst2;
      data0.key_16b_inst3 = tbl_data->key_16b_inst3;
      data1.key_16b_inst4 = tbl_data->key_16b_inst4;
      data1.key_16b_inst5 = tbl_data->key_16b_inst5;
      data1.key_16b_inst6 = tbl_data->key_16b_inst6;
      data1.key_16b_inst7 = tbl_data->key_16b_inst7;
  }
  else
  {
      data1.key_16b_inst2 = tbl_data->key_16b_inst2;
      data1.key_16b_inst3 = tbl_data->key_16b_inst3;
  }
  data0.isa_key_valids_1 = tbl_data->isa_key_valids_1;
  data0.isb_key_valids_1 = tbl_data->isb_key_valids_1;
  data0.tcam_key_valids_1 = tbl_data->tcam_key_valids_1;
  data0.key_program_variable = tbl_data->key_program_variable;
  data1.key_32b_inst2 = tbl_data->key_32b_inst2;
  data1.key_32b_inst3 = tbl_data->key_32b_inst3;
  data1.isa_key_valids_2 = tbl_data->isa_key_valids_2;
  data1.isb_key_valids_2 = tbl_data->isb_key_valids_2;
  data1.tcam_key_valids_2 = tbl_data->tcam_key_valids_2;
  data1.isa_and_mask = tbl_data->isa_and_mask;
  data1.isa_or_mask = tbl_data->isa_or_mask;
  data1.isa_lookup_enable = tbl_data->isa_lookup_enable;
  data1.isb_and_mask = tbl_data->isb_and_mask;
  data1.isb_or_mask = tbl_data->isb_or_mask;
  data1.isb_lookup_enable = tbl_data->isb_lookup_enable;
  data1.tcam_db_profile = tbl_data->tcam_db_profile;
  data1.vlan_translation_0_pd_bitmap = tbl_data->vlan_translation_0_pd_bitmap;
  data1.vlan_translation_1_pd_bitmap = tbl_data->vlan_translation_1_pd_bitmap;
  data1.processing_profile = tbl_data->processing_profile;

#ifdef BCM_88660_A0
  data1.vlan_translation_is_use_strength = 0;
  if (tbl_data->vlan_translation_is_use_strength) {
      data1.vlan_translation_is_use_strength = tbl_data->vlan_translation_is_use_strength;
      data1.vlan_translation_0_pd_tcam_strength = tbl_data->vlan_translation_0_pd_tcam_strength;
      data1.vlan_translation_0_pd_isa_strength = tbl_data->vlan_translation_0_pd_isa_strength; 
      data1.vlan_translation_0_pd_isb_strength = tbl_data->vlan_translation_0_pd_isb_strength; 
      data1.vlan_translation_1_pd_tcam_strength = tbl_data->vlan_translation_1_pd_tcam_strength;
      data1.vlan_translation_1_pd_isa_strength = tbl_data->vlan_translation_1_pd_isa_strength; 
      data1.vlan_translation_1_pd_isb_strength = tbl_data->vlan_translation_1_pd_isb_strength; 
  }
#endif

  res = arad_pp_ihp_vtt1st_key_construction0_tbl_set_unsafe(
          unit,
          entry_offset,
          &data0
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = arad_pp_ihp_vtt1st_key_construction1_tbl_set_unsafe(
          unit,
          entry_offset,
          &data1
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA  *tbl_data
  )
{
  uint32 dbal;
  uint32
    res = SOC_SAND_OK;
  uint32    
    data_tbl_0[ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE],
    data_tbl_1[ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_GET_UNSAFE);

  dbal = tbl_data->dbal;
  ARAD_CLEAR(data_tbl_0, uint32, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE);
  ARAD_CLEAR(data_tbl_1, uint32, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  /* 
   * ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0
   */
  res = soc_mem_read(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data_tbl_0          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->key_16b_inst0 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  KEY_16B_INST_0f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  tbl_data->key_16b_inst1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  KEY_16B_INST_1f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  tbl_data->key_32b_inst0 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  KEY_32B_INST_0f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  tbl_data->key_32b_inst1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  KEY_32B_INST_1f    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  tbl_data->isa_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  ISA_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  tbl_data->isb_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  ISB_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

  tbl_data->tcam_key_valids_1 = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  TCAM_KEY_VALIDSf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

  if (SOC_IS_JERICHO(unit) && !dbal) {
      /* Temp WA to work on Arad microcode */
      tbl_data->isa_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isa_key_valids_1);
      tbl_data->isb_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isb_key_valids_1);
      tbl_data->tcam_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->tcam_key_valids_1);
  }
  else
  {
      if(SOC_IS_JERICHO(unit))
      {
          tbl_data->key_16b_inst2 = soc_mem_field32_get(
                          unit,
                          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                          data_tbl_0,
                          KEY_16B_INST_2f    );
          SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

          tbl_data->key_16b_inst3 = soc_mem_field32_get(
                          unit,
                          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                          data_tbl_0,
                          KEY_16B_INST_3f    );
          SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);
      }
  }

  tbl_data->key_program_variable = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  KEY_PROGRAM_VARIABLEf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

  tbl_data->isa_key_initial_from_vt = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  ISA_KEY_INITIAL_FROM_VTf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

  tbl_data->isb_key_initial_from_vt = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  ISB_KEY_INITIAL_FROM_VTf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

  tbl_data->tcam_key_initial_from_vt = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
                  data_tbl_0,
                  TCAM_KEY_INITIAL_FROM_VTf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

  /* 
   * ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1
   */
  res = soc_mem_read(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data_tbl_1          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  if (SOC_IS_JERICHO(unit) && dbal)
  {
      tbl_data->key_16b_inst4   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      KEY_16B_INST_4f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

      tbl_data->key_16b_inst5   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      KEY_16B_INST_5f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

      tbl_data->key_16b_inst6   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      KEY_16B_INST_6f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

      tbl_data->key_16b_inst7   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      KEY_16B_INST_7f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

  }
  else
  {
      tbl_data->key_16b_inst2   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      SOC_IS_JERICHO(unit)? KEY_16B_INST_4f: KEY_16B_INST_2f);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

      tbl_data->key_16b_inst3   = soc_mem_field32_get(
                      unit,
                      IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                      data_tbl_1,
                      SOC_IS_JERICHO(unit)? KEY_16B_INST_5f: KEY_16B_INST_3f            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);
  }

  tbl_data->key_32b_inst2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  KEY_32B_INST_2f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  tbl_data->key_32b_inst3   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  KEY_32B_INST_3f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 43, exit);

  tbl_data->isa_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISA_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  tbl_data->isb_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISB_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  tbl_data->tcam_key_valids_2   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  TCAM_KEY_VALIDSf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);
  
  if (SOC_IS_JERICHO(unit) && !dbal) {
      /* Temp WA to work on Arad microcode */
      tbl_data->isa_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isa_key_valids_2);
      tbl_data->isb_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->isb_key_valids_2);
      tbl_data->tcam_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_parse(tbl_data->tcam_key_valids_2);
  }

  tbl_data->isa_and_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISA_AND_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  tbl_data->isa_or_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISA_OR_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  tbl_data->isa_lookup_enable   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISA_LOOKUP_ENABLEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

  tbl_data->isb_and_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISB_AND_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);

  tbl_data->isb_or_mask   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISB_OR_MASKf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

  tbl_data->isb_lookup_enable   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  ISB_LOOKUP_ENABLEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

  tbl_data->tcam_db_profile   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  TCAM_DB_PROFILEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

  if (!SOC_IS_ARADPLUS(unit)) {
      tbl_data->termination_0_pd_bitmap   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  TERMINATION_0_PD_BITMAPf);
      SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

      tbl_data->termination_1_pd_bitmap   = soc_mem_field32_get(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  TERMINATION_1_PD_BITMAPf);
      SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);
  }
  else {
      /* 
       * In ARAD+: 
       * - Skip looking at the 2 LSBs of vlan_translation_0_pd_bitmap: 
       * it seems unused in arad_pp_isem_access.c in any program. Return an error if set in Arad+
       * - Translation table from enable->strength with assumption the order in same strength 
       * is identical to Arad-A0/B0: 
       *   for TCAM low-priority: 0<->0 and 1<-> strength 1
       *   for ISEM-A/B: 0<->0 and 1<->strength 2
       *   for TCAM high-priority: 0<->0 and 1<->strength 3
       */
      soc_field_t 
          strength_fields[2][ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {
              {TERMINATION_0_PD_TCAM_STRENGTHf, TERMINATION_0_PD_TCAM_STRENGTHf, TERMINATION_0_PD_ISA_STRENGTHf, TERMINATION_0_PD_ISB_STRENGTHf},
              {TERMINATION_1_PD_TCAM_STRENGTHf, TERMINATION_1_PD_TCAM_STRENGTHf, TERMINATION_1_PD_ISA_STRENGTHf, TERMINATION_1_PD_ISB_STRENGTHf}
          };

      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe(
                unit,
                FALSE, /* is_for_flp */
                data_tbl_1,
                IHP_VTT_2ND_LOOKUP_PROGRAM_1m, 
                strength_fields[0],
                &(tbl_data->termination_0_pd_bitmap)
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_get_unsafe(
                unit,
                FALSE, /* is_for_flp */
                data_tbl_1,
                IHP_VTT_2ND_LOOKUP_PROGRAM_1m, 
                strength_fields[1],
                &(tbl_data->termination_1_pd_bitmap)
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);
  }

  tbl_data->processing_profile   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              PROCESSING_PROFILEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 68, exit);

  tbl_data->processing_code   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              PROCESSING_CODEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

  tbl_data->result_to_use_0   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              RESULT_TO_USE_0f );
  SOC_SAND_CHECK_FUNC_RESULT(res, 72, exit);

  tbl_data->result_to_use_1   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              RESULT_TO_USE_1f );
  SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);

  tbl_data->result_to_use_2   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              RESULT_TO_USE_2f );
  SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);

 tbl_data->second_stage_parsing   = soc_mem_field32_get(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              SECOND_STAGE_PARSINGf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 78, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA  *tbl_data
  )
{
  uint32
      isa_key_valids_1,
      isb_key_valids_1,
      tcam_key_valids_1,
      isa_key_valids_2,
      isb_key_valids_2,
      tcam_key_valids_2,
    res = SOC_SAND_OK;
  uint32 dbal;

  uint32
    data_tbl_0[ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE],
    data_tbl_1[ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_SET_UNSAFE);

  dbal = tbl_data->dbal;
  ARAD_CLEAR(data_tbl_0, uint32, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0_TBL_ENTRY_SIZE);
  ARAD_CLEAR(data_tbl_1, uint32, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1_TBL_ENTRY_SIZE);

  /* 
   * ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION0
   */
  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          KEY_16B_INST_0f,
          tbl_data->key_16b_inst0 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          KEY_16B_INST_1f,
          tbl_data->key_16b_inst1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);

  if(SOC_IS_JERICHO(unit) && dbal)
  {
      soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
              data_tbl_0,
              KEY_16B_INST_2f,
              tbl_data->key_16b_inst2 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);

        soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
              data_tbl_0,
              KEY_16B_INST_3f,
              tbl_data->key_16b_inst3 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
  }

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          KEY_32B_INST_0f,
          tbl_data->key_32b_inst0 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          KEY_32B_INST_1f,
          tbl_data->key_32b_inst1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  if (SOC_IS_JERICHO(unit) && !dbal) {
      /* Temp WA to work on Arad microcode */
      isa_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isa_key_valids_1);
      isb_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isb_key_valids_1);
      tcam_key_valids_1 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->tcam_key_valids_1);
  } else {
      isa_key_valids_1 = tbl_data->isa_key_valids_1;
      isb_key_valids_1 = tbl_data->isb_key_valids_1;
      tcam_key_valids_1 = tbl_data->tcam_key_valids_1;
  }

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          ISA_KEY_VALIDSf,
          isa_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          ISB_KEY_VALIDSf,
          isb_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          TCAM_KEY_VALIDSf,
          tcam_key_valids_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          KEY_PROGRAM_VARIABLEf,
          tbl_data->key_program_variable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          ISA_KEY_INITIAL_FROM_VTf,
          tbl_data->isa_key_initial_from_vt );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          ISB_KEY_INITIAL_FROM_VTf,
          tbl_data->isb_key_initial_from_vt );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          data_tbl_0,
          TCAM_KEY_INITIAL_FROM_VTf,
          tbl_data->tcam_key_initial_from_vt );
  SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data_tbl_0          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 55, exit);

  /* 
   * ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION1
   */
  if (SOC_IS_JERICHO(unit) && dbal)
  {
       soc_mem_field32_set(
                unit,
                IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                data_tbl_1,
                KEY_16B_INST_4f,
                tbl_data->key_16b_inst4 );
        SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

        soc_mem_field32_set(
                 unit,
                 IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                 data_tbl_1,
                 KEY_16B_INST_5f,
                 tbl_data->key_16b_inst5 );
         SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

         soc_mem_field32_set(
                  unit,
                  IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                  data_tbl_1,
                  KEY_16B_INST_6f,
                  tbl_data->key_16b_inst6 );
          SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);

          soc_mem_field32_set(
                   unit,
                   IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
                   data_tbl_1,
                   KEY_16B_INST_7f,
                   tbl_data->key_16b_inst7 );
           SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

  }
  else
  {
      soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              SOC_IS_JERICHO(unit)? KEY_16B_INST_4f: KEY_16B_INST_2f,
              tbl_data->key_16b_inst2 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

        soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              SOC_IS_JERICHO(unit)? KEY_16B_INST_5f: KEY_16B_INST_3f,
              tbl_data->key_16b_inst3 );
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

  }

    soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          KEY_32B_INST_2f,
          tbl_data->key_32b_inst2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

    soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          KEY_32B_INST_3f,
          tbl_data->key_32b_inst3 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
  

  if (SOC_IS_JERICHO(unit) && !dbal) {
      /* Temp WA to work on Arad microcode */
      isa_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isa_key_valids_2);
      isb_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->isb_key_valids_2);
      tcam_key_valids_2 = arad_pp_ihp_vtt_key_construction_key_valids_1_jericho_wa_build(tbl_data->tcam_key_valids_2);
  } else {
      isa_key_valids_2 = tbl_data->isa_key_valids_2;
      isb_key_valids_2 = tbl_data->isb_key_valids_2;
      tcam_key_valids_2 = tbl_data->tcam_key_valids_2;
  }

    soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISA_KEY_VALIDSf,
          isa_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISB_KEY_VALIDSf,
          isb_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          TCAM_KEY_VALIDSf,
          tcam_key_valids_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISA_AND_MASKf,
          tbl_data->isa_and_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISA_OR_MASKf,
          tbl_data->isa_or_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISA_LOOKUP_ENABLEf,
          tbl_data->isa_lookup_enable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISB_AND_MASKf,
          tbl_data->isb_and_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISB_OR_MASKf,
          tbl_data->isb_or_mask );
  SOC_SAND_CHECK_FUNC_RESULT(res, 48, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          ISB_LOOKUP_ENABLEf,
          tbl_data->isb_lookup_enable );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          TCAM_DB_PROFILEf,
          tbl_data->tcam_db_profile );
  SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);

  if (!SOC_IS_ARADPLUS(unit)) {
      soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              TERMINATION_0_PD_BITMAPf,
              tbl_data->termination_0_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);

      soc_mem_field32_set(
              unit,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
              data_tbl_1,
              TERMINATION_1_PD_BITMAPf,
              tbl_data->termination_1_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
  }
  else {
      /* 
       * In ARAD+: 
       * - Skip looking at the 2 LSBs of vlan_translation_0_pd_bitmap: 
       * it seems unused in arad_pp_isem_access.c in any program. Return an error if set in Arad+
       * - Translation table from enable->strength with assumption the order in same strength 
       * is identical to Arad-A0/B0: 
       *   for TCAM low-priority: 0<->0 and 1<-> strength 1
       *   for ISEM-A/B: 0<->0 and 1<->strength 2
       *   for TCAM high-priority: 0<->0 and 1<->strength 3
       */
      soc_field_t 
          strength_fields[2][ARAD_PP_VTT_PD_BITMAP_NOF_FIELDS] = {
              {TERMINATION_0_PD_TCAM_STRENGTHf, TERMINATION_0_PD_TCAM_STRENGTHf, TERMINATION_0_PD_ISA_STRENGTHf, TERMINATION_0_PD_ISB_STRENGTHf},
              {TERMINATION_1_PD_TCAM_STRENGTHf, TERMINATION_1_PD_TCAM_STRENGTHf, TERMINATION_1_PD_ISA_STRENGTHf, TERMINATION_1_PD_ISB_STRENGTHf}
          };

      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe(
              unit,
              FALSE, /* is_for_flp */
              data_tbl_1,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m, 
              strength_fields[0],
              tbl_data->termination_0_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 53, exit);

      res = arad_pp_ihp_vtt_flp_key_construction_pd_bitmap_set_unsafe(
              unit,
              FALSE, /* is_for_flp */
              data_tbl_1,
              IHP_VTT_2ND_LOOKUP_PROGRAM_1m, 
              strength_fields[1],
              tbl_data->termination_1_pd_bitmap );
      SOC_SAND_CHECK_FUNC_RESULT(res, 55, exit);
  }

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          PROCESSING_PROFILEf,
          tbl_data->processing_profile );
  SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          PROCESSING_CODEf,
          tbl_data->processing_code );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          RESULT_TO_USE_0f,
          tbl_data->result_to_use_0 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          RESULT_TO_USE_1f,
          tbl_data->result_to_use_1 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          RESULT_TO_USE_2f,
          tbl_data->result_to_use_2 );
  SOC_SAND_CHECK_FUNC_RESULT(res, 66, exit);

  soc_mem_field32_set(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          data_tbl_1,
          SECOND_STAGE_PARSINGf,
          tbl_data->second_stage_parsing );
  SOC_SAND_CHECK_FUNC_RESULT(res, 68, exit);

  res = soc_mem_write(
          unit,
          IHP_VTT_2ND_LOOKUP_PROGRAM_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data_tbl_1          
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 70, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_fec_entry_accessed_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_DATA, 1);


  res = READ_IHB_FEC_ENTRY_ACCESSEDm(
          unit,
          ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
          IHB_BLOCK(unit, core_id),
          ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fec_entry_accessed = soc_mem_field32_get(
          unit,
          IHB_FEC_ENTRY_ACCESSEDm,
          data,
          FEC_ENTRY_ACCESSEDf            
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_entry_accessed_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_fec_entry_accessed_tbl_set_unsafe(
    SOC_SAND_IN  int                                      unit,
    SOC_SAND_IN  int                                      core_id,
    SOC_SAND_IN  uint32                                   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_ENTRY_ACCESSED_TBL_ENTRY_SIZE);

  /* In Jericho this table is dynamic, access is granted on init, see soc_jer_ihb_tbls_init */
  soc_mem_field32_set(
          unit,
          IHB_FEC_ENTRY_ACCESSEDm,
          data,
          FEC_ENTRY_ACCESSEDf,
          tbl_data->fec_entry_accessed );

  res = WRITE_IHB_FEC_ENTRY_ACCESSEDm(
          unit,
          ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
          IHB_BLOCK(unit, core_id),
          ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
          data );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_entry_accessed_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_path_select_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PATH_SELECT_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    fec_path_select_mem = ARAD_PP_FEC_PATH_SELECT_MEM(unit);
  uint32
    data[ARAD_PP_IHB_PATH_SELECT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PATH_SELECT_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PATH_SELECT_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_PATH_SELECT_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          fec_path_select_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

   tbl_data->path_select[0]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_0f            );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

   tbl_data->path_select[1]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_1f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);

   tbl_data->path_select[2]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_2f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);

   tbl_data->path_select[3]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_3f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 43, exit);

  tbl_data->path_select[4]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_4f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);

          tbl_data->path_select[5]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_5f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 45, exit);

  tbl_data->path_select[6]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_6f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);

   tbl_data->path_select[7]   = soc_mem_field32_get(
                  unit,
                  fec_path_select_mem,
                  data,
                  PATH_SELECT_7f            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 47, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_path_select_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_path_select_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PATH_SELECT_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    fec_path_select_mem = ARAD_PP_FEC_PATH_SELECT_MEM(unit);
  uint32
    data[ARAD_PP_IHB_PATH_SELECT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PATH_SELECT_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PATH_SELECT_TBL_ENTRY_SIZE);
        soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_0f,
          tbl_data->path_select[0] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_1f,
          tbl_data->path_select[1] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_2f,
          tbl_data->path_select[2] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_3f,
          tbl_data->path_select[3] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_4f,
          tbl_data->path_select[4] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_5f,
          tbl_data->path_select[5] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_6f,
          tbl_data->path_select[6] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);

            soc_mem_field32_set(
          unit,
          fec_path_select_mem,
          data,
          PATH_SELECT_7f,
          tbl_data->path_select[7] );
  SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);

  /* WA for Jericho+: indirect_wr_mask register masking mechanism is opposite for IHB_FEC_PATH_SELECT table */  
  if (SOC_IS_JERICHO_PLUS_A0(unit)) {
      res = WRITE_IHB_INDIRECT_WR_MASKr(unit,SOC_CORE_ALL, 0);
      SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);
  }
  res = soc_mem_write(
          unit,
          fec_path_select_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 39, exit);
  if (SOC_IS_JERICHO_PLUS_A0(unit)) {
      res = WRITE_IHB_INDIRECT_WR_MASKr(unit,SOC_CORE_ALL, 0xffffffff);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
  }  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_path_select_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_rif_info_to_rif_profile_convert(
    SOC_SAND_IN  int    unit,    
    SOC_SAND_IN  uint32 uc_rpf_enable,
    SOC_SAND_IN  uint32 enable_default_routing,
    SOC_SAND_IN  uint32 custom_rif_profile_bit,
    SOC_SAND_IN  uint32 intf_class,    
    SOC_SAND_IN  uint32 routing_enablers_bm_id,
    SOC_SAND_OUT uint32 *rif_profile
  )
{
    (*rif_profile) |= routing_enablers_bm_id<<(SOC_DPP_CONFIG(unit)->l3.bit_offset_of_the_routing_enablers_profile);    
    (*rif_profile) |= uc_rpf_enable<<ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_URPF_ENABLE_BIT;
    (*rif_profile) |= enable_default_routing<<ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_DEFAULT_ROUTING_BIT;
    (*rif_profile) |= custom_rif_profile_bit<<ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_CUSTOM_RIF_PROFILE_BIT;
    (*rif_profile) |= intf_class;    
    return 0;
}
uint32
  arad_pp_rif_profile_to_rif_info_convert(
    SOC_SAND_IN  int    unit,
    SOC_SAND_IN  uint32 rif_profile,
    SOC_SAND_OUT uint8  *uc_rpf_enable,
    SOC_SAND_OUT uint8  *enable_default_routing,
    SOC_SAND_OUT uint8  *custom_rif_profile_bit,
    SOC_SAND_OUT uint8  *intf_class,
    SOC_SAND_OUT uint8  *routing_enablers_bm_id,
    SOC_SAND_OUT uint32 *routing_enablers_bm,
    SOC_SAND_IN  uint8  is_routing_enablers_needed
  )
{
    uint32  rif_profile_mask = 0x3f; /* IN-RIF profile is 6 bits*/
    
    SOCDNX_INIT_FUNC_DEFS;
    (*uc_rpf_enable) = rif_profile>>ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_URPF_ENABLE_BIT & 1;
    (*enable_default_routing) = rif_profile>>ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_DEFAULT_ROUTING_BIT & 1;
    (*custom_rif_profile_bit) = 0;
     /*If case the ipmc_l3mcastl2_mode SOC property enabled the 3rd bit is dedicated to IPV4 L2 program selection,
      * otherwise the 3rd bit is part of the 4 bits enablers. same goes to IPv4 DC*/
    if(SOC_DPP_CONFIG(unit)->pp.ipmc_l3mcastl2_mode == 1){
        (*custom_rif_profile_bit) = (rif_profile>>ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_CUSTOM_RIF_PROFILE_BIT & 1);
    }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)	
	if(ARAD_KBP_ENABLE_IPV4_DC){
        (*custom_rif_profile_bit) = (rif_profile>>ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_CUSTOM_RIF_PROFILE_BIT & 1);
    }
#endif
    if (is_routing_enablers_needed) {
        *routing_enablers_bm_id = ((rif_profile & (rif_profile_mask >> SOC_DPP_CONFIG(unit)->l3.nof_dedicated_in_rif_profile_bits)) >> SOC_DPP_CONFIG(unit)->l3.bit_offset_of_the_routing_enablers_profile);
        (*intf_class) = rif_profile & (rif_profile_mask >> (SOC_DPP_NOF_IN_RIF_PROFILE_BITS - SOC_DPP_CONFIG(unit)->l3.bit_offset_of_the_routing_enablers_profile));
        SOCDNX_IF_ERR_EXIT(_bcm_dpp_am_template_l3_rif_mac_termination_combination_data_get(unit,*routing_enablers_bm_id,routing_enablers_bm));
    }

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
  arad_pp_ihb_flp_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FLP_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHP_FLP_PROGRAM_SELECTION_CAM_NOF_LONGS)];
  soc_mem_t
    mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_FLP_PROGRAM_SELECTION_CAM_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FLP_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  if(SOC_IS_JERICHO(unit)) {
    mem = IHP_FLP_PROGRAM_SELECTION_CAMm;
  } else {
    mem = IHB_FLP_PROGRAM_SELECTION_CAMm;
  }

  res = soc_mem_read(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, mem, data, PARSER_LEAF_CONTEXTf);
  tbl_data->port_profile = soc_mem_field32_get(unit, mem, data, PORT_PROFILEf);
  tbl_data->ptc_profile = soc_mem_field32_get(unit, mem, data, PTC_PROFILEf);
  tbl_data->packet_format_code = soc_mem_field32_get(unit, mem, data, PACKET_FORMAT_CODEf);
  tbl_data->forwarding_header_qualifier = soc_mem_field32_get(unit, mem, data, FORWARDING_HEADER_QUALIFIERf);
  tbl_data->forwarding_code = soc_mem_field32_get(unit, mem, data, FORWARDING_CODEf);
  tbl_data->forwarding_offset_index = soc_mem_field32_get(unit, mem, data, FORWARDING_OFFSET_INDEXf);
  tbl_data->trill_mc = soc_mem_field32_get(unit, mem, data, TRILL_MCf);
  tbl_data->packet_is_compatible_mc = soc_mem_field32_get(unit, mem, data, PACKET_IS_COMPATIBLE_MCf);
  tbl_data->ll_is_arp = soc_mem_field32_get(unit, mem, data, LL_IS_ARPf);
  tbl_data->elk_status = soc_mem_field32_get(unit, mem, data, ELK_STATUSf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem, data, COS_PROFILEf);
  tbl_data->service_type = soc_mem_field32_get(unit, mem, data, SERVICE_TYPEf);
  tbl_data->vt_processing_profile = soc_mem_field32_get(unit, mem, data, VT_PROCESSING_PROFILEf);
  tbl_data->vt_lookup_0_found = soc_mem_field32_get(unit, mem, data, VT_LOOKUP_0_FOUNDf);
  tbl_data->vt_lookup_1_found = soc_mem_field32_get(unit, mem, data, VT_LOOKUP_1_FOUNDf);
  tbl_data->tt_processing_profile = soc_mem_field32_get(unit, mem, data, TT_PROCESSING_PROFILEf);
  tbl_data->tt_lookup_0_found = soc_mem_field32_get(unit, mem, data, TT_LOOKUP_0_FOUNDf);
  tbl_data->tt_lookup_1_found = soc_mem_field32_get(unit, mem, data, TT_LOOKUP_1_FOUNDf);
  tbl_data->parser_leaf_context_mask = soc_mem_field32_get(unit, mem, data, PARSER_LEAF_CONTEXT_MASKf);
  tbl_data->port_profile_mask = soc_mem_field32_get(unit, mem, data, PORT_PROFILE_MASKf);
  tbl_data->ptc_profile_mask = soc_mem_field32_get(unit, mem, data, PTC_PROFILE_MASKf);
  tbl_data->packet_format_code_mask = soc_mem_field32_get(unit, mem, data, PACKET_FORMAT_CODE_MASKf);
  tbl_data->forwarding_header_qualifier_mask = soc_mem_field32_get(unit, mem, data, FORWARDING_HEADER_QUALIFIER_MASKf);
  tbl_data->forwarding_code_mask = soc_mem_field32_get(unit, mem, data, FORWARDING_CODE_MASKf);
  tbl_data->forwarding_offset_index_mask = soc_mem_field32_get(unit, mem, data, FORWARDING_OFFSET_INDEX_MASKf);
  tbl_data->trill_mc_mask = soc_mem_field32_get(unit, mem, data, TRILL_MC_MASKf);
  tbl_data->packet_is_compatible_mc_mask = soc_mem_field32_get(unit, mem, data, PACKET_IS_COMPATIBLE_MC_MASKf);
  tbl_data->ll_is_arp_mask = soc_mem_field32_get(unit, mem, data, LL_IS_ARP_MASKf);
  tbl_data->elk_status_mask = soc_mem_field32_get(unit, mem, data, ELK_STATUS_MASKf);
  tbl_data->cos_profile_mask = soc_mem_field32_get(unit, mem, data, COS_PROFILE_MASKf);
  tbl_data->service_type_mask = soc_mem_field32_get(unit, mem, data, SERVICE_TYPE_MASKf);
  tbl_data->vt_processing_profile_mask = soc_mem_field32_get(unit, mem, data, VT_PROCESSING_PROFILE_MASKf);
  tbl_data->vt_lookup_0_found_mask = soc_mem_field32_get(unit, mem, data, VT_LOOKUP_0_FOUND_MASKf);
  tbl_data->vt_lookup_1_found_mask = soc_mem_field32_get(unit, mem, data, VT_LOOKUP_1_FOUND_MASKf);
  tbl_data->tt_processing_profile_mask = soc_mem_field32_get(unit, mem, data, TT_PROCESSING_PROFILE_MASKf);
  tbl_data->tt_lookup_0_found_mask = soc_mem_field32_get(unit, mem, data, TT_LOOKUP_0_FOUND_MASKf);
  tbl_data->tt_lookup_1_found_mask = soc_mem_field32_get(unit, mem, data, TT_LOOKUP_1_FOUND_MASKf);
  tbl_data->valid = soc_mem_field32_get(unit, mem, data, VALIDf);
  if(!SOC_IS_QAX(unit))
  {
      tbl_data->program = soc_mem_field32_get(unit, mem, data, PROGRAMf);
  }
  /* In-RIF profile */
  if(SOC_IS_JERICHO(unit)) {
    uint32 in_rif_profile, in_rif_profile_mask;
    uint8 intf_class;
    in_rif_profile = soc_mem_field32_get(unit, mem, data, IN_RIF_PROFILEf);
    in_rif_profile_mask = soc_mem_field32_get(unit, mem, data, IN_RIF_PROFILE_MASKf);
    arad_pp_rif_profile_to_rif_info_convert(unit, in_rif_profile,
                                             &(tbl_data->in_rif_uc_rpf_enable),
                                             &(tbl_data->l_3_vpn_default_routing),
                                             &(tbl_data->custom_rif_profile_bit),
                                             &(intf_class),
                                             NULL,
                                             NULL,
                                             0 );

    tbl_data->l_3_vpn_default_routing_mask = (SHR_BITGET(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_DEFAULT_ROUTING_BIT) != 0);
    tbl_data->in_rif_uc_rpf_enable_mask    = (SHR_BITGET(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_URPF_ENABLE_BIT) != 0);
    tbl_data->custom_rif_profile_bit_mask  = (SHR_BITGET(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_CUSTOM_RIF_PROFILE_BIT) != 0);
  } else {
    tbl_data->l_3_vpn_default_routing = soc_mem_field32_get(unit, mem, data, L_3_VPN_DEFAULT_ROUTINGf);
    tbl_data->in_rif_uc_rpf_enable = soc_mem_field32_get(unit, mem, data, IN_RIF_UC_RPF_ENABLEf);
    tbl_data->l_3_vpn_default_routing_mask = soc_mem_field32_get(unit, mem, data, L_3_VPN_DEFAULT_ROUTING_MASKf);
    tbl_data->in_rif_uc_rpf_enable_mask = soc_mem_field32_get(unit, mem, data, IN_RIF_UC_RPF_ENABLE_MASKf);
    /* The ipmc bridge v4mc feature is supported to Jericho and above */
    tbl_data->custom_rif_profile_bit      = 0;
    tbl_data->custom_rif_profile_bit_mask = 1;
  }

  /* New fields */
  if (SOC_IS_JERICHO(unit)) {
    tbl_data->forwarding_offset_index_ext = soc_mem_field32_get(unit, mem, data, FORWARDING_OFFSET_INDEX_EXTf);
    tbl_data->cpu_trap_code = soc_mem_field32_get(unit, mem, data, CPU_TRAP_CODEf);
    tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem, data, IN_LIF_PROFILEf);
    tbl_data->llvp_incoming_tag_structure = soc_mem_field32_get(unit, mem, data, LLVP_INCOMING_TAG_STRUCTUREf);
    tbl_data->forwarding_plus_1_header_qualifier = soc_mem_field32_get(unit, mem, data, FORWARDING_PLUS_1_HEADER_QUALIFIERf);
    tbl_data->tunnel_termination_code = soc_mem_field32_get(unit, mem, data, TUNNEL_TERMINATION_CODEf);
    tbl_data->qualifier_0 = soc_mem_field32_get(unit, mem, data, QUALIFIER_0f);
    tbl_data->in_lif_data_index = soc_mem_field32_get(unit, mem, data, IN_LIF_DATA_INDEXf);
    tbl_data->in_lif_data_msb = soc_mem_field32_get(unit, mem, data, IN_LIF_DATA_MSBf);
    tbl_data->forwarding_offset_index_ext_mask = soc_mem_field32_get(unit, mem, data, FORWARDING_OFFSET_INDEX_EXT_MASKf);
    tbl_data->cpu_trap_code_mask = soc_mem_field32_get(unit, mem, data, CPU_TRAP_CODE_MASKf);
    tbl_data->in_lif_profile_mask = soc_mem_field32_get(unit, mem, data, IN_LIF_PROFILE_MASKf);
    tbl_data->llvp_incoming_tag_structure_mask = soc_mem_field32_get(unit, mem, data, LLVP_INCOMING_TAG_STRUCTURE_MASKf);
    tbl_data->forwarding_plus_1_header_qualifier_mask = soc_mem_field32_get(unit, mem, data, FORWARDING_PLUS_1_HEADER_QUALIFIER_MASKf);
    tbl_data->tunnel_termination_code_mask = soc_mem_field32_get(unit, mem, data, TUNNEL_TERMINATION_CODE_MASKf);
    tbl_data->qualifier_0_mask = soc_mem_field32_get(unit, mem, data, QUALIFIER_0_MASKf);
    tbl_data->in_lif_data_index_mask = soc_mem_field32_get(unit, mem, data, IN_LIF_DATA_INDEX_MASKf);
    tbl_data->in_lif_data_msb_mask = soc_mem_field32_get(unit, mem, data, IN_LIF_DATA_MSB_MASKf);
  }

    if (SOC_IS_QAX(unit)) {
        if (SOC_IS_QUX(unit)) {
            tbl_data->pemContextMask = soc_mem_field32_get(unit, mem, data, PEM_CONTEXT_MASKf);
        } else {
            tbl_data->pemContextMask = soc_mem_field32_get(unit, mem, data, ITEM_219_223f);
        }
        tbl_data->program = soc_mem_field32_get(unit, mem, data, PROGRAM_DATAf);
    }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FLP_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHP_FLP_PROGRAM_SELECTION_CAM_NOF_LONGS)];
  soc_mem_t
    mem;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_FLP_PROGRAM_SELECTION_CAM_NOF_LONGS));

  if(SOC_IS_JERICHO(unit)) {
    mem = IHP_FLP_PROGRAM_SELECTION_CAMm;
  } else {
    mem = IHB_FLP_PROGRAM_SELECTION_CAMm;
  }

  soc_mem_field32_set(unit, mem, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);
  soc_mem_field32_set(unit, mem, data, PORT_PROFILEf, tbl_data->port_profile);
  soc_mem_field32_set(unit, mem, data, PTC_PROFILEf, tbl_data->ptc_profile);
  soc_mem_field32_set(unit, mem, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, mem, data, FORWARDING_HEADER_QUALIFIERf, tbl_data->forwarding_header_qualifier);
  soc_mem_field32_set(unit, mem, data, FORWARDING_CODEf, tbl_data->forwarding_code);
  soc_mem_field32_set(unit, mem, data, FORWARDING_OFFSET_INDEXf, tbl_data->forwarding_offset_index);
  soc_mem_field32_set(unit, mem, data, TRILL_MCf, tbl_data->trill_mc);
  soc_mem_field32_set(unit, mem, data, PACKET_IS_COMPATIBLE_MCf, tbl_data->packet_is_compatible_mc);
  soc_mem_field32_set(unit, mem, data, LL_IS_ARPf, tbl_data->ll_is_arp);
  soc_mem_field32_set(unit, mem, data, ELK_STATUSf, tbl_data->elk_status);
  soc_mem_field32_set(unit, mem, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem, data, SERVICE_TYPEf, tbl_data->service_type);
  soc_mem_field32_set(unit, mem, data, VT_PROCESSING_PROFILEf, tbl_data->vt_processing_profile);
  soc_mem_field32_set(unit, mem, data, VT_LOOKUP_0_FOUNDf, tbl_data->vt_lookup_0_found);
  soc_mem_field32_set(unit, mem, data, VT_LOOKUP_1_FOUNDf, tbl_data->vt_lookup_1_found);
  soc_mem_field32_set(unit, mem, data, TT_PROCESSING_PROFILEf, tbl_data->tt_processing_profile);
  soc_mem_field32_set(unit, mem, data, TT_LOOKUP_0_FOUNDf, tbl_data->tt_lookup_0_found);
  soc_mem_field32_set(unit, mem, data, TT_LOOKUP_1_FOUNDf, tbl_data->tt_lookup_1_found);
  soc_mem_field32_set(unit, mem, data, PARSER_LEAF_CONTEXT_MASKf, tbl_data->parser_leaf_context_mask);
  soc_mem_field32_set(unit, mem, data, PORT_PROFILE_MASKf, tbl_data->port_profile_mask);
  soc_mem_field32_set(unit, mem, data, PTC_PROFILE_MASKf, tbl_data->ptc_profile_mask);
  soc_mem_field32_set(unit, mem, data, PACKET_FORMAT_CODE_MASKf, tbl_data->packet_format_code_mask);
  soc_mem_field32_set(unit, mem, data, FORWARDING_HEADER_QUALIFIER_MASKf, tbl_data->forwarding_header_qualifier_mask);
  soc_mem_field32_set(unit, mem, data, FORWARDING_CODE_MASKf, tbl_data->forwarding_code_mask);
  soc_mem_field32_set(unit, mem, data, FORWARDING_OFFSET_INDEX_MASKf, tbl_data->forwarding_offset_index_mask);
  soc_mem_field32_set(unit, mem, data, TRILL_MC_MASKf, tbl_data->trill_mc_mask);
  soc_mem_field32_set(unit, mem, data, PACKET_IS_COMPATIBLE_MC_MASKf, tbl_data->packet_is_compatible_mc_mask);
  soc_mem_field32_set(unit, mem, data, LL_IS_ARP_MASKf, tbl_data->ll_is_arp_mask);
  soc_mem_field32_set(unit, mem, data, ELK_STATUS_MASKf, tbl_data->elk_status_mask);
  soc_mem_field32_set(unit, mem, data, COS_PROFILE_MASKf, tbl_data->cos_profile_mask);
  soc_mem_field32_set(unit, mem, data, SERVICE_TYPE_MASKf, tbl_data->service_type_mask);
  soc_mem_field32_set(unit, mem, data, VT_PROCESSING_PROFILE_MASKf, tbl_data->vt_processing_profile_mask);
  soc_mem_field32_set(unit, mem, data, VT_LOOKUP_0_FOUND_MASKf, tbl_data->vt_lookup_0_found_mask);
  soc_mem_field32_set(unit, mem, data, VT_LOOKUP_1_FOUND_MASKf, tbl_data->vt_lookup_1_found_mask);
  soc_mem_field32_set(unit, mem, data, TT_PROCESSING_PROFILE_MASKf, tbl_data->tt_processing_profile_mask);
  soc_mem_field32_set(unit, mem, data, TT_LOOKUP_0_FOUND_MASKf, tbl_data->tt_lookup_0_found_mask);
  soc_mem_field32_set(unit, mem, data, TT_LOOKUP_1_FOUND_MASKf, tbl_data->tt_lookup_1_found_mask);
  soc_mem_field32_set(unit, mem, data, VALIDf, tbl_data->valid);
  if(!SOC_IS_JERICHO_PLUS(unit))
  {
      soc_mem_field32_set(unit, mem, data, PROGRAMf, tbl_data->program);
  }

  /* In-RIF profile */
  if(SOC_IS_JERICHO(unit)) {
    uint32 in_rif_profile = 0, in_rif_profile_mask = 0;
    /* Set the mask to -1 by default */
    SHR_BITSET_RANGE(&in_rif_profile_mask, 0, soc_mem_field_length(unit, mem, IN_RIF_PROFILE_MASKf));
    /* Copy the relevant bits */
    arad_pp_rif_info_to_rif_profile_convert(unit,tbl_data->in_rif_uc_rpf_enable,
                                            tbl_data->l_3_vpn_default_routing,
                                            tbl_data->custom_rif_profile_bit,
                                            0/*intf_class*/,
                                            0/*routing_enablers_bm_id*/,
                                            &(in_rif_profile));     
    
    SHR_BITCOPY_RANGE(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_DEFAULT_ROUTING_BIT, &tbl_data->l_3_vpn_default_routing_mask, 0, 1);
    SHR_BITCOPY_RANGE(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_URPF_ENABLE_BIT, &tbl_data->in_rif_uc_rpf_enable_mask, 0, 1);    
    SHR_BITCOPY_RANGE(&in_rif_profile_mask, ARAD_PP_RIF_RIF_PROFILE_STRUCTURE_CUSTOM_RIF_PROFILE_BIT, &tbl_data->custom_rif_profile_bit_mask, 0, 1);
    /* Set the HW */
    soc_mem_field32_set(unit, mem, data, IN_RIF_PROFILEf, in_rif_profile);
    soc_mem_field32_set(unit, mem, data, IN_RIF_PROFILE_MASKf, in_rif_profile_mask);
  } else {
    soc_mem_field32_set(unit, mem, data, L_3_VPN_DEFAULT_ROUTINGf, tbl_data->l_3_vpn_default_routing);
    soc_mem_field32_set(unit, mem, data, IN_RIF_UC_RPF_ENABLEf, tbl_data->in_rif_uc_rpf_enable);
    soc_mem_field32_set(unit, mem, data, L_3_VPN_DEFAULT_ROUTING_MASKf, tbl_data->l_3_vpn_default_routing_mask);
    soc_mem_field32_set(unit, mem, data, IN_RIF_UC_RPF_ENABLE_MASKf, tbl_data->in_rif_uc_rpf_enable_mask);
  }

  /* New fields */
  if (SOC_IS_JERICHO(unit)) {
    soc_mem_field32_set(unit, mem, data, FORWARDING_OFFSET_INDEX_EXTf, tbl_data->forwarding_offset_index_ext);
    soc_mem_field32_set(unit, mem, data, CPU_TRAP_CODEf, tbl_data->cpu_trap_code);
    soc_mem_field32_set(unit, mem, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
    soc_mem_field32_set(unit, mem, data, LLVP_INCOMING_TAG_STRUCTUREf, tbl_data->llvp_incoming_tag_structure);
    soc_mem_field32_set(unit, mem, data, FORWARDING_PLUS_1_HEADER_QUALIFIERf, tbl_data->forwarding_plus_1_header_qualifier);
    soc_mem_field32_set(unit, mem, data, TUNNEL_TERMINATION_CODEf, tbl_data->tunnel_termination_code);
    soc_mem_field32_set(unit, mem, data, QUALIFIER_0f, tbl_data->qualifier_0);
    soc_mem_field32_set(unit, mem, data, IN_LIF_DATA_INDEXf, tbl_data->in_lif_data_index);
    soc_mem_field32_set(unit, mem, data, IN_LIF_DATA_MSBf, tbl_data->in_lif_data_msb);
    soc_mem_field32_set(unit, mem, data, FORWARDING_OFFSET_INDEX_EXT_MASKf, tbl_data->forwarding_offset_index_ext_mask);
    soc_mem_field32_set(unit, mem, data, CPU_TRAP_CODE_MASKf, tbl_data->cpu_trap_code_mask);
    soc_mem_field32_set(unit, mem, data, IN_LIF_PROFILE_MASKf, tbl_data->in_lif_profile_mask);
    soc_mem_field32_set(unit, mem, data, LLVP_INCOMING_TAG_STRUCTURE_MASKf, tbl_data->llvp_incoming_tag_structure_mask);
    soc_mem_field32_set(unit, mem, data, FORWARDING_PLUS_1_HEADER_QUALIFIER_MASKf, tbl_data->forwarding_plus_1_header_qualifier_mask);
    soc_mem_field32_set(unit, mem, data, TUNNEL_TERMINATION_CODE_MASKf, tbl_data->tunnel_termination_code_mask);
    soc_mem_field32_set(unit, mem, data, QUALIFIER_0_MASKf, tbl_data->qualifier_0_mask);
    soc_mem_field32_set(unit, mem, data, IN_LIF_DATA_INDEX_MASKf, tbl_data->in_lif_data_index_mask);
    soc_mem_field32_set(unit, mem, data, IN_LIF_DATA_MSB_MASKf, tbl_data->in_lif_data_msb_mask);
  }

    if (SOC_IS_QAX(unit)) {
        if (SOC_IS_QUX(unit)) {
            soc_mem_field32_set(unit, mem, data, PEM_CONTEXT_MASKf, tbl_data->pemContextMask);
        } else {
            soc_mem_field32_set(unit, mem, data, ITEM_219_223f, 0x1f);
        }
    }  
    if (SOC_IS_JERICHO_PLUS(unit)) {
        soc_mem_field32_set(unit, mem, data, PROGRAM_DATAf, tbl_data->program);
    }

    res = soc_mem_write(
          unit,
          mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_process_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FLP_PROCESS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FLP_PROCESS_TBL_ENTRY_SIZE];
  soc_field_t
      strength_fld;
  soc_mem_t
    flp_process_mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_PROCESS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_PROCESS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FLP_PROCESS_TBL_DATA, 1);

  if (SOC_IS_JERICHO(unit)) {
      flp_process_mem = IHP_FLP_PROCESSm;
  } else {
      flp_process_mem = IHB_FLP_PROCESSm;
  }

  res = soc_mem_read(
          unit,
          flp_process_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  if (SOC_IS_ARAD_B1_AND_BELOW(unit)) {
      /* This field is not present in Arad+, see IHP_ELK_PAYLOAD_FORMATm */
      tbl_data->elk_result_format = soc_mem_field32_get(unit, flp_process_mem, data, ELK_RESULT_FORMATf);
  }

  /* Translation 1x1 in strength between Arad-B0 and Arad+ between present bit and strength value */
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_FWD_IN_RESULT_A_STRENGTHf: INCLUDE_ELK_FWD_IN_RESULT_Af;
  tbl_data->include_elk_fwd_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_2ND_IN_RESULT_A_STRENGTHf: INCLUDE_LEM_2ND_IN_RESULT_Af;
  tbl_data->include_lem_2nd_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_JERICHO(unit)? TCAM_0_IN_RESULT_A_STRENGTHf: (SOC_IS_ARADPLUS(unit)? TCAM_IN_RESULT_A_STRENGTHf: INCLUDE_TCAM_IN_RESULT_Af);
  tbl_data->include_tcam_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_2ND_IN_RESULT_A_STRENGTHf: INCLUDE_LPM_2ND_IN_RESULT_Af;
  tbl_data->include_lpm_2nd_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_EXT_IN_RESULT_A_STRENGTHf: INCLUDE_ELK_EXT_IN_RESULT_Af;
  tbl_data->include_elk_ext_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_1ST_IN_RESULT_A_STRENGTHf: INCLUDE_LEM_1ST_IN_RESULT_Af;
  tbl_data->include_lem_1st_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_1ST_IN_RESULT_A_STRENGTHf: INCLUDE_LPM_1ST_IN_RESULT_Af;
  tbl_data->include_lpm_1st_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);

  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_FWD_IN_RESULT_B_STRENGTHf: INCLUDE_ELK_FWD_IN_RESULT_Bf;
  tbl_data->include_elk_fwd_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_2ND_IN_RESULT_B_STRENGTHf: INCLUDE_LEM_2ND_IN_RESULT_Bf;
  tbl_data->include_lem_2nd_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_JERICHO(unit)? TCAM_0_IN_RESULT_B_STRENGTHf: (SOC_IS_ARADPLUS(unit)? TCAM_IN_RESULT_B_STRENGTHf: INCLUDE_TCAM_IN_RESULT_Bf);
  tbl_data->include_tcam_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_2ND_IN_RESULT_B_STRENGTHf: INCLUDE_LPM_2ND_IN_RESULT_Bf;
  tbl_data->include_lpm_2nd_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_EXT_IN_RESULT_B_STRENGTHf: INCLUDE_ELK_EXT_IN_RESULT_Bf;
  tbl_data->include_elk_ext_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_1ST_IN_RESULT_B_STRENGTHf: INCLUDE_LEM_1ST_IN_RESULT_Bf;
  tbl_data->include_lem_1st_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_1ST_IN_RESULT_B_STRENGTHf: INCLUDE_LPM_1ST_IN_RESULT_Bf;
  tbl_data->include_lpm_1st_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, strength_fld);

  tbl_data->result_a_format = soc_mem_field32_get(unit, flp_process_mem, data, RESULT_A_FORMATf);
  tbl_data->result_b_format = soc_mem_field32_get(unit, flp_process_mem, data, RESULT_B_FORMATf);
  tbl_data->not_found_trap_code = soc_mem_field32_get(unit, flp_process_mem, data, NOT_FOUND_TRAP_CODEf);
  tbl_data->not_found_trap_strength = soc_mem_field32_get(unit, flp_process_mem, data, NOT_FOUND_TRAP_STRENGTHf);
  tbl_data->not_found_snoop_strength = soc_mem_field32_get(unit, flp_process_mem, data, NOT_FOUND_SNOOP_STRENGTHf);
  tbl_data->sa_lkp_result_select = soc_mem_field32_get(unit, flp_process_mem, data, SA_LKP_RESULT_SELECTf);
  tbl_data->apply_fwd_result_a = soc_mem_field32_get(unit, flp_process_mem, data, APPLY_FWD_RESULT_Af);
  tbl_data->sa_lkp_process_enable = soc_mem_field32_get(unit, flp_process_mem, data, SA_LKP_PROCESS_ENABLEf);
  tbl_data->procedure_ethernet_default = soc_mem_field32_get(unit, flp_process_mem, data, PROCEDURE_ETHERNET_DEFAULTf);
  tbl_data->unknown_address = soc_mem_field32_get(unit, flp_process_mem, data, UNKNOWN_ADDRESSf);
  tbl_data->enable_hair_pin_filter = soc_mem_field32_get(unit, flp_process_mem, data, ENABLE_HAIR_PIN_FILTERf);
  tbl_data->enable_rpf_check = soc_mem_field32_get(unit, flp_process_mem, data, ENABLE_RPF_CHECKf);
  tbl_data->compatible_mc_bridge_fallback = soc_mem_field32_get(unit, flp_process_mem, data, COMPATIBLE_MC_BRIDGE_FALLBACKf);
  tbl_data->enable_lsr_p2p_service = soc_mem_field32_get(unit, flp_process_mem, data, ENABLE_LSR_P2P_SERVICEf);
  tbl_data->learn_enable = soc_mem_field32_get(unit, flp_process_mem, data, LEARN_ENABLEf);
  tbl_data->fwd_processing_profile = soc_mem_field32_get(unit, flp_process_mem, data, FWD_PROCESSING_PROFILEf);
  
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
    tbl_data->select_default_result_a = soc_mem_field32_get(unit, flp_process_mem, data, SELECT_DEFAULT_RESULT_Af);
    tbl_data->select_default_result_b = soc_mem_field32_get(unit, flp_process_mem, data, SELECT_DEFAULT_RESULT_Bf);
  }

  /* Jericho new fields */
  if (SOC_IS_JERICHO(unit)) {
    tbl_data->include_tcam_1_in_result_a = soc_mem_field32_get(unit, flp_process_mem, data, TCAM_1_IN_RESULT_A_STRENGTHf);
    tbl_data->include_tcam_1_in_result_b = soc_mem_field32_get(unit, flp_process_mem, data, TCAM_1_IN_RESULT_B_STRENGTHf);
    tbl_data->lpm_1st_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, LPM_1ST_LKP_ENABLE_DEFAULTf);
    tbl_data->lpm_2nd_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, LPM_2ND_LKP_ENABLE_DEFAULTf);
    tbl_data->lpm_public_1st_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, LPM_PUBLIC_1ST_LKP_ENABLE_DEFAULTf);
    tbl_data->lpm_public_2nd_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, LPM_PUBLIC_2ND_LKP_ENABLE_DEFAULTf);
    tbl_data->elk_fwd_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, ELK_FWD_LKP_ENABLE_DEFAULTf);
    tbl_data->elk_ext_lkp_enable_default = soc_mem_field32_get(unit, flp_process_mem, data, ELK_EXT_LKP_ENABLE_DEFAULTf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_process_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_process_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FLP_PROCESS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FLP_PROCESS_TBL_ENTRY_SIZE];
  soc_field_t
      strength_fld;
  soc_mem_t
    flp_process_mem;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_PROCESS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_PROCESS_TBL_ENTRY_SIZE);

  if (SOC_IS_JERICHO(unit)) {
      flp_process_mem = IHP_FLP_PROCESSm;
  } else {
      flp_process_mem = IHB_FLP_PROCESSm;
  }

  if (SOC_IS_ARAD_B1_AND_BELOW(unit)) {
      /* This field is not present in Arad+, see IHP_ELK_PAYLOAD_FORMATm */
      soc_mem_field32_set(unit, flp_process_mem, data, ELK_RESULT_FORMATf, tbl_data->elk_result_format);
  }

  /* Translation 1x1 in strength between Arad-B0 and Arad+ between present bit and strength value */
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_FWD_IN_RESULT_A_STRENGTHf: INCLUDE_ELK_FWD_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_elk_fwd_in_result_a);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_2ND_IN_RESULT_A_STRENGTHf: INCLUDE_LEM_2ND_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lem_2nd_in_result_a);
  strength_fld = SOC_IS_JERICHO(unit)? TCAM_0_IN_RESULT_A_STRENGTHf: (SOC_IS_ARADPLUS(unit)? TCAM_IN_RESULT_A_STRENGTHf: INCLUDE_TCAM_IN_RESULT_Af);
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_tcam_in_result_a);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_2ND_IN_RESULT_A_STRENGTHf: INCLUDE_LPM_2ND_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lpm_2nd_in_result_a);
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_EXT_IN_RESULT_A_STRENGTHf: INCLUDE_ELK_EXT_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_elk_ext_in_result_a);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_1ST_IN_RESULT_A_STRENGTHf: INCLUDE_LEM_1ST_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lem_1st_in_result_a);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_1ST_IN_RESULT_A_STRENGTHf: INCLUDE_LPM_1ST_IN_RESULT_Af;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lpm_1st_in_result_a);

  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_FWD_IN_RESULT_B_STRENGTHf: INCLUDE_ELK_FWD_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_elk_fwd_in_result_b);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_2ND_IN_RESULT_B_STRENGTHf: INCLUDE_LEM_2ND_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lem_2nd_in_result_b);
  strength_fld = SOC_IS_JERICHO(unit)? TCAM_0_IN_RESULT_B_STRENGTHf: (SOC_IS_ARADPLUS(unit)? TCAM_IN_RESULT_B_STRENGTHf: INCLUDE_TCAM_IN_RESULT_Bf);
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_tcam_in_result_b);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_2ND_IN_RESULT_B_STRENGTHf: INCLUDE_LPM_2ND_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lpm_2nd_in_result_b);
  strength_fld = SOC_IS_ARADPLUS(unit)? ELK_EXT_IN_RESULT_B_STRENGTHf: INCLUDE_ELK_EXT_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_elk_ext_in_result_b);
  strength_fld = SOC_IS_ARADPLUS(unit)? LEM_1ST_IN_RESULT_B_STRENGTHf: INCLUDE_LEM_1ST_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lem_1st_in_result_b);
  strength_fld = SOC_IS_ARADPLUS(unit)? LPM_1ST_IN_RESULT_B_STRENGTHf: INCLUDE_LPM_1ST_IN_RESULT_Bf;
  soc_mem_field32_set(unit, flp_process_mem, data, strength_fld, tbl_data->include_lpm_1st_in_result_b);

  soc_mem_field32_set(unit, flp_process_mem, data, RESULT_A_FORMATf, tbl_data->result_a_format);
  soc_mem_field32_set(unit, flp_process_mem, data, RESULT_B_FORMATf, tbl_data->result_b_format);
  soc_mem_field32_set(unit, flp_process_mem, data, NOT_FOUND_TRAP_CODEf, tbl_data->not_found_trap_code);
  soc_mem_field32_set(unit, flp_process_mem, data, NOT_FOUND_TRAP_STRENGTHf, tbl_data->not_found_trap_strength);
  soc_mem_field32_set(unit, flp_process_mem, data, NOT_FOUND_SNOOP_STRENGTHf, tbl_data->not_found_snoop_strength);
  soc_mem_field32_set(unit, flp_process_mem, data, SA_LKP_RESULT_SELECTf, tbl_data->sa_lkp_result_select);
  soc_mem_field32_set(unit, flp_process_mem, data, APPLY_FWD_RESULT_Af, tbl_data->apply_fwd_result_a);
  soc_mem_field32_set(unit, flp_process_mem, data, SA_LKP_PROCESS_ENABLEf, tbl_data->sa_lkp_process_enable);
  soc_mem_field32_set(unit, flp_process_mem, data, PROCEDURE_ETHERNET_DEFAULTf, tbl_data->procedure_ethernet_default);
  soc_mem_field32_set(unit, flp_process_mem, data, UNKNOWN_ADDRESSf, tbl_data->unknown_address);
  soc_mem_field32_set(unit, flp_process_mem, data, ENABLE_HAIR_PIN_FILTERf, tbl_data->enable_hair_pin_filter);
  soc_mem_field32_set(unit, flp_process_mem, data, ENABLE_RPF_CHECKf, tbl_data->enable_rpf_check);
  soc_mem_field32_set(unit, flp_process_mem, data, COMPATIBLE_MC_BRIDGE_FALLBACKf, tbl_data->compatible_mc_bridge_fallback);
  soc_mem_field32_set(unit, flp_process_mem, data, ENABLE_LSR_P2P_SERVICEf, tbl_data->enable_lsr_p2p_service);
  soc_mem_field32_set(unit, flp_process_mem, data, LEARN_ENABLEf, tbl_data->learn_enable);
  soc_mem_field32_set(unit, flp_process_mem, data, FWD_PROCESSING_PROFILEf, tbl_data->fwd_processing_profile);

  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
    soc_mem_field32_set(unit, flp_process_mem, data, SELECT_DEFAULT_RESULT_Af, tbl_data->select_default_result_a);
    soc_mem_field32_set(unit, flp_process_mem, data, SELECT_DEFAULT_RESULT_Bf, tbl_data->select_default_result_b);
  }


  /* Jericho new fields */
  if (SOC_IS_JERICHO(unit)) {
    soc_mem_field32_set(unit, flp_process_mem, data, TCAM_1_IN_RESULT_A_STRENGTHf, tbl_data->include_tcam_1_in_result_a);
    soc_mem_field32_set(unit, flp_process_mem, data, TCAM_1_IN_RESULT_B_STRENGTHf, tbl_data->include_tcam_1_in_result_b);
    soc_mem_field32_set(unit, flp_process_mem, data, LPM_1ST_LKP_ENABLE_DEFAULTf, tbl_data->lpm_1st_lkp_enable_default);
    soc_mem_field32_set(unit, flp_process_mem, data, LPM_2ND_LKP_ENABLE_DEFAULTf, tbl_data->lpm_2nd_lkp_enable_default);
    soc_mem_field32_set(unit, flp_process_mem, data, LPM_PUBLIC_1ST_LKP_ENABLE_DEFAULTf, tbl_data->lpm_public_1st_lkp_enable_default);
    soc_mem_field32_set(unit, flp_process_mem, data, LPM_PUBLIC_2ND_LKP_ENABLE_DEFAULTf, tbl_data->lpm_public_2nd_lkp_enable_default);
    soc_mem_field32_set(unit, flp_process_mem, data, ELK_FWD_LKP_ENABLE_DEFAULTf, tbl_data->elk_fwd_lkp_enable_default);
    soc_mem_field32_set(unit, flp_process_mem, data, ELK_EXT_LKP_ENABLE_DEFAULTf, tbl_data->elk_ext_lkp_enable_default);
  }

  res = soc_mem_write(
          unit,
          flp_process_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_process_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_lookups_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FLP_LOOKUPS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHP_FLP_LOOKUPS_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_LOOKUPS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_FLP_LOOKUPS_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FLP_LOOKUPS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_FLP_LOOKUPSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->elk_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_LKP_VALIDf);
  tbl_data->elk_wait_for_reply = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_WAIT_FOR_REPLYf);
  tbl_data->elk_opcode = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_OPCODEf);
  tbl_data->elk_key_a_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_A_LSB_VALID_BYTESf);
  tbl_data->elk_key_b_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_B_LSB_VALID_BYTESf);
  tbl_data->elk_key_c_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_C_LSB_VALID_BYTESf);
  tbl_data->elk_packet_data_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_PACKET_DATA_SELECTf);
  tbl_data->lem_1st_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_VALIDf);
  tbl_data->lem_1st_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_KEY_SELECTf);
  tbl_data->lem_1st_lkp_key_type = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_KEY_TYPEf);
  tbl_data->lem_1st_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_AND_VALUEf);
  tbl_data->lem_1st_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_OR_VALUEf);
  tbl_data->lem_2nd_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_VALIDf);
  tbl_data->lem_2nd_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_KEY_SELECTf);
  tbl_data->lem_2nd_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_AND_VALUEf);
  tbl_data->lem_2nd_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_OR_VALUEf);
  tbl_data->lpm_1st_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_VALIDf);
  tbl_data->lpm_1st_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_KEY_SELECTf);
  tbl_data->lpm_1st_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_AND_VALUEf);
  tbl_data->lpm_1st_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_OR_VALUEf);
  tbl_data->lpm_2nd_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_VALIDf);
  tbl_data->lpm_2nd_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_KEY_SELECTf);
  tbl_data->lpm_2nd_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_AND_VALUEf);
  tbl_data->lpm_2nd_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_OR_VALUEf);
  tbl_data->tcam_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_KEY_SELECT_0f);
  tbl_data->tcam_lkp_db_profile = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_DB_PROFILE_0f);
  tbl_data->tcam_traps_lkp_db_profile_0 = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_TRAPS_LKP_DB_PROFILE_0f);
  tbl_data->tcam_traps_lkp_db_profile_1 = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_TRAPS_LKP_DB_PROFILE_1f);
  tbl_data->enable_tcam_identification_ieee_1588 = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ENABLE_TCAM_IDENTIFICATION_IEEE_1588f);
  tbl_data->enable_tcam_identification_oam = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ENABLE_TCAM_IDENTIFICATION_OAMf);
  tbl_data->learn_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LEARN_KEY_SELECTf);

  if (SOC_IS_JERICHO(unit)) {
    tbl_data->elk_key_d_lsb_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_D_LSB_VALID_BYTESf);
    tbl_data->elk_key_a_msb_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_A_MSB_VALID_BYTESf);
    tbl_data->elk_key_b_msb_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_B_MSB_VALID_BYTESf);
    tbl_data->elk_key_c_msb_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_C_MSB_VALID_BYTESf);
    tbl_data->elk_key_d_msb_valid_bytes = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_D_MSB_VALID_BYTESf);
    tbl_data->lpm_public_1st_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_VALIDf);
    tbl_data->lpm_public_1st_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_KEY_SELECTf);
    tbl_data->lpm_public_1st_lkp_key_size = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_KEY_SIZEf);
    tbl_data->lpm_public_1st_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_AND_VALUEf);
    tbl_data->lpm_public_1st_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_OR_VALUEf);
    tbl_data->lpm_public_2nd_lkp_valid = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_VALIDf);
    tbl_data->lpm_public_2nd_lkp_key_select = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_KEY_SELECTf);
    tbl_data->lpm_public_2nd_lkp_key_size = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_KEY_SIZEf);
    tbl_data->lpm_public_2nd_lkp_and_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_AND_VALUEf);
    tbl_data->lpm_public_2nd_lkp_or_value = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_OR_VALUEf);
    tbl_data->tcam_lkp_key_select_1 = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_KEY_SELECT_1f);
    tbl_data->tcam_lkp_db_profile_1 = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_DB_PROFILE_1f);
  }

  if (SOC_IS_JERICHO_PLUS(unit)) {

    tbl_data->Lpm_1stLkpType       = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_TYPEf);
    tbl_data->Lpm_2ndLkpType       = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_TYPEf);
    tbl_data->LpmPublic_1stLkpType = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_TYPEf);
    tbl_data->LpmPublic_2ndLkpType = soc_mem_field32_get(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_TYPEf);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_lookups_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_lookups_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FLP_LOOKUPS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(IHP_FLP_LOOKUPS_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_LOOKUPS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(IHP_FLP_LOOKUPS_NOF_LONGS));

  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_LKP_VALIDf, tbl_data->elk_lkp_valid);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_WAIT_FOR_REPLYf, tbl_data->elk_wait_for_reply);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_OPCODEf, tbl_data->elk_opcode);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_A_LSB_VALID_BYTESf, tbl_data->elk_key_a_valid_bytes);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_B_LSB_VALID_BYTESf, tbl_data->elk_key_b_valid_bytes);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_C_LSB_VALID_BYTESf, tbl_data->elk_key_c_valid_bytes);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_PACKET_DATA_SELECTf, tbl_data->elk_packet_data_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_VALIDf, tbl_data->lem_1st_lkp_valid);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_KEY_SELECTf, tbl_data->lem_1st_lkp_key_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_KEY_TYPEf, tbl_data->lem_1st_lkp_key_type);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_AND_VALUEf, tbl_data->lem_1st_lkp_and_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_1ST_LKP_OR_VALUEf, tbl_data->lem_1st_lkp_or_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_VALIDf, tbl_data->lem_2nd_lkp_valid);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_KEY_SELECTf, tbl_data->lem_2nd_lkp_key_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_AND_VALUEf, tbl_data->lem_2nd_lkp_and_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEM_2ND_LKP_OR_VALUEf, tbl_data->lem_2nd_lkp_or_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_VALIDf, tbl_data->lpm_1st_lkp_valid);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_KEY_SELECTf, tbl_data->lpm_1st_lkp_key_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_AND_VALUEf, tbl_data->lpm_1st_lkp_and_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_OR_VALUEf, tbl_data->lpm_1st_lkp_or_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_VALIDf, tbl_data->lpm_2nd_lkp_valid);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_KEY_SELECTf, tbl_data->lpm_2nd_lkp_key_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_AND_VALUEf, tbl_data->lpm_2nd_lkp_and_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_OR_VALUEf, tbl_data->lpm_2nd_lkp_or_value);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_KEY_SELECT_0f, tbl_data->tcam_lkp_key_select);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_DB_PROFILE_0f, tbl_data->tcam_lkp_db_profile);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_TRAPS_LKP_DB_PROFILE_0f, tbl_data->tcam_traps_lkp_db_profile_0);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_TRAPS_LKP_DB_PROFILE_1f, tbl_data->tcam_traps_lkp_db_profile_1);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ENABLE_TCAM_IDENTIFICATION_IEEE_1588f, tbl_data->enable_tcam_identification_ieee_1588);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ENABLE_TCAM_IDENTIFICATION_OAMf, tbl_data->enable_tcam_identification_oam);
  soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LEARN_KEY_SELECTf, tbl_data->learn_key_select);

  if (SOC_IS_JERICHO(unit)) {
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_D_LSB_VALID_BYTESf, tbl_data->elk_key_d_lsb_valid_bytes);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_A_MSB_VALID_BYTESf, tbl_data->elk_key_a_msb_valid_bytes);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_B_MSB_VALID_BYTESf, tbl_data->elk_key_b_msb_valid_bytes);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_C_MSB_VALID_BYTESf, tbl_data->elk_key_c_msb_valid_bytes);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, ELK_KEY_D_MSB_VALID_BYTESf, tbl_data->elk_key_d_msb_valid_bytes);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_VALIDf, tbl_data->lpm_public_1st_lkp_valid);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_KEY_SELECTf, tbl_data->lpm_public_1st_lkp_key_select);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_KEY_SIZEf, tbl_data->lpm_public_1st_lkp_key_size);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_AND_VALUEf, tbl_data->lpm_public_1st_lkp_and_value);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_OR_VALUEf, tbl_data->lpm_public_1st_lkp_or_value);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_VALIDf, tbl_data->lpm_public_2nd_lkp_valid);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_KEY_SELECTf, tbl_data->lpm_public_2nd_lkp_key_select);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_KEY_SIZEf, tbl_data->lpm_public_2nd_lkp_key_size);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_AND_VALUEf, tbl_data->lpm_public_2nd_lkp_and_value);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_OR_VALUEf, tbl_data->lpm_public_2nd_lkp_or_value);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_KEY_SELECT_1f, tbl_data->tcam_lkp_key_select_1);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, TCAM_LKP_DB_PROFILE_1f, tbl_data->tcam_lkp_db_profile_1);
  }

  if (SOC_IS_JERICHO_PLUS(unit)) {
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_1ST_LKP_TYPEf, tbl_data->Lpm_1stLkpType);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_2ND_LKP_TYPEf, tbl_data->Lpm_2ndLkpType);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_1ST_LKP_TYPEf, tbl_data->LpmPublic_1stLkpType);
    soc_mem_field32_set(unit, IHP_FLP_LOOKUPSm, data, LPM_PUBLIC_2ND_LKP_TYPEf, tbl_data->LpmPublic_2ndLkpType);
  }

  res = soc_mem_write(
          unit,
          IHP_FLP_LOOKUPSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_lookups_tbl_set_unsafe()", entry_offset, 0);
}

/* 
 * Jericho porting: 
 * - given an instruction, return the correct field 
 * - during Jericho porting, use instruction 0-2 similarly, 
 * and instructions 3-5 as Jericho instructions 4-6
 */
soc_field_t
  arad_pp_ihb_flp_key_field_get(
     SOC_SAND_IN  int      unit,
     SOC_SAND_IN  uint32   instruction_id
  )
{
  switch (instruction_id) {
  case 0:
    return INSTRUCTION_0_16Bf;
    break;
  case 1:
    return INSTRUCTION_1_16Bf;
    break;
  case 2:
    return INSTRUCTION_2_16Bf;
    break;
  case 3:
#if 0 
    return (SOC_IS_JERICHO(unit)? INSTRUCTION_3_16Bf: INSTRUCTION_3_32Bf));
#endif 
    return (SOC_IS_JERICHO(unit)? INSTRUCTION_4_32Bf: INSTRUCTION_3_32Bf);
    break;
  case 4:
#if 0 
    return INSTRUCTION_4_32Bf);
#endif 
    return (SOC_IS_JERICHO(unit)? INSTRUCTION_5_32Bf: INSTRUCTION_4_32Bf);
    break;
  case 5:
#if 0 
    return INSTRUCTION_4_32Bf);
#endif 
    return (SOC_IS_JERICHO(unit)? INSTRUCTION_6_32Bf: INSTRUCTION_5_32Bf);
    break;
  default:
    return INVALIDf;
  }

}

/* 
 * Given an instruction bitmap, return the conofigured HW: 
 * - if Arad, (or Jericho in long-term), return the same value 
 * - if Jericho (short-term, only for porting): 
 *   - if Key-A or Key-B, return 0 on MSB, and same value on LSB
 *   - if Key-C, use bits 7:0 for LSB, and bits 15:8 for MSB
 */
uint32
  arad_pp_ihb_flp_key_inst_valid_bitmap_hw_set(
     SOC_SAND_IN  int      unit,
     SOC_SAND_IN  int      mem_ndx,
     SOC_SAND_IN  uint32   key_id,
     SOC_SAND_IN  uint32   inst_valid_bitmap /* struct value */
  )
{
  if (SOC_IS_JERICHO(unit)) {
    if (key_id < 2) { /* Key A or Key B */
      return (mem_ndx? 0x0: FLP_INSTR_VALID_BMP_ARAD_TO_JER(inst_valid_bitmap));
    } else {
      return (mem_ndx? FLP_INSTR_VALID_BMP_ARAD_TO_JER(((inst_valid_bitmap >> 8) & 0xFF)): FLP_INSTR_VALID_BMP_ARAD_TO_JER((inst_valid_bitmap & 0xFF)));
    }
  } else {
    return inst_valid_bitmap;
  }

}

uint32
  arad_pp_ihb_flp_ce_resources_per_program_get_unsafe(
    SOC_SAND_IN  int    unit,
    SOC_SAND_IN  uint32 entry_offset,
    SOC_SAND_OUT uint32 *ce_rsrc
  )
{
    uint32
    res = SOC_SAND_OK;
    uint32
    data[ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE];
    soc_mem_t
    flp_key_construction_mem = SOC_IS_JERICHO(unit)? IHP_FLP_KEY_CONSTRUCTION_LSBm: IHB_FLP_KEY_CONSTRUCTIONm;
    uint32 offset = 1, i;
    uint32 inst_fields_arr[8] = {INSTRUCTION_0_16Bf, INSTRUCTION_1_16Bf, INSTRUCTION_2_16Bf, 
                                 INSTRUCTION_3_32Bf, INSTRUCTION_4_32Bf, INSTRUCTION_5_32Bf,
                                 INSTRUCTION_6_32Bf, INSTRUCTION_7_32Bf};

    int nof_instructions = SOC_DPP_DEFS_GET(unit, nof_flp_instructions_lsb)/2;


    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

    if (nof_instructions == 8) {
        inst_fields_arr[3] = INSTRUCTION_3_16Bf;              
    }

    ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE);
    
    res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    for (i = 0; i < nof_instructions; i++) {
        if( soc_mem_field32_get(unit, flp_key_construction_mem, data, inst_fields_arr[i])) {
            (*ce_rsrc) |= offset;
        }
        offset = offset*2;
    }    

    res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset + SOC_DPP_IMP_DEFS_GET(unit, flp_instructions_nof),
          data
        );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);    

    for (i = 0; i < nof_instructions; i++) {
        if( soc_mem_field32_get(unit, flp_key_construction_mem, data, inst_fields_arr[i])) {
            (*ce_rsrc) |= offset;
        }
        offset = offset*2;
    }
    
    if (SOC_DPP_DEFS_GET(unit, nof_flp_instructions_lsb) == SOC_DPP_DEFS_GET(unit, nof_flp_16b_instructions)) {

        flp_key_construction_mem = IHP_FLP_KEY_CONSTRUCTION_MSBm;
        ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE);

        res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

        for (i = 0; i < nof_instructions; i++) {
            if( soc_mem_field32_get(unit, flp_key_construction_mem, data, inst_fields_arr[i])) {
                (*ce_rsrc) |= offset;
            }
            offset = offset*2;
        }

        res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset + SOC_DPP_IMP_DEFS_GET(unit, flp_instructions_nof),
          data
        );
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);    

        for (i = 0; i < nof_instructions; i++) {
            if( soc_mem_field32_get(unit, flp_key_construction_mem, data, inst_fields_arr[i])) {
                (*ce_rsrc) |= offset;
            }
            offset = offset*2;
        }
    }

exit:
    SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_ce_resources_per_program_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_flp_key_construction_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE];
  soc_mem_t
    flp_key_construction_mem = SOC_IS_JERICHO(unit)? IHP_FLP_KEY_CONSTRUCTION_LSBm: IHB_FLP_KEY_CONSTRUCTIONm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    tbl_data->instruction_0_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 0));
    tbl_data->instruction_1_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 1));
    tbl_data->instruction_2_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 2));
    tbl_data->instruction_3_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 3));
    tbl_data->instruction_4_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 4));
    tbl_data->instruction_5_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 5));
    tbl_data->key_a_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_A_INST_0_TO_7_VALIDf: KEY_A_INST_0_TO_5_VALIDf);
    tbl_data->key_b_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_B_INST_0_TO_7_VALIDf: KEY_B_INST_0_TO_5_VALIDf);
    tbl_data->key_c_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_C_INST_0_TO_7_VALIDf: KEY_C_INST_0_TO_5_VALIDf);
  
    if (SOC_IS_JERICHO(unit)) {
      uint32 key_a_inst_0_to_5_valid, key_b_inst_0_to_5_valid;

      tbl_data->instruction_6_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_6_32Bf);
      tbl_data->instruction_7_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_7_32Bf);
      tbl_data->key_d_inst_0_to_7_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, KEY_D_INST_0_TO_7_VALIDf);

      /*  Arad instructions 3-5 as Jericho instructions 4-6. */
      key_a_inst_0_to_5_valid = tbl_data->key_a_inst_0_to_5_valid;
      key_a_inst_0_to_5_valid = key_a_inst_0_to_5_valid >> 4; /* move 4-6 instructions to be the first bits */
      SHR_BITCOPY_RANGE(&(tbl_data->key_a_inst_0_to_5_valid), 3, &key_a_inst_0_to_5_valid, 0, 5);

      key_b_inst_0_to_5_valid = tbl_data->key_b_inst_0_to_5_valid;
      key_b_inst_0_to_5_valid = key_b_inst_0_to_5_valid >> 4; /* move 4-6 instructions to be the first bits */
      SHR_BITCOPY_RANGE(&(tbl_data->key_b_inst_0_to_5_valid), 3, &key_b_inst_0_to_5_valid, 0, 5);      
    }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_key_construction_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_key_construction_ext_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  int  is_msb,
    SOC_SAND_OUT ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE];
  soc_mem_t
    flp_key_construction_mem = SOC_IS_JERICHO(unit)? (is_msb ? IHP_FLP_KEY_CONSTRUCTION_MSBm : IHP_FLP_KEY_CONSTRUCTION_LSBm) : IHB_FLP_KEY_CONSTRUCTIONm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          flp_key_construction_mem,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    tbl_data->instruction_0_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_0_16Bf);
    tbl_data->instruction_1_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_1_16Bf);
    tbl_data->instruction_2_16b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_2_16Bf);
    tbl_data->instruction_3_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit) ? INSTRUCTION_3_16Bf : INSTRUCTION_3_32Bf);
    tbl_data->instruction_4_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_4_32Bf);
    tbl_data->instruction_5_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_5_32Bf);
    tbl_data->key_a_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_A_INST_0_TO_7_VALIDf: KEY_A_INST_0_TO_5_VALIDf);
    tbl_data->key_b_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_B_INST_0_TO_7_VALIDf: KEY_B_INST_0_TO_5_VALIDf);
    tbl_data->key_c_inst_0_to_5_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_C_INST_0_TO_7_VALIDf: KEY_C_INST_0_TO_5_VALIDf);

    if (SOC_IS_JERICHO(unit)) {
      tbl_data->instruction_6_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_6_32Bf);
      tbl_data->instruction_7_32b = soc_mem_field32_get(unit, flp_key_construction_mem, data, INSTRUCTION_7_32Bf);
      tbl_data->key_d_inst_0_to_7_valid = soc_mem_field32_get(unit, flp_key_construction_mem, data, KEY_D_INST_0_TO_7_VALIDf);
    }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_key_construction_ext_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_flp_key_construction_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    mem_ndx,
    nof_mems,
    data[ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE];
  soc_mem_t
    flp_key_construction_mem = SOC_IS_JERICHO(unit)? IHP_FLP_KEY_CONSTRUCTION_LSBm: IHB_FLP_KEY_CONSTRUCTIONm;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FLP_KEY_CONSTRUCTION_TBL_ENTRY_SIZE);

  /* In Jericho porting, write the same content in both LSB and MSB tables in first stage */
  nof_mems = SOC_IS_JERICHO(unit)? 2: 1;
  for (mem_ndx = 0; mem_ndx < nof_mems; mem_ndx++) {
    if (SOC_IS_JERICHO(unit) && (mem_ndx == 1)) {
      flp_key_construction_mem = IHP_FLP_KEY_CONSTRUCTION_MSBm;
    }

    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 0), tbl_data->instruction_0_16b);
    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 1), tbl_data->instruction_1_16b);
    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 2), tbl_data->instruction_2_16b);
    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 3), tbl_data->instruction_3_32b);
    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 4), tbl_data->instruction_4_32b);
    soc_mem_field32_set(unit, flp_key_construction_mem, data, arad_pp_ihb_flp_key_field_get(unit, 5), tbl_data->instruction_5_32b);

    soc_mem_field32_set(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_A_INST_0_TO_7_VALIDf: KEY_A_INST_0_TO_5_VALIDf, arad_pp_ihb_flp_key_inst_valid_bitmap_hw_set(unit, mem_ndx, 0, tbl_data->key_a_inst_0_to_5_valid));
    soc_mem_field32_set(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_B_INST_0_TO_7_VALIDf: KEY_B_INST_0_TO_5_VALIDf, arad_pp_ihb_flp_key_inst_valid_bitmap_hw_set(unit, mem_ndx, 1, tbl_data->key_b_inst_0_to_5_valid));
    soc_mem_field32_set(unit, flp_key_construction_mem, data, SOC_IS_JERICHO(unit)? KEY_C_INST_0_TO_7_VALIDf: KEY_C_INST_0_TO_5_VALIDf, arad_pp_ihb_flp_key_inst_valid_bitmap_hw_set(unit, mem_ndx, 2, tbl_data->key_c_inst_0_to_5_valid));

    res = soc_mem_write(
            unit,
            flp_key_construction_mem,
            MEM_BLOCK_ANY,
            entry_offset,
            data
          );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_flp_key_construction_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_lpm_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32  bank_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_LPM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_LPM_TBL_ENTRY_SIZE];
  uint32
    memory;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LPM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_LPM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_LPM_TBL_DATA, 1);
  
  switch(bank_id) {
  case 0:
      memory = IHB_LPMm;
  break;
  case 1:
      memory = IHB_LPM_2m;
  break;
  case 2:
      memory = IHB_LPM_3m;
  break;
  case 3:
      memory = IHB_LPM_4m;
  break;
  case 4:
      memory = IHB_LPM_5m;
  break;
  case 5:
      memory = IHB_LPM_6m;
  break;
  default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_TBL_RANGE_OUT_OF_LIMIT, 20, exit);
  }

  res = soc_mem_read(
          unit,
          memory,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->lpm = soc_mem_field32_get(unit, IHB_LPM_2m, data, LPM_2f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lpm_tbl_get_unsafe()", entry_offset, 0);
}
#define LPM_USE_DMA 1

uint32
  arad_pp_ihb_lpm_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32  bank_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  uint32   nof_entries,
    SOC_SAND_OUT uint32   *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
#if LPM_USE_DMA
  uint32
      *dma_buff;
#endif
/*  uint32
    data[ARAD_PP_IHB_LPM_TBL_ENTRY_SIZE];*/
  uint32
    memory;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LPM_TBL_SET_UNSAFE);

  switch(bank_id) {
  case 0:
      memory = IHB_LPMm;
  break;
  case 1:
      memory = IHB_LPM_2m;
  break;
  case 2:
      memory = IHB_LPM_3m;
  break;
  case 3:
      memory = IHB_LPM_4m;
  break;
  case 4:
      memory = IHB_LPM_5m;
  break;
  case 5:
      memory = IHB_LPM_6m;
  break;
  default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_TBL_RANGE_OUT_OF_LIMIT, 20, exit);
  }

  if(nof_entries == 1) {
      res = soc_mem_write(
              unit,
              memory,
              MEM_BLOCK_ANY,
              entry_offset,
              tbl_data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
      goto exit;
  }
  /* write chunk of entries */

#if LPM_USE_DMA
  res = arad_pp_sw_db_ipv4_lpm_dma_buff_get(unit,&dma_buff);
  SOC_SAND_CHECK_FUNC_RESULT(res, 45, exit);
  

  /* copy data into DMA buffer */
  sal_memcpy(dma_buff, tbl_data,  nof_entries * sizeof(uint32));

  /* write into the lines, from buffer*/
  res = soc_mem_array_write_range(unit, 0, memory, 0, MEM_BLOCK_ANY, entry_offset, entry_offset+nof_entries-1, dma_buff);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res,50,exit);
#else
{
    uint32 indx = 0;
    for (indx = 0; indx < nof_entries; ++indx) {
        res = soc_mem_write(
                unit,
                memory,
                MEM_BLOCK_ANY,
                entry_offset+indx,
                &tbl_data[indx]
              );
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
    }
}
#endif

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lpm_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_tcam_action_mem_and_index_get(
    SOC_SAND_IN  int              unit,
    SOC_SAND_IN  uint32              action_tbl_id,
    SOC_SAND_IN  uint8               is_for_hit_bit,
    SOC_SAND_OUT soc_mem_t           *mem_tbl,
    SOC_SAND_OUT uint32              *arr_index
  )
{
  soc_mem_t
      action_tbl_small[] = {IHB_TCAM_ACTION_24m, IHB_TCAM_ACTION_25m, 
          IHB_TCAM_ACTION_26m, IHB_TCAM_ACTION_27m},
      hit_bit_tbl_small[] = {IHB_TCAM_ACTION_HIT_INDICATION_24m, IHB_TCAM_ACTION_HIT_INDICATION_25m, 
              IHB_TCAM_ACTION_HIT_INDICATION_26m, IHB_TCAM_ACTION_HIT_INDICATION_27m},
      action_tbl_small_jericho[] = {PPDB_A_TCAM_ACTION_SMALL_24m, PPDB_A_TCAM_ACTION_SMALL_25m, 
          PPDB_A_TCAM_ACTION_SMALL_26m, PPDB_A_TCAM_ACTION_SMALL_27m, 
          PPDB_A_TCAM_ACTION_SMALL_28m, PPDB_A_TCAM_ACTION_SMALL_29m, 
          PPDB_A_TCAM_ACTION_SMALL_30m, PPDB_A_TCAM_ACTION_SMALL_31m},
      hit_bit_tbl_small_jericho[] = {PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_24m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_25m,  
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_26m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_27m, 
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_28m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_29m, 
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_30m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_31m},
      action_tbl_small_qux[] = {PPDB_A_TCAM_ACTION_SMALL_16m, PPDB_A_TCAM_ACTION_SMALL_17m,
          PPDB_A_TCAM_ACTION_SMALL_18m, PPDB_A_TCAM_ACTION_SMALL_19m,
          PPDB_A_TCAM_ACTION_SMALL_20m, PPDB_A_TCAM_ACTION_SMALL_21m,
          PPDB_A_TCAM_ACTION_SMALL_22m, PPDB_A_TCAM_ACTION_SMALL_23m},
      hit_bit_tbl_small_qux[] = {PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_16m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_17m,
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_18m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_19m,
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_20m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_21m,
              PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_22m, PPDB_A_TCAM_ACTION_HIT_INDICATION_SMALL_23m};
   uint32
       action_tbl_small_id;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_ACTION_TBL_GET_UNSAFE);

  /* 
   * Get the table name and the good index
   */
  if (action_tbl_id < (2 * SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks))) {
      *mem_tbl = is_for_hit_bit? PPDB_A_TCAM_ACTION_HIT_INDICATIONm: PPDB_A_TCAM_ACTIONm;
      *arr_index = action_tbl_id;
  }
  else if (action_tbl_id < (2 * SOC_DPP_DEFS_GET_TCAM_NOF_BANKS(unit))) {
      action_tbl_small_id = action_tbl_id - (2 * SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks));
      if(SOC_IS_JERICHO(unit)) {
          if (SOC_IS_QUX(unit)) {
              *mem_tbl = is_for_hit_bit? hit_bit_tbl_small_qux[action_tbl_small_id] : action_tbl_small_qux[action_tbl_small_id];
          } else {
              *mem_tbl = is_for_hit_bit? hit_bit_tbl_small_jericho[action_tbl_small_id]: action_tbl_small_jericho[action_tbl_small_id];
          }
          *arr_index = 0;
      } else
      {
          *mem_tbl = is_for_hit_bit? hit_bit_tbl_small[action_tbl_small_id]: action_tbl_small[action_tbl_small_id];
          *arr_index = 0;
      }
  }
  else {
      SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }         

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_action_mem_and_index_get()", action_tbl_id, 0);
}


/*
 * Read indirect table tcam_action_tbl from block IHB,
 * doesn't take semaphore.
 * Must only be called from a function taking the device semaphore
 */

uint32
  arad_pp_ihb_tcam_action_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              action_tbl_id,
    SOC_SAND_IN  uint32              line,
    SOC_SAND_IN  uint8               is_for_hit_bit,
    SOC_SAND_OUT ARAD_PP_IHB_TCAM_ACTION_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    offset = line,
    arr_index,
    data[ARAD_PP_IHB_TCAM_ACTION_TBL_ENTRY_SIZE];
  soc_mem_t           
      mem_tbl;
  soc_field_t 
      field;
  uint32
      access_lcl[1];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_ACTION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_TCAM_ACTION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_TCAM_ACTION_TBL_DATA, 1);

  /* 
   * Get the table name and the good index
   */
  res = arad_pp_ihb_tcam_action_mem_and_index_get(
            unit,
            action_tbl_id,
            is_for_hit_bit,
            &mem_tbl,
            &arr_index
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
 
  /* 
   * 2 TCAM Action tables per TCAM bank, 1024 lines per table 
   * Take as input the TCAM Bank (and not the TCAM Action table index), 
   * and the Action table logical line, and not the actual HW line 
   */
  if (is_for_hit_bit) {
      offset = ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_LINE(line);
  }
  res = soc_mem_array_read(
          unit,
          mem_tbl,
          arr_index,
          MEM_BLOCK_ANY,
          offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);


 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-Action-read: array-index:%d, line:%d, data:%d \n\r")), arr_index, line, data[0]));

  field = is_for_hit_bit? HITf: ACTIONf;
  tbl_data->action = soc_mem_field32_get(
                        unit,
                        mem_tbl,
                        data,
                        field);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
         
  if (is_for_hit_bit) {
      *access_lcl = tbl_data->action;
      tbl_data->action = SHR_BITGET(access_lcl, ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_BIT(line))? 1: 0;
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_action_tbl_get_unsafe()", line, 0);
}

uint32
  arad_pp_ihb_tcam_action_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              action_tbl_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  uint8               is_for_hit_bit,
    SOC_SAND_IN  ARAD_PP_IHB_TCAM_ACTION_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    offset=entry_offset,
    arr_index=action_tbl_id,
    data[ARAD_PP_IHB_TCAM_ACTION_TBL_ENTRY_SIZE];
  soc_mem_t           
      mem_tbl;
  soc_field_t 
      field;
  uint32
      action_lcl[1];
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_ACTION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_TCAM_ACTION_TBL_ENTRY_SIZE);

  /* 
   * Get the table name and the good index
   */
  res = arad_pp_ihb_tcam_action_mem_and_index_get(
            unit,
            action_tbl_id,
            is_for_hit_bit,
            &mem_tbl,
            &arr_index
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (is_for_hit_bit) {
      offset = ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_LINE(entry_offset);
  }

  /* Get the bitmap and set the correct bit */
  if (is_for_hit_bit) {
      res = soc_mem_array_read(
              unit,
              mem_tbl,
              arr_index,
              MEM_BLOCK_ALL,
              offset,
              action_lcl
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 23, exit);

      if (tbl_data->action) {
          SHR_BITSET(action_lcl, ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_BIT(entry_offset));
      }
      else {
          SHR_BITCLR(action_lcl, ARAD_IHB_TCAM_HIT_INDICATION_TCAM_ENTRY_TO_BIT(entry_offset));
      }
  }
  else {
      *action_lcl = tbl_data->action;
  }

  field = is_for_hit_bit? HITf: ACTIONf;
  soc_mem_field32_set(
          unit,
          mem_tbl,
          data,
          field,
          *action_lcl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  
  res = soc_mem_array_write(
          unit,
          mem_tbl,
          arr_index,
          MEM_BLOCK_ALL,
          offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                                 "TCAM-Action-write: mem %d %s array-index:%d, line:%d, data:%d \n\r")), mem_tbl, SOC_MEM_NAME(unit, mem_tbl), arr_index, offset, data[0]));


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_action_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_ingress_vlan_edit_command_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EGQ_IVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
  );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->tpid_profile_link   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          TPID_PROFILEf );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  tbl_data->edit_command_outer_vid_source   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          OUTER_VID_SRCf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

  tbl_data->edit_command_outer_pcp_dei_source   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          OUTER_PCP_DEI_SRCf        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

  tbl_data->edit_command_inner_vid_source   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          INNER_VID_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

  tbl_data->edit_command_inner_pcp_dei_source   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          INNER_PCP_DEI_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);

  tbl_data->edit_command_bytes_to_remove   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          TAGS_TO_REMOVEf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

  tbl_data->outer_tpid_ndx   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          OUTER_TPID_INDEXf            );
  SOC_SAND_CHECK_FUNC_RESULT(res, 100, exit);

  tbl_data->inner_tpid_ndx   = soc_mem_field32_get(
          unit,
          EGQ_IVEC_TABLEm,
          data,
          INNER_TPID_INDEXf    );
  SOC_SAND_CHECK_FUNC_RESULT(res, 110, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_ingress_vlan_edit_command_map_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_egq_ingress_vlan_edit_command_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA  *tbl_data
  )
{
    uint32
    res = SOC_SAND_OK;
    uint32
    data[ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE];

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_SET_UNSAFE);

    ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              TPID_PROFILEf,
              tbl_data->tpid_profile_link );
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              OUTER_VID_SRCf,
              tbl_data->edit_command_outer_vid_source );
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              OUTER_PCP_DEI_SRCf,
              tbl_data->edit_command_outer_pcp_dei_source );
      SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              INNER_VID_SRCf,
              tbl_data->edit_command_inner_vid_source );
      SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              INNER_PCP_DEI_SRCf,
              tbl_data->edit_command_inner_pcp_dei_source );
      SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              TAGS_TO_REMOVEf,
              tbl_data->edit_command_bytes_to_remove );
      SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              OUTER_TPID_INDEXf,
              tbl_data->outer_tpid_ndx );
      SOC_SAND_CHECK_FUNC_RESULT(res, 100, exit);

      soc_mem_field32_set(
              unit,
              EGQ_IVEC_TABLEm,
              data,
              INNER_TPID_INDEXf,
              tbl_data->inner_tpid_ndx );
      SOC_SAND_CHECK_FUNC_RESULT(res, 110, exit);

      res = soc_mem_write(
              unit,
              EGQ_IVEC_TABLEm,
              MEM_BLOCK_ANY,
              entry_offset,
              data
      );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 120, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_ingress_vlan_edit_command_map_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_egq_vsi_membership_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
    uint32
    res = SOC_SAND_OK;
    uint32
    data[ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE];

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_GET_UNSAFE);

    ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE);
    ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA, 1);

    res = soc_mem_read(unit, EGQ_VSI_MEMBERSHIPm, EGQ_BLOCK(unit, core_id), entry_offset, data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

    soc_mem_field_get(unit, EGQ_VSI_MEMBERSHIPm, data, VSI_MEMBERSHIPf, &(tbl_data->vsi_membership[0]));

    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

    exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_vsi_membership_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_vsi_membership_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
    uint32
    res = SOC_SAND_OK;
    uint32
    data[ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE];

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_SET_UNSAFE);

    ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE);

      res = soc_mem_read(unit, EGQ_VSI_MEMBERSHIPm, EGQ_BLOCK(unit, core_id), entry_offset, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

      soc_mem_field_set(unit, EGQ_VSI_MEMBERSHIPm, data, VSI_MEMBERSHIPf, (uint32*)&(tbl_data->vsi_membership[0]));

      res = soc_mem_write(unit, EGQ_VSI_MEMBERSHIPm, EGQ_BLOCK(unit, core_id), entry_offset, data);

      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_vsi_membership_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_egress_membership_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
    uint32
    data[ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE];

    /*
       Assuming EGQ_VSI_MEMBERSHIPm and EPNI_EGRESS_MEMBERSHIP tables are identical
    */
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32 ) * ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, EPNI_EGRESS_MEMBERSHIPm, EPNI_BLOCK(unit, core_id), entry_offset, data));

    soc_mem_field_get(unit, EPNI_EGRESS_MEMBERSHIPm, data, EGRESS_MEMBERSHIPf, &(tbl_data->vsi_membership[0]));

exit:
    SOCDNX_FUNC_RETURN;
}


uint32
  arad_pp_epni_egress_membership_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
    uint32
    data[ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE];

    /*
       Assuming EGQ_VSI_MEMBERSHIPm and EPNI_EGRESS_MEMBERSHIP tables are identical
    */

    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32 )* ARAD_PP_EGQ_VSI_MEMBERSHIP_TBL_ENTRY_SIZE);

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, EPNI_EGRESS_MEMBERSHIPm, EPNI_BLOCK(unit, core_id), entry_offset, data));

    soc_mem_field_set(unit, EPNI_EGRESS_MEMBERSHIPm, data, EGRESS_MEMBERSHIPf, (uint32*)&(tbl_data->vsi_membership[0]));

    SOCDNX_IF_ERR_EXIT(soc_mem_write(unit, EPNI_EGRESS_MEMBERSHIPm, EPNI_BLOCK(unit, core_id), entry_offset, data));

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
  arad_pp_epni_tx_tag_table_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_TX_TAG_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_TX_TAG_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_TX_TAG_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_TX_TAG_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_TX_TAG_TABLE_TBL_DATA, 1);

  res = soc_mem_read(unit, EPNI_TX_TAG_TABLEm, EPNI_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  soc_mem_field_get(unit, EPNI_TX_TAG_TABLEm, data, TX_TAG_TABLEf, &(tbl_data->entry[0]));
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_tx_tag_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_tx_tag_table_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_TX_TAG_TABLE_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_TX_TAG_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_TX_TAG_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_TX_TAG_TABLE_TBL_ENTRY_SIZE);
  
  soc_mem_field_set(unit, EPNI_TX_TAG_TABLEm, data, TX_TAG_TABLEf, (uint32 *)&(tbl_data->entry[0]));
  
  res = soc_mem_write(unit, EPNI_TX_TAG_TABLEm, EPNI_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_tx_tag_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_STP_TBL_ENTRY_SIZE 9

uint32
  arad_pp_epni_stp_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_STP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_STP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_STP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_STP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_STP_TBL_DATA, 1);

  res = READ_EPNI_SPANNING_TREE_PROTOCOL_STATE_MEMORY_STPm(unit, EPNI_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);
  soc_mem_field_get(unit, EPNI_SPANNING_TREE_PROTOCOL_STATE_MEMORY_STPm, data, STPf, tbl_data->stp);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_stp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_stp_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id, 
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_STP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_STP_TBL_ENTRY_SIZE];

 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_STP_TBL_SET_UNSAFE);
  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_STP_TBL_ENTRY_SIZE);
  
  soc_mem_field_set(unit, EPNI_SPANNING_TREE_PROTOCOL_STATE_MEMORY_STPm, data, STPf, (uint32*)(tbl_data->stp));
  res = WRITE_EPNI_SPANNING_TREE_PROTOCOL_STATE_MEMORY_STPm(unit, EPNI_BLOCK(unit, core_id), entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_stp_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_pcp_dei_map_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_PCP_DEI_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PCP_DEI_MAP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PCP_DEI_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PCP_DEI_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PCP_DEI_MAP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_PCP_DEI_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

soc_mem_field_get(unit, EPNI_PCP_DEI_TABLEm, data, PCP_DEI_MAPf,&tbl_data->pcp_dei_map);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_pcp_dei_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_pcp_dei_map_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_PCP_DEI_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PCP_DEI_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PCP_DEI_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PCP_DEI_MAP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_PCP_DEI_TABLEm, data, PCP_DEI_MAPf, tbl_data->pcp_dei_map);

  res = soc_mem_write(
          unit,
          EPNI_PCP_DEI_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);


  /* PCP_DEI_TABLE and NATIVE_PCP_DEI_TABLE are duplicated */
  if (SOC_IS_JERICHO_PLUS(unit)) {
      res = soc_mem_write(
              unit,
              EPNI_NATIVE_PCP_DEI_TABLEm,
              MEM_BLOCK_ANY,
              entry_offset,
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 50, exit);
  } 

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_pcp_dei_map_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_epni_egress_edit_cmd_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_DATA  *tbl_data
  )
{
  uint32
    entry,
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_DATA, 1);

 res = soc_mem_read(
          unit,
          EPNI_EVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset/2,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  entry = (entry_offset & 0x1 ) * (ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_FLD_SIZE); 

  soc_sand_bitstream_get_any_field(data,entry+0,2,&tbl_data->tags_to_remove);
  soc_sand_bitstream_get_any_field(data,entry+2,2,&tbl_data->inner_pcp_dei_source);
  soc_sand_bitstream_get_any_field(data,entry+4,2,&tbl_data->outer_pcp_dei_source);
  soc_sand_bitstream_get_any_field(data,entry+6,3,&tbl_data->inner_vid_source);
  soc_sand_bitstream_get_any_field(data,entry+9,3,&tbl_data->outer_vid_source);
  soc_sand_bitstream_get_any_field(data,entry+12,(SOC_IS_JERICHO_PLUS(unit)) ? 3 : 2,&tbl_data->inner_tpid_index);
  soc_sand_bitstream_get_any_field(data,entry+((SOC_IS_JERICHO_PLUS(unit)) ? 15 : 14),(SOC_IS_QAX(unit)) ? 3 : 2,&tbl_data->outer_tpid_index);
  if (SOC_IS_JERICHO_PLUS(unit)) {
      soc_sand_bitstream_get_any_field(data,entry+18,1,&tbl_data->packet_is_tagged_after_eve);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_egress_edit_cmd_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_egress_edit_cmd_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_DATA  *tbl_data
  )
{
  uint32
    entry,
    tmp,
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE);

  res = soc_mem_read(
          unit,
          EPNI_EVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset/2,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  entry = (entry_offset & 0x1) * (ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_FLD_SIZE); 

  tmp = ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_INFO(unit, 
                    tbl_data->outer_tpid_index, tbl_data->inner_tpid_index, \
                    tbl_data->outer_vid_source, tbl_data->inner_vid_source, \
                    tbl_data->outer_pcp_dei_source, tbl_data->inner_pcp_dei_source, \
                    tbl_data->tags_to_remove, \
                    tbl_data->packet_is_tagged_after_eve);

  soc_sand_bitstream_set_any_field(&tmp,entry,ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_FLD_SIZE,data);

  /* soc_mem_field_set(unit, EPNI_EVEC_TABLEm, data, EVEC_TABLE_DATAf, &tmp);*/

  res = soc_mem_write(
          unit,
          EPNI_EVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset/2,
          data
        );
  /* EVEC and native EVEC are duplicated */
  if (SOC_IS_JERICHO_PLUS(unit)) {

      tmp = 0; 
      entry = 0; 
      ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_ENTRY_SIZE);

      res = soc_mem_read(
              unit,
              EPNI_NATIVE_EVEC_TABLEm,
              MEM_BLOCK_ANY,
              entry_offset/2,
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

      entry = (entry_offset & 0x1) * (ARAD_PP_EPNI_NATIVE_EGRESS_EDIT_CMD_TBL_FLD_SIZE); 

      tmp = ARAD_PP_EPNI_EGRESS_EDIT_CMD_TBL_INFO(unit, 
                        tbl_data->outer_tpid_index, tbl_data->inner_tpid_index, \
                        tbl_data->outer_vid_source, tbl_data->inner_vid_source, \
                        tbl_data->outer_pcp_dei_source, tbl_data->inner_pcp_dei_source, \
                        tbl_data->tags_to_remove, \
                        0);

      soc_sand_bitstream_set_any_field(&tmp,entry,ARAD_PP_EPNI_NATIVE_EGRESS_EDIT_CMD_TBL_FLD_SIZE,data);

      res = soc_mem_write(
              unit,
              EPNI_NATIVE_EVEC_TABLEm,
              MEM_BLOCK_ANY,
              entry_offset/2,
              data
            );
  }
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_egress_edit_cmd_tbl_set_unsafe()", entry_offset, 0);
}
uint32
  arad_pp_epni_ingress_vlan_edit_command_map_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_IVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
    );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          tbl_data->tpid_profile_link   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  TPID_PROFILEf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

          tbl_data->edit_command_outer_vid_source   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  OUTER_VID_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

          tbl_data->edit_command_outer_pcp_dei_source   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  OUTER_PCP_DEI_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

          tbl_data->edit_command_inner_vid_source   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  INNER_VID_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

          tbl_data->edit_command_inner_pcp_dei_source   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  INNER_PCP_DEI_SRCf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);

          tbl_data->edit_command_bytes_to_remove   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  TAGS_TO_REMOVEf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

          tbl_data->outer_tpid_ndx   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  OUTER_TPID_INDEXf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 100, exit);

          tbl_data->inner_tpid_ndx   = soc_mem_field32_get(
                  unit,
                  EPNI_IVEC_TABLEm,
                  data,
                  INNER_TPID_INDEXf);
  SOC_SAND_CHECK_FUNC_RESULT(res, 110, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_ingress_vlan_edit_command_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_ingress_vlan_edit_command_map_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_INGRESS_VLAN_EDIT_COMMAND_MAP_TBL_ENTRY_SIZE);
            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          TPID_PROFILEf,
          tbl_data->tpid_profile_link );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          OUTER_VID_SRCf,
          tbl_data->edit_command_outer_vid_source );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          OUTER_PCP_DEI_SRCf,
          tbl_data->edit_command_outer_pcp_dei_source );
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          INNER_VID_SRCf,
          tbl_data->edit_command_inner_vid_source );
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          INNER_PCP_DEI_SRCf,
          tbl_data->edit_command_inner_pcp_dei_source );
  SOC_SAND_CHECK_FUNC_RESULT(res, 80, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          TAGS_TO_REMOVEf,
          tbl_data->edit_command_bytes_to_remove );
  SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          OUTER_TPID_INDEXf,
          tbl_data->outer_tpid_ndx );
  SOC_SAND_CHECK_FUNC_RESULT(res, 100, exit);

            soc_mem_field32_set(
          unit,
          EPNI_IVEC_TABLEm,
          data,
          INNER_TPID_INDEXf,
          tbl_data->inner_tpid_ndx );
  SOC_SAND_CHECK_FUNC_RESULT(res, 110, exit);

  res = soc_mem_write(
          unit,
          EPNI_IVEC_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 120, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_ingress_vlan_edit_command_map_tbl_set_unsafe()", entry_offset, 0);
}


#define ARAD_PP_EPNI_EXP_REMARK_TBL_ENTRY_SIZE 2

uint32
  arad_pp_epni_exp_remark_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_EXP_REMARK_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_EXP_REMARK_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_EXP_REMARK_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_EXP_REMARK_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_EXP_REMARK_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_EXP_REMARKm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->exp_remark_data = soc_mem_field32_get(unit, EPNI_EXP_REMARKm, data, EXP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_exp_remark_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_exp_remark_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_EXP_REMARK_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_EXP_REMARK_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_EXP_REMARK_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_EXP_REMARK_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_EXP_REMARKm, data, EXP_REMARK_DATAf, tbl_data->exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_EXP_REMARKm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_exp_remark_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_DSCP_REMARK_TBL_ENTRY_SIZE 2

uint32
  arad_pp_epni_dscp_remark_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_DSCP_REMARK_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_DSCP_REMARK_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_DSCP_REMARK_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_DSCP_REMARK_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_DSCP_REMARK_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_DSCP_REMARKm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_remark_data = soc_mem_field32_get(unit, EPNI_DSCP_REMARKm, data, DSCP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_dscp_remark_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_dscp_remark_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_DSCP_REMARK_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_DSCP_REMARK_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_DSCP_REMARK_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_DSCP_REMARK_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_DSCP_REMARKm, data, DSCP_REMARK_DATAf, tbl_data->dscp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_DSCP_REMARKm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_dscp_remark_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_epni_remark_mpls_to_exp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_MPLS_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_MPLS_TO_EXPm, data, REMARK_MPLS_TO_EXPf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_mpls_to_exp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_mpls_to_exp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_MPLS_TO_EXP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_MPLS_TO_EXPm, data, REMARK_MPLS_TO_EXPf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_MPLS_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_mpls_to_exp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_epni_remark_mpls_to_dscp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_GET_UNSAFE);
    
  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_MPLS_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_MPLS_TO_DSCPm, data, REMARK_MPLS_TO_DSCPf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_mpls_to_dscp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_mpls_to_dscp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_MPLS_TO_DSCP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_MPLS_TO_DSCPm, data, REMARK_MPLS_TO_DSCPf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_MPLS_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_mpls_to_dscp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_epni_remark_ipv6_to_exp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_IPV6_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_IPV6_TO_EXPm, data, EXP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv6_to_exp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_ipv6_to_exp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV6_TO_EXP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_IPV6_TO_EXPm, data, EXP_REMARK_DATAf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_IPV6_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv6_to_exp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_ENTRY_SIZE 2

uint32
  arad_pp_epni_remark_ipv6_to_dscp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_IPV6_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_IPV6_TO_DSCPm, data, EXP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv6_to_dscp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_ipv6_to_dscp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV6_TO_DSCP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_IPV6_TO_DSCPm, data, EXP_REMARK_DATAf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_IPV6_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv6_to_dscp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_epni_remark_ipv4_to_exp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_IPV4_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_IPV4_TO_EXPm, data, EXP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv4_to_exp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_ipv4_to_exp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV4_TO_EXP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_IPV4_TO_EXPm, data, EXP_REMARK_DATAf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_IPV4_TO_EXPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv4_to_exp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_ENTRY_SIZE 2

uint32
  arad_pp_epni_remark_ipv4_to_dscp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_REMARK_IPV4_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->dscp_exp_remark_data = soc_mem_field32_get(unit, EPNI_REMARK_IPV4_TO_DSCPm, data, EXP_REMARK_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv4_to_dscp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_remark_ipv4_to_dscp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_REMARK_IPV4_TO_DSCP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_REMARK_IPV4_TO_DSCPm, data, EXP_REMARK_DATAf, tbl_data->dscp_exp_remark_data);

  res = soc_mem_write(
          unit,
          EPNI_REMARK_IPV4_TO_DSCPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_remark_ipv4_to_dscp_tbl_set_unsafe()", entry_offset, 0);
}



STATIC uint32
  arad_pp_ihb_tcam_tbl_bank_offset_get(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           hw_offset,
    SOC_SAND_OUT  uint32                           *bank_offset
  )
{
    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_BANK_OFFSET_GET);

    if (bank_ndx >= SOC_DPP_DEFS_GET_TCAM_NOF_BANKS(unit)) {
          SOC_SAND_SET_ERROR_CODE(ARAD_TCAM_BANK_NDX_OUT_OF_RANGE_ERR, 10, exit); /* incorrect bank id */
    } else {
        /* nof tcam big bank lines is equal to nof tcam small banks line ini all devices
         * following code works for both big/small tcam bank indexes*/
        *bank_offset = (((bank_ndx * SOC_DPP_DEFS_GET(unit, nof_tcam_big_bank_lines)) + hw_offset) * 2);
    }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_ihb_tcam_tbl_bank_offset_get()", 0, 0);
}

uint32
  arad_pp_ihb_tcam_tbl_read_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           entry_offset,
    SOC_SAND_OUT   ARAD_PP_IHB_TCAM_BANK_TBL_DATA    *tcam_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    hw_offset,
    data_index,
    nof_words,
    nof_entries_in_line_w = nof_entries_in_line,
    idx,
    valid_fld;
  soc_reg_above_64_val_t
    mem_val,
    data_out;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TCAM_TBL_READ_UNSAFE);

  
  sal_memset(tcam_data,0x0, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));
 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line)
  */
  if (nof_entries_in_line == 0 || nof_entries_in_line > 3)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }

  if(nof_entries_in_line == ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE) {
      nof_entries_in_line_w = 1;
  }

 /*
  * in case there is two words per line which word to use.
  */
  if (entry_offset >= nof_entries_in_line_w * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }
 /*
  * low word or high word
  */
  if (nof_entries_in_line_w == 1)
  {
    hw_offset = entry_offset;
  }
  else
  {
    hw_offset = entry_offset >> 1;
  }

  /* reading the key */
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  SOC_REG_ABOVE_64_CLEAR(mem_val);

#ifdef PLISIM /* Preserve logic for simulation */
  if (!SAL_BOOT_PLISIM) 
#endif
{
/* skip the command write if we are in crash crash recovery */
#ifdef CRASH_RECOVERY_SUPPORT
      if(!BCM_UNIT_DO_HW_READ_WRITE(unit))
#endif
      {
      soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x1);
      /*those fields should be set to zero. the mem_val is cleared before so it is not needed to zero their value 
        don't eraze this.     
      soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 0x0);
      soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
      soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);*/
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
      }
}

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 55, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));

#if defined(PLISIM) || defined(CRASH_RECOVERY_SUPPORT)
  if (SAL_BOOT_PLISIM || BCM_UNIT_DO_HW_READ_WRITE(unit)) {  
      /* Only in the Simulation */
      valid_fld = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_VALIDf);
  }
  else
#endif
  {
      valid_fld = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_VALIDf);
  }
 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-read: bank:%d entry:%d, entries in line: %d, "
                         " - Entry is valid: %d\n\r")), bank_ndx, entry_offset, nof_entries_in_line, valid_fld));

  SOC_REG_ABOVE_64_CLEAR(data_out);

  if(nof_entries_in_line_w == 1) {
    if(valid_fld != 0x3 && valid_fld!=0) {
      /* i.e. not all the entry is valid*/
      SOC_SAND_SET_ERROR_CODE(0, 60, exit);
    }
    tcam_data->valid = (valid_fld !=0);

#ifdef PLISIM   
    if (SAL_BOOT_PLISIM) {  
      /* Only in the Simulation */
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);
    }
    else
#endif
    {
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
    }

    SHR_BITCOPY_RANGE(tcam_data->value, 0, data_out, 2, 80);
    SHR_BITCOPY_RANGE(tcam_data->value, 80, data_out, 84, 80);
  }
  else
  {
#ifdef PLISIM
  if (SAL_BOOT_PLISIM) {
        /* Only in the Simulation */
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);  
    }
    else
#endif 
    {
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
    }
    if(entry_offset % 2 == 0) {

      tcam_data->valid = (valid_fld & 0x1) != 0;
      /* i.e. we should take the lsb 80 bits*/
      SHR_BITCOPY_RANGE(tcam_data->value, 0, data_out, 2, 80); 
    } else {

      tcam_data->valid = (valid_fld & 0x2) != 0;
      /* i.e. we should take the msb 80 bits*/
      SHR_BITCOPY_RANGE(tcam_data->value, 0, data_out, 84, 80);
    }
  }

  /* reading the mask */
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
  ++data_index;

  /*SOC_SAND_SOC_IF_ERROR_RETURN(res, 90, exit, READ_PPDB_A_TCAM_BANKm(unit, MEM_BLOCK_ANY, data_index, mem_val));*/
  SOC_REG_ABOVE_64_CLEAR(mem_val);

#ifdef PLISIM /* Preserve logic for simulation */
  if (!SAL_BOOT_PLISIM) 
#endif
{
/* skip the command write if we are in crash crash recovery */
#ifdef CRASH_RECOVERY_SUPPORT
      if(!BCM_UNIT_DO_HW_READ_WRITE(unit))
#endif
      {
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x1);
  /* those fields should be set to zero. the mem_val is cleared before so it is not needed to zero their value 
  don't eraze this. 
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);*/
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 100, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
      }
}

  SOC_REG_ABOVE_64_CLEAR(data_out);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 120, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
  SOC_REG_ABOVE_64_CLEAR(data_out);

  if(nof_entries_in_line_w == 1) {
#if defined(PLISIM) || defined(CRASH_RECOVERY_SUPPORT)
  if (SAL_BOOT_PLISIM || BCM_UNIT_DO_HW_READ_WRITE(unit)) {  

          /* Only in the Simulation */
            soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);
      }
      else
#endif
      {
          soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
      }
      SHR_BITCOPY_RANGE(tcam_data->mask, 0, data_out, 2, 80);
      SHR_BITCOPY_RANGE(tcam_data->mask, 80, data_out, 84, 80);
  }
  else
  {
#if defined(PLISIM) || defined(CRASH_RECOVERY_SUPPORT)
  if (SAL_BOOT_PLISIM || BCM_UNIT_DO_HW_READ_WRITE(unit)) {  
      /* Only in the Simulation */
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);
    }
    else 
#endif
    {
        soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
    }

    if(entry_offset % 2 == 0) {
      /* i.e. we should take the lsb 88 bits*/
      SHR_BITCOPY_RANGE(tcam_data->mask, 0, data_out, 2, 80); 
    } else {
      /* i.e. we should take the msb 88 bits*/
      SHR_BITCOPY_RANGE(tcam_data->mask, 0, data_out, 84, 82); 
    }
  }
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "before decode\n\r")));
  arad_tbl_access_buffer_print(tcam_data->value,ARAD_PP_IHB_TCAM_DATA_WIDTH);
  arad_tbl_access_buffer_print(tcam_data->mask,ARAD_PP_IHB_TCAM_DATA_WIDTH);
#endif
  /* convert mask
   * mask = ^read_mask | data; (Arad) 
   * mask = read_mask | data (Jericho) 
   */
  if(nof_entries_in_line_w == 1) {
      nof_words = 5;
  }
  else{
      nof_words = 3;
  }

  for(idx = 0; idx < nof_words; ++idx) {
      if (SOC_IS_JERICHO(unit)) {
          /* Different encoding in Jericho:can be seen only in RTL */
          tcam_data->mask[idx] = tcam_data->mask[idx] | tcam_data->value[idx];
      } else {
          tcam_data->mask[idx] = ~tcam_data->mask[idx] | tcam_data->value[idx];
      }
      
  }

  if(nof_words == 3) {
      SHR_BITCLR_RANGE(tcam_data->mask,80,16);
  }
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "after decode\n\r")));
#endif

  arad_tbl_access_tcam_print(tcam_data);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_tcam_tbl_read_unsafe()",0,0);
}

/* currently support only 80*/
uint32
  arad_pp_ihb_tcam_tbl_read_two_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           entry_offset,
    SOC_SAND_OUT   ARAD_PP_IHB_TCAM_BANK_TBL_DATA  tcam_data[2]
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    hw_offset,
    data_index,
    nof_words,
    nof_entries_in_line_w = nof_entries_in_line,
    idx,
    tcam_idx,
    valid_fld;
  soc_reg_above_64_val_t
    mem_val,
    data_out;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TCAM_TBL_READ_UNSAFE);

  
  sal_memset(&tcam_data[0],0x0, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));
  sal_memset(&tcam_data[1],0x0, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));
 /*
  * ONLY 80
  */
  if (nof_entries_in_line != 2)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }

 /*
  * in case there is two words per line which word to use.
  */
  if (entry_offset >= nof_entries_in_line_w * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }

  /* Always 80b key */
  hw_offset = entry_offset >> 1;

  /* raeding the key */
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  SOC_REG_ABOVE_64_CLEAR(mem_val);

#ifdef PLISIM
  if (!SAL_BOOT_PLISIM) 
#endif
{
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x1);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
}

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 55, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
#ifdef PLISIM   
    if (SAL_BOOT_PLISIM) {
      /* Only in the Simulation */
        valid_fld = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_VALIDf);
    }
    else 
#endif
    {
        valid_fld = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_VALIDf);
    }
 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-read: bank:%d entry:%d, entries in line: %d, "
                         " - Entry is valid: %d\n\r")), bank_ndx, entry_offset, nof_entries_in_line, valid_fld));

  SOC_REG_ABOVE_64_CLEAR(data_out);

  /* 80b key case */
#ifdef PLISIM   
  if (SAL_BOOT_PLISIM) {
    /* Only in the Simulation */
      soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);
  }
  else 
#endif
  {
      soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
  }

  /* first 80 */
  tcam_data[0].valid = (valid_fld & 0x1) != 0;
  SHR_BITCOPY_RANGE(tcam_data[0].value, 0, data_out, 2, 80); 

  /* second 80 */
  tcam_data[1].valid = (valid_fld & 0x2) != 0;
  SHR_BITCOPY_RANGE(tcam_data[1].value, 0, data_out, 84, 80);

  /* reading the mask */
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
  ++data_index;

  /*SOC_SAND_SOC_IF_ERROR_RETURN(res, 90, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));*/
  SOC_REG_ABOVE_64_CLEAR(mem_val);

#ifdef PLISIM
  if (!SAL_BOOT_PLISIM) 
#endif
  {
    soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 0x0);
    soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x1);
    soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
    soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);
    SOC_SAND_SOC_IF_ERROR_RETURN(res, 100, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
  }

  SOC_REG_ABOVE_64_CLEAR(data_out);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 120, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
  SOC_REG_ABOVE_64_CLEAR(data_out);

#ifdef PLISIM   
  if (SAL_BOOT_PLISIM) {
    /* Only in the Simulation */
      soc_mem_field_get(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, data_out);
  }
  else 
#endif
  {
      soc_mem_field_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_DOUTf, data_out);
  }
  
  /* i.e. we should take the lsb 88 bits*/
  SHR_BITCOPY_RANGE(tcam_data[0].mask, 0, data_out, 2, 80); 
  SHR_BITCOPY_RANGE(tcam_data[1].mask, 0, data_out, 84, 82); 

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "before decode 1\n\r")));
  arad_tbl_access_buffer_print(tcam_data[0].value,ARAD_PP_IHB_TCAM_DATA_WIDTH);
  arad_tbl_access_buffer_print(tcam_data[0].mask,ARAD_PP_IHB_TCAM_DATA_WIDTH);
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "before decode 2\n\r")));
  arad_tbl_access_buffer_print(tcam_data[1].value,ARAD_PP_IHB_TCAM_DATA_WIDTH);
  arad_tbl_access_buffer_print(tcam_data[1].mask,ARAD_PP_IHB_TCAM_DATA_WIDTH);
#endif
  /* convert mask
   * mask = ^read_mask | data; (Arad) 
   * mask = read_mask | data (Jericho) 
   */
  nof_words = 3;


  for(tcam_idx = 0; tcam_idx < 2; ++tcam_idx) {
      for(idx = 0; idx < nof_words; ++idx) {
          if (SOC_IS_JERICHO(unit)) {
              /* Different encoding in Jericho:can be seen only in RTL */
              tcam_data[tcam_idx].mask[idx] = tcam_data[tcam_idx].mask[idx] | tcam_data[tcam_idx].value[idx];
          } else {
              tcam_data[tcam_idx].mask[idx] = ~tcam_data[tcam_idx].mask[idx] | tcam_data[tcam_idx].value[idx];
          }
      }

      if(nof_words == 3) {
          SHR_BITCLR_RANGE(tcam_data[tcam_idx].mask,80,16);
      }
    #if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
      LOG_INFO(BSL_LS_SOC_MEM,
               (BSL_META_U(unit,
                           "after decode\n\r")));
    #endif
      arad_tbl_access_tcam_print(&tcam_data[tcam_idx]);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_read_two_unsafe()",0,0);
}



STATIC
  uint32
    arad_pp_ihb_tcam_entries_in_line_to_format(
        SOC_SAND_IN   uint32                           nof_entries_in_line
    )
{
    switch(nof_entries_in_line) {
    case 2:
        return 0;
    case ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE:
        return 3;
    case 1:
    default:
        return 1;
    }
    return 1;
}
    
/*
 * get the TCAM_CPU_CMD_WRf value
 */
uint32
  arad_pp_ihb_tcam_tbl_write_tcam_cpu_cmd_wrf_get(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           data_index
  )
{

    if (SOC_IS_JERICHO(unit)){
        return 0x3;
    } else {
        return 0x1;
    }
}
    
/*
 * Write a single line of the TCAM Bank table
 */
STATIC uint32
  arad_pp_ihb_tcam_tbl_write_single_line_mask(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           data_index,
    SOC_SAND_IN   uint32                           tcam_in_data_mask2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1]
  )
{
  uint32
    res = SOC_SAND_OK;
  soc_reg_above_64_val_t
    mem_val,
    fld_val;
    
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_WRITE_UNSAFE);

  SOC_REG_ABOVE_64_CLEAR(mem_val);

  /* In Jericho, TCAM_CPU_CMD_WRf is enlarged to allow independent 80b entry configurations */
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 
                      arad_pp_ihb_tcam_tbl_write_tcam_cpu_cmd_wrf_get(unit, data_index));
  /* those fields should be set to zero. the mem_val is cleared before so it is not needed to zero their value 
  don't erase this. */
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);

  SOC_REG_ABOVE_64_CLEAR(fld_val);
  sal_memcpy(fld_val, tcam_in_data_mask2, (ARAD_PP_IHB_TCAM_DATA_WIDTH+1) * sizeof(uint32));
  soc_mem_field_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, fld_val);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 70, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
{
    uint32
        print_indx;
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "write to address%08x data: \n\r"),data_index));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), mem_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
}
#endif

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_write_single_line_mask()",0,0);
}
    
/*
 * Write a single line of the TCAM Bank table
 */
STATIC uint32
  arad_pp_ihb_tcam_tbl_write_single_line_value(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           data_index,
    SOC_SAND_IN   uint32                           valid_fld,
    SOC_SAND_IN   uint32                           tcam_in_data_value2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1]
  )
{
  uint32
    res = SOC_SAND_OK;
  soc_reg_above_64_val_t
    mem_val,
    fld_val;
    
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_WRITE_UNSAFE);

  SOC_REG_ABOVE_64_CLEAR(mem_val);

  /* In Jericho, TCAM_CPU_CMD_WRf is enlarged to allow independent 80b entry configurations */
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 
                      arad_pp_ihb_tcam_tbl_write_tcam_cpu_cmd_wrf_get(unit, data_index));
    /* those fields should be set to zero. the mem_val is cleared before so it is not needed to zero their value 
  don't eraze this. */
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);

  SOC_REG_ABOVE_64_CLEAR(fld_val);

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
{
    uint32
        print_indx;
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "write to mem-val without DI %08x data: \n\r"),data_index));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), mem_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "tcam_in_data_value2: DI\n\r")));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), tcam_in_data_value2[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
}
#endif

  sal_memcpy(fld_val, tcam_in_data_value2, (ARAD_PP_IHB_TCAM_DATA_WIDTH+1) * sizeof(uint32));
  soc_mem_field_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, fld_val);
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
{
    uint32
        print_indx;
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "write to address%08x data: \n\r"),data_index));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), mem_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "fld_val\n\r")));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), fld_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
}
#endif

  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_VALIDf, valid_fld);
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
{
    uint32
        print_indx;
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "write to address%08x data: \n\r"),data_index));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), mem_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
}
#endif
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, MEM_BLOCK_ANY, data_index, mem_val));
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
{
    uint32
        print_indx;
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "write to address%08x data: \n\r"),data_index));
    for(print_indx = 6;print_indx>0;--print_indx) {
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "%08x"), mem_val[print_indx-1]));
    }
    LOG_INFO(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         "\n\r")));
}
#endif


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_write_single_line_value()",0,0);
}
    


/*
 * Write to Tcam Banks from block IHB,
 * takes semaphore
 */
uint32
  arad_pp_ihb_tcam_tbl_write_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           entry_offset,
    SOC_SAND_IN   ARAD_PP_IHB_TCAM_BANK_TBL_DATA   *tcam_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    hw_offset,
    data_index,
    indx,
    entry_mode,
    old_place=0,
    new_place=0,
    entry_mode_mask,
    nof_words,
    nof_entries_in_line_w = nof_entries_in_line,
    valid_fld;
  uint32
      tcam_in_data_mask[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_value[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_mask2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_value2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1];
  ARAD_PP_IHB_TCAM_BANK_TBL_DATA
      read_tcam_data;
  ARAD_PP_IHB_TCAM_BANK_TBL_DATA
      write_tcam_data;
    
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_WRITE_UNSAFE);

 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line) 
  *  nof_entries_in_line      width
  *  --------------------------------
  *  1                  160
  *  2                  80
  *  ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE                  320
  */
  if (nof_entries_in_line == 0 || ((nof_entries_in_line > 2) && (nof_entries_in_line !=ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE)))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }
  if(nof_entries_in_line == ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE) {
      nof_entries_in_line_w = 1;
  }
 /*
  * in case there are two words per line which word to use.
  */
  if (entry_offset >= nof_entries_in_line_w * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }
 /*
  * low word or high word
  */
  if (nof_entries_in_line_w == 1)
  {
    hw_offset = entry_offset; /* 160b or 320b */
  }
  else if (nof_entries_in_line_w == 2)
  {
    hw_offset = entry_offset >> 1;
  }
  else{
      SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 21, exit);
  }

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-write: bank:%d entry:%d, entries in line: %d\n\r")), bank_ndx, entry_offset, nof_entries_in_line));
  arad_tbl_access_tcam_print(tcam_data);

  
  /* finally we will write, write_tcam_data */
  sal_memset(&write_tcam_data,0x0, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));


  /* if mode is two entries in line then read other side */
  if(nof_entries_in_line == 2) {
      valid_fld = 0;

      /* place: 0 or 1 */
      new_place = entry_offset%2;
      old_place = (uint32)(1 - new_place);

      res = 
        arad_pp_ihb_tcam_tbl_read_unsafe(
            unit,
            bank_ndx,
            nof_entries_in_line,
            (entry_offset%2)?entry_offset-1:entry_offset+1, /* my second half */
            &read_tcam_data
        );
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

      /* set old valid bit into valid bits */
      if(read_tcam_data.valid) {
          valid_fld = (1 << old_place);
      }
      /* set new valid bit into valid bits */
      valid_fld |= (tcam_data->valid << new_place);

      /* set old and new mask value parts according to placement */
      SHR_BITCOPY_RANGE(write_tcam_data.mask,80*new_place,tcam_data->mask,0,80);
      SHR_BITCOPY_RANGE(write_tcam_data.value,80*new_place,tcam_data->value,0,80);
      if(read_tcam_data.valid) {
          SHR_BITCOPY_RANGE(write_tcam_data.mask,80*old_place,read_tcam_data.mask,0,80);
          SHR_BITCOPY_RANGE(write_tcam_data.value,80*old_place,read_tcam_data.value,0,80);
      }
      write_tcam_data.valid = valid_fld != 0;
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "full line: \n\r")));
  arad_tbl_access_tcam_print(&write_tcam_data);
#endif
      
  }
  else if (nof_entries_in_line_w == 1){
      sal_memcpy(&write_tcam_data, tcam_data, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));
      if(tcam_data->valid) {
          valid_fld = 3;
      }
      else{
          valid_fld = 0;
      }
  }
  else{
      SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 21, exit);/* 320 not implemented yet*/
  }
  entry_mode = arad_pp_ihb_tcam_entries_in_line_to_format(nof_entries_in_line);

 /*
  * calc key and mask 
  * KEY1 (mask) = key | ~mask (Arad) 
  * KEY1 (mask) = ~key & mask (Jericho) 
  * KEY0 (data) = key & mask
  */
  sal_memset(tcam_in_data_mask,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));
  sal_memset(tcam_in_data_value,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));

  sal_memset(tcam_in_data_mask2,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));
  sal_memset(tcam_in_data_value2,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));

  SHR_BITCOPY_RANGE(tcam_in_data_mask,2,write_tcam_data.mask,0,80);
  SHR_BITCOPY_RANGE(tcam_in_data_value,2,write_tcam_data.value,0,80);

  SHR_BITCOPY_RANGE(tcam_in_data_mask,84,write_tcam_data.mask,80,80);
  SHR_BITCOPY_RANGE(tcam_in_data_value,84,write_tcam_data.value,80,80);

  /* bits 0-1, and 82-83 for entry type */
  entry_mode_mask = 0x3;
  SHR_BITCOPY_RANGE(tcam_in_data_mask,0,&entry_mode_mask,0,2);
  SHR_BITCOPY_RANGE(tcam_in_data_mask,82,&entry_mode_mask,0,2);

  SHR_BITCOPY_RANGE(tcam_in_data_value,0,&entry_mode,0,2);
  SHR_BITCOPY_RANGE(tcam_in_data_value,82,&entry_mode,0,2);
  
  /* nof_words = (ARAD_PP_IHB_TCAM_DATA_WIDTH + (nof_entries_in_line -  1)) / nof_entries_in_line;*/
  nof_words = ARAD_PP_IHB_TCAM_DATA_WIDTH+1;
  for (indx = 0; indx < nof_words; ++indx)
  {
      if (SOC_IS_JERICHO(unit)) {
          /* Different encoding in Jericho:can be seen only in RTL */
          tcam_in_data_mask2[indx] = (~(tcam_in_data_value[indx])) & tcam_in_data_mask[indx];
      } else {
          tcam_in_data_mask2[indx] = tcam_in_data_value[indx] | ~(tcam_in_data_mask[indx]);
      }
    tcam_in_data_value2[indx] = tcam_in_data_value[indx] & tcam_in_data_mask[indx];
  }

  SHR_BITCLR_RANGE(tcam_in_data_mask2,164,28);
  SHR_BITCLR_RANGE(tcam_in_data_value2,164,28);

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "after encode: \n\r")));
  arad_tbl_access_buffer_print(tcam_in_data_value, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
  arad_tbl_access_buffer_print(tcam_in_data_mask, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
#endif

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "after shifting: \n\r")));
  arad_tbl_access_buffer_print(tcam_in_data_value2, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
  arad_tbl_access_buffer_print(tcam_in_data_mask2, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
#endif

  /* 
   * In order not to influence the traffic: 
   * - for a valid entry, write the mask first, and then data + valid 
   * - for an invalid entry,  write the data + valid first, and then mask
   */ 
  if (tcam_data->valid) {
      res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
      SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);
      ++data_index; /* ++ for mask */
      /* writing the mask first not to influence traffic */
      res = arad_pp_ihb_tcam_tbl_write_single_line_mask(
                unit,
                bank_ndx,
                data_index,
                tcam_in_data_mask2
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 28, exit);

      /* writing the key */
      res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
      SOC_SAND_CHECK_FUNC_RESULT(res, 29, exit);  
      res = arad_pp_ihb_tcam_tbl_write_single_line_value(
                unit,
                bank_ndx,
                data_index,
                valid_fld,
                tcam_in_data_value2
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else { /* tcam_data->valid invalid */
      /* writing the key */
      res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
      SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);
      res = arad_pp_ihb_tcam_tbl_write_single_line_value(
                unit,
                bank_ndx,
                data_index,
                valid_fld,
                tcam_in_data_value2
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

      res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
      SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);
      ++data_index; /* ++ for mask */
      /* writing the mask first not to influence traffic */
      res = arad_pp_ihb_tcam_tbl_write_single_line_mask(
                unit,
                bank_ndx,
                data_index,
                tcam_in_data_mask2
              );
      SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_write_unsafe()",0,0);
}


/*
 * Write to Tcam Banks from block IHB, use only for 80 bits!
 * takes semaphore
 */
uint32
  arad_pp_ihb_tcam_tbl_write_two_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           entry_offset,
    SOC_SAND_IN   ARAD_PP_IHB_TCAM_BANK_TBL_DATA   tcam_data[2]
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    hw_offset,
    data_index,
    indx,
    entry_mode,
    entry_mode_mask,
    nof_words,
    nof_entries_in_line_w = nof_entries_in_line,
    valid_fld;
  uint32
      tcam_in_data_mask[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_value[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_mask2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1],
      tcam_in_data_value2[ARAD_PP_IHB_TCAM_DATA_WIDTH+1];
  ARAD_PP_IHB_TCAM_BANK_TBL_DATA
      write_tcam_data;
    
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_WRITE_UNSAFE);

 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line) 
  *  nof_entries_in_line      width
  *  --------------------------------
  *  1                  160
  *  2                  80
  *  ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE                  320
  */
  if (nof_entries_in_line != 2 )
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }

 /*
  * in case there are two words per line which word to use.
  */
  if (entry_offset >= nof_entries_in_line_w * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }
 /*
  * low word or high word
  */
 hw_offset = entry_offset >> 1;

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-write: bank:%d entry:%d, entries in line: %d\n\r")), bank_ndx, entry_offset, nof_entries_in_line));
  arad_tbl_access_tcam_print(tcam_data);

  
  /* finally we will write, write_tcam_data */
  sal_memset(&write_tcam_data,0x0, sizeof(ARAD_PP_IHB_TCAM_BANK_TBL_DATA));


  /* if mode is two entries in line then read other side */

  /* set valid bit into valid bits */
  valid_fld = tcam_data[0].valid | (tcam_data[1].valid << 1);

  /* set old and new mask value parts according to placement */
  SHR_BITCOPY_RANGE(write_tcam_data.mask,0,tcam_data[0].mask,0,80);
  SHR_BITCOPY_RANGE(write_tcam_data.value,0,tcam_data[0].value,0,80);
  SHR_BITCOPY_RANGE(write_tcam_data.mask,80,tcam_data[1].mask,0,80);
  SHR_BITCOPY_RANGE(write_tcam_data.value,80,tcam_data[1].value,0,80);
#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "full line: \n\r")));
  arad_tbl_access_tcam_print(&write_tcam_data);
#endif

  entry_mode = arad_pp_ihb_tcam_entries_in_line_to_format(nof_entries_in_line);

 /*
  * calc key and mask 
  * KEY1 (mask) = key | ~mask (Arad) 
  * KEY1 (mask) = ~key & mask (Jericho) 
  * KEY0 (data) = key & mask
  */
  sal_memset(tcam_in_data_mask,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));
  sal_memset(tcam_in_data_value,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));

  
  sal_memset(tcam_in_data_mask2,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));
  sal_memset(tcam_in_data_value2,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));

  SHR_BITCOPY_RANGE(tcam_in_data_mask,2,write_tcam_data.mask,0,80);
  SHR_BITCOPY_RANGE(tcam_in_data_value,2,write_tcam_data.value,0,80);

  SHR_BITCOPY_RANGE(tcam_in_data_mask,84,write_tcam_data.mask,80,80);
  SHR_BITCOPY_RANGE(tcam_in_data_value,84,write_tcam_data.value,80,80);

  /* bits 0-1, and 82-83 for entry type */
  entry_mode_mask = 0x3;
  SHR_BITCOPY_RANGE(tcam_in_data_mask,0,&entry_mode_mask,0,2);
  SHR_BITCOPY_RANGE(tcam_in_data_mask,82,&entry_mode_mask,0,2);

  SHR_BITCOPY_RANGE(tcam_in_data_value,0,&entry_mode,0,2);
  SHR_BITCOPY_RANGE(tcam_in_data_value,82,&entry_mode,0,2);
  
  /* nof_words = (ARAD_PP_IHB_TCAM_DATA_WIDTH + (nof_entries_in_line -  1)) / nof_entries_in_line;*/
  nof_words = ARAD_PP_IHB_TCAM_DATA_WIDTH+1;
  for (indx = 0; indx < nof_words; ++indx)
  {
      if (SOC_IS_JERICHO(unit)) {
          /* Different encoding in Jericho:can be seen only in RTL */
          tcam_in_data_mask2[indx] = (~(tcam_in_data_value[indx])) & tcam_in_data_mask[indx];
      } else {
          tcam_in_data_mask2[indx] = tcam_in_data_value[indx] | ~(tcam_in_data_mask[indx]);
      }
    tcam_in_data_value2[indx] = tcam_in_data_value[indx] & tcam_in_data_mask[indx];
  }

  SHR_BITCLR_RANGE(tcam_in_data_mask2,164,28);
  SHR_BITCLR_RANGE(tcam_in_data_value2,164,28);

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "after encode: \n\r")));
  arad_tbl_access_buffer_print(tcam_in_data_value, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
  arad_tbl_access_buffer_print(tcam_in_data_mask, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
#endif

#if ARAD_PP_TBL_ACC_TCAM_LOW_LEVEL_DEBUG_PRINT
  LOG_INFO(BSL_LS_SOC_MEM,
           (BSL_META_U(unit,
                       "after shifting: \n\r")));
  arad_tbl_access_buffer_print(tcam_in_data_value2, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
  arad_tbl_access_buffer_print(tcam_in_data_mask2, ARAD_PP_IHB_TCAM_DATA_WIDTH+1);
#endif

  /* 
   * This function is mainly used to invalidate entries, 
   * so write the valid bit first 
   */
  /* writing the key */
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);
  res = arad_pp_ihb_tcam_tbl_write_single_line_value(
            unit,
            bank_ndx,
            data_index,
            valid_fld,
            tcam_in_data_value2
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, hw_offset, &data_index);
  SOC_SAND_CHECK_FUNC_RESULT(res, 31, exit);
  ++data_index; /* ++ for mask */
  /* writing the mask first not to influence traffic */
  res = arad_pp_ihb_tcam_tbl_write_single_line_mask(
            unit,
            bank_ndx,
            data_index,
            tcam_in_data_mask2
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_write_two_unsafe()",0,0);
}

uint32
  arad_pp_ihb_pmf_pass_2_key_update_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_PMF_PASS_2_KEY_UPDATEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->action_select = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, ACTION_SELECTf);
  tbl_data->enable_update_key = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, ENABLE_UPDATE_KEYf);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      soc_field_t flds[] = {
              KEY_A_LEM_OPERATION_SELECTf, 
              KEY_B_LEM_OPERATION_SELECTf, 
              KEY_C_LEM_OPERATION_SELECTf, 
              KEY_D_LEM_OPERATION_SELECTf
      };
      uint32 *fld_vals[4];
      int i = 0;
      int fld_desc_idx;

      tbl_data->key_d_use_compare_result = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_USE_COMPARE_RESULTf);  
      tbl_data->key_d_mask_select = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_MASK_SELECTf);  
      tbl_data->key_d_xor_enable = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_XOR_ENABLEf);  

      /* LEM operation select per key. */
      fld_vals[i++] = &tbl_data->key_a_lem_operation_select;
      fld_vals[i++] = &tbl_data->key_b_lem_operation_select;
      fld_vals[i++] = &tbl_data->key_c_lem_operation_select;
      fld_vals[i++] = &tbl_data->key_d_lem_operation_select;

      for (fld_desc_idx = 0; fld_desc_idx < sizeof(flds) / sizeof(flds[0]); fld_desc_idx++) {
          *(fld_vals[fld_desc_idx]) = soc_mem_field32_get(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, flds[fld_desc_idx]);
      }
  }
#endif

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_pass_2_key_update_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_pmf_pass_2_key_update_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PMF_PASS_2_KEY_UPDATE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, ACTION_SELECTf, tbl_data->action_select);
  soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, ENABLE_UPDATE_KEYf, tbl_data->enable_update_key);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      soc_field_t flds[] = {
          KEY_A_LEM_OPERATION_SELECTf, 
          KEY_B_LEM_OPERATION_SELECTf, 
          KEY_C_LEM_OPERATION_SELECTf, 
          KEY_D_LEM_OPERATION_SELECTf
      };
      uint32 fld_vals[4];
      int i = 0;
      int fld_desc_idx;

      soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_USE_COMPARE_RESULTf, tbl_data->key_d_use_compare_result);
      soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_MASK_SELECTf, tbl_data->key_d_mask_select);
      soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, KEY_D_XOR_ENABLEf, tbl_data->key_d_xor_enable);

      /* LEM operation select per key. */
      fld_vals[i++] = tbl_data->key_a_lem_operation_select;
      fld_vals[i++] = tbl_data->key_b_lem_operation_select;
      fld_vals[i++] = tbl_data->key_c_lem_operation_select;
      fld_vals[i++] = tbl_data->key_d_lem_operation_select;

      for (fld_desc_idx = 0; fld_desc_idx < sizeof(flds) / sizeof(flds[0]); fld_desc_idx++) {
          soc_mem_field32_set(unit, IHB_PMF_PASS_2_KEY_UPDATEm, data, flds[fld_desc_idx], fld_vals[fld_desc_idx]);
      }
  }
#endif

  res = soc_mem_write(
          unit,
          IHB_PMF_PASS_2_KEY_UPDATEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pmf_pass_2_key_update_tbl_set_unsafe()", entry_offset, 0);
}




/*
 * Read to Tcam Banks from block IHB,
 * doesn't take semaphore.
 */
uint32
  arad_pp_ihb_tcam_access_profile_tbl_read_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           access_profile_id,
    SOC_SAND_OUT  ARAD_PP_IHB_TCAM_ACCESS_PROFILE_TBL_DATA    *data
  )
{
  uint32
    mem_val[2] = {0},
    res;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_ACCESS_PROFILE_TBL_READ_UNSAFE);
  SOC_SAND_CHECK_NULL_INPUT(data);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, READ_PPDB_A_TCAM_ACCESS_PROFILEm(unit, MEM_BLOCK_ANY, access_profile_id, mem_val));
  soc_mem_field_get(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ACTION_BITMAPf, &data->action_bitmap);
  soc_mem_field_get(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, KEY_SIZEf, &data->key_size);
  soc_mem_field_get(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, IS_DIRECTf, &data->is_direct);
  soc_mem_field_get(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ANDf, &data->prefix_and);
  soc_mem_field_get(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ORf, &data->prefix_or);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_access_profile_tbl_read_unsafe()",access_profile_id,0);
}

/*
 * Write to Tcam Banks from block IHB,
 * doesn't take semaphore.
 */
uint32
  arad_pp_ihb_tcam_access_profile_tbl_write_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           access_profile_id,
    SOC_SAND_IN   ARAD_PP_IHB_TCAM_ACCESS_PROFILE_TBL_DATA     *data
  )
{
  uint32
    mem_val[2] = {0},
    fld_val,
    res;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_ACCESS_PROFILE_TBL_WRITE_UNSAFE);
  SOC_SAND_CHECK_NULL_INPUT(data);

  
  fld_val = data->action_bitmap;
  soc_mem_field_set(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ACTION_BITMAPf, &fld_val);
  fld_val = data->key_size;
  soc_mem_field_set(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, KEY_SIZEf, &fld_val);
  fld_val = data->is_direct;
  soc_mem_field_set(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, IS_DIRECTf, &fld_val);
  fld_val = data->prefix_and;
  soc_mem_field_set(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ANDf, &fld_val);
  fld_val = data->prefix_or;
  soc_mem_field_set(unit, PPDB_A_TCAM_ACCESS_PROFILEm, mem_val, ORf, &fld_val);
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, WRITE_PPDB_A_TCAM_ACCESS_PROFILEm(unit, MEM_BLOCK_ANY, access_profile_id, mem_val));
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_access_profile_tbl_write_unsafe()",0,0);
}

uint32
  arad_pp_ihb_tcam_pd_profile_tbl_read_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           pd_profile_id,
    SOC_SAND_OUT  ARAD_PP_IHB_TCAM_PD_PROFILE_TBL_DATA    *data
  )
{
  uint32
    mem_val = 0,
    res;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_PD_PROFILE_TBL_READ_UNSAFE);
  SOC_SAND_CHECK_NULL_INPUT(data);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, READ_PPDB_A_TCAM_PD_PROFILEm(unit, MEM_BLOCK_ANY, pd_profile_id, &mem_val));
  soc_mem_field_get(unit, PPDB_A_TCAM_PD_PROFILEm, &mem_val, BITMAPf, &data->bitmap);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_pd_profile_tbl_read_unsafe()",0,0);
}

uint32
  arad_pp_ihb_tcam_pd_profile_tbl_write_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           pd_profile_id,
    SOC_SAND_IN   ARAD_PP_IHB_TCAM_PD_PROFILE_TBL_DATA     *data
  )
{
  uint32
    mem_val = 0,
    fld_val,
    res;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_PD_PROFILE_TBL_WRITE_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(data);
  
  fld_val = data->bitmap;
  soc_mem_field_set(unit, PPDB_A_TCAM_PD_PROFILEm, &mem_val, BITMAPf, &fld_val);
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 20, exit, WRITE_PPDB_A_TCAM_PD_PROFILEm(unit, MEM_BLOCK_ANY, pd_profile_id, &mem_val));

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_pd_profile_tbl_write_unsafe()",0,0);
}

/*
 * Set the valid bit in the TCAM
 */
uint32
  arad_pp_ihb_tcam_invalid_bit_set_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           entry_offset
  )
{
  uint32
    res = SOC_SAND_OK,
    hw_offset,
    nof_entries_in_line_w = nof_entries_in_line;
  ARAD_PP_IHB_TCAM_BANK_TBL_DATA 
      read_tcam_data[2];
  uint64
    tcam_manager_1;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_VALID_BIT_TBL_SET_UNSAFE);

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-write-valid: bank:%d entry:%d, entries in line: %d, \n\r")), bank_ndx, entry_offset, nof_entries_in_line));

 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line)
  */
  if (nof_entries_in_line == 0 || nof_entries_in_line > 3)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }
  if(nof_entries_in_line == ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE) {
      nof_entries_in_line_w = 1;
  }
 /*
  * in case there is two words per line which word to use.
  */
  if (entry_offset >= nof_entries_in_line_w * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }
 /*
  * low word or high word
  */
  if (nof_entries_in_line_w == 1)
  {
    hw_offset = entry_offset;
  }
  else
  {
    hw_offset = entry_offset >> 1;
  }

  /* for 80 bits, do not use the TCAM manager - it will disable both entries in the same line */
  if(nof_entries_in_line == 2) {
      res = arad_pp_ihb_tcam_tbl_read_two_unsafe(
                unit,
                bank_ndx,
                nof_entries_in_line,
                (entry_offset%2)?entry_offset-1:entry_offset, /* even entry /base */
                read_tcam_data
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

      read_tcam_data[entry_offset%2].valid = 0;

      res = arad_pp_ihb_tcam_tbl_write_two_unsafe(
                unit,
                bank_ndx,
                nof_entries_in_line,
                (entry_offset%2)?entry_offset-1:entry_offset, /* even entry /base */
                read_tcam_data
            );
          SOC_SAND_CHECK_FUNC_RESULT(res, 24, exit);

      goto exit;
  }
  /* for 160 / 320 bits */
  else {
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 30, exit, READ_PPDB_A_TCAM_MANAGER_1r(unit, &tcam_manager_1));
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_SRCf, hw_offset);
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_DSTf, hw_offset);
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_RANGEf, 1);
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_BANKf, bank_ndx);
      /* Indicate if 320b entry */
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_MOVE_COUPLEf, 
                            (nof_entries_in_line == ARAD_PP_IHB_TCAM_HALF_ENTRY_IN_LINE));
      soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_INVALIDATEf, 0x1); /* Always invalidate */
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_MANAGER_1r(unit, tcam_manager_1));

      SOC_SAND_SOC_IF_ERROR_RETURN(res, 50, exit, WRITE_PPDB_A_TCAM_MANAGER_0r(unit, 0x1));

      /* Wait trigger to become 0 */
      res = arad_polling(
              unit,
              ARAD_TIMEOUT,
              ARAD_MIN_POLLS,
              PPDB_A_TCAM_MANAGER_0r,
              REG_PORT_ANY,
              0,
              TCAM_MANAGER_TRIGGERf,
              0
            ); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_invalid_bit_set_unsafe()",0,0);
}

/*
 * Get indirect table Tcam Bank A from block IHB,
 * takes semaphore
 */
uint32
  arad_pp_ihb_tcam_tbl_flush_unsafe(
    SOC_SAND_IN   int          unit,
    SOC_SAND_IN   uint32          bank_ndx
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_FLUSH_UNSAFE);

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "Invalidate bank: %d \n\r")), bank_ndx));

  /* we should set the bit of the bank index */
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, WRITE_PPDB_A_TCAM_RESET_BLOCK_BITMAPr(unit, 1 << bank_ndx));

  /*need sleep */
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, WRITE_PPDB_A_TCAM_RESET_BLOCK_BITMAPr(unit, 0));


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_flush_unsafe()",0,0);
}

/*
 *  Compare operation for a single TCAM bank. Note that only 72b and 144b are supported by this
 *  operation.
 */
uint32
  arad_pp_ihb_tcam_tbl_compare_unsafe(
    SOC_SAND_IN   int                             unit,
    SOC_SAND_IN   uint32                             bank_ndx,
    SOC_SAND_IN   uint32                             nof_entries_in_line,
    SOC_SAND_IN   ARAD_PP_IHB_TCAM_BANK_TBL_DATA     *compare_data,
    SOC_SAND_OUT  ARAD_PP_IHB_TCAM_COMPARE_DATA      *found_data
  )
{
  uint32
    bank_offset,
    res = SOC_SAND_OK;
  soc_reg_above_64_val_t
    mem_val,
    fld_val;
  uint32
      entry_mode,
      tcam_in_data_value[ARAD_PP_IHB_TCAM_DATA_WIDTH+1];


  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_COMPARE_UNSAFE);

 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line)
  */
  if (nof_entries_in_line == 0 || nof_entries_in_line > 3)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }



  SOC_REG_ABOVE_64_CLEAR(mem_val);

  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_CMPf, 0x1);

  /* 
  those fields should be set to zero. the mem_val is cleared before so it is not needed to zero their value 
  don't eraze this.  
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_WRf, 0x0);
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RDf, 0x0);  
  soc_mem_field32_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_RESERVEDf, 0x0);*/

  SOC_REG_ABOVE_64_CLEAR(fld_val);
  sal_memset(tcam_in_data_value,0x0, sizeof(uint32)*(ARAD_PP_IHB_TCAM_DATA_WIDTH+1));



  /* if 80 bits COPY TO both  */
  if(nof_entries_in_line == 2) {
      SHR_BITCOPY_RANGE(tcam_in_data_value,84,compare_data->value,0,80);
      SHR_BITCOPY_RANGE(tcam_in_data_value,2,compare_data->value,0,80);
  }
  else{
      SHR_BITCOPY_RANGE(tcam_in_data_value,2,compare_data->value,0,80);
      SHR_BITCOPY_RANGE(tcam_in_data_value,84,compare_data->value,80,80);
  }

  /* bits 0-1, and 82-83 for entry type */
  entry_mode = arad_pp_ihb_tcam_entries_in_line_to_format(nof_entries_in_line);


  SHR_BITCOPY_RANGE(tcam_in_data_value,0,&entry_mode,0,2);
  SHR_BITCOPY_RANGE(tcam_in_data_value,82,&entry_mode,0,2);


  sal_memcpy(fld_val, tcam_in_data_value, (ARAD_PP_IHB_TCAM_DATA_WIDTH+1)*sizeof(uint32));

  soc_mem_field_set(unit, PPDB_A_TCAM_BANK_COMMANDm, mem_val, TCAM_CPU_CMD_DIf, fld_val);
  res = arad_pp_ihb_tcam_tbl_bank_offset_get(unit, bank_ndx, 0/* hw_offset */, &bank_offset);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_BANK_COMMANDm(unit, 
                                                                   MEM_BLOCK_ANY, 
                                                                   bank_offset, 
                                                                   mem_val));

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 60, exit, READ_PPDB_A_TCAM_BANK_COMMANDm(unit, 
                                                                  MEM_BLOCK_ANY, 
                                                                  bank_offset,
                                                                  mem_val));
  found_data->found = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_MATCHf);
  if(found_data->found) {
    found_data->address = soc_mem_field32_get(unit, PPDB_A_TCAM_BANK_REPLYm, mem_val, TCAM_CPU_REP_AINDEXf);
    if(nof_entries_in_line == 1) {
        found_data->address /= 2;
    }
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_compare_unsafe()",0,0);
}

/*
 * move command by the CPU of the TCAM bank entries.
 * doesn't take semaphore.
 */
uint32
  arad_pp_ihb_tcam_tbl_move_unsafe(
    SOC_SAND_IN   int                           unit,
    SOC_SAND_IN   uint32                           bank_ndx,
    SOC_SAND_IN   uint32                           move_couple,
    SOC_SAND_IN   uint32                           nof_entries_in_line,
    SOC_SAND_IN   uint32                           source_entry_start_ndx,
    SOC_SAND_IN   uint32                           source_entry_end_ndx,
    SOC_SAND_IN   uint32                           dest_entry_start_ndx
  )
{
  uint32
    hw_offset_source,
    hw_offset_dest,
    range,
    res;
  uint64
    tcam_manager_1;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_TCAM_TBL_MOVE_UNSAFE);

 LOG_VERBOSE(BSL_LS_SOC_MEM,
             (BSL_META_U(unit,
                         SOC_DPP_MSG("      "
                         "TCAM-Block-move: bank:%d, entry-source-start:%d, entry-source-end:%d, "
                         "entry-dest-start:%d, is-320b: %d, nof_entries_in_line: %d\n\r")), 
              bank_ndx, source_entry_start_ndx, source_entry_end_ndx,
              dest_entry_start_ndx, move_couple, nof_entries_in_line));

 /*
  * in ARAD the only use of the TACM for 164 bits word (one word per line) 82 bits words (2 words per line)
  */
  if (nof_entries_in_line == 0 || nof_entries_in_line > 2)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 10, exit);
  }
 /*
  * in case there is two words per line which word to use.
  */
  if (source_entry_start_ndx >= nof_entries_in_line * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }
  if (dest_entry_start_ndx >= nof_entries_in_line * ARAD_TCAM_NOF_LINES_PER_BANK(unit, bank_ndx))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_TBL_RANGE_OUT_OF_LIMIT_ERR, 20, exit);
  }

 /*
  * low word or high word
  */
  if (nof_entries_in_line == 1)
  {
    hw_offset_source = source_entry_start_ndx;
    hw_offset_dest = dest_entry_start_ndx;
    range = source_entry_end_ndx - source_entry_start_ndx + 1;
  }
  else
  {
    hw_offset_source = source_entry_start_ndx >> 1;
    hw_offset_dest = dest_entry_start_ndx >> 1;
    range = (source_entry_end_ndx - source_entry_start_ndx + 2) / 2;
  }

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 30, exit, READ_PPDB_A_TCAM_MANAGER_1r(unit, &tcam_manager_1));
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_SRCf, hw_offset_source);
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_DSTf, hw_offset_dest);
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_RANGEf, range);
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_BANKf, bank_ndx);
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_MOVE_COUPLEf, move_couple);
  soc_reg64_field32_set(unit, PPDB_A_TCAM_MANAGER_1r, &tcam_manager_1, TCAM_MANAGER_INVALIDATEf, 0x0);
  SOC_SAND_SOC_IF_ERROR_RETURN(res, 40, exit, WRITE_PPDB_A_TCAM_MANAGER_1r(unit, tcam_manager_1));

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 50, exit, WRITE_PPDB_A_TCAM_MANAGER_0r(unit, 0x1));

  res = arad_polling(
          unit,
          ARAD_TIMEOUT,
          ARAD_MIN_POLLS,
          PPDB_A_TCAM_MANAGER_0r,
          REG_PORT_ANY,
          0,
          TCAM_MANAGER_TRIGGERf,
          0
        ); 
  SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_tcam_tbl_move_unsafe()",0,0);
}

/* automatically generated code */
#define ARAD_PP_IHP_PINFO_LLR_TBL_ENTRY_SIZE 3

uint32
  arad_pp_ihp_pinfo_llr_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int   core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PINFO_LLR_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PINFO_LLR_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PINFO_LLR_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PINFO_LLR_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PINFO_LLR_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PINFO_LLRm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->vlan_classification_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, VLAN_CLASSIFICATION_PROFILEf);
  tbl_data->pcp_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, PCP_PROFILEf);
  tbl_data->ignore_incoming_pcp = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_PCPf);
  tbl_data->tc_dp_tos_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, TC_DP_TOS_ENABLEf);
  tbl_data->tc_dp_tos_index = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, TC_DP_TOS_INDEXf);
  tbl_data->tc_l_4_protocol_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, TC_L_4_PROTOCOL_ENABLEf);
  tbl_data->tc_subnet_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, TC_SUBNET_ENABLEf);
  tbl_data->tc_port_protocol_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, TC_PORT_PROTOCOL_ENABLEf);
  tbl_data->default_traffic_class = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DEFAULT_TRAFFIC_CLASSf);
  tbl_data->ignore_incoming_up = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_UPf);
  tbl_data->incoming_up_map_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, INCOMING_UP_MAP_PROFILEf);
  tbl_data->use_dei = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, USE_DEIf);
  tbl_data->drop_precedence_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DROP_PRECEDENCE_PROFILEf);
  tbl_data->sa_lookup_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, SA_LOOKUP_ENABLEf);
  tbl_data->action_profile_sa_drop_index = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ACTION_PROFILE_SA_DROP_INDEXf);
  tbl_data->enable_sa_authentication = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ENABLE_SA_AUTHENTICATIONf);
  tbl_data->ignore_incoming_vid = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_VIDf);
  tbl_data->vid_ipv4_subnet_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, VID_IPV4_SUBNET_ENABLEf);
  tbl_data->vid_port_protocol_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, VID_PORT_PROTOCOL_ENABLEf);
  tbl_data->protocol_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, PROTOCOL_PROFILEf);
  tbl_data->default_initial_vid = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DEFAULT_INITIAL_VIDf);
  tbl_data->non_authorized_mode_8021x = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, NON_AUTHORIZED_MODE_8021Xf);
  tbl_data->reserved_mc_trap_profile = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, RESERVED_MC_TRAP_PROFILEf);
  tbl_data->enable_arp_trap = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ENABLE_ARP_TRAPf);
  tbl_data->enable_igmp_trap = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ENABLE_IGMP_TRAPf);
  tbl_data->enable_mld_trap = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ENABLE_MLD_TRAPf);
  tbl_data->enable_dhcp_trap = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, ENABLE_DHCP_TRAPf);
  tbl_data->general_trap_enable = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, GENERAL_TRAP_ENABLEf);
  tbl_data->default_cpu_trap_code = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DEFAULT_CPU_TRAP_CODEf);
  tbl_data->default_action_profile_fwd = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DEFAULT_ACTION_PROFILE_FWDf);
  tbl_data->default_action_profile_snp = soc_mem_field32_get(unit, IHP_PINFO_LLRm, data, DEFAULT_ACTION_PROFILE_SNPf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pinfo_llr_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_pinfo_llr_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int   core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PINFO_LLR_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PINFO_LLR_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PINFO_LLR_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PINFO_LLR_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, VLAN_CLASSIFICATION_PROFILEf, tbl_data->vlan_classification_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, PCP_PROFILEf, tbl_data->pcp_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_PCPf, tbl_data->ignore_incoming_pcp);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, TC_DP_TOS_ENABLEf, tbl_data->tc_dp_tos_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, TC_DP_TOS_INDEXf, tbl_data->tc_dp_tos_index);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, TC_L_4_PROTOCOL_ENABLEf, tbl_data->tc_l_4_protocol_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, TC_SUBNET_ENABLEf, tbl_data->tc_subnet_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, TC_PORT_PROTOCOL_ENABLEf, tbl_data->tc_port_protocol_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DEFAULT_TRAFFIC_CLASSf, tbl_data->default_traffic_class);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_UPf, tbl_data->ignore_incoming_up);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, INCOMING_UP_MAP_PROFILEf, tbl_data->incoming_up_map_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, USE_DEIf, tbl_data->use_dei);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DROP_PRECEDENCE_PROFILEf, tbl_data->drop_precedence_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, SA_LOOKUP_ENABLEf, tbl_data->sa_lookup_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ACTION_PROFILE_SA_DROP_INDEXf, tbl_data->action_profile_sa_drop_index);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ENABLE_SA_AUTHENTICATIONf, tbl_data->enable_sa_authentication);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, IGNORE_INCOMING_VIDf, tbl_data->ignore_incoming_vid);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, VID_IPV4_SUBNET_ENABLEf, tbl_data->vid_ipv4_subnet_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, VID_PORT_PROTOCOL_ENABLEf, tbl_data->vid_port_protocol_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, PROTOCOL_PROFILEf, tbl_data->protocol_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DEFAULT_INITIAL_VIDf, tbl_data->default_initial_vid);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, NON_AUTHORIZED_MODE_8021Xf, tbl_data->non_authorized_mode_8021x);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, RESERVED_MC_TRAP_PROFILEf, tbl_data->reserved_mc_trap_profile);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ENABLE_ARP_TRAPf, tbl_data->enable_arp_trap);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ENABLE_IGMP_TRAPf, tbl_data->enable_igmp_trap);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ENABLE_MLD_TRAPf, tbl_data->enable_mld_trap);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, ENABLE_DHCP_TRAPf, tbl_data->enable_dhcp_trap);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, GENERAL_TRAP_ENABLEf, tbl_data->general_trap_enable);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DEFAULT_CPU_TRAP_CODEf, tbl_data->default_cpu_trap_code);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DEFAULT_ACTION_PROFILE_FWDf, tbl_data->default_action_profile_fwd);
  soc_mem_field32_set(unit, IHP_PINFO_LLRm, data, DEFAULT_ACTION_PROFILE_SNPf, tbl_data->default_action_profile_snp);

  res = soc_mem_write(
          unit,
          IHP_PINFO_LLRm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pinfo_llr_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_llr_llvp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LLR_LLVP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LLR_LLVP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LLR_LLVP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_LLR_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->incoming_vid_exist = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, INCOMING_VID_EXISTf);
  tbl_data->incoming_tag_exist = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_EXISTf);
  tbl_data->incoming_tag_index = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_INDEXf);
  tbl_data->incoming_s_tag_exist = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, INCOMING_S_TAG_EXISTf);
  tbl_data->acceptable_frame_type_action = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, ACCEPTABLE_FRAME_TYPE_ACTIONf);
  tbl_data->outer_comp_index = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, OUTER_COMP_INDEXf);
  tbl_data->inner_comp_index = soc_mem_field32_get(unit, IHP_LLR_LLVPm, data, INNER_COMP_INDEXf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_llr_llvp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_llr_llvp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LLR_LLVP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LLR_LLVP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_VID_EXISTf, tbl_data->incoming_vid_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_EXISTf, tbl_data->incoming_tag_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_INDEXf, tbl_data->incoming_tag_index);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_S_TAG_EXISTf, tbl_data->incoming_s_tag_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, ACCEPTABLE_FRAME_TYPE_ACTIONf, tbl_data->acceptable_frame_type_action);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, OUTER_COMP_INDEXf, tbl_data->outer_comp_index);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INNER_COMP_INDEXf, tbl_data->inner_comp_index);

  res = soc_mem_write(
          unit,
          IHP_LLR_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_llr_llvp_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_llr_llvp_tbl_fill_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LLR_LLVP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LLR_LLVP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LLR_LLVP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_VID_EXISTf, tbl_data->incoming_vid_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_EXISTf, tbl_data->incoming_tag_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_TAG_INDEXf, tbl_data->incoming_tag_index);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INCOMING_S_TAG_EXISTf, tbl_data->incoming_s_tag_exist);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, ACCEPTABLE_FRAME_TYPE_ACTIONf, tbl_data->acceptable_frame_type_action);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, OUTER_COMP_INDEXf, tbl_data->outer_comp_index);
  soc_mem_field32_set(unit, IHP_LLR_LLVPm, data, INNER_COMP_INDEXf, tbl_data->inner_comp_index);

  res = arad_fill_table_with_entry(unit, IHP_LLR_LLVPm, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_llr_llvp_tbl_fill_unsafe()", entry_offset, 0);
}


#define ARAD_PP_IHP_ECM_STEP_TBL_ENTRY_SIZE 1
#define ARAD_PP_ECM_STEP_TBL_NOF_BANKS_6    6
#define ARAD_PP_ECM_STEP_TBL_NOF_BANKS_8 8
#define ARAD_PP_ECM_STEP_TBL_NOF_ENTRIES 64


int
arad_pp_em_step_table_init_cb(SOC_SAND_IN int unit, 
                            SOC_SAND_IN int copyno, 
                            SOC_SAND_IN int array_index, 
                            SOC_SAND_IN int entry_offset, 
                            SOC_SAND_OUT uint32 *data, 
                            SOC_SAND_IN int entry_sz,
                            SOC_SAND_IN void *cookie)
{
    ARAD_PP_IHP_ECM_STEP_TBL_DATA tbl_data;
    int max_step, nof_banks, nof_entries;
    int *mem_id;

    SOCDNX_INIT_FUNC_DEFS;

    SOCDNX_NULL_CHECK(cookie);
    mem_id = (int*) cookie;

    switch (*mem_id) {
    case EDB_ESEM_STEP_TABLEm:
    case EDB_ESEM_0_STEP_TABLEm:
    case EDB_ESEM_1_STEP_TABLEm:
    case OAMP_REMOTE_MEP_EXACT_MATCH_STEP_TABLEm:
    case PPDB_A_OEMA_STEP_TABLEm:
    case PPDB_A_OEMB_STEP_TABLEm:
    case PPDB_A_ISEM_STEP_TABLEm:
    case PPDB_B_ISEM_STEP_TABLEm:
    case IHB_ISEM_STEP_TABLEm:
    case IHP_ISA_STEP_TABLEm:
    case IHP_ISB_STEP_TABLEm:
        nof_banks = ARAD_PP_ECM_STEP_TBL_NOF_BANKS_8;
        break;
    case PPDB_B_LARGE_EM_STEP_TABLEm:
        nof_banks = SOC_DPP_DEFS_GET(unit, nof_lem_banks);
        break;
    case EDB_GLEM_STEP_TABLEm:
        nof_banks = SOC_DPP_DEFS_GET(unit, nof_glem_banks);
        break;
    default:
        SOCDNX_EXIT_WITH_ERR(SOC_E_INTERNAL, (_BSL_SOCDNX_MSG_STR("Unknown table memory.")));
    }

    if (nof_banks != 6 && nof_banks != 7 && nof_banks != 8) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_UNAVAIL, (_BSL_SOCDNX_MSG_STR("Step table support for EMs with %d banks is not available."), nof_banks));
    }

    nof_entries = ARAD_PP_ECM_STEP_TBL_NOF_ENTRIES; /* Shouldn't be changed anytime soon. */

    if (entry_offset >= nof_entries) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_INTERNAL, (_BSL_SOCDNX_MSG_STR( "Entry too high. Was %d but max is %d."), entry_offset, nof_entries - 1));
    }

    SOCDNX_CLEAR(&tbl_data, ARAD_PP_IHP_ECM_STEP_TBL_DATA, 1);

    /* Maximum used step in the source steps offset. In case of 8 banks, it's not using the last step (#8) */
    max_step = (nof_entries - 2 /* -1 for maximum entry, -1 for for the formula */ ) / (nof_banks - 1);

    if (nof_banks == 8) {
        max_step--;
    }
    
    /*
     * The way to fill the step table is according to the asic exact match step machine algorithm, and it is too long 
     *  to document. However, some points can be noticed for future devices:
     *      1. If a field should be -1, set all bits to 1 according to field size.
     *      2. If a field should hold a number that's more than the maximum allowed by its bits,
     *          it should be set to the mod of the max number. 
     *              For example: the step field is 3 bits wide when there are 8 banks,
     *                  so 8 is set to 0.
     *      3. Entry #0 is always different.
     */
    if (entry_offset == 0) {
        /* Entry #0 of the table is treated differently. */
        tbl_data.step           = 0xff;     /* Should be -1. */
        tbl_data.write_line     = 0;
        tbl_data.write_valid    = 1;
        tbl_data.offset         = nof_banks - 1;
        tbl_data.read_line      = (nof_banks == 8) ? 0x7 : 0xf; /* Should be -1. */
    } else {
        /* Fill according to the standard filling method. */
        tbl_data.step           = (entry_offset - 1) / (nof_banks - 1);
        tbl_data.read_line      = tbl_data.step;
        if (nof_banks == 8 && tbl_data.read_line == 8) { /* Only 3 bits in the field. */
            tbl_data.read_line = 0;
        }

        tbl_data.write_valid    = (entry_offset <= max_step) ? 1 : 0;
        tbl_data.write_line     = (tbl_data.write_valid) ? entry_offset
           : (nof_banks == 8) ? 0x7 : 0xf; /* Should be -1. */
        tbl_data.offset         = entry_offset % (nof_banks - 1);
        if (!tbl_data.offset) {
            tbl_data.offset = (nof_banks - 1);
        }
    }

    /* 
     * Write to the buffer. Since all the tables of the same size are the same,
     * we use ISEM as the 8 banks base, and glem as the 6 banks base. 
     * Currently, the only 6 banks tables are GLEM and LEM, and only in jericho. It may need 
     *  to be changed in the future. 
     */
    if (nof_banks == 8) {
        if (SOC_IS_JERICHO_PLUS_A0(unit)) {
            soc_mem_field32_set(unit, EDB_ESEM_0_STEP_TABLEm, data, ESEM_0_MM_READ_LINEf, tbl_data.read_line);
            soc_mem_field32_set(unit, EDB_ESEM_0_STEP_TABLEm, data, ESEM_0_MM_WRITE_LINEf, tbl_data.write_line);
            soc_mem_field32_set(unit, EDB_ESEM_0_STEP_TABLEm, data, ESEM_0_MM_WRITE_VALIDf, tbl_data.write_valid);
            soc_mem_field32_set(unit, EDB_ESEM_0_STEP_TABLEm, data, ESEM_0_SOURCE_STEPf, tbl_data.step);
            soc_mem_field32_set(unit, EDB_ESEM_0_STEP_TABLEm, data, ESEM_0_TABLE_OFFSETf, tbl_data.offset);
        }
        else {
            soc_mem_field32_set(unit, EDB_ESEM_STEP_TABLEm, data, ESEM_MM_READ_LINEf, tbl_data.read_line);
            soc_mem_field32_set(unit, EDB_ESEM_STEP_TABLEm, data, ESEM_MM_WRITE_LINEf, tbl_data.write_line);
            soc_mem_field32_set(unit, EDB_ESEM_STEP_TABLEm, data, ESEM_MM_WRITE_VALIDf, tbl_data.write_valid);
            soc_mem_field32_set(unit, EDB_ESEM_STEP_TABLEm, data, ESEM_SOURCE_STEPf, tbl_data.step);
            soc_mem_field32_set(unit, EDB_ESEM_STEP_TABLEm, data, ESEM_TABLE_OFFSETf, tbl_data.offset);
        }
    } else {
        soc_mem_field32_set(unit, EDB_GLEM_STEP_TABLEm, data, GLEM_MM_READ_LINEf, tbl_data.read_line);
        soc_mem_field32_set(unit, EDB_GLEM_STEP_TABLEm, data, GLEM_MM_WRITE_LINEf, tbl_data.write_line);
        soc_mem_field32_set(unit, EDB_GLEM_STEP_TABLEm, data, GLEM_MM_WRITE_VALIDf, tbl_data.write_valid);
        soc_mem_field32_set(unit, EDB_GLEM_STEP_TABLEm, data, GLEM_SOURCE_STEPf, tbl_data.step);
        soc_mem_field32_set(unit, EDB_GLEM_STEP_TABLEm, data, GLEM_TABLE_OFFSETf, tbl_data.offset);
    }

exit:
    SOCDNX_FUNC_RETURN;
}

int
arad_pp_ecm_step_table_fill(int unit, int table_mem)   
{
    int rv;
    SOCDNX_INIT_FUNC_DEFS;
    rv = arad_fill_table_with_variable_values_by_caching(unit, table_mem, 0, MEM_BLOCK_ANY, -1, -1,
                                                         arad_pp_em_step_table_init_cb, &table_mem);
    SOCDNX_IF_ERR_EXIT(rv);
exit:
    SOCDNX_FUNC_RETURN;
}

uint32
arad_tbl_access_em_step_tbls_init(int unit) 
{
    int rv;

    SOCDNX_INIT_FUNC_DEFS;


    if (SOC_IS_QAX(unit) && !SOC_IS_QAX_A0(unit) && !SOC_IS_QAX_B0(unit) && !SOC_IS_QUX(unit)) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_INTERNAL, (_BSL_SOCDNX_MSG_STR("Warning: Step tables are intialized by an asic algorithm that "
                                                                   "depends on the number of banks in each exact match.\n"
                                                                   "Please verify that they are updated to this new chip before"
                                                                   "updating this warning for the next gen chip.")));
    }
    
    /* Fill ESEM step table. */
    if (SOC_IS_JERICHO_PLUS_A0(unit)) {
        rv = arad_pp_ecm_step_table_fill(unit, EDB_ESEM_0_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);

        rv = arad_pp_ecm_step_table_fill(unit, EDB_ESEM_1_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    }
    else {
        rv = arad_pp_ecm_step_table_fill(unit, EDB_ESEM_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    }
    
    /* Fill OEMA step table. */
    rv = arad_pp_ecm_step_table_fill(unit, PPDB_A_OEMA_STEP_TABLEm);
    SOCDNX_IF_ERR_EXIT(rv);
    
    /* Fill OEMB step table. */
    rv = arad_pp_ecm_step_table_fill(unit, PPDB_A_OEMB_STEP_TABLEm);
    SOCDNX_IF_ERR_EXIT(rv);
    
    /* Fill OAMP step table. */
    rv = arad_pp_ecm_step_table_fill(unit, OAMP_REMOTE_MEP_EXACT_MATCH_STEP_TABLEm);
    SOCDNX_IF_ERR_EXIT(rv);
    
    /* 
     * ISEM step table is 2 different tables with different names on arad and qax, and one table on jericho. 
     * Because it's split into different tables, aliasing would be too cumbersome. 
     */
    if (SOC_IS_QAX(unit)) {
        rv = arad_pp_ecm_step_table_fill(unit, PPDB_A_ISEM_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
        rv = arad_pp_ecm_step_table_fill(unit, PPDB_B_ISEM_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    
    } else if (SOC_IS_JERICHO(unit)) {
        rv = arad_pp_ecm_step_table_fill(unit, IHB_ISEM_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        rv = arad_pp_ecm_step_table_fill(unit, IHP_ISA_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
        rv = arad_pp_ecm_step_table_fill(unit, IHP_ISB_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    }
    
    /* Fill LEM step table. */    
    rv = arad_pp_ecm_step_table_fill(unit, PPDB_B_LARGE_EM_STEP_TABLEm);
    SOCDNX_IF_ERR_EXIT(rv);
    
    if (SOC_IS_JERICHO(unit)) {
        /* GLEM doesn't exist in arad. */
        rv = arad_pp_ecm_step_table_fill(unit, EDB_GLEM_STEP_TABLEm);
        SOCDNX_IF_ERR_EXIT(rv);
    }
  
exit:
    SOCDNX_FUNC_RETURN;
}


#define ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_ll_mirror_profile_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int   core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_LL_MIRROR_PROFILEm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->ll_mirror_profile = soc_mem_field32_get(unit, IHP_LL_MIRROR_PROFILEm, data, LL_MIRROR_PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_ll_mirror_profile_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_ll_mirror_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LL_MIRROR_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_LL_MIRROR_PROFILEm, data, LL_MIRROR_PROFILEf, tbl_data->ll_mirror_profile);

  res = soc_mem_write(
          unit,
          IHP_LL_MIRROR_PROFILEm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_ll_mirror_profile_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihp_subnet_classify_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_SUBNET_CLASSIFYm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->ipv4_subnet = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNETf);
  tbl_data->ipv4_subnet_mask = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_MASKf);
  tbl_data->ipv4_subnet_vid = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_VIDf);
  tbl_data->ipv4_subnet_tc = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_TCf);
  tbl_data->ipv4_subnet_tc_valid = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_TC_VALIDf);
  tbl_data->ipv4_subnet_valid = soc_mem_field32_get(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_VALIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_subnet_classify_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_subnet_classify_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SUBNET_CLASSIFY_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNETf, tbl_data->ipv4_subnet);
  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_MASKf, tbl_data->ipv4_subnet_mask);
  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_VIDf, tbl_data->ipv4_subnet_vid);
  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_TCf, tbl_data->ipv4_subnet_tc);
  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_TC_VALIDf, tbl_data->ipv4_subnet_tc_valid);
  soc_mem_field32_set(unit, IHP_SUBNET_CLASSIFYm, data, IPV4_SUBNET_VALIDf, tbl_data->ipv4_subnet_valid);

  res = soc_mem_write(
          unit,
          IHP_SUBNET_CLASSIFYm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_subnet_classify_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PORT_PROTOCOL_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_port_protocol_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PORT_PROTOCOL_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PORT_PROTOCOL_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PORT_PROTOCOL_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PORT_PROTOCOL_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PORT_PROTOCOL_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PORT_PROTOCOLm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->vid = soc_mem_field32_get(unit, IHP_PORT_PROTOCOLm, data, VIDf);
  tbl_data->vid_valid = soc_mem_field32_get(unit, IHP_PORT_PROTOCOLm, data, VID_VALIDf);
  tbl_data->traffic_class = soc_mem_field32_get(unit, IHP_PORT_PROTOCOLm, data, TRAFFIC_CLASSf);
  tbl_data->traffic_class_valid = soc_mem_field32_get(unit, IHP_PORT_PROTOCOLm, data, TRAFFIC_CLASS_VALIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_port_protocol_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_port_protocol_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PORT_PROTOCOL_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PORT_PROTOCOL_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PORT_PROTOCOL_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PORT_PROTOCOL_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PORT_PROTOCOLm, data, VIDf, tbl_data->vid);
  soc_mem_field32_set(unit, IHP_PORT_PROTOCOLm, data, VID_VALIDf, tbl_data->vid_valid);
  soc_mem_field32_set(unit, IHP_PORT_PROTOCOLm, data, TRAFFIC_CLASSf, tbl_data->traffic_class);
  soc_mem_field32_set(unit, IHP_PORT_PROTOCOLm, data, TRAFFIC_CLASS_VALIDf, tbl_data->traffic_class_valid);

  res = soc_mem_write(
          unit,
          IHP_PORT_PROTOCOLm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_port_protocol_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_TOS_2_COS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_tos_2_cos_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_TOS_2_COS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TOS_2_COS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TOS_2_COS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TOS_2_COS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_TOS_2_COS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_TOS_2_COSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->valid = soc_mem_field32_get(unit, IHP_TOS_2_COSm, data, VALIDf);
  tbl_data->tc = soc_mem_field32_get(unit, IHP_TOS_2_COSm, data, TCf);
  tbl_data->dp = soc_mem_field32_get(unit, IHP_TOS_2_COSm, data, DPf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_tos_2_cos_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_tos_2_cos_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_TOS_2_COS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TOS_2_COS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TOS_2_COS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TOS_2_COS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_TOS_2_COSm, data, VALIDf, tbl_data->valid);
  soc_mem_field32_set(unit, IHP_TOS_2_COSm, data, TCf, tbl_data->tc);
  soc_mem_field32_set(unit, IHP_TOS_2_COSm, data, DPf, tbl_data->dp);

  res = soc_mem_write(
          unit,
          IHP_TOS_2_COSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_tos_2_cos_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_RESERVED_MC_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_reserved_mc_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_RESERVED_MC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_RESERVED_MC_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_RESERVED_MC_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_RESERVED_MC_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_RESERVED_MC_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_RESERVED_MCm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fwd = soc_mem_field32_get(unit, IHP_RESERVED_MCm, data, FWDf);
  tbl_data->snp = soc_mem_field32_get(unit, IHP_RESERVED_MCm, data, SNPf);
  tbl_data->cpu_trap_code = soc_mem_field32_get(unit, IHP_RESERVED_MCm, data, CPU_TRAP_CODEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_reserved_mc_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_reserved_mc_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_RESERVED_MC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_RESERVED_MC_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_RESERVED_MC_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_RESERVED_MC_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_RESERVED_MCm, data, FWDf, tbl_data->fwd);
  soc_mem_field32_set(unit, IHP_RESERVED_MCm, data, SNPf, tbl_data->snp);
  soc_mem_field32_set(unit, IHP_RESERVED_MCm, data, CPU_TRAP_CODEf, tbl_data->cpu_trap_code);

  res = soc_mem_write(
          unit,
          IHP_RESERVED_MCm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_reserved_mc_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PP_PORT_INFO_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_pp_port_info_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PP_PORT_INFO_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PP_PORT_INFO_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PP_PORT_INFO_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PP_PORT_INFO_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PP_PORT_INFO_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PP_PORT_INFOm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->pp_port_outer_header_start = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, PP_PORT_OUTER_HEADER_STARTf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, TPID_PROFILEf);
  tbl_data->default_parser_program_pointer = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, DEFAULT_PARSER_PROGRAM_POINTERf);
  tbl_data->default_pfq_0 = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, DEFAULT_PFQ_0f);
  tbl_data->parser_custom_macro_select = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, PARSER_CUSTOM_MACRO_SELECTf);
  tbl_data->mpls_next_address_use_specualte = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, data, MPLS_NEXT_ADDRESS_USE_SPECUALTEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pp_port_info_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_pp_port_info_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PP_PORT_INFO_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PP_PORT_INFO_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PP_PORT_INFO_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PP_PORT_INFO_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, PP_PORT_OUTER_HEADER_STARTf, tbl_data->pp_port_outer_header_start);
  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, DEFAULT_PARSER_PROGRAM_POINTERf, tbl_data->default_parser_program_pointer);
  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, DEFAULT_PFQ_0f, tbl_data->default_pfq_0);
  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, PARSER_CUSTOM_MACRO_SELECTf, tbl_data->parser_custom_macro_select);
  soc_mem_field32_set(unit, IHP_PP_PORT_INFOm, data, MPLS_NEXT_ADDRESS_USE_SPECUALTEf, tbl_data->mpls_next_address_use_specualte);

  res = soc_mem_write(
          unit,
          IHP_PP_PORT_INFOm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pp_port_info_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_src_system_port_fem_bit_select_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->src_system_port_fem_bit_select = soc_mem_field32_get(unit, IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLEm, data, SRC_SYSTEM_PORT_FEM_BIT_SELECTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_bit_select_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_src_system_port_fem_bit_select_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLEm, data, SRC_SYSTEM_PORT_FEM_BIT_SELECTf, tbl_data->src_system_port_fem_bit_select);

  res = soc_mem_write(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_BIT_SELECT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_bit_select_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_src_system_port_fem_map_index_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32              pgm_ndx,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->src_system_port_fem_map_index = soc_mem_field32_get(unit, IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm, data, SRC_SYSTEM_PORT_FEM_MAP_INDEXf);
  tbl_data->src_system_port_fem_map_data = soc_mem_field32_get(unit, IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm, data, SRC_SYSTEM_PORT_FEM_MAP_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_map_index_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_src_system_port_fem_map_index_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32              pgm_ndx,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm, data, SRC_SYSTEM_PORT_FEM_MAP_INDEXf, tbl_data->src_system_port_fem_map_index);
  soc_mem_field32_set(unit, IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm, data, SRC_SYSTEM_PORT_FEM_MAP_DATAf, tbl_data->src_system_port_fem_map_data);

  res = soc_mem_write(
          unit,
          IHP_SRC_SYSTEM_PORT_FEM_MAP_INDEX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset + (pgm_ndx << ARAD_PP_IHP_FEM_SEL_BITS_SIZE_IN_BITS),
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_src_system_port_fem_map_index_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_packet_format_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PACKET_FORMAT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->packet_format_code = soc_mem_field32_get(unit, IHP_PACKET_FORMAT_TABLEm, data, PACKET_FORMAT_CODEf);
  tbl_data->parser_leaf_context = soc_mem_field32_get(unit, IHP_PACKET_FORMAT_TABLEm, data, PARSER_LEAF_CONTEXTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_packet_format_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_packet_format_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PACKET_FORMAT_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PACKET_FORMAT_TABLEm, data, PACKET_FORMAT_CODEf, tbl_data->packet_format_code);
  soc_mem_field32_set(unit, IHP_PACKET_FORMAT_TABLEm, data, PARSER_LEAF_CONTEXTf, tbl_data->parser_leaf_context);

  res = soc_mem_write(
          unit,
          IHP_PACKET_FORMAT_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_packet_format_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_ENTRY_SIZE 4

uint32
  arad_pp_ihp_parser_custom_macro_parameters_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PARSER_CUSTOM_MACRO_PARAMETERSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->cstm_word_select = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_WORD_SELECTf);
  tbl_data->cstm_mask_left = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_MASK_LEFTf);
  tbl_data->cstm_mask_right = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_MASK_RIGHTf);
  tbl_data->cstm_condition_select = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_CONDITION_SELECTf);
  tbl_data->cstm_comparator_mode = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_COMPARATOR_MODEf);
  tbl_data->cstm_comparator_mask = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_COMPARATOR_MASKf);
  tbl_data->cstm_shift_sel = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_SELf);
  tbl_data->cstm_shift_a = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_Af);
  tbl_data->cstm_shift_b = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_Bf);
  tbl_data->augment_previous_stage = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, AUGMENT_PREVIOUS_STAGEf);
  tbl_data->qualifier_or_mask = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_OR_MASKf);
  tbl_data->qualifier_and_mask = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_AND_MASKf);
  tbl_data->header_qualifier_mask = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, HEADER_QUALIFIER_MASKf);
  tbl_data->qualifier_shift = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_SHIFTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_custom_macro_parameters_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_custom_macro_parameters_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PARAMETERS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_WORD_SELECTf, tbl_data->cstm_word_select);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_MASK_LEFTf, tbl_data->cstm_mask_left);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_MASK_RIGHTf, tbl_data->cstm_mask_right);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_CONDITION_SELECTf, tbl_data->cstm_condition_select);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_COMPARATOR_MODEf, tbl_data->cstm_comparator_mode);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_COMPARATOR_MASKf, tbl_data->cstm_comparator_mask);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_SELf, tbl_data->cstm_shift_sel);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_Af, tbl_data->cstm_shift_a);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, CSTM_SHIFT_Bf, tbl_data->cstm_shift_b);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, AUGMENT_PREVIOUS_STAGEf, tbl_data->augment_previous_stage);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_OR_MASKf, tbl_data->qualifier_or_mask);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_AND_MASKf, tbl_data->qualifier_and_mask);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, HEADER_QUALIFIER_MASKf, tbl_data->header_qualifier_mask);
  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PARAMETERSm, data, QUALIFIER_SHIFTf, tbl_data->qualifier_shift);

  res = soc_mem_write(
          unit,
          IHP_PARSER_CUSTOM_MACRO_PARAMETERSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_custom_macro_parameters_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_parser_eth_protocols_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PARSER_ETH_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->eth_type_protocol = soc_mem_field32_get(unit, IHP_PARSER_ETH_PROTOCOLSm, data, ETH_TYPE_PROTOCOLf);
  tbl_data->eth_sap_protocol = soc_mem_field32_get(unit, IHP_PARSER_ETH_PROTOCOLSm, data, ETH_SAP_PROTOCOLf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_eth_protocols_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_eth_protocols_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_ETH_PROTOCOLS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PARSER_ETH_PROTOCOLSm, data, ETH_TYPE_PROTOCOLf, tbl_data->eth_type_protocol);
  soc_mem_field32_set(unit, IHP_PARSER_ETH_PROTOCOLSm, data, ETH_SAP_PROTOCOLf, tbl_data->eth_sap_protocol);

  res = soc_mem_write(
          unit,
          IHP_PARSER_ETH_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_eth_protocols_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_parser_ip_protocols_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PARSER_IP_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->ip_protocol = soc_mem_field32_get(unit, IHP_PARSER_IP_PROTOCOLSm, data, IP_PROTOCOLf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_ip_protocols_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_ip_protocols_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_IP_PROTOCOLS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PARSER_IP_PROTOCOLSm, data, IP_PROTOCOLf, tbl_data->ip_protocol);

  if (SOC_IS_JERICHO_PLUS(unit))
  {
	  soc_mem_field32_set(unit, IHP_PARSER_IP_PROTOCOLSm, data, EXTENSION_VALIDf, tbl_data->extension_valid);
  }

  res = soc_mem_write(
          unit,
          IHP_PARSER_IP_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_ip_protocols_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_parser_custom_macro_protocols_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_PARSER_CUSTOM_MACRO_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->cstm_protocol = soc_mem_field32_get(unit, IHP_PARSER_CUSTOM_MACRO_PROTOCOLSm, data, CSTM_PROTOCOLf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_custom_macro_protocols_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_parser_custom_macro_protocols_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_PARSER_CUSTOM_MACRO_PROTOCOLS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_PARSER_CUSTOM_MACRO_PROTOCOLSm, data, CSTM_PROTOCOLf, tbl_data->cstm_protocol);

  res = soc_mem_write(
          unit,
          IHP_PARSER_CUSTOM_MACRO_PROTOCOLSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_parser_custom_macro_protocols_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihp_bvd_topology_id_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_BVD_TOPOLOGY_IDm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->lsb[0] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSBf);
  tbl_data->lsb[1] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_1f);
  tbl_data->lsb[2] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_2f);
  tbl_data->lsb[3] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_3f);
  tbl_data->lsb[4] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_4f);
  tbl_data->lsb[5] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_5f);
  tbl_data->lsb[6] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_6f);
  tbl_data->lsb[7] = soc_mem_field32_get(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_7f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_bvd_topology_id_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_bvd_topology_id_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_BVD_TOPOLOGY_ID_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSBf, tbl_data->lsb[0]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_1f, tbl_data->lsb[1]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_2f, tbl_data->lsb[2]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_3f, tbl_data->lsb[3]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_4f, tbl_data->lsb[4]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_5f, tbl_data->lsb[5]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_6f, tbl_data->lsb[6]);
  soc_mem_field32_set(unit, IHP_BVD_TOPOLOGY_IDm, data, LSB_7f, tbl_data->lsb[7]);

  res = soc_mem_write(
          unit,
          IHP_BVD_TOPOLOGY_IDm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_bvd_topology_id_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_BVD_FID_CLASS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_bvd_fid_class_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_BVD_FID_CLASS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_BVD_FID_CLASS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_BVD_FID_CLASS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_BVD_FID_CLASS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_BVD_FID_CLASS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_BVD_FID_CLASSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fid_class[0] = soc_mem_field32_get(unit, IHP_BVD_FID_CLASSm, data, FID_CLASSf);
  tbl_data->fid_class[1] = soc_mem_field32_get(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_1f);
  tbl_data->fid_class[2] = soc_mem_field32_get(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_2f);
  tbl_data->fid_class[3] = soc_mem_field32_get(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_3f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_bvd_fid_class_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_bvd_fid_class_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_BVD_FID_CLASS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_BVD_FID_CLASS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_BVD_FID_CLASS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_BVD_FID_CLASS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_BVD_FID_CLASSm, data, FID_CLASSf, tbl_data->fid_class[0]);
  soc_mem_field32_set(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_1f, tbl_data->fid_class[1]);
  soc_mem_field32_set(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_2f, tbl_data->fid_class[2]);
  soc_mem_field32_set(unit, IHP_BVD_FID_CLASSm, data, FID_CLASS_3f, tbl_data->fid_class[3]);

  res = soc_mem_write(
          unit,
          IHP_BVD_FID_CLASSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_bvd_fid_class_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_FID_CLASS_2_FID_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_fid_class_2_fid_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_FID_CLASS_2_FID_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_FID_CLASS_2_FID_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_FID_CLASS_2_FID_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_FID_CLASS_2_FID_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_FID_CLASS_2_FID_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_FID_CLASS_2_FIDm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fid = soc_mem_field32_get(unit, IHP_FID_CLASS_2_FIDm, data, FIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_fid_class_2_fid_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_fid_class_2_fid_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_FID_CLASS_2_FID_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_FID_CLASS_2_FID_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_FID_CLASS_2_FID_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_FID_CLASS_2_FID_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_FID_CLASS_2_FIDm, data, FIDf, tbl_data->fid);

  res = soc_mem_write(
          unit,
          IHP_FID_CLASS_2_FIDm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_fid_class_2_fid_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vlan_range_compression_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VLAN_RANGE_COMPRESSION_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->vlan_range_lower_limit = soc_mem_field32_get(unit, IHP_VLAN_RANGE_COMPRESSION_TABLEm, data, VLAN_RANGE_LOWER_LIMITf);
  tbl_data->vlan_range_upper_limit = soc_mem_field32_get(unit, IHP_VLAN_RANGE_COMPRESSION_TABLEm, data, VLAN_RANGE_UPPER_LIMITf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vlan_range_compression_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vlan_range_compression_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VLAN_RANGE_COMPRESSION_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VLAN_RANGE_COMPRESSION_TABLEm, data, VLAN_RANGE_LOWER_LIMITf, tbl_data->vlan_range_lower_limit);
  soc_mem_field32_set(unit, IHP_VLAN_RANGE_COMPRESSION_TABLEm, data, VLAN_RANGE_UPPER_LIMITf, tbl_data->vlan_range_upper_limit);

  res = soc_mem_write(
          unit,
          IHP_VLAN_RANGE_COMPRESSION_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vlan_range_compression_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_ENTRY_SIZE 3

uint32
  arad_pp_ihp_vtt_in_pp_port_vlan_config_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_IN_PP_PORT_VLAN_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->range_valid_0 = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_VLAN_CONFIGm, data, RANGE_VALID_0f);
  tbl_data->range_valid_1 = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_VLAN_CONFIGm, data, RANGE_VALID_1f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_in_pp_port_vlan_config_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt_in_pp_port_vlan_config_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_IN_PP_PORT_VLAN_CONFIG_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_VLAN_CONFIGm, data, RANGE_VALID_0f, tbl_data->range_valid_0);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_VLAN_CONFIGm, data, RANGE_VALID_1f, tbl_data->range_valid_1);

  res = soc_mem_write(
          unit,
          IHP_VTT_IN_PP_PORT_VLAN_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_in_pp_port_vlan_config_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_designated_vlan_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_DESIGNATED_VLAN_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->designated_vlan = soc_mem_field32_get(unit, IHP_DESIGNATED_VLAN_TABLEm, data, DESIGNATED_VLANf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_designated_vlan_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_designated_vlan_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_DESIGNATED_VLAN_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_DESIGNATED_VLAN_TABLEm, data, DESIGNATED_VLANf, tbl_data->designated_vlan);

  res = soc_mem_write(
          unit,
          IHP_DESIGNATED_VLAN_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_designated_vlan_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihp_vtt_in_pp_port_config_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_IN_PP_PORT_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->vlan_domain = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, VLAN_DOMAINf);
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->mapped_pp_port = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, MAPPED_PP_PORTf);
      tbl_data->enable_my_nick_name_bitmap = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, ENABLE_MY_NICK_NAME_BITMAPf);
  }
  tbl_data->vlan_translation_profile = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, VLAN_TRANSLATION_PROFILEf);
  tbl_data->termination_profile = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, TERMINATION_PROFILEf);
  tbl_data->designated_vlan_index = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, DESIGNATED_VLAN_INDEXf);
  tbl_data->default_port_lif = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, DEFAULT_PORT_LIFf);
  tbl_data->all_vlan_member = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, ALL_VLAN_MEMBERf);
  tbl_data->learn_lif = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, LEARN_LIFf);
  tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, USE_IN_LIFf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_in_pp_port_config_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt_in_pp_port_config_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int      core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_IN_PP_PORT_CONFIG_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, VLAN_DOMAINf, tbl_data->vlan_domain);
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, MAPPED_PP_PORTf, tbl_data->mapped_pp_port);
      soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, ENABLE_MY_NICK_NAME_BITMAPf, tbl_data->enable_my_nick_name_bitmap);
  }
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, VLAN_TRANSLATION_PROFILEf, tbl_data->vlan_translation_profile);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, TERMINATION_PROFILEf, tbl_data->termination_profile);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, DESIGNATED_VLAN_INDEXf, tbl_data->designated_vlan_index);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, DEFAULT_PORT_LIFf, tbl_data->default_port_lif);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, ALL_VLAN_MEMBERf, tbl_data->all_vlan_member);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, LEARN_LIFf, tbl_data->learn_lif);
  soc_mem_field32_set(unit, IHP_VTT_IN_PP_PORT_CONFIGm, data, USE_IN_LIFf, tbl_data->use_in_lif);

  res = soc_mem_write(
          unit,
          IHP_VTT_IN_PP_PORT_CONFIGm,
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_in_pp_port_config_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VTT_LLVP_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vtt_llvp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VTT_LLVP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_LLVP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_LLVP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_LLVP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VTT_LLVP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VTT_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->incoming_tag_structure = soc_mem_field32_get(unit, IHP_VTT_LLVPm, data, INCOMING_TAG_STRUCTUREf);
  tbl_data->ivec = soc_mem_field32_get(unit, IHP_VTT_LLVPm, data, IVECf);
  tbl_data->pcp_dei_profile = soc_mem_field32_get(unit, IHP_VTT_LLVPm, data, PCP_DEI_PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_llvp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vtt_llvp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VTT_LLVP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VTT_LLVP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VTT_LLVP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VTT_LLVP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VTT_LLVPm, data, INCOMING_TAG_STRUCTUREf, tbl_data->incoming_tag_structure);
  soc_mem_field32_set(unit, IHP_VTT_LLVPm, data, IVECf, tbl_data->ivec);
  soc_mem_field32_set(unit, IHP_VTT_LLVPm, data, PCP_DEI_PROFILEf, tbl_data->pcp_dei_profile);

  res = soc_mem_write(
          unit,
          IHP_VTT_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vtt_llvp_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_ingress_vlan_edit_command_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->ivec = soc_mem_field32_get(unit, IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm, data, IVECf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_ingress_vlan_edit_command_table_tbl_get_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_inrif_configuration_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  uint32   tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, IVECf, tbl_data);

  res = soc_mem_write(
          unit,
          IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_ingress_vlan_edit_command_table_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_map_rif_profile_to_routing_enable_tbl_set_unsafe(
    SOC_SAND_IN  int    unit,
    SOC_SAND_IN  uint32 entry_offset,
    SOC_SAND_IN  uint32 tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[1];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, 1);

  data[0] = tbl_data;

  res = soc_mem_write(
          unit,
          IHP_MAP_RIF_PROFILE_TO_ROUTING_ENABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_map_rif_profile_to_routing_enable_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_ingress_vlan_edit_command_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_INGRESS_VLAN_EDIT_COMMAND_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm, data, IVECf, tbl_data->ivec);

  res = soc_mem_write(
          unit,
          IHP_INGRESS_VLAN_EDIT_COMMAND_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_ingress_vlan_edit_command_table_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_vlan_edit_pcp_dei_map_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VLAN_EDIT_PCP_DEI_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->pcp_dei = soc_mem_field32_get(unit, IHP_VLAN_EDIT_PCP_DEI_MAPm, data, PCP_DEIf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vlan_edit_pcp_dei_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vlan_edit_pcp_dei_map_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VLAN_EDIT_PCP_DEI_MAP_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VLAN_EDIT_PCP_DEI_MAPm, data, PCP_DEIf, tbl_data->pcp_dei);

  res = soc_mem_write(
          unit,
          IHP_VLAN_EDIT_PCP_DEI_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vlan_edit_pcp_dei_map_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_DP_PROFILE_MASK 0x3

uint32
  arad_pp_epni_dp_map_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_DP_MAP_TBL_DATA *tbl_data
  )
{
	uint32
		res = SOC_SAND_OK;
	uint32
		data[ARAD_PP_EPNI_DP_MAP_TBL_ENTRY_SIZE];

	SOC_SAND_INIT_ERROR_DEFINITIONS(0); /* should be  ARAD_PP_EPNI_DP_MAP_TBL_GET_UNSAFE ? */

	ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_DP_MAP_TBL_ENTRY_SIZE);
	ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PCP_DEI_MAP_TBL_DATA, 1);

	if (!SOC_IS_JERICHO_PLUS(unit)) {
		SOC_SAND_SET_ERROR_MSG((_BSL_SOCDNX_SAND_MSG("Function only works on QAX and above")));
	}


	res = soc_mem_read(
			unit,
			EPNI_PCP_DEI_DP_MAPPING_TABLEm,
			MEM_BLOCK_ANY,
			entry_offset,
			data
			);
	SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

	tbl_data->pcp_dei = soc_mem_field32_get(unit, EPNI_PCP_DEI_DP_MAPPING_TABLEm, data, PUSH_PCP_DEIf);

	exit:
	SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_dp_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_dp_map_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN ARAD_PP_EPNI_DP_MAP_TBL_DATA *tbl_data
  )
{
	uint32
	res = SOC_SAND_OK;
	uint32
	data[ARAD_PP_EPNI_DP_MAP_TBL_ENTRY_SIZE];

	SOC_SAND_INIT_ERROR_DEFINITIONS(0); /* should be ARAD_PP_EPNI_DP_MAP_TBL_SET_UNSAFE ? */

	ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_DP_MAP_TBL_ENTRY_SIZE);

	if (!SOC_IS_JERICHO_PLUS(unit)) {
		SOC_SAND_SET_ERROR_MSG((_BSL_SOCDNX_SAND_MSG("Function only works on QAX and above")));
	}

	soc_mem_field32_set(unit, EPNI_PCP_DEI_DP_MAPPING_TABLEm, data, PUSH_PCP_DEIf, tbl_data->pcp_dei);

	res = soc_mem_write(
			unit,
			EPNI_PCP_DEI_DP_MAPPING_TABLEm,
			MEM_BLOCK_ALL,
			entry_offset,
			data
			);
	SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
	
exit:
	SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_dp_map_tbl_set_unsafe",  entry_offset, 0);
}


uint32
  arad_pp_ihp_in_rif_config_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_IN_RIF_CONFIG_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->cos_profile = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, SOC_IS_JERICHO(unit)? IN_RIF_COS_PROFILEf: COS_PROFILEf);
  tbl_data->vrf = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, VRFf);

  if (SOC_IS_JERICHO(unit)) {
    tbl_data->rif_profile = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, IN_RIF_PROFILEf);    
  } else {
    tbl_data->uc_rpf_enable = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, UC_RPF_ENABLEf);
    tbl_data->enable_routing_mc = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_MCf);
    tbl_data->enable_routing_uc = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_UCf);
    tbl_data->enable_routing_mpls = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_MPLSf);
    tbl_data->l_3_vpn_default_routing = soc_mem_field32_get(unit, IHP_IN_RIF_CONFIG_TABLEm, data, L_3_VPN_DEFAULT_ROUTINGf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_in_rif_config_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_in_rif_config_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_IN_RIF_CONFIG_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, VRFf, tbl_data->vrf);
  soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, SOC_IS_JERICHO(unit)? IN_RIF_COS_PROFILEf: COS_PROFILEf, tbl_data->cos_profile);

  if (SOC_IS_JERICHO(unit)) {    
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, IN_RIF_PROFILEf, tbl_data->rif_profile);
  } else {
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, UC_RPF_ENABLEf, tbl_data->uc_rpf_enable);
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_MCf, tbl_data->enable_routing_mc);
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_UCf, tbl_data->enable_routing_uc);
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, ENABLE_ROUTING_MPLSf, tbl_data->enable_routing_mpls);
    soc_mem_field32_set(unit, IHP_IN_RIF_CONFIG_TABLEm, data, L_3_VPN_DEFAULT_ROUTINGf, tbl_data->l_3_vpn_default_routing);
  }

  res = soc_mem_write(
          unit,
          IHP_IN_RIF_CONFIG_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_in_rif_config_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_tc_dp_map_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_TC_DP_MAP_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->traffic_class_0 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_0f);
  tbl_data->drop_precedence_0 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_0f);
  tbl_data->traffic_class_1 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_1f);
  tbl_data->drop_precedence_1 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_1f);
  tbl_data->traffic_class_2 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_2f);
  tbl_data->drop_precedence_2 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_2f);
  tbl_data->traffic_class_3 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_3f);
  tbl_data->drop_precedence_3 = soc_mem_field32_get(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_3f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_tc_dp_map_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_tc_dp_map_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TC_DP_MAP_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_0f, tbl_data->traffic_class_0);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_0f, tbl_data->drop_precedence_0);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_1f, tbl_data->traffic_class_1);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_1f, tbl_data->drop_precedence_1);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_2f, tbl_data->traffic_class_2);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_2f, tbl_data->drop_precedence_2);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, TRAFFIC_CLASS_3f, tbl_data->traffic_class_3);
  soc_mem_field32_set(unit, IHP_TC_DP_MAP_TABLEm, data, DROP_PRECEDENCE_3f, tbl_data->drop_precedence_3);

  res = soc_mem_write(
          unit,
          IHP_TC_DP_MAP_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_tc_dp_map_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_PINFO_FER_TBL_ENTRY_SIZE 1

int
  arad_pp_ihb_pinfo_fer_tbl_get_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PINFO_FER_TBL_DATA *tbl_data
  )
{
    uint32 data[ARAD_PP_IHB_PINFO_FER_TBL_ENTRY_SIZE];

    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32) * ARAD_PP_IHB_PINFO_FER_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_PP_IHB_PINFO_FER_TBL_DATA));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(
          unit,
          IHB_PINFO_FERm,
          IHB_BLOCK(unit, core_id),
          entry_offset,
          data
        ));

    tbl_data->ecmp_lb_key_count = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, ECMP_LB_KEY_COUNTf);
    tbl_data->lag_lb_key_start = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, LAG_LB_KEY_STARTf);
    tbl_data->lag_lb_key_count = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, LAG_LB_KEY_COUNTf);
    tbl_data->lb_profile = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, LB_PROFILEf);
    tbl_data->lb_bos_search = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, LB_BOS_SEARCHf);
    tbl_data->lb_include_bos_hdr = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, LB_INCLUDE_BOS_HDRf);
    tbl_data->icmp_redirect_enable = soc_mem_field32_get(unit, IHB_PINFO_FERm, data, ICMP_REDIRECT_ENABLEf);

exit:
    SOCDNX_FUNC_RETURN;
}

int
  arad_pp_ihb_pinfo_fer_tbl_set_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PINFO_FER_TBL_DATA *tbl_data
  )
{
    uint32 data[ARAD_PP_IHB_PINFO_FER_TBL_ENTRY_SIZE];

    SOCDNX_INIT_FUNC_DEFS;
 
    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_IHB_PINFO_FER_TBL_ENTRY_SIZE);

    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, ECMP_LB_KEY_COUNTf, tbl_data->ecmp_lb_key_count);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, LAG_LB_KEY_STARTf, tbl_data->lag_lb_key_start);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, LAG_LB_KEY_COUNTf, tbl_data->lag_lb_key_count);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, LB_PROFILEf, tbl_data->lb_profile);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, LB_BOS_SEARCHf, tbl_data->lb_bos_search);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, LB_INCLUDE_BOS_HDRf, tbl_data->lb_include_bos_hdr);
    soc_mem_field32_set(unit, IHB_PINFO_FERm, data, ICMP_REDIRECT_ENABLEf, tbl_data->icmp_redirect_enable);

    SOCDNX_IF_ERR_EXIT(soc_mem_write(
          unit,
          IHB_PINFO_FERm,
          IHB_BLOCK(unit, core_id),
          entry_offset,
          data
        ));

exit:
    SOCDNX_FUNC_RETURN;
}

#define ARAD_PP_IHB_LB_PFC_PROFILE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihb_lb_pfc_profile_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_LB_PFC_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_LB_PFC_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LB_PFC_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_LB_PFC_PROFILE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_LB_PFC_PROFILE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_LB_PFC_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->lb_vector_index_1 = soc_mem_field32_get(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_1f);
  tbl_data->lb_vector_index_2 = soc_mem_field32_get(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_2f);
  tbl_data->lb_vector_index_3 = soc_mem_field32_get(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_3f);
  tbl_data->lb_vector_index_4 = soc_mem_field32_get(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_4f);
  tbl_data->lb_vector_index_5 = soc_mem_field32_get(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_5f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lb_pfc_profile_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_lb_pfc_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_LB_PFC_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_LB_PFC_PROFILE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LB_PFC_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_LB_PFC_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_1f, tbl_data->lb_vector_index_1);
  soc_mem_field32_set(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_2f, tbl_data->lb_vector_index_2);
  soc_mem_field32_set(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_3f, tbl_data->lb_vector_index_3);
  soc_mem_field32_set(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_4f, tbl_data->lb_vector_index_4);
  soc_mem_field32_set(unit, IHB_LB_PFC_PROFILEm, data, LB_VECTOR_INDEX_5f, tbl_data->lb_vector_index_5);

  res = soc_mem_write(
          unit,
          IHB_LB_PFC_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lb_pfc_profile_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihb_lb_vector_program_map_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_LB_VECTOR_PROGRAM_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  soc_mem_field64_get(unit, IHB_LB_VECTOR_PROGRAM_MAPm, data, CHUNK_BITMAPf, &tbl_data->chunk_bitmap);
  tbl_data->chunk_size = soc_mem_field32_get(unit, IHB_LB_VECTOR_PROGRAM_MAPm, data, CHUNK_SIZEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lb_vector_program_map_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_lb_vector_program_map_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_ENTRY_SIZE);

  soc_mem_field64_set(unit, IHB_LB_VECTOR_PROGRAM_MAPm, data, CHUNK_BITMAPf, tbl_data->chunk_bitmap);
  soc_mem_field32_set(unit, IHB_LB_VECTOR_PROGRAM_MAPm, data, CHUNK_SIZEf, tbl_data->chunk_size);

  res = soc_mem_write(
          unit,
          IHB_LB_VECTOR_PROGRAM_MAPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_lb_vector_program_map_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_fec_ecmp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FEC_ECMP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    ecmp_data[SOC_DPP_IMP_DEFS_MAX(IHB_FEC_ECMP_NOF_LONGS)],
    rpf_data;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ECMP_TBL_GET_UNSAFE);

  ARAD_CLEAR(ecmp_data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_FEC_ECMP_NOF_LONGS));
  ARAD_CLEAR(&rpf_data, uint32, 1);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FEC_ECMP_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_FEC_ECMPm,
          MEM_BLOCK_ANY,
          entry_offset,
          ecmp_data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->group_start_pointer = soc_mem_field32_get(unit, IHB_FEC_ECMPm, ecmp_data, GROUP_START_POINTERf);
  tbl_data->group_size = soc_mem_field32_get(unit, IHB_FEC_ECMPm, ecmp_data, GROUP_SIZEf);
  tbl_data->is_protected = soc_mem_field32_get(unit, IHB_FEC_ECMPm, ecmp_data, PROTECTEDf);
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->rpf_fec_pointer = soc_mem_field32_get(unit, IHB_FEC_ECMPm, ecmp_data, RPF_FEC_POINTERf);
  }
  else {
      /*On Jericho, RPF pointer is held on a different table*/
      res = soc_mem_read(
          unit,
          IHB_FEC_RPF_ECMPm,
          MEM_BLOCK_ANY,
          entry_offset,
          &rpf_data
        );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

      tbl_data->rpf_fec_pointer = soc_mem_field32_get(unit, IHB_FEC_RPF_ECMPm, &rpf_data, RPF_FEC_POINTERf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_ecmp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_fec_ecmp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FEC_ECMP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    ecmp_data[SOC_DPP_IMP_DEFS_MAX(IHB_FEC_ECMP_NOF_LONGS)],
    rpf_data;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ECMP_TBL_SET_UNSAFE);

  ARAD_CLEAR(ecmp_data, uint32, SOC_DPP_IMP_DEFS_MAX(IHB_FEC_ECMP_NOF_LONGS));
  ARAD_CLEAR(&rpf_data, uint32, 1);

  soc_mem_field32_set(unit, IHB_FEC_ECMPm, ecmp_data, GROUP_START_POINTERf, tbl_data->group_start_pointer);
  soc_mem_field32_set(unit, IHB_FEC_ECMPm, ecmp_data, GROUP_SIZEf, tbl_data->group_size);
  soc_mem_field32_set(unit, IHB_FEC_ECMPm, ecmp_data, PROTECTEDf, tbl_data->is_protected);
  
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHB_FEC_ECMPm, ecmp_data, RPF_FEC_POINTERf, tbl_data->rpf_fec_pointer);
  } 
  else {
      /*On Jericho, RPF pointer is held on a different table*/
      soc_mem_field32_set(unit, IHB_FEC_RPF_ECMPm, &rpf_data, RPF_FEC_POINTERf, tbl_data->rpf_fec_pointer);
  }

  res = soc_mem_write(
          unit,
          IHB_FEC_ECMPm,
          MEM_BLOCK_ANY,
          entry_offset,
          ecmp_data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      res = soc_mem_write(
          unit,
          IHB_FEC_RPF_ECMPm,
          MEM_BLOCK_ANY,
          entry_offset,
          &rpf_data
          );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 50, exit);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_ecmp_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_fec_super_entry_utilize_desc_dma(
    SOC_SAND_IN int   unit,
    SOC_SAND_IN uint8 enable
  )
{
    SOCDNX_INIT_FUNC_DEFS;

    arad_tbl_super_fec_utilize_desc_dma[unit] = enable;

    SOCDNX_FUNC_RETURN;
}

STATIC
  uint32
   arad_pp_fec_super_entry_update_cache_write_desc_dma(
      SOC_SAND_IN int       unit,
      SOC_SAND_IN soc_mem_t mem,
      SOC_SAND_IN uint32    fec_index,
      SOC_SAND_IN uint32   *data
      )
{
    uint32 blk;
    uint32 index = SOC_IS_QAX(unit) ? ARAD_PP_TBL_FEC_ENTRY_INDEX(fec_index) : JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, fec_index);
    uint32 array_index = SOC_IS_QAX(unit) ? 0 : JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, fec_index);
    int entry_dw = soc_mem_entry_words(unit, mem);
    int mem_array_vmap_offset = array_index * soc_mem_index_count(unit, mem);
    int mem_array_cache_offset = mem_array_vmap_offset * entry_dw;
    uint32 *cache;
    uint8 *vmap;

    SOCDNX_INIT_FUNC_DEFS;

    MEM_LOCK(unit, mem);
    SOC_MEM_BLOCK_ITER(unit, mem, blk) {
        cache = SOC_MEM_STATE(unit, mem).cache[blk];
        vmap = SOC_MEM_STATE(unit, mem).vmap[blk];
#if defined(BCM_88675_A0)
        /* Add a descriptor to the DMA chain */
        SOCDNX_IF_ERR_EXIT(jer_sbusdma_desc_add(unit, mem, array_index, blk, index, (void *)data));
#endif /* defined(BCM_88675_A0) */
        /* Update the cache */
        sal_memcpy(cache + mem_array_cache_offset + index * entry_dw, data, entry_dw * 4);
        CACHE_VMAP_SET(vmap, index);
    }

#if defined(BCM_88675_A0)
exit:
#endif /* defined(BCM_88675_A0) */
    MEM_UNLOCK(unit, mem);
    SOCDNX_FUNC_RETURN;
}

uint32
  arad_pp_ihb_fec_super_entry_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   fec_index,
    SOC_SAND_OUT ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_DATA *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_DATA, 1);

  mem = (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) ? PPDB_A_FEC_SUPER_ENTRY_BANKm : IHB_FEC_SUPER_ENTRYm;

  if (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) {
    res = soc_mem_array_read(
            unit,
            mem,
            JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, fec_index),
            MEM_BLOCK_ANY,
            JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, fec_index),
            data
          );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  } else {
    res = soc_mem_read(
            unit,
            IHB_FEC_SUPER_ENTRYm,
            MEM_BLOCK_ANY,
            ARAD_PP_SUPER_FEC_ENTRY_INDEX(fec_index),
            data
          );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  }

  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem, data, PROTECTION_POINTERf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_super_entry_tbl_get_unsafe()", fec_index, 0);
}

uint32
  arad_pp_ihb_fec_super_entry_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   fec_index,
    SOC_SAND_IN  ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_DATA *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE);

  mem = (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) ? PPDB_A_FEC_SUPER_ENTRY_BANKm : IHB_FEC_SUPER_ENTRYm;

  if (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) {
    res = soc_mem_array_read(
            unit,
            mem,
            JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, fec_index),
            MEM_BLOCK_ANY,
            JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, fec_index),
            data
          );
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  } else {
      res = soc_mem_read(
              unit,
              mem,
              MEM_BLOCK_ANY,
              ARAD_PP_TBL_FEC_ENTRY_INDEX(fec_index),
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  }

  soc_mem_field32_set(unit, mem, data, PROTECTION_POINTERf, tbl_data->protection_pointer);

  if (arad_tbl_super_fec_utilize_desc_dma[unit]) {
      res = arad_pp_fec_super_entry_update_cache_write_desc_dma(unit, mem, fec_index, data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  } else {
      if (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) {
        res = soc_mem_array_write(
                unit,
                mem,
                JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, fec_index),
                MEM_BLOCK_ANY,
                JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, fec_index),
                data
              );
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
      } else {
        res = soc_mem_write(
                unit,
                mem,
                MEM_BLOCK_ANY,
                ARAD_PP_TBL_FEC_ENTRY_INDEX(fec_index),
                data
              );
        SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
      }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_super_entry_tbl_set_unsafe()", fec_index, 0);
}


uint32
  arad_pp_ihb_fec_super_entry_tbl_fill_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_DATA *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];
  uint32 val[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];
  soc_mem_t mem;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE);

  mem = (SOC_IS_JERICHO(unit) && (!SOC_IS_QAX(unit))) ? PPDB_A_FEC_SUPER_ENTRY_BANKm : IHB_FEC_SUPER_ENTRYm;

  soc_mem_field32_set(unit,  mem, data, PROTECTION_POINTERf, tbl_data->protection_pointer);

  if (SOC_IS_JERICHO(unit)) {
      sal_memcpy(val, tbl_data->data0,  ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE * sizeof(uint32));
      soc_mem_field_set(unit, mem, data, DATA_0f, val);
      sal_memcpy(val, tbl_data->data1,  ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE * sizeof(uint32));
      soc_mem_field_set(unit, mem, data, DATA_1f, val);
  }

  res = arad_fill_table_with_entry(unit,  mem, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE);

      /* Set data in a different table */
      sal_memcpy(val, tbl_data->data0,  ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE * sizeof(uint32));
      soc_mem_field_set(unit, IHB_FEC_ENTRYm, data, DATAf, val);

      res = arad_fill_table_with_entry(unit,  IHB_FEC_ENTRYm, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_super_entry_tbl_set_unsafe()", 0, 0);
}

#define ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihb_fec_entry_general_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_DATA *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE];
  uint32 entry_format=0;
  uint8  system_headers_mode;


  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_DATA, 1);

  if (SOC_IS_JERICHO(unit)) {
      uint32 super_entry_data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];

      if(SOC_IS_QAX(unit))
      {
          res = READ_IHB_FEC_SUPER_ENTRYm( unit,
                                           MEM_BLOCK_ANY,
                                           ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                                           super_entry_data );
      }
      else
      {
          res = READ_PPDB_A_FEC_SUPER_ENTRY_BANKm( unit,
                                                   JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                                                   MEM_BLOCK_ANY,
                                                   JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                                                   super_entry_data);
      }

      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);
      soc_mem_field_get(unit, (SOC_IS_QAX(unit)) ? IHB_FEC_SUPER_ENTRYm :PPDB_A_FEC_SUPER_ENTRY_BANKm, super_entry_data,
                        JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);
  }
  else {
      res = READ_IHB_FEC_ENTRY_GENERALm(
              unit,
              ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
              MEM_BLOCK_ANY,
              ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);
  }

  tbl_data->destination = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, DESTINATIONf);
  tbl_data->uc_rpf_mode = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, UC_RPF_MODEf);
  tbl_data->mc_rpf_mode = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, MC_RPF_MODEf);

  SHR_BITCOPY_RANGE(&entry_format,0, data, SOC_IS_ARADPLUS_AND_BELOW(unit)?50:56, 1);
  if(entry_format == 0) { /* format A */
    tbl_data->arp_ptr = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A), data, ARP_PTRf);
    tbl_data->out_lif = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A), data, OUT_LIFf);
    tbl_data->format = ARAD_PP_IHB_FEC_FORMAT_A;

    if (SOC_IS_JERICHO(unit)) {

        res = sw_state_access[unit].dpp.soc.arad.pp.header_data.system_headers_mode.get(unit, &system_headers_mode);
        SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

        if (system_headers_mode == ARAD_PP_SYSTEM_HEADERS_MODE_ARAD) {
            /*
             * In case of Arad system headers mode in Jericho EEI should be configured explicitly
             * inside the FEC table to adjust the Jericho format.
             * In case format - A- configure fec_entry_format_a_arp_pointer[17:16] to be 2b11, 
             * so we need to take the extra bits off. 
             */
            tbl_data->arp_ptr &= ~0x30000;
        }
    }

    goto  exit;
  }
  entry_format = 0;
  SHR_BITCOPY_RANGE(&entry_format,0, data,SOC_IS_ARADPLUS_AND_BELOW(unit)?49:55, 2);
  if(entry_format == 3) { /* format NULL */
    tbl_data->format = ARAD_PP_IHB_FEC_FORMAT_NULL;
    goto  exit;
  }
  entry_format = 0;
  SHR_BITCOPY_RANGE(&entry_format,0, data,SOC_IS_ARADPLUS_AND_BELOW(unit)?48:54, 3);
  if(entry_format == 4) { /* format B */
    tbl_data->format = ARAD_PP_IHB_FEC_FORMAT_B;
    tbl_data->out_lif = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_B), data, OUT_LIFf);
    goto exit;
  }
  if(entry_format == 5) { /* format C */
    tbl_data->format = ARAD_PP_IHB_FEC_FORMAT_C;
    tbl_data->eei = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_C), data, EEIf);

    if (SOC_IS_JERICHO(unit)) {
        res = sw_state_access[unit].dpp.soc.arad.pp.header_data.system_headers_mode.get(unit, &system_headers_mode);
        SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

        if ((system_headers_mode == ARAD_PP_SYSTEM_HEADERS_MODE_ARAD) && ((tbl_data->eei & 0xC00000) == 0xC00000)) {
            /*
            * In case of Arad system headers mode in Jericho EEI should be configured explicitly
            * inside the FEC table to adjust the Jericho format.
            * In case format - C: if the EEI if of type outlif (EEI[23:22] == 2b11) fec_entry[23:20] was configured to 4b1111.
            * So we need to take the extra bits off.  
            */
            tbl_data->eei &= ~0x300000;
        }
    }

    goto exit;
  }
 
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_entry_general_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_fec_entry_general_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_DATA *tbl_data
  )
{
  uint32 res = SOC_SAND_OK;
  uint32 data[ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE];
  uint32 entry_format;
  uint8  system_headers_mode;
  uint64 field64;
  uint32 eei;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, UC_RPF_MODEf, tbl_data->uc_rpf_mode);
  soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, MC_RPF_MODEf, tbl_data->mc_rpf_mode);
  if(tbl_data->format == ARAD_PP_IHB_FEC_FORMAT_A) {
    entry_format = 0;

    eei = tbl_data->arp_ptr;
    if (SOC_IS_JERICHO(unit)) {

        res = sw_state_access[unit].dpp.soc.arad.pp.header_data.system_headers_mode.get(unit, &system_headers_mode);
        SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

        if (system_headers_mode == ARAD_PP_SYSTEM_HEADERS_MODE_ARAD) {
            /*
             * In case of Arad system headers mode in Jericho EEI should be configured explicitly
             * inside the FEC table to adjust the Jericho format.
             * In case format - A- configure fec_entry_format_a_arp_pointer[17:16] to be 2b11
             */
            eei = tbl_data->arp_ptr | 0x30000;
        }
    }

    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A), data, ARP_PTRf, eei);
    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A), data, OUT_LIFf, tbl_data->out_lif);
    if (SOC_IS_JERICHO(unit)) {
           soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A), data, OUT_LIF_IS_NATIVE_VSIf, 1);
    }
    soc_mem_field32_set(unit,  ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_A) , data, IDENTIFIERf, entry_format);
  }
  else if(tbl_data->format == ARAD_PP_IHB_FEC_FORMAT_NULL) {
    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        soc_mem_field32_set(unit, IHB_FEC_ENTRY_FORMAT_NULLm, data, RESERVEDf, 0);
    }
    else {
        COMPILER_64_ZERO(field64);
        soc_mem_field64_set(unit,ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_NULL), data, RESERVEDf, field64);
    }
    entry_format = 3;
    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_NULL), data, IDENTIFIERf, entry_format);
  }
  else if(tbl_data->format == ARAD_PP_IHB_FEC_FORMAT_B) {
    entry_format = 4;
    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_B), data, OUT_LIFf, tbl_data->out_lif);
    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_B), data, RESERVEDf, 0);
    soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_B), data, IDENTIFIERf, entry_format);
  }
  else if (tbl_data->format == ARAD_PP_IHB_FEC_FORMAT_C) {
      eei = tbl_data->eei;
      if (SOC_IS_JERICHO(unit)) {
          res = sw_state_access[unit].dpp.soc.arad.pp.header_data.system_headers_mode.get(unit, &system_headers_mode);
          SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);

          if ((system_headers_mode == ARAD_PP_SYSTEM_HEADERS_MODE_ARAD) && ((tbl_data->eei & 0xC00000) == 0xC00000)) {
              /*
              * In case of Arad system headers mode in Jericho EEI should be configured explicitly
              * inside the FEC table to adjust the Jericho format.
              * In case format - C: if the EEI if of type outlif (EEI[23:22] == 2b11) configure fec_entry[23:20] to be 4b1111
              */
              eei = tbl_data->eei | 0x300000;
          }
      }

      entry_format = 5;
      soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_C), data, EEIf, eei);
      soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_C), data, RESERVEDf, 0);
      soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_FORMAT_C), data, IDENTIFIERf, entry_format);
  }
  
  if (SOC_IS_JERICHO(unit)) {
      uint32 super_entry_data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];

      if(SOC_IS_QAX(unit))
      {
          res = READ_IHB_FEC_SUPER_ENTRYm( unit,
                  MEM_BLOCK_ANY,
                  ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                  super_entry_data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);

          soc_mem_field_set(unit, IHB_FEC_SUPER_ENTRYm, super_entry_data,
                  JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);

          if (arad_tbl_super_fec_utilize_desc_dma[unit]) {
              res = arad_pp_fec_super_entry_update_cache_write_desc_dma(unit, IHB_FEC_SUPER_ENTRYm, entry_offset, super_entry_data);
              SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
          } else {
              res = WRITE_IHB_FEC_SUPER_ENTRYm( unit,
                      MEM_BLOCK_ANY,
                      ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                      super_entry_data);
              SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
          }
      }
      else
      {
          res = READ_PPDB_A_FEC_SUPER_ENTRY_BANKm(unit,
                  JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                  MEM_BLOCK_ANY,
                  JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                  super_entry_data);
          SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

          soc_mem_field_set(unit, PPDB_A_FEC_SUPER_ENTRY_BANKm, super_entry_data,
                  JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);

          if (arad_tbl_super_fec_utilize_desc_dma[unit]) {
              res = arad_pp_fec_super_entry_update_cache_write_desc_dma(unit, PPDB_A_FEC_SUPER_ENTRY_BANKm, entry_offset, super_entry_data);
              SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
          } else {
              res = WRITE_PPDB_A_FEC_SUPER_ENTRY_BANKm( unit,
                      JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                      MEM_BLOCK_ANY,
                      JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                      super_entry_data);
              SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
          }
      }
  } else {
      res = WRITE_IHB_FEC_ENTRY_GENERALm( unit,
              ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
              MEM_BLOCK_ANY,
              ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
              data);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 31, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fec_entry_general_tbl_set_unsafe()", entry_offset, 0);
}

uint32
arad_pp_ihb_fec_entry_general_tbl_uc_rpf_mode_set(
    int                         unit,
	uint32                      entry_offset,
	uint32                      uc_rpf_mode
)
{
  uint32
    rv,
	prev_uc_rpf_mode,
    data[ARAD_PP_IHB_FEC_ENTRY_GENERAL_TBL_ENTRY_SIZE],
	super_entry_data[ARAD_PP_IHB_FEC_SUPER_ENTRY_TBL_ENTRY_SIZE];

  SOCDNX_INIT_FUNC_DEFS;

  if (SOC_IS_JERICHO(unit)) {
      if(SOC_IS_QAX(unit))
      {
          rv = READ_IHB_FEC_SUPER_ENTRYm( unit,
                                           MEM_BLOCK_ANY,
                                           ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                                           super_entry_data );
      }
      else
      {
          rv = READ_PPDB_A_FEC_SUPER_ENTRY_BANKm( unit,
                                                   JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                                                   MEM_BLOCK_ANY,
                                                   JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                                                   super_entry_data);
      }

      SOCDNX_IF_ERR_EXIT(rv);
      soc_mem_field_get(unit, (SOC_IS_QAX(unit)) ? IHB_FEC_SUPER_ENTRYm :PPDB_A_FEC_SUPER_ENTRY_BANKm, super_entry_data,
                        JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);
  }
  else {
      rv = READ_IHB_FEC_ENTRY_GENERALm(
              unit,
              ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
              MEM_BLOCK_ANY,
              ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
              data
            );
      SOCDNX_IF_ERR_EXIT(rv);
  }
 
  prev_uc_rpf_mode = soc_mem_field32_get(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, UC_RPF_MODEf);

  /*No change*/
  if (prev_uc_rpf_mode == uc_rpf_mode) {
	  goto exit;
  }

  soc_mem_field32_set(unit, ARAD_PP_FEC_ENTRY_FORMAT_BY_CHIP(unit, FEC_ENTRY_GENERAL), data, UC_RPF_MODEf, uc_rpf_mode);

  if (SOC_IS_JERICHO(unit)) {
      if(SOC_IS_QAX(unit))
      {
          rv = READ_IHB_FEC_SUPER_ENTRYm( unit,
                  MEM_BLOCK_ANY,
                  ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                  super_entry_data);
          SOCDNX_IF_ERR_EXIT(rv);

          soc_mem_field_set(unit, IHB_FEC_SUPER_ENTRYm, super_entry_data,
                  JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);

          rv = WRITE_IHB_FEC_SUPER_ENTRYm( unit,
                  MEM_BLOCK_ANY,
                  ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
                  super_entry_data);
          SOCDNX_IF_ERR_EXIT(rv);
      }
      else
      {
          rv = READ_PPDB_A_FEC_SUPER_ENTRY_BANKm(unit,
                  JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                  MEM_BLOCK_ANY,
                  JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                  super_entry_data);
          SOCDNX_IF_ERR_EXIT(rv);

          soc_mem_field_set(unit, PPDB_A_FEC_SUPER_ENTRY_BANKm, super_entry_data,
                  JERICHO_PP_FEC_ENTRY_OFFSET(unit, entry_offset) == 0 ? DATA_0f : DATA_1f, data);

          rv = WRITE_PPDB_A_FEC_SUPER_ENTRY_BANKm( unit,
                  JERICHO_PP_SUPER_FEC_ARRAY_INDEX(unit, entry_offset),
                  MEM_BLOCK_ANY,
                  JERICHO_PP_SUPER_FEC_ENTRY_INDEX(unit, entry_offset),
                  super_entry_data);
          SOCDNX_IF_ERR_EXIT(rv);
      }
  } else {
      rv = WRITE_IHB_FEC_ENTRY_GENERALm( unit,
              ARAD_PP_TBL_FEC_ARRAY_INDEX(entry_offset),
              MEM_BLOCK_ANY,
              ARAD_PP_TBL_FEC_ENTRY_INDEX(entry_offset),
              data);
      SOCDNX_IF_ERR_EXIT(rv);
  }

exit:
	SOCDNX_FUNC_RETURN;
}

#define ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihb_destination_status_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_DESTINATION_STATUS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_DESTINATION_STATUS_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_DESTINATION_STATUS_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_DESTINATION_STATUSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->destination_valid[0] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_0f);
  tbl_data->destination_valid[1] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_1f);
  tbl_data->destination_valid[2] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_2f);
  tbl_data->destination_valid[3] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_3f);
  tbl_data->destination_valid[4] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_4f);
  tbl_data->destination_valid[5] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_5f);
  tbl_data->destination_valid[6] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_6f);
  tbl_data->destination_valid[7] = soc_mem_field32_get(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_7f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_destination_status_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_destination_status_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_DESTINATION_STATUS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_DESTINATION_STATUS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_0f, tbl_data->destination_valid[0]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_1f, tbl_data->destination_valid[1]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_2f, tbl_data->destination_valid[2]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_3f, tbl_data->destination_valid[3]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_4f, tbl_data->destination_valid[4]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_5f, tbl_data->destination_valid[5]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_6f, tbl_data->destination_valid[6]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_7f, tbl_data->destination_valid[7]);

  res = soc_mem_write(
          unit,
          IHB_DESTINATION_STATUSm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_destination_status_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_destination_status_tbl_fill_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  ARAD_PP_IHB_DESTINATION_STATUS_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_DESTINATION_STATUS_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_DESTINATION_STATUS_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_0f, tbl_data->destination_valid[0]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_1f, tbl_data->destination_valid[1]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_2f, tbl_data->destination_valid[2]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_3f, tbl_data->destination_valid[3]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_4f, tbl_data->destination_valid[4]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_5f, tbl_data->destination_valid[5]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_6f, tbl_data->destination_valid[6]);
  soc_mem_field32_set(unit, IHB_DESTINATION_STATUSm, data, DESTINATION_VALID_7f, tbl_data->destination_valid[7]);

  res = arad_fill_table_with_entry(unit, IHB_DESTINATION_STATUSm, MEM_BLOCK_ANY, data); /* fill memory with the entry in data */
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_destination_status_tbl_set_unsafe()", 0, 0);
}

#define ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_ENTRY_SIZE 5

uint32
  arad_pp_ihb_fwd_act_profile_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_FWD_ACT_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fwd_act_trap = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAPf);
  tbl_data->fwd_act_destination = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATIONf);
  tbl_data->fwd_act_destination_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_OVERWRITEf);
  tbl_data->fwd_act_out_lif = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_OUT_LIFf);
  tbl_data->fwd_act_out_lif_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_OUT_LIF_OVERWRITEf);
  tbl_data->fwd_act_eei = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_EEIf);
  tbl_data->fwd_act_eei_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_EEI_OVERWRITEf);
  tbl_data->fwd_act_destination_add_vsi = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_ADD_VSIf);
  tbl_data->fwd_act_destination_add_vsi_shift = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_ADD_VSI_SHIFTf);
  tbl_data->fwd_act_traffic_class = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAFFIC_CLASSf);
  tbl_data->fwd_act_traffic_class_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAFFIC_CLASS_OVERWRITEf);
  tbl_data->fwd_act_drop_precedence = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCEf);
  tbl_data->fwd_act_drop_precedence_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_OVERWRITEf);
  tbl_data->fwd_act_meter_pointer_a_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_A_OVERWRITEf);
  tbl_data->fwd_act_meter_pointer_b_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_B_OVERWRITEf);
  tbl_data->fwd_act_meter_pointer = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTERf);
  tbl_data->fwd_act_meter_pointer_update = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_UPDATEf);
  tbl_data->fwd_act_counter_pointer = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTERf);
  tbl_data->fwd_act_counter_pointer_a_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_A_OVERWRITEf);
  tbl_data->fwd_act_counter_pointer_b_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_B_OVERWRITEf);
  tbl_data->fwd_act_counter_pointer_update = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_UPDATEf);
  tbl_data->fwd_act_drop_precedence_meter_command = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_METER_COMMANDf);
  tbl_data->fwd_act_drop_precedence_meter_command_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_METER_COMMAND_OVERWRITEf);
  tbl_data->fwd_act_forwarding_code = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FORWARDING_CODEf);
  tbl_data->fwd_act_forwarding_code_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FORWARDING_CODE_OVERWRITEf);
  tbl_data->fwd_act_fwd_offset_index = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_INDEXf);
  tbl_data->fwd_act_fwd_offset_fix = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_FIXf);
  tbl_data->fwd_act_fwd_offset_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_OVERWRITEf);
  tbl_data->fwd_act_ethernet_policer_pointer = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_ETHERNET_POLICER_POINTERf);
  tbl_data->fwd_act_ethernet_policer_pointer_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_ETHERNET_POLICER_POINTER_OVERWRITEf);
  tbl_data->fwd_act_learn_disable = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_LEARN_DISABLEf);
  tbl_data->fwd_act_bypass_filtering = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_BYPASS_FILTERINGf);
  tbl_data->fwd_act_da_type_overwrite = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DA_TYPE_OVERWRITEf);
  tbl_data->fwd_act_da_type = soc_mem_field32_get(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DA_TYPEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fwd_act_profile_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_fwd_act_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_DATA *tbl_data,
    SOC_SAND_IN  int                                    core_id
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_FWD_ACT_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAPf, tbl_data->fwd_act_trap);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATIONf, tbl_data->fwd_act_destination);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_OVERWRITEf, tbl_data->fwd_act_destination_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_OUT_LIFf, tbl_data->fwd_act_out_lif);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_OUT_LIF_OVERWRITEf, tbl_data->fwd_act_out_lif_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_EEIf, tbl_data->fwd_act_eei);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_EEI_OVERWRITEf, tbl_data->fwd_act_eei_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_ADD_VSIf, tbl_data->fwd_act_destination_add_vsi);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DESTINATION_ADD_VSI_SHIFTf, tbl_data->fwd_act_destination_add_vsi_shift);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAFFIC_CLASSf, tbl_data->fwd_act_traffic_class);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_TRAFFIC_CLASS_OVERWRITEf, tbl_data->fwd_act_traffic_class_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCEf, tbl_data->fwd_act_drop_precedence);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_OVERWRITEf, tbl_data->fwd_act_drop_precedence_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_A_OVERWRITEf, tbl_data->fwd_act_meter_pointer_a_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_B_OVERWRITEf, tbl_data->fwd_act_meter_pointer_b_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTERf, tbl_data->fwd_act_meter_pointer);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_METER_POINTER_UPDATEf, tbl_data->fwd_act_meter_pointer_update);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTERf, tbl_data->fwd_act_counter_pointer);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_A_OVERWRITEf, tbl_data->fwd_act_counter_pointer_a_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_B_OVERWRITEf, tbl_data->fwd_act_counter_pointer_b_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_COUNTER_POINTER_UPDATEf, tbl_data->fwd_act_counter_pointer_update);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_METER_COMMANDf, tbl_data->fwd_act_drop_precedence_meter_command);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DROP_PRECEDENCE_METER_COMMAND_OVERWRITEf, tbl_data->fwd_act_drop_precedence_meter_command_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FORWARDING_CODEf, tbl_data->fwd_act_forwarding_code);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FORWARDING_CODE_OVERWRITEf, tbl_data->fwd_act_forwarding_code_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_INDEXf, tbl_data->fwd_act_fwd_offset_index);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_FIXf, tbl_data->fwd_act_fwd_offset_fix);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_FWD_OFFSET_OVERWRITEf, tbl_data->fwd_act_fwd_offset_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_ETHERNET_POLICER_POINTERf, tbl_data->fwd_act_ethernet_policer_pointer);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_ETHERNET_POLICER_POINTER_OVERWRITEf, tbl_data->fwd_act_ethernet_policer_pointer_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_LEARN_DISABLEf, tbl_data->fwd_act_learn_disable);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_BYPASS_FILTERINGf, tbl_data->fwd_act_bypass_filtering);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DA_TYPE_OVERWRITEf, tbl_data->fwd_act_da_type_overwrite);
  soc_mem_field32_set(unit, IHB_FWD_ACT_PROFILEm, data, FWD_ACT_DA_TYPEf, tbl_data->fwd_act_da_type);

  res = soc_mem_write(
          unit,
          IHB_FWD_ACT_PROFILEm,
          IHB_BLOCK(unit,core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_fwd_act_profile_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_SNOOP_ACTION_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihb_snoop_action_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_SNOOP_ACTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_SNOOP_ACTION_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_SNOOP_ACTION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_SNOOP_ACTION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_SNOOP_ACTION_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_SNOOP_ACTIONm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->snoop_action = soc_mem_field32_get(unit, IHB_SNOOP_ACTIONm, data, SNOOP_ACTIONf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_snoop_action_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_snoop_action_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_SNOOP_ACTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_SNOOP_ACTION_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_SNOOP_ACTION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_SNOOP_ACTION_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_SNOOP_ACTIONm, data, SNOOP_ACTIONf, tbl_data->snoop_action);

  res = soc_mem_write(
          unit,
          IHB_SNOOP_ACTIONm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_snoop_action_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE 1


uint32
  arad_pp_ihp_pp_port_program_select_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT uint32 * profile
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE];
  soc_mem_t
    port_prog_sel_flp_mem;
  int 
    block;


  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);
  (*profile) = 0;

  port_prog_sel_flp_mem = IHP_FLP_PP_PORT_PROGRAM_SELECTm;
  block =  IHP_BLOCK(unit, core_id);

  res = soc_mem_read(unit, port_prog_sel_flp_mem, block, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  (*profile) = soc_mem_field32_get(unit, port_prog_sel_flp_mem, data, PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pp_port_program_select_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_pp_port_program_select_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT uint32 profile
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE];
  soc_mem_t
    port_prog_sel_flp_mem;
  int 
    block;


  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);

  port_prog_sel_flp_mem = IHP_FLP_PP_PORT_PROGRAM_SELECTm;
  block =  IHP_BLOCK(unit, core_id);

  res = soc_mem_read(unit, port_prog_sel_flp_mem, block, entry_offset, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  soc_mem_field32_set(unit, port_prog_sel_flp_mem, data, PROFILEf, profile);  

  res = soc_mem_write(
          unit,
          port_prog_sel_flp_mem,
          block,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_pp_port_program_select_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_pinfo_flp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_PINFO_FLP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE];
  soc_mem_t
    pinfo_flp_mem;
  int 
    block;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PINFO_FLP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_PINFO_FLP_TBL_DATA, 1);

  if (SOC_IS_JERICHO(unit)) {
      pinfo_flp_mem = IHP_PINFO_FLP_0m;
      block =  IHP_BLOCK(unit, core_id);
  } else {
      pinfo_flp_mem = IHB_PINFO_FLPm;
      block = MEM_BLOCK_ANY;
  }
  res = soc_mem_read(
          unit,
          pinfo_flp_mem,
          block,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);


  if (!SOC_IS_JERICHO_PLUS(unit)) {
      tbl_data->program_selection_profile = soc_mem_field32_get(unit, pinfo_flp_mem, data, PROGRAM_SELECTION_PROFILEf);
  }else{
    res = arad_pp_ihp_pp_port_program_select_tbl_get_unsafe(unit, core_id, entry_offset, &(tbl_data->program_selection_profile));
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 35, exit);
  }

  tbl_data->enable_pp_inject = soc_mem_field32_get(unit, pinfo_flp_mem, data, ENABLE_PP_INJECTf);
  tbl_data->key_gen_var = soc_mem_field32_get(unit, pinfo_flp_mem, data, KEY_GEN_VARf);
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->mapped_pp_port = soc_mem_field32_get(unit, pinfo_flp_mem, data, MAPPED_PP_PORTf);
  }

  if (SOC_IS_JERICHO(unit)) {
      pinfo_flp_mem = IHP_PINFO_FLP_1m;
      ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);
      res = soc_mem_read(
              unit,
              pinfo_flp_mem,
              block,
              entry_offset,
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  }

  tbl_data->action_profile_sa_drop_index = soc_mem_field32_get(unit, pinfo_flp_mem, data, ACTION_PROFILE_SA_DROP_INDEXf);
  tbl_data->action_profile_sa_not_found_index = soc_mem_field32_get(unit, pinfo_flp_mem, data, ACTION_PROFILE_SA_NOT_FOUND_INDEXf);
  tbl_data->action_profile_da_not_found_index = soc_mem_field32_get(unit, pinfo_flp_mem, data, ACTION_PROFILE_DA_NOT_FOUND_INDEXf);
  tbl_data->enable_unicast_same_interface_filter = soc_mem_field32_get(unit, pinfo_flp_mem, data, ENABLE_UNICAST_SAME_INTERFACE_FILTERf);
  tbl_data->learn_enable = soc_mem_field32_get(unit, pinfo_flp_mem, data, LEARN_ENABLEf);
  tbl_data->port_is_pbp = soc_mem_field32_get(unit, pinfo_flp_mem, data, PORT_IS_PBPf);
  tbl_data->ieee_1588_profile = soc_mem_field32_get(unit, pinfo_flp_mem, data, IEEE_1588_PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pinfo_flp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_pinfo_flp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_PINFO_FLP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE];
  soc_mem_t
    pinfo_flp_mem;
  int 
    block;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_PINFO_FLP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);
  if (SOC_IS_JERICHO(unit)) {
      pinfo_flp_mem = IHP_PINFO_FLP_0m;
      block =  IHP_BLOCK(unit, core_id);
  } else {
      pinfo_flp_mem = IHB_PINFO_FLPm;
      block = MEM_BLOCK_ANY;
  }
  if (!SOC_IS_JERICHO_PLUS(unit)) {
      soc_mem_field32_set(unit, pinfo_flp_mem, data, PROGRAM_SELECTION_PROFILEf, tbl_data->program_selection_profile);
  }else{
    res = arad_pp_ihp_pp_port_program_select_tbl_set_unsafe(unit, core_id, entry_offset, tbl_data->program_selection_profile);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);
  }

  soc_mem_field32_set(unit, pinfo_flp_mem, data, ENABLE_PP_INJECTf, tbl_data->enable_pp_inject);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, KEY_GEN_VARf, tbl_data->key_gen_var);
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, pinfo_flp_mem, data, MAPPED_PP_PORTf, tbl_data->mapped_pp_port);
  }

  if (SOC_IS_JERICHO(unit)) {
      res = soc_mem_write(
              unit,
              pinfo_flp_mem,
              block,
              entry_offset,
              data
            );
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);
      pinfo_flp_mem = IHP_PINFO_FLP_1m;
      ARAD_CLEAR(data, uint32, ARAD_PP_IHB_PINFO_FLP_TBL_ENTRY_SIZE);
  }

  soc_mem_field32_set(unit, pinfo_flp_mem, data, ACTION_PROFILE_SA_DROP_INDEXf, tbl_data->action_profile_sa_drop_index);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, ACTION_PROFILE_SA_NOT_FOUND_INDEXf, tbl_data->action_profile_sa_not_found_index);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, ACTION_PROFILE_DA_NOT_FOUND_INDEXf, tbl_data->action_profile_da_not_found_index);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, ENABLE_UNICAST_SAME_INTERFACE_FILTERf, tbl_data->enable_unicast_same_interface_filter);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, LEARN_ENABLEf, tbl_data->learn_enable);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, PORT_IS_PBPf, tbl_data->port_is_pbp);
  soc_mem_field32_set(unit, pinfo_flp_mem, data, IEEE_1588_PROFILEf, tbl_data->ieee_1588_profile);

  res = soc_mem_write(
          unit,
          pinfo_flp_mem,
          block,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_pinfo_flp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_VRF_CONFIG_TBL_ENTRY_SIZE 2

uint32
  arad_pp_ihb_vrf_config_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_VRF_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_VRF_CONFIG_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_VRF_CONFIG_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_VRF_CONFIG_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_VRF_CONFIG_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_VRF_CONFIGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->default_action_uc = soc_mem_field32_get(unit, IHB_VRF_CONFIGm, data, DEFAULT_ACTION_UCf);
  tbl_data->default_action_mc = soc_mem_field32_get(unit, IHB_VRF_CONFIGm, data, DEFAULT_ACTION_MCf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_vrf_config_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_vrf_config_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_VRF_CONFIG_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_VRF_CONFIG_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_VRF_CONFIG_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_VRF_CONFIG_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_VRF_CONFIGm, data, DEFAULT_ACTION_UCf, tbl_data->default_action_uc);
  soc_mem_field32_set(unit, IHB_VRF_CONFIGm, data, DEFAULT_ACTION_MCf, tbl_data->default_action_mc);

  res = soc_mem_write(
          unit,
          IHB_VRF_CONFIGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_vrf_config_tbl_set_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihb_header_profile_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHB_HEADER_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data = 0;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_HEADER_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(tbl_data, ARAD_PP_IHB_HEADER_PROFILE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHB_HEADER_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          &data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->st_vsq_ptr_tc_mode = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, ST_VSQ_PTR_TC_MODEf);
  tbl_data->build_ftmh = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, BUILD_FTMHf);
  tbl_data->build_pph = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, BUILD_PPHf);
  tbl_data->always_add_pph_learn_ext = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, ALWAYS_ADD_PPH_LEARN_EXTf);
  tbl_data->never_add_pph_learn_ext = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, NEVER_ADD_PPH_LEARN_EXTf);
  tbl_data->enable_stacking_uc = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, ENABLE_STACKING_UCf);
  tbl_data->enable_stacking_mc = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, ENABLE_STACKING_MCf);
  tbl_data->user_header_1_size = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, USER_HEADER_1_SIZEf);
  tbl_data->user_header_2_size = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, USER_HEADER_2_SIZEf);
  tbl_data->mc_id_in_user_header_2 = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, MC_ID_IN_USER_HEADER_2f);
  tbl_data->out_lif_in_user_header_2 = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, OUT_LIF_IN_USER_HEADER_2f);
  tbl_data->ftmh_reserved_value = soc_IHB_HEADER_PROFILEm_field32_get(unit, &data, FTMH_RESERVED_VALUEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_header_profile_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihb_header_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_HEADER_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data = 0;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_HEADER_PROFILE_TBL_SET_UNSAFE);

  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, ST_VSQ_PTR_TC_MODEf, tbl_data->st_vsq_ptr_tc_mode);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, BUILD_FTMHf, tbl_data->build_ftmh);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, BUILD_PPHf, tbl_data->build_pph);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, ALWAYS_ADD_PPH_LEARN_EXTf, tbl_data->always_add_pph_learn_ext);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, NEVER_ADD_PPH_LEARN_EXTf, tbl_data->never_add_pph_learn_ext);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, ENABLE_STACKING_UCf, tbl_data->enable_stacking_uc);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, ENABLE_STACKING_MCf, tbl_data->enable_stacking_mc);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, USER_HEADER_1_SIZEf, tbl_data->user_header_1_size);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, USER_HEADER_2_SIZEf, tbl_data->user_header_2_size);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, MC_ID_IN_USER_HEADER_2f, tbl_data->mc_id_in_user_header_2);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, OUT_LIF_IN_USER_HEADER_2f, tbl_data->out_lif_in_user_header_2);
  soc_IHB_HEADER_PROFILEm_field32_set(unit, &data, FTMH_RESERVED_VALUEf, tbl_data->ftmh_reserved_value);

  res = soc_mem_write(
          unit,
          IHB_HEADER_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          &data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_header_profile_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHB_SNP_ACT_PROFILE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihb_snp_act_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHB_SNP_ACT_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHB_SNP_ACT_PROFILE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHB_SNP_ACT_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHB_SNP_ACT_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHB_SNP_ACT_PROFILEm, data, SAMPLING_PROBABILITYf, tbl_data->sampling_probability);

  res = soc_mem_write(
          unit,
          IHB_SNP_ACT_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihb_snp_act_profile_tbl_set_unsafe()", entry_offset, 0);
}


#define ARAD_PP_EGQ_PP_PPCT_TBL_ENTRY_SIZE 3

uint32
  arad_pp_egq_pp_ppct_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_PP_PPCT_TBL_DATA *tbl_data
  )
{
    uint32 res = SOC_SAND_OK;
    uint32 data[ARAD_PP_EGQ_PP_PPCT_TBL_ENTRY_SIZE];

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_PP_PPCT_TBL_GET_UNSAFE);

    ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_PP_PPCT_TBL_ENTRY_SIZE);
    ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_PP_PPCT_TBL_DATA, 1);


    res = soc_mem_read(
              unit,
              EGQ_PP_PPCTm,
              EGQ_BLOCK(unit, core_id),
              entry_offset,
              data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    tbl_data->pvlan_port_type = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, PVLAN_PORT_TYPEf);
    tbl_data->unknown_bc_da_action_filter = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, UNKNOWN_BC_DA_ACTION_FILTERf);
    tbl_data->unknown_mc_da_action_filter = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, UNKNOWN_MC_DA_ACTION_FILTERf);
    tbl_data->unknown_uc_da_action_filter = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, UNKNOWN_UC_DA_ACTION_FILTERf);
    tbl_data->acceptable_frame_type_profile = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ACCEPTABLE_FRAME_TYPE_PROFILEf);
    tbl_data->egress_vsi_filtering_enable = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, EGRESS_VSI_FILTERING_ENABLEf);
    tbl_data->disable_filtering = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, DISABLE_FILTERINGf);
    tbl_data->port_is_pbp = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, PORT_IS_PBPf);
    tbl_data->pmf_profile = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, PMF_PROFILEf);
    tbl_data->orientation = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ORIENTATIONf);
    tbl_data->mtu = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, MTUf);
    tbl_data->pmf_data = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, PMF_DATAf);
    /* tbl_data->enable_same_interface_filters_lifs = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ENABLE_SAME_INTERFACE_FILTERS_LIFSf); */
    if (soc_mem_field_valid(unit, EGQ_PP_PPCTm, ENABLE_MULTICAST_SAME_INTERFACE_FILTERSf)) {
        tbl_data->enable_same_interface_filters_ports =
            soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ENABLE_MULTICAST_SAME_INTERFACE_FILTERSf);
    } else {
        tbl_data->enable_same_interface_filters_ports =
            soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ENABLE_SAME_INTERFACE_FILTERS_PORTSf);
    }
    tbl_data->enable_unicast_same_interface_filter = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ENABLE_UNICAST_SAME_INTERFACE_FILTERf);
    tbl_data->counter_profile = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, COUNTER_PROFILEf);
    tbl_data->counter_compensation = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, COUNTER_COMPENSATIONf);
    if (SOC_IS_JERICHO(unit)) {
        tbl_data->enable_tm_counter_ptr = soc_mem_field32_get(unit, EGQ_PP_PPCTm, data, ENABLE_TM_COUNTER_PTRf);
    }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_pp_ppct_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_pp_ppct_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_PP_PPCT_TBL_DATA *tbl_data
  )
{
    uint32 res = SOC_SAND_OK;
    uint32 data[ARAD_PP_EGQ_PP_PPCT_TBL_ENTRY_SIZE];

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_PP_PPCT_TBL_SET_UNSAFE);

    ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_PP_PPCT_TBL_ENTRY_SIZE);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, PVLAN_PORT_TYPEf, tbl_data->pvlan_port_type);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, UNKNOWN_BC_DA_ACTION_FILTERf, tbl_data->unknown_bc_da_action_filter);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, UNKNOWN_MC_DA_ACTION_FILTERf, tbl_data->unknown_mc_da_action_filter);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, UNKNOWN_UC_DA_ACTION_FILTERf, tbl_data->unknown_uc_da_action_filter);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ACCEPTABLE_FRAME_TYPE_PROFILEf, tbl_data->acceptable_frame_type_profile);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, EGRESS_VSI_FILTERING_ENABLEf, tbl_data->egress_vsi_filtering_enable);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, DISABLE_FILTERINGf, tbl_data->disable_filtering);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, PORT_IS_PBPf, tbl_data->port_is_pbp);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, PMF_PROFILEf, tbl_data->pmf_profile);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ORIENTATIONf, tbl_data->orientation);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, MTUf, tbl_data->mtu);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, PMF_DATAf, tbl_data->pmf_data);
    /*  soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ENABLE_SAME_INTERFACE_FILTERS_LIFSf, tbl_data->enable_same_interface_filters_lifs); */
    if (soc_mem_field_valid(unit, EGQ_PP_PPCTm, ENABLE_MULTICAST_SAME_INTERFACE_FILTERSf)) {
        soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ENABLE_MULTICAST_SAME_INTERFACE_FILTERSf,
                            tbl_data->enable_same_interface_filters_ports);
    } else {
        soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ENABLE_SAME_INTERFACE_FILTERS_PORTSf,
                            tbl_data->enable_same_interface_filters_ports);
    }
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ENABLE_UNICAST_SAME_INTERFACE_FILTERf, tbl_data->enable_unicast_same_interface_filter);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, COUNTER_PROFILEf, tbl_data->counter_profile);
    soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, COUNTER_COMPENSATIONf, tbl_data->counter_compensation);
    if (SOC_IS_JERICHO(unit)) {
        soc_mem_field32_set(unit, EGQ_PP_PPCTm, data, ENABLE_TM_COUNTER_PTRf, tbl_data->enable_tm_counter_ptr);
    }

    res = soc_mem_write(
              unit,
              EGQ_PP_PPCTm,
              EGQ_BLOCK(unit, core_id),
              entry_offset,
              data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_pp_ppct_tbl_set_unsafe()", entry_offset, 0);
}

uint32
arad_pp_egq_ttl_scope_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   vsi_ndx,
    SOC_SAND_OUT ARAD_PP_EGQ_TTL_SCOPE_TBL_DATA *tbl_data)
{
    uint32 res = SOC_SAND_OK;
    uint32 vsi_offset;
    uint32 vsi_index;
    uint64 data, field_64;
    soc_mem_t mem;
    soc_reg_above_64_val_t reg_above_64;

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_TTL_SCOPE_TBL_GET_UNSAFE);
    tbl_data->ttl_scope_index = 0;

    COMPILER_64_ZERO(field_64);

    if (SOC_IS_JERICHO(unit)) {
        vsi_index = vsi_ndx / 16;
        vsi_offset = vsi_ndx & 0xF;
    } else {
        vsi_index = vsi_ndx / 8;
        vsi_offset = vsi_ndx & 0x7;
    }

    mem = EGQ_TTL_SCOPEm;
    res = soc_mem_read(
                unit,
                mem,
                MEM_BLOCK_ANY,
                vsi_index,
                &data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    soc_mem_field64_get(unit, mem, &data, TTL_SCOPEf, &field_64);

    SOC_REG_ABOVE_64_CLEAR(reg_above_64);
    reg_above_64[0] = COMPILER_64_LO(field_64);
    reg_above_64[1] = COMPILER_64_HI(field_64);
    SHR_BITCOPY_RANGE(&tbl_data->ttl_scope_index, 0, reg_above_64,
                      3 * vsi_offset, 3);

exit:
    SOC_SAND_EXIT_AND_SEND_ERROR(
        "error in arad_pp_egq_ttl_scope_tbl_get_unsafe()", vsi_ndx, 0);
}

uint32
arad_pp_egq_ttl_scope_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   vsi_ndx,
    SOC_SAND_IN  ARAD_PP_EGQ_TTL_SCOPE_TBL_DATA *tbl_data)
{
    uint64 field_64;
    uint32 res = SOC_SAND_OK;
    uint64 data;
    uint32 vsi_offset;
    uint32 vsi_index;
    soc_mem_t mem;
    soc_reg_above_64_val_t reg_above_64;

    SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_TTL_SCOPE_TBL_SET_UNSAFE);

    COMPILER_64_ZERO(field_64);

    if (SOC_IS_JERICHO(unit)) {
        vsi_index = vsi_ndx / 16;
        vsi_offset = vsi_ndx & 0xF;
    } else {
        vsi_index = vsi_ndx / 8;
        vsi_offset = vsi_ndx & 0x7;
    }

    mem = EGQ_TTL_SCOPEm;
    res = soc_mem_read(
                unit,
                mem,
                MEM_BLOCK_ANY,
                vsi_index,
                &data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

    soc_mem_field64_get(unit, mem, &data, TTL_SCOPEf, &field_64);
    SOC_REG_ABOVE_64_CLEAR(reg_above_64);
    reg_above_64[0] = COMPILER_64_LO(field_64);
    reg_above_64[1] = COMPILER_64_HI(field_64);

    SHR_BITCOPY_RANGE(reg_above_64, 3 * vsi_offset,
                      &(tbl_data->ttl_scope_index), 0, 3);
    COMPILER_64_SET(field_64, reg_above_64[1], reg_above_64[0]);
    soc_mem_field64_set(unit, mem, &data, TTL_SCOPEf, field_64);

    res = soc_mem_write(
                unit,
                mem,
                MEM_BLOCK_ANY,
                vsi_index,
                &data);
    SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);


exit:
    SOC_SAND_EXIT_AND_SEND_ERROR(
        "error in arad_pp_egq_ttl_scope_tbl_set_unsafe()", vsi_ndx, 0);
}

#define ARAD_PP_EGQ_AUX_TABLE_TBL_ENTRY_SIZE 2

uint32
  arad_pp_egq_aux_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_AUX_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_AUX_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_AUX_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_AUX_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_AUX_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EGQ_AUX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->aux_table_data = soc_mem_field32_get(unit, EGQ_AUX_TABLEm, data, AUX_TABLE_DATAf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_aux_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_aux_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_AUX_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_AUX_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_AUX_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_AUX_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EGQ_AUX_TABLEm, data, AUX_TABLE_DATAf, tbl_data->aux_table_data);

  res = soc_mem_write(
          unit,
          EGQ_AUX_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_aux_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_ENTRY_SIZE 2

uint32
  arad_pp_egq_action_profile_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EGQ_ACTION_PROFILE_TABLEm,
          EGQ_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->out_tm_port_valid = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, OUT_TM_PORT_VALIDf);
  tbl_data->out_tm_port = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, OUT_TM_PORTf);
  tbl_data->discard = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, DISCARDf);
  tbl_data->cud_valid = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, ORIGINAL_CUD_VALIDf);
  tbl_data->cud = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, ORIGINAL_CUDf);
  tbl_data->dp_valid = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, DP_VALIDf);
  tbl_data->dp = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, DPf);
  tbl_data->tc_valid = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, TC_VALIDf);
  tbl_data->tc = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, TCf);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit))
  {
        tbl_data->pp_dsp_valid = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, PP_DSP_VALIDf);
        tbl_data->pp_dsp = soc_mem_field32_get(unit, EGQ_ACTION_PROFILE_TABLEm, data, PP_DSPf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_action_profile_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_egq_action_profile_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  int  core_id,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EGQ_ACTION_PROFILE_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, OUT_TM_PORT_VALIDf, tbl_data->out_tm_port_valid);

  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, OUT_TM_PORTf, tbl_data->out_tm_port);

  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, DISCARDf, tbl_data->discard);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, ORIGINAL_CUD_VALIDf, tbl_data->cud_valid);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, ORIGINAL_CUDf, tbl_data->cud);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, DP_VALIDf, tbl_data->dp_valid);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, DPf, tbl_data->dp);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, TC_VALIDf, tbl_data->tc_valid);
  soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, TCf, tbl_data->tc);

  if (!SOC_IS_ARADPLUS_AND_BELOW(unit))
  {
        soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, PP_DSP_VALIDf, tbl_data->pp_dsp_valid);
        soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, PP_DSPf,tbl_data->pp_dsp);
        soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, COS_PROFILE_VALIDf, tbl_data->cos_profile_valid);
        soc_mem_field32_set(unit, EGQ_ACTION_PROFILE_TABLEm, data, COS_PROFILEf,tbl_data->cos_profile);
  }

  res = soc_mem_write(
          unit,
          EGQ_ACTION_PROFILE_TABLEm,
          EGQ_BLOCK(unit, core_id),
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_egq_action_profile_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_PP_PCT_TBL_ENTRY_SIZE 4

int
  arad_pp_epni_pp_pct_tbl_get_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     pp_port,
    SOC_SAND_OUT ARAD_PP_EPNI_PP_PCT_TBL_DATA *tbl_data
  )
{
    soc_mem_t mem;
    uint32 data[ARAD_PP_EPNI_PP_PCT_TBL_ENTRY_SIZE];

    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_EPNI_PP_PCT_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_PP_EPNI_PP_PCT_TBL_DATA));

 

    mem = EPNI_PACKETPROCESSING_PORT_CONFIGURATION_TABLEm;

    SOCDNX_IF_ERR_EXIT(soc_mem_read(
            unit,
            mem,
            EPNI_BLOCK(unit, core_id),
            pp_port,
            data
    ));

    tbl_data->acceptable_frame_type_profile = soc_mem_field32_get(unit, mem, data, ACCEPTABLE_FRAME_TYPE_PROFILEf);
    tbl_data->port_is_pbp = soc_mem_field32_get(unit, mem, data, PORT_IS_PBPf);
    tbl_data->egress_stp_filter_enable = soc_mem_field32_get(unit, mem, data, EGRESS_STP_FILTER_ENABLEf);
    tbl_data->egress_vsi_filter_enable = soc_mem_field32_get(unit, mem, data, EGRESS_VSI_FILTER_ENABLEf);
    tbl_data->disable_filter = soc_mem_field32_get(unit, mem, data, DISABLE_FILTERf);
    tbl_data->default_sem_result = soc_mem_field32_get(unit, mem, data, DEFAULT_SEM_RESULTf);
    tbl_data->exp_map_profile = soc_mem_field32_get(unit, mem, data, EXP_MAP_PROFILEf);
    tbl_data->vlan_domain = soc_mem_field32_get(unit, mem, data, VLAN_DOMAINf);
    tbl_data->cep_c_vlan_edit = soc_mem_field32_get(unit, mem, data, CEP_C_VLAN_EDITf);
    tbl_data->llvp_profile = soc_mem_field32_get(unit, mem, data, LLVP_PROFILEf);
    tbl_data->mpls_eth_type_select = soc_mem_field32_get(unit, mem, data, MPLS_ETH_TYPE_SELECTf);
    tbl_data->prge_profile = soc_mem_field32_get(unit, mem, data, PRGE_PROFILEf);
    tbl_data->prge_var = soc_mem_field32_get(unit, mem, data, PRGE_VARf);
    tbl_data->dst_system_port = soc_mem_field32_get(unit, mem, data, DST_SYSTEM_PORTf);
    tbl_data->mtu = soc_mem_field32_get(unit, mem, data, MTUf);
    tbl_data->ieee_1588_mac_enable = soc_mem_field32_get(unit, mem, data, IEEE_1588_MAC_ENABLEf);
    tbl_data->oam_port_profile = soc_mem_field32_get(unit, mem, data, OAM_PORT_PROFILEf);
    if (SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        tbl_data->reserved = soc_mem_field32_get(unit, mem, data, OSTS_ENABLEf);
    } else {
        tbl_data->reserved = soc_mem_field32_get(unit, mem, data, RESERVEDf);
    }

exit:
    SOCDNX_FUNC_RETURN;
}

int
  arad_pp_epni_pp_pct_tbl_set_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     pp_port,
    SOC_SAND_IN  ARAD_PP_EPNI_PP_PCT_TBL_DATA *tbl_data
  )
{
    soc_mem_t mem;
    uint32 data[ARAD_PP_EPNI_PP_PCT_TBL_ENTRY_SIZE];

    SOCDNX_INIT_FUNC_DEFS;

 

    mem = EPNI_PACKETPROCESSING_PORT_CONFIGURATION_TABLEm;

    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_EPNI_PP_PCT_TBL_ENTRY_SIZE);

    soc_mem_field32_set(unit, mem, data, ACCEPTABLE_FRAME_TYPE_PROFILEf, tbl_data->acceptable_frame_type_profile);
    soc_mem_field32_set(unit, mem, data, PORT_IS_PBPf, tbl_data->port_is_pbp);
    soc_mem_field32_set(unit, mem, data, EGRESS_STP_FILTER_ENABLEf, tbl_data->egress_stp_filter_enable);
    soc_mem_field32_set(unit, mem, data, EGRESS_VSI_FILTER_ENABLEf, tbl_data->egress_vsi_filter_enable);
    soc_mem_field32_set(unit, mem, data, DISABLE_FILTERf, tbl_data->disable_filter);
    soc_mem_field32_set(unit, mem, data, DEFAULT_SEM_RESULTf, tbl_data->default_sem_result);
    soc_mem_field32_set(unit, mem, data, EXP_MAP_PROFILEf, tbl_data->exp_map_profile);
    soc_mem_field32_set(unit, mem, data, VLAN_DOMAINf, tbl_data->vlan_domain);
    soc_mem_field32_set(unit, mem, data, CEP_C_VLAN_EDITf, tbl_data->cep_c_vlan_edit);
    soc_mem_field32_set(unit, mem, data, LLVP_PROFILEf, tbl_data->llvp_profile);
    soc_mem_field32_set(unit, mem, data, MPLS_ETH_TYPE_SELECTf, tbl_data->mpls_eth_type_select);
    soc_mem_field32_set(unit, mem, data, PRGE_PROFILEf, tbl_data->prge_profile);
    soc_mem_field32_set(unit, mem, data, PRGE_VARf, tbl_data->prge_var);
    soc_mem_field32_set(unit, mem, data, DST_SYSTEM_PORTf, tbl_data->dst_system_port);
    soc_mem_field32_set(unit, mem, data, MTUf, tbl_data->mtu);
    soc_mem_field32_set(unit, mem, data, IEEE_1588_MAC_ENABLEf, tbl_data->ieee_1588_mac_enable);
    soc_mem_field32_set(unit, mem, data, OAM_PORT_PROFILEf, tbl_data->oam_port_profile);
    if (SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        soc_mem_field32_set(unit, mem, data, OSTS_ENABLEf, tbl_data->reserved);
    } else {
        soc_mem_field32_set(unit, mem, data, RESERVEDf, tbl_data->reserved);
    }

    SOCDNX_IF_ERR_EXIT(soc_mem_write(
            unit,
            mem,
            EPNI_BLOCK(unit, core_id),
            pp_port,
            data
    ));
exit:
    SOCDNX_FUNC_RETURN;
}

#define ARAD_PP_EPNI_LLVP_TABLE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_epni_llvp_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_LLVP_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_LLVP_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_LLVP_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_LLVP_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_LLVP_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->c_tag_offset = soc_mem_field32_get(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, C_TAG_OFFSETf);
  tbl_data->packet_has_c_tag = soc_mem_field32_get(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_C_TAGf);
  tbl_data->packet_has_up = soc_mem_field32_get(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_UPf);
  tbl_data->packet_has_pcp_dei = soc_mem_field32_get(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_PCP_DEIf);
  tbl_data->incoming_tag_format = soc_mem_field32_get(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, INCOMING_TAG_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_llvp_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_llvp_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_LLVP_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_LLVP_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_LLVP_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_LLVP_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, C_TAG_OFFSETf, tbl_data->c_tag_offset);
  soc_mem_field32_set(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_C_TAGf, tbl_data->packet_has_c_tag);
  soc_mem_field32_set(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_UPf, tbl_data->packet_has_up);
  soc_mem_field32_set(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, PACKET_HAS_PCP_DEIf, tbl_data->packet_has_pcp_dei);
  soc_mem_field32_set(unit, EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm, data, INCOMING_TAG_FORMATf, tbl_data->incoming_tag_format);

  res = soc_mem_write(
          unit,
          EPNI_LINK_LAYER_VLAN_PROCESSING_LLVPm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_llvp_table_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vsi_low_cfg_1_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VSI_LOW_CFG_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->topology_id = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_1m, data, TOPOLOGY_IDf);
  tbl_data->my_mac = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_1m, data, MY_MACf);
  if (!SOC_IS_QAX(unit) || SOC_IS_QUX(unit)) {
      /*in QAX this field is configured in another memory */
      tbl_data->my_mac_valid = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_1m, data, MY_MAC_VALIDf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_low_cfg_1_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_low_cfg_1_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_LOW_CFG_1_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_1m, data, TOPOLOGY_IDf, tbl_data->topology_id);
  soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_1m, data, MY_MACf, tbl_data->my_mac);
  if (soc_mem_field_valid(unit, IHP_VSI_LOW_CFG_1m, MY_MAC_VALIDf)) { 
    /*in QAX this field is configured in another memory */
    soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_1m, data, MY_MAC_VALIDf, tbl_data->my_mac_valid);
  }

  res = soc_mem_write(
          unit,
          IHP_VSI_LOW_CFG_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_low_cfg_1_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vsi_low_cfg_2_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VSI_LOW_CFG_2m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->profile = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_2m, data, PROFILEf);
  tbl_data->fid_class = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_2m, data, FID_CLASSf);
  tbl_data->da_not_found_destination = soc_mem_field32_get(unit, IHP_VSI_LOW_CFG_2m, data, DA_NOT_FOUND_DESTINATIONf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_low_cfg_2_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_low_cfg_2_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_LOW_CFG_2_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_2m, data, PROFILEf, tbl_data->profile);
  soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_2m, data, FID_CLASSf, tbl_data->fid_class);
  soc_mem_field32_set(unit, IHP_VSI_LOW_CFG_2m, data, DA_NOT_FOUND_DESTINATIONf, tbl_data->da_not_found_destination);

  res = soc_mem_write(
          unit,
          IHP_VSI_LOW_CFG_2m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_low_cfg_2_tbl_set_unsafe()", entry_offset, 0);
}


#define ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vsi_my_mac_tbl_get_unsafe(int unit, uint32 entry_offset, uint8* enable_my_mac)
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE];
  uint32 bitmap_pos, bit_pos, valid, bitmap[1];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  if (SOC_IS_QUX(unit)) {
      SOC_EXIT;
  }

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE);  
  
  bitmap_pos = (entry_offset / 8);
  bit_pos = (entry_offset % 8);
  res = soc_mem_read(
          unit,
          IHP_VSI_MY_MAC_VALIDm,
          MEM_BLOCK_ANY,
          bitmap_pos,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  bitmap[0] = soc_mem_field32_get(unit, IHP_VSI_MY_MAC_VALIDm, data, MY_MAC_VALID_BIT_MAPf);

  soc_sand_bitstream_get_any_field(bitmap, bit_pos, 1, &valid);
  (*enable_my_mac) = valid;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_my_mac_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_vsi_my_mac_tbl_set_unsafe(int unit, uint32 entry_offset, uint8 enable_my_mac)
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE];
  uint32 bitmap_pos, bit_pos, bitmap[1], tmp_enable_my_mac;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  if (SOC_IS_QUX(unit)) {
      SOC_EXIT;
  }
  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE);  
  
  bitmap_pos = (entry_offset / 8);
  bit_pos = (entry_offset % 8);

  res = soc_mem_read(
          unit,
          IHP_VSI_MY_MAC_VALIDm,
          MEM_BLOCK_ANY,
          bitmap_pos,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  bitmap[0] = soc_mem_field32_get(unit, IHP_VSI_MY_MAC_VALIDm, data, MY_MAC_VALID_BIT_MAPf);  

  

  /*set the bit */
  tmp_enable_my_mac = (uint32)enable_my_mac;
  soc_sand_bitstream_set_any_field(&tmp_enable_my_mac, bit_pos, 1, bitmap);

  soc_mem_field32_set(unit, IHP_VSI_MY_MAC_VALIDm, data, MY_MAC_VALID_BIT_MAPf, bitmap[0]);
  
  res = soc_mem_write(
          unit,
          IHP_VSI_MY_MAC_VALIDm,
          MEM_BLOCK_ANY,
          bitmap_pos,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_my_mac_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_vsi_high_my_mac_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VSI_HIGH_MY_MACm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->valid[0] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALIDf);
  tbl_data->valid[1] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_1f);
  tbl_data->valid[2] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_2f);
  tbl_data->valid[3] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_3f);
  tbl_data->valid[4] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_4f);
  tbl_data->valid[5] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_5f);
  tbl_data->valid[6] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_6f);
  tbl_data->valid[7] = soc_mem_field32_get(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_7f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_my_mac_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_high_my_mac_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_MY_MAC_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALIDf, tbl_data->valid[0]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_1f, tbl_data->valid[1]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_2f, tbl_data->valid[2]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_3f, tbl_data->valid[3]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_4f, tbl_data->valid[4]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_5f, tbl_data->valid[5]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_6f, tbl_data->valid[6]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_MY_MACm, data, VALID_7f, tbl_data->valid[7]);

  res = soc_mem_write(
          unit,
          IHP_VSI_HIGH_MY_MACm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_my_mac_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vsi_high_info_tbl_set_unsafe(int unit, uint32 entry_offset, uint32 frwrd_dest, uint32 profile_ingress)
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_HIGH_CFGm, data, PROFILE_INDEXf, profile_ingress);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_CFGm, data, DA_NOT_FOUND_DESTINATIONf, frwrd_dest);
      
  res = soc_mem_write(
          unit,
          IHP_VSI_HIGH_CFGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_info_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_high_info_tbl_get_unsafe(int unit, uint32 entry_offset, uint32* frwrd_dest, uint32* profile_ingress)
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE);  

  res = soc_mem_read(
          unit,
          IHP_VSI_HIGH_CFGm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  (*profile_ingress) = soc_mem_field32_get(unit, IHP_VSI_HIGH_CFGm, data, PROFILE_INDEXf);  
  (*frwrd_dest) = soc_mem_field32_get(unit, IHP_VSI_HIGH_CFGm, data, DA_NOT_FOUND_DESTINATIONf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_info_tbl_get_unsafe()", entry_offset, 0);
}


uint32
  arad_pp_ihp_vsi_high_profile_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VSI_HIGH_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->index[0] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEXf);
  tbl_data->index[1] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_1f);
  tbl_data->index[2] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_2f);
  tbl_data->index[3] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_3f);
  tbl_data->index[4] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_4f);
  tbl_data->index[5] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_5f);
  tbl_data->index[6] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_6f);
  tbl_data->index[7] = soc_mem_field32_get(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_7f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_profile_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_high_profile_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_PROFILE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEXf, tbl_data->index[0]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_1f, tbl_data->index[1]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_2f, tbl_data->index[2]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_3f, tbl_data->index[3]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_4f, tbl_data->index[4]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_5f, tbl_data->index[5]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_6f, tbl_data->index[6]);
  soc_mem_field32_set(unit, IHP_VSI_HIGH_PROFILEm, data, INDEX_7f, tbl_data->index[7]);

  res = soc_mem_write(
          unit,
          IHP_VSI_HIGH_PROFILEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_profile_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_vsi_high_da_not_found_destination_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATIONm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->da_not_found_destination = soc_mem_field32_get(unit, IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATIONm, data, DA_NOT_FOUND_DESTINATIONf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_da_not_found_destination_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vsi_high_da_not_found_destination_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATION_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATIONm, data, DA_NOT_FOUND_DESTINATIONf, tbl_data->da_not_found_destination);

  res = soc_mem_write(
          unit,
          IHP_VSI_HIGH_DA_NOT_FOUND_DESTINATIONm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vsi_high_da_not_found_destination_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_mact_fid_counter_db_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_DATA *tbl_data
  )
{
  int rv = SOC_E_NONE;
  uint32
    data[ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE];

  SOCDNX_INIT_FUNC_DEFS;

  SOCDNX_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE);
  SOCDNX_CLEAR(tbl_data, ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_DATA, 1);

  rv = soc_mem_read(
          unit,
          PPDB_B_LARGE_EM_FID_COUNTER_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOCDNX_IF_ERR_EXIT(rv);

  tbl_data->entry_count = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_DBm, data, ENTRY_COUNTf);
exit:
  SOCDNX_FUNC_RETURN;
}


uint32
  arad_pp_ihp_mact_entry_count_db_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_DATA *tbl_data
  )
{
  int rv = SOC_E_NONE;
  uint32
    data[ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE];

  SOCDNX_INIT_FUNC_DEFS;

  SOCDNX_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE);
  SOCDNX_CLEAR(tbl_data, ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_DATA, 1);


  rv = READ_PPDB_B_LARGE_EM_COUNTER_LIMIT_LARGE_EM_DB_ENTRIES_COUNTr(unit, &tbl_data->entry_count);
  SOCDNX_SAND_IF_ERR_EXIT(rv);

exit:
  SOCDNX_FUNC_RETURN;
}


uint32
  arad_pp_ihp_mact_fid_counter_db_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_COUNTER_DB_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_DBm, data, ENTRY_COUNTf, tbl_data->entry_count);

  res = soc_mem_write(
          unit,
          PPDB_B_LARGE_EM_FID_COUNTER_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_fid_counter_db_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_mact_fid_profile_db_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          PPDB_B_LARGE_EM_FID_PROFILE_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->profile_pointer[0] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_0f);
  tbl_data->profile_pointer[1] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_1f);
  tbl_data->profile_pointer[2] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_2f);
  tbl_data->profile_pointer[3] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_3f);
  tbl_data->profile_pointer[4] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_4f);
  tbl_data->profile_pointer[5] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_5f);
  tbl_data->profile_pointer[6] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_6f);
  tbl_data->profile_pointer[7] = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_7f);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_fid_profile_db_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_mact_fid_profile_db_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_PROFILE_DB_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_0f, tbl_data->profile_pointer[0]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_1f, tbl_data->profile_pointer[1]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_2f, tbl_data->profile_pointer[2]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_3f, tbl_data->profile_pointer[3]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_4f, tbl_data->profile_pointer[4]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_5f, tbl_data->profile_pointer[5]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_6f, tbl_data->profile_pointer[6]);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_PROFILE_DBm, data, PROFILE_POINTER_7f, tbl_data->profile_pointer[7]);

  res = soc_mem_write(
          unit,
          PPDB_B_LARGE_EM_FID_PROFILE_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_fid_profile_db_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_ENTRY_SIZE 1

uint32
  arad_pp_ihp_mact_fid_counter_profile_db_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->limit = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, LIMITf);
  tbl_data->interrupt_en = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, INTERRUPT_ENf);
  tbl_data->message_en = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, MESSAGE_ENf);
  tbl_data->event_forwarding_profile = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, EVENT_FORWARDING_PROFILEf);
  tbl_data->fid_aging_profile = soc_mem_field32_get(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, FID_AGING_PROFILEf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_fid_counter_profile_db_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_mact_fid_counter_profile_db_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_MACT_FID_COUNTER_PROFILE_DB_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, LIMITf, tbl_data->limit);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, INTERRUPT_ENf, tbl_data->interrupt_en);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, MESSAGE_ENf, tbl_data->message_en);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, EVENT_FORWARDING_PROFILEf, tbl_data->event_forwarding_profile);
  soc_mem_field32_set(unit, PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm, data, FID_AGING_PROFILEf, tbl_data->fid_aging_profile);

  res = soc_mem_write(
          unit,
          PPDB_B_LARGE_EM_FID_COUNTER_PROFILE_DBm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_mact_fid_counter_profile_db_tbl_set_unsafe()", entry_offset, 0);
}



uint32
  arad_pp_ihp_vlan_port_membership_tbl_get_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
      data_0[ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE],
      data_1[ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data_0, uint32, ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(data_1, uint32, ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE);

  res = soc_mem_array_read(
          unit,
          IHP_VSI_PORT_MEMBERSHIPm,
          0, 
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data_0
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  res = soc_mem_array_read(
          unit,
          IHP_VSI_PORT_MEMBERSHIPm,
          1, 
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data_1
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  soc_mem_field_get(
      unit, 
      IHP_VSI_PORT_MEMBERSHIPm, 
      data_0, 
      VLAN_PORT_MEMBER_LINEf, 
      (uint32*) &(tbl_data->vlan_port_member_line[0])
      );
  soc_mem_field_get(
      unit, 
      IHP_VSI_PORT_MEMBERSHIPm, 
      data_1, 
      VLAN_PORT_MEMBER_LINEf, 
      (uint32*) &(tbl_data->vlan_port_member_line[4])
      );

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_vlan_port_membership_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_vlan_port_membership_tbl_set_unsafe(
    SOC_SAND_IN  int             unit,
    SOC_SAND_IN  int             core_id,
    SOC_SAND_IN  uint32              entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_DATA  *tbl_data
  )
{
  uint32
      res = SOC_SAND_OK;
  uint32
      data_0[ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE],
      data_1[ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data_0, uint32, ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(data_1, uint32, ARAD_PP_IHP_VLAN_PORT_MEMBERSHIP_TBL_ENTRY_SIZE);

  soc_mem_field_set(
      unit, 
      IHP_VSI_PORT_MEMBERSHIPm, 
      data_0, 
      VLAN_PORT_MEMBER_LINEf, 
      (uint32*) &(tbl_data->vlan_port_member_line[0])
      );

  soc_mem_field_set(
      unit, 
      IHP_VSI_PORT_MEMBERSHIPm, 
      data_1, 
      VLAN_PORT_MEMBER_LINEf, 
      (uint32*) &(tbl_data->vlan_port_member_line[4])
      );

  res = soc_mem_array_write(
          unit,
          IHP_VSI_PORT_MEMBERSHIPm,
          0, 
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data_0
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

  res = soc_mem_array_write(
          unit,
          IHP_VSI_PORT_MEMBERSHIPm,
          1, 
          IHP_BLOCK(unit, core_id),
          entry_offset,
          data_1
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in soc_pb_pp_ihp_vlan_port_membership_tbl_set_unsafe()", entry_offset, 0);
}


#define ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

/* In Jericho, the out_lif field is split into LSBs and MSBs. These macros are here so the out_lif can be split in the
   set function and merged in the get function. */

#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_MASK    1
#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_SHIFT   17

#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_MASK    0x1ffff
#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_SHIFT   0

#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_GET(_out_lif)  \
    ((_out_lif >> ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_SHIFT) & ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_MASK)

#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_GET(_out_lif)  \
    ((_out_lif >> ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_SHIFT) & ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_MASK)

#define ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_SET(_out_lif, _out_lif_msb, _out_lif_lsb)  \
    (_out_lif) = (((_out_lif_msb & ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_MASK) << ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_SHIFT) \
                | ((out_lif_lsb & ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_MASK) << ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_SHIFT))

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_ac_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_ENTRY_SIZE];
  uint32 out_lif_lsb = 0, out_lif_msb = 0;
  soc_mem_t lif_mem_id = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_2_OUT_LIFm : IHP_LIF_TABLE_AC_2_OUT_LIFm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);
  
  res = soc_mem_array_read(unit, lif_mem_id, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->destination = soc_mem_field32_get(unit, lif_mem_id, data, DESTINATIONf);
  tbl_data->vlan_edit_vid_2 = soc_mem_field32_get(unit, lif_mem_id, data, VLAN_EDIT_VID_2f);
  tbl_data->vlan_edit_vid_1 = soc_mem_field32_get(unit, lif_mem_id, data, VLAN_EDIT_VID_1f);
  tbl_data->vlan_edit_pcp_dei_profile = soc_mem_field32_get(unit, lif_mem_id, data, VLAN_EDIT_PCP_DEI_PROFILEf);
  tbl_data->vlan_edit_profile = soc_mem_field32_get(unit, lif_mem_id, data, VLAN_EDIT_PROFILEf);
  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, lif_mem_id, data, ORIENTATION_IS_HUBf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, lif_mem_id, data, COS_PROFILEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, lif_mem_id, data, IN_LIF_PROFILEf);
  tbl_data->out_lif_valid = soc_mem_field32_get(unit, lif_mem_id, data, OUT_LIF_VALIDf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, lif_mem_id, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, lif_mem_id, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, lif_mem_id, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, lif_mem_id, data, TYPEf);

  /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif  = soc_mem_field32_get(unit, lif_mem_id, data, SYS_IN_LIFf);
      out_lif_lsb           = soc_mem_field32_get(unit, lif_mem_id, data, OUT_LIF_LSBf);
      out_lif_msb           = soc_mem_field32_get(unit, lif_mem_id, data, OUT_LIF_MSBf);
      ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_SET(tbl_data->out_lif, out_lif_msb, out_lif_lsb);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, USE_IN_LIFf);
      tbl_data->out_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, OUT_LIFf);
      tbl_data->destination_valid = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, DESTINATION_VALIDf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_ac_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_ac_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_ENTRY_SIZE];
  soc_mem_t lif_table_ac_2_out_lif_mem = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_2_OUT_LIFm : IHP_LIF_TABLE_AC_2_OUT_LIFm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_AC_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, OUT_LIF_LSBf, ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_LSB_GET(tbl_data->out_lif));
      soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, OUT_LIF_MSBf, ARAD_PP_PPDB_B_LIF_TABLE_AC_2_OUT_LIF_OUT_LIF_MSB_GET(tbl_data->out_lif));
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, USE_IN_LIFf, tbl_data->use_in_lif);
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, DESTINATION_VALIDf, tbl_data->destination_valid);
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_ACm, data, OUT_LIFf, tbl_data->out_lif);
  } 

  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, VLAN_EDIT_VID_2f, tbl_data->vlan_edit_vid_2);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, VLAN_EDIT_VID_1f, tbl_data->vlan_edit_vid_1);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, VLAN_EDIT_PCP_DEI_PROFILEf, tbl_data->vlan_edit_pcp_dei_profile);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, VLAN_EDIT_PROFILEf, tbl_data->vlan_edit_profile);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, OUT_LIF_VALIDf, tbl_data->out_lif_valid);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, lif_table_ac_2_out_lif_mem, data, TYPEf, tbl_data->type);


  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, lif_table_ac_2_out_lif_mem, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_ac_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_pwe_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_ENTRY_SIZE],
    bank_id,
    entry_offset_in_bank;
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_2_EEIm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);


  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);
  
  tbl_data->destination = soc_mem_field32_get(unit, mem_var, data, DESTINATIONf);
  tbl_data->destination_valid = soc_mem_field32_get(unit, mem_var, data, DESTINATION_VALIDf);
  tbl_data->eei_or_out_lif = soc_mem_field32_get(unit, mem_var, data, OUT_LIF_OR_LABELf);
  tbl_data->eei_or_out_lif_identifier = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf);
  tbl_data->vlan_edit_vid_1 = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_VID_1f);
  tbl_data->vlan_edit_pcp_dei_profile = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_PCP_DEI_PROFILEf);
  tbl_data->vlan_edit_profile = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_PROFILEf);
  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);

    /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_PWEm, data, USE_IN_LIFf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_pwe_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_pwe_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_2_EEIm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PWE_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_PWEm, data, USE_IN_LIFf, tbl_data->use_in_lif);
  } 


  soc_mem_field32_set(unit, mem_var, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALIDf, tbl_data->destination_valid);
  soc_mem_field32_set(unit, mem_var, data, OUT_LIF_OR_LABELf, tbl_data->eei_or_out_lif);
  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf, tbl_data->eei_or_out_lif_identifier);
  soc_mem_field32_set(unit, mem_var, data, VLAN_EDIT_VID_1f, tbl_data->vlan_edit_vid_1);
  soc_mem_field32_set(unit, mem_var, data, VLAN_EDIT_PCP_DEI_PROFILEf, tbl_data->vlan_edit_pcp_dei_profile);
  soc_mem_field32_set(unit, mem_var, data, VLAN_EDIT_PROFILEf, tbl_data->vlan_edit_profile);
  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_pwe_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_pbb_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_ENTRY_SIZE];
  soc_mem_t lif_mem = (SOC_IS_JERICHO(unit)) ? IHP_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_P2P_TO_PBBm;
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_2_EEIm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, lif_mem, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->destination = soc_mem_field32_get(unit, lif_mem, data, DESTINATIONf);
  tbl_data->destination_valid = soc_mem_field32_get(unit, lif_mem, data, DESTINATION_VALIDf);
  tbl_data->vlan_edit_vid_1 = soc_mem_field32_get(unit, lif_mem, data, VLAN_EDIT_VID_1f);
  tbl_data->vlan_edit_pcp_dei_profile = soc_mem_field32_get(unit, lif_mem, data, VLAN_EDIT_PCP_DEI_PROFILEf);
  tbl_data->vlan_edit_profile = soc_mem_field32_get(unit, lif_mem, data, VLAN_EDIT_PROFILEf);
  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, lif_mem, data, ORIENTATION_IS_HUBf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, lif_mem, data, COS_PROFILEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, lif_mem, data, IN_LIF_PROFILEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, lif_mem, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, lif_mem, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, lif_mem, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, lif_mem, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, lif_mem, data, TYPEf);

  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
      tbl_data->eei =                   soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIFf);
      tbl_data->eei_or_out_lif_type = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_PBBm, data, USE_IN_LIFf);
      tbl_data->eei = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_P2P_TO_PBBm, data, EEIf);
  }
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_pbb_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_ac_p2p_to_pbb_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_ENTRY_SIZE];
  soc_mem_t lif_mem = (SOC_IS_JERICHO_PLUS_A0(unit)) ? PPDB_B_LIF_TABLE_AC_2_EEIm : ((SOC_IS_JERICHO(unit)) ? IHP_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_P2P_TO_PBBm);

  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)? PPDB_B_LIF_TABLE_AC_2_EEIm : IHP_LIF_TABLE_AC_2_EEIm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_P2P_TO_PBB_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf, tbl_data->eei_or_out_lif_type);
      soc_mem_field32_set(unit, mem_var, data, OUT_LIF_OR_LABELf, tbl_data->eei);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_PBBm, data, USE_IN_LIFf, tbl_data->use_in_lif);
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_P2P_TO_PBBm, data, EEIf, tbl_data->eei);
  } 
  
  soc_mem_field32_set(unit, lif_mem, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, lif_mem, data, DESTINATION_VALIDf, tbl_data->destination_valid);
  soc_mem_field32_set(unit, lif_mem, data, VLAN_EDIT_VID_1f, tbl_data->vlan_edit_vid_1);
  soc_mem_field32_set(unit, lif_mem, data, VLAN_EDIT_PCP_DEI_PROFILEf, tbl_data->vlan_edit_pcp_dei_profile);
  soc_mem_field32_set(unit, lif_mem, data, VLAN_EDIT_PROFILEf, tbl_data->vlan_edit_profile);
  soc_mem_field32_set(unit, lif_mem, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, lif_mem, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, lif_mem, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, lif_mem, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, lif_mem, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, lif_mem, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, lif_mem, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, lif_mem, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_p2p_to_pbb_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_ac_mp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    bank_id,
    entry_offset_in_bank;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)?PPDB_B_LIF_TABLE_AC_MPm:IHP_LIF_TABLE_AC_MPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data));

  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  tbl_data->learn_info = soc_mem_field32_get(unit, mem_var, data, LEARN_INFOf);
  tbl_data->tt_learn_enable = soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->da_not_found_profile = soc_mem_field32_get(unit, mem_var, data, DA_NOT_FOUND_PROFILEf);
  tbl_data->vlan_edit_vid_2 = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_VID_2f);
  tbl_data->vlan_edit_vid_1 = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_VID_1f);
  tbl_data->vlan_edit_pcp_dei_profile = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_PCP_DEI_PROFILEf);
  tbl_data->vlan_edit_profile = soc_mem_field32_get(unit, mem_var, data, VLAN_EDIT_PROFILEf);
  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);


  /* Some fields have different names in Jericho, or don't exist in Jericho/Jericho Plus, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_AC_MPm, data, USE_IN_LIFf);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_mp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_ac_mp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_ENTRY_SIZE];
  soc_mem_t lif_table_ac_mp_mem = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_AC_MPm : IHP_LIF_TABLE_AC_MPm;
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_AC_MP_TBL_ENTRY_SIZE);

    /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_AC_MPm, data, USE_IN_LIFf, tbl_data->use_in_lif);
  } 


  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VSIf, tbl_data->vsi);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, LEARN_INFOf, tbl_data->learn_info);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, DA_NOT_FOUND_PROFILEf, tbl_data->da_not_found_profile);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VLAN_EDIT_VID_2f, tbl_data->vlan_edit_vid_2);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VLAN_EDIT_VID_1f, tbl_data->vlan_edit_vid_1);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VLAN_EDIT_PCP_DEI_PROFILEf, tbl_data->vlan_edit_pcp_dei_profile);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VLAN_EDIT_PROFILEf, tbl_data->vlan_edit_profile);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, lif_table_ac_mp_mem, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, lif_table_ac_mp_mem, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ac_mp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_isid_p2p_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)?PPDB_B_LIF_TABLE_ISID_P2Pm:IHP_LIF_TABLE_ISID_P2Pm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->eei_or_out_lif_lsb = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_LSBf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  tbl_data->destination = soc_mem_field32_get(unit, mem_var, data, DESTINATIONf);
  tbl_data->destination_valid = soc_mem_field32_get(unit, mem_var, data, DESTINATION_VALIDf);
  tbl_data->eei_or_out_lif_type = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);
  tbl_data->eei_or_out_lif = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_MSBf);

  /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
      tbl_data->in_lif_profile =        soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->service_type_lsb = soc_mem_field32_get(unit, IHP_LIF_TABLE_ISID_P2Pm, data, SERVICE_TYPE_LSBf);
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_ISID_P2Pm, data, USE_IN_LIFf);
  }


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_isid_p2p_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_isid_p2p_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_ISID_P2Pm : IHP_LIF_TABLE_ISID_P2Pm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_ISID_P2P_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_ISID_P2Pm, data, USE_IN_LIFf, tbl_data->use_in_lif);
      soc_mem_field32_set(unit, IHP_LIF_TABLE_ISID_P2Pm, data, SERVICE_TYPE_LSBf, tbl_data->service_type_lsb);
  }

  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_MSBf, tbl_data->eei_or_out_lif);
  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_LSBf, tbl_data->eei_or_out_lif_lsb);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
  soc_mem_field32_set(unit, mem_var, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALIDf, tbl_data->destination_valid);
  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf, tbl_data->eei_or_out_lif_type);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_isid_p2p_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_isid_mp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_ISID_MPm : IHP_LIF_TABLE_ISID_MPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  tbl_data->da_not_found_profile = soc_mem_field32_get(unit, mem_var, data, DA_NOT_FOUND_PROFILEf);
  tbl_data->destination = soc_mem_field32_get(unit, mem_var, data, DESTINATIONf);
  tbl_data->destination_valid = soc_mem_field32_get(unit, mem_var, data, DESTINATION_VALIDf);
  tbl_data->tt_learn_enable = soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);

  /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
      tbl_data->in_lif_profile =        soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_ISID_MPm, data, USE_IN_LIFf);
      tbl_data->service_type_lsb = soc_mem_field32_get(unit, IHP_LIF_TABLE_ISID_MPm, data, SERVICE_TYPE_LSBf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_isid_mp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_isid_mp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_ISID_MPm : IHP_LIF_TABLE_ISID_MPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_ISID_MP_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, IHP_LIF_TABLE_ISID_MPm, data, USE_IN_LIFf, tbl_data->use_in_lif);
      soc_mem_field32_set(unit, IHP_LIF_TABLE_ISID_MPm, data, SERVICE_TYPE_LSBf, tbl_data->service_type_lsb);
  } 

  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
  soc_mem_field32_set(unit, mem_var, data, DA_NOT_FOUND_PROFILEf, tbl_data->da_not_found_profile);
  soc_mem_field32_set(unit, mem_var, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALIDf, tbl_data->destination_valid);
  soc_mem_field32_set(unit, mem_var, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_isid_mp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_trill_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_TRILLm : IHP_LIF_TABLE_TRILLm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  /* Until arad+: learn info is fec only. */
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      uint32 learn_info = soc_mem_field32_get(unit, mem_var, data, LEARN_INFOf);
      COMPILER_64_SET(tbl_data->learn_info, 0,learn_info); 
  } 
  /* for jericho: learn info is fec + eei */
  else {
      soc_mem_field64_get(unit, mem_var, data, LEARN_DATAf, &tbl_data->learn_info);
  }
  tbl_data->service_type = soc_mem_field32_get(unit, mem_var, data, SERVICE_TYPEf);
  tbl_data->tt_learn_enable = soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);

  if (SOC_IS_JERICHO(unit)) {
      tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
      tbl_data->orientation_is_hub_valid = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUB_VALIDf);
      tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
      tbl_data->in_lif_profile_valid = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILE_VALIDf);
      tbl_data->sys_in_lif = soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_trill_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_trill_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_TRILLm : IHP_LIF_TABLE_TRILLm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_TRILL_TBL_ENTRY_SIZE);


    /* The name of the table is different and some fields exist only on Jericho. Set the right table id and handle the fields. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
      soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUB_VALIDf, tbl_data->orientation_is_hub_valid);
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILE_VALIDf, tbl_data->in_lif_profile_valid);
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0);
  } 

  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
  /* Until arad+: learn info is fec only. */
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      uint32 learn_info = COMPILER_64_LO(tbl_data->learn_info); 
      soc_mem_field32_set(unit, mem_var, data, LEARN_INFOf, learn_info);
  } 
  /* for jericho: learn info is fec + eei */
  else if (SOC_IS_JERICHO(unit)) {
      /* learn info in Jericho supports only forwarding payload format in arad mode \
         Until the code is ready to got the learn info in the right format, don't save learn info */
      soc_mem_field64_set(unit, mem_var, data, LEARN_DATAf, tbl_data->learn_info);
  }
  soc_mem_field32_set(unit, mem_var, data, SERVICE_TYPEf, tbl_data->service_type);
  soc_mem_field32_set(unit, mem_var, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_trill_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_ip_tt_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_IP_TTm : IHP_LIF_TABLE_IP_TTm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->model_is_pipe = soc_mem_field32_get(unit, mem_var, data, MODEL_IS_PIPEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->da_not_found_profile = soc_mem_field32_get(unit, mem_var, data, DA_NOT_FOUND_PROFILEf);
  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  tbl_data->in_rif = soc_mem_field32_get(unit, mem_var, data, IN_RIFf);
  tbl_data->in_rif_valid = soc_mem_field32_get(unit, mem_var, data, IN_RIF_VALIDf);
  tbl_data->learn_info = soc_mem_field32_get(unit, mem_var, data, LEARN_INFOf);
  tbl_data->service_type = soc_mem_field32_get(unit, mem_var, data, SERVICE_TYPEf);
  tbl_data->tt_learn_enable = soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      if (SOC_IS_ARADPLUS_AND_BELOW(unit)) { /* Soc is not Jericho and above */
          tbl_data->use_in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_IP_TTm, data, USE_IN_LIFf);  
      }
      tbl_data->skip_ethernet = soc_mem_field32_get(unit, mem_var, data, SKIP_ETHERNETf);
  }
 
#endif /* BCM_88660_A0 */

  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =               soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
      tbl_data->orientation_is_hub_valid = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUB_VALIDf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ip_tt_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_ip_tt_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_IP_TTm : IHP_LIF_TABLE_IP_TTm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_IP_TT_TBL_ENTRY_SIZE);

    /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUB_VALIDf, tbl_data->orientation_is_hub_valid);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      if (SOC_IS_ARADPLUS(unit)) {
          soc_mem_field32_set(unit, IHP_LIF_TABLE_IP_TTm, data, USE_IN_LIFf, tbl_data->use_in_lif);
      }
  } 

  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, MODEL_IS_PIPEf, tbl_data->model_is_pipe);
  soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, DA_NOT_FOUND_PROFILEf, tbl_data->da_not_found_profile);
  soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
  soc_mem_field32_set(unit, mem_var, data, IN_RIFf, tbl_data->in_rif);
  soc_mem_field32_set(unit, mem_var, data, IN_RIF_VALIDf, tbl_data->in_rif_valid);
  soc_mem_field32_set(unit, mem_var, data, LEARN_INFOf, tbl_data->learn_info);
  soc_mem_field32_set(unit, mem_var, data, SERVICE_TYPEf, tbl_data->service_type);
  soc_mem_field32_set(unit, mem_var, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    /* skip ethernet for roo */
    soc_mem_field32_set(unit, mem_var, data, SKIP_ETHERNETf, tbl_data->skip_ethernet);
  }
#endif /* BCM_88660_A0 */
  

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_ip_tt_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_label_pwe_p2p_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    bank_id,
    entry_offset_in_bank;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_LABEL_PWE_P2Pm : IHP_LIF_TABLE_LABEL_PWE_P2Pm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->action_profile_index = soc_mem_field32_get(unit, mem_var, data, ACTION_PROFILE_INDEXf);
  tbl_data->model_is_pipe = soc_mem_field32_get(unit, mem_var, data, MODEL_IS_PIPEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->eei_or_out_lif = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIFf);
  tbl_data->destination = soc_mem_field32_get(unit, mem_var, data, DESTINATIONf);
  tbl_data->eei_or_out_lif_type = soc_mem_field32_get(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);
  tbl_data->termination_profile_msb = soc_mem_field32_get(unit, mem_var, data, TERMINATION_TYPE_MSBf);
  tbl_data->termination_profile = soc_mem_field32_get(unit, mem_var, data, TERMINATION_TYPE_LSBf);

  /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
        tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        tbl_data->destination_valid = soc_mem_field32_get(unit, IHP_LIF_TABLE_LABEL_PWE_P2Pm, data, DESTINATION_VALIDf);
        tbl_data->in_lif = soc_mem_field32_get(unit, IHP_LIF_TABLE_LABEL_PWE_P2Pm, data, IN_LIFf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_pwe_p2p_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_label_pwe_p2p_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_LABEL_PWE_P2Pm : IHP_LIF_TABLE_LABEL_PWE_P2Pm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_P2P_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, mem_var, data, IN_LIFf, tbl_data->in_lif);
      soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALIDf, tbl_data->destination_valid);
  } 

  soc_mem_field32_set(unit, mem_var, data, TERMINATION_TYPE_LSBf, tbl_data->termination_profile);
  soc_mem_field32_set(unit, mem_var, data, TERMINATION_TYPE_MSBf, tbl_data->termination_profile_msb);
  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, ACTION_PROFILE_INDEXf, tbl_data->action_profile_index);
  soc_mem_field32_set(unit, mem_var, data, MODEL_IS_PIPEf, tbl_data->model_is_pipe);
  soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIFf, tbl_data->eei_or_out_lif);
  soc_mem_field32_set(unit, mem_var, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, mem_var, data, EEI_OR_OUT_LIF_TYPEf, tbl_data->eei_or_out_lif_type);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_pwe_p2p_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

uint32
  arad_pp_ihp_lif_table_label_pwe_mp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_LABEL_PWE_MPm : IHP_LIF_TABLE_LABEL_PWE_MPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub = soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->action_profile_index = soc_mem_field32_get(unit, mem_var, data, ACTION_PROFILE_INDEXf);
  tbl_data->termination_profile = soc_mem_field32_get(unit, mem_var, data, TERMINATION_TYPEf);
  tbl_data->in_lif_profile = soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->tpid_profile = soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile = soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->da_not_found_profile = soc_mem_field32_get(unit, mem_var, data, DA_NOT_FOUND_PROFILEf);
  tbl_data->vsi = soc_mem_field32_get(unit, mem_var, data, VSIf);
  soc_mem_field64_get(unit, mem_var, data, LEARN_DATAf, &tbl_data->learn_data);
  tbl_data->tt_learn_enable = soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->vsi_assignment_mode = soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set = soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path = soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer = soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type = soc_mem_field32_get(unit, mem_var, data, TYPEf);

    /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->in_lif_valid =          soc_mem_field32_get(unit, IHP_LIF_TABLE_LABEL_PWE_MPm, data, IN_LIF_VALIDf);
      tbl_data->termination_profile_msb = soc_mem_field32_get(unit, IHP_LIF_TABLE_LABEL_PWE_MPm, data, TERMINATION_PROFILE_MSBf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_pwe_mp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_label_pwe_mp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit) ? PPDB_B_LIF_TABLE_LABEL_PWE_MPm : IHP_LIF_TABLE_LABEL_PWE_MPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PWE_MP_TBL_ENTRY_SIZE);

  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_VALIDf, tbl_data->in_lif_valid);
      soc_mem_field32_set(unit, mem_var, data, TERMINATION_PROFILE_MSBf, tbl_data->termination_profile_msb);
  } 

  soc_mem_field32_set(unit, mem_var, data, TERMINATION_TYPEf, tbl_data->termination_profile);
  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, ACTION_PROFILE_INDEXf, tbl_data->action_profile_index);
  soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, DA_NOT_FOUND_PROFILEf, tbl_data->da_not_found_profile);
  soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
  soc_mem_field64_set(unit, mem_var, data, LEARN_DATAf, tbl_data->learn_data);
  soc_mem_field32_set(unit, mem_var, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_pwe_mp_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_ENTRY_SIZE ARAD_PP_IHP_LIF_TABLE_ENTRY_SIZE

/* In Jericho, the VSI field is deprecated. Instead, the VSI MSBs are used as the inrif's LSBs. Therefore,
   in the set function, the field needs to be split in two, and in the get function, the LSBs and MSBs
   need to be read separately and merged. */
#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_MASK    0x1fff
#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_SHIFT   2

#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_MASK    3
#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_SHIFT   0

#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_GET(_in_rif)  \
    ((_in_rif >> ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_SHIFT) & ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_MASK)

#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_GET(_in_rif)  \
    ((_in_rif >> ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_SHIFT) & ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_MASK)

#define ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_SET(_in_rif, _in_rif_msb, _in_rif_lsb)  \
    (_in_rif) = (((_in_rif_msb & ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_MASK) << ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_SHIFT) \
                | ((_in_rif_lsb & ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_MASK) << ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_SHIFT))

uint32
  arad_pp_ihp_lif_table_label_protocol_or_lsp_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_ENTRY_SIZE];
  uint32 in_rif_lsb, in_rif_msb;
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)?PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSPm:IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSPm;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_DATA, 1);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  res = soc_mem_array_read(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->orientation_is_hub =    soc_mem_field32_get(unit, mem_var, data, ORIENTATION_IS_HUBf);
  tbl_data->action_profile_index =  soc_mem_field32_get(unit, mem_var, data, ACTION_PROFILE_INDEXf);
  tbl_data->model_is_pipe =         soc_mem_field32_get(unit, mem_var, data, MODEL_IS_PIPEf);
  tbl_data->in_lif_profile =        soc_mem_field32_get(unit, mem_var, data, IN_LIF_PROFILEf);
  tbl_data->tpid_profile =          soc_mem_field32_get(unit, mem_var, data, TPID_PROFILEf);
  tbl_data->cos_profile =           soc_mem_field32_get(unit, mem_var, data, COS_PROFILEf);
  tbl_data->da_not_found_profile =  soc_mem_field32_get(unit, mem_var, data, DA_NOT_FOUND_PROFILEf);
  tbl_data->service_type =          soc_mem_field32_get(unit, mem_var, data, SERVICE_TYPEf);
  tbl_data->in_rif_valid =          soc_mem_field32_get(unit, mem_var, data, IN_RIF_VALIDf);
  tbl_data->forwarding_code =       soc_mem_field32_get(unit, mem_var, data, FORWARDING_CODEf);
  tbl_data->destination =           soc_mem_field32_get(unit, mem_var, data, DESTINATIONf);
  tbl_data->tt_learn_enable =       soc_mem_field32_get(unit, mem_var, data, TT_LEARN_ENABLEf);
  tbl_data->vsi_assignment_mode =   soc_mem_field32_get(unit, mem_var, data, VSI_ASSIGNMENT_MODEf);
  tbl_data->oam_lif_set =           soc_mem_field32_get(unit, mem_var, data, OAM_LIF_SETf);
  tbl_data->protection_path =       soc_mem_field32_get(unit, mem_var, data, PROTECTION_PATHf);
  tbl_data->protection_pointer =    soc_mem_field32_get(unit, mem_var, data, PROTECTION_POINTERf);
  tbl_data->type =                  soc_mem_field32_get(unit, mem_var, data, TYPEf);

  /* Some fields have different names in Jericho, or don't exist in Jericho, or exist only in Jericho. */
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->termination_profile =   soc_mem_field32_get(unit, mem_var, data, TERMINATION_TYPE_LSBf);
      tbl_data->destination_valid =     soc_mem_field32_get(unit, mem_var, data, DESTINATION_VALID_OR_TERMINATION_TYPE_MSBf);
      tbl_data->sys_in_lif =            soc_mem_field32_get(unit, mem_var, data, SYS_IN_LIFf);
      tbl_data->vsi =                   soc_mem_field32_get(unit, mem_var, data, VSIf);
      if (soc_mem_field_valid(unit, mem_var, IN_RIFf)) {
          tbl_data->in_rif =            soc_mem_field32_get(unit, mem_var, data, IN_RIFf);
      } else {
      /* Concerning the lines below: In Jericho, the VSI field is deprecated.
       * Instead, the VSI MSBs are used as the inrif's LSBs. Therefore,
       * the LSBs and MSBs need to be read separately and merged.
       */
          in_rif_msb =                  soc_mem_field32_get(unit, mem_var, data, IN_RIF_MSBf);
          in_rif_lsb =                  soc_mem_field32_get(unit, mem_var, data, VSI_MSBf);
          ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_SET(tbl_data->in_rif, in_rif_msb, in_rif_lsb);
      }
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      tbl_data->in_lif_valid =          soc_mem_field32_get(unit, mem_var, data, IN_LIF_VALIDf);
      tbl_data->termination_profile =   soc_mem_field32_get(unit, mem_var, data, TERMINATION_PROFILEf);
      tbl_data->vsi =                   soc_mem_field32_get(unit, mem_var, data, VSIf);
      tbl_data->in_rif =                soc_mem_field32_get(unit, mem_var, data, IN_RIFf);
      tbl_data->destination_valid =     soc_mem_field32_get(unit, mem_var, data, DESTINATION_VALIDf);
      tbl_data->expect_bos =            soc_mem_field32_get(unit, mem_var, data, EXPECT_BOSf);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_protocol_or_lsp_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_lif_table_label_protocol_or_lsp_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK,
    entry_offset_in_bank,
    bank_id;
  uint32
    data[ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_ENTRY_SIZE];
  soc_mem_t mem_var = SOC_IS_JERICHO_PLUS_A0(unit)?PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSPm:IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSPm;
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_TBL_ENTRY_SIZE);


  /* The name of the table, and some fields are different in Jericho. Handle them here. */
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, mem_var, data, SYS_IN_LIFf, tbl_data->sys_in_lif);
      soc_mem_field32_set(unit, mem_var, data, DOUBLE_DATA_ENTRYf, 0 /* Not configurable */);
      soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALID_OR_TERMINATION_TYPE_MSBf, tbl_data->destination_valid);
      soc_mem_field32_set(unit, mem_var, data, TERMINATION_TYPE_LSBf, tbl_data->termination_profile);
      if (tbl_data->in_rif_valid) {
          if (soc_mem_field_valid(unit, mem_var, IN_RIFf)) {
              soc_mem_field32_set(unit, mem_var, data, IN_RIFf, tbl_data->in_rif);
          } else {
              soc_mem_field32_set(unit, mem_var, data, IN_RIF_MSBf, ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_MSB_GET(tbl_data->in_rif));
              /* Concerning the line below: In Jericho, the vsi msb and in rif LSB intersect. In case rif is invalid, vsi msb's belongs only to the vsi */
              soc_mem_field32_set(unit, mem_var, data, VSI_MSBf, ARAD_PP_PPDB_B_LIF_TABLE_LABEL_PROTOCOL_OR_LSP_IN_RIF_LSB_GET(tbl_data->in_rif));
          }
      } else {
          soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
      }
 
  } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
      soc_mem_field32_set(unit, mem_var, data, IN_LIF_VALIDf, tbl_data->in_lif_valid);
      soc_mem_field32_set(unit, mem_var, data, IN_RIFf, tbl_data->in_rif);
      soc_mem_field32_set(unit, mem_var, data, DESTINATION_VALIDf, tbl_data->destination_valid);
      soc_mem_field32_set(unit, mem_var, data, TERMINATION_PROFILEf, tbl_data->termination_profile);
      soc_mem_field32_set(unit, mem_var, data, VSIf, tbl_data->vsi);
      soc_mem_field32_set(unit, mem_var, data, EXPECT_BOSf, tbl_data->expect_bos);
  } 

  soc_mem_field32_set(unit, mem_var, data, ORIENTATION_IS_HUBf, tbl_data->orientation_is_hub);
  soc_mem_field32_set(unit, mem_var, data, ACTION_PROFILE_INDEXf, tbl_data->action_profile_index);
  soc_mem_field32_set(unit, mem_var, data, MODEL_IS_PIPEf, tbl_data->model_is_pipe);
  soc_mem_field32_set(unit, mem_var, data, IN_LIF_PROFILEf, tbl_data->in_lif_profile);
  soc_mem_field32_set(unit, mem_var, data, TPID_PROFILEf, tbl_data->tpid_profile);
  soc_mem_field32_set(unit, mem_var, data, COS_PROFILEf, tbl_data->cos_profile);
  soc_mem_field32_set(unit, mem_var, data, DA_NOT_FOUND_PROFILEf, tbl_data->da_not_found_profile);
  soc_mem_field32_set(unit, mem_var, data, SERVICE_TYPEf, tbl_data->service_type);
  soc_mem_field32_set(unit, mem_var, data, IN_RIF_VALIDf, tbl_data->in_rif_valid);
  soc_mem_field32_set(unit, mem_var, data, FORWARDING_CODEf, tbl_data->forwarding_code);
  if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
  }
  soc_mem_field32_set(unit, mem_var, data, DESTINATIONf, tbl_data->destination);
  soc_mem_field32_set(unit, mem_var, data, TT_LEARN_ENABLEf, tbl_data->tt_learn_enable);
  soc_mem_field32_set(unit, mem_var, data, VSI_ASSIGNMENT_MODEf, tbl_data->vsi_assignment_mode);
  soc_mem_field32_set(unit, mem_var, data, OAM_LIF_SETf, tbl_data->oam_lif_set);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_PATHf, tbl_data->protection_path);
  soc_mem_field32_set(unit, mem_var, data, PROTECTION_POINTERf, tbl_data->protection_pointer);
  soc_mem_field32_set(unit, mem_var, data, TYPEf, tbl_data->type);

  bank_id = ARAD_PP_IN_LIF_TO_BANK_ID(unit, entry_offset);
  entry_offset_in_bank = ARAD_PP_IN_LIF_TO_OFFSET_IN_BANK(unit, entry_offset);

  if(SOC_IS_JERICHO_PLUS_A0(unit)){
    mem_var=PPDB_B_LIF_TABLEm;
  }
  res = soc_mem_array_write(unit, mem_var, bank_id, MEM_BLOCK_ANY, entry_offset_in_bank, data);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_lif_table_label_protocol_or_lsp_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_isid_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_ISID_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_ISID_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_ISID_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_ISID_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_ISID_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_ISID_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->isid = soc_mem_field32_get(unit, EPNI_ISID_TABLEm, data, ISIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_isid_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_isid_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_ISID_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_ISID_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_ISID_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_ISID_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_ISID_TABLEm, data, ISIDf, tbl_data->isid);

  res = soc_mem_write(
          unit,
          EPNI_ISID_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_isid_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_termination_profile_table_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_TERMINATION_PROFILE_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->ttl_exp_label_index = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, TTL_EXP_LABEL_INDEXf);
  tbl_data->reject_ttl_0 = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, REJECT_TTL_0f);
  tbl_data->reject_ttl_1 = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, REJECT_TTL_1f);
  tbl_data->has_cw = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, HAS_CWf);
  tbl_data->labels_to_terminate = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, LABELS_TO_TERMINATEf);
  tbl_data->skip_ethernet = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, SKIP_ETHERNETf);

#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    tbl_data->check_bos = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, CHECK_BOSf);
    if (SOC_IS_JERICHO(unit)) {
        tbl_data->expect_bos = soc_mem_field32_get(unit, IHP_TERMINATION_PROFILE_TABLEm, data, EXPECT_BOSf);
    }
  }
#endif /* BCM_88660_A0 */
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_termination_profile_table_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_termination_profile_table_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_TERMINATION_PROFILE_TABLE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, TTL_EXP_LABEL_INDEXf, tbl_data->ttl_exp_label_index);
  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, REJECT_TTL_0f, tbl_data->reject_ttl_0);
  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, REJECT_TTL_1f, tbl_data->reject_ttl_1);
  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, HAS_CWf, tbl_data->has_cw);
  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, LABELS_TO_TERMINATEf, tbl_data->labels_to_terminate);
  soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, SKIP_ETHERNETf, tbl_data->skip_ethernet);
        
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, CHECK_BOSf, tbl_data->check_bos);
    if (SOC_IS_JERICHO(unit)) {
        soc_mem_field32_set(unit, IHP_TERMINATION_PROFILE_TABLEm, data, EXPECT_BOSf, tbl_data->expect_bos);
    }
  }
#endif /* BCM_88660_A0 */
  
  res = soc_mem_write(
          unit,
          IHP_TERMINATION_PROFILE_TABLEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_termination_profile_table_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_action_profile_mpls_value_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IHP_ACTION_PROFILE_MPLS_VALUEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->cpu_trap_code = soc_mem_field32_get(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, CPU_TRAP_CODEf);
  tbl_data->cpu_trap_strength = soc_mem_field32_get(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, CPU_TRAP_STRENGTHf);
  tbl_data->snoop_strength = soc_mem_field32_get(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, SNOOP_STRENGTHf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_action_profile_mpls_value_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_ihp_action_profile_mpls_value_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IHP_ACTION_PROFILE_MPLS_VALUE_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, CPU_TRAP_CODEf, tbl_data->cpu_trap_code);
  soc_mem_field32_set(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, CPU_TRAP_STRENGTHf, tbl_data->cpu_trap_strength);
  soc_mem_field32_set(unit, IHP_ACTION_PROFILE_MPLS_VALUEm, data, SNOOP_STRENGTHf, tbl_data->snoop_strength);

  res = soc_mem_write(
          unit,
          IHP_ACTION_PROFILE_MPLS_VALUEm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_ihp_action_profile_mpls_value_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_0_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, OUTLIF_1f);
  tbl_data->pp_dsp_1a = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, PP_DSP_1Af);
  tbl_data->pp_dsp_1b = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, PP_DSP_1Bf);
  tbl_data->link_ptr = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, LINK_PTRf);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_0_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_0_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_0_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, PP_DSP_1Af, tbl_data->pp_dsp_1a);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, PP_DSP_1Bf, tbl_data->pp_dsp_1b);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, LINK_PTRf, tbl_data->link_ptr);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_0m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_0m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_0_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_1_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, OUTLIF_1f);
  tbl_data->bmp_ptr = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, BMP_PTRf);
  tbl_data->link_ptr = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, LINK_PTRf);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_1_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_1_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_1_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, BMP_PTRf, tbl_data->bmp_ptr);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, LINK_PTRf, tbl_data->link_ptr);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_1m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_1m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_1_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_2_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_2m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, OUTLIF_1f);
  tbl_data->outlif_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, OUTLIF_2f);
  tbl_data->link_ptr = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, LINK_PTRf);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_2_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_2_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_2_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, OUTLIF_2f, tbl_data->outlif_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, LINK_PTRf, tbl_data->link_ptr);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_2m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_2m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_2_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_4_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_4m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, OUTLIF_1f);
  tbl_data->pp_dsp_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, PP_DSP_1f);
  tbl_data->outlif_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, OUTLIF_2f);
  tbl_data->pp_dsp_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, PP_DSP_2f);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_4_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_4_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_4_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, PP_DSP_1f, tbl_data->pp_dsp_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, OUTLIF_2f, tbl_data->outlif_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, PP_DSP_2f, tbl_data->pp_dsp_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_4m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_4m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_4_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_5_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_5m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, OUTLIF_1f);
  tbl_data->pp_dsp_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, PP_DSP_1f);
  tbl_data->outlif_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, OUTLIF_2f);
  tbl_data->pp_dsp_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, PP_DSP_2f);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_5_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_5_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_5_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, PP_DSP_1f, tbl_data->pp_dsp_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, OUTLIF_2f, tbl_data->outlif_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, PP_DSP_2f, tbl_data->pp_dsp_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_5m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_5m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_5_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_6_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_6m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_1f);
  tbl_data->outlif_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_2f);
  tbl_data->outlif_3 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_3f);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_6_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_6_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_6_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_2f, tbl_data->outlif_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, OUTLIF_3f, tbl_data->outlif_3);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_6m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_6m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_6_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_format_7_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_FORMAT_7m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->outlif_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_1f);
  tbl_data->outlif_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_2f);
  tbl_data->outlif_3 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_3f);
  tbl_data->entry_format = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, ENTRY_FORMATf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_7_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_format_7_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_FORMAT_7_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_1f, tbl_data->outlif_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_2f, tbl_data->outlif_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, OUTLIF_3f, tbl_data->outlif_3);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_FORMAT_7m, data, ENTRY_FORMATf, tbl_data->entry_format);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_FORMAT_7m,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_format_7_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_special_format_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_SPECIAL_FORMATm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->mc_bmp_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_1f);
  tbl_data->mc_bmp_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_2f);
  tbl_data->mc_bmp_3 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_3f);
  tbl_data->mc_bmp_4 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_4f);
  tbl_data->mc_bmp_5 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_5f);
  tbl_data->mc_bmp_6 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_6f);
  tbl_data->mc_bmp_7 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_7f);
  tbl_data->mc_bmp_8 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_8f);
  tbl_data->reserved = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, RESERVEDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_special_format_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_special_format_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_SPECIAL_FORMAT_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_1f, tbl_data->mc_bmp_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_2f, tbl_data->mc_bmp_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_3f, tbl_data->mc_bmp_3);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_4f, tbl_data->mc_bmp_4);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_5f, tbl_data->mc_bmp_5);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_6f, tbl_data->mc_bmp_6);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_7f, tbl_data->mc_bmp_7);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, MC_BMP_8f, tbl_data->mc_bmp_8);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_SPECIAL_FORMATm, data, RESERVEDf, tbl_data->reserved);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_SPECIAL_FORMATm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_special_format_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_ENTRY_SIZE 2

uint32
  arad_pp_irr_mcdb_egress_tdm_format_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          IRR_MCDB_EGRESS_TDM_FORMATm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->pp_dsp_1 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_1f);
  tbl_data->pp_dsp_2 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_2f);
  tbl_data->pp_dsp_3 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_3f);
  tbl_data->pp_dsp_4 = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_4f);
  tbl_data->link_ptr = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, LINK_PTRf);
  tbl_data->reserved = soc_mem_field32_get(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, RESERVEDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_tdm_format_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_irr_mcdb_egress_tdm_format_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_IRR_MCDB_EGRESS_TDM_FORMAT_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_1f, tbl_data->pp_dsp_1);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_2f, tbl_data->pp_dsp_2);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_3f, tbl_data->pp_dsp_3);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, PP_DSP_4f, tbl_data->pp_dsp_4);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, LINK_PTRf, tbl_data->link_ptr);
  soc_mem_field32_set(unit, IRR_MCDB_EGRESS_TDM_FORMATm, data, RESERVEDf, tbl_data->reserved);

  res = soc_mem_write(
          unit,
          IRR_MCDB_EGRESS_TDM_FORMATm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_irr_mcdb_egress_tdm_format_tbl_set_unsafe()", entry_offset, 0);
}

/* Clear table data and mask all fields */
void
  ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA_init(
     int unit,
    ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA   *tbl_data
  )
{
  sal_memset(tbl_data, 0, sizeof(ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA));
  tbl_data->fwd_code_mask                     = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FWD_CODE_MASKf);
  tbl_data->prge_tm_profile_mask              = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, PRGE_TM_PROFILE_MASKf);
  tbl_data->prge_pp_profile_mask              = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, PRGE_PP_PROFILE_MASKf);
  tbl_data->system_mc_mask                    = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, SYSTEM_MC_MASKf);
  tbl_data->oam_sub_type_mask                 = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, OAM_SUB_TYPE_MASKf);
  tbl_data->ace_variable_mask                 = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, ACE_VARIABLE_MASKf);
  tbl_data->value_1_mask                      = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, VALUE_1_MASKf);
  tbl_data->pph_type_mask                     = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, PPH_TYPE_MASKf);
  tbl_data->fhei_size_mask                    = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FHEI_SIZE_MASKf);
  tbl_data->eei_valid_mask                    = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, EEI_VALID_MASKf);
  tbl_data->learn_ext_exist_mask              = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, LEARN_EXT_EXIST_MASKf);
  tbl_data->data_entry_lsbs_mask              = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, DATA_ENTRY_LSBS_MASKf);
  tbl_data->first_enc_mask                    = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FIRST_ENC_MASKf);
  tbl_data->second_enc_mask                   = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, SECOND_ENC_MASKf);
  tbl_data->link_editor_entry_is_ac_mask      = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, LINK_EDITOR_ENTRY_IS_AC_MASKf);
  tbl_data->data_entry_cnt_mask               = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, DATA_ENTRY_CNT_MASKf);
  tbl_data->routing_over_overlay_mask         = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, ROUTING_OVER_OVERLAY_MASKf);
  tbl_data->first_out_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FIRST_OUT_LIF_PROFILE_MASKf);
  tbl_data->second_out_lif_profile_mask       = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, SECOND_OUT_LIF_PROFILE_MASKf);
  tbl_data->third_out_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, THIRD_OUT_LIF_PROFILE_MASKf);
  tbl_data->forth_out_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FORTH_OUT_LIF_PROFILE_MASKf);
  tbl_data->first_out_lif_profile_valid_mask  = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FIRST_OUT_LIF_PROFILE_VALID_MASKf);
  tbl_data->second_out_lif_profile_valid_mask = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, SECOND_OUT_LIF_PROFILE_VALID_MASKf);
  tbl_data->third_out_lif_profile_valid_mask  = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, THIRD_OUT_LIF_PROFILE_VALID_MASKf);
  tbl_data->forth_out_lif_profile_valid_mask  = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FORTH_OUT_LIF_PROFILE_VALID_MASKf);
  tbl_data->fifth_out_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FIFTH_OUT_LIF_PROFILE_MASKf);
  tbl_data->sixth_out_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, SIXTH_OUT_LIF_PROFILE_MASKf);
  tbl_data->native_ac_lif_profile_mask        = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, NATIVE_AC_LIF_PROFILE_MASKf);
  tbl_data->mirror_enable_mask                = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, MIRROR_ENABLE_MASKf);
  tbl_data->mirror_command_mask               = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, MIRROR_COMMAND_MASKf);
  tbl_data->fwd_enable_mask                   = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, FWD_ENABLE_MASKf);
  tbl_data->data_entry_2_lsbs_mask            = ARAD_EGR_PRGE_PROG_SEL_DEFAULT_ENTRY_FIELD_MASK(unit, DATA_ENTRY_2_LSBS_MASKf);
}

uint32
  arad_pp_epni_prge_program_selection_cam_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(EPNI_PRGE_PROGRAM_SELECTION_CAM_NOF_LONGS)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(EPNI_PRGE_PROGRAM_SELECTION_CAM_NOF_LONGS));
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_PRGE_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->fwd_code = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_CODEf);
  tbl_data->prge_tm_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_TM_PROFILEf);
  tbl_data->prge_pp_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_PP_PROFILEf);
  tbl_data->system_mc = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SYSTEM_MCf);
  tbl_data->pph_type = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PPH_TYPEf);
  tbl_data->fhei_size = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FHEI_SIZEf);
  tbl_data->eei_valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, EEI_VALIDf);
  tbl_data->learn_ext_exist = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LEARN_EXT_EXISTf);
  tbl_data->value_1 = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALUE_1f);
  tbl_data->ace_variable = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ACE_VARIABLEf);
  tbl_data->oam_sub_type = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, OAM_SUB_TYPEf);
  tbl_data->data_entry_lsbs = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_LSBSf);
  tbl_data->first_enc = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_ENCf);
  tbl_data->second_enc = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_ENCf);
  tbl_data->link_editor_entry_is_ac = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LINK_EDITOR_ENTRY_IS_ACf);
  tbl_data->data_entry_cnt = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_CNTf);
  tbl_data->fwd_code_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_CODE_MASKf);
  tbl_data->prge_tm_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_TM_PROFILE_MASKf);
  tbl_data->prge_pp_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_PP_PROFILE_MASKf);
  tbl_data->system_mc_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SYSTEM_MC_MASKf);
  tbl_data->pph_type_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PPH_TYPE_MASKf);
  tbl_data->fhei_size_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FHEI_SIZE_MASKf);
  tbl_data->eei_valid_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, EEI_VALID_MASKf);
  tbl_data->learn_ext_exist_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LEARN_EXT_EXIST_MASKf);
  tbl_data->value_1_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALUE_1_MASKf);
  tbl_data->ace_variable_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ACE_VARIABLE_MASKf);
  tbl_data->oam_sub_type_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, OAM_SUB_TYPE_MASKf);
  tbl_data->data_entry_lsbs_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_LSBS_MASKf);
  tbl_data->first_enc_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_ENC_MASKf);
  tbl_data->second_enc_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_ENC_MASKf);
  tbl_data->link_editor_entry_is_ac_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LINK_EDITOR_ENTRY_IS_AC_MASKf);
  tbl_data->data_entry_cnt_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_CNT_MASKf);
  if (SOC_IS_JERICHO(unit)) {
      tbl_data->routing_over_overlay = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ROUTING_OVER_OVERLAYf);
      tbl_data->routing_over_overlay_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ROUTING_OVER_OVERLAY_MASKf);

      tbl_data->first_out_lif_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILEf);
      tbl_data->second_out_lif_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILEf);
      tbl_data->third_out_lif_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILEf);
      tbl_data->forth_out_lif_profile = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILEf);

      tbl_data->first_out_lif_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_MASKf);
      tbl_data->second_out_lif_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_MASKf);
      tbl_data->third_out_lif_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_MASKf);
      tbl_data->forth_out_lif_profile_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_MASKf);



      if (!SOC_IS_QAX(unit) && !SOC_IS_JERICHO_PLUS_A0(unit)) {
          tbl_data->first_out_lif_profile_valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_VALIDf);
          tbl_data->second_out_lif_profile_valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_VALIDf);
          tbl_data->third_out_lif_profile_valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_VALIDf);
          tbl_data->forth_out_lif_profile_valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_VALIDf);

          tbl_data->first_out_lif_profile_valid_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_VALID_MASKf);
          tbl_data->second_out_lif_profile_valid_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_VALID_MASKf);
          tbl_data->third_out_lif_profile_valid_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_VALID_MASKf);
          tbl_data->forth_out_lif_profile_valid_mask = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_VALID_MASKf);
      }
  }
  if (SOC_IS_JERICHO_PLUS(unit)) {

      tbl_data->fifth_out_lif_profile            = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIFTH_OUT_LIF_PROFILEf);
      tbl_data->sixth_out_lif_profile            = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SIXTH_OUT_LIF_PROFILEf);
      tbl_data->native_ac_lif_profile            = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, NATIVE_AC_LIF_PROFILEf);
      tbl_data->mirror_enable                    = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_ENABLEf);
      tbl_data->mirror_command                   = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_COMMANDf);
      tbl_data->fwd_enable                       = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_ENABLEf);
      tbl_data->data_entry_2_lsbs                = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_2_LSBSf);

      tbl_data->fifth_out_lif_profile_mask       = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIFTH_OUT_LIF_PROFILE_MASKf);
      tbl_data->sixth_out_lif_profile_mask       = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SIXTH_OUT_LIF_PROFILE_MASKf);
      tbl_data->native_ac_lif_profile_mask       = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, NATIVE_AC_LIF_PROFILE_MASKf);
      tbl_data->mirror_enable_mask               = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_ENABLE_MASKf);
      tbl_data->mirror_command_mask              = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_COMMAND_MASKf);
      tbl_data->fwd_enable_mask                  = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_ENABLE_MASKf);
      tbl_data->data_entry_2_lsbs_mask           = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_2_LSBS_MASKf);

  }
  tbl_data->program = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PROGRAMf);
  tbl_data->valid = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALIDf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_program_selection_cam_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_prge_program_selection_cam_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[SOC_DPP_IMP_DEFS_MAX(EPNI_PRGE_PROGRAM_SELECTION_CAM_NOF_LONGS)];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_PROGRAM_SELECTION_CAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, SOC_DPP_IMP_DEFS_MAX(EPNI_PRGE_PROGRAM_SELECTION_CAM_NOF_LONGS));

  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_CODEf, tbl_data->fwd_code);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_TM_PROFILEf, tbl_data->prge_tm_profile);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_PP_PROFILEf, tbl_data->prge_pp_profile);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SYSTEM_MCf, tbl_data->system_mc);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PPH_TYPEf, tbl_data->pph_type);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FHEI_SIZEf, tbl_data->fhei_size);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, EEI_VALIDf, tbl_data->eei_valid);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LEARN_EXT_EXISTf, tbl_data->learn_ext_exist);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALUE_1f, tbl_data->value_1);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ACE_VARIABLEf, tbl_data->ace_variable);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, OAM_SUB_TYPEf, tbl_data->oam_sub_type);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_LSBSf, tbl_data->data_entry_lsbs);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_ENCf, tbl_data->first_enc);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_ENCf, tbl_data->second_enc);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LINK_EDITOR_ENTRY_IS_ACf, tbl_data->link_editor_entry_is_ac);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_CNTf, tbl_data->data_entry_cnt);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_CODE_MASKf, tbl_data->fwd_code_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_TM_PROFILE_MASKf, tbl_data->prge_tm_profile_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PRGE_PP_PROFILE_MASKf, tbl_data->prge_pp_profile_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SYSTEM_MC_MASKf, tbl_data->system_mc_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PPH_TYPE_MASKf, tbl_data->pph_type_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FHEI_SIZE_MASKf, tbl_data->fhei_size_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, EEI_VALID_MASKf, tbl_data->eei_valid_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LEARN_EXT_EXIST_MASKf, tbl_data->learn_ext_exist_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALUE_1_MASKf, tbl_data->value_1_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ACE_VARIABLE_MASKf, tbl_data->ace_variable_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, OAM_SUB_TYPE_MASKf, tbl_data->oam_sub_type_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_LSBS_MASKf, tbl_data->data_entry_lsbs_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_ENC_MASKf, tbl_data->first_enc_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_ENC_MASKf, tbl_data->second_enc_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, LINK_EDITOR_ENTRY_IS_AC_MASKf, tbl_data->link_editor_entry_is_ac_mask);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_CNT_MASKf, tbl_data->data_entry_cnt_mask);
  if (SOC_IS_JERICHO(unit)) {
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ROUTING_OVER_OVERLAYf, tbl_data->routing_over_overlay);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, ROUTING_OVER_OVERLAY_MASKf, tbl_data->routing_over_overlay_mask);

      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILEf, tbl_data->first_out_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILEf, tbl_data->second_out_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILEf, tbl_data->third_out_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILEf, tbl_data->forth_out_lif_profile);

      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_MASKf, tbl_data->first_out_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_MASKf, tbl_data->second_out_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_MASKf, tbl_data->third_out_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_MASKf, tbl_data->forth_out_lif_profile_mask);

      if (!SOC_IS_QAX(unit) && !SOC_IS_JERICHO_PLUS_A0(unit)) {
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_VALIDf, tbl_data->first_out_lif_profile_valid);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_VALIDf, tbl_data->second_out_lif_profile_valid);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_VALIDf, tbl_data->third_out_lif_profile_valid);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_VALIDf, tbl_data->forth_out_lif_profile_valid);

          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIRST_OUT_LIF_PROFILE_VALID_MASKf, tbl_data->first_out_lif_profile_valid_mask);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SECOND_OUT_LIF_PROFILE_VALID_MASKf, tbl_data->second_out_lif_profile_valid_mask);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, THIRD_OUT_LIF_PROFILE_VALID_MASKf, tbl_data->third_out_lif_profile_valid_mask);
          soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FORTH_OUT_LIF_PROFILE_VALID_MASKf, tbl_data->forth_out_lif_profile_valid_mask);
      }
  }
  if (SOC_IS_JERICHO_PLUS(unit)) {
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIFTH_OUT_LIF_PROFILEf, tbl_data->fifth_out_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SIXTH_OUT_LIF_PROFILEf, tbl_data->sixth_out_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, NATIVE_AC_LIF_PROFILEf, tbl_data->native_ac_lif_profile);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_ENABLEf, tbl_data->mirror_enable);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_COMMANDf, tbl_data->mirror_command);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_ENABLEf, tbl_data->fwd_enable);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_2_LSBSf, tbl_data->data_entry_2_lsbs);

      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FIFTH_OUT_LIF_PROFILE_MASKf, tbl_data->fifth_out_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, SIXTH_OUT_LIF_PROFILE_MASKf, tbl_data->sixth_out_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, NATIVE_AC_LIF_PROFILE_MASKf, tbl_data->native_ac_lif_profile_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_ENABLE_MASKf, tbl_data->mirror_enable_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, MIRROR_COMMAND_MASKf, tbl_data->mirror_command_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, FWD_ENABLE_MASKf, tbl_data->fwd_enable_mask);
      soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, DATA_ENTRY_2_LSBS_MASKf, tbl_data->data_entry_2_lsbs_mask);
  }
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, PROGRAMf, tbl_data->program);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAM_SELECTION_CAMm, data, VALIDf, tbl_data->valid);

  res = soc_mem_write(
          unit,
          EPNI_PRGE_PROGRAM_SELECTION_CAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_program_selection_cam_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_PRGE_PROGRAM_TBL_ENTRY_SIZE 3

uint32
  arad_pp_epni_prge_program_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_PRGE_PROGRAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_PROGRAM_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_PROGRAM_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_PROGRAM_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PRGE_PROGRAM_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_PRGE_PROGRAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->program_pointer = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAMm, data, PROGRAM_POINTERf);
  tbl_data->register_src = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAMm, data, REGISTER_SRCf);
  tbl_data->bytes_to_remove = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAMm, data, BYTES_TO_REMOVEf);
  tbl_data->remove_network_header = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAMm, data, REMOVE_NETWORK_HEADERf);
  tbl_data->remove_system_header = soc_mem_field32_get(unit, EPNI_PRGE_PROGRAMm, data, REMOVE_SYSTEM_HEADERf);
  soc_mem_field64_get(unit, EPNI_PRGE_PROGRAMm, data, PROGRAM_VARf, &tbl_data->program_var);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_program_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_prge_program_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_PRGE_PROGRAM_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_PROGRAM_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_PROGRAM_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_PROGRAM_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAMm, data, PROGRAM_POINTERf, tbl_data->program_pointer);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAMm, data, REGISTER_SRCf, tbl_data->register_src);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAMm, data, BYTES_TO_REMOVEf, tbl_data->bytes_to_remove);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAMm, data, REMOVE_NETWORK_HEADERf, tbl_data->remove_network_header);
  soc_mem_field32_set(unit, EPNI_PRGE_PROGRAMm, data, REMOVE_SYSTEM_HEADERf, tbl_data->remove_system_header);
  soc_mem_field64_set(unit, EPNI_PRGE_PROGRAMm, data, PROGRAM_VARf, tbl_data->program_var);

  res = soc_mem_write(
          unit,
          EPNI_PRGE_PROGRAMm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_program_tbl_set_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_ENTRY_SIZE 2

uint32
  arad_pp_epni_prge_instruction_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  soc_mem_t  memory_offset,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          memory_offset,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  tbl_data->src_select = soc_mem_field32_get(unit, memory_offset, data, SRC_SELECTf);
  tbl_data->size_src = soc_mem_field32_get(unit, memory_offset, data, SIZE_SRCf);
  tbl_data->size_base = soc_mem_field32_get(unit, memory_offset, data, SIZE_BASEf);
  tbl_data->offset_src = soc_mem_field32_get(unit, memory_offset, data, OFFSET_SRCf);
  tbl_data->offset_base = soc_mem_field32_get(unit, memory_offset, data, OFFSET_BASEf);
  tbl_data->fem_select = soc_mem_field32_get(unit, memory_offset, data, FEM_SELECTf);
  tbl_data->op_value = soc_mem_field32_get(unit, memory_offset, data, OP_VALUEf);
  tbl_data->op_1_field_select = soc_mem_field32_get(unit, memory_offset, data, OP_1_FIELD_SELECTf);
  tbl_data->op_2_field_select = soc_mem_field32_get(unit, memory_offset, data, OP_2_FIELD_SELECTf);
  tbl_data->op_3_field_select = soc_mem_field32_get(unit, memory_offset, data, OP_3_FIELD_SELECTf);
  tbl_data->alu_action = soc_mem_field32_get(unit, memory_offset, data, ALU_ACTIONf);
  tbl_data->cmp_action = soc_mem_field32_get(unit, memory_offset, data, CMP_ACTIONf);
  tbl_data->dst_select = soc_mem_field32_get(unit, memory_offset, data, DST_SELECTf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_instruction_tbl_get_unsafe()", memory_offset, entry_offset);
}

uint32
  arad_pp_epni_prge_instruction_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  soc_mem_t  memory_offset,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_INSTRUCTION_TBL_ENTRY_SIZE);

  soc_mem_field32_set(unit, memory_offset, data, SRC_SELECTf, tbl_data->src_select);
  soc_mem_field32_set(unit, memory_offset, data, SIZE_SRCf, tbl_data->size_src);
  soc_mem_field32_set(unit, memory_offset, data, SIZE_BASEf, tbl_data->size_base);
  soc_mem_field32_set(unit, memory_offset, data, OFFSET_SRCf, tbl_data->offset_src);
  soc_mem_field32_set(unit, memory_offset, data, OFFSET_BASEf, tbl_data->offset_base);
  soc_mem_field32_set(unit, memory_offset, data, FEM_SELECTf, tbl_data->fem_select);
  soc_mem_field32_set(unit, memory_offset, data, OP_VALUEf, (uint16)(tbl_data->op_value));
  soc_mem_field32_set(unit, memory_offset, data, OP_1_FIELD_SELECTf, tbl_data->op_1_field_select);
  soc_mem_field32_set(unit, memory_offset, data, OP_2_FIELD_SELECTf, tbl_data->op_2_field_select);
  soc_mem_field32_set(unit, memory_offset, data, OP_3_FIELD_SELECTf, tbl_data->op_3_field_select);
  soc_mem_field32_set(unit, memory_offset, data, ALU_ACTIONf, tbl_data->alu_action);
  soc_mem_field32_set(unit, memory_offset, data, CMP_ACTIONf, tbl_data->cmp_action);
  soc_mem_field32_set(unit, memory_offset, data, DST_SELECTf, tbl_data->dst_select);

  res = soc_mem_write(
          unit,
          memory_offset,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_instruction_tbl_set_unsafe()", memory_offset, entry_offset);
}


#define ARAD_PP_EPNI_PRGE_DATA_TBL_ENTRY_SIZE 5

uint32
  arad_pp_epni_prge_data_tbl_get_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_OUT ARAD_PP_EPNI_PRGE_DATA_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_DATA_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_DATA_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_DATA_TBL_ENTRY_SIZE);
  ARAD_CLEAR(tbl_data, ARAD_PP_EPNI_PRGE_DATA_TBL_DATA, 1);

  res = soc_mem_read(
          unit,
          EPNI_PRGE_DATAm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 30, exit);

  soc_mem_field_get(
      unit, 
      EPNI_PRGE_DATAm, 
      data, 
      PRGE_DATA_ENTRYf, 
      (uint32*) &(tbl_data->prge_data_entry[0])
      );


exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_data_tbl_get_unsafe()", entry_offset, 0);
}

uint32
  arad_pp_epni_prge_data_tbl_set_unsafe(
    SOC_SAND_IN  int  unit,
    SOC_SAND_IN  uint32   entry_offset,
    SOC_SAND_IN  ARAD_PP_EPNI_PRGE_DATA_TBL_DATA *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_PP_EPNI_PRGE_DATA_TBL_ENTRY_SIZE];
 
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_EPNI_PRGE_DATA_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_PP_EPNI_PRGE_DATA_TBL_ENTRY_SIZE);

  soc_mem_field_set(
      unit, 
      EPNI_PRGE_DATAm, 
      data, 
      PRGE_DATA_ENTRYf, 
      (uint32*) &(tbl_data->prge_data_entry[0])
      );


  res = soc_mem_write(
          unit,
          EPNI_PRGE_DATAm,
          MEM_BLOCK_ANY,
          entry_offset,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_epni_prge_data_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_iqm_cnm_profile_tbl_set_unsafe (
    SOC_SAND_IN  int                                   unit,
    SOC_SAND_IN  uint32                                   profile_ndx,
    SOC_SAND_IN  ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_DATA   *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CNM_PROFILE_TBL_SET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_ENTRY_SIZE);
  
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_FB_MAX_VALf, tbl_data->cp_fb_max_val);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_FIXED_SAMPLE_BASEf, tbl_data->cp_fixed_sample_base);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_QEQf, tbl_data->cp_qeq);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_QUANT_DIVf, tbl_data->cp_quant_div);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_0f, tbl_data->cp_sample_base[0]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_1f, tbl_data->cp_sample_base[1]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_2f, tbl_data->cp_sample_base[2]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_3f, tbl_data->cp_sample_base[3]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_4f, tbl_data->cp_sample_base[4]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_5f, tbl_data->cp_sample_base[5]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_6f, tbl_data->cp_sample_base[6]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_7f, tbl_data->cp_sample_base[7]);
  soc_mem_field32_set(unit, IQM_CPPRMm, data, CP_Wf, tbl_data->cp_w);

  res = soc_mem_write(
          unit,
          IQM_CPPRMm,
          MEM_BLOCK_ANY,
          profile_ndx,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_cnm_profile_tbl_set_unsafe()", profile_ndx, 0);
}

uint32
  arad_iqm_cnm_profile_tbl_get_unsafe (
    SOC_SAND_IN  int                                   unit,
    SOC_SAND_IN  uint32                                   profile_ndx,
    SOC_SAND_OUT ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_DATA   *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data[ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_ENTRY_SIZE];

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CNM_PROFILE_TBL_GET_UNSAFE);

  ARAD_CLEAR(data, uint32, ARAD_IQM_CNM_PARAMETERS_TABLE_TBL_ENTRY_SIZE);
  
  res = soc_mem_read(
          unit,
          IQM_CPPRMm,
          MEM_BLOCK_ANY,
          profile_ndx,
          data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  tbl_data->cp_fb_max_val = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_FB_MAX_VALf);
  tbl_data->cp_fixed_sample_base = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_FIXED_SAMPLE_BASEf);
  tbl_data->cp_qeq = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_QEQf);
  tbl_data->cp_quant_div = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_QUANT_DIVf);
  tbl_data->cp_sample_base[0] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_0f);
  tbl_data->cp_sample_base[1] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_1f);
  tbl_data->cp_sample_base[2] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_2f);
  tbl_data->cp_sample_base[3] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_3f);
  tbl_data->cp_sample_base[4] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_4f);
  tbl_data->cp_sample_base[5] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_5f);
  tbl_data->cp_sample_base[6] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_6f);
  tbl_data->cp_sample_base[7] = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_SAMPLE_BASE_7f);
  tbl_data->cp_w = soc_mem_field32_get(unit, IQM_CPPRMm, data, CP_Wf);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_cnm_profile_tbl_get_unsafe()", profile_ndx, 0);
}

uint32
  arad_iqm_cnm_ds_tbl_set_unsafe(
    SOC_SAND_IN  int                     unit,
    SOC_SAND_IN  uint32                     entry_offset,
    SOC_SAND_IN  ARAD_IQM_CNM_DS_TBL_DATA   *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data = 0,
    sampling_mode;
  ARAD_CNM_CP_INFO
    cp_info;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CNM_DS_TBL_SET_UNSAFE);
  SOC_TMC_CNM_CP_INFO_clear(&cp_info);

  res = arad_cnm_cp_get_unsafe(unit, &cp_info);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  if(cp_info.pkt_gen_mode == SOC_TMC_CNM_GEN_MODE_SAMPLING)
  {
    sampling_mode = 1;
  }
  else
  {
    sampling_mode = 0;
  }

  if(sampling_mode == 0)
  {
    soc_mem_field32_set(unit, IQM_CPDMSm, &data, CP_ENABLEf, tbl_data->cp_enable_1);
    soc_mem_field32_set(unit, IQM_CPDMSm, &data, CP_CLASSf, tbl_data->cp_profile_1);
    soc_mem_field32_set(unit, IQM_CPDMSm, &data, CP_IDf, tbl_data->cp_id);
  }
  else
  {
    /* In sampling mode each entry in the table contains data for 2 CP queues */
    /* Bit 0:     CP Enable 1   */
    /* Bits 1-3:  CP Profile 1  */
    /* Bit 4:     CP Enable 2   */
    /* Bits 5-7:  CP Profile 2  */
    soc_mem_field32_set(unit, IQM_CPDMSm, &data, CP_ENABLEf, tbl_data->cp_enable_1);
    soc_mem_field32_set(unit, IQM_CPDMSm, &data, CP_CLASSf, tbl_data->cp_profile_1);
    SOC_SAND_SET_BIT(data,tbl_data->cp_enable_2,ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_EN_2_BIT);
    data |= SOC_SAND_SET_BITS_RANGE(tbl_data->cp_profile_2, ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_MSB, ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_LSB);
  }
  
  res = soc_mem_write(
          unit,
          IQM_CPDMSm,
          MEM_BLOCK_ANY,
          entry_offset,
          &data
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_cnm_ds_tbl_set_unsafe()", entry_offset, 0);
}

uint32
  arad_iqm_cnm_ds_tbl_get_unsafe(
    SOC_SAND_IN  int                     unit,
    SOC_SAND_IN  uint32                     entry_offset,
    SOC_SAND_OUT ARAD_IQM_CNM_DS_TBL_DATA   *tbl_data
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    data,
    sampling_mode;
  ARAD_CNM_CP_INFO
    cp_info;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_IQM_CNM_DS_TBL_GET_UNSAFE);
  SOC_TMC_CNM_CP_INFO_clear(&cp_info);

  res = arad_cnm_cp_get_unsafe(unit, &cp_info);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = soc_mem_read(
        unit,
        IQM_CPDMSm,
        MEM_BLOCK_ANY,
        entry_offset,
        &data
      );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

  if(cp_info.pkt_gen_mode == SOC_TMC_CNM_GEN_MODE_SAMPLING)
  {
    sampling_mode = 1;
  }
  else
  {
    sampling_mode = 0;
  }

  if(sampling_mode == 0)
  {
    soc_mem_field_get(unit, IQM_CPDMSm, &data, CP_ENABLEf, &tbl_data->cp_enable_1);
    soc_mem_field_get(unit, IQM_CPDMSm, &data, CP_CLASSf, &tbl_data->cp_profile_1);
    soc_mem_field_get(unit, IQM_CPDMSm, &data, CP_IDf, &tbl_data->cp_id);
  }
  else
  {
    /* In sampling mode each entry in the table contains data for 2 CP queues */
    /* Bit 0:     CP Enable 1   */
    /* Bits 1-3:  CP Profile 1  */
    /* Bit 4:     CP Enable 2   */
    /* Bits 5-7:  CP Profile 2  */
    soc_mem_field_get(unit, IQM_CPDMSm, &data, CP_ENABLEf, &tbl_data->cp_enable_1);
    soc_mem_field_get(unit, IQM_CPDMSm, &data, CP_CLASSf, &tbl_data->cp_profile_1);
    tbl_data->cp_enable_2 = SOC_SAND_GET_BIT(data, ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_EN_2_BIT);
    tbl_data->cp_profile_2 = SOC_SAND_GET_BITS_RANGE(data, ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_MSB, ARAD_IQM_CNM_DS_TBL_DATA_SAMPLING_PROFILE_LSB);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_iqm_cnm_ds_tbl_get_unsafe()", entry_offset, 0);
}

#define ARAD_PP_EGQ_DSP_PTR_MAP_TBL_ENTRY_SIZE 2

int
  arad_pp_egq_dsp_ptr_map_tbl_get_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     tm_port,
    SOC_SAND_OUT ARAD_PP_EGQ_DSP_PTR_MAP_TBL_DATA *tbl_data
  )
{
    uint32 data[ARAD_PP_EGQ_DSP_PTR_MAP_TBL_ENTRY_SIZE];
    int rv;
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_EGQ_DSP_PTR_MAP_TBL_ENTRY_SIZE);
    sal_memset(tbl_data, 0, sizeof(ARAD_PP_EGQ_DSP_PTR_MAP_TBL_DATA));

    rv = READ_EGQ_DSP_PTR_MAPm(unit, EGQ_BLOCK(unit, core_id), tm_port, data);
    SOCDNX_IF_ERR_EXIT(rv);

    tbl_data->out_tm_port = soc_mem_field32_get(unit, EGQ_DSP_PTR_MAPm, data, OUT_TM_PORTf);
    tbl_data->out_pp_port = soc_mem_field32_get(unit, EGQ_DSP_PTR_MAPm, data, OUT_PP_PORTf);
    tbl_data->dst_system_port = soc_mem_field32_get(unit, EGQ_DSP_PTR_MAPm, data, DST_SYSTEM_PORTf);

exit:
    SOCDNX_FUNC_RETURN;
}

int
  arad_pp_egq_dsp_ptr_map_tbl_set_unsafe(
    SOC_SAND_IN  int        unit,
    SOC_SAND_IN  int        core_id,
    SOC_SAND_IN  uint32     tm_port,
    SOC_SAND_IN  ARAD_PP_EGQ_DSP_PTR_MAP_TBL_DATA *tbl_data
  )
{
    uint32 data[ARAD_PP_EGQ_DSP_PTR_MAP_TBL_ENTRY_SIZE];
    uint32 tm_port_rep, pp_port_rep;
    int rv;
    SOCDNX_INIT_FUNC_DEFS;

    sal_memset(data, 0, sizeof(uint32)*ARAD_PP_EGQ_DSP_PTR_MAP_TBL_ENTRY_SIZE);

    soc_mem_field32_set(unit, EGQ_DSP_PTR_MAPm, data, OUT_TM_PORTf, tbl_data->out_tm_port);
    soc_mem_field32_set(unit, EGQ_DSP_PTR_MAPm, data, OUT_PP_PORTf, tbl_data->out_pp_port);
    soc_mem_field32_set(unit, EGQ_DSP_PTR_MAPm, data, DST_SYSTEM_PORTf, tbl_data->dst_system_port);

    rv = WRITE_EGQ_DSP_PTR_MAPm(unit, EGQ_BLOCK(unit, core_id), tm_port, data);
    SOCDNX_IF_ERR_EXIT(rv);

    if(SOC_IS_JERICHO(unit)) {
        rv = WRITE_EPNI_DSP_PTR_MAPm(unit, EPNI_BLOCK(unit, core_id), tm_port, data);
        SOCDNX_IF_ERR_EXIT(rv);
    }

    /* no need to set replication port for ERP*/
    /* coverity explanation: (0 =< core_id < 2) */
    /* coverity [overrun-local:FALSE] */
    /* coverity [negative_returs:FALSE] */
    if ( !((SOC_INFO(unit).erp_port[core_id] >= 0) && (tm_port == ARAD_ERP_PORT_ID)) )
    {
        if (SOC_DPP_CONFIG(unit)->tm.mc_mode & DPP_MC_EGR_17B_CUDS_127_PORTS_MODE &&
            tbl_data->out_tm_port != ARAD_MAX_FAP_PORT_ID /*setting out tm port as 255 marks it invalid - no need for replication*/ ) 
        {
            if(tm_port > ARAD_NOF_FAP_PORTS_EGR_MC_17BIT_CUD - 1) {
                SOCDNX_EXIT_WITH_ERR(SOC_E_INTERNAL, (_BSL_SOCDNX_MSG_STR( "Invalid tm port ID when using MC_EGR_17B_CUDS_127_PORTS_MODE")));
            }

            if(tbl_data->out_pp_port > ARAD_NOF_FAP_PORTS_EGR_MC_17BIT_CUD - 1) {
                SOCDNX_EXIT_WITH_ERR(SOC_E_INTERNAL, (_BSL_SOCDNX_MSG_STR( "Invalid pp port ID when using MC_EGR_17B_CUDS_127_PORTS_MODE")));
            }

            tm_port_rep = tm_port + ARAD_FAP_PORTS_OFFSET_EGR_MC_17BIT_CUD;
            pp_port_rep = tbl_data->out_pp_port + ARAD_FAP_PORTS_OFFSET_EGR_MC_17BIT_CUD;
            soc_mem_field32_set(unit, EGQ_DSP_PTR_MAPm, data, OUT_PP_PORTf, pp_port_rep);
            rv = WRITE_EGQ_DSP_PTR_MAPm(unit, EGQ_BLOCK(unit, core_id), tm_port_rep, data);
            SOCDNX_IF_ERR_EXIT(rv);

            if(SOC_IS_JERICHO(unit)) {
                rv = WRITE_EPNI_DSP_PTR_MAPm(unit, EPNI_BLOCK(unit, core_id), tm_port_rep, data);
                SOCDNX_IF_ERR_EXIT(rv);
            }
        }
    }
exit:
    SOCDNX_FUNC_RETURN;

}

/* } */
#undef _ERR_MSG_MODULE_NAME


int arad_tbl_mem_cache_enable_parity_tbl(int unit, soc_mem_t mem, void* en)
{
    int rc = SOC_E_NONE;

  SOC_MEM_ALIAS_TO_ORIG(unit,mem);
    /* If table has valid PARITY field - it should be cached
     * Although the table SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC__SHDS has no PARITY field,
     * but it should be cached */
    if (SOC_MEM_FIELD_VALID(unit, mem, PARITYf) || 
        (SOC_IS_ARADPLUS_AND_BELOW(unit) && (mem == SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm))) {
        rc = arad_tbl_mem_cache_mem_set(unit, mem, en);
    }

    LOG_INFO(BSL_LS_SOC_MEM, (BSL_META_U(unit, "parity memory %s cache\n"),SOC_MEM_NAME(unit, mem)));
    return rc;
}

int arad_tbl_mem_cache_enable_ecc_tbl(int unit, soc_mem_t mem, void* en)
{
    int rc = SOC_E_NONE;

  SOC_MEM_ALIAS_TO_ORIG(unit,mem);
    /* If table has valid ECC field - it should be cached */
    if (SOC_MEM_FIELD_VALID(unit, mem, ECCf))
        rc = arad_tbl_mem_cache_mem_set(unit, mem, en);

    LOG_INFO(BSL_LS_SOC_MEM, (BSL_META_U(unit, "ecc memory %s cache\n"),SOC_MEM_NAME(unit, mem)));
    return rc;
}

int arad_tbl_cache_enable_predefined_tbl(int unit)
{
    int i            = 0;
    int rc             = SOC_E_NONE;
    int enable         = 1;
    soc_mem_t mem     = INVALIDm;
    int size_of_predefined_array = sizeof(soc_arad_predefined_cached_mem_list)/sizeof(soc_mem_t) - 1 /* (-1) for the last element - NUM_SOC_MEM*/;

    for(i = 0; i < size_of_predefined_array; i++)
    {
        mem = soc_arad_predefined_cached_mem_list[i];

        if(!SOC_MEM_IS_VALID(unit, mem) || !soc_mem_is_cachable(unit, mem))
        {
            LOG_ERROR(BSL_LS_SOC_MEM, (BSL_META("unit %d cache failed for %d (%s) rv %d\n"), unit, mem, SOC_MEM_NAME(unit, mem), rc));
            return SOC_E_UNAVAIL;
        }
        rc = arad_tbl_mem_cache_mem_set(unit, mem, &enable);
    }
    return rc;
}

int soc_mem_is_in_soc_property(int unit, soc_mem_t mem, int en)
{
    /*Check whether given 'mem' is defined in the soc_property configuration.*/
    char mem_name[SOC_PROPERTY_NAME_MAX];
    char *mptr;

    if (en == TRUE)    /* mem_cache_enable_specific_ */
    {
        sal_strncpy(mem_name, spn_MEM_CACHE_ENABLE, SOC_PROPERTY_NAME_MAX);
        mptr = &mem_name[sal_strlen(mem_name)];
        sal_strncpy(mptr, "_specific_", (SOC_PROPERTY_NAME_MAX - sal_strlen(mem_name)));
    }
    else            /* mem_nocache_ */
        sal_strncpy(mem_name, "mem_nocache_",SOC_PROPERTY_NAME_MAX);

    mptr = &mem_name[sal_strlen(mem_name)];
    sal_strncpy(mptr, SOC_MEM_NAME(unit, mem), (SOC_PROPERTY_NAME_MAX - sal_strlen(mem_name)));


    if (soc_property_get(unit, mem_name, 0))
    {
        LOG_ERROR(BSL_LS_APPL_TESTS, (BSL_META("unit %d memory %d (%s), soc_prop %s\n"), unit, mem, SOC_MEM_NAME(unit, mem), mem_name));
        return TRUE;
    }
    return FALSE;
}

int arad_tbl_mem_cache_enable_specific_tbl(int unit, soc_mem_t mem, void* en)
{
  int rc        = SOC_E_NONE;
    int cache_enable = *(int *)en;

    SOC_MEM_ALIAS_TO_ORIG(unit,mem);
    if (soc_mem_is_in_soc_property(unit, mem, cache_enable))
    {
        if(!SOC_MEM_IS_VALID(unit, mem) || !soc_mem_is_cachable(unit, mem))
        {
            LOG_ERROR(BSL_LS_SOC_MEM, (BSL_META("unit %d cache %s failed for %d (%s) rv %d\n"), unit, cache_enable ?"enable":"disable", mem, SOC_MEM_NAME(unit, mem), rc));
            return SOC_E_UNAVAIL;
        }
        rc = arad_tbl_mem_cache_mem_set(unit, mem, en);
    }

    return rc;
}

int arad_tbl_mem_cache_mem_set(int unit, soc_mem_t mem, void* en)
{
    int rc         = SOC_E_NONE;
    int enable     = *(int *)en;
    int dis        = 0;

  SOC_MEM_ALIAS_TO_ORIG(unit,mem);
    if(!SOC_MEM_IS_VALID(unit, mem) || !soc_mem_is_cachable(unit, mem))
    {
        return SOC_E_NONE;
    }

    /* Skip the "mem_nocache_" memories in soc_property */
    if (enable == TRUE)
    {
        if (soc_mem_is_in_soc_property(unit, mem, dis))
            return SOC_E_NONE;
    }

    /* Turn on cache memory for all tables */
    if (soc_mem_is_valid(unit, mem) &&
        ((SOC_MEM_INFO(unit, mem).blocks | SOC_MEM_INFO(unit, mem).blocks_hi) != 0))
    {
       rc = soc_mem_cache_set(unit, mem, COPYNO_ALL, enable);
    }
    else
    {
        rc = SOC_E_NONE;
    }

    return rc;
}
#include <soc/dpp/SAND/Utils/sand_footer.h>
#endif /* of #if defined(BCM_88650_A0) */




