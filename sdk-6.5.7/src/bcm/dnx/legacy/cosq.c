/*
 * $Id: cosq.c,v 1.433 Broadcom SDK $
 *
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * Soc_dnx-B COSQ
 */
#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_COSQ

#include <shared/bsl.h>
#include <shared/swstate/access/sw_state_access.h>
#include <bcm/debug.h>
#include <bcm/error.h>
#include <bcm_int/common/debug.h>
#include <bcm/cosq.h>
#include <shared/gport.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm_int/dnx_dispatch.h>
#include <bcm_int/dnx/legacy/utils.h>
#include <bcm_int/dnx/legacy/error.h>
#include <bcm_int/dnx/legacy/gport_mgmt.h>
#include <bcm_int/dnx/legacy/utils.h>
#include <bcm_int/dnx/legacy/error.h>
#include <bcm_int/dnx/legacy/cosq.h>
#include <bcm_int/dnx/legacy/switch.h>
#include <bcm_int/control.h>
#include <bcm_int/dnx/legacy/alloc_mngr.h>
#include <bcm_int/dnx/legacy/alloc_mngr_cosq.h>
#include <bcm_int/dnx/legacy/fabric.h>
#include <bcm_int/dnx/legacy/alloc_mngr_utils.h>


#include <soc/dnxc/legacy/error.h>
#include <soc/dnxc/legacy/dnxc_wb.h>
#include <soc/dnx/legacy/dnx_config_defs.h>
#include <soc/dnx/legacy/dnx_config_imp_defs.h>
#include <soc/dnx/legacy/mbcm.h>
#include <soc/dnx/legacy/drv.h>
#include <soc/dnx/legacy/port_map.h>
#include <soc/dnx/legacy/TMC/tmc_api_ingress_packet_queuing.h>
#include <soc/dnx/legacy/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dnx/legacy/TMC/tmc_api_ingress_traffic_mgmt.h>
#include <soc/dnx/legacy/TMC/tmc_api_egr_queuing.h>
#include <soc/dnx/legacy/TMC/tmc_api_ofp_rates.h>
#include <soc/dnx/legacy/TMC/tmc_api_multicast_fabric.h>
#include <soc/dnx/legacy/TMC/tmc_api_flow_control.h>
#include <soc/dnx/legacy/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dnx/legacy/TMC/tmc_api_ports.h>
#include <soc/dnx/legacy/SAND/Utils/sand_framework.h>
#include <soc/dnx/legacy/debug.h>

#include <shared/swstate/access/sw_state_access.h>
#include <soc/dnx/legacy/ARAD/arad_api_ofp_rates.h>
#include <soc/dnx/legacy/ARAD/arad_scheduler_elements.h>
#include <soc/dnx/legacy/ARAD/arad_api_mgmt.h>
#include <soc/dnx/legacy/ARAD/arad_sw_db.h>
#include <soc/dnx/legacy/ARAD/arad_ingress_scheduler.h>
#include <soc/dnx/legacy/ARAD/arad_api_ingress_scheduler.h>
#include <soc/dnx/legacy/ARAD/arad_api_flow_control.h>
#include <soc/dnx/legacy/ARAD/arad_egr_queuing.h>
#include <soc/dnx/legacy/ARAD/arad_api_ingress_packet_queuing.h>
#include <soc/dnx/legacy/port_sw_db.h>
#include <soc/dnx/legacy/JER/jer_egr_queuing.h>


#ifdef CRASH_RECOVERY_SUPPORT
#include <soc/hwstate/hw_log.h>
#endif
/* 
 * local defines
 */

/*Used to handle delay tolarence MACRO to user q type translation*/
#define DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) (SOC_IS_JERICHO(unit) ? DNX_TMC_ITM_NOF_QT_STATIC : 0)
#define DNX_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) (JER2_ARAD_SW_DB_NOF_LEGAL_DYNAMIC_QUEUE_TYPES(unit))
/*Relevant only for Jericho*/
#define DNX_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type) \
            (hw_q_type = (user_q_type >= DNX_TMC_ITM_PREDEFIEND_OFFSET) ? (user_q_type - DNX_TMC_ITM_PREDEFIEND_OFFSET) : user_q_type)


#define DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR 250
#define DNX_COSQ_SLOW_LEVEL_VAL_MAX (DNX_TMC_ITM_CR_SLOW_LEVEL_VAL_MAX * DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR)

#define DNX_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX     (DNX_TMC_EGR_OFP_SCH_WFQ_WEIGHT_MAX)
#define DNX_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX     (1023)

#define DNX_COSQ_EGR_OFP_SCH_SP_LOW             (BCM_COSQ_SP1)
#define DNX_COSQ_EGR_OFP_SCH_SP_HIGH            (BCM_COSQ_SP0)

/* COSQ max num for PB */
#define DNX_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit)  (SOC_DNX_CONFIG(unit)->tm.max_egr_q_prio-1)
#define DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)  (cosq >= 0 && cosq <= DNX_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit))

/* Egress thresh limitations */
#define DNX_COSQ_PB_EGR_THRESH_MNT_NOF_BITS     (5)
#define DNX_COSQ_PB_EGR_THRESH_EXP_NOF_BITS     (4)
#define DNX_COSQ_PB_EGR_THRESH_NOF_BITS         (DNX_COSQ_PB_EGR_THRESH_MNT_NOF_BITS + DNX_COSQ_PB_EGR_THRESH_EXP_NOF_BITS)


/* COSQ max dp */
#define DNX_COSQ_EGR_DP_NUM_MAX                 (DNX_DEVICE_COSQ_EGR_NOF_DP-1)

/* FMQ limitations */
#define DNX_COSQ_PACKET_NOF_TC                  (8)
#define DNX_COSQ_FMQ_MAX_CLS_TC                 (DNX_TMC_MULT_FABRIC_CLS_MAX)
#define DNX_COSQ_FMQ_MAX_BURST_LIMIT            (63)
#define DNX_COSQ_FMQ_MAX_BE_WEIGHT              (15)
#define DNX_COSQ_FMQ_NOF_BE                     (DNX_TMC_MULT_FABRIC_NOF_BE_CLASSES)

#define DNX_COSQ_PB_EGR_OFP_SCH_MODE_HP_OVER_LP_FAIR (0)

/* Bandwidth limits */
#define DNX_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT (DNX_TMC_OFP_RATES_BURST_LIMIT_MAX)

#define DNX_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT (DNX_TMC_OFP_RATES_SCH_BURST_LIMIT_MAX)
#define DNX_COSQ_PB_E2E_ERP_RATE                 (10*1000*1000)
#define DNX_COSQ_PB_E2E_OLP_RATE                 (10*1000*1000)
#define DNX_COSQ_PB_E2E_OAMP_RATE                (10*1000*1000)

/* DRM factor bandwidth */
#define DNX_COSQ_DRM_FACTOR_BANDWIDTH            (72)


#define DNX_COSQ_TCG_NOF_PRIORITIES_SUPPORT      (DNX_TMC_TCG_NOF_PRIORITIES_SUPPORT)

/* Default profile for Ingress TC mapping */
#define DNX_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE (0)

/* Default profiles for multisets */
#define DNX_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE    (0)
#define DNX_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE (0)
#define DNX_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE    (0)
/*
  the following define moved to define tool
#define DNX_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL(unit)  (1048576) 
*/
#define DNX_COSQ_PB_ING_QUEUE_MAX_SRAM_PDS_DEFAULT_VAL  (32*1024-1) /* maximal allowed value --  from JER2_QAX */
#define DNX_COSQ_JER2_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL  (1048576)
#define DNX_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL  (2)
#define DNX_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE (0)
#define DNX_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE      (14)

#define DNX_COSQ_JER2_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE         (0)

/* Scheduler compensation final delta */
#define DNX_COSQ_ADJUST_SIZE_FINAL_DELTA_DEFAULT_PROFILE  (0)

/* Tail drop info definiations */

/* WRED info limitations */
#define DNX_COSQ_PB_WRED_WQ_MAX                     (31) /*SOC_DNX_ITM_WQ_MAX*/

/* Discard info limitation */
#define BCM_DNX_COSQ_DISCARD_FROP_PROB              (100)
#define BCM_DNX_COSQ_DISCARD_SYSTEM_RED_FROP_PROB   (0xffff)

/* 256 MB */
#define DNX_COSQ_PB_WRED_MIN_AVRG_TH_MAX            (0XFFFFFFF)
#define DNX_COSQ_PB_WRED_MAX_AVRG_TH_MAX            (0XFFFFFFF)

/* minumum FSM mutiplier size, under which the mecahnism is disabled */
#define DNX_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE (1 << 5)
/* maximum FSM mutiplier size, over which the multiplier will still be the maximum */
#define DNX_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE (1 << 12)

/* credit discount limitations */
#define DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL             (127)
#define DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL             (-128)

/* credit egress dicsount limitations */
#define DNX_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL         (-64)
#define DNX_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL         (64)

/* Cosq maximum connection class */
#define DNX_COSQ_VSQ_NOF_CONNECTION_CLASS           (32)
/* Cosq maximum VSQ pointer */
#define DNX_COSQ_VSQ_NOF_PP_POINTERS(unit)          (SOC_DNX_DEFS_GET(unit, nof_local_ports)) /*In Arad (256), in Jericho 512*/

#define DNX_COSQ_JER2_ARAD_MAX_QUEUE_PD_THRESH           (4095)
#define DNX_COSQ_JER2_ARAD_MAX_SP_PD_THRESH              (13000)
#define DNX_COSQ_MAX_SP_PD_THRESH                   (15000)

/* Soc_dnx-B comptaible mode. In case E2E gport is being retrieved always refer it as the first base_queue (cosq =0) */
#define DNX_COSQ_PB_DEFAULT_PORT_TC          (0)

/* Flow Control */
#define DNX_COSQ_FC_NOF_PRIORITIES           (8)

/* reserved connectors region */
#define DNX_DEVICE_COSQ_QUEUE_RESERVED_REGION_ID(unit) (SOC_IS_QUX(unit) ? 96 : (SOC_IS_QAX(unit) ? 64 : 0))


#define DNX_SAND_TRUE  1
#define DNX_SAND_FALSE 0
/* Set all HR modes as request depend on Port-TC */
#define DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,mode) \
{ \
    if (SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) { \
        int tc; \
        for (tc = 0; tc < DNX_TMC_NOF_TRAFFIC_CLASSES; tc++) \
        { \
          port_info.hr_modes[tc] = mode; \
        }\
    } else { \
        port_info.hr_mode = mode; \
    } \
}

/* DROP Hyst threshold set */
#define DNX_COSQ_THRESHOLD_HYST_SET(unit,hyst,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        hyst.set = value; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        hyst.clear = value; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* DROP Hyst threshold get */
#define DNX_COSQ_THRESHOLD_HYST_GET(unit,value,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        value = hyst.set; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        value = hyst.clear; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold set */
#define DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,hyst,cosq,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.set = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.set = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.clear = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.clear = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold get */
#define DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,value,cosq,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.set; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.set; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.clear; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.clear; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}

/* Add Addmistion tests to argument */
#define DNX_COSQ_ADMISSION_TEST_ADD(arg,admission_tests) \
{ \
    arg |= (admission_tests.ctgry_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CT:0; \
    arg |= (admission_tests.ctgry_trffc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTTC:0; \
    arg |= (admission_tests.ctgry2_3_cnctn_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTCC:0; \
    arg |= (admission_tests.sttstcs_tag_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_ST:0; \
    arg |= (admission_tests.llfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_LLFC:0; \
    arg |= (admission_tests.pfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_PFC:0; \
}

/* Offsets for VSQ group IDS CBFC,LLFC*/
#define BCM_DNX_VSQ_ID_CBFC8_DNX(soc_pb_internal_id,traffic_class) \
          (100 + ((soc_pb_internal_id / 8) << 3) + traffic_class)

#define BCM_DNX_VSQ_ID_LLFC_DNX(soc_pb_internal_id) \
          (100 + ((soc_pb_internal_id) << 1))

#define BCM_DNX_VSQ_ID_CBFC_JER2_ARAD(jer2_arad_internal_id,traffic_class) \
          (388 + ((jer2_arad_internal_id * DNX_TMC_NOF_TRAFFIC_CLASSES) + traffic_class))

#define BCM_DNX_VSQ_ID_LLFC_JER2_ARAD(jer2_arad_internal_id) \
          (356 + (jer2_arad_internal_id))

#define BCM_DNX_COSQ_PORT_ID_TO_INTERFACE_ID(port_id) \
          (port_id - BCM_DNX_PORT_INTERFACE_START)


#define DNX_COSQ_COUNTERS_MAX_STATS               (20)
#define DNX_COSQ_COUNTERS_MAX_SETS                (DNX_TMC_NOF_TRAFFIC_CLASSES * DNX_TMC_NOF_DROP_PRECEDENCE * SOC_DNX_DEFS_MAX(NOF_CORES) * 2 /*System-multicast*/)
 

/* a drop precedence value indicating to some APIs to use ECN configuration instead of a drop precedence */
#define BCM_DNX_ECN_DP DNX_TMC_NOF_DROP_PRECEDENCE

#define BCM_DNX_COSQ_FC_CAL_ID_NUM 8



extern int bcm_dnx_port_speed_get(int unit, bcm_port_t port, int *speed);
extern int bcm_dnx_port_internal_get(int unit, uint32 flags, int internal_ports_max, bcm_gport_t *internal_gport, int *internal_ports_count);
extern int bcm_dnx_port_control_get(int unit, bcm_port_t port, bcm_port_control_t type, int *value);
extern int bcm_dnx_port_control_set(int unit, bcm_port_t port, bcm_port_control_t type, int value);
extern int bcm_dnx_stk_my_modid_get(int,int *);
extern int bcm_dnx_stk_sysport_gport_get(int,bcm_gport_t,bcm_gport_t *);
extern int bcm_dnx_stk_gport_sysport_get(int,bcm_gport_t,bcm_gport_t *);

/* 
 * Data structures
 */
typedef enum
{
    /* 
     * sch_drop_words_consumed
     */
    BCM_DNX_COSQ_THRESH_SCH_DROP_WORDS = 0,
    /* 
     * unsch_drop_words_consumed
     */
    BCM_DNX_COSQ_THRESH_UNSCH_DROP_WORDS,
    /* 
     * sch_drop_pkts_consumed
     */
    BCM_DNX_COSQ_THRESH_SCH_DROP_PKTS,
    /* 
     * unsch_drop_pkts_consumed
     */
    BCM_DNX_COSQ_THRESH_UNSCH_DROP_PKTS,
    /* 
     * sch_fc_words_consumed
     */
    BCM_DNX_COSQ_THRESH_SCH_FC_WORDS

} bcm_dnx_cosq_thresh_field_t;

/* 
 * Profile type for ingress queue
 */
typedef enum
{
    /* 
     * Rate class profile
     */
    BCM_DNX_COSQ_RATE_CLS = 0,
    /* 
     * Discount class profile
     */
    BCM_DNX_COSQ_DISCOUNT_CLS = 1,
    /* 
     * VSQ connection class
     */
    BCM_DNX_COSQ_VSQ_CC = 2,
    /* 
     * VSQ traffic class
     */
    BCM_DNX_COSQ_VSQ_TC = 3,
    /* 
     * Queue signature
     */
    BCM_DNX_COSQ_QUEUE_SIGNATURE = 4,
    /* 
     * Last entry 
     */
    BCM_DNX_COSQ_NOF_CLSSES

} bcm_dnx_cosq_queue_profile_type_t;


typedef enum
{
  /*
   *  
   */
  _BCM_DNX_PFC_BITMAP_PORT = 0,
  /*
   *  
   */
  _BCM_DNX_PFC_BITMAP_INTF_TC = 1,
  /*
   *  
   */
  _BCM_DNX_PFC_BITMAP_PORT_TC = 2,
  /*
   *  
   */
  _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_UP = 3,
  /*
   *  
   */
  _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_DOWN = 4,
  /*
   *  Number of types in 
   */
  _BCM_DNX_PFC_BITMAP_NOF_TYPE = 5
  
}_bcm_dnx_pfc_bitmap_type;

/* Must match order in bcm_dnx_cosq_hdlist_type_t */
static char * _dnx_list_hd_type_str[] = 
{
    "voq group state",
    "connector group state",
    "scheduler state",
    "flow state",
    "not valid"
};

/*Used to verifying validity of rate class input for queue creating*/
typedef struct bcm_dnx_cosq_queue_attributes_verify_s {
    int rate_class_nof_additions[DNX_DEVICE_COSQ_MAX_COS];
    int delay_tolerance_nof_additions[DNX_DEVICE_COSQ_MAX_COS];
    bcm_cosq_queue_attributes_t queue_attributes[DNX_DEVICE_COSQ_MAX_COS];
    int nof_ocb_only_queues_per_rate_class[DNX_DEVICE_COSQ_MAX_COS];
    int nof_dram_mixed_queues_per_rate_class[DNX_DEVICE_COSQ_MAX_COS];
    int nof_delay_tolerance;
    int nof_rate_class;
    int32 reservation_change[DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int32 ocb_reservation_change;
} bcm_dnx_cosq_queue_attributes_verify_t;

typedef int (*num_elements_setter_cb)(int unit, int core, int num_elements);
typedef int (*type_setter_cb)(int unit, int core, bcm_dnx_cosq_hdlist_type_t type);
typedef int (*buff_allocater_cb)(int unit, int core, int nof_instances_to_alloc);

/*
 * local functions
 */
static int
_bcm_dnx_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);

static int
_bcm_dnx_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);


static int
_bcm_dnx_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);

static int
_bcm_dnx_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
static int
_bcm_dnx_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
static int
_bcm_dnx_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

static int
_bcm_dnx_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

static int
_bcm_dnx_cosq_gport_egress_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

static int
_bcm_dnx_cosq_gport_egress_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

static int
_bcm_dnx_cosq_gport_egress_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

static int
_bcm_dnx_cosq_gport_e2e_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

static int
_bcm_dnx_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

static int
_bcm_dnx_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

static int
_bcm_dnx_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
static int
_bcm_dnx_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
static int
_bcm_dnx_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);
static int
_bcm_dnx_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);
static int
_bcm_dnx_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

static int
_bcm_dnx_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags);

static int
_bcm_dnx_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

static int
 _bcm_dnx_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags);
static int
 _bcm_dnx_cosq_gport_e2e_port_bandwidth_get(int unit,
                          bcm_gport_t gport,
                          bcm_cos_queue_t cosq,
                          uint32 *kbits_sec_min,
                          uint32 *kbits_sec_max,
                          uint32 *flags);

static int
 _bcm_dnx_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags);
static int
 _bcm_dnx_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
static int
_bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags);
static int
_bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags);
static int
_bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags);
static int
_bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags);
static int
_bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

static int
_bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
static int
_bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

static int
_bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
static int
_bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

static int
_bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
static int
_bcm_dnx_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

static int
_bcm_dnx_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
static int
_bcm_dnx_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
static int
_bcm_dnx_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
static int
_bcm_dnx_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
static int
_bcm_dnx_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
static int 
_bcm_dnx_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq);
static int
_bcm_dnx_egress_cosq_validate(int unit, 
                                int cosq);

static int
_bcm_dnx_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority);
static int
_bcm_dnx_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_egress_thresh_profile_set(int unit,
                                          int port,
                                          int profile);
static int
_bcm_dnx_cosq_egress_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_profile);
static int
_bcm_jer2_arad_cosq_egress_thresh_profile_data_set(int unit,
                                              int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_profile);
static int
_bcm_dnx_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
static int
_bcm_dnx_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                                        int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
static int
_bcm_dnx_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
static int
_bcm_dnx_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
static int
_bcm_dnx_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_cls);
static int
_bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_all_fc_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_all_fc_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_interface_egress_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_interface_egress_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

static int
_bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                            bcm_gport_t gport,
                                                            bcm_cos_queue_t cosq,
                                                            bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dnx_cosq_egress_queue_mapping_info_t* mapping_info);
static int
_bcm_dnx_cosq_gport_egress_queue_map_get(int unit,
                                           bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset);
static int
_bcm_dnx_cosq_gport_egress_queue_map_set(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t offset);

static int
_bcm_dnx_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
static int
_bcm_dnx_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
static int
_bcm_dnx_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
static int
_bcm_dnx_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
static int
_bcm_dnx_cosq_fmq_mapping_set(int unit, 
                                     bcm_port_t port,
                                     bcm_cos_t priority, 
                                     bcm_cos_queue_t cosq);
static int
_bcm_dnx_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq);
static int
_bcm_dnx_cosq_control_flow_get(int unit,
                                  bcm_gport_t port,
                                  bcm_cos_queue_t cosq,
                                  bcm_cosq_control_t type,
                                  int *arg);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

static int
_bcm_dnx_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);
static int
_bcm_dnx_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);

static int
_bcm_dnx_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
static int
_bcm_dnx_cosq_control_egress_port_tcg_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
static int
_bcm_dnx_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
static int
_bcm_dnx_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
static int
_bcm_dnx_cosq_control_egress_port_tcg_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
static int
_bcm_dnx_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
static int
_bcm_dnx_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
static int
_bcm_dnx_cosq_control_flow_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
static int
_bcm_dnx_cosq_control_congestion_port_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg);
static int
_bcm_dnx_cosq_control_congestion_port_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg);
static int
_bcm_dnx_cosq_control_profile_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg);
static int
_bcm_dnx_cosq_control_profile_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);
static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);
static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);

static int
_bcm_dnx_cosq_ingress_port_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int arg);

static int
_bcm_dnx_cosq_ingress_port_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int *arg);

static int
_bcm_dnx_cosq_control_device_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);

static int
_bcm_dnx_cosq_control_e2e_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
static int
_bcm_dnx_cosq_control_egress_port_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
static int
_bcm_dnx_cosq_control_egress_port_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
static int
_bcm_dnx_cosq_control_egress_interface_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
static int
_bcm_dnx_cosq_control_egress_interface_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
static int
_bcm_dnx_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);


static int
_bcm_dnx_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
static int
_bcm_dnx_cosq_control_device_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
static int
_bcm_dnx_cosq_control_system_port_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
static int
_bcm_dnx_cosq_control_system_port_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg);
static int
_bcm_dnx_cosq_control_egress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
static int
_bcm_dnx_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg);
static int
_bcm_dnx_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
static int
_bcm_dnx_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg);
static int
_bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               int core,
                                                               uint8 is_ocb_only,
                                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 reservation_change[][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES]);
static int
_bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core,
                                                        int qid,
                                                        int rate_class);
static int
_bcm_dnx_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dnx_cosq_queue_profile_type_t profile_type,
                                      int profile);
static int
_bcm_dnx_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dnx_cosq_queue_profile_type_t profile_type,
                                      int* profile);
static int
_bcm_dnx_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info);
static int
_bcm_dnx_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *exact_rate_class_info);

static int
_bcm_dnx_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dnx_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info);

static int
_bcm_dnx_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha);
static int
_bcm_dnx_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class);
static int
_bcm_dnx_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int*        set_alpha);
static int
_bcm_dnx_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size);

static int
_bcm_dnx_cosq_gport_rate_class_color_size_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_color_t color,
                                                    uint32 flags,
                                                    bcm_cosq_gport_size_t *gport_size);
static int
_bcm_dnx_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
static int
_bcm_dnx_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);

static int
_bcm_dnx_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class);
static int
_bcm_dnx_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_rate_class_discard_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_rate_class_discard_get(int unit, 
                                             bcm_gport_t gport, 
                                             bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_voq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_voq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_sched_gport_add(int unit,
                                bcm_gport_t port,
                                int numq,
                                uint32 flags,
                                bcm_gport_t *gport);

static int
_bcm_dnx_cosq_connector_gport_add(int unit,
                                    int core,
                                    int src_modid,
                                    uint32 nof_remote_cores,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport);
static int
_bcm_dnx_cosq_mcast_gport_add(int unit,
                                bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                                bcm_gport_t *gport);
static int
_bcm_dnx_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport);

static int
_bcm_dnx_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags);

static int
_bcm_dnx_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags);

static int
_bcm_dnx_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags);

static int
_bcm_dnx_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

static int
_bcm_dnx_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

static int
_bcm_dnx_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    DNX_TMC_ITM_QT_NDX *user_q_type);
static int
_bcm_dnx_cosq_user_q_type_to_delay_tolerance(
    int unit,
    DNX_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level);

int static
_bcm_dnx_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);

static int
_bcm_dnx_cosq_sched_gport_delete(int unit, bcm_gport_t gport);

static int
_bcm_dnx_cosq_connector_gport_delete(int unit, bcm_gport_t gport);

static int
_bcm_dnx_cosq_mcast_gport_delete(int unit, bcm_gport_t gport);

static int
_bcm_dnx_cosq_ucast_gport_delete(int unit, bcm_gport_t gport);

static int
_bcm_dnx_cosq_fap_port_get(int unit,
                            bcm_gport_t gport,
                            uint32 *p_fap_port,
                            int *core,
                            int *is_interface);
static int
_bcm_dnx_cosq_vsq_fc_info_get(int unit, bcm_gport_t vsq_port, DNX_TMC_FC_GEN_INBND_INFO *inbnd_info);
int
bcm_dnx_tm_port_get(int unit, int core, int p_fap_port, bcm_port_t* port);

int
bcm_dnx_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port);

static int
_bcm_dnx_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           );

static int
_bcm_dnx_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             );

int
bcm_dnx_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port);

static int
_bcm_dnx_cosq_sched_init(int unit);

static int
_bcm_dnx_cosq_sched_cl_verify_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode);

static int
_bcm_dnx_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid);

/* VSQ local functions  { */
static int 
_bcm_dnx_cosq_voq_discard_retrieve_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps);
static int
_bcm_dnx_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq);

/*Get a pointer for the VSQ rate class wred data*/
bcm_dnx_cosq_vsq_rate_class_wred_info_t* 
bcm_dnx_cosq_vsq_rate_class_wred_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls);

/*Get a pointer for the VSQ rate class tail-drop data*/
bcm_dnx_cosq_vsq_rate_class_taildrop_info_t* 
bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, int headroom, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls);

/*Get a pointer for the VSQ rate class fc data*/
bcm_dnx_cosq_vsq_rate_class_fc_info_t* 
bcm_dnx_cosq_vsq_rate_class_fc_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls);

static int
_bcm_dnx_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      DNX_TMC_ITM_VSQ_GROUP vsq_category_index,
                                      bcm_dnx_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dnx_cosq_vsq_rate_class_info_t *exact_rate_class_info);
static int
_bcm_dnx_cosq_vsq_rate_class_exchange_set(int unit,
                                            int core_id,
                                            DNX_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dnx_cosq_vsq_rate_class_info_t *data_rate_class);
static int 
_bcm_dnx_cosq_vsq_id_range_verify(int unit,
                                    int core_id,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match);

static int 
_bcm_dnx_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dnx_cosq_vsq_type_t *vsq_group_type);
static int 
_bcm_dnx_cosq_gport_vsq_rate_class_destroy(
   int unit, 
   int core_id,
   int vsq_index,
   bcm_dnx_cosq_vsq_type_t vsq_group_type,
   uint8 ocb_only);

static int
_bcm_dnx_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port);
static int 
_bcm_dnx_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dnx_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport);

static int 
_bcm_dnx_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info);
static int
_bcm_dnx_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
static int
_bcm_dnx_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
static int
_bcm_dnx_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
static int
_bcm_dnx_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
static int
_bcm_dnx_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
static int
_bcm_dnx_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
/* VSQ local functions  } */
static int _bcm_dnx_cosq_pfc_bitmap_get(int unit, 
                                          _bcm_dnx_pfc_bitmap_type pfc_bmp_type, 
                                          bcm_port_t port, 
                                          bcm_cos_queue_t cosq, 
                                          DNX_TMC_FC_PFC_GENERIC_BITMAP *generic_bm);
static int
_bcm_dnx_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);

static int
_bcm_dnx_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
static int
_bcm_dnx_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
static int
_bcm_dnx_cosq_generation_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);
static int
_bcm_dnx_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);

static int
_bcm_dnx_cosq_fc_init(int unit);

static int 
_bcm_dnx_cosq_default_thresholds_set(int unit, int core, int any_port_with_1_priority, int total_mc_reserved_pds_sp0, int total_mc_reserved_pds_sp1);


/*
 * Support Functions - Flow 
 */
int
_bcm_dnx_se_flow_id_get(int unit, int flow_id, DNX_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow);

static int
_bcm_dnx_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets);
static int
_bcm_dnx_cosq_mode_get(int unit, int core, DNX_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode);

static int
_bcm_dnx_cosq_credit_class_info_get(int unit, int core, DNX_TMC_SCH_SE_INFO *se_config, int mode, bcm_dnx_cosq_class_info_t *info);

static int
_bcm_dnx_cosq_sched_enhanced_mode_get(int unit, int core, DNX_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode);

static int
_bcm_dnx_cosq_cl_sched_weight_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dnx_cosq_class_info_t *info, int *weight);

static int
_bcm_dnx_cosq_credit_class_weight_validate(int unit, int weight, bcm_dnx_cosq_class_info_t *info, int *updated_type);

static int
_bcm_dnx_cosq_alloc_n_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int flags, bcm_dnx_cosq_gport_info_t **info);

static int
_bcm_dnx_cosq_bcm_cosq_to_tcg(int unit,int cosq,DNX_TMC_TCG_NDX *tcg);
static int
_bcm_dnx_cosq_port_tcg_validate(int unit, bcm_gport_t gport, DNX_TMC_TCG_NDX tcg);

static int
_bcm_dnx_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq);

static int
_bcm_dnx_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id);

static int
_bcm_dnx_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, int allow_core_all, bcm_gport_t *parent_port);

static int
_bcm_dnx_cosq_ingress_tc_mapping_set(int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t cosq);

static int 
_bcm_dnx_cosq_ingress_tc_mapping_hw_set(int unit, int core_id, int profile, int is_flow, DNX_TMC_ITM_TC_MAPPING *tc_mapping);

static int
_bcm_dnx_cosq_ingress_tc_mapping_get(int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t *cosq);

static int 
_bcm_dnx_cosq_stk_sysport_set(int unit, int core, int sysport, int *stk_exist);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

int
_bcm_jer2_arad_cosq_control_congestion_queue_range_set(int unit, bcm_cosq_control_t type, int arg);

int
_bcm_jer2_arad_cosq_control_congestion_queue_range_get(int unit, bcm_cosq_control_t type, int *arg);


static int 
_bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int priority, int generic_bm_id, DNX_TMC_FC_PFC_GENERIC_BITMAP *bitmap);


int
_bcm_jer2_arad_cosq_update_reserved_pd_threshold_all_sps(int unit);

static int
_bcm_dnx_cosq_port2se_id(int unit, int core, int fap_port, bcm_cos_t priority, DNX_TMC_SCH_SE_ID *se_id);

static int
_bcm_dnx_cosq_se_id2port(int unit, int core, DNX_TMC_SCH_SE_ID se_id, int *fap_port, bcm_cos_t *priority);

static int
_bcm_dnx_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);

static int
_bcm_dnx_cosq_pkt_size_compensation_profiles_crps_init(int unit);

static
int _bcm_dnx_cosq_pkt_size_compensation_profiles_stat_interface_init(int unit);

static int
_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_set(int unit,
                                                    bcm_cosq_pkt_size_adjust_info_t * adjust_info,
                                                    int delta);

static int
_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_get(int unit,
                                                    bcm_cosq_pkt_size_adjust_info_t * adjust_info,
                                                    int *delta);

/*
 * element (data structure) allocation
 */
/* static */ bcm_dnx_cosq_list_hd_t * _bcm_dnx_cosq_listhd_alloc(int unit);


/*
 * utility functions
 */

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
/*
 * Defines, Typedefs, ...
 * {
 */
/*
 * This is the 'leaf' (entry) of the data base for VIG
 * (_bcm_dnx_cosq_alloc_n_gport_validate_info_get())
 */
typedef struct bcm_dnx_cosq_vig_leaf_s {
      /*
       * This element is loaded by a non-zero value
       * to indicate loaded information is valid.
       */
    int                            valid ;
      /*
       * This element is loaded by a non-zero value to indicate that
       * flow (index/key of this entry) was a 'base_flow_id' in
       * _bcm_dnx_cosq_alloc_n_gport_validate_info_get().
       * Info corresponding to 'base_flow_id' is used, in the second stage,
       * to calculate the final flow id (which may be equal to
       * 'base_flow_id')
       */
    int                            is_base_flow ;
      /*
       * This element is loaded by a non-zero value to indicate that
       * flow (index/key of this entry) was a final (second stage) 'flow_id' in
       * _bcm_dnx_cosq_alloc_n_gport_validate_info_get().
       * See 'is_base_flow' above
       */
    int                            is_final_flow ;
      /*
       * flow_id corresonding to the gport
       */
    int                            base_flow_id ;
      /*
       * corresponding gport
       */
    int                            gport ;
      /*
       * Indicator on how 'flow_id' was extracted. To get a match, both 'flow_id'
       * and its source must be the same. See _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
       */
    int                            source_of_flow_id ;
    bcm_dnx_cosq_gport_info_t      gport_info ;
    DNX_TMC_SCH_FLOW               flow_config ;
    DNX_TMC_SCH_SE_INFO            se_config ;
} bcm_dnx_cosq_vig_leaf_t ;
/*
 * }
 */


/*
 * Local static
 * {
 */
/*
 * 'vig' stands for _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
 */
/*
 * This is a pointer to the 'root' of the VIG data base array, per unit. Memory
 * is allocated dynamically in bcm_dnx_vig_db_create().
 */
static struct bcm_dnx_cosq_vig_leaf_s *Vig_db[SOC_MAX_NUM_DEVICES] = {(struct bcm_dnx_cosq_vig_leaf_s *)0} ;
/*
 * }
 */
/*****************************************************
*NAME
* bcm_dnx_vig_db_create
*TYPE: PROC
*DATE: 08/APR/2015
*FUNCTION:
*  Allocate memory and initialize data base for storage
*  of data collected in
*  _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
*CALLING SEQUENCE:
*  bcm_dnx_vig_db_create(unit,vig_db_pp,sizeof_vig_element)
*INPUT:
*  DIRECT:
*    int unit -
*      Identifier of device for which memory element is looked up.
*    bcm_dnx_cosq_vig_leaf_t **vig_db_pp -
*      This procedure loads pointed memory by the pointer
*      to the large array of memory elements, each of size
*      'sizeof(bcm_dnx_cosq_vig_leaf_t)'. Altogether, there are
*      SOC_DNX_DEFS_GET(unit,nof_flows_per_pipe) *
*                       SOC_DNX_DEFS_GET(unit,nof_cores)
*      such memory elements per unit.
*  INDIRECT:
*    SOC_MAX_NUM_DEVICES -
*      Maximal number of supported devices.
*    NOF_FLOWS_PER_PIPE -
*      Maximal number of flows per one core
*    NOF_CORES -
*      Maximal number of supported cores per device.
*    bcm_dnx_cosq_vig_leaf_t -
*      Structure of each memory element
*OUTPUT:
*  DIRECT:
*    bcm_error_t -
*      Standard error. If not equal to BCM_E_NONE then
*      some error was encountered.
*  INDIRECT:
*    Allocated memory.
*REMARKS:
*  None
*SEE ALSO:
*  
*****************************************************/
static bcm_error_t bcm_dnx_vig_db_create(int unit, bcm_dnx_cosq_vig_leaf_t **vig_db_pp)
{
  unsigned long size, count, total_allocated ;
  bcm_dnx_cosq_vig_leaf_t *vig_leaf_p ;

  BCMDNX_INIT_FUNC_DEFS ;

  size =
    (SOC_DNX_DEFS_GET(unit,nof_flows_per_pipe) * SOC_DNX_DEFS_GET(unit,nof_cores)) ;
  total_allocated = size * (unsigned long)sizeof(bcm_dnx_cosq_vig_leaf_t) ;
  vig_leaf_p = (bcm_dnx_cosq_vig_leaf_t *)sal_alloc(total_allocated,"vig_db") ;
  if (vig_leaf_p == NULL)
  {
    _rv = BCM_E_MEMORY ;
    goto exit ;
  }
  *vig_db_pp = (void *)vig_leaf_p ;
  for (count = 0 ; count < size ; count++, vig_leaf_p++)
  {
    vig_leaf_p->valid = 0 ;
  }
exit:
  BCMDNX_FUNC_RETURN ;
}
/*****************************************************
*NAME
* bcm_dnx_vig_lookup
*TYPE: PROC
*DATE: 08/APR/2015
*FUNCTION:
*  Look up the data base (array pointed by vig_db) and see
*  if element characterised by input parameters is valid.
*  If it is, indicate by return value. Also return (indirectly)
*  the address of the corresponding element, valid or not.
*CALLING SEQUENCE:
*  bcm_dnx_vig_lookup(
*    vig_db, unit, core, flow_id, source_of_flow_id, vig_leaf_pp)
*INPUT:
*  DIRECT:
*    bcm_dnx_cosq_vig_leaf_t *vig_db -
*      Pointer to the large array of memory elements (data base),
*      each of size 'sizeof(bcm_dnx_cosq_vig_leaf_t)' allocated for
*      this unit.
*    int unit -
*      Identifier of device for which memory element is looked up.
*    int core -
*      Identifier of core for which memory element is looked up.
*    int flow_id -
*      Identifier of flow id for which memory element is looked up.
*    int source_of_flow_id -
*      Identifier of source_of_flow_id for which memory element
*      is looked up. See 'vig_source_of_flow_id_t'. See remarks.
*      If set to '-1' then this parameter is ignored (i.e., 'do not care').
*    bcm_dnx_cosq_vig_leaf_t **vig_leaf_pp -
*      This procedure loads pointed memory by pointer to element
*      corresponding to input parameters.
*  INDIRECT:
*    bcm_dnx_cosq_vig_leaf_t -
*      Structure of each memory section
*OUTPUT:
*  DIRECT:
*    int -
*      If non-zero then valid element was found.
*  INDIRECT:
*    See vig_leaf_p
*REMARKS:
*  If valid element is found but there is no match between
*  input 'source_of_flow_id' and the one recorded within
*  the element then it is marked as empty (invalid) and
*  would, consequently, be reloaded (if in
*  _bcm_dnx_cosq_alloc_n_gport_validate_info_get()).
*SEE ALSO:
*  
*****************************************************/
static int bcm_dnx_vig_lookup(
  bcm_dnx_cosq_vig_leaf_t *vig_db,
  int unit,
  int core,
  int flow_id,
  int source_of_flow_id,
  bcm_dnx_cosq_vig_leaf_t **vig_leaf_pp
  )
{
  int ret ;
  unsigned long offset ;
  bcm_dnx_cosq_vig_leaf_t *vig_leaf_p ;

  ret = 0 ;
  offset = (flow_id * SOC_DNX_DEFS_GET(unit,nof_cores)) + core ;
  vig_leaf_p = &(vig_db[offset]) ;
  *vig_leaf_pp = vig_leaf_p ;
  if (vig_leaf_p->valid)
  {
    if ((source_of_flow_id == vig_leaf_p->source_of_flow_id) || (source_of_flow_id == -1))
    {
      ret = 1 ;
    }
    else
    {
      /*
       * There is no match on 'source_of_flow_id'. Clear
       * element to be reloaded.
       */
      vig_leaf_p->valid = 0 ;
    }
  }
  return (ret) ;
}
/*****************************************************
*NAME
* bcm_dnx_vig_delete_this_flow
*TYPE: PROC
*DATE: 15/APR/2015
*FUNCTION:
*  Remove all instances of specified flow from data base
*  corresponding to specified unit and core.
*CALLING SEQUENCE:
*  bcm_dnx_vig_delete_this_flow(unit,core,vig_db,flow_id)
*INPUT:
*  DIRECT:
*    int unit -
*      Identifier of device for which flow_id is to be removed.
*    int core -
*      Identifier of core for which flow_id is to be removed.
*    bcm_dnx_cosq_vig_leaf_t *vig_db -
*      Pointer to the large array of memory elements (data base),
*      each of size 'sizeof(bcm_dnx_cosq_vig_leaf_t)' allocated for
*      this unit.
*    int flow_id -
*      Identifier of flow id for which memory element is looked up.
*  INDIRECT:
*    None
*OUTPUT:
*  DIRECT:
*    bcm_error_t -
*      Standard error. If not equal to BCM_E_NONE then
*      some error was encountered.
*  INDIRECT:
*    Allocated memory.
*REMARKS:
*  None
*SEE ALSO:
*  
*****************************************************/
static bcm_error_t bcm_dnx_vig_delete_this_flow(
  int unit, int core, bcm_dnx_cosq_vig_leaf_t *vig_db, int flow_id)
{
  BCMDNX_INIT_FUNC_DEFS ;

  if (vig_db) {
    /*
     * Data base has been set. Look for corresponding entry.
     */
    int entry_was_found ;
    int source_of_flow_id ;
    bcm_dnx_cosq_vig_leaf_t *vig_leaf_p ;
    /*
     * Indicate lookup with 'do not care on source_of_flow_id'.
     */
    source_of_flow_id = -1 ;
    do {
      entry_was_found =
          bcm_dnx_vig_lookup(
            Vig_db[unit], unit, core, flow_id, source_of_flow_id, &vig_leaf_p) ;
      if (entry_was_found) {
        /*
         * Matching entry has been found. Entry is pointed by 'vig_leaf_p'.
         * Remove entry from data base.
         */
        vig_leaf_p->valid = 0 ;
      } else {
        /*
         * No matching entry has been found. All entries corresponding to
         * this flow_id have been removed.
         */
        BCM_EXIT ;
      }
    } while (1) ;
  }
exit:
  BCMDNX_FUNC_RETURN ;
}
/*****************************************************
*NAME
* bcm_dnx_vig_display_whole_db
*TYPE: PROC
*DATE: 8/APR/2015
*FUNCTION:
*  Debug/monitor procedure for display of all valid entries
*  on data base.
*CALLING SEQUENCE:
*  bcm_dnx_vig_display_whole_db()
*INPUT:
*  DIRECT:
*    None
*  INDIRECT:
*    Vig_db[] -
*      Pointer to data base per unit
*OUTPUT:
*  DIRECT:
*    None
*  INDIRECT:
*    Printed data base contents.
*REMARKS:
*  Currently, this procedure prints the contents of the
*  whole data base.
*SEE ALSO:
*  bcm_dnx_vig_lookup(), bcm_dnx_vig_db_create()
*****************************************************/
void bcm_dnx_vig_display_whole_db(void)
{
  int unit_counter, num_units ;
  int entry_counter, num_entrys ;
  int num_flows, num_cores ;
  int flow_id, core_id ;
  int num_valid_entries ;
  bcm_dnx_cosq_vig_leaf_t *vig_db_p ;

  num_units = (int)(sizeof(Vig_db) / sizeof(Vig_db[0])) ;
  for (unit_counter = 0 ; unit_counter < num_units ; unit_counter++)
  {
    if (Vig_db[unit_counter])
    {
      num_flows = SOC_DNX_DEFS_GET(unit_counter,nof_flows_per_pipe) ;
      num_cores = SOC_DNX_DEFS_GET(unit_counter,nof_cores) ;
      num_entrys = num_flows * num_cores ;
      sal_printf(
        "%s():Data base for unit %d:\r\n"
        "============================================\r\n",
        __FUNCTION__,unit_counter) ;
      vig_db_p = Vig_db[unit_counter] ;
      num_valid_entries = 0 ;
      for (entry_counter = 0 ; entry_counter < num_entrys ; entry_counter++, vig_db_p++)
      {
        if (vig_db_p->valid)
        {
          flow_id = entry_counter / num_cores ;
          core_id = entry_counter - (flow_id * num_cores) ;
          sal_printf(
            "Flow %06d (0x%08lX) core %d gport %010d (0x%08lX) is_connector %d is_se %d\r\n",
            flow_id, (unsigned long)flow_id, core_id,
            vig_db_p->gport, (unsigned long)vig_db_p->gport,
            vig_db_p->gport_info.is_connector, vig_db_p->gport_info.is_se) ;
          num_valid_entries++ ;
        }
      }
      sal_printf("\r\n") ;
      sal_printf(
        "%s(): Total number of valid entries on unit %d: %d\r\n",__FUNCTION__,unit_counter,num_valid_entries) ;
    }
    else
    {
      sal_printf(
        "%s(): No data base established for unit %d\r\n",__FUNCTION__,unit_counter) ;
    }
  }
  return ;
}
/* } */
#else
/* { */
void bcm_dnx_vig_display_whole_db(void)
{
    sal_printf(
        "%s(): This procedure is empty when OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is zero\r\n",__FUNCTION__) ;
    return ;
}
/* } */
#endif
static int
bcm_dnx_cosq_nif_to_gport_get(int              unit,
                                soc_port_if_t    if_type,
                                uint32           protocol_offset,
                                bcm_gport_t      *gport)
{
    int rc = BCM_E_NONE;
    pbmp_t ports_bm;
    soc_port_if_t if_type_i;
    uint32 offset_i;
    int found = 0;
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    

    rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_bm);
    BCMDNX_IF_ERR_EXIT(rc);

    PBMP_ITER(ports_bm, port) {

        rc = dnx_port_sw_db_interface_type_get(unit, port, &if_type_i);
        BCMDNX_IF_ERR_EXIT(rc);

        if(if_type_i != if_type) {
            continue;
        }

        rc = dnx_port_sw_db_protocol_offset_get(unit, port, 0, &offset_i);
        BCMDNX_IF_ERR_EXIT(rc);

        if(offset_i != protocol_offset) {
            continue;
        }

        BCM_GPORT_LOCAL_SET(*gport, port);
        found = 1;

    }

    if(!found) {
        DNXC_EXIT_WITH_ERR(BCM_E_NOT_FOUND, (_BSL_SOC_MSG("Couldn't find port for interface(%d) offset(%d)"),if_type,protocol_offset));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Convert from BCM SP modes to dnx EGR OFP interface prio modes
 */
static int
_bcm_dnx_cosq_mode_sp_to_egr_ofp_interface_prio(int unit, int mode,
                                            DNX_TMC_EGR_OFP_INTERFACE_PRIO *nif_priority)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

      switch(mode) {
          case BCM_COSQ_SP0:
              *nif_priority = DNX_TMC_EGR_OFP_INTERFACE_PRIO_HIGH;
              break;
          case BCM_COSQ_SP1:
              *nif_priority = DNX_TMC_EGR_OFP_INTERFACE_PRIO_LOW;
              break;          
          default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid mode %d"), unit ,mode));
      }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert BCM VSQ TYPES to TMC VSQ TYPES
 */
static int
_bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(bcm_dnx_cosq_vsq_type_t vsq_type,
                                             DNX_TMC_ITM_VSQ_GROUP *dnx_tmcvsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(vsq_type) {
        case BCM_DNX_COSQ_VSQ_TYPE_CTGRY:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_CTGRY;
            break;
        case BCM_DNX_COSQ_VSQ_TYPE_CTCC:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS;
            break;
        case BCM_DNX_COSQ_VSQ_TYPE_CTTC:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS;
            break;
        case BCM_DNX_COSQ_VSQ_TYPE_PP:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_STTSTCS_TAG;
            break;
        case BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_SRC_PORT;
            break;
        case BCM_DNX_COSQ_VSQ_TYPE_PG:
            *dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_PG;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq type %d is not matched to tmc vsq group type\n"), vsq_type));  
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert TMC VSQ TYPES to BCM VSQ TYPES
 */
static int
_bcm_dnx_cosq_tmc_vsq_type_to_bcm_vsq_type(DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type,
                                             bcm_dnx_cosq_vsq_type_t *vsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(dnx_tmcvsq_type) {
        case DNX_TMC_ITM_VSQ_GROUP_CTGRY:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_CTGRY;
            break;
        case DNX_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_CTCC;
            break;
        case DNX_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_CTTC;
            break;
        case DNX_TMC_ITM_VSQ_GROUP_STTSTCS_TAG:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_PP;
            break;
        case DNX_TMC_ITM_VSQ_GROUP_LLFC:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_LLFC;
            break;
        case DNX_TMC_ITM_VSQ_GROUP_PFC:
            *vsq_type = BCM_DNX_COSQ_VSQ_TYPE_PFC;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq tmc type %d is not matched to bcm vsq group type\n"), dnx_tmcvsq_type));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Convert from BCM cosq to dnx EGR Q Prio
 */
static int
_bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(int unit,
                                      int cosq,
                                      DNX_TMC_EGR_Q_PRIO *prio)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *prio = DNX_TMC_EGR_Q_PRIO_0;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *prio = DNX_TMC_EGR_Q_PRIO_1;
            break;
        case 2:
            *prio = DNX_TMC_EGR_Q_PRIO_2;
            break;
        case 3:
            *prio = DNX_TMC_EGR_Q_PRIO_3;
            break;
        case 4:
            *prio = DNX_TMC_EGR_Q_PRIO_4;
            break;
        case 5:
            *prio = DNX_TMC_EGR_Q_PRIO_5;
            break;
        case 6:
            *prio = DNX_TMC_EGR_Q_PRIO_6;
            break;
        case 7:
            *prio = DNX_TMC_EGR_Q_PRIO_7;
            break;
        case -1:
            *prio = DNX_TMC_EGR_Q_PRIO_ALL;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d: invalid cosq %d"), unit, cosq));
    }
exit:
    BCMDNX_FUNC_RETURN;
}
                      
static int
_bcm_dnx_cosq_port2se_id(int unit, int core,
                           int fap_port, 
                           bcm_cos_t priority, 
                           DNX_TMC_SCH_SE_ID *se_id)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 dnx_sand_rc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        /* Priority must be default */
        if (priority != DNX_COSQ_PB_DEFAULT_PORT_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priortiy given is out of range, should be set to 0 or -1 %d"), unit, priority));
        }
        *se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_port2se_id,(fap_port)));     
    } else {      
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tc2se_id,(unit, core, fap_port, priority, se_id)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, dnx_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority, dnx_sand_rc, rc));
        }      
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_se_id2port(int unit, int core,
                           DNX_TMC_SCH_SE_ID se_id,
                           int *fap_port, 
                           bcm_cos_t *priority)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 dnx_sand_rc = 0, port_id = 0, tc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        *fap_port = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2port_id,(se_id)));     
        *priority = DNX_COSQ_PB_DEFAULT_PORT_TC;
    }  else {      
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_se2port_tc_id,(unit, core, se_id, &port_id, &tc)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting port, tc from HR scheduler element %d, dnx_sand error 0x%x, rc error 0x%x"), unit, se_id, dnx_sand_rc, rc));
        }      
        *fap_port = port_id;
        *priority = tc;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

static unsigned int
_bcm_cosq_bit_count_get(uint32 value);

int
bcm_dnx_cosq_internal_ports_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int internal_ports_max = DNX_COSQ_SCH_MAX_PORT_ID(unit);
    int internal_ports_count, internal_ports_count_sum;
    bcm_gport_t internal_gport[SOC_DNX_DEFS_MAX(NOF_CORES)];    
    uint32 dnx_sand_rc, tm_port;
    DNX_TMC_SCH_PORT_INFO port_info;
    uint32 internal_rates[6];
    bcm_gport_t internal_gport_sum[6];
    int internal_port_i;
    int core;
    soc_port_t port;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_SCH_PORT_INFO_clear(&port_info);
    /* Set default port information */
    port_info.enable = TRUE;    
    DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_DUAL_WFQ);
    if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
    }

    /*
     * Get OLP/OAMP/ERP ports, and fill interface + rate per type
    */
    internal_ports_count_sum = 0;

    rc = bcm_dnx_port_internal_get(unit, BCM_PORT_INTERNAL_OLP,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        BCM_ERR_EXIT_NO_MSG(rc);
    } 
    if (internal_ports_count) {
        for (internal_port_i = 0; internal_port_i < internal_ports_count; internal_port_i++) {
            internal_rates[internal_ports_count_sum] = DNX_COSQ_PB_E2E_OLP_RATE;
            internal_gport_sum[internal_ports_count_sum] = internal_gport[internal_port_i];
            ++internal_ports_count_sum;
        }
    }

    rc = bcm_dnx_port_internal_get(unit, BCM_PORT_INTERNAL_EGRESS_REPLICATION,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        BCM_ERR_EXIT_NO_MSG(rc);
    } 
    if (internal_ports_count) {
        for (internal_port_i = 0; internal_port_i < internal_ports_count; internal_port_i++) {
            internal_rates[internal_ports_count_sum] = DNX_COSQ_PB_E2E_ERP_RATE;
            internal_gport_sum[internal_ports_count_sum] = internal_gport[internal_port_i];
            ++internal_ports_count_sum;
        }
    }


    /* Configure OLP/OAMP/ERP if valid */
    for (internal_port_i = 0; internal_port_i < internal_ports_count_sum; internal_port_i++) {
        rc = _bcm_dnx_cosq_fap_port_get(unit, internal_gport_sum[internal_port_i], &tm_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get OFP OLP/OAMP port gport: 0x%x, error(0x%x)\n"), internal_port_i, rc));                   
            BCM_ERR_EXIT_NO_MSG(rc);
        }
                          
        if (tm_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), tm_port));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_device_if_weight_idx_set,(unit, port, 1)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), 
                                  unit, tm_port, dnx_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_if_shaper_rate_set, (unit, core, tm_port, internal_rates[internal_port_i])));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), 
                                  unit, tm_port, dnx_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
        
        port_info.max_expected_rate = internal_rates[internal_port_i]/1000;;
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, tm_port, &port_info)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, tm_port, dnx_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
    }
      
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    uint32 rate_class_index;
    bcm_dnx_cosq_ingress_rate_class_info_t rate_class_info;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED)
    {
        /*enable new mode*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.set(unit, JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED));

        /*set all rate classes to default sttings*/
        for (rate_class_index = 0; rate_class_index < DNX_TMC_ITM_NOF_RATE_CLASSES; rate_class_index++) 
        {
            rc = _bcm_dnx_cosq_voq_rate_class_default_set(unit, rate_class_index, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

    } else if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be simple: advanced mapping cnnot be used")));
    } /*if we allready enabled advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_queue_rate_cls_mapping_mode_simple_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    bcm_dnx_cosq_ingress_rate_class_info_t rate_class_info;
    int is_allocated, 
        rate_class,
        ref_count;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&rate_class_info, 0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
        /*enable new mode*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.set(unit, JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE));
        /*init alloc mngr*/
        for (rate_class = 0; rate_class <= DNX_TMC_ITM_RATE_CLASS_MAX; rate_class++) {
            BCMDNX_IF_ERR_EXIT(jer2_arad_sw_db_rate_class_ref_count_get(unit, BCM_CORE_ALL, 2, (uint32)rate_class, (uint32*)&ref_count));
            if (ref_count != 0) {
                /*Get HW configuration*/
                rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
                BCMDNX_IF_ERR_EXIT(rc);
                rc = _bcm_dnx_am_template_queue_rate_cls_allocate_group(unit,
                                                                        BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID,
                                                                        &rate_class_info,
                                                                        ref_count,
                                                                        &is_allocated,
                                                                        &rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                /* 
                 * rate class 0 is the default rate class, so we allocate a dummy entry so it will never be released when using exchange function 
                 * This extra allocation make sure the entr won't be released. 
                 */
                if (rate_class == 0) {
                    rc = _bcm_dnx_am_template_queue_rate_cls_allocate_group(unit,
                                                                            BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID,
                                                                            &rate_class_info,
                                                                            1,
                                                                            &is_allocated,
                                                                            &rate_class);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
        }
    } else if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be advanced: simple mapping cnnot be used")));
    } /*if we allready sime advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

#define BCM_DNX_FINAL_DELTA_VAL_MIN   -16
#define BCM_DNX_FINAL_DELTA_VAL_MAX    15

static int 
_bcm_dnx_cosq_ingress_scheduler_compensation_init(int unit)
{
    DNX_TMC_ITM_CR_DISCOUNT_INFO discount_info;
    int delta, profile, rc = BCM_E_NONE;
    DNX_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;
    uint32 dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Set Ingress discount class info (scheduler per queue compensation )*/   
    profile = DNX_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE;
    DNX_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_info); 
    if (DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) {
            discount_info.discount = 0; /* legacy mode */
    } else {
            discount_info.discount = DNX_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE; /* new mode */
    }
    /* state restored during warmboot */
    rc = _bcm_dnx_am_template_queue_discount_cls_init(unit,profile,&discount_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* legacy ingress compensation, always set */
    if (!SOC_IS_QAX(unit)) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_discount_set, (unit,profile,&discount_info)));
        DNX_SAND_IF_ERR_EXIT(dnx_sand_rc); 
    }

    /* configure new mode credit class compensation */
    if (DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) { /* new mechanism */
        adjust_type = DNX_TMC_ITM_PKT_SIZE_ADJUST_QUEUE;
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_credits_adjust_size_set ,(unit, SOC_CORE_ALL, profile, adjust_type, discount_info.discount)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Init scheduler compensation final delta mapping (final delta is only relevant for Jericho) */
    if (DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) && !SOC_IS_QAX(unit)) {
        int final_delta = 0;
        /* init final delta default profile */
        profile = DNX_COSQ_ADJUST_SIZE_FINAL_DELTA_DEFAULT_PROFILE;
        rc = _bcm_dnx_am_template_scheduler_adjust_size_final_delta_mapping_init(unit, profile, &final_delta);
        BCMDNX_IF_ERR_EXIT(rc);

        /* by default map all 'in range' deltas 1-1, 'out range' deltas map to 'edges' values, meaning: 
         * values -128...-17 are mapped to -16. 
         * values -16...15 are mapped to themselves (1-1 mapping).
         * values 16...127 are mapped to 15. 
         */
        for (delta = DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL; delta < DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL; delta++) {
            if (delta < BCM_DNX_FINAL_DELTA_VAL_MIN) {
                final_delta = BCM_DNX_FINAL_DELTA_VAL_MIN;
            } else if (delta > BCM_DNX_FINAL_DELTA_VAL_MAX) {
                final_delta = BCM_DNX_FINAL_DELTA_VAL_MAX;
            } else {
                final_delta = delta;
            }
            rc = bcm_dnx_cosq_pkt_size_adjust_delta_map_set(unit, delta, final_delta);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Ideally for code maintenance and readability code path could be the same across
 * coldboot and warmboot. This requires that that at the low level driver all
 * configuration (write accesses) be blocked. The low level driver should allow read
 * accesses (coreesponding write accesses e.g. reading indirect registers/memory).
 *
 * Since this is currently not implemented (i.e blocking all configuration changes)
 * specific coldboot/warmboot checks are added in the init phase.
 *
 * NOTE:
 *      mode of restoring state via replay of commands is not suppoted. Thus it is not
 *      mandatory for the low level driver to block writes during init phase.
 */
int
bcm_dnx_cosq_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int reserved_flow_id;
    int idx, idx1, discount_data = 0;
    uint32 profile, tm_port, flags;
    bcm_dnx_cosq_egress_thresh_key_info_t *thresh_info = NULL;
    bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t *uc_thresh_info = NULL;
    bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t *mc_thresh_info = NULL;
    bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info = NULL, *exact_rate_class_info = NULL;
    bcm_dnx_cosq_ingress_system_red_dp_pr_info_t *sys_red_dp_pr_info = NULL;
    bcm_dnx_cosq_vsq_rate_class_info_t *vsq_rate_class_info = NULL, *vsq_exact_rate_class_info = NULL;
    DNX_TMC_ITM_WRED_QT_DP_INFO wred_default_info;
    DNX_TMC_ITM_VSQ_TAIL_DROP_INFO vsq_max_size_default_info;
    DNX_TMC_ITM_VSQ_FC_INFO fc_default_info;
    DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO egr_discount_info;
    DNX_TMC_ITM_TC_MAPPING tc_mapping;
    DNX_TMC_SCH_PORT_INFO port_info;
    bcm_port_t port_i;
    uint32 dnx_sand_rc;
    int hr_fc_default_template, hr_fc_default_template_data, nof_remote_cores;
    bcm_gport_t gport;
    DNX_TMC_SCH_SE_ID          se_index;
    bcm_cosq_delay_tolerance_t delay_tolerance;
    uint8 src_modid = 0;
    int is_coldboot = TRUE;
    uint32 rci_i, link_rate=0, link_rate_tmp, links_num_i, fap_port, nof_priorities, priority_i;
    int speed, core;
    DNX_TMC_SCH_DEVICE_RATE_ENTRY dev_rate ;
    pbmp_t ports_map;
    uint32 ocb_only_flags = 0;
    int8 credit_watchdog_mode;
    uint32 nof_sch_active_links = SOC_DNX_DEFS_GET(unit, nof_sch_active_links);
    uint32 nof_fabric_links = SOC_DNX_DEFS_GET(unit, nof_fabric_links);
    int rsrc_type = DNX_TMC_INGRESS_THRESHOLD_INVALID;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
            is_coldboot = FALSE;
        }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Allocation */
    BCMDNX_ALLOC(thresh_info, sizeof(bcm_dnx_cosq_egress_thresh_key_info_t), "egress thresh key info handle memory");
    if (thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    BCMDNX_ALLOC(uc_thresh_info, sizeof(bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t), "egress intf uc thresh key info handle memory");
    if (uc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf uc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(mc_thresh_info, sizeof(bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t), "egress intf mc thresh key info handle memory");
    if (mc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf mc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(rate_class_info, sizeof(bcm_dnx_cosq_ingress_rate_class_info_t), "cosq ingress rate class info handle memory");
    if (rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(exact_rate_class_info, sizeof(bcm_dnx_cosq_ingress_rate_class_info_t), "cosq ingress rate class info exact handle memory");
    if (exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(sys_red_dp_pr_info, sizeof(bcm_dnx_cosq_ingress_system_red_dp_pr_info_t), "system RED drop prob info handle memory");
    if (sys_red_dp_pr_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress system RED drop prob info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_rate_class_info, sizeof(bcm_dnx_cosq_vsq_rate_class_info_t), "vsq rate class info handle memory");
    if (vsq_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_exact_rate_class_info, sizeof(bcm_dnx_cosq_vsq_rate_class_info_t), "vsq rate class info exact handle memory");
    if (vsq_exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    if (!SOC_WARM_BOOT(unit)) {
        if (sw_state_access[unit].dnx.bcm.cosq.alloc(unit) != _SHR_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to allocate warmboot cosq memory\n"), unit));
        }
    }

    sal_memset(thresh_info,0x0,sizeof(bcm_dnx_cosq_egress_thresh_key_info_t));
    sal_memset(uc_thresh_info,0x0,sizeof(bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t));
    sal_memset(mc_thresh_info,0x0,sizeof(bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t));
    sal_memset(rate_class_info,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(sys_red_dp_pr_info,0x0,sizeof(bcm_dnx_cosq_ingress_system_red_dp_pr_info_t));
    sal_memset(vsq_rate_class_info,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));
    sal_memset(vsq_exact_rate_class_info,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t)); 
    DNX_TMC_ITM_TC_MAPPING_clear(&tc_mapping);
    DNX_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&vsq_max_size_default_info);
    
    if (is_coldboot) {    
        /* A.M initliaztion */        
        SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
        {
            /* Thresh type: Derive infromation from dune init, and set into A.M. */
            profile = SOC_DNX_DEFS_GET(unit, cosq_egr_default_thresh_type);
            rc = _bcm_dnx_cosq_egress_thresh_entry_get(unit, core ,profile,thresh_info); 
            BCMDNX_IF_ERR_EXIT(rc);
        
            rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_map);
            SOC_PBMP_ITER(ports_map, idx) {
                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, idx, &flags));
                if (!(DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags))) {
                    rc = _bcm_dnx_cosq_egress_thresh_profile_set(unit,idx,profile);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
    
            rc = _bcm_dnx_cosq_egress_thresh_profile_data_set(unit,core,profile,thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);
            
            /* state restored during warmboot */
            rc = _bcm_dnx_am_template_cosq_egr_thresh_init(unit,core ,profile,thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);           
        }

        /* Ingress compensation init */
        rc = _bcm_dnx_cosq_ingress_scheduler_compensation_init(unit);
        BCMDNX_IF_ERR_EXIT(rc); 

        SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
        {
            /* Set Egress Interface Unicast Thresh class info */
            profile = DNX_COSQ_JER2_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_dnx_cosq_egress_fc_interface_uc_thresh_entry_get(unit, core, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dnx_am_template_cosq_egr_interface_unicast_thresh_init(unit, core ,profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dnx_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit, core, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            /* Set Egress Interface Multicast Thresh class info */
            profile = DNX_COSQ_JER2_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_dnx_cosq_egress_fc_interface_mc_thresh_entry_get(unit, profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dnx_am_template_cosq_egr_interface_multicast_thresh_init(unit, core ,profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dnx_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit, core , profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        /* Set Ingress rate class info, WRED already disabled by zeroing the structure */
        profile = DNX_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE;

        /* state restored during warmboot */
        rc = _bcm_dnx_cosq_voq_rate_class_default_set(unit,profile,exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* System RED */ 
        profile = DNX_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE;
        _bcm_dnx_cosq_sys_red_dp_pr_hw_set(unit, profile, sys_red_dp_pr_info);
        rc = _bcm_dnx_am_template_system_red_dp_pr_init(unit, profile, sys_red_dp_pr_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Set VSQ rate class info */
        profile = DNX_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE;    
        /*set default Tail Drop values to maximum alowed by hardware, assum that the length of IQM_VQPR_MA-E is identical*/
        DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_default_info);
        DNX_TMC_ITM_VSQ_FC_INFO_clear(&fc_default_info);
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_tail_drop_default_get,(unit, &vsq_max_size_default_info)));
        DNX_SAND_IF_ERR_EXIT(dnx_sand_rc);
        for (idx = 0 ; idx < DNX_TMC_NOF_NON_SRC_BASED_VSQ_GROUPS; idx++) {
            for (idx1 = 0 ; idx1 < DNX_DEVICE_COSQ_ING_NOF_DP; idx1++) {
                vsq_rate_class_info->queue[idx].taildrop.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->queue[idx].taildrop.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                    vsq_rate_class_info->queue[idx].taildrop.max_size_th[rsrc_type][idx1] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                }

                vsq_rate_class_info->queue[idx].wred.enable[idx1] = wred_default_info.wred_en;
                vsq_rate_class_info->queue[idx].wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
                vsq_rate_class_info->queue[idx].wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
                vsq_rate_class_info->queue[idx].wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
                vsq_rate_class_info->queue[idx].wred.max_probability[idx1] = wred_default_info.max_probability;
            }
            vsq_rate_class_info->queue[idx].fc.queue_size = fc_default_info.q_size_fc;
            vsq_rate_class_info->queue[idx].fc.bd_size = fc_default_info.bd_size_fc;
            for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                vsq_rate_class_info->queue[idx].fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
            }
        }
        for (idx = 0; idx < DNX_DEVICE_COSQ_VSQ_NOF_RSRC_POOLS(unit); idx++) {
            for (idx1 = 0 ; idx1 < DNX_DEVICE_COSQ_ING_NOF_DP; idx1++) {
                if (SOC_IS_QAX(unit)) {
                    for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        vsq_rate_class_info->port[idx].guaranteed_size[rsrc_type][idx1] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                        vsq_rate_class_info->port[idx].shared_size[rsrc_type][idx1] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                        vsq_rate_class_info->port[idx].headroom_size[rsrc_type] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    }
                } else {
                    vsq_rate_class_info->port[idx].shared.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                    vsq_rate_class_info->port[idx].shared.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                    vsq_rate_class_info->port[idx].headroom.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                    vsq_rate_class_info->port[idx].headroom.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                    vsq_rate_class_info->port[idx].min_threshold[idx1] = 0;
                }

                vsq_rate_class_info->port[idx].wred.enable[idx1] = wred_default_info.wred_en;
                vsq_rate_class_info->port[idx].wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
                vsq_rate_class_info->port[idx].wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
                vsq_rate_class_info->port[idx].wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
                vsq_rate_class_info->port[idx].wred.max_probability[idx1] = wred_default_info.max_probability;
            }
            vsq_rate_class_info->port[idx].fc.queue_size = fc_default_info.q_size_fc;
            vsq_rate_class_info->port[idx].fc.bd_size = fc_default_info.bd_size_fc;
            for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                vsq_rate_class_info->port[idx].fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
            }
        }
        for (idx1 = 0 ; idx1 < DNX_DEVICE_COSQ_ING_NOF_DP; idx1++) {
            if (SOC_IS_QAX(unit)) {
                for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                    vsq_rate_class_info->pg.guaranteed_size[rsrc_type][idx1] = 0;
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].max_threshold = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].min_threshold = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].alpha = 0;
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom_nominal = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom_extension = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                }
            } else {
                vsq_rate_class_info->pg.shared.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                vsq_rate_class_info->pg.shared.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->pg.headroom.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                vsq_rate_class_info->pg.headroom.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->pg.min_threshold[idx1] = 0;
            }

            vsq_rate_class_info->pg.wred.enable[idx1] = wred_default_info.wred_en;
            vsq_rate_class_info->pg.wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
            vsq_rate_class_info->pg.wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
            vsq_rate_class_info->pg.wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
            vsq_rate_class_info->pg.wred.max_probability[idx1] = wred_default_info.max_probability;
        }
        vsq_rate_class_info->pg.fc.queue_size = fc_default_info.q_size_fc;
        vsq_rate_class_info->pg.fc.bd_size = fc_default_info.bd_size_fc;
        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            vsq_rate_class_info->pg.fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
        }

        for (idx = 0 ; idx < DNX_DEVICE_COSQ_ING_NOF_DP; idx++) {
            vsq_rate_class_info->pg.queue_alpha_bds[idx] = vsq_max_size_default_info.alpha;
        }
        vsq_rate_class_info->pg.prm.pool_id = 0;
        vsq_rate_class_info->pg.prm.is_lossles = FALSE;
        vsq_rate_class_info->pg.prm.use_min_port = FALSE;
        vsq_rate_class_info->pg.prm.admit_profile = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.sign = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.exp = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.offset = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.floor = 0;
        /* state restored during warmboot */
        for (idx = 0 ; idx < DNX_DEVICE_COSQ_VSQ_NOF_CATEGORY_MAX; idx++) {
            rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, profile, idx, vsq_rate_class_info, vsq_exact_rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rc = _bcm_dnx_am_template_vsq_rate_cls_init(unit, profile, vsq_exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* start - Ingress UC/FLOW TC Mapping profile */
        profile = DNX_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE;

        for(idx = 0 ; idx < DNX_TMC_NOF_TRAFFIC_CLASSES; idx++) {
            /* Default: Map each incoming TC to itself */ 
            tc_mapping.new_tc[idx] = idx;
        }

        rc = _bcm_dnx_am_template_ingress_flow_tc_mapping_init(unit,profile,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);
        rc = _bcm_dnx_am_template_ingress_uc_tc_mapping_init(unit,profile,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_cosq_ingress_tc_mapping_hw_set(unit, BCM_CORE_ALL, profile, 0, &tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_cosq_ingress_tc_mapping_hw_set(unit, BCM_CORE_ALL, profile, 1, &tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);
        /* end - Ingress UC/FLOW TC Mapping profile */

        if (SOC_IS_JERICHO(unit)) {
            uint32 pg_tc_bitmap = 0; /*All TCs are mapped to offset 0, by defalt*/
            rc = bcm_dnx_am_pg_init(unit);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dnx_am_template_vsq_pg_tc_mapping_profile_init(unit, BCM_CORE_ALL, pg_tc_bitmap);
            BCMDNX_IF_ERR_EXIT(rc);
            if (!SOC_IS_QAX(unit)) {  
            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_set, (unit, BCM_CORE_ALL, 0, pg_tc_bitmap)));
            BCMDNX_IF_ERR_EXIT(rc);
            } 
        }
    }
    /* init egress compensation data */
    DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&egr_discount_info);  
    discount_data = DNX_COSQ_EG_DISCOUNT_DEFAULT_VALUE;
    egr_discount_info.mc_credit_discount = discount_data;
    egr_discount_info.uc_credit_discount = discount_data;
    /* First, Initialize all ports */
    BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
    if (!SOC_WARM_BOOT(unit)) {
        BCM_PBMP_ITER(ports_map, port_i) {
            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags)); 
            if (DNX_PORT_IS_STAT_INTERFACE(flags) || DNX_PORT_IS_ELK_INTERFACE(flags))
            {
                continue;
            }
            rc = dnx_port_sw_db_local_to_tm_port_get(unit,port_i, &tm_port, &core);
            BCMDNX_IF_ERR_EXIT(rc);
            /* state restored during warmboot */
            rc = _bcm_dnx_am_template_egress_port_discount_cls_init(unit,core,tm_port,&egr_discount_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (is_coldboot) {
        /* number of elements per block, set to total # voq groups for now */
        /* allocate in 1k blocks at later date.                            */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.num_elements.set(unit, 0,  DNX_DEVICE_DNX_VOQ_HD_SIZE(unit)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.type.set(unit, 0, dnx_cosq_hdlist_voq_group));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.alloc(unit, 0, DNX_DEVICE_DNX_VOQ_HD_SIZE(unit)));
    
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dnx_list_hd_type_str[dnx_cosq_hdlist_voq_group], DNX_DEVICE_DNX_VOQ_HD_SIZE(unit)));

        BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
            /*
             * number of elements per block, set to total # flows for now
             * allocate in 1k blocks at later date.
             */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.num_elements.set(unit, core, DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.type.set(unit, core, dnx_cosq_hdlist_flow));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.alloc(unit, core, DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dnx_list_hd_type_str[dnx_cosq_hdlist_flow], DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.num_elements.set(unit, core, DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.type.set(unit, core, dnx_cosq_hdlist_connector_group));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.alloc(unit, core, DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dnx_list_hd_type_str[dnx_cosq_hdlist_connector_group], DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)));

            /*
             * allocate SE data structures
             */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.num_elements.set(unit, core, SOC_DNX_CONFIG(unit)->tm.max_ses));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.type.set(unit, core, dnx_cosq_hdlist_se));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.alloc(unit, core, SOC_DNX_CONFIG(unit)->tm.max_ses));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dnx_list_hd_type_str[dnx_cosq_hdlist_se], SOC_DNX_CONFIG(unit)->tm.max_ses));
        }
    }
    /* initialize cosq module resource manager */
    rc = bcm_dnx_am_cosq_init(unit);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, resource manager init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_coldboot) {
        
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY        
        ocb_only_flags = SOC_DNX_CONFIG(unit)->jer2_arad->init.dram.nof_drams ? 0 : BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
#endif 
        /* set standard credit request profiles */
        BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        /* If credit watchdog configuration is not set, set or restore it from hardware */
        if (DNX_IS_CREDIT_WATCHDOG_UNINITIALIZED(unit, credit_watchdog_mode)) {
            DNX_TMC_ITM_CR_WD_INFO crwd_info;
            DNX_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
            crwd_info.top_queue = crwd_info.bottom_queue = JER2_ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, BCM_CORE_ALL,&crwd_info,&crwd_info)));
        }
        BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (is_coldboot) { /* In cold boot, configure the predefined credit request profiles */

            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_get(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));
            delay_tolerance.credit_request_hungry_multiplier = 2048; /* VERIFY */
            delay_tolerance.credit_request_satisfied_empty_queue_exceed_thresh = 1; /* VERIFY */
            /* The following two threshold will later also be set to the default by entering the credit watchdog mode. */
            delay_tolerance.credit_request_watchdog_status_msg_gen = DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode) ?
               0 : DNX_TMC_ITM_CREDIT_WATCHDOG_NORMAL_STATUS_MSG_THRESHOLD;

            delay_tolerance.credit_request_watchdog_delete_queue_thresh = DNX_TMC_ITM_CREDIT_WATCHDOG_NORMAL_DELETE_THRESHOLD;

            /* credit request profile (delay tolerance) for (any) 1Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 2 * 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_1G, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 10Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 10Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024 / 10;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 40Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 15 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 15 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 40Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -15 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -15 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -15 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 30 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 30 * 1024;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 100Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 100Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -100 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 90 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 90 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 200Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 76 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 76 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 200Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -76 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -76 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -76 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -114688; /* max absolute value supported */
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 122880; /* max supported value */
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 122880;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 76 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 122880; /* using backoff value, higher is not allowed */
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY, &delay_tolerance));

            if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                delay_tolerance.flags = BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY | ocb_only_flags;
                BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_15, &delay_tolerance));
            }
        }
    }
    if (is_coldboot) {
        BCM_DNX_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
            /* Set VSQ category mode to be none by default */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.vsq_category_mode.set(unit, core, bcmFabricVsqCatagoryModeNone));
        }
        rc = bcm_dnx_fabric_control_set(unit,bcmFabricVsqCategory,bcmFabricVsqCatagoryModeNone);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "unit %d, failed in vsq mode none settings, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    {
        BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {

            nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][DNX_DEVICE_COSQ_QUEUE_RESERVED_REGION_ID(unit)];
             if (is_coldboot) {
		            rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, nof_remote_cores, 0, FALSE, FALSE, FALSE, FALSE, 
		                                                    DNX_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS, DNX_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, &src_modid, &reserved_flow_id);
		            if (rc != BCM_E_NONE) {
		                LOG_ERROR(BSL_LS_BCM_COSQ,
		                          (BSL_META_U(unit,
		                                      "unit %d, failed to reserve connector resources, error 0x%x\n"), unit, rc));
		                BCMDNX_IF_ERR_EXIT(rc);
		            }
		            LOG_VERBOSE(BSL_LS_BCM_COSQ,
		                    (BSL_META_U(unit,
		                                "unit %d core %d, connector resources. reserved start region 0x%x\n"), unit, core, reserved_flow_id));
        		}
        }
        if (is_coldboot) {
            DNX_TMC_SCH_PORT_INFO_clear(&port_info);
            /* Set default port information */
            port_info.enable = TRUE;
            DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_DUAL_WFQ);
            if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
              port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
            }

            BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
            BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
            BCM_PBMP_ITER(ports_map, port_i) {
                DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
                if (!(DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags))) {
                    BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); /* Not necessary */
                    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                              "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }

                    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities));

                    /* allocate port HRs */
                    for (priority_i = 0; priority_i < nof_priorities; priority_i++) {

                        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
                        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                                (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, dnx_sand error 0x%x, rc error 0x%x"),
                                                                                                                   unit, fap_port, priority_i, dnx_sand_rc, rc));
                        }
                        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));
                    }


                    if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "Invalid fap port %d\n"), fap_port));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }

                    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, fap_port, &port_info)));
                    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, error in setting scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, fap_port, dnx_sand_rc, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }
        if (is_coldboot) {
            rc = bcm_dnx_cosq_internal_ports_init(unit);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in internal port initialization 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    
        /* update flow control template information */
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {   
            if (is_coldboot) {
                hr_fc_default_template = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3 - 1;
                hr_fc_default_template_data = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.hr_fc_default_template.set(unit, hr_fc_default_template));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.hr_fc_default_template_data.set(unit, hr_fc_default_template_data));
                
        
                LOG_VERBOSE(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Setting up FC Template %d, Value %d"), hr_fc_default_template, hr_fc_default_template_data));

                BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
                    /* state restored during warmboot */
                    rc = _bcm_dnx_am_template_cosq_port_hr_fc_init(unit, core, hr_fc_default_template, &hr_fc_default_template_data);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                  "unit %d, failed in update of flow control HR temlates, error 0x%x\n"), unit, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }

        SOC_DNX_ALLOW_WARMBOOT_WRITE(_bcm_dnx_cosq_sched_init(unit), rc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed in sched init, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
    
        if (is_coldboot) {
            /* Set default DRM (device rate memory) */
            DNX_TMC_SCH_DEVICE_RATE_ENTRY_clear(&dev_rate);
    
            /* Currently link_rate is triggered by maximal speed rate */
            link_rate = 0;


            PBMP_SFI_ITER(unit, port_i) {
                if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, sfi), port_i)) {
                    rc = bcm_dnx_port_speed_get(unit, port_i, &speed);
                    BCMDNX_IF_ERR_EXIT(rc);
    
                    link_rate_tmp = (speed * DNX_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
                    link_rate = (link_rate > link_rate_tmp) ? link_rate:link_rate_tmp;
                }
            }
            /*
             * Fill up the first eight entries in DRM tables. These (first 8) relate to 'local'
             * route and they get values corresponding to high bit rates.
             */
            for(rci_i = 0; rci_i < SOC_DNX_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
            {
              dev_rate.rci_level = rci_i;
              dev_rate.num_active_links = 0;
              dev_rate.rate = DNX_TMC_SCH_MAX_RATE_MBPS_JER2_ARAD(unit);
              /*
               *  0 links means local route
               */
              if (!SOC_IS_QAX(unit)) { /*for jer2_qax, SCH_SHARED_DEVICE_RATE_SHARED_DRM is not in use*/
                  dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_device_rate_entry_set,(unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
                  if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                      rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                          "unit %d, error in setting mbcm_dnx_sch_device_rate_entry_set rci_level %d, num_active_links %d, dnx_sand error 0x%x, error 0x%x\n"),
                          unit, dev_rate.rci_level, dev_rate.num_active_links, dnx_sand_rc, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                  }
              }
              /*
               * The following clause is for multi-core systems only (Currently only Jericho), and JER2_QAX...!
               */
              if (SOC_IS_JERICHO(unit)) {
                /*
                 * For multi core systems (and JER2_QAX...), load the SCH_DEVICE_RATE_MEMORY_DRM table which is specific per core
                 * (unlike SCH_SHARED_DEVICE_RATE_SHARED_DRM, which is shared by the two cores and is loaded
                 * in the clause above and is common to all systems (single-core and multi-core))
                 */
                BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
                  dnx_sand_rc =
                    (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_device_rate_entry_core_set,(unit, core, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate))) ;
                  if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                        "unit %d, error in setting mbcm_dnx_sch_device_rate_entry_core_set rci_level %d, num_active_links %d, dnx_sand error 0x%x, error 0x%x\n"),
                        unit, dev_rate.rci_level, dev_rate.num_active_links, dnx_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                  }
                }
              }
            }

            for(rci_i = 0; rci_i < SOC_DNX_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
            {
              for (links_num_i = 1; links_num_i <= nof_sch_active_links; links_num_i++)
              {

                dev_rate.rci_level = rci_i;
                dev_rate.num_active_links = links_num_i ;
                dev_rate.rate = (((links_num_i * link_rate) / (rci_i + 1))) * nof_fabric_links / nof_sch_active_links ; /* Translate fabric links to SCH links */
                /*
                 *  0 links means local route
                 *  RCI 0 - if the number of active links is small,
                 *  and the links are indeed in-use, the RCI will rise above 0.
                 *  Otherwise - we don't limit the scheduler rate.
                 */
                if(
                    (dev_rate.rate > DNX_TMC_SCH_MAX_RATE_MBPS_JER2_ARAD(unit)) ||
                    (dev_rate.rci_level == 0)
                  )
                {
                  dev_rate.rate = DNX_TMC_SCH_MAX_RATE_MBPS_JER2_ARAD(unit);
                }

                if (!SOC_IS_QAX(unit)) { /*for jer2_qax, SCH_SHARED_DEVICE_RATE_SHARED_DRM is not in use*/
                    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_device_rate_entry_set,(unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
                    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                              "unit %d, error in setting mbcm_dnx_sch_device_rate_entry_set rci_level %d, num_active_links %d, dnx_sand error 0x%x, error 0x%x\n"), unit, dev_rate.rci_level,
                                      dev_rate.num_active_links, dnx_sand_rc, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
                /*
                 * The following clause is for multi-core systems only (Currently only Jericho), and JER2_QAX...!
                 */
                if (SOC_IS_JERICHO(unit)) {
                  /*
                   * For multi core systems (and JER2_QAX...), load the SCH_DEVICE_RATE_MEMORY_DRM table which is specific per core
                   * (unlike SCH_SHARED_DEVICE_RATE_SHARED_DRM, which is shared by the two cores and is loaded
                   * in the clause above and is common to all systems (single-core and multi-core)
                   */
                  BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
                    dnx_sand_rc =
                      (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_device_rate_entry_core_set,(unit, core, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate))) ;
                    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                      rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                          "unit %d, error in setting mbcm_dnx_sch_device_rate_entry_core_set rci_level %d, num_active_links %d, dnx_sand error 0x%x, error 0x%x\n"),
                          unit, dev_rate.rci_level, dev_rate.num_active_links, dnx_sand_rc, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                    }
                  }
                }
              }
            }
        }
    }
      

    
    rc = _bcm_dnx_cosq_fc_init(unit);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed fc init, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if ((is_coldboot == TRUE) && SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit))
    {
        /* init ingress packet size compensation profiles feature for CRPS use */
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_cosq_pkt_size_compensation_profiles_crps_init(unit) );
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_cosq_pkt_size_compensation_profiles_stat_interface_init(unit) );
    }
exit:
  if (thresh_info != NULL) {
     BCM_FREE(thresh_info);
  }
  if (uc_thresh_info != NULL) {
     BCM_FREE(uc_thresh_info);
  }
  if (mc_thresh_info != NULL) {
     BCM_FREE(mc_thresh_info);
  }
  if (rate_class_info != NULL) {
     BCM_FREE(rate_class_info);
  }
  if (exact_rate_class_info != NULL) {
     BCM_FREE(exact_rate_class_info);
  }
  if (sys_red_dp_pr_info != NULL) {
     BCM_FREE(sys_red_dp_pr_info);
  }
  if (vsq_rate_class_info != NULL) {
     BCM_FREE(vsq_rate_class_info);
  }
  if (vsq_exact_rate_class_info != NULL) {
     BCM_FREE(vsq_exact_rate_class_info);
  }
  BCMDNX_FUNC_RETURN;
}

/*
*  Tear down local state and related
*/
int
bcm_dnx_cosq_detach(int unit)
{
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(result);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    {
      /*
       * If memory has already been allocated for data base then free it
       * at run time to increase free heap size.
       */
      if (Vig_db[unit]) {
        LOG_INFO(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
               "%s(): Vig memory has been allocated so free allocated memory.\r\n"),
                  __FUNCTION__) ) ;
        sal_free(Vig_db[unit]) ;
        Vig_db[unit] = NULL ;
      }
    }
/* } */
#endif
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the common status message time in the common status message time mode.
 * Need to set the scan time, if to send a message after 1/2 scans.
 * Need to update the delete times of all the progiles.
 */
static int
_bcm_jer2_arad_reconfigure_common_fsm_mode(int unit, int fsm_time_us)
{
    bcm_cosq_range_t watch_dog_range;
    int8 credit_watchdog_mode;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (!DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can set common status message time only in common status message mode")));
    }
    switch (fsm_time_us) {
      case 0:
      case JER2_ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS     / 1000: /*  125 */
      case 2 * JER2_ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  250 */
      case 4 * JER2_ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  500 */
      case 8 * JER2_ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /* 1000 */
      case JER2_ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS     / 1000: /* 2000 */
      case 2 * JER2_ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000: /* 4000 */
        break;
      default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG(
          "Invalid common status message time %d, must be one of 0, 125, 250, 500, 1000, 2000, 4000"),
          fsm_time_us));
    }
    
    /* do all the work */
    watch_dog_range.is_enabled = BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE;
    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_range_set(unit, BCM_CORE_ALL, BCM_DNX_COSQ_CREDIT_WATHDOG_USE_ENABLE, &watch_dog_range, fsm_time_us));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the common status message time in us of the common status message time mode.
 */
static int
_bcm_jer2_arad_common_fsm_mode_get_time(int unit, int *fsm_time_us)
{
    DNX_TMC_ITM_CR_WD_INFO crwd_info;
    uint32 exact_credit_watchdog_scan_time_nano;
    int8 credit_watchdog_mode;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (!DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can get common status message time only in common status message mode")));
    } else if (fsm_time_us == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("received null pointer")));
    }

    /* get the number of scans till a message is generated */
    DNX_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
    crwd_info.top_queue = crwd_info.bottom_queue = crwd_info.max_flow_msg_gen_rate_nano =
      crwd_info.min_scan_cycle_period_micro = JER2_ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, BCM_CORE_ALL, &crwd_info, &crwd_info)));

    BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    *fsm_time_us = (exact_credit_watchdog_scan_time_nano / 1000) * crwd_info.min_scan_cycle_period_micro;
    if (exact_credit_watchdog_scan_time_nano % 1000) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Can not get exact common status message time. It looks close to %d"), *fsm_time_us));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*Used to handle delay tolarence MACRO to user q type translation*/
static int
_bcm_dnx_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    DNX_TMC_ITM_QT_NDX *user_q_type){
    BCMDNX_INIT_FUNC_DEFS;
    if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) {
        *user_q_type = delay_tolerance_level - BCM_COSQ_DELAY_TOLERANCE_NORMAL;
        if ((delay_tolerance_level < BCM_COSQ_DELAY_TOLERANCE_02 || delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15)) {
            *user_q_type += DNX_TMC_ITM_PREDEFIEND_OFFSET;
        } else {
            *user_q_type += DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        }
    } else if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23) {
        *user_q_type = delay_tolerance_level + DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) - (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15)));
    } else if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) {
        *user_q_type = delay_tolerance_level + (DNX_TMC_ITM_PREDEFIEND_OFFSET - BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED);
    } else {
        *user_q_type = DNX_TMC_ITM_QT_NDX_INVALID;
    }
    BCMDNX_FUNC_RETURN;
}

/*Used to handle user q type translation to delay tolarence MACRO*/
static int
_bcm_dnx_cosq_user_q_type_to_delay_tolerance(
    int unit,
    DNX_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level){
    BCMDNX_INIT_FUNC_DEFS;
    if (user_q_type >= DNX_TMC_ITM_PREDEFIEND_OFFSET) {
        if (user_q_type == DNX_TMC_ITM_PREDEFIEND_OFFSET + BCM_COSQ_DELAY_TOLERANCE_15 - BCM_COSQ_DELAY_TOLERANCE_NORMAL) {
            *delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_15;
        } else {
            *delay_tolerance_level = user_q_type + (BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED - DNX_TMC_ITM_PREDEFIEND_OFFSET);
        }
    } else {
        if (user_q_type - DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < DNX_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) &&
            user_q_type - DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) >= DNX_TMC_ITM_QT_PUSH_Q_NDX) {
            *delay_tolerance_level = (user_q_type - DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit)) + (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15 + 1)));
        } else if (user_q_type - DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < DNX_TMC_ITM_QT_PUSH_Q_NDX){
            *delay_tolerance_level = user_q_type + BCM_COSQ_DELAY_TOLERANCE_NORMAL - DNX_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("User Q type is not legal")));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_delay_tolerance_level_get(int unit,
                                         int delay_tolerance_level,
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;    
    DNX_TMC_ITM_QT_NDX dt_level;
    DNX_TMC_ITM_CR_REQUEST_INFO cr_req_info;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Get the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_jer2_arad_common_fsm_mode_get_time(unit, &delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    /*We cannot configure push queue attributes other than OCB-only and Hight-priority (Jericho-only)*/
    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    DNX_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    if (cr_req_info.wd_th.cr_wd_dlt_q_th == DNX_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Could not get the user defined delay tolerance level (queue type) since it was not set")));
    }
    if (delay_tolerance_level != BCM_COSQ_DELAY_TOLERANCE_15) {
        delay_tolerance->credit_request_watchdog_status_msg_gen =
                         cr_req_info.wd_th.cr_wd_stts_msg_gen;
        delay_tolerance->credit_request_watchdog_delete_queue_thresh =
                         cr_req_info.wd_th.cr_wd_dlt_q_th;
        delay_tolerance->credit_request_hungry_off_to_slow_thresh =
                         cr_req_info.hungry_th.off_to_slow_th;
        delay_tolerance->credit_request_hungry_off_to_normal_thresh =
                         cr_req_info.hungry_th.off_to_normal_th;
        delay_tolerance->credit_request_hungry_slow_to_normal_thresh =
                         cr_req_info.hungry_th.slow_to_normal_th;
        delay_tolerance->credit_request_hungry_normal_to_slow_thresh =
                         cr_req_info.hungry_th.normal_to_slow_th;

        delay_tolerance->credit_request_hungry_multiplier =
                 cr_req_info.hungry_th.multiplier;

        delay_tolerance->credit_request_satisfied_backoff_enter_thresh =
                         cr_req_info.satisfied_th.backoff_th.backoff_enter_th;
        delay_tolerance->credit_request_satisfied_backoff_exit_thresh =
                         cr_req_info.satisfied_th.backoff_th.backoff_exit_th;
        delay_tolerance->credit_request_satisfied_backlog_enter_thresh =
                         cr_req_info.satisfied_th.backlog_th.backlog_enter_th;
        delay_tolerance->credit_request_satisfied_backlog_exit_thresh =
                         cr_req_info.satisfied_th.backlog_th.backlog_exit_th;
        delay_tolerance->credit_request_satisfied_backslow_enter_thresh = 
                        cr_req_info.satisfied_th.backslow_th.backslow_enter_th; 
        delay_tolerance->credit_request_satisfied_backslow_exit_thresh = 
            cr_req_info.satisfied_th.backslow_th.backslow_exit_th; 
        delay_tolerance->credit_request_satisfied_empty_queue_thresh =
                         cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th;
        delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh =
                         cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q;
        delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh =
                         cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q;
        delay_tolerance->flags = (SOC_IS_ARADPLUS(unit) && cr_req_info.is_remote_credit_value) ?
                         BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE : 0;
        if (cr_req_info.is_low_latency) {
            delay_tolerance->flags |= BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY;
        }
        if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            int slow_level;
            for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
                delay_tolerance->slow_level_thresh_down[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level] * DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR;
                delay_tolerance->slow_level_thresh_up[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level] * DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR;
            }
        }
    }
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        delay_tolerance->flags |= (cr_req_info.is_ocb_only) ? BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY : 0;
        delay_tolerance->flags |= (cr_req_info.is_high_priority) ? BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY : 0;
    }
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_delay_tolerance_level_set(int unit,
                                         int delay_tolerance_level, 
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    uint32 dnx_sand_rc;    
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_QT_NDX dt_level;
    DNX_TMC_ITM_CR_REQUEST_INFO cr_req_info, cr_req_exact_info;
    int8 credit_watchdog_mode;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         ( delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }
    /*We cannot configure push queue attributes other than OCB-only and Hight-priority (Jericho-only)*/
    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Set the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_jer2_arad_reconfigure_common_fsm_mode(unit, delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
        DNX_IS_CREDIT_WATCHDOG_FAST_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("delete queue thresholds (aging) are not supported in aggressive status message credit watchdog mode")));
    } else if (DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        if (delay_tolerance->credit_request_watchdog_status_msg_gen) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("status message generation thresholds are not supported per delay tolerance level in common status message credit watchdog mode\n"
                             "They are set for all the chip using BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG")));
        } else if (delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
                   (delay_tolerance->credit_request_watchdog_delete_queue_thresh > 7680 ||
                    delay_tolerance->credit_request_watchdog_delete_queue_thresh < 2)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("A delete queue (aging) threshold should be between 2ms and 7680ms, or 0 for no deletion")));
        } /* we permit 7.68s since with shortest scan (125us) the max scans till delete (15*2^12) give 7.68s */
    }
    if (delay_tolerance->flags) {
        uint32 unsupported_flags = delay_tolerance->flags & ~(BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE | BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY | BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY);
        if (unsupported_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("None supported flags 0x%x were specified"),
              (unsigned)unsupported_flags));
        } if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) && !SOC_IS_ARADPLUS(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE flag is not supported on this device")));
        }
    }

    DNX_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    DNX_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_exact_info);


    /* retrieve current information in case we do not set all of it 
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    */
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        cr_req_info.is_ocb_only = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY ? 1 : 0; 
        cr_req_info.is_high_priority = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY ? 1 : 0;
    }

    /*We cannot configure push queue attributes other than OCB-only and Hight-priority*/
    if (delay_tolerance_level != BCM_COSQ_DELAY_TOLERANCE_15) {
        if (delay_tolerance->credit_request_hungry_slow_to_normal_thresh < 
            delay_tolerance->credit_request_hungry_normal_to_slow_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: SlowToNormal (which is %d) must be equal or higher than NormalToSlow (which is %d), otherwise could result endless toggle between states.\n"),
                                 delay_tolerance->credit_request_hungry_slow_to_normal_thresh,
                      delay_tolerance->credit_request_hungry_normal_to_slow_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) must be equal or higher than BackOffExit (which is %d), otherwise could result endless toggle between Backoff states.\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backlog_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackLogEnter (which is %d) must be equal or higher than BackLogExit (which is %d), otherwise could result endless toggle between BackLog states.\n"),
                                 delay_tolerance->credit_request_satisfied_backlog_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_enter_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) should be equal or higher than BackLogEnter (which is %d)\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_enter_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh >
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (
              _BSL_BCM_MSG("EmptyQueueMaxBalance (which is %d) must be equal or lower than backOffExit (which is %d), otherwise could result queue stuck in Off state."),
              delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh,
              delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        /* Finish of non Petra code performing sanity tests on thresholds */
        cr_req_info.is_low_latency = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY ? TRUE : FALSE;
        if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            int slow_level;
            if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("flag BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE does not supported in Jericho")));
            }

           for (slow_level = 0; slow_level < DNX_TMC_ITM_CR_SLOW_LEVELS; slow_level++) {
               if (delay_tolerance->slow_level_thresh_up[slow_level] < 0 ||
                   delay_tolerance->slow_level_thresh_up[slow_level] > DNX_COSQ_SLOW_LEVEL_VAL_MAX) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d out of range %d. \nShould be 0-%d bytes"),
                                                    slow_level, slow_level + 1,
                                                    delay_tolerance->slow_level_thresh_up[slow_level], 
                                                    DNX_COSQ_SLOW_LEVEL_VAL_MAX));

               }
               if (delay_tolerance->slow_level_thresh_down[slow_level] < 0 ||
                   delay_tolerance->slow_level_thresh_down[slow_level] > DNX_COSQ_SLOW_LEVEL_VAL_MAX) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d out of range %d. \nShould be 0-%d bytes"),
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_down[slow_level], 
                                                    DNX_COSQ_SLOW_LEVEL_VAL_MAX));

               }
           }
           for (slow_level = 0; slow_level < DNX_TMC_ITM_CR_SLOW_LEVELS - 1; slow_level++) {
               /*SfTh12 must be bigger than SfTh 01 and so on.*/
               if (delay_tolerance->slow_level_thresh_up[slow_level + 1] < delay_tolerance->slow_level_thresh_up[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level + 1, slow_level + 2,
                                                    slow_level, slow_level + 1,
                                                    delay_tolerance->slow_level_thresh_up[slow_level + 1], 
                                                    delay_tolerance->slow_level_thresh_up[slow_level]));

               }
           }
           for (slow_level = 0; slow_level < DNX_TMC_ITM_CR_SLOW_LEVELS - 1; slow_level++) {
               /*SfTh10 must be smaller than SfTh 21 and so on.*/
               if (delay_tolerance->slow_level_thresh_down[slow_level + 1] < delay_tolerance->slow_level_thresh_down[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level + 2, slow_level + 1,
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_down[slow_level + 1], 
                                                    delay_tolerance->slow_level_thresh_down[slow_level]));

               }
           }
           for (slow_level = 0; slow_level < DNX_TMC_ITM_CR_SLOW_LEVELS; slow_level++) {
               /*SfTh10 must be smaller than SfTh 01 and so on (hysteresys).*/
               if (delay_tolerance->slow_level_thresh_up[slow_level] < delay_tolerance->slow_level_thresh_down[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level, slow_level + 1,
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_up[slow_level], 
                                                    delay_tolerance->slow_level_thresh_down[slow_level]));

               }
           }

            for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
                cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level] = delay_tolerance->slow_level_thresh_down[slow_level] / DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR;
                cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level] = delay_tolerance->slow_level_thresh_up[slow_level] / DNX_COSQ_SLOW_LEVEL_SCALING_FACTOR;
            }
        }
    }


    /* update configuration */
    cr_req_info.wd_th.cr_wd_stts_msg_gen =
                     delay_tolerance->credit_request_watchdog_status_msg_gen;
    cr_req_info.wd_th.cr_wd_dlt_q_th =
                     delay_tolerance->credit_request_watchdog_delete_queue_thresh;
    cr_req_info.hungry_th.off_to_slow_th =
                     delay_tolerance->credit_request_hungry_off_to_slow_thresh;
    cr_req_info.hungry_th.off_to_normal_th =
                     delay_tolerance->credit_request_hungry_off_to_normal_thresh;
    cr_req_info.hungry_th.slow_to_normal_th =
                     delay_tolerance->credit_request_hungry_slow_to_normal_thresh;
    cr_req_info.hungry_th.normal_to_slow_th =
                     delay_tolerance->credit_request_hungry_normal_to_slow_thresh;

    /* handle values out of the possible range */
    cr_req_info.hungry_th.multiplier =
                     delay_tolerance->credit_request_hungry_multiplier < DNX_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE ? 0 : (
                     delay_tolerance->credit_request_hungry_multiplier < DNX_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE ?
                     delay_tolerance->credit_request_hungry_multiplier : DNX_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE );

    cr_req_info.satisfied_th.backoff_th.backoff_enter_th =
                     delay_tolerance->credit_request_satisfied_backoff_enter_thresh;
    cr_req_info.satisfied_th.backoff_th.backoff_exit_th =
                     delay_tolerance->credit_request_satisfied_backoff_exit_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_enter_th =
                     delay_tolerance->credit_request_satisfied_backlog_enter_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_exit_th =
                     delay_tolerance->credit_request_satisfied_backlog_exit_thresh;
    cr_req_info.satisfied_th.backslow_th.backslow_enter_th =
                     delay_tolerance->credit_request_satisfied_backslow_enter_thresh;
    cr_req_info.satisfied_th.backslow_th.backslow_exit_th =
                     delay_tolerance->credit_request_satisfied_backslow_exit_thresh;
    cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th = 
                     delay_tolerance->credit_request_satisfied_empty_queue_thresh;
    cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh;
    cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh;
    cr_req_info.is_remote_credit_value = (delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) ? TRUE : FALSE;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_cr_request_set,(unit, dt_level, &cr_req_info, &cr_req_exact_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    if (cr_req_exact_info.wd_th.cr_wd_dlt_q_th == DNX_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FULL, (_BSL_BCM_MSG("Could not allocate the user defined delay tolerance level (queue type) since the available ones are exhausted")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_resource_gport_port_get(int unit, 
                                       bcm_gport_t gport, 
                                       bcm_port_t *port)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t port_gport = 0;
    int se_id, flow_id, dummy_tc;
    int core ;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, gport, 0, &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!BCM_GPORT_IS_SCHEDULER(port_gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("gport given is not scheduler gport")));
    }

    flow_id = BCM_GPORT_SCHEDULER_GET(port_gport) ;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port_gport) ;

    /* Convert scheduler to port id */
    se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
    rc = _bcm_dnx_cosq_se_id2port(unit,core,se_id, port, &dummy_tc);                       
    if (rc != BCM_E_NONE || *port == DNX_COSQ_SCH_PORT_ID_INVALID(unit)) {
        rc = BCM_E_PARAM;
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, Invalid se 0x%x specified - does not correspond to port\n"), unit, se_id));
        BCMDNX_IF_ERR_EXIT(rc);
    }


exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_sched_set(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int mode,
                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_dnx_cosq_gport_ucast_queue_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_scheduler_port_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_queue_sched_set(unit, gport, cosq, mode, weight);
    }
 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_dnx_cosq_gport_fmq_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_set(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_set(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_dnx_cosq_gport_e2e_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_set, 
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_ingress)); 
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_local_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_GENERIC_PIPE(gport)) {
        if (!(DNX_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_RX_QUEUE_GENERIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_generic_pipe));
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("gport type not supported")));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_sched_get(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int *mode,
                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_dnx_cosq_gport_ucast_queue_sched_get(unit, gport, cosq, mode, weight);
    }

    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_scheduler_port_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_queue_sched_get(unit, gport, cosq, mode, weight);
    }
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_dnx_cosq_gport_fmq_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_get(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_get(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_dnx_cosq_gport_e2e_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_ingress));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dnx_cosq_gport_egress_core_fifo_local_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_GENERIC_PIPE(gport)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, BCM_COSQ_GPORT_FABRIC_RX_QUEUE_GENERIC_PIPE_PIPE_GET(gport), weight, soc_dnx_cosq_gport_egress_core_fifo_fabric_generic_pipe));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int         resource_type_flag;
    uint32      resource_count;
    bcm_cosq_ingress_queue_bundle_gport_config_t config;
    int cosq;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* basic consistency checks */
    resource_type_flag = (flags &
                           (BCM_COSQ_GPORT_SCHEDULER | BCM_COSQ_GPORT_VOQ_CONNECTOR |
                            BCM_COSQ_GPORT_VSQ | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP |
                            BCM_COSQ_GPORT_ISQ | BCM_COSQ_GPORT_UCAST_QUEUE_GROUP));

    resource_count = _bcm_cosq_bit_count_get(resource_type_flag);
    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG(
          "unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"),
          unit, resource_type_flag, resource_count));
    }
    
    /* check for scheduler resource allocation */
    if (flags & BCM_COSQ_GPORT_SCHEDULER) {
        rc = _bcm_dnx_cosq_sched_gport_add(unit, port, numq, flags, gport);
    }

    /* check for connector resource allocation */
    else if (flags & BCM_COSQ_GPORT_VOQ_CONNECTOR) {
        if (!(flags & BCM_COSQ_GPORT_WITH_ID) && SOC_DNX_DEFS_GET(unit, nof_cores) > 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can't determine core ID")));
        } else {
            rc = _bcm_dnx_cosq_connector_gport_add(unit, -1, -1, 1, port, numq, flags, gport);
        }
    }  
    /* check for multicast resource allocation */
    else if (flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to zero*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_dnx_cosq_mcast_gport_add(unit, &config, gport);
    }
    /* unicast or ISQ resources */
    else if ((flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP) || 
         (flags & BCM_COSQ_GPORT_ISQ)) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to default 10 slow enabled mode*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_dnx_cosq_ucast_gport_add(unit, &config, gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, add not support for gport(0x%x)"), unit, *gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_voq_connector_gport_add(int unit, 
                                           bcm_cosq_voq_connector_gport_t *config, 
                                           bcm_gport_t *gport)
{
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_core_get(unit, config->port, 0, &core));    

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_connector_gport_add(unit, core, config->remote_modid, config->nof_remote_cores, 0, 
                                                           config->numq, config->flags, gport));
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_get(int unit,
                         bcm_gport_t gport,
                         bcm_gport_t *physical_port,
                         int *num_cos_levels,
                         uint32 *flags)
{
    bcm_error_t   rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency cheks */
    if (flags == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flags, must be 0"), unit));
    }

    if (flags != NULL) {
        (*flags) = 0;
    }
    if (num_cos_levels != NULL) {
       (*num_cos_levels) = 0;
    }
    if (physical_port != NULL) {
       (*physical_port) = 0;
    } else {
    /* Not all calls use physical_port,
     * but since that may change, better to 
     * expect it as a valid parameter
     */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, physical port must be valid parameter - not NULL"), unit));
    }

    BCMDNX_NULL_CHECK(num_cos_levels);
    
    if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_dnx_cosq_connector_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_dnx_cosq_sched_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        rc = _bcm_dnx_cosq_e2e_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_dnx_cosq_ucast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_dnx_cosq_mcast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else {
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_delete(int unit,
                            bcm_gport_t gport)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* consistency checks */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_dnx_cosq_sched_gport_delete(unit, gport);
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_dnx_cosq_connector_gport_delete(unit, gport);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_dnx_cosq_mcast_gport_delete(unit, gport);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_dnx_cosq_ucast_gport_delete(unit, gport);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, delete not support for gport(0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}
int bcm_dnx_cosq_gport_traverse(int unit,
                                  bcm_cosq_gport_traverse_cb cb,
                                  void *user_data)
{
    bcm_error_t rc = BCM_E_NONE;
    int voq = 0, nbr_cos = 0;
    bcm_gport_t gport = 0;
    int is_multicast=FALSE, is_isq=FALSE, is_unicast=FALSE;
    int queue_type = 0;
    int flow_id = 0, flow_id_temp = 0, flow_region;
    int                              is_odd_even;
    uint8                            is_interdigitated;
    int se_id,
        se_id_start,
        se_id_end,
        se_id_type,
        se_type_iter,
        se_id_loop_start[3] = {DNX_DEVICE_COSQ_CL_SE_ID_MIN_JER2_ARAD, DNX_DEVICE_COSQ_FQ_SE_ID_MIN_JER2_ARAD, DNX_DEVICE_COSQ_HR_SE_ID_MIN_JER2_ARAD},
        se_id_loop_end[3] = {DNX_DEVICE_COSQ_CL_SE_ID_MAX_JER2_ARAD, DNX_DEVICE_COSQ_FQ_SE_ID_MAX_JER2_ARAD, DNX_DEVICE_COSQ_HR_SE_ID_MAX_JER2_ARAD},
        se_ids_types[3] = {DNX_DEVICE_COSQ_CL_MASK, DNX_DEVICE_COSQ_FQ_MASK, DNX_DEVICE_COSQ_HR_MASK};
    int core = 0;
    uint32 sw_state_ref_cnt;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;

    /* walk through all the queues in the system, create gport and call
     * callback function for each unicast or multicast gport, passing 
     * user data to cb function
     */
    BCM_DNX_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
        for (voq=0;
             voq <  DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit); 
             voq += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, core, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core, voq), &sw_state_num_cos));
                nbr_cos = sw_state_num_cos;

            /* Queue not in use, go to the next */
            if (nbr_cos == 0) {
                continue;
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) voq base(%d) num_cos(%d)\n"), 
                                  unit, voq, nbr_cos));


            rc = _bcm_dnx_cosq_qid_type_get(unit, core, voq, &gport, &is_multicast,
                                              &is_unicast, &is_isq, &queue_type);

            if (BCM_FAILURE(rc)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, add not support for gport(0x%x)\n"), unit, gport));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            if (is_unicast) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, voq);
            } 
            else if (is_multicast) {
                BCM_GPORT_MCAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, voq);
            }
            else if (is_isq) {
                BCM_COSQ_GPORT_ISQ_CORE_QUEUE_SET(gport, core, voq);
            }
            rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        for (flow_id_temp=0;
             flow_id_temp < DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit); 
             flow_id_temp += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

            flow_id = flow_id_temp;

            if (flow_id> (DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit)/2)) {
                flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(flow_id);
                rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even);
                BCMDNX_IF_ERR_EXIT(rc);
                if (is_interdigitated) {
                    flow_id += 2; /*interdigitated connectors*/
                }
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, flow_id, &sw_state_num_cos));
            nbr_cos = sw_state_num_cos;

            /* Queue not in use, go to the next */
            if (nbr_cos == 0) {
                continue;
            }

            if(SOC_IS_QAX(unit)){
                flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) connector flow(%d) num_cos(%d)\n"), 
                                  unit, flow_id, nbr_cos));


            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport, flow_id, core);

            rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);
        }
        for (se_type_iter = 0 ; se_type_iter < 3 ; ++se_type_iter) {

            se_id_start = se_id_loop_start[se_type_iter];
            se_id_end = se_id_loop_end[se_type_iter];
            se_id_type = se_ids_types[se_type_iter];

            for (se_id = se_id_start ; se_id <= se_id_end ;  ++se_id) {

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
                /* se not in use, go to the next */
                if (sw_state_ref_cnt == 0) {
                    continue;
                }

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit(%d) se base(%d) num_ref(%d)\n"), 
                                      unit, se_id, sw_state_ref_cnt));

                flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
                if (flow_id == DNX_DEVICE_COSQ_SCH_FLOW_ID_INVALID_JER2_ARAD) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,(_BSL_BCM_MSG_STR("unit %d, illegal se %d\n"), unit, se_id));
                }

                if(SOC_IS_QAX(unit)){
                    flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
                }

                BCM_GPORT_SCHEDULER_CORE_SET(gport,flow_id,core);

                rc = cb(unit, 0/*port*/, 1, se_id_type/*flags*/, gport, user_data);

                BCMDNX_IF_ERR_EXIT(rc);

            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_priority_get(int unit, 
                                int start_queue,
                                int end_queue,
                                int *pri_profile_id)
{
    uint32 region = 0, last_region, start_region = 0;
    uint32 first_profile_id = 0, profile_id = 0;
    uint32 dnx_sand_rc;
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile_id valid pointer required")));        
    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64"), 
                       unit, start_queue, end_queue));
    }
    
    start_region = start_queue/DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    for (region = start_region;
         region <= last_region;
         region++) {
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_priority_map_tmplt_select_get,(unit, region, &profile_id)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dnx_itm_priority_map_tmplt_select_get region %d, profile_id %d, dnx_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  profile_id, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        if (region == start_region) {
            first_profile_id = profile_id;
        }
        if (first_profile_id != profile_id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("template queue range mismatch region(%d)=(%d) doesn't match start (%d)=(%d)"), 
                                        region, profile_id, start_region, first_profile_id));
        }
    }
    *pri_profile_id = profile_id;
    
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_priority_set(int unit,
                                int start_queue,
                                int end_queue,
                                int pri_profile_id)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 region = 0, last_region = 0;
    uint32 dnx_sand_rc;
    uint32 start_region;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id > DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, maximum profile exceeded (3) number resources specified (%d)\nmaximum profile exceeded"), 
                       unit, pri_profile_id));

    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)\nstart queue exceeds end queue"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64\nparameter error"), 
                       unit, start_queue, end_queue));
    }

    start_region = start_queue/DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    for (region = start_region;
         region <= last_region; 
         region++) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_priority_map_tmplt_select_set,(unit, region, pri_profile_id)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dnx_itm_priority_map_tmplt_select_set region %d, profile_id %d, dnx_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  pri_profile_id, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_priority_profile_get(int unit,
                                        int pri_profile_id,
                                        int *count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    DNX_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (pri_profile_id > DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    *count = DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dnx_itm_priority_map_tmplt_get  profile_id %d, dnx_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    pri_profile->pri[0] = prm_info.map[0];
    pri_profile->pri[1] = prm_info.map[1];

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_priority_profile_set(int unit,
                                        int pri_profile_id,
                                        int count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)

{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    if (pri_profile_id > DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    if (count != DNX_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, count(%d) must be (%d) queues per template\n"), 
                              unit, count, BCM_COSQ_PRIORITY_PROFILE_MAX_SIZE));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("count error")));

    }

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dnx_itm_priority_map_tmplt_get  profile_id %d, dnx_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    

    prm_info.map[0] = pri_profile->pri[0];
    prm_info.map[1] = pri_profile->pri[1];

    dnx_sand_rc =  (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_priority_map_tmplt_set,(unit, pri_profile_id, &prm_info)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dnx_itm_priority_map_tmplt_set  profile_id %d, dnx_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

bcm_dnx_cosq_vsq_rate_class_wred_info_t* 
bcm_dnx_cosq_vsq_rate_class_wred_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }

    if (vsq_group < DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].wred);
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < DNX_TMC_ITM_NOF_RSRC_POOLS) {
            return (void *)&(data_rate_cls->port[pool_index].wred);
        }
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_PG) {
        return (void *)&(data_rate_cls->pg.wred);
    }
    return (void *)NULL;
}

bcm_dnx_cosq_vsq_rate_class_taildrop_info_t* 
bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, int headroom, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }
    if (vsq_group < DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].taildrop);
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < DNX_TMC_ITM_NOF_RSRC_POOLS) {
            if (headroom) {
                return (void *)&(data_rate_cls->port[pool_index].headroom);    
            } else {
                return (void *)&(data_rate_cls->port[pool_index].shared);
            }
        }
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_PG) {
        if (headroom) {
            return (void *)&(data_rate_cls->pg.headroom);
        } else {
            return (void *)&(data_rate_cls->pg.shared);
        }
    }
    return (void *)NULL;
}

bcm_dnx_cosq_vsq_rate_class_fc_info_t* 
bcm_dnx_cosq_vsq_rate_class_fc_data_get(int unit, const DNX_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dnx_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }
    if (vsq_group < DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].fc);
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < DNX_TMC_ITM_NOF_RSRC_POOLS) {
            return (void *)&(data_rate_cls->port[pool_index].fc);
        }
    }
    if (vsq_group == DNX_TMC_ITM_VSQ_GROUP_PG) {
        return (void *)&(data_rate_cls->pg.fc);
    }
    return (void *)NULL;
}
/* 
 * Purpose: Commit in HW rate class information 
 */
static int
_bcm_dnx_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      DNX_TMC_ITM_VSQ_GROUP vsq_category_index,
                                      bcm_dnx_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dnx_cosq_vsq_rate_class_info_t *exact_rate_class_info)
{
    uint32                dnx_sand_rc = 0;    
    bcm_error_t           rc = BCM_E_NONE;
    int dp_index;
    DNX_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    DNX_TMC_ITM_VSQ_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    DNX_TMC_ITM_VSQ_WRED_GEN_INFO wred_gen_info;
    DNX_TMC_ITM_VSQ_FC_INFO fc_info, exact_fc_info;
    soc_dnx_config_t *dnx = SOC_DNX_CONFIG(unit);
    int pool_id;
    bcm_dnx_cosq_vsq_rate_class_wred_info_t *wred, *exact_wred;
    bcm_dnx_cosq_vsq_rate_class_taildrop_info_t *taildrop, *exact_taildrop;
    bcm_dnx_cosq_vsq_rate_class_fc_info_t *fc, *exact_fc;
    int is_headroom = 0, rsrc_type = DNX_TMC_INGRESS_THRESHOLD_INVALID;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(rate_class_info);
    BCMDNX_NULL_CHECK(exact_rate_class_info);
    
    DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);
    DNX_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&exact_tail_drop_info);
    DNX_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);

    
    for (pool_id = 0; 
         pool_id < ((vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) ? DNX_DEVICE_COSQ_VSQ_NOF_RSRC_POOLS(unit) : 1); 
         pool_id++) {
        if (pool_id != 0 && vsq_category_index != DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
            continue;
        }
        wred = bcm_dnx_cosq_vsq_rate_class_wred_data_get(unit, vsq_category_index, pool_id, rate_class_info);
        exact_wred = bcm_dnx_cosq_vsq_rate_class_wred_data_get(unit, vsq_category_index, pool_id, exact_rate_class_info);


        for (dp_index = 0; dp_index < DNX_DEVICE_COSQ_ING_NOF_DP; dp_index++) {
            DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
            DNX_TMC_ITM_VSQ_WRED_GEN_INFO_clear(&wred_gen_info); 
        
            /* WRED */
            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_wred_get,(unit,vsq_category_index, rate_class, dp_index, pool_id, &wred_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_wred_gen_get,(unit, vsq_category_index, rate_class, pool_id, &wred_gen_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            if (wred->enable[dp_index]) {
                wred_gen_info.wred_en = 1;
            }
            /*shalitas: Why don't we configure exp_wq?*/
            /*wred_gen_info.exp_wq = rate_class_info->wred_exp_wq[vsq_category_index];*/                             
            wred_info.max_avrg_th           = wred->max_avrg_th[dp_index];
            wred_info.min_avrg_th           = wred->min_avrg_th[dp_index];
            wred_info.max_probability       = wred->max_probability[dp_index];
            wred_info.wred_en               = wred->enable[dp_index];
            wred_info.ignore_packet_size    = (dnx->tm.wred_packet_size == 0) ? 1 : 0;
            wred_info.max_packet_size       = dnx->tm.wred_packet_size;

            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_wred_set,(unit, vsq_category_index, rate_class, dp_index, pool_id, &wred_info, &exact_wred_info)));
            BCMDNX_IF_ERR_EXIT(rc);
   
            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_wred_gen_set,(unit, vsq_category_index, rate_class, pool_id, &wred_gen_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            /*  Set exact rate class information according to exact wred information */
            exact_wred->min_avrg_th[dp_index] = exact_wred_info.min_avrg_th;
            exact_wred->max_avrg_th[dp_index] = exact_wred_info.max_avrg_th;
            exact_wred->max_probability[dp_index] = exact_wred_info.max_probability;
            exact_wred->enable[dp_index] = exact_wred_info.wred_en;
            exact_wred->ignore_packet_size[dp_index] = wred_info.max_packet_size;

            if (!SOC_IS_QAX(unit) || (SOC_IS_QAX(unit) && vsq_category_index < DNX_TMC_ITM_VSQ_GROUP_SRC_PORT)) {
                /* 
                 * For JER2_QAX we seperate destination-based VSQs from source-based VSQs.
                 * This part is the destination-based VSQs taildrop 
                 */
                for (is_headroom = 0; is_headroom < 2; is_headroom++) {
                    taildrop = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, vsq_category_index, pool_id, is_headroom, rate_class_info);
                    exact_taildrop = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, vsq_category_index, pool_id, is_headroom, exact_rate_class_info);

                    /* Tail drop */                                
                    DNX_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&tail_drop_info);
                    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_tail_drop_get,(unit,vsq_category_index, rate_class, dp_index, pool_id, is_headroom, &tail_drop_info)));
                    BCMDNX_IF_ERR_EXIT(rc);

                    /*shalitas: Today we configure the headroom and the pool in the same way*/
                    tail_drop_info.max_inst_q_size     = taildrop->max_size[dp_index];
                    tail_drop_info.max_inst_q_size_bds = taildrop->max_size_bds[dp_index];
                    for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        tail_drop_info.max_inst_q_size_th[rsrc_type]= taildrop->max_size_th[rsrc_type][dp_index];
                    }

                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_PG) {
                        tail_drop_info.alpha = rate_class_info->pg.queue_alpha_bds[dp_index];
                    }

                    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_tail_drop_set,(unit, vsq_category_index, rate_class, dp_index, pool_id, is_headroom, &tail_drop_info, &exact_tail_drop_info)));
                    BCMDNX_IF_ERR_EXIT(rc);

                    exact_taildrop->max_size[dp_index]     = exact_tail_drop_info.max_inst_q_size;
                    exact_taildrop->max_size_bds[dp_index] = exact_tail_drop_info.max_inst_q_size_bds;
                    for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        exact_taildrop->max_size_th[rsrc_type][dp_index] = exact_tail_drop_info.max_inst_q_size_th[rsrc_type];
                    }

                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_PG) {
                        exact_rate_class_info->pg.queue_alpha_bds[dp_index] = tail_drop_info.alpha;
                    }
                }
            }
            if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                if (SOC_IS_QAX(unit)) {
                    /* 
                     * For JER2_QAX we seperate destination-based VSQs from source-based VSQs.
                     * This part relates to the source-based VSQs. 
                     */
                    bcm_dnx_cosq_src_port_vsq_rate_class_info_t *src_port = &rate_class_info->port[pool_id];
                    bcm_dnx_cosq_src_port_vsq_rate_class_info_t *exact_src_port = &exact_rate_class_info->port[pool_id];
                    DNX_TMC_ITM_VSQ_SRC_PORT_INFO src_port_info, exact_src_port_info;
                    bcm_dnx_cosq_pg_vsq_rate_class_info_t *pg = &rate_class_info->pg;
                    bcm_dnx_cosq_pg_vsq_rate_class_info_t *exact_pg = &exact_rate_class_info->pg;
                    DNX_TMC_ITM_VSQ_PG_INFO pg_info, exact_pg_info;

                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
                        DNX_TMC_ITM_VSQ_SRC_PORT_INFO_clear(&exact_src_port_info);
                        DNX_TMC_ITM_VSQ_SRC_PORT_INFO_clear(&src_port_info);

                        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            src_port_info.max_guaranteed[rsrc_type] = src_port->guaranteed_size[rsrc_type][dp_index];
                            src_port_info.max_shared[rsrc_type] = src_port->shared_size[rsrc_type][dp_index];
                            src_port_info.max_headroom[rsrc_type] = src_port->headroom_size[rsrc_type];
                        }

                        rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_src_port_rjct_set, (unit, vsq_category_index, dp_index, pool_id, &src_port_info, &exact_src_port_info));
                        BCMDNX_IF_ERR_EXIT(rc);

                        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            exact_src_port->guaranteed_size[rsrc_type][dp_index] = exact_src_port_info.max_guaranteed[rsrc_type];
                            exact_src_port->shared_size[rsrc_type][dp_index] = exact_src_port_info.max_shared[rsrc_type];
                            exact_src_port->headroom_size[rsrc_type] = exact_src_port_info.max_headroom[rsrc_type];
                        }
                    }

                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_PG) {
                        DNX_TMC_ITM_VSQ_PG_INFO_clear(&exact_pg_info);
                        DNX_TMC_ITM_VSQ_PG_INFO_clear(&pg_info);

                        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            pg_info.max_guaranteed[rsrc_type] = pg->guaranteed_size[rsrc_type][dp_index];
                            pg_info.max_shared[rsrc_type].max_threshold = pg->shared_size[rsrc_type][dp_index].max_threshold;
                            pg_info.max_shared[rsrc_type].min_threshold = pg->shared_size[rsrc_type][dp_index].min_threshold;
                            pg_info.max_shared[rsrc_type].alpha = pg->shared_size[rsrc_type][dp_index].alpha;
                            pg_info.max_headroom[rsrc_type].max_headroom = pg->headroom_size[rsrc_type].max_headroom;
                            pg_info.max_headroom[rsrc_type].max_headroom_nominal = pg->headroom_size[rsrc_type].max_headroom_nominal;
                            pg_info.max_headroom[rsrc_type].max_headroom_extension = pg->headroom_size[rsrc_type].max_headroom_extension;
                        }

                        rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_rjct_set, (unit, vsq_category_index, dp_index, &pg_info, &exact_pg_info));
                        BCMDNX_IF_ERR_EXIT(rc);

                        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            exact_pg->guaranteed_size[rsrc_type][dp_index] = exact_pg_info.max_guaranteed[rsrc_type];
                            exact_pg->shared_size[rsrc_type][dp_index].max_threshold = exact_pg_info.max_shared[rsrc_type].max_threshold;
                            exact_pg->shared_size[rsrc_type][dp_index].min_threshold = exact_pg_info.max_shared[rsrc_type].min_threshold;
                            exact_pg->shared_size[rsrc_type][dp_index].alpha = exact_pg_info.max_shared[rsrc_type].alpha;
                            exact_pg->headroom_size[rsrc_type].max_headroom = exact_pg_info.max_headroom[rsrc_type].max_headroom;
                            exact_pg->headroom_size[rsrc_type].max_headroom_nominal = exact_pg_info.max_headroom[rsrc_type].max_headroom_nominal;
                            exact_pg->headroom_size[rsrc_type].max_headroom_extension = exact_pg_info.max_headroom[rsrc_type].max_headroom_extension;
                        }
                    }
                } else {
                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_SRC_PORT) {
                        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_src_reserve_set, (unit, BCM_CORE_ALL, vsq_category_index, rate_class, dp_index, pool_id, rate_class_info->port[pool_id].min_threshold[dp_index], &exact_rate_class_info->port[pool_id].min_threshold[dp_index])));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_PG) {
                        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_src_reserve_set, (unit, BCM_CORE_ALL, vsq_category_index, rate_class, dp_index, pool_id, rate_class_info->pg.min_threshold[dp_index], &exact_rate_class_info->pg.min_threshold[dp_index])));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }

        
        fc = bcm_dnx_cosq_vsq_rate_class_fc_data_get(unit, vsq_category_index, pool_id, rate_class_info);
        exact_fc = bcm_dnx_cosq_vsq_rate_class_fc_data_get(unit, vsq_category_index, pool_id, exact_rate_class_info);

        DNX_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_fc_get,(unit, vsq_category_index, rate_class, pool_id, &fc_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        fc_info.q_size_fc.set    = fc->queue_size.set;
        fc_info.q_size_fc.clear  = fc->queue_size.clear;
        fc_info.bd_size_fc.set   = fc->bd_size.set;
        fc_info.bd_size_fc.clear = fc->bd_size.clear;
        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            fc_info.size_fc[rsrc_type].set   = fc->size[rsrc_type].set;
            fc_info.size_fc[rsrc_type].clear = fc->size[rsrc_type].clear;
        }

        /* Set information */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_fc_set,(unit, vsq_category_index, rate_class, pool_id, &fc_info,&exact_fc_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        exact_fc->queue_size.set    = exact_fc_info.q_size_fc.set;
        exact_fc->queue_size.clear  = exact_fc_info.q_size_fc.clear;
        exact_fc->bd_size.set       = exact_fc_info.bd_size_fc.set;
        exact_fc->bd_size.clear     = exact_fc_info.bd_size_fc.clear;  
        for (rsrc_type = 0; rsrc_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            exact_fc->size[rsrc_type].set    = exact_fc_info.size_fc[rsrc_type].set;
            exact_fc->size[rsrc_type].clear  = exact_fc_info.size_fc[rsrc_type].clear;
        }
    }

    if (vsq_category_index == DNX_TMC_ITM_VSQ_GROUP_PG && !SOC_IS_ARADPLUS_AND_BELOW(unit) && !SOC_IS_QAX(unit)) {
        /* In JER2_QAX PG params are per PG-VSQ and not per rate class, so we don't set them here. */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_prm_set, (unit, rate_class, &(rate_class_info->pg.prm)))); 
        sal_memcpy(&(exact_rate_class_info->pg.prm), &(rate_class_info->pg.prm), sizeof(DNX_TMC_ITM_VSQ_PG_PRM));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Since there is only 1 counter for reserved DB per VSQE/F, need to find
 * the maximum reserved amount of the VSQ across all colors (and for VSQE
 * also across pools).
 */
static uint32
_bcm_dnx_cosq_vsq_max_reserved_get(bcm_dnx_cosq_vsq_type_t vsq_group_type,
                                     bcm_dnx_cosq_vsq_rate_class_info_t *data_rate_class)
{
    uint32 max_reserved = 0, color_reserved = 0;
    uint8 color = 0, pool_id = 0;

    /* Find maximum reserved size of all colors in VSQ */
    for (color = 0; color < DNX_DEVICE_COSQ_ING_NOF_DP; ++color) {
        if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT) {
            for (pool_id = 0; pool_id < DNX_TMC_ITM_NOF_RSRC_POOLS; ++pool_id) {
                color_reserved = data_rate_class->port[pool_id].min_threshold[color];
                if (color_reserved > max_reserved) {
                    max_reserved = color_reserved;
                }
            }
        } else if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG) {
            color_reserved = data_rate_class->pg.min_threshold[color];
            if (color_reserved > max_reserved) {
                max_reserved = color_reserved;
            }
        }
    }

    return max_reserved;
}

/*
 * Purpose:
 *  Check there are enough resources after reserve_change will be updated,
 *  and then update the new reserved resources in sw_state.
 */
static int
_bcm_dnx_cosq_vsq_total_reserve_update(int unit,
                                         int core_id,
                                         uint8 is_ocb_only,
                                         int reserve_change)
{
    bcm_error_t rv;
    DNX_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    DNX_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    BCMDNX_INIT_FUNC_DEFS;

    rv = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
    BCMDNX_IF_ERR_EXIT(rv);

    ingress_resource = is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram);

    if (ingress_resource->pool_0 + 
            ingress_resource->pool_1 + 
            ingress_resource->headroom +
            ingress_resource->reserved +
            reserve_change > ingress_resource->total) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Run out of resource to reserve/guarantee for VSQ. Consider reduce pools size.")));
    }
    
    DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
    /* Update reserved resource in sw_state */
    rv = sw_state_access[unit].dnx.soc.jer2_jericho.tm.ingress_reserved_resource.get(unit, core_id, &ingress_reserved_resource);
    BCMDNX_IF_ERR_EXIT(rv);
    (is_ocb_only) ? (ingress_reserved_resource.ocb_reserved += reserve_change) : (ingress_reserved_resource.dram_reserved += reserve_change);
    rv = sw_state_access[unit].dnx.soc.jer2_jericho.tm.ingress_reserved_resource.set(unit, core_id, &ingress_reserved_resource);
    BCMDNX_IF_ERR_EXIT(rv);
#endif 

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_category_get(int unit,
                                 int core_id,
                                 int queue_id,
                                 int *vsq_category)
{
    uint32 dnx_sand_rc;
    DNX_TMC_ITM_CATEGORY_RNGS info;
    int queue_category = 0;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_ITM_CATEGORY_RNGS_clear(&info);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_category_rngs_get,(unit, core_id, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (queue_id <= info.vsq_ctgry0_end) {
        queue_category = 0;
    } else if (queue_id <= info.vsq_ctgry1_end) {
        queue_category = 1;
    } else if (queue_id <= info.vsq_ctgry2_end) {
        queue_category = 2;
    } else {
        queue_category = 3;
    }
    *vsq_category = queue_category;

exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_vsq_id_range_verify(int unit,
                                    int core_id,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match)
{
    bcm_error_t rv;
    int queue_category = 0;
    BCMDNX_INIT_FUNC_DEFS;
    
    *is_match = 0;

    rv = _bcm_dnx_cosq_vsq_category_get(unit, core_id, queue_id, &queue_category);
    BCMDNX_IF_ERR_EXIT(rv);

    if (queue_category == vsq_category) {
        *is_match = 1;
    } 

    BCMDNX_IF_ERR_EXIT(rv);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_vsq_add(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    int vsq_category = 0, vsq_connection_cls = -1, vsq_traffic_cls = -1;    
    int is_match;
    int core_queue = BCM_CORE_ALL, core_vsq = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DNX_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    
    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue) + cosq;
    core_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(queue);

    if ((core_queue < 0 || core_queue >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core_queue != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x) failed, core out of range %d"), unit, queue, core_queue));
    }

    if (!(BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is no members adding for this type of vsq"), unit, vsq));
    }
    
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        core_vsq = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
        if (core_vsq != core_queue && core_vsq != BCM_CORE_ALL && core_queue != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, vsq and voq cores must be equal. vsq core core id %d, queue core is %d"), unit, vsq, core_vsq, core_queue));
        }
        vsq_category = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq)) {
        vsq_connection_cls =  BCM_COSQ_GPORT_VSQ_CC_GET(vsq);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        vsq_traffic_cls =  BCM_COSQ_GPORT_VSQ_TC_GET(vsq);
    }

    rc = _bcm_dnx_cosq_vsq_id_range_verify(unit, core_queue, queue_id, vsq_category, &is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq, queue));
    }   

    /* Set new mapping */
    if (vsq_connection_cls != -1) {
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DNX_COSQ_VSQ_CC, vsq_connection_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_traffic_cls != -1) {
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DNX_COSQ_VSQ_TC, vsq_traffic_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_vsq_delete(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    int vsq_category = 0; 
    int is_match;  
    int core_queue = BCM_CORE_ALL, core_vsq = BCM_CORE_ALL;

  
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DNX_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    

    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue) + cosq;
    core_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(queue);

    if ((core_queue < 0 || core_queue >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core_queue != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x) failed, core out of range %d"), unit, queue, core_queue));
    }

    if (!(BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is no members adding for this type of vsq"), unit, vsq));
    }

    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        core_vsq = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
        if (core_vsq != core_queue && core_vsq != BCM_CORE_ALL && core_queue != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, vsq and voq cores must be equal. vsq core core id %d, queue core is %d"), unit, vsq, core_vsq, core_queue));
        }
        vsq_category = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    }
    
    rc = _bcm_dnx_cosq_vsq_id_range_verify(unit, core_queue, queue_id, vsq_category, &is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq, queue));
    }   

    /* Delete by mapping queue to default vsq, which is 0 */
    if (BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DNX_COSQ_VSQ_TC, 0);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq)) {
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DNX_COSQ_VSQ_CC, 0);    
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    BCMDNX_IF_ERR_EXIT(rc);        

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_vsq_delete_all(
    int unit, 
    bcm_gport_t vsq)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_vsq_get(
    int unit, 
    bcm_gport_t vsq, 
    int queue_max, 
    bcm_gport_t *queue_array, 
    bcm_cos_queue_t *cosq_array, 
    int *queue_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dnx_cosq_vsq_type_t *vsq_group_type)                                 
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_GLOBAL;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_CT) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_CTGRY;        
    }
    
    if (vsq_info->flags == BCM_COSQ_VSQ_CTTC) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_CTTC;
    }
    
    if (vsq_info->flags == BCM_COSQ_VSQ_CTCC) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_CTCC;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_PP;
    }
    /*Arad only types*/
    /*Src Port VSQ, and PG VSQ are configured in another another API*/
    if (vsq_info->flags == BCM_COSQ_VSQ_PFC) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_PFC;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
        *vsq_group_type = BCM_DNX_COSQ_VSQ_TYPE_LLFC;
    }

    BCMDNX_IF_ERR_EXIT(rc);        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * retrieve VSQ information from VSQ GPORT. 
 * When vsq_group_type is of tmc type returns the inner vsq index in tmc type.
 */
int
_bcm_dnx_cosq_gport_vsq_gport_get(int unit,
                                    bcm_gport_t vsq_gport,
                                    bcm_cos_queue_t cosq, 
                                    int *core_id,
                                    uint8 *is_ocb_only,
                                    bcm_dnx_cosq_vsq_type_t *vsq_group_type,
                                    int *vsq_index)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 vsq_type_info;
    int src_port = 0;
    int traffic_class = 0;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_LAST_JER2_ARAD;
    uint32 dnx_sand_rc, internal_id;  
    uint32 index = 0;  
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG] = {0};

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(core_id);
    BCMDNX_NULL_CHECK(is_ocb_only);
    BCMDNX_NULL_CHECK(vsq_group_type);
    BCMDNX_NULL_CHECK(vsq_index); 

    *is_ocb_only = 0;
    *vsq_group_type = BCM_DNX_COSQ_GPORT_VSQ_TYPE_GET(vsq_gport);

    if (cosq != 0 && cosq != -1) {
        /* cosq must be 0/-1 for all VSQs, even for VSQ-PG,
         * because cosq is not relevant anymore for this function.
         */
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "VSQ 0x%x must have cosq 0 or -1.\n"), vsq_gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }

    if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *vsq_index = 0;
    } else if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTGRY) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTTC) {
        *vsq_index = (BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport) * DNX_COSQ_PACKET_NOF_TC) + BCM_COSQ_GPORT_VSQ_TC_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTCC) {
        *vsq_index = ((BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport) - 2) * DNX_COSQ_VSQ_NOF_CONNECTION_CLASS) + BCM_COSQ_GPORT_VSQ_CC_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PP) {
        src_port = BCM_COSQ_GPORT_VSQ_PP_GET(vsq_gport);
        *vsq_index = src_port;
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (SOC_IS_JERICHO(unit) && (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT)) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        if (!SOC_IS_QAX(unit)) {
            *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
        }
    } else if (SOC_IS_JERICHO(unit) && (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG)) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_PG_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);

        if (!SOC_IS_QAX(unit)) {
            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_ocb_get ,(unit, *core_id, *vsq_index, 1, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);

            *is_ocb_only = ocb_only_array[0];
        }
    } else if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PFC || *vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_LLFC) {
        bcm_dnx_cosq_vsq_type_t vsq_group_type_get;

        *core_id = 0;
        vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq_gport);
        if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PFC) {
           /* retrieve Class based and Src port */
           src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
           /* Class based = Traffic class in PB */
           traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
        } else {
           /* LLFC */
           src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);
        }

        /* Get internal interface id */
        rc = dnx_port_sw_db_first_phy_port_get(unit, src_port, &internal_id /*one based*/);
        BCMDNX_IF_ERR_EXIT(rc);
        internal_id--;
        /* Conclude VSQ Group ID */
        if (*vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PFC) {
            vsq_id = BCM_DNX_VSQ_ID_CBFC_JER2_ARAD(internal_id,traffic_class);
        } else {
            /* LLFC */
            vsq_id = BCM_DNX_VSQ_ID_LLFC_JER2_ARAD(internal_id);
        }
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_global2group,(unit, vsq_id, &dnx_tmcvsq_type, &index, is_ocb_only)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in vsq id retrieve %d, vsq gport 0x%x"), unit, vsq_id, vsq_gport));
        }

        *vsq_index = (int)index;
        rc = _bcm_dnx_cosq_tmc_vsq_type_to_bcm_vsq_type(dnx_tmcvsq_type, &vsq_group_type_get);
        BCMDNX_IF_ERR_EXIT(rc);

        if (*vsq_group_type != vsq_group_type_get) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, VSQ 0x%x: Soc level VSQ group type %d in diffrent from configured type %d."), unit, vsq_gport, *vsq_group_type, vsq_group_type_get));
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq 0x%x group type %d "), unit, vsq_gport, *vsq_group_type));
    }
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dnx_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type;
    int local_port;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PFC || vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_LLFC)
    {
      /* retrieve local port from source port */
      rc = _bcm_dnx_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
      BCMDNX_IF_ERR_EXIT(rc);      
    }
    switch (vsq_group_type) {
    case BCM_DNX_COSQ_VSQ_TYPE_GLOBAL:
        BCM_COSQ_GPORT_VSQ_GL_SET(*vsq_gport, vsq_info->core_id);
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_CTGRY:
        BCM_COSQ_GPORT_VSQ_CT_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id);
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_CTTC:
        BCM_COSQ_GPORT_VSQ_CTTC_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id, vsq_info->traffic_class);
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_CTCC:
        BCM_COSQ_GPORT_VSQ_CTCC_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id, vsq_info->cc_id);
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_PP:
        BCM_COSQ_GPORT_VSQ_PP_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->pp_vsq_id);
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_PFC: /*Arad legacy type*/
        BCM_COSQ_VSQ_TYPE_INFO_GROUPE_SET(vsq_type, local_port, vsq_info->traffic_class);
        BCM_COSQ_GPORT_VSQ_SET(*vsq_gport, BCM_COSQ_VSQ_PFC, vsq_type); 
        break;
    case BCM_DNX_COSQ_VSQ_TYPE_LLFC: /*Arad legacy type*/
        BCM_COSQ_VSQ_TYPE_INFO_GROUPF_SET(vsq_type, local_port);
        BCM_COSQ_GPORT_VSQ_SET(*vsq_gport, BCM_COSQ_VSQ_LLFC, vsq_type);
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d "), unit, vsq_group_type));        
    }        

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port)
{
  bcm_error_t rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;   
  rv = bcm_dnx_cosq_user_port_get(unit, src_port, local_port);
  BCMDNX_IF_ERR_EXIT(rv);


exit:
BCMDNX_FUNC_RETURN;
}



static int 
_bcm_dnx_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    /* Validate category range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_CT || 
         vsq_info->flags == BCM_COSQ_VSQ_CTTC || 
         vsq_info->flags == BCM_COSQ_VSQ_CTCC) && 
        (vsq_info->ct_id < 0 || vsq_info->ct_id > (DNX_TMC_ITM_VSQ_GROUPA_SZE(unit) - 1))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ct_id range %d "), unit, vsq_info->ct_id));        
    }
    if ((vsq_info->flags == BCM_COSQ_VSQ_GL || 
        vsq_info->flags == BCM_COSQ_VSQ_CT || 
        vsq_info->flags == BCM_COSQ_VSQ_CTTC || 
        vsq_info->flags == BCM_COSQ_VSQ_CTCC) &&
        (vsq_info->core_id != BCM_CORE_ALL && (vsq_info->core_id < 0 || vsq_info->core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid core id %d"), unit, vsq_info->core_id));
    }
    /* Validate connection class range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_CTCC) && 
        (vsq_info->ct_id < 2 || vsq_info->ct_id > 3 || vsq_info->cc_id > (DNX_COSQ_VSQ_NOF_CONNECTION_CLASS - 1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Category id or Connection class. CT %d, CC %d, CTCC expect category of 2-3 "), unit, vsq_info->ct_id, vsq_info->cc_id));
    }

    /* Validate source  ports range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_PFC) || (vsq_info->flags == BCM_COSQ_VSQ_LLFC)) {
        int local_port;
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Jericho does not support type %d"), unit, vsq_info->traffic_class));
        }
        /* Validate traffic class range */
        if ((vsq_info->traffic_class < 0 || vsq_info->traffic_class > (DNX_DEVICE_COSQ_ING_NOF_TC - 1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid traffic class range %d "), unit, vsq_info->traffic_class));        
        }

        rc = _bcm_dnx_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
        BCMDNX_IF_ERR_EXIT(rc);
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
        if (local_port < 0 || local_port > (_BCM_DNX_NOF_TM_PORTS(unit) - 1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Source port. Source port %x "), unit, vsq_info->src_port));        
        }
#endif 
    }
    /* Validate PP range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_PP) && 
        (vsq_info->pp_vsq_id < 0 || vsq_info->pp_vsq_id > SOC_DNX_CONFIG(unit)->pdm_extension.max_st_vsq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid pp vsq id %d "), unit, vsq_info->pp_vsq_id));        
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    int core_id = BCM_CORE_ALL;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    int index, nof_drop_prec;  
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];
    bcm_dnx_cosq_vsq_type_t vsq_group_type = BCM_DNX_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only;
    bcm_dnx_cosq_vsq_rate_class_wred_info_t *wred;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_group;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));    

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate Params */
    rc = _bcm_dnx_cosq_gport_discard_verify(unit, discard, 1);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve VSQ id */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);    
    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_group);
    BCMDNX_IF_ERR_EXIT(rc);
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL (unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_group, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */

    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change Rate class configuration according to discard structure */
    rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit, discard->flags, drop_prec, &nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    /* Note: Wred enable is global per rate class, thus if at least one dp is enable, all dps are enable. */
    wred = bcm_dnx_cosq_vsq_rate_class_wred_data_get(unit, dnx_tmcvsq_group, 0, &data_rate_class);
    for (index = 0; index < nof_drop_prec; index++) {
        wred->enable[drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? DNX_SAND_TRUE : DNX_SAND_FALSE;
        wred->min_avrg_th[drop_prec[index]] = discard->min_thresh;
        wred->max_avrg_th[drop_prec[index]] = discard->max_thresh;
        wred->max_probability[drop_prec[index]] = discard->drop_probability;
    }

    /* WRED exp wq parameter is same for all dps and ECN */
    /*data_rate_class.wred_exp_wq[dnx_tmcvsq_group] = discard->gain;*/

    /* Settings WRED parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */
     

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_dnx_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: retrieve WRED configuration
 */
static int
_bcm_dnx_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;    
    int core_id = BCM_CORE_ALL;
    int nof_drop_prec;
    uint32 dnx_sand_rc;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    uint32 relevant_flags;
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = 0; 
    int vsq_index;
    uint8 is_ocb_only;
    bcm_dnx_cosq_vsq_rate_class_wred_info_t *wred;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));    

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* retrieve VSQ id */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
   
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x"), unit, discard->flags));
    }

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_BYTES);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x"), unit, discard->flags));
    }

    rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    wred = bcm_dnx_cosq_vsq_rate_class_wred_data_get(unit, dnx_tmcvsq_type, 0, &data_rate_class);
    discard->drop_probability = wred->max_probability[dp_index];
    /*discard->gain = data_rate_class.wred_exp_wq[dnx_tmcvsq_type];*/
    discard->min_thresh = wred->min_avrg_th[dp_index];
    discard->max_thresh = wred->max_avrg_th[dp_index];
    if (wred->enable[dp_index] == DNX_SAND_TRUE) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    uint32 relevant_flags, tail_drop_types_flags;   
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    int index, tail_drop_count;
    uint32 dnx_sand_rc;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = 0;
    int vsq_index;
    uint8 is_ocb_only;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    int pool_id, headroom;
    bcm_dnx_cosq_vsq_rate_class_taildrop_info_t* taildrop;

    bcm_color_t start_color;
    bcm_color_t end_color;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));

    BCMDNX_NULL_CHECK(gport_size);

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate params */
    if (SOC_IS_QAX(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC));
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));
    } else {
        tail_drop_types_flags = flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC;
    }
    /*shalitas: add flag for headroom and shared*/
    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    if (SOC_IS_QAX(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    } else {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    }

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }    

    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DNX_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    /* retrieve VSQ ID */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1 && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Only source port VSQs can be configured for pool 1, the type given is %d"), unit, vsq_group_type));
    }
    pool_id = (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1) ? 1 : 0;

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    /* Get old rate class data */
    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change related information */
    start_color = flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND ? 0 : color;
    end_color = flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND ? DNX_DEVICE_COSQ_ING_NOF_DP : color + 1;
    headroom = 0;   /* headroom is relevant only for source bases VSQs (VSQE-F) */
    taildrop = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_type, pool_id, headroom, &data_rate_class); 
    for (index = start_color; index < end_color; index++) {
        if (SOC_IS_QAX(unit)) {
            if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
                if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                    taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][index] = gport_size->size_max;
                } else if (flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) {
                    taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_SRAM_PDS][index] = gport_size->size_max;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
                }
            } else if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][index] = gport_size->size_max;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }
        } else {
            if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                taildrop->max_size[index] = gport_size->size_max;
            } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                taildrop->max_size_bds[index] = gport_size->size_max;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }

            if (!SOC_IS_ARADPLUS_AND_BELOW(unit) && 
                (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && 
                (dnx_tmcvsq_type == DNX_TMC_ITM_VSQ_GROUP_PG)) {
                if (gport_size->size_alpha_max < JER2_ARAD_PLUS_MIN_ALPHA || gport_size->size_alpha_max > JER2_ARAD_PLUS_MAX_ALPHA) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Illegal size_alpha_max value %d, must be in range %d..%d"),
                      gport_size->size_alpha_max, JER2_ARAD_PLUS_MIN_ALPHA, JER2_ARAD_PLUS_MAX_ALPHA));
                }
                data_rate_class.pg.queue_alpha_bds[index] = gport_size->size_alpha_max;
            }
        }
    }

    /* Settings Tail drop parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_dnx_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    uint32 relevant_flags, tail_drop_types_flags;    
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;    
    int tail_drop_count;   
    uint32 dnx_sand_rc; 
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = 0;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    int vsq_index;
    uint8 is_ocb_only;
    int pool_id;
    bcm_dnx_cosq_vsq_rate_class_taildrop_info_t* taildrop;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    
    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate params */
    if (SOC_IS_QAX(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC));
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));
    } else {
        tail_drop_types_flags = flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC;
    }
    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    if (SOC_IS_QAX(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    } else {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    }

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DNX_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    /* retrieve VSQ id */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1 && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Only source port VSQs can be configured for pool 1, the type given is %d"), unit, vsq_group_type));
    }
    pool_id = (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1) ? 1 : 0;

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }
    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_DNX_UNIT_CHECK(unit);

    /* Get old rate class data */
    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    taildrop = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_type, pool_id, 0, &data_rate_class); 
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
        color = 0;
    }

    if (SOC_IS_QAX(unit)) {
        if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
            if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                 gport_size->size_max = taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][color];
            } else if (flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) {
                 gport_size->size_max = taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_SRAM_PDS][color];
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }
        } else if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
             gport_size->size_max = taildrop->max_size_th[DNX_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][color];
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
        }
    } else {
        if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
            gport_size->size_max = taildrop->max_size[color];
        } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            gport_size->size_max = taildrop->max_size_bds[color];
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n . Missing size flag"), unit, flags));
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_DROP_TH drop_info,exact_drop_info;
    uint32 relevant_flags, threshold_type_flags, dnx_sand_rc;
    int threshold_count;
    int core_id = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(gport);
    BCM_DNX_UNIT_CHECK(unit);/* not really needed. just to aviod coverity defect */

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors 
          || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* The BCM_COSQ_THRESHOLD_OCB flag is used to configure One Way Bypass thresholds.
       This feature is supported only from jer2_aradplus */
    if(SOC_IS_ARAD_B1_AND_BELOW(unit)){
        if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, using flag BCM_COSQ_THRESHOLD_OCB is supported only for jer2_aradplus and above\n"), unit));
        }
    }

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | 
                                         BCM_COSQ_THRESHOLD_INGRESS | 
                                         BCM_COSQ_THRESHOLD_UNICAST |
                                         BCM_COSQ_THRESHOLD_MULTICAST | 
                                         BCM_COSQ_THRESHOLD_SET | 
                                         BCM_COSQ_THRESHOLD_CLEAR | 
                                         BCM_COSQ_THRESHOLD_DROP | 
                                         BCM_COSQ_THRESHOLD_OCB | 
                                         BCM_COSQ_THRESHOLD_POOL0 | 
                                         BCM_COSQ_THRESHOLD_POOL1);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    DNX_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* retrieve information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_drop_get,(unit, core_id, &drop_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (SOC_IS_QAX(unit)) {
        switch (threshold->type) {
            case bcmCosqThresholdDbuffs:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Set global free SRAM-Buffers */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram[1][threshold->dp],threshold->flags,threshold->value);
                    DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram_only[1][threshold->dp],threshold->flags,threshold->value);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdDbuffs must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptorBuffers:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Set global free SRAM-PDBs */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram[0][threshold->dp],threshold->flags,threshold->value);
                    DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram_only[0][threshold->dp],threshold->flags,threshold->value);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptorsBuffers must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdBundleDescriptorBuffers:
                /* Set global free DRAM-BDBs */
                DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_dram[threshold->dp],threshold->flags,threshold->value);
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

    } else {
        /* Jericho2 TBD: delete all lines under 'else' - not relevant */
        if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
            /* Set unicast dbuffs thresholds */
            if (SOC_IS_JERICHO(unit)) {
                /* GET OUT - in jer2_jericho all ocb dbuffs are MC */
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all Dram data buffers are MC - setting threshold for unicast Dram data buffers is redundant"), unit));
            }

            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.unicast[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
            /* Set full multicast dbuffs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.full_mc[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
            /* Set mini multicast dbuffs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mini_mc[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Set bds thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_bds[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Set bds thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bds[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Set bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_bdbs[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Set bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bdbs[threshold->dp],threshold->flags,threshold->value);
        }

        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->flags & BCM_COSQ_THRESHOLD_OCB && 
            threshold->type == bcmCosqThresholdBytes) {
            /* Set bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_mem_excess[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
                   !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
                   threshold->type == bcmCosqThresholdBytes) {
            /* Set bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mem_excess[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs))
        {
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
            {
                if (SOC_IS_JERICHO(unit)) 
                {
                    /* GET OUT - in jer2_jericho all ocb dbuffs are MC */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all OCB data buffers are MC - setting threshold for unicast OCB data buffers is redundant"), unit));
                }

                /* Set OCB unicast dbuffs thresholds */
                DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_uc[threshold->dp], threshold->flags, threshold->value);
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                /* Set OCB full multicast dbuffs thresholds */
                DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_mc[threshold->dp], threshold->flags, threshold->value);
            }
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0)) {
            DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_shrd_pool[0][threshold->dp], threshold->flags, threshold->value);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
            DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.mix_shrd_pool[0][threshold->dp], threshold->flags, threshold->value);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1)) {
            DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_shrd_pool[1][threshold->dp], threshold->flags, threshold->value);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
            DNX_COSQ_THRESHOLD_HYST_SET(unit, drop_info.mix_shrd_pool[1][threshold->dp], threshold->flags, threshold->value);
        }
    }

    /* Set information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_drop_set,(unit, core_id, &drop_info, &exact_drop_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_DROP_TH drop_info;
    uint32 relevant_flags, threshold_type_flags, dnx_sand_rc;
    int threshold_count;
    int core_id = BCM_CORE_ALL;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(gport);
    BCM_DNX_UNIT_CHECK(unit);/* not really needed. just to aviod coverity defect */

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | 
                                         BCM_COSQ_THRESHOLD_INGRESS | 
                                         BCM_COSQ_THRESHOLD_UNICAST |
                                         BCM_COSQ_THRESHOLD_MULTICAST | 
                                         BCM_COSQ_THRESHOLD_SET | 
                                         BCM_COSQ_THRESHOLD_CLEAR | 
                                         BCM_COSQ_THRESHOLD_DROP | 
                                         BCM_COSQ_THRESHOLD_OCB |
                                         BCM_COSQ_THRESHOLD_POOL0 | 
                                         BCM_COSQ_THRESHOLD_POOL1);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    DNX_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* retrieve information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_drop_get,(unit, core_id, &drop_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
         
    if (SOC_IS_QAX(unit)) {
        switch (threshold->type) {
            case bcmCosqThresholdDbuffs:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Get global free SRAM-Buffers */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram[1][threshold->dp]);
                    DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram_only[1][threshold->dp]);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdDbuffs must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptorBuffers:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Get global free SRAM-PDBs */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram[0][threshold->dp]);
                    DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram_only[0][threshold->dp]);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptorsBuffers must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdBundleDescriptorBuffers:
                DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_dram[threshold->dp]);
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

    } else {
        /* Jericho2 TBD: delete all lines under 'else' - not relevant */
        if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
            /* Get unicast dbuffs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.unicast[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
            /* Get full multicast dbuffs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.full_mc[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
            /* Get mini multicast dbuffs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mini_mc[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Get bds thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_bds[threshold->dp]);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Get bds thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bds[threshold->dp]);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) &&
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Get bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_bdbs[threshold->dp]);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
                   !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
                   threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Get bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bdbs[threshold->dp]);
        }
        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) &&
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) &&
            threshold->flags & BCM_COSQ_THRESHOLD_OCB &&
            threshold->type == bcmCosqThresholdBytes){
            /* Get OCB bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_mem_excess[threshold->dp]);
        } else  if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBytes) {
            /* Get bdbs thresholds */
            DNX_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mem_excess[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs))
        {
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
            {
                if (SOC_IS_JERICHO(unit)) 
                {
                    /* GET OUT - in jer2_jericho all ocb dbuffs are MC */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all OCB data buffers are MC - can't get threshold for unicast OCB data buffers"), unit));
                }

                /* Set OCB unicast dbuffs thresholds */
                DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_uc[threshold->dp]);
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                /* Set OCB full multicast dbuffs thresholds */
                DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_mc[threshold->dp]);
            }
        }
        
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0)) {
            DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_shrd_pool[0][threshold->dp]);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
            DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.mix_shrd_pool[0][threshold->dp]);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1)) {
            DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.ocb_shrd_pool[1][threshold->dp]);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
            DNX_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.mix_shrd_pool[1][threshold->dp]);
        }
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Verify params given to APIs configuring scheduled voq ocb thresholds (per port)
*/
static int
_bcm_dnx_cosq_voq_rate_class_ocb_threshold_verify(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint8 is_set,
                                                    bcm_cosq_threshold_t *threshold)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if (SOC_IS_QAX(unit) && (threshold->flags & BCM_COSQ_THRESHOLD_OCB)) { 
        /* 
           OCB eligibility doesn't exist is JER2_QAX.
           Return UNAVAIL when calling the following with the flag BCM_COSQ_THRESHOLD_OCB:
           bcm_cosq_gport_threshold_set(unit,voq_gport, cosq, threshold);
        */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("BCM_COSQ_THRESHOLD_OCB flag is not supported")));
        
    }
    if (!(threshold->type == bcmCosqThresholdBytes
        || threshold->type == bcmCosqThresholdDbuffs)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_OCB | BCM_COSQ_THRESHOLD_UNICAST))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    if (is_set){
        if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) &&
            (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Both of the flags SET and CLEAR are set"), unit));
        }
    }
    if (!(DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    /*verify vsq_category if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC){
        if (threshold->tc < 0 || threshold->tc > DNX_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), threshold->flags ));
        }
    } 
    /*verify tc if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY){
        if (threshold->vsq_category < 0 || threshold->vsq_category >= DNX_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), threshold->vsq_category));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
* Purpose: 
* Set scheduled voq ocb thresholds (per rate class)
*/
static int
_bcm_dnx_cosq_rate_class_ocb_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    BCMDNX_INIT_FUNC_DEFS;
    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc = _bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);
   
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    BCMDNX_NULL_CHECK(threshold);

    rc =_bcm_dnx_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*set relevant data int the rate class data*/
    rc = _bcm_dnx_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*2. configure HW*/
    rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_cls,&exact_data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);        


    /* 
     * Note: No SW Update of ocb voq eligible 
     * This udate is done by passing a queue gport type with flags BCM_COSQ_THRESHOLD_IGNORE_VALUE, since we must know what qid should be configured                                                                                                                                                                             );
     * dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[threshold->tc][threshold->vsq_category].voq_eligible)));
     * DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
     */
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* ignore value only of a voq (per port)
*/
static int
_bcm_dnx_cosq_voq_ocb_threshold_ignore_value_set(int unit,
                                                   int qid,
                                                   int tc,
                                                   int vsq_category) 
{
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_cls;
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    int rate_class;
    int core = BCM_CORE_ALL;
    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("OCB eligiblity is not configured in Jericho.")));
    }
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    /*verify tc and vaq_category if they are specified directly*/
    if (tc < 0 || tc >= DNX_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), tc));
    }
    if (vsq_category < 0 || vsq_category >= DNX_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), vsq_category));
    }
    rc = _bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, &rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
* Purpose: 
* Set scheduled voq ocb thresholds (per port)
*/
static int
_bcm_dnx_cosq_voq_ocb_threshold_set(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    int is_allocated, is_last;
    int new_rate_cls, old_rate_cls;
    int base_queue, qid;
    int tc, vsq_category;
    uint32 dnx_sand_rc;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
        BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
    }

    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UCAST_QUEUE_GROUP_QID_GET(gport); 
    } else /* BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) */
    {
        base_queue = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x) core out of range %d"), unit, gport, core));
    }
    /* Verify */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }
    qid = base_queue + cosq;

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else {
        tc = cosq;
        threshold->tc = tc;
    }

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
    {
        /* get vsq category */
        rc = _bcm_dnx_cosq_vsq_category_get(unit, core, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
        threshold->vsq_category = vsq_category;
    }

    if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        rc = _bcm_dnx_cosq_voq_ocb_threshold_ignore_value_set(unit, qid, tc, vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* SW Update */
        /* Old data get */
        rc = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /*if !queue_to_rate_class_mapping_is_simple only configure ocb_voq_eligible_dynamic_set ignoring threshold->value, else reconfigure the OCB using threshold->value*/
        rc =_bcm_dnx_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
        BCMDNX_IF_ERR_EXIT(rc);


        /*set relevant data int the rate class data*/
        rc = _bcm_dnx_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Update information in SW */
        rc = _bcm_dnx_am_template_queue_rate_cls_exchange(unit,core,qid,&data_rate_cls,&old_rate_cls,&is_last,&new_rate_cls,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Commit Changes in HW according to given thresholds */
        if (is_allocated) {
            rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,new_rate_cls,&data_rate_cls,&exact_data_rate_cls);
            BCMDNX_IF_ERR_EXIT(rc);        
        }
        /* Set new mapping */
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit,core,qid,BCM_DNX_COSQ_RATE_CLS,new_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Get scheduled voq rate class ocb thresholds (per port)
*/
static int
_bcm_dnx_cosq_rate_class_ocb_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_cls;
    int tc;
    int vsq_category;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc =_bcm_dnx_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* data get */
    rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    tc = threshold->tc;
    vsq_category = threshold->vsq_category;

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[0]
                 * DNX_DEVICE_DNX_COSQ_OCB_16BYTES_RESOLUTION;
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[0];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(data_rate_cls.ocb_info[tc][vsq_category].voq_eligible == TRUE)
    {
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_CLEAR);
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_SET);
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Get scheduled voq ocb thresholds (per port)
*/
static int
_bcm_dnx_cosq_voq_ocb_threshold_get(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_cls;
    int base_queue, qid;
    int tc;
    int vsq_category;
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;
    uint32 is_voq_eligible = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));

    /* Verify */
    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    rc =_bcm_dnx_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport); 
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else /* BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) */
    {
        base_queue = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
        core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport);
    }
    qid = base_queue + cosq;

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else 
    {
        tc = cosq;
    }

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
    {
        /* get vsq category */
        rc = _bcm_dnx_cosq_vsq_category_get(unit, core, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (queue_to_rate_class_mapping_is_simple != JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rc = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* data get */
        rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
    {
        /* data get */
        rc = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[0]
                 * DNX_DEVICE_DNX_COSQ_OCB_16BYTES_RESOLUTION;
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[0];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if (SOC_IS_JERICHO(unit)) {
        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_voq_is_ocb_eligible_get,(unit, core, qid, &is_voq_eligible));
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        is_voq_eligible = data_rate_cls.ocb_info[tc][vsq_category].voq_eligible;
    }

    if (is_voq_eligible) {
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_CLEAR);
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_SET);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * VSQ rate class exchange set commit includes allocation management and HW.
 */
static int
_bcm_dnx_cosq_vsq_rate_class_exchange_set(int unit,
                                            int core_id,
                                            DNX_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dnx_cosq_vsq_rate_class_info_t *data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    bcm_dnx_cosq_vsq_rate_class_info_t exact_data_rate_class, cleared_data_rate;
    int new_rate_class,is_allocated,old_rate_class,is_last;   
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type = DNX_TMC_ITM_VSQ_GROUP_LAST_JER2_ARAD;    
    uint32 vsq_index = 0;
    uint8 is_ocb_only;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));
    sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));    

    /* Convert global2group */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_global2group,(unit, vsq_id, &dnx_tmcvsq_type, &vsq_index, &is_ocb_only)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_DNX_UNIT_CHECK(unit);

    /* Update information in SW */
    rc = _bcm_dnx_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, new_rate_class, dnx_tmcvsq_type, data_rate_class, &exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(&exact_data_rate_class, data_rate_class, sizeof(exact_data_rate_class));
    }

    /* Set new mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_qt_rt_cls_set,(unit, core_id, is_ocb_only, dnx_tmcvsq_type, vsq_index, new_rate_class)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, old_rate_class, dnx_tmcvsq_type, &cleared_data_rate, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    rc = _bcm_dnx_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, &exact_data_rate_class, &old_rate_class,&is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, new_rate_class, dnx_tmcvsq_type, &exact_data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    
    /* Set new mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_qt_rt_cls_set,(unit, core_id, is_ocb_only, dnx_tmcvsq_type, vsq_index, new_rate_class)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, old_rate_class, dnx_tmcvsq_type, &cleared_data_rate, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }    

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_vsq_fc_threshold_set(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq, 
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    DNX_TMC_ITM_VSQ_FC_INFO fc_info,exact_fc_info;
    uint32 threshold_type_flags, dnx_sand_rc;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = BCM_DNX_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int flag_count;   
    uint8 is_ocb_only = FALSE;
    bcm_dnx_cosq_vsq_rate_class_fc_info_t* fc;
    int pool_id;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);
    DNX_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);

    /* basic consistency checks */
    threshold_type_flags = (flags);

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none flags should be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (SOC_IS_JERICHO(unit)) {
        if ((pfc_threshold->xon_threshold != 0) || (pfc_threshold->xoff_threshold != 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, xon_threshold %d  and xoff_threshold %d can be only 0"), unit,
                pfc_threshold->xon_threshold, pfc_threshold->xoff_threshold));
        }
    }
    /* Convert to VSQ type & VSQ ID */
    /* retrieve vsq index */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    BCM_DNX_UNIT_CHECK(unit);

    /* Get Rate class data */
    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    for (pool_id = 0; pool_id < DNX_TMC_ITM_NOF_RSRC_POOLS; ++pool_id) {
        fc = bcm_dnx_cosq_vsq_rate_class_fc_data_get(unit, dnx_tmcvsq_type, pool_id, &data_rate_class);
        /* Set unicast dbuffs thresholds */
        fc->queue_size.set = pfc_threshold->xoff_threshold;
        fc->queue_size.clear = pfc_threshold->xon_threshold;

        /* Set bdbs thresholds */
        fc->bd_size.set = pfc_threshold->xoff_threshold_bd;
        fc->bd_size.clear = pfc_threshold->xon_threshold_bd;
    }

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_dnx_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_fc_threshold_get(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq, 
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;    
    int core_id = BCM_CORE_ALL;
    uint32 threshold_type_flags, dnx_sand_rc;
    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = BCM_DNX_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;     
    int flag_count;       
    bcm_dnx_cosq_vsq_rate_class_fc_info_t* fc;

    BCMDNX_INIT_FUNC_DEFS;
    /* basic consistency checks */
    threshold_type_flags = (flags);

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none flags should be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    /* Convert to VSQ type & VSQ ID */
    /* retrieve vsq index */
    rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    BCM_DNX_UNIT_CHECK(unit);
    /* Get Rate class data */
    rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
    fc = bcm_dnx_cosq_vsq_rate_class_fc_data_get(unit, dnx_tmcvsq_type, 0, &data_rate_class);
         
    /* Get unicast dbuffs thresholds */
    pfc_threshold->xoff_threshold = fc->queue_size.set;
    pfc_threshold->xon_threshold =  fc->queue_size.clear;

    /* Get bds thresholds */
    pfc_threshold->xoff_threshold_bd = fc->bd_size.set;
    pfc_threshold->xon_threshold_bd =  fc->bd_size.clear;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_fc_thresh_set(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_FC_TH fc_info, exact_fc_info;
    uint32 relevant_flags, dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, function is supported only for jer2_jericho\n"), unit));
    }

    /* Validate threshold types */
    if(SOC_IS_QAX(unit)) {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdPacketDescriptors
            || threshold->type == bcmCosqThresholdPacketDescriptorBuffers
            || threshold->type == bcmCosqThresholdBytes)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    } else {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdFullDbuffs
            || threshold->type == bcmCosqThresholdMiniDbuffs 
            || threshold->type == bcmCosqThresholdBufferDescriptors )) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    }

    /* Validate threshold flags */
    if(SOC_IS_QAX(unit)) {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_HEADROOM | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    } else {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_MULTICAST | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    }

    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    /* Validate threshold param */
    if (threshold->priority != BCM_COSQ_HIGH_PRIORITY && threshold->priority != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }

    DNX_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* Retreive information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_get,(unit, &fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Set bdbs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Set mini multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mini_mc, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Set full multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
        (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set OCB dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdPacketDescriptorBuffers)) {
        /* Set OCB pdbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_pdb, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set OCB pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_p0, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set OCB pool 1 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_p1, threshold->priority, threshold->flags, threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set MIX pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mix_p0, threshold->priority, threshold->flags, threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set MIX pool 1 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mix_p1, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 0 packet descriptors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0_pd, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 1 packet descriptors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1_pd, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 0 bytes thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0_byte, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 1 bytes thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1_byte, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdDbuffs)) { 
        /* Set sram headroom dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.hdrm, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdPacketDescriptors)) { 
        /* Set sram headroom packet descritpors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.hdrm_pd, threshold->priority, threshold->flags, threshold->value);
    }

    /* Set information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_set,(unit, &fc_info, &exact_fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_fc_thresh_get(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_FC_TH fc_info;
    uint32 relevant_flags, dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, function is supported only for jer2_jericho\n"), unit));
    }

    /* Validate threshold types */
    if(SOC_IS_QAX(unit)) {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdPacketDescriptors
            || threshold->type == bcmCosqThresholdPacketDescriptorBuffers
            || threshold->type == bcmCosqThresholdBytes)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    } else {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdFullDbuffs
            || threshold->type == bcmCosqThresholdMiniDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptors)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    }

    /* Validate flags */
    if(SOC_IS_QAX(unit)) {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_HEADROOM | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    } else {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_MULTICAST | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    }

    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) && (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_SET and BCM_COSQ_THRESHOLD_CLEAR cannot be used together\n"), 
            unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    /* Validate threshold param */
    if (threshold->priority != BCM_COSQ_HIGH_PRIORITY && threshold->priority != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }

    DNX_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* Retreive information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_get,(unit, &fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Get bdbs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.bdbs);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Get mini multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mini_mc);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Get full multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.full_mc);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
        (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Get OCB dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdPacketDescriptorBuffers)) {
        /* Set OCB pdbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_pdb);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get OCB pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_p0);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get OCB pool 1 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_p1);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get MIX pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mix_p0);
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, BCM_COSQ_THRESHOLD_CLEAR, fc_info.mix_p0);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get MIX pool 1 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mix_p1);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 1 dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 0 packet descriptors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0_pd);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 1 packet descriptors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1_pd);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 0 bytes thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0_byte);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 1 bytes thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1_byte);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->flags & bcmCosqThresholdDbuffs)) { 
        /* Set sram headroom dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.hdrm);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->flags & bcmCosqThresholdPacketDescriptors)) { 
        /* Set sram headroom packet descritpors thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.hdrm_pd);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_FC_TH fc_info,exact_fc_info;
    uint32 relevant_flags, threshold_type_flags, dnx_sand_rc;
    int flag_count;       

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);
    DNX_TMC_ITM_GLOB_RCS_FC_TH_clear(&exact_fc_info);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* basic consistency checks */
    threshold_type_flags = (flags & 
                           (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_MULTICAST));

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag can be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    /* retrieve information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_get,(unit,&fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Set unicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Set full multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    /* Set bdbs thresholds */
    DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold_bd);
    DNX_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold_bd);

    /* Set information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_set,(unit,&fc_info,&exact_fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_GLOB_RCS_FC_TH fc_info;
    uint32 relevant_flags, dnx_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(pfc_threshold);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    DNX_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* retrieve information */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_glob_rcs_fc_get,(unit,&fc_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Get unicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.unicast);
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.unicast);
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Get full multicast dbuffs thresholds */
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.full_mc);
        DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.full_mc);
    }

    /* Get bdbs thresholds */
    DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold_bd,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.bdbs);
    DNX_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold_bd,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.bdbs);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int bcm_dnx_cosq_gport_vsq_create(
    int unit, 
    bcm_cosq_vsq_info_t *vsq_info, 
    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = BCM_DNX_COSQ_VSQ_NOF_TYPES;    


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(vsq_info);
    BCMDNX_NULL_CHECK(vsq_gport);

    /* basic consistency checks */
    if (SOC_IS_JERICHO(unit) && (vsq_info->flags == BCM_COSQ_VSQ_LLFC || vsq_info->flags == BCM_COSQ_VSQ_PFC)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq flags 0x%x for VSQ types BCM_COSQ_VSQ_LLFC and BCM_COSQ_VSQ_PFC are not supported in Jericho"), unit, vsq_info->flags));
    }
    if (vsq_info->flags > BCM_COSQ_VSQ_PFC) {
        /* No information required */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq flags 0x%x"), unit, vsq_info->flags));
    }
    if (vsq_info->flags == BCM_COSQ_VSQ_PP || vsq_info->flags == BCM_COSQ_VSQ_LLFC || vsq_info->flags == BCM_COSQ_VSQ_PFC) {
        if (!SOC_IS_QAX(unit)) {
            /* PDM extended mode is mandatory for ST-VSQ, LLFC-VSQ, PFC-VSQ */
            
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            if (SOC_DNX_CONFIG(unit)->jer2_arad->init.dram.pdm_mode != JER2_ARAD_INIT_PDM_MODE_REDUCED) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, 
                                    (_BSL_BCM_MSG("PDM extended mode must be set in order to use ST-VSQ, LLFC-VSQ, PFC-VSQ.\n")));
            }
#endif 
        }
    }
    if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
        if (vsq_info->pp_vsq_id > SOC_DNX_CONFIG(unit)->pdm_extension.max_st_vsq) {
            LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit,
                    "ST-VSQ ID %d is higher than the maximum ST-VSQ ID %d in the PDM extension.\n"), vsq_info->pp_vsq_id, SOC_DNX_CONFIG(unit)->pdm_extension.max_st_vsq));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }

    /* Validate VSQ Info */
    rc = _bcm_dnx_cosq_vsq_info_verify(unit, vsq_info);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* retrieve VSQ group */
    rc = _bcm_dnx_cosq_gport_vsq_get_group_type(unit, vsq_info, &vsq_group_type);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Set VSQ gport */
    rc = _bcm_dnx_cosq_gport_vsq_gport_set(unit, vsq_info, vsq_group_type, vsq_gport);
    BCMDNX_IF_ERR_EXIT(rc);  
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_src_vsqs_gport_add(
    int unit, 
    bcm_gport_t port, 
    bcm_cosq_src_vsqs_gport_config_t *config, 
    bcm_gport_t *src_port_vsq_gport, 
    bcm_gport_t *pg_base_vsq_gport)
{
    int pg_base = 0, src_port = 0;
    uint32 src_pp_port = 0;
    int core_id, core_index, pg_core_id;
    int src_port_vsq_index, src_port_vsq_core_id;
    int cosq = 0;
    uint32 tc_mapping = 0, found_tc_mapping[BCM_COSQ_VSQ_NOF_PG];
    uint32 pg_tc_bitmap = 0, default_pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int default_pg_tc_profile = 0, is_last = 0, new_pg_tc_profile = 0, is_allocated = 0;

    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG] = {0};

    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    DNX_TMC_ITM_VSQ_NDX vsq_id;
    DNX_TMC_ITM_VSQ_PG_PRM pg_prm;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    uint8 allocate = TRUE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(src_port_vsq_gport);
    BCMDNX_NULL_CHECK(pg_base_vsq_gport);
    BCMDNX_NULL_CHECK(config);

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_dnx_cosq_src_vsqs_gport_add() is not supported for this device type.")));
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this - not relevant anymore */
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
        if (SOC_DNX_CONFIG(unit)->jer2_arad->init.dram.pdm_mode != JER2_ARAD_INIT_PDM_MODE_REDUCED) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, 
                                (_BSL_BCM_MSG("PDM extended mode must be set in order to use SRC-VSQs.\n")));
        }
#endif 
    }

    if (config->numq <= 0 || config->numq > BCM_COSQ_VSQ_NOF_PG) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                            (_BSL_BCM_MSG("The numq %d value is out of range, valid range is 1-%d."), config->numq, BCM_COSQ_VSQ_NOF_PG));
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this - not relevant anymore */
        for (cosq = 0; cosq < config->numq; cosq++) {
            if (config->pg_attributes[cosq].ocb_only > 1) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "Invalid OCB Only value %d, PG offset %d.\n"), config->pg_attributes[cosq].ocb_only, cosq));

                DNXC_IF_ERR_EXIT(SOC_E_PARAM);
            }
        }
    }

    if (BCM_GPORT_IS_LOCAL(port)) {
        src_port = BCM_GPORT_LOCAL_GET(port);
    } else if (SOC_PORT_VALID(unit, port)) {
        src_port = port;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, 
                            (_BSL_BCM_MSG("Invalid port type %d."), port));
    }
    sal_memset(found_tc_mapping, 0xffffffff, sizeof(uint32[BCM_COSQ_VSQ_NOF_PG]));
    for (cosq = 0; cosq < config->numq; cosq++) {
        for (tc_mapping = 0; tc_mapping < DNX_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
            if (config->pg_attributes[cosq].cosq_bitmap & (0x1 << tc_mapping)) {
                if (found_tc_mapping[tc_mapping] != 0xffffffff) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Invalid cosq bitmap configuration. TC %d, Cannot be mapped to %d, and to %d.\n"), tc_mapping, found_tc_mapping[tc_mapping], cosq));
                    BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);

                }
                found_tc_mapping[tc_mapping] = cosq;
            }
        }
    }
    for (tc_mapping = 0; tc_mapping < DNX_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
        if (found_tc_mapping[tc_mapping] == 0xffffffff) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "Invalid cosq bitmap configuration. TC %d is not mapped.\n"), tc_mapping));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }
    for (cosq = 0; cosq < config->numq; cosq++) {
        if (config->pg_attributes[cosq].pool_id != 0 && config->pg_attributes[cosq].pool_id != 1) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "Invalid pool ID, PG offset %d, pool ID %d.\n"), cosq, config->pg_attributes[cosq].pool_id));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }
    /*Get the relavent core ID from the src_port*/
    rc = dnx_port_sw_db_local_to_pp_port_get(unit, src_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);
   
    if (src_pp_port > SOC_DNX_CONFIG(unit)->pdm_extension.max_pp_port) {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit,
                "Source PP-port %d is higher than the maximum PP-Port %d in the PDM extension.\n"), src_pp_port, SOC_DNX_CONFIG(unit)->pdm_extension.max_pp_port));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    
    if (SOC_IS_QAX(unit)) {
        /* 
         * No need to use alloc manager or WITH_ID flag, since VSQ-E/F gports
         * are mapped 1-1 to phy_port/phy_lane respectively.
         */
        uint32 phy_port = 0;
        uint32 phy_lane = 0;

        /* VSQ-E index is mapped 1-1 to NIF port */
        rc = dnx_port_sw_db_first_phy_port_get(unit, src_port, &phy_port);
        BCMDNX_IF_ERR_EXIT(rc);
        src_port_vsq_index = phy_port - 1; /* phy_port is one based */
        BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);

        /* PG-VSQ base is mapped 1-1 to serdes */
        DNXC_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_qsgmii_offsets_remove, (unit, phy_port, &phy_lane)));
        pg_base = phy_lane - 1;
        BCM_DNX_CORES_ITER(core_id, core_index) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.pg_numq.set(unit, core_index, pg_base, config->numq));
        }
        BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);
    } else {
        /* Jericho2 TBD: delete this section. not relevant anymore */
        /*If with ID - validate that the VSQ gport handles are legel*/
        if (config->flags & BCM_COSQ_GPORT_WITH_ID) {
            if (!BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(*src_port_vsq_gport)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("src_port_vsq_gport (%d) is not a VSQ src port handle"), *src_port_vsq_gport));
            }
            if (!BCM_COSQ_GPORT_IS_VSQ_PG(*pg_base_vsq_gport)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("pg_base_vsq_gport (%d) is not a VSQ PG handle"), *pg_base_vsq_gport));
            }
            src_port_vsq_index = BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(*src_port_vsq_gport);
            src_port_vsq_core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(*src_port_vsq_gport);
            if (src_port_vsq_core_id != core_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("src-port-VSQ-Core ID(%d) must be equal to source port core ID(%d)."), src_port_vsq_core_id, core_id));
            }
            pg_base = BCM_COSQ_GPORT_VSQ_PG_GET(*pg_base_vsq_gport);
            if (pg_base + config->numq >= DNX_TMC_ITM_VSQ_GROUPF_SZE(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("PG-base(%d) with size (%d) is out of range."), pg_base, config->numq));
            }
            pg_core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(*pg_base_vsq_gport);
            if (pg_core_id != core_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("PG-Core ID(%d) must be equal to source port core ID(%d)."), pg_core_id, core_id));
            }
            if (bcm_dnx_am_pg_check(unit, core_id, pg_base) == BCM_E_NOT_FOUND) {
                allocate = TRUE;
                /*Allocation management PG*/
                rc = bcm_dnx_am_pg_alloc(unit, core_id, DNX_SHR_TEMPLATE_MANAGE_SET_WITH_ID, config->numq, &pg_base);
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                int allocated_numq = 0;
                allocate = FALSE;
                /*validate numq*/
                rc = bcm_dnx_am_pg_get(unit, core_id, pg_base, &allocated_numq);
                BCMDNX_IF_ERR_EXIT(rc);

                if (config->numq != allocated_numq) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("Cannot allocate pg_base(%d) numq(%d), since it is allready allocated with numq(%d)."), 
                                         pg_base, config->numq, allocated_numq));
                }
            }
            /*configure a VSQ src port*/
            rc = bcm_dnx_am_vsq_src_port_alloc(unit, core_id, DNX_SHR_TEMPLATE_MANAGE_SET_WITH_ID, src_pp_port, &src_port_vsq_index);
            BCMDNX_IF_ERR_EXIT(rc);

        } else {
            allocate = TRUE;
            /*Allocation management PG*/
            rc = bcm_dnx_am_pg_alloc(unit, core_id, 0, config->numq, &pg_base);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);

            rc = bcm_dnx_am_vsq_src_port_alloc(unit, core_id, 0, src_pp_port, &src_port_vsq_index);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);
        }
    }
    /*mapping tc cosq_bitmaps to profile*/
    for (pg_tc_bitmap = 0, tc_mapping = 0; tc_mapping < DNX_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
        SHR_BITCOPY_RANGE(&pg_tc_bitmap, tc_mapping * 3, &found_tc_mapping[tc_mapping], 0, 3);
    }
    BCM_DNX_CORES_ITER(core_id, core_index) {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_index, src_pp_port, &default_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (allocate) {
            rc = _bcm_dnx_am_template_vsq_pg_tc_mapping_exchange(unit, core_index, pg_tc_bitmap, default_pg_tc_profile, &is_last, &new_pg_tc_profile, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_mapping_set ,(unit, core_index, src_pp_port, new_pg_tc_profile)));
            BCMDNX_IF_ERR_EXIT(rc); 

            if (is_allocated) {
                rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_set, (unit, core_index, new_pg_tc_profile, pg_tc_bitmap)));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            /*validate consistency*/
            rc = _bcm_dnx_am_template_vsq_pg_tc_mapping_profile_data_get(unit, core_id, default_pg_tc_profile, &default_pg_tc_bitmap);
            BCMDNX_IF_ERR_EXIT(rc);
            if (pg_tc_bitmap != default_pg_tc_bitmap) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("pg_base(%d) PG TC bitmap allready configured 0x%x, connot configure it to be 0x%x."), 
                                     pg_base, default_pg_tc_bitmap, pg_tc_bitmap));

            }
        }
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this section. ocb_only is not relevant anymore */
        if (allocate) {
            /*Configure*/
            for (cosq = 0; cosq < config->numq; cosq++) {
                ocb_only_array[cosq] = config->pg_attributes[cosq].ocb_only;
            }

            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_ocb_set ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            /*validate consistency*/
            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_ocb_get ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);

            for (cosq = 0; cosq < config->numq; cosq++) {
                if (ocb_only_array[cosq] != config->pg_attributes[cosq].ocb_only) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("pg_base(%d) OCB-only value for ofsset %d is %d, cannot set it to be %d."), 
                                         pg_base, 
                                         cosq, 
                                         ocb_only_array[cosq],
                                         config->pg_attributes[cosq].ocb_only));
                }
            }
        }
    }

    /*configure a VSQ src port to VSQ PG mapping*/
    for (cosq = 0; cosq < config->numq; cosq++) {
        BCM_DNX_CORES_ITER(core_id, core_index) {
            DNX_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

            if (SOC_IS_QAX(unit)) {
                /* In JER2_QAX PG-params are per PG-VSQ */
                pg_prm.pool_id = config->pg_attributes[cosq].pool_id;
                pg_prm.is_lossles = config->pg_attributes[cosq].is_lossles;
                pg_prm.use_min_port = TRUE;

                rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pb_prm_set, (unit, pg_base + cosq, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                /* Jericho2 TBD: delete this section */
                /* In Jericho and below PG params are per rate class */
                rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(BCM_DNX_COSQ_VSQ_TYPE_PG,&dnx_tmcvsq_type);
                BCMDNX_IF_ERR_EXIT(rc);

                DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL (unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, pg_base + cosq, config->pg_attributes[cosq].ocb_only, &vsq_id)));

                /* Get Rate class data */
                rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_index, vsq_id, &data_rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                if (allocate) {
                    /*Configure*/
                    data_rate_class.pg.prm.pool_id = config->pg_attributes[cosq].pool_id;
                    data_rate_class.pg.prm.is_lossles = config->pg_attributes[cosq].is_lossles;
                    data_rate_class.pg.prm.use_min_port = TRUE;

                    /* Find new profile according to given settings and commit changes */
                    rc = _bcm_dnx_cosq_vsq_rate_class_exchange_set(unit, core_index, vsq_id, &data_rate_class);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    /*validate consistency*/
                    if (data_rate_class.pg.prm.pool_id != config->pg_attributes[cosq].pool_id) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                            (_BSL_BCM_MSG("pg_base(%d) Pool-ID for ofsset %d is %d, cannot set it to be %d."), 
                                             pg_base,
                                             cosq,
                                             data_rate_class.pg.prm.pool_id,
                                             config->pg_attributes[cosq].pool_id));
                    }
                    if (data_rate_class.pg.prm.is_lossles != config->pg_attributes[cosq].is_lossles) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                            (_BSL_BCM_MSG("pg_base(%d) Pool-ID for ofsset %d is %d, cannot set it to be %d."), 
                                             pg_base,
                                             cosq,
                                             data_rate_class.pg.prm.is_lossles,
                                             config->pg_attributes[cosq].is_lossles));
                    }
                }
            }
        }
    }

    /*Map port to PG*/
    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_src_vsqs_mapping_set ,(unit, core_id, src_pp_port, src_port_vsq_index, pg_base, TRUE)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_dnx_cosq_src_vsqs_gport_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
    int pg_base = -1;
    uint32 src_pp_port = 0;
    int src_local_port = 0;
    int core_id, core_index;
    int cosq = 0, numq = 0;
    uint32 pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int old_pg_tc_profile = 0, is_last = 0, new_pg_tc_profile = 0, is_allocated = 0;
    int src_port_vsq_index;
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG], ocb_only;
    bcm_cosq_vsq_info_t vsq_info;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("_bcm_dnx_cosq_src_vsqs_gport_destroy() is not supported for this device type.")));
    }

    if (BCM_GPORT_IS_LOCAL(vsq_gport)) { 
        src_local_port = BCM_GPORT_LOCAL_GET(vsq_gport);
    } if (SOC_PORT_VALID(unit, vsq_gport)) {
        src_local_port = vsq_gport;
    } else if (BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(vsq_gport) || BCM_COSQ_GPORT_IS_VSQ_PG(vsq_gport)) {
        rc = _bcm_dnx_cosq_vsq_info_get(unit, vsq_gport, &vsq_info);
        BCMDNX_IF_ERR_EXIT(rc);
        src_local_port = vsq_info.src_port;
    } else {   
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                            (_BSL_BCM_MSG("Invalid VSQ type %d."), vsq_gport));
    }
    rc = dnx_port_sw_db_local_to_pp_port_get(unit, src_local_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_src_vsqs_mapping_get ,(unit, core_id, src_pp_port, &src_port_vsq_index, &pg_base, &enable)));
    BCMDNX_IF_ERR_EXIT(rc);
    if (!enable) {
        BCM_EXIT;
    }

    /* In JER2_QAX we didn't allocate, so no need to deallocate */
    if (!SOC_IS_QAX(unit)) {
        rc = bcm_dnx_am_vsq_src_port_free(unit, core_id, src_port_vsq_index);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    for (ocb_only = 0; ocb_only < 2; ocb_only++) {
        /*Map to default rate class*/
        rc = _bcm_dnx_cosq_gport_vsq_rate_class_destroy(unit, core_id, src_port_vsq_index, BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT, ocb_only);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Destroy VSQ, src_pp_port==-1 indicates to destroy */
    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_src_vsqs_mapping_set ,(unit, core_id, src_pp_port, src_port_vsq_index, pg_base, FALSE)));
    BCMDNX_IF_ERR_EXIT(rc);

    /* In JER2_QAX we didn't allocate, so no need to deallocate */
    if (SOC_IS_QAX(unit)) {
        uint8 numq_get = 0;
        core_index = (core_id == BCM_CORE_ALL) ? 0 : core_id;
        DNXC_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.pg_numq.get(unit, core_index, pg_base, &numq_get));
        numq = numq_get;
    } else {
        rc = bcm_dnx_am_pg_get(unit, core_id, pg_base, &numq);
        BCMDNX_IF_ERR_EXIT(rc);

        /*Allocation management PG*/
        rc = bcm_dnx_am_pg_free(unit, core_id, pg_base);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    for (pg_tc_bitmap = 0, cosq = 0; cosq < numq; cosq++) {
        ocb_only_array[cosq] = FALSE;
    }
    if (!SOC_IS_QAX(unit)) {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_ocb_set ,(unit, core_id, pg_base, numq, ocb_only_array)));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    for (cosq = 0; cosq < numq; cosq++) {
        rc = _bcm_dnx_cosq_gport_vsq_rate_class_destroy(unit, core_id, pg_base + cosq, BCM_DNX_COSQ_VSQ_TYPE_PG, ocb_only_array[cosq]);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /*All TCs are mapped to offset 0, by defalt*/
    pg_tc_bitmap = 0;
    BCM_DNX_CORES_ITER(core_id, core_index) {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_index, src_pp_port, &old_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_am_template_vsq_pg_tc_mapping_exchange(unit, core_index, pg_tc_bitmap, old_pg_tc_profile, &is_last, &new_pg_tc_profile, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_mapping_set ,(unit, core_index, src_pp_port, new_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc); 

        if (is_allocated) {
            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_set, (unit, core_index, new_pg_tc_profile, pg_tc_bitmap)));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (SOC_IS_QAX(unit)) {
        /* In JER2_QAX PG-params are per PG-VSQ */
        DNX_TMC_ITM_VSQ_PG_PRM pg_prm;
        DNX_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

        for (cosq = 0; cosq < numq; cosq++) {
            rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pb_prm_set, (unit, pg_base + cosq, &pg_prm));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_src_vsqs_gport_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cosq_src_vsqs_gport_config_t *config, 
    bcm_gport_t *src_port_vsq_gport, 
    bcm_gport_t *pg_base_vsq_gport)
{
    int pg_base = 0, src_port = 0;
    uint32 src_pp_port = 0;
    int core_id, core_index;
    int cosq = 0;
    uint32 tc_mapping = 0, mapped_too;
    uint32 pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int pg_tc_profile = 0;
    int src_port_vsq_index = 0;
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG];

    DNX_TMC_ITM_VSQ_GROUP dnx_tmcvsq_type;
    DNX_TMC_ITM_VSQ_NDX vsq_id;
    DNX_TMC_ITM_VSQ_PG_PRM pg_prm;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(src_port_vsq_gport);
    BCMDNX_NULL_CHECK(pg_base_vsq_gport);
    BCMDNX_NULL_CHECK(config);

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_dnx_cosq_src_vsqs_gport_get() is not supported for this device type.")));
    }

    if (BCM_GPORT_IS_LOCAL(port)) {
        src_port = BCM_GPORT_LOCAL_GET(port);
    } else if (SOC_PORT_VALID(unit, port)) {
        src_port = port;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, 
                            (_BSL_BCM_MSG("Invalid port type %d."), port));
    }
    /*Get the relavent core ID from the src_port*/
    rc = dnx_port_sw_db_local_to_pp_port_get(unit, src_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_src_vsqs_mapping_get ,(unit, core_id, src_pp_port, &src_port_vsq_index, &pg_base, &enable)));
    BCMDNX_IF_ERR_EXIT(rc);
    if (!enable) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,  (_BSL_BCM_MSG("Source VSQs for core %d, PP port %d, do not exist."), core_id, src_pp_port));
    }
    /*configure a VSQ src port*/
    BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);
    BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);

    rc = bcm_dnx_am_pg_get(unit, core_id, pg_base, &(config->numq));
    BCMDNX_IF_ERR_EXIT(rc);

    /*mapping tc cosq_bitmaps to profile*/
    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_id, src_pp_port, &pg_tc_profile)));
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_am_template_vsq_pg_tc_mapping_profile_data_get(unit, core_id, pg_tc_profile, &pg_tc_bitmap);
    BCMDNX_IF_ERR_EXIT(rc);

    for (mapped_too = 0, tc_mapping = 0; tc_mapping < DNX_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++, mapped_too = 0) {
        SHR_BITCOPY_RANGE(&mapped_too, 0, &pg_tc_bitmap, tc_mapping * 3, 3);
        config->pg_attributes[mapped_too].cosq_bitmap |= (0x1 << tc_mapping);
    }
    if (!SOC_IS_QAX(unit)) {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_ocb_get ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    for (pg_tc_bitmap = 0, cosq = 0; cosq < config->numq; cosq++) {
        if (SOC_IS_QAX(unit)) {
            config->pg_attributes[cosq].ocb_only = 0;
        } else {
            config->pg_attributes[cosq].ocb_only = ocb_only_array[cosq];
        }
    }
    for (cosq = 0; cosq < config->numq; cosq++) {
        BCM_DNX_CORES_ITER(core_id, core_index) {
            DNX_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

            if (SOC_IS_QAX(unit)) {
                rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pb_prm_get, (unit, pg_base + cosq, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(BCM_DNX_COSQ_VSQ_TYPE_PG,&dnx_tmcvsq_type);
                BCMDNX_IF_ERR_EXIT(rc);

                DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL (unit,mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, pg_base + cosq, config->pg_attributes[cosq].ocb_only, &vsq_id)));

                /* Get Rate class data */
                rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_index, vsq_id, &data_rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                sal_memcpy(&pg_prm, &data_rate_class.pg.prm, sizeof(DNX_TMC_ITM_VSQ_PG_PRM));
            }

            config->pg_attributes[cosq].pool_id = pg_prm.pool_id;
            config->pg_attributes[cosq].is_lossles = pg_prm.is_lossles;            
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_vsq_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    bcm_dnx_cosq_vsq_rate_class_info_t vsq_rate_class_info;
    bcm_dnx_cosq_vsq_type_t vsq_group_type = BCM_DNX_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only_dummy /*It isn't relevent if the destroyed VSQ is ocb-only of dram-mixed, we destroy them together*/, 
        is_ocb_only, 
        use_ocb_only = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    /* 
     * Upon deleting VSQ, the following configuration taking place: 
     * 1. Remove WRED and tail drop settings, this is done by moving to default profile. 
     * 2. Remove from allocation management 
     */
     
    /* 1. Remove WRED and tail drop settings */
    sal_memset(&vsq_rate_class_info,0x0,sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));

    if (!(BCM_COSQ_GPORT_IS_VSQ(vsq_gport) || BCM_GPORT_IS_LOCAL(vsq_gport) || SOC_PORT_VALID(unit, vsq_gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport type")));
    }
    if (!(BCM_GPORT_IS_LOCAL(vsq_gport) || SOC_PORT_VALID(unit, vsq_gport))) {
        /* retrieve VSQ id */
        rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, vsq_gport, 0, &core_id, &is_ocb_only_dummy, &vsq_group_type, &vsq_index);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTCC || 
        vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTTC || 
        vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTGRY || 
        vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PP) {
        use_ocb_only = (1 + SOC_DNX_DEFS_GET(unit, vsq_ocb_only_support));
        for (is_ocb_only = 0; is_ocb_only < use_ocb_only; is_ocb_only++) {
            rc = _bcm_dnx_cosq_gport_vsq_rate_class_destroy(unit, core_id, vsq_index, vsq_group_type, is_ocb_only);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (SOC_IS_JERICHO(unit) && 
              (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT || 
               vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG || 
               BCM_GPORT_IS_LOCAL(vsq_gport) || 
               SOC_PORT_VALID(unit, vsq_gport))) {
        rc = _bcm_dnx_cosq_src_vsqs_gport_destroy(unit, vsq_gport);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_vsq_rate_class_destroy(
   int unit, 
   int core_id,
   int vsq_index,
   bcm_dnx_cosq_vsq_type_t vsq_group_type,
   uint8 ocb_only) 
{
    DNX_TMC_ITM_VSQ_GROUP 
        dnx_tmcvsq_type;
    DNX_TMC_ITM_VSQ_NDX 
        vsq_id = 0;
    bcm_error_t 
        rc = BCM_E_NONE;
    uint32 
        dnx_sand_rc;
    bcm_dnx_cosq_vsq_rate_class_info_t 
        vsq_rate_class_info,
        exact_vsq_rate_class_info;
    int 
        new_rate_class,
        is_allocated,
        old_rate_class,
        is_last;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }

    if (!(vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTCC || 
          vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTTC || 
          vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_CTGRY || 
          vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PP || 
          vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT ||
          vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG)) {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Cannot Configure rate class for VSQ group type %d."), vsq_group_type));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);

    }
    sal_memset(&vsq_rate_class_info, 0x0, sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));

    rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_index_group2global,(unit, dnx_tmcvsq_type, vsq_index, ocb_only, &vsq_id)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* 
     * shalitas: use funtion, _bcm_dnx_cosq_vsq_rate_class_exchange_set(int unit,int core_id,DNX_TMC_ITM_VSQ_NDX vsq_id,bcm_dnx_cosq_vsq_rate_class_info_t *data_rate_class); 
     * to reset rate class info, and use valid default values.
     */
    rc = _bcm_dnx_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, &vsq_rate_class_info, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, new_rate_class, dnx_tmcvsq_type, &vsq_rate_class_info, &exact_vsq_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Set new mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_qt_rt_cls_set, (unit, core_id, ocb_only, dnx_tmcvsq_type, vsq_index, new_rate_class)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&vsq_rate_class_info, 0x0, sizeof(bcm_dnx_cosq_vsq_rate_class_info_t));
        rc = _bcm_dnx_cosq_vsq_rate_class_hw_set(unit, old_rate_class, dnx_tmcvsq_type, &vsq_rate_class_info, &exact_vsq_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_resource_allocation_get(
    int unit, 
    uint32 flags, 
    bcm_cosq_resource_t resource, 
    bcm_cosq_allocation_entity_t *target, 
    bcm_cosq_resource_amounts_t *amounts)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_vsq_type_t vsq_group_type;
    DNX_TMC_ITM_VSQ_GROUP   dnx_tmcvsq_group;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    int vsq_index;
    uint8 is_ocb_only;
    int core_id;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dnx_cosq_vsq_rate_class_taildrop_info_t *headroom = NULL, *shared_pool = NULL;
    DNX_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    DNX_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(target);
    BCMDNX_NULL_CHECK(amounts);

    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_resource_allocation_get() is not supported for this device type.")));
    }
    if (resource != bcmReservationResourceBufferDescriptors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Resource must be bcmReservationResourceBufferDescriptors")));
    }
    if (target->color >= bcmColorPreserve) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target color(%d) out of range."), target->color));
    }
    if (target->pool_id >= DNX_TMC_ITM_NOF_RSRC_POOLS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target pool_id(%d) is out of range."), target->pool_id));
    }
    /*get mapping between VSQE and VSQF*/
    rc =_bcm_dnx_cosq_gport_vsq_gport_get(unit, target->gport, 0, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_PG && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ(%d) must be souce-port-VSQ or PG-VSQ"), target->gport));
    }

    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
        BCMDNX_IF_ERR_EXIT(rc);

        ingress_resource = target->is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram);
        amounts->reserved = ingress_resource->reserved;
        amounts->max_headroom = ingress_resource->headroom;
        amounts->max_shared_pool = (target->pool_id == 0) ? (ingress_resource->pool_0) : (ingress_resource->pool_1);
    } else { /* VSQE-F */
        rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_group);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_index_group2global, (unit, dnx_tmcvsq_group, vsq_index, target->is_ocb_only, &vsq_id));
        DNX_BCM_SAND_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Get reserved */
        if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT) {
            amounts->reserved = data_rate_class.port[target->pool_id].min_threshold[target->color];
        } else if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG) {
            amounts->reserved = data_rate_class.pg.min_threshold[target->color];
        }

        /* Get headroom and pool */
        headroom = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_group, target->pool_id, 1, &data_rate_class); 
        shared_pool = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_group, target->pool_id, 0, &data_rate_class); 

        /* if (resource == bcmReservationResourceBufferDescriptors) */
        amounts->max_headroom = headroom->max_size_bds[target->color];
        amounts->max_shared_pool = shared_pool->max_size_bds[target->color];
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_resource_allocation_set(
    int unit, 
    uint32 flags,
    bcm_cosq_resource_t resource, 
    bcm_cosq_allocation_entity_t *target, 
    bcm_cosq_resource_amounts_t *amounts)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_vsq_type_t vsq_group_type;
    DNX_TMC_ITM_VSQ_GROUP   dnx_tmcvsq_group;
    DNX_TMC_ITM_VSQ_NDX vsq_id = 0;
    int vsq_index;
    uint8 is_ocb_only;
    int core_id;
    bcm_dnx_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dnx_cosq_vsq_rate_class_taildrop_info_t *headroom = NULL, *shared_pool = NULL;
    bcm_color_t color, start_color, end_color;
    DNX_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    DNX_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    uint32 old_max_reserved = 0, new_max_reserved = 0;
    int reserve_change = 0;
    int32 reserve_change_array[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(target);
    BCMDNX_NULL_CHECK(amounts);
    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_resource_allocation_get() is not supported for this device type.")));
    }
    if (flags && !(flags & BCM_COSQ_RSRC_ALLOC_COLOR_BLIND)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be 0 or BCM_COSQ_RSRC_ALLOC_COLOR_BLIND")));
    }
    if (resource != bcmReservationResourceBufferDescriptors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Resource must be bcmReservationResourceBufferDescriptors")));
    }
    if (target->color >= bcmColorPreserve) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target color(%d) out of range."), target->color));
    }
    if (target->pool_id >= DNX_TMC_ITM_NOF_RSRC_POOLS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target pool_id(%d) is out of range."), target->pool_id));
    }
    if (amounts->max_shared_pool > DNX_TMC_ITM_VSQ_GRNT_BD_SIZE_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Max shared pool resource(%d) is out of range."), amounts->max_shared_pool));
    }
    if (amounts->max_headroom > DNX_TMC_ITM_VSQ_GRNT_BD_SIZE_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Max headroom resource(%d) is out of range."), amounts->max_headroom));
    }

    sal_memset(&reserve_change_array, 0x0, sizeof(reserve_change_array));

    /*get mapping between VSQE and VSQF*/
    rc =_bcm_dnx_cosq_gport_vsq_gport_get(unit, target->gport, 0, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_PG && vsq_group_type != BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ(%d) must be souce-port-VSQ, PG-VSQ or global-VSQ"), target->gport));
    }

    if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
        int thresh_type;

        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
        BCMDNX_IF_ERR_EXIT(rc);

        /* target->is_ocb_only is used for GL-VSQ. is_ocb_only is used for VSQE-F */
        ingress_resource = target->is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram);

        if (amounts->max_shared_pool + 
                ((target->pool_id == 0) ? (ingress_resource->pool_1) : (ingress_resource->pool_0)) + 
                amounts->max_headroom + 
                ingress_resource->reserved > ingress_resource->total) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Not enough free memory for new amounts in core %d"), core_id));
        }

        /*
         * If headroom is configured then the dynamic thresholds of VOQs
         * should be changed accordingly, because headroom resources
         * should be guaranteed.
         */
        
        for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
            reserve_change_array[core_id][thresh_type] = amounts->max_headroom - ingress_resource->headroom;
        }
        if (reserve_change_array[core_id][0] != 0) {
            rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core_id, target->is_ocb_only, reserve_change_array));
                BCMDNX_IF_ERR_EXIT(rc);
        }
        /* update pool and headroom is hw */
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_resource_allocation_set, (unit, core_id, target->pool_id, target->is_ocb_only, amounts->max_shared_pool, amounts->max_headroom));
        BCMDNX_IF_ERR_EXIT(rc);

    } else { /* VSQE-F */
        /* target->is_ocb_only is used for GL-VSQ. is_ocb_only is used for VSQE-F */
        if (target->is_ocb_only != is_ocb_only) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("target->is_ocb_only(%d) doesn't match the configured VSQ(0x%x) is_ocb_only(%d)"), target->is_ocb_only, target->gport, is_ocb_only));
        }

        rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &dnx_tmcvsq_group);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_index_group2global, (unit, dnx_tmcvsq_group, vsq_index, is_ocb_only, &vsq_id));
        DNX_BCM_SAND_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG) {
            if (data_rate_class.pg.prm.pool_id != target->pool_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target's pool_id(%d) must be equal to the allocated PG-VSQ(%d) pool_id(%d)"),
                            target->pool_id, target->gport, data_rate_class.pg.prm.pool_id));
            }

            if (data_rate_class.pg.prm.is_lossles == FALSE && amounts->max_headroom != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("PG-VSQ(%d) must be lossles in order to configure headroom"), target->gport));
            }

            /*
             * If reservation is configured, it needs to be taken from VSQF (i.e. use_min_port=FALSE).
             * If reservation is NOT configured, it needs to be taken from VSQE (i.e. use_min_port=TRUE).
             */
            if (amounts->reserved == 0) {
                data_rate_class.pg.prm.use_min_port = TRUE;
            } else {
                data_rate_class.pg.prm.use_min_port = FALSE;
            }
        }

        /* Configure max_headroom and max_shared_pool */
        headroom = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_group, target->pool_id, 1, &data_rate_class); 
        shared_pool = bcm_dnx_cosq_vsq_rate_class_taildrop_data_get(unit, dnx_tmcvsq_group, target->pool_id, 0, &data_rate_class); 

        if (flags & BCM_COSQ_RSRC_ALLOC_COLOR_BLIND) {
            /* Configure all colors the same */
            start_color = 0;
            end_color = DNX_DEVICE_COSQ_ING_NOF_DP;
        } else {
            /* Configure only specific color */
            start_color = target->color;
            end_color = target->color + 1;
        }

        for (color = start_color; color < end_color; ++color) {
            /* if (resource == bcmReservationResourceBufferDescriptors) */
            headroom->max_size_bds[color] = amounts->max_headroom;
            shared_pool->max_size_bds[color] = amounts->max_shared_pool;
        }

        /* Find old maximum reserved size of all colors in VSQ */
        old_max_reserved = _bcm_dnx_cosq_vsq_max_reserved_get(vsq_group_type, &data_rate_class);

        /* Configure reserved (guaranteed) size */
        for (color = start_color; color < end_color; ++color) {
            if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_SRC_PORT) {
                data_rate_class.port[target->pool_id].min_threshold[color] = amounts->reserved;
            } else if (vsq_group_type == BCM_DNX_COSQ_VSQ_TYPE_PG) {
                data_rate_class.pg.min_threshold[color] = amounts->reserved;
            }
        }

        /* Find the new maximum reserved size of all colors in VSQ */
        new_max_reserved = _bcm_dnx_cosq_vsq_max_reserved_get(vsq_group_type, &data_rate_class);

        /* update total reserved resources */
        reserve_change = new_max_reserved - old_max_reserved;
        rc = _bcm_dnx_cosq_vsq_total_reserve_update(unit, core_id, is_ocb_only, reserve_change);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Find new profile according to given settings and commit changes */
        rc = _bcm_dnx_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* In STRICT mode need to change also VOQ dynamic thresholds */
        if (SOC_DNX_CONFIG(unit)->jer2_jer->tm.cgm_mgmt_guarantee_mode == DNX_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
            int thresh_type;
            
            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                
                reserve_change_array[core_id][thresh_type] = reserve_change;
            }
            if (reserve_change_array[core_id][0] != 0) {
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core_id, is_ocb_only, reserve_change_array));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Following are the symantics of this call
 *    - sched_port => parent element
 *    - input_port => child element
 *    - cosq       => child element cosq
 */
int
bcm_dnx_cosq_gport_attach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dnx_cosq_gport_info_t        *child_info ;
    bcm_dnx_cosq_gport_info_t        *parent_info ;
    int                              child_mode = 0, flow_id_index, flow_id, i, orig_sub_flow0_id, orig_sub_flow1_id;
    bcm_dnx_cosq_class_info_t        info;
    int                              weight = 0, updated_type;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    DNX_TMC_SCH_FLOW                     exact_flow_config;
    uint32                           dnx_sand_rc, region, nof_remote_cores;   
    bcm_gport_t                      parent_port;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, dummy_tc;
    int                             core ;
    DNX_TMC_SCH_SE_ID               sw_state_default_se;
    uint32                          sw_state_ref_cnt;

    
    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, sched_port, 0, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for sched_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)sched_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on JER2_QAX*/
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &sched_port, core);
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &input_port, core);
    }
    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, sched_port, 0, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* 
     * Note: API does not support parent of type Port-TC. User that wants
     * to attach Port-TC object. Call first handle_get and receieve scheduler gport.
     */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, API does not support Port-TC obejects gport: 0x%x \n"), unit, parent_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* Validate parent and child elements are not exact. In that case we cant attach parent to input when parent = input */
    if (parent_port == input_port) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, attach cant be done when parent 0x%x equals input port 0x%x\n"), unit, parent_port,input_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* validate parent element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, parent_port, -1, dnx_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* validate child element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, input_port, cosq, dnx_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info->is_se) {
        rc = _bcm_dnx_cosq_se_id2port(unit,core,parent_info->se_id,&parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving port id from SE %d, error 0x%x\n"), unit, parent_info->se_id, rc));
            goto err;
        }
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( (parent_info->is_se) &&
                        ( (parent_se_port != DNX_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info->se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.get(unit, core, child_info->actual_flow_id, &child_mode));

    /* get parent element information for child hookup corresponding to child scheduling mode */
    rc = _bcm_dnx_cosq_credit_class_info_get(unit, core, parent_info->se_config, child_mode, &info);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d core %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x\n"), unit, core, rc));
        goto err;
    }

    /* retrieve child element weight */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, child_info->actual_flow_id, &weight));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "Unit(%d) flow_id(%d), Weight(%d)\n"),
                         unit, child_info->actual_flow_id, weight));
    
    weight = (info.weight_mode == DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) ? weight :
                       ((info.weight_mode == DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) ? 0 : weight);

    rc = _bcm_dnx_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in adjusting flow type for weight/weight mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* hookup hierarchy */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    cs_info->se_type = parent_info->se_config->type;
    cs_info->id = parent_info->se_config->id;
    switch (cs_info->se_type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            cs_info->se_info.hr.sp_class = updated_type;
            cs_info->se_info.hr.weight = weight;
            break;

        case DNX_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;

        default:
            break;
    }

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);

        child_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    if(!child_info->is_connector) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_group_set,(unit, core, child_info->se_id, child_info->se_config, child_info->flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting se %d group, dnx_sand error 0x%x, error 0x%x\n"), unit, child_info->se_id, dnx_sand_rc, rc));
             goto err;
        }
    }

    /* increment reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, (parent_info->se_config)->id, &sw_state_ref_cnt));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, (parent_info->se_config)->id, sw_state_ref_cnt + 1));
    }
    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info) ;
        }
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info) ;
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info) ;
    }
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info) ;
    }
/* } */
#endif
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}
int
bcm_dnx_cosq_gport_detach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    /* consistency checks */
    if (!(BCM_COSQ_GPORT_IS_E2E_PORT(sched_port) || BCM_GPORT_IS_SCHEDULER(sched_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(sched_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(sched_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), sched_port));
    }

    if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(input_port) ||
          BCM_COSQ_GPORT_IS_COMPOSITE_SF2(input_port) || BCM_GPORT_IS_SCHEDULER(input_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(input_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(input_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), input_port));
    }


    rc = _bcm_dnx_cosq_sched_connector_gport_detach(unit, sched_port, input_port, cosq);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_parent_get(int unit,
                                    bcm_gport_t child_port,
                                    bcm_cos_queue_t cos,
                                    bcm_gport_t *parent_port)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dnx_cosq_gport_info_t        *child_info ;
    bcm_dnx_cosq_gport_info_t        *parent_info;
    int                              flow_id_index;
    int                              flow_id, base_flow_id;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE   *cs_info;
    DNX_TMC_SCH_SE_ID                    se_id;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, tc;
    bcm_gport_t                      parent_tmp, fap_port;
    int                              core ;
    DNX_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, child_port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for child_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)child_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on JER2_QAX*/
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &child_port, core);
    }

    /* validate child element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, child_port, cos, dnx_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* Retrieve hierarchy parent */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;  
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    se_id = cs_info->id;
    flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));

    /* Retrieve scheduler information */
    BCM_GPORT_SCHEDULER_CORE_SET(parent_tmp,flow_id,core);

    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, parent_tmp, 0, dnx_device_cosq_gport_sched_nocirpir_ds_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* Get port id in case SE is parent */
    rc = _bcm_dnx_cosq_se_id2port(unit, core, se_id, &parent_se_port, &tc);
    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, Error retreving port id from SE %d\n"), unit,se_id));          
      goto err;
    } 

    /* Validate SE is parent */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( ( (parent_se_port != DNX_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    /* In case SE is not parent: validate someone is referenced to it */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
    if ((!is_parent_reserved_res) && sw_state_ref_cnt <= DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Parent SE(%d) reference count is 0\n"),
                              unit, se_id));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* Default se is not attached to anyone */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id == sw_state_default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not attached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }


    /* In case SE is parent return different gport */
    if (!is_parent_reserved_res) {
        /* Validated parent scheduler. Set parent gport */
        flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
        if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on JER2_QAX (32k on QUX) flow range, as the user would expect*/
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
        }
        if (parent_info->is_dual == FALSE) {
            /* Non dual, just set scheduler gport */
            BCM_GPORT_SCHEDULER_CORE_SET((*parent_port), flow_id, core);
        } else {
            /* return base flow id with either CIR gport (CL) or PIR gport (FQ) */
            base_flow_id = (flow_id - (flow_id & 0x3)); 
            if ( (parent_info->se_config->type == DNX_TMC_SCH_SE_TYPE_FQ) ||
                   (parent_info->se_config->type == DNX_TMC_SCH_SE_TYPE_HR) ) {
                BCM_COSQ_GPORT_SCHED_PIR_CORE_SET((*parent_port), base_flow_id, core);
            } else if (parent_info->se_config->type == DNX_TMC_SCH_SE_TYPE_CL) {
                BCM_COSQ_GPORT_SCHED_CIR_CORE_SET((*parent_port), base_flow_id, core);
            }
        }
    } else {
        /* Set parent gport to be Port gport */
        if (tc == DNX_COSQ_PB_DEFAULT_PORT_TC) {
            /* In case of TC = 0 or Petra-B compatible TC returns E2E */
            rc = bcm_dnx_tm_port_get(unit, core, parent_se_port, &fap_port);
            if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, Error retreving port id from SE %d\n"), unit,parent_se_port));          
              goto err;
            }
            BCM_COSQ_GPORT_E2E_PORT_SET(*parent_port, fap_port);
        } else {
            /* In case of Port-TC return SCHEDULER gport */
            flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
            if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on JER2_QAX (32k on QUX) flow range, as the user would expect*/
                flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
            }
            BCM_GPORT_SCHEDULER_CORE_SET((*parent_port), flow_id, core);  
        }
    }   

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info);
    }
/* } */
#endif
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_link_fc_shaper_verify(int unit,
                                   bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (cosq != 0)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, cosq));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
 

int
_bcm_dnx_link_fc_shaper_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    uint32 dnx_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    DNX_TMC_FABRIC_FC_SHAPER info;
    DNX_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper); 
    DNX_TMC_FABRIC_FC_SHAPER_clear(&info);
    
    link_ndx = SOC_DNX_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_dnx_link_fc_shaper_verify(unit, cosq);  
    BCMDNX_IF_ERR_EXIT(rc);        

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, dnx_sand error 0x%x\n"), unit, link_ndx, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }  
        
    if (*flags & BCM_COSQ_BW_LLFC)
    {
        /* LLFC shaper */
        if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.fc_shaper.bytes;
            *kbits_sec_min = 0;
        }    
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.fc_shaper.cells;
            *kbits_sec_min = 0;            
        }
    }
    else
    {
        /* Data shaper */
        if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.data_shaper.bytes;
            *kbits_sec_min = 0;
        }
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.data_shaper.cells;
            *kbits_sec_min = 0;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_link_fc_shaper_add(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    uint32 dnx_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    DNX_TMC_FABRIC_FC_SHAPER info;
    DNX_TMC_FABRIC_FC_SHAPER exact_info;
    DNX_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper);
    DNX_TMC_FABRIC_FC_SHAPER_clear(&info);
    DNX_TMC_FABRIC_FC_SHAPER_clear(&exact_info);

    link_ndx = SOC_DNX_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_dnx_link_fc_shaper_verify(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);        

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    
    if(DNX_SAND_FAILURE(dnx_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, dnx_sand error 0x%x\n"), unit, link_ndx, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }    

    if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_BYTES_MODE) 
    {
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.bytes = kbits_sec_max;
        } 
        else 
        {
            info.data_shaper.bytes = kbits_sec_max;
        }
    }
    /* Currently shaper cell mode is not supported */
    if (shaper.shaper_mode == DNX_TMC_FABRIC_SHAPER_CELLS_MODE) 
    {        
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.cells = kbits_sec_max;
        } 
        else
        {
            info.data_shaper.cells = kbits_sec_max;
        }
    }
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_shaper_set,(unit, link_ndx, &shaper, &info, &exact_info)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, failed to set link %d flow control shaper parameters, dnx_sand error 0x%x\n"), unit, link_ndx, dnx_sand_rc));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_egress_port_scheduler_pps_to_kbps(int unit, int core, uint32 pps, uint32 *kbps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *kbps = pps*num_of_bytes_per_packet*8/1000;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_egress_port_scheduler_kbps_to_pps(int unit, int core, uint32 kbps, uint32 *pps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *pps = (kbps*1000)/(8*num_of_bytes_per_packet);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_bandwidth_set(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_port_t port;
    bcm_gport_t parent_port;
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, gport, 1, &parent_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {       
        rc =  _bcm_dnx_link_fc_shaper_add(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(parent_port) 
        || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(parent_port)
        || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(parent_port)) {
        rc = _bcm_dnx_cosq_gport_fmq_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
      rc = _bcm_dnx_cosq_gport_isq_bandwidth_set(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }    
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(parent_port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(parent_port))) {   
        rc = _bcm_dnx_cosq_gport_flow_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(parent_port)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(parent_port);

        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            rc = _bcm_dnx_cosq_gport_e2e_interface_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_dnx_cosq_gport_e2e_port_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(parent_port)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    /* Egress transmit scheduler */

    else if (BCM_GPORT_IS_LOCAL(parent_port) || BCM_GPORT_IS_MODPORT(parent_port)) {
        if (BCM_GPORT_IS_LOCAL(parent_port)) {
            port = BCM_GPORT_LOCAL_GET(parent_port);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(parent_port);
        }        


        if (BCM_DNX_PORT_IS_INTERFACE(port)) {        
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);           
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(parent_port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(parent_port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int port = 0;
    bcm_gport_t res_gport;
    

    BCMDNX_INIT_FUNC_DEFS;

    /* determine if gport refers to a pre-allocated resource */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, gport, 1, &res_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {
        rc =  _bcm_dnx_link_fc_shaper_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    }  

    /* Egress transmit scheduler */
    else if (BCM_GPORT_IS_LOCAL(res_gport) ||
         BCM_GPORT_IS_MODPORT(res_gport)) {

        if (BCM_GPORT_IS_LOCAL(res_gport)) {
            port = BCM_GPORT_LOCAL_GET(res_gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(res_gport);
        }        
        
        if (BCM_DNX_PORT_IS_INTERFACE(port)) {  
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }   

    else if (BCM_COSQ_GPORT_IS_PORT_TC(res_gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(res_gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        rc = _bcm_dnx_cosq_gport_fmq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
        rc = _bcm_dnx_cosq_gport_isq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* Ingress Scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }

    /* E2E scheduler */
    else if ( (BCM_GPORT_IS_SCHEDULER(res_gport)) ||
              (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(res_gport)) ) {
            rc = _bcm_dnx_cosq_gport_flow_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(res_gport)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(res_gport);

        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            rc = _bcm_dnx_cosq_gport_e2e_interface_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_dnx_cosq_gport_e2e_port_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(res_gport)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(res_gport)) {
        rc = _bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_size_set(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 bytes_min,
                        uint32 bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_size_get(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 *bytes_min,
                        uint32 *bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_color_size_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            rc = _bcm_dnx_cosq_gport_voq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }   
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_dnx_cosq_gport_vsq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }
    if (BCM_GPORT_IS_PROFILE(gport)) {
            rc = _bcm_dnx_cosq_gport_rate_class_color_size_get(unit,gport,color,flags,gport_size);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_color_size_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            rc = _bcm_dnx_cosq_gport_voq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_dnx_cosq_gport_vsq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    } 
    if (BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_dnx_cosq_gport_rate_class_color_size_set(unit,gport,color,flags,gport_size);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

#ifdef CRASH_RECOVERY_SUPPORT 
    soc_dnxc_cr_suppress(unit,dnxc_cr_no_support_unknown);
#endif

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) ) {
        rc = _bcm_dnx_cosq_gport_voq_discard_set(unit, gport, cosq, discard);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_dnx_cosq_gport_vsq_discard_set(unit, gport, cosq, discard);
    }
    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_dnx_cosq_gport_rate_class_discard_set(unit, gport, discard);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_dnx_cosq_gport_voq_discard_get(unit, gport, cosq, discard);
    }

    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_dnx_cosq_gport_vsq_discard_get(unit, gport, cosq, discard);
    } 
    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_dnx_cosq_gport_rate_class_discard_get(unit, gport, discard);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_gport_ingress_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{

    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;


    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;
        
        vsq_type = BCM_DNX_COSQ_GPORT_VSQ_TYPE_GET(gport);
        if (vsq_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flag BCM_COSQ_THRESHOLD_NOT_COMMIT is not supported. flags 0x%x"), unit,threshold->flags));
            }
                    
            /* Drop Threshold set */
            if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                /* VSQ gl tail drop thresholds */
                rc = _bcm_dnx_cosq_vsq_gl_drop_threshold_set(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);                
            }

            /* Flow control set */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                /* VSQ gl fc thresholds */
                rc = _bcm_dnx_cosq_vsq_gl_fc_thresh_set(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,vsq_type));
        }        
    } else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)){
        if((threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
            rc = _bcm_dnx_cosq_voq_ocb_threshold_set(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_dnx_cosq_rate_class_ocb_threshold_set(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_egress_drop_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* null gport or core gport */
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) 
    {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
        {
            if(cosq == -1) 
            {
                rc = _bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_set(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }

        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) 
        {
            if(cosq == -1)
            {
                /* Device wide flow control mci threshold */                
                rc = _bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_set(unit, gport, cosq, threshold);           
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) {

            if(cosq == -1) {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_set(unit, gport, cosq, 0, threshold); 
            }
            else
            {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(unit, gport, cosq, 0, threshold); 
            }         
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1) {

            if(cosq == -1) {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_set(unit, gport, cosq, 1, threshold); 
            }
            else
            {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(unit, gport, cosq, 1, threshold); 
            }
            
        } else { /* i.e. set all */
            if(cosq == -1) {
                rc = _bcm_dnx_cosq_gport_egress_device_all_drop_threshold_set(unit, gport, cosq, threshold); 
            }
            else
            {
              BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);
         
    /* else - using specific gport */
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) { /* Egress UC Queue drop thresholds */
        rc = _bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold); 
        BCMDNX_IF_ERR_EXIT(rc);
    
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) { /* Egress MC Queue drop thresholds*/
        rc = _bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {

        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DNX_PORT_IS_INTERFACE(gport_lcl)) {       
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_interface_egress_threshold_set(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        }
                
        
    }
    else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d , Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_egress_sp_reserved_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc= BCM_E_NONE;

    int core_iterator, core, sp;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */
    
    if (!( threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    } 

    sp = (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) ? 0:1;  

    if (!(gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)))
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected core gport %x"), gport));
      

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_core_get(unit,gport, 1, &core_iterator));

    SOC_DNX_CORES_ITER(core_iterator, core)
    {      
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sp_reserved_set ,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCMDNX_IF_ERR_EXIT(rc); 
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_gport_egress_sp_reserved_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc= BCM_E_NONE;
    int core, sp;
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */
    
    if (!( threshold->type == bcmCosqThresholdAvailablePacketDescriptors
           || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    } 

    if (!(gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)))
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected core gport %x"), gport));

    sp = (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) ? 0 : 1; 
    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_core_get(unit,gport,0,&core));

    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sp_reserved_get ,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, &threshold->value, soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_gport_egress_fc_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    
    /* Egress device wide flow control */
    /* null gport equals 0 */
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            /* Device wide flow control sheduled threshold */
            rc = _bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_set(unit, gport, cosq, threshold); 
            
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {           
            /* Device wide flow control unscheduled threshold */                   
            rc = _bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_set(unit, gport, cosq, threshold);   
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){
            /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 0, threshold); 
                  
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){
            /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 1, threshold);                
        }
        else {
            /* Device wide flow control global threshold */
            rc = _bcm_dnx_cosq_gport_egress_device_all_fc_threshold_set(unit, gport, cosq, threshold); 
        }
    }
    /* Egress scheduler port, channelized issues: */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DNX_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_interface_egress_threshold_set(unit, gport, cosq, threshold);
        }
    }
    /* Egress UC Queue fc thresholds */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_set(unit, gport, cosq, threshold);
    }
    else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_gport_egress_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint8   traffic_en = 0;
    uint32  dnx_sand_rc = DNX_SAND_OK;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid flags %d"), unit ,threshold->flags));
    }

    /* Traffic Enabled Restriction */
    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors ||
       threshold->type == bcmCosqThresholdAvailableDataBuffers)
    {
      dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_enable_traffic_get,(unit, &traffic_en)));
      DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
      if(traffic_en == TRUE)
      {
        /* Check the override flag for allowing modifications during traffic */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing thresholds of %d is not allowed while traffic is enabled"), 
                                            unit ,threshold->type));
        }
      }
    }

    /* verify types per device */

    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_threshold_types_verify, (unit, (soc_dnx_cosq_threshold_type_t)threshold->type)));
    BCMDNX_IF_ERR_EXIT(rc);

    /*check cosq validity*/

    rc = _bcm_dnx_egress_cosq_validate(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Drop Threshold set */
    if (threshold->flags & BCM_COSQ_THRESHOLD_DROP)
    {
       rc = _bcm_dnx_cosq_gport_egress_drop_threshold_set(unit, gport, cosq, threshold);
       BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* Flow control set */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) 
    {
        rc = _bcm_dnx_cosq_gport_egress_fc_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    /* MC SP Reserved */
    else if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) || (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1))
    {
        rc = _bcm_dnx_cosq_gport_egress_sp_reserved_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_system_red_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    DNX_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;
    
    BCMDNX_INIT_FUNC_DEFS;
  
    DNX_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);    
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_glob_rcs_get,(unit, &info)));
    
    /* Set system RED Dbuff Thresholds/Values */
    if (threshold->type == bcmCosqThresholdDbuffs) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.unicast_rng_ths[0] = threshold->value;
            info.values.unicast_rng_vals[0]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.unicast_rng_ths[1] = threshold->value;
            info.values.unicast_rng_vals[1]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.unicast_rng_ths[2] = threshold->value;
            info.values.unicast_rng_vals[2]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.unicast_rng_vals[3]    = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdFullDbuffs) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.multicast_rng_ths[0] = threshold->value;
            info.values.multicast_rng_vals[0]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.multicast_rng_ths[1] = threshold->value;
            info.values.multicast_rng_vals[1]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.multicast_rng_ths[2] = threshold->value;
            info.values.multicast_rng_vals[2]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.multicast_rng_vals[3]    = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.bds_rng_ths[0] = threshold->value;
            info.values.bds_rng_vals[0]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.bds_rng_ths[1] = threshold->value;
            info.values.bds_rng_vals[1]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.bds_rng_ths[2] = threshold->value;
            info.values.bds_rng_vals[2]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.bds_rng_vals[3]   = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbDbuffs) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.ocb_rng_ths[0] = threshold->value;
            info.values.ocb_rng_vals[0]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.ocb_rng_ths[1] = threshold->value;
            info.values.ocb_rng_vals[1]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.ocb_rng_ths[2] = threshold->value;
            info.values.ocb_rng_vals[2]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.ocb_rng_vals[3]   = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else {
        /* Must use one of these threshold type  */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
    } 
    
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_glob_rcs_set,(unit, &info)));      
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_rci_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_rci_threshold_set, 
                                      (unit, gport, threshold->value, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_rci_threshold_set, 
                                      (unit, gport, threshold->value, soc_dnx_cosq_gport_egress_core_fifo_local_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
    
    }
    
exit:
    BCMDNX_FUNC_RETURN;

}

int
_bcm_dnx_cosq_gport_per_dp_drop_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        dnx_soc_cosq_threshold_t soc_threshold;
        soc_threshold.value = threshold->value;
        soc_threshold.dp = threshold->dp;
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_set,
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_set, 
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_set, 
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_local_mcast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
       }
   }
   
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_gport_eth_port_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_port_t port = 0;
    DNX_TMC_FC_PORT_FIFO_TH fc_fifo_th;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        if (BCM_GPORT_IS_LOCAL(gport)) {
            port = BCM_GPORT_LOCAL_GET(gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(gport);
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, port));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_port_fifo_threshold_get,(unit, port, &fc_fifo_th)));

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
        /* set RX PORT FIFO Link Level Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
            fc_fifo_th.llfc.set = threshold->value;
        }
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            fc_fifo_th.llfc.clear = threshold->value;
        }
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
        /* set RX PORT FIFO Priority Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
            fc_fifo_th.pfc.set = threshold->value;
        }
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            fc_fifo_th.pfc.clear = threshold->value;
        }
    }

    /* Set information */
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_port_fifo_threshold_set, (unit, port, &fc_fifo_th)));
   
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_dnx_cosq_gport_threshold_set(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(threshold);
    /* Ingress tresholds */
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) 
    {
        rc = _bcm_dnx_cosq_gport_ingress_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS)
    {
        rc = _bcm_dnx_cosq_gport_egress_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED)
    {
        rc = _bcm_dnx_cosq_gport_system_red_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);

    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI) 
    {
        rc = _bcm_dnx_cosq_gport_rci_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);

    }

    else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP)) 
    {
        rc =  _bcm_dnx_cosq_gport_per_dp_drop_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC))
    {
        rc = _bcm_dnx_cosq_gport_eth_port_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else 
    {/* i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_gport_ingress_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;
        
        vsq_type = BCM_DNX_COSQ_GPORT_VSQ_TYPE_GET(gport);
        if (vsq_type == BCM_DNX_COSQ_VSQ_TYPE_GLOBAL) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported flags 0x%x"), unit,threshold->flags));
            }
                    
            /* Drop Threshold get */
            if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                /* VSQ gl tail drop thresholds */
                rc = _bcm_dnx_cosq_vsq_gl_drop_threshold_get(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);                
            }

            /* Flow control get */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                /* vsq gl flow control thresholds */
                rc = _bcm_dnx_cosq_vsq_gl_fc_thresh_get(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,gport));
        }        
    } else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)){
        if((threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
            rc = _bcm_dnx_cosq_voq_ocb_threshold_get(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        } 
    } else if (BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_dnx_cosq_rate_class_ocb_threshold_get(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);  
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_egress_drop_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
  
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            if(cosq == -1) 
            {
                rc = _bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_get(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
            if(cosq == -1) 
            {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_get(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){            
            if(cosq == -1) 
            {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_get(unit, gport, cosq, 0, threshold);
            }
            else
            {
                rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(unit, gport, cosq, 0, threshold); 
            }
        } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){     
                if(cosq == -1) 
                {
                    rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_get(unit, gport, cosq, 1, threshold); 
                }
                else
                {
                    rc = _bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(unit, gport, cosq, 1, threshold); 
                }
        }
        else
        {/* i.e all*/ 
            if(cosq == -1) 
            {
                rc = _bcm_dnx_cosq_gport_egress_device_all_drop_threshold_get(unit, gport, cosq, threshold);
            }
            else {
               BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }

        } 
    /* Egress UC Queue drop thresholds */
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold);         
    /* Egress MC Queue drop thresholds*/
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold); 
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DNX_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_interface_egress_threshold_get(unit, gport, cosq, threshold);
        }
    } else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);  
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_egress_fc_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /* Egress device wide flow control */
    /* gport 0 equals gport null */
    if (gport == 0  || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
        {
            /* Device wide flow control sheduled threshold */
            rc = _bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_get(unit, gport, cosq, threshold); 
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) 
        {
                /* Device wide flow control unscheduled threshold */
            rc = _bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_get(unit, gport, cosq, threshold);                       
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0)
        {
                /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 0, threshold);   
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1)
        {
                /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 1, threshold);
        }       
        else 
        {
            /* Device wide flow control global threshold */
            rc = _bcm_dnx_cosq_gport_egress_device_all_fc_threshold_get(unit, gport, cosq, threshold);
        }
    }
    /* Egress scheduler port, channelized issues */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DNX_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_gport_interface_egress_threshold_get(unit, gport, cosq, threshold);
        }
        else
        {
            /* Egress scheduler port */
        }
     }
        
    /* Egress UC Queue fc thresholds */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_get(unit, gport, cosq, threshold);
    }

    else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_egress_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /*check cosq validity*/

    rc = _bcm_dnx_egress_cosq_validate(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /*verify types per device */

    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_threshold_types_verify, (unit, (soc_dnx_cosq_threshold_type_t)threshold->type)));
    BCMDNX_IF_ERR_EXIT(rc);

    /* Drop Threshold get */
    if (threshold->flags & BCM_COSQ_THRESHOLD_DROP)
    {
        rc = _bcm_dnx_cosq_gport_egress_drop_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Flow control get */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) 
    {
        rc = _bcm_dnx_cosq_gport_egress_fc_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* MC SP Reserved */
    else if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) || (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1))
    {
        rc = _bcm_dnx_cosq_gport_egress_sp_reserved_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }        
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_gport_system_red_threshold_get(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               bcm_cosq_threshold_t *threshold)
{
    DNX_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;
   
    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_glob_rcs_get,(unit, &info)));

    /* Set system RED Dbuff Thresholds/Values */
    if (threshold->type == bcmCosqThresholdDbuffs) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.unicast_rng_ths[0];
            threshold->dp    = info.values.unicast_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.unicast_rng_ths[1];
            threshold->dp    = info.values.unicast_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.unicast_rng_ths[2];
            threshold->dp    = info.values.unicast_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.unicast_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdFullDbuffs) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.multicast_rng_ths[0];
            threshold->dp    = info.values.multicast_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.multicast_rng_ths[1];
            threshold->dp    = info.values.multicast_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.multicast_rng_ths[2];
            threshold->dp    = info.values.multicast_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.multicast_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {

        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.bds_rng_ths[0];
            threshold->dp    = info.values.bds_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.bds_rng_ths[1];
            threshold->dp    = info.values.bds_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.bds_rng_ths[2];
            threshold->dp    = info.values.bds_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.bds_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbDbuffs) {

        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.ocb_rng_ths[0];
            threshold->dp    = info.values.ocb_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.ocb_rng_ths[1];
            threshold->dp    = info.values.ocb_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.ocb_rng_ths[2];
            threshold->dp    = info.values.ocb_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.ocb_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else {
        /* Must use one of these threshold type  */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_rci_threshold_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_rci_threshold_get, 
                                      (unit, gport, &(threshold->value), soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_rci_threshold_get, 
                                      (unit, gport, &(threshold->value), soc_dnx_cosq_gport_egress_core_fifo_local_ucast));
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_per_dp_drop_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        dnx_soc_cosq_threshold_t soc_threshold;
        sal_memset(&soc_threshold, 0x0, sizeof(soc_threshold));
        soc_threshold.dp = threshold->dp;
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dnx_cosq_gport_egress_core_fifo_local_mcast));
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
        threshold->value = soc_threshold.value;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_dnx_cosq_gport_eth_port_threshold_get(int unit,
                                                 bcm_gport_t gport,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_threshold_t *threshold)
{
    bcm_port_t port = 0;
    DNX_TMC_FC_PORT_FIFO_TH fc_fifo_th;
    BCMDNX_INIT_FUNC_DEFS;

    if ((threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) && (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_ETH_PORT_LLFC and BCM_COSQ_THRESHOLD_ETH_PORT_PFC cannot be used together\n"), 
            unit, threshold->flags));
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) && (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_SET and BCM_COSQ_THRESHOLD_CLEAR cannot be used together\n"), 
            unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        if (BCM_GPORT_IS_LOCAL(gport)) {
            port = BCM_GPORT_LOCAL_GET(gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(gport);
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, gport));
    }

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_port_fifo_threshold_get,(unit, port, &fc_fifo_th)));

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
        /* get RX PORT FIFO Link Level Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
            threshold->value = fc_fifo_th.llfc.set;
        }
        
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            threshold->value = fc_fifo_th.llfc.clear;
        }
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
        /* get RX PORT FIFO Priority Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
            threshold->value = fc_fifo_th.pfc.set;
        }
        
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            threshold->value = fc_fifo_th.pfc.clear;
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_dnx_cosq_gport_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) 
    {
        rc = _bcm_dnx_cosq_gport_ingress_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS)  
    {
        rc = _bcm_dnx_cosq_gport_egress_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED) 
    {
        rc = _bcm_dnx_cosq_gport_system_red_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI)
    {
        rc = _bcm_dnx_cosq_gport_rci_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))
    {
        rc = _bcm_dnx_cosq_gport_per_dp_drop_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC))
    {
        rc = _bcm_dnx_cosq_gport_eth_port_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {/*i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_dnx_cosq_gport_egress_map_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_queue_map_set(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

    

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_egress_map_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t *offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_queue_map_get(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_egress_multicast_config_set(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint8   traffic_en = 0;
    uint32  dnx_sand_rc = DNX_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    /* Traffic Enabled Restriction */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mgmt_enable_traffic_get,(unit, &traffic_en)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    if(traffic_en == TRUE)
    {
        /* Check the override flag for allowing modifications during traffic */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing MC TC mapping is not allowed while traffic is enabled"), unit));
        }
    }


    if((gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        rc = _bcm_dnx_cosq_device_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if ((BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) && (flags & BCM_COSQ_MULTICAST_SCHEDULED )) {
        rc = _bcm_dnx_cosq_gport_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_egress_multicast_config_get(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if(gport == 0 && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        rc = _bcm_dnx_cosq_device_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_dnx_cosq_gport_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_connection_set(int unit,
                                    bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t rc = BCM_E_NONE;
    int is_ingress = FALSE, is_egress = FALSE, is_remove = FALSE;
    int my_modid;
    int nbr_cos, nbr_quads, cur_quad, i;
    int base_qid, base_cid, base_cid_i, queue_region, flow_id, flow_id_i, flow_region, is_odd_even;
    uint8 sw_state_flags;

    uint8 is_non_contiguous, is_composite;
    DNX_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
    DNX_TMC_SCH_FLOW sch_flow;
    DNX_TMC_SCH_QUARTET_MAPPING_INFO quartet_flow_info;
    uint32 dnx_sand_rc, nof_remote_cores;
    int nbr_flow_quartets;
    int updated_base_cid;
    uint8 sw_state_num_cos;
    /*
     * Just load some initial value to be on the safe side. Overwritten below.
     */
    int ingress_core = 0 ;
    int egress_core = 0 ;
    int core_id = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport_connect parameter needs to be specified"), unit));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, flags (0x%x), remoteModid (%d)\n"), gport_connect->flags, gport_connect->remote_modid));

    if (gport_connect->flags & ~(BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS | BCM_COSQ_GPORT_CONNECTION_INVALID)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
    is_remove = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INVALID) ? TRUE : FALSE; 

    if ( (is_ingress == FALSE) && (is_egress == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flags parameter(0x%x) need to specify ingresss/egress"), unit, gport_connect->flags));
    }

    if ( (is_ingress == TRUE) && (is_egress == TRUE) ) {
        rc = bcm_dnx_stk_my_modid_get(unit, &my_modid);
        if (rc) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "my modid invalid bcm_dnx_stk_my_modid_get() rc=%s\n"), bcm_errmsg(rc)));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (gport_connect->remote_modid != my_modid) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, modid specified (%d) needs to be the local modid when ingress & egress are specified"), unit, gport_connect->remote_modid));
        }
    }

    if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast/isq gport 0x%x"), unit, gport_connect->voq));
    }
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
        ingress_core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
        ingress_core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
    } else {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
        ingress_core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_connect->voq);
    }
    if ((ingress_core < 0 || ingress_core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && ingress_core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x) core out of range %d"), unit, gport_connect->voq, ingress_core));
    }
    if (ingress_core == BCM_CORE_ALL && !SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x), connot map both VOQs in assymetric mode."), unit, gport_connect->voq));
    }
    if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector gport 0x%x"), unit, gport_connect->voq_connector));
    }
    egress_core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;
    base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);
    if (SOC_IS_QAX(unit) && is_egress) {
        base_cid = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, base_cid);
    }
    if (is_ingress == TRUE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,ingress_core , base_qid), &sw_state_num_cos));
    }
    else { /* is_egress */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, egress_core, base_cid, &sw_state_num_cos));
    }

    nbr_cos = sw_state_num_cos;
    if (nbr_cos > 8) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) cid(%d) internal state get error\n"), unit, base_cid));
        BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
    }
 
    nbr_quads = BCM_DEVICE_DNX_COSQ_QUEUE_QUAD_GET(nbr_cos);    

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Base_CID (0x%x)\n"), base_cid));

    if (is_ingress) {
        SOC_DNX_CORES_ITER(ingress_core, core_id) {
            /* determine queue region mode */
            queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_qid);
            rc = _bcm_dnx_queue_region_config_get(unit, core_id, queue_region, &is_non_contiguous);
            BCMDNX_IF_ERR_EXIT(rc);

            DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_queue_to_flow_mapping_get,(unit, core_id, DNX_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving queue (%d) flow mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_qid, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            is_composite = queue_map_info.is_composite;


            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "  DBG, isNonContiguous %s, isComposite %s, nbrQuads(%d)\n"), 
                                  ((is_non_contiguous) ? "True" : "False"), ((is_composite) ? "True" : "False"), nbr_quads));

        
            updated_base_cid = base_cid;
            for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
                _bcm_dnx_flow_id_get(unit, core_id, updated_base_cid, cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET,
                                   is_non_contiguous, is_composite, is_remove, &flow_id);

                flow_id_i = SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit) ?
                            _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(flow_id, SOC_DNX_DEFS_GET(unit, nof_cores), core_id) :
                            flow_id;
                queue_map_info.flow_quartet_index = DNX_TMC_SCH_FLOW_TO_QRTT_ID(flow_id_i); 

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "  DBG, qQuartet %d, QueueMap (fQuartet %d, isComposite %d)\n"), 
                                      DNX_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))),
                           queue_map_info.flow_quartet_index, queue_map_info.is_composite));
                queue_map_info.is_modport = 1; /* In direct mapping mode, we should use the retrieved modport and not the sysport. Does not affect indirect mode. */

                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_set,
                    (unit, core_id, DNX_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))), &queue_map_info)));
                if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting queue (%d) flow mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), dnx_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCM_EXIT;
                }
            }
        }
    }

    if (is_egress) {

        flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_cid);
        rc = _bcm_dnx_flow_region_config_get(unit, egress_core, flow_region, &is_non_contiguous, &is_odd_even);
        BCMDNX_IF_ERR_EXIT(rc);

        DNX_TMC_SCH_FLOW_clear(unit, &sch_flow);
        DNX_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_get,(unit, egress_core, base_cid, &sch_flow)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving sch flow (%d), dnx_sand error 0x%x, error 0x%x\n"), unit, base_cid, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        if ( (sch_flow.sub_flow[0].is_valid == FALSE) && (sch_flow.sub_flow[1].is_valid == FALSE) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, ino sub flow enabled for sch flow (%d), dnx_sand error 0x%x, error 0x%x"), unit, base_cid, dnx_sand_rc, rc));
        } 

        is_composite = ((sch_flow.sub_flow[0].is_valid == TRUE) && (sch_flow.sub_flow[1].is_valid == TRUE)) ? TRUE : FALSE;

        _bcm_dnx_nbr_flow_quartets_for_queue_quartet(unit, is_non_contiguous, is_composite,
                                                                            &nbr_flow_quartets);

        nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[egress_core][flow_region];

        for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
            /* set all symmetric connections*/
            for (i = 0; i < nof_remote_cores; i++) {

                int local_cid, local_cid_quartet ;
                int other_cid, other_cid_quartet ;

                quartet_flow_info.base_q_qrtt_id = DNX_TMC_IPQ_Q_TO_QRTT_ID(base_qid + (cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET));
                quartet_flow_info.is_composite = is_composite;
                if (is_remove) {
                    quartet_flow_info.fip_id = DNX_TMC_MAX_FAP_ID; /* set to invalid modid */
                } else {
                    quartet_flow_info.fip_id = gport_connect->remote_modid + i; 
                }


                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "  DBG, fQuartet %d, nbrQuartets %d, FlowMap (qQuartet %d, isComposite %d, remoteModid %d)\n"), 
                                      DNX_TMC_SCH_FLOW_TO_QRTT_ID(base_cid) + (cur_quad * nbr_flow_quartets), nbr_flow_quartets,
                           
                           quartet_flow_info.base_q_qrtt_id, quartet_flow_info.is_composite, quartet_flow_info.fip_id));

                local_cid = base_cid + DNX_TMC_SCH_QRTT_TO_FLOW_ID(cur_quad * nbr_flow_quartets) ;
                /*
                 * Mark 'other' quartet as valid or not. See remark on 'other_quartet_is_valid'
                 * element in DNX_TMC_SCH_QUARTET_MAPPING_INFO.
                 */
                local_cid_quartet = DNX_TMC_SCH_FLOW_TO_QRTT_ID(local_cid) ;
                if (local_cid_quartet % 2) {
                    /*
                     * Odd cid quartet. Other should be the even one.
                     */
                    other_cid_quartet = local_cid_quartet - 1 ;
                } else {
                    /*
                     * Even cid quartet. Other should be the odd one.
                     */
                    other_cid_quartet = local_cid_quartet + 1 ;
                }
                other_cid = DNX_TMC_SCH_QRTT_TO_FLOW_ID(other_cid_quartet) ;
                quartet_flow_info.other_quartet_is_valid = 0 ;

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, other_cid, &sw_state_flags));
                    if (sw_state_flags & CONNECTION_IS_VALID_MASK) {
                        quartet_flow_info.other_quartet_is_valid = 1 ; ;
                    }
                /*
                 * Mark connectors group as invalid to start with. Update to 'valid'
                 * when operation succeeds.
                 */

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, local_cid, &sw_state_flags));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.set(unit, egress_core, local_cid, sw_state_flags & ~CONNECTION_IS_VALID_MASK));

                base_cid_i = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(base_cid, nof_remote_cores, i);
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_flow_to_queue_mapping_set,
                             (unit, egress_core, DNX_TMC_SCH_FLOW_TO_QRTT_ID(base_cid_i) + (cur_quad * nbr_flow_quartets),
                             nbr_flow_quartets, &quartet_flow_info)));
                if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting queue (%d) flow mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), dnx_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCM_EXIT;
                }
                /*
                 * Mapping was completed successfully. Mark connectors group as valid
                 * by reloading 'num_cos' by its original value.
                 */
                if (!is_remove) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, local_cid, &sw_state_flags));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.set(unit, egress_core, local_cid, sw_state_flags | CONNECTION_IS_VALID_MASK));
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_gport_connection_get(int unit,
                              bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t                       rc = BCM_E_NONE;
    uint32                            dnx_sand_rc;
    int                               flag_count;       
    int                               is_ingress, is_egress;
    
    int                               base_qid=0, base_cid=0;
    DNX_TMC_IPQ_QUARTET_MAP_INFO          queue_map_info;
    bcm_gport_t                       modport_gport, sysport_gport;
    DNX_TMC_SCH_QUARTET_MAPPING_INFO      quartet_flow_info;
    DNX_SAND_U32_RANGE                    queue_range;
    int                               queue_region;
    int                               is_multicast = FALSE, is_unicast = FALSE;
    int                               is_isq = FALSE, egress_core;
    int                               ingress_core = 0, core_id;
    DNX_TMC_ITM_INGRESS_SHAPE_INFO    isp_info;
    uint8                             sw_state_num_cos;
    uint8                             is_interdigitated;

    /*
     * Initialize, Just to have some value. Overwritten below.
     */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport_connect"), unit));
    }
 
    flag_count = _bcm_cosq_bit_count_get(gport_connect->flags);
    if (flag_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }
    if ((gport_connect->flags &
            (BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS)) == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
   
    if (is_ingress) {
        unsigned indirect_mode = 1;
        if (JER2_ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
            indirect_mode = 0;
        }
        if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
                         BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)
                          || BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast gport 0x%x"), unit, gport_connect->voq));
        }

        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
            ingress_core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_connect->voq) ;
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
            ingress_core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
        } else {
            base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
            ingress_core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_connect->voq);
        }
        /*
         * If extracted core is out of bounds then return with error.
         */
        if (ingress_core < 0 || ingress_core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) {
            int is_core_err = 1;
            if (SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit)) {
                if (ingress_core == BCM_CORE_ALL) { /* In symmetric mode core CAN be SOC_CORE_ALL */
                    is_core_err = 0;
                }
            }
            if (is_core_err) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Core (%d) is out of bounds"), unit, ingress_core));
            }
        }
        core_id = (ingress_core == BCM_CORE_ALL) ? 0 : ingress_core;
        /*
         * At this point, 'core' contains the right value for 'ingress' device.
         */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core_id , base_qid), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) internal state get error\n"), unit, base_qid));
            BCM_RETURN_VAL_EXIT(BCM_E_RESOURCE);
        }

        DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
            (unit, core_id, DNX_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_qid, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /*
         * Get 'core' (on egress device) from 'gport_connect->voq_connector'. It is not
         * supposed to contain any info (since it is the output of this procedure (in
         * this 'ingress' case) except for the 'core' of the egress device (which is
         * known to the caller but not to this procedure).
         */
        egress_core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;

        queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_qid);
        rc = _bcm_dnx_queue_region_config_get(unit, core_id, queue_region, &is_interdigitated);
        BCMDNX_IF_ERR_EXIT(rc);
  
        if (is_interdigitated) {
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport_connect->voq_connector, DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue_map_info.flow_quartet_index)+2, egress_core);
        } else {
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport_connect->voq_connector, DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue_map_info.flow_quartet_index), egress_core);
        }


        if (indirect_mode) {
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);

            rc = bcm_dnx_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
            BCMDNX_IF_ERR_EXIT(rc);

            gport_connect->remote_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
        } else { /* direct mapping mode */
            gport_connect->remote_modid = queue_map_info.fap_id; /* fap_id is actually mod_id */
        }
    }


    if (is_egress) {
        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq connector 0x%x"), unit, gport_connect->voq_connector));
        }
        base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);
        if (SOC_IS_QAX(unit)) {
            base_cid = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, base_cid);
        }
        /*
         * Get 'core' (on egress device) from 'gport_connect->voq_connector'. Caller is
         * assumed to have it set properly.
         */
        core_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;
        /*
         * If extracted core is out of bounds then return with error.
         */
        if ((core_id >= SOC_DNX_DEFS_GET(unit, nof_cores)) || (core_id < 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Core (%d) is out of bounds"), unit, core_id)) ;
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core_id, base_cid, &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }

        DNX_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_flow_to_queue_mapping_get,
            (unit, core_id, DNX_TMC_SCH_FLOW_TO_QRTT_ID(base_cid), &quartet_flow_info)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_qid, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        base_qid = DNX_TMC_IPQ_QRTT_TO_Q_ID(quartet_flow_info.base_q_qrtt_id);

        /* Get multicast queue id range */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_enhanced_get,(unit, core_id, &queue_range)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
            is_multicast = TRUE;
        }
        else {
            /* Get ISQ queue range */
            DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_get,(unit, core_id, &isp_info)));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

            if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
                is_isq = TRUE;
            } else {
                is_unicast = TRUE;
            }
        }

        if (is_multicast) {
            BCM_GPORT_MCAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_unicast) {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_isq) {
            BCM_COSQ_GPORT_ISQ_SET(gport_connect->voq, base_qid);
        }

        gport_connect->remote_modid = quartet_flow_info.fip_id;
    
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_port_mapping_multi_get(int unit, 
                                    bcm_port_t port,
                                    int count,
                                    bcm_cos_t *priority, 
                                    bcm_cos_queue_t *cosq)
{
    return BCM_E_UNAVAIL;
}

int
bcm_dnx_cosq_port_mapping_multi_set(int unit, 
                                    bcm_port_t port,
                                    int count,
                                    bcm_cos_t *priority, 
                                    bcm_cos_queue_t *cosq)
{
    return BCM_E_UNAVAIL;
}
int
bcm_dnx_cosq_port_mapping_set(int unit, 
                                bcm_port_t port,
                                bcm_cos_t priority, 
                                bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* FMQ mapping */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
            rc = _bcm_dnx_cosq_fmq_mapping_set(unit, port, priority, cosq);
#ifndef BCM_WARM_BOOT_SUPPORT /* With this flag the check has been already done */
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
#endif
    } else if (
      (BCM_GPORT_IS_SYSTEM_PORT(port) || 
       BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
       BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
       BCM_COSQ_GPORT_IS_ISQ(port))){

      rc = _bcm_dnx_cosq_ingress_tc_mapping_set(unit,port,priority,cosq);
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid Port")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_port_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /* FMQ mappin */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        rc = _bcm_dnx_cosq_fmq_mapping_get(unit, port, priority, cosq);
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
    } else if( 
              (BCM_GPORT_IS_SYSTEM_PORT(port) || 
               BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
               BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
               BCM_COSQ_GPORT_IS_ISQ(port))){
      rc = _bcm_dnx_cosq_ingress_tc_mapping_get(unit,port,priority,cosq);
    }
    else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, port));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_mapping_set(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* Validate */
    if (priority < 0 || priority >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    if (cosq < 0 || cosq > DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }

    /* Global mapping between PP TC and Ingress TC */
    /* By default: mapping is 1:1 */

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_traffic_class_map_set,(unit,priority,cosq)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_mapping_get(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    DNX_TMC_IPQ_TR_CLS ipq_tr_cls = 0;
        
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);    

    /* Validate */
    if (priority < 0 || priority >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_traffic_class_map_get,(unit,priority,&ipq_tr_cls)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *cosq = ipq_tr_cls;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_cosq_dnx_vsq_category_set(int unit,                                   
                                 int core_id,
                                 int range_type,
                                 DNX_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rv;
    int vsq_category_id;
    DNX_TMC_ITM_CATEGORY_RNGS info;
    int mode;
    BCMDNX_INIT_FUNC_DEFS;


    /* Clear */
    DNX_TMC_ITM_CATEGORY_RNGS_clear(&info);
    switch (range_type) {
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeMulticastQueue:
        vsq_category_id = 0;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeShaperQueue:
        vsq_category_id = 1;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeFabricQueue:
        vsq_category_id = 2;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRecycleQueue:
        vsq_category_id = 3;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories"), range_type));
    }
    
    /* Set new VSQ category range */ 
    rc = bcm_dnx_fabric_control_get(unit, bcmFabricVsqCategory, &mode);
    BCMDNX_IF_ERR_EXIT(rc); 

    if (mode == bcmFabricVsqCatagoryModeNone) {
        /* All VOQs are in the same category 2 except VOQs 0-3. */
        info.vsq_ctgry0_end = 3;
        info.vsq_ctgry1_end = 3;
        info.vsq_ctgry2_end = DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit);        
    } else if (mode == bcmFabricVsqCatagoryMode1 || mode == bcmFabricVsqCatagoryMode2) {

        dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_category_rngs_get,(unit, core_id, &info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);
    
        if (mode == bcmFabricVsqCatagoryMode2 && vsq_category_id != 2 && vsq_category_id != 0) {
            /* Nothing to do */
            BCM_EXIT;
        }

        BCM_DNX_UNIT_CHECK(unit);
        /* validate parameters */        
        if (queue_range->start > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("start of given range %d is out of range"), queue_range->start));
        }
        if (queue_range->end > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("end of given range %d is out of range"), queue_range->end));
        }
        if (queue_range->end < queue_range->start) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid vsq range given, range end %d is lower than start %d"),range_type, queue_range->start, queue_range->end));
        }

        switch (vsq_category_id) {
        case 0:
            info.vsq_ctgry0_end = queue_range->end;
            /* Align other categories accordingly */
            info.vsq_ctgry1_end = DNX_SAND_MAX(info.vsq_ctgry0_end, info.vsq_ctgry1_end);
            info.vsq_ctgry2_end = DNX_SAND_MAX(info.vsq_ctgry1_end, info.vsq_ctgry2_end);
            break;
        case 1:
            /* Take as previous end the range.start-1 only if different to zero, otherwise start-1 returns -1 */
            info.vsq_ctgry0_end = DNX_SAND_MAX(DNX_SAND_MAX(queue_range->start, 1) - 1, 0);
            info.vsq_ctgry1_end = queue_range->end;
            /* Align other categories accordingly */            
            info.vsq_ctgry2_end = DNX_SAND_MAX(info.vsq_ctgry1_end, info.vsq_ctgry2_end);   
            /* update new range */
            queue_range->start = info.vsq_ctgry0_end + 1; 
            queue_range->end = info.vsq_ctgry1_end; 
            break;        
        case 2:
            info.vsq_ctgry1_end = DNX_SAND_MAX(DNX_SAND_MAX(queue_range->start, 1) - 1, info.vsq_ctgry0_end);
            info.vsq_ctgry2_end = queue_range->end;
            /* update new range */
            queue_range->start = info.vsq_ctgry1_end + 1; 
            break;
        case 3:
            info.vsq_ctgry2_end = DNX_SAND_MAX(DNX_SAND_MAX(queue_range->start, 1) - 1, info.vsq_ctgry1_end);
            /* update new range */
            queue_range->start = info.vsq_ctgry2_end + 1; 
            break;
        /* coverity[dead_error_begin:FALSE] */
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("fabric control mode %d invalid vsq category id %d "), range_type,vsq_category_id));
        }
    } else {
        /* Not valid category modes */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ Category invalid %d"),mode)); 
    }

    /* Set new ranges */
    dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_category_rngs_set,(unit, core_id, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);
    
exit:
    BCMDNX_FUNC_RETURN;
}
int 
_bcm_cosq_dnx_vsq_category_get(int unit,
                                 int core_id,
                                 int range_type,
                                 DNX_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    int mode;
    uint32 dnx_sand_rv;
    DNX_TMC_ITM_CATEGORY_RNGS info;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Clear */
    DNX_TMC_ITM_CATEGORY_RNGS_clear(&info);

    BCMDNX_NULL_CHECK(queue_range);

    rc = bcm_dnx_fabric_control_get(unit, bcmFabricVsqCategory, &mode);
    BCMDNX_IF_ERR_EXIT(rc); 

    dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_category_rngs_get,(unit, core_id, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);

    if (mode == bcmFabricVsqCatagoryModeNone) {
        /* All VOQs are in the same category 2 and being mapped to 4-96K. Multicast Queues 0-3 */
        switch (range_type) {
        case bcmCosqRangeMulticastQueue:
            queue_range->start = 0;
            queue_range->end = 3;
            break;
        case bcmCosqRangeFabricQueue:
            queue_range->start = 4;
            queue_range->end = DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit);
            break;
        default:
            queue_range->start = 0;
            queue_range->end = 0;
        }
        /* Nothing to do */        
        BCM_EXIT;   
    }
     
    switch (range_type) {
    case bcmCosqRangeMulticastQueue:
        queue_range->start = 0;
        queue_range->end = info.vsq_ctgry0_end;
        break;
    case bcmCosqRangeShaperQueue:
        queue_range->start = DNX_SAND_MIN(info.vsq_ctgry0_end + 1, info.vsq_ctgry1_end);
        queue_range->end = info.vsq_ctgry1_end;
        break;
    case bcmCosqRangeFabricQueue:
        queue_range->start = DNX_SAND_MIN(info.vsq_ctgry1_end + 1, info.vsq_ctgry2_end);
        queue_range->end = info.vsq_ctgry2_end;
        break;
    case bcmCosqRecycleQueue:
        queue_range->start = DNX_SAND_MIN(info.vsq_ctgry2_end + 1, DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit));
        queue_range->end = DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit);
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories"), range_type));
    }

    if (mode == bcmFabricVsqCatagoryMode2 && range_type != bcmCosqRangeFabricQueue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories mode %d"), range_type, mode));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}
int
_bcm_dnx_cosq_queue_range_get(int unit,
                                int core_id,
                                int type,
                                DNX_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(queue_range);
    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }
    if (type == bcmCosqRangeMulticastQueue) {
        /* Get queue id range */
        DNXC_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_enhanced_get,(unit, core_id, queue_range)));
    } else if (type == bcmCosqRangeShaperQueue) {
        DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_get,(unit, core_id, &isp_info)));
        BCMDNX_IF_ERR_EXIT(rc);
        queue_range->start = isp_info.q_range.q_num_low;
        queue_range->end = isp_info.q_range.q_num_high;
    } else if (type == bcmCosqRangeFabricQueue) {
        rc = _bcm_cosq_dnx_vsq_category_get(unit, core_id, type, queue_range);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid range type %d"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_dnx_cosq_queue_range_set(int unit,
                                int core_id,
                                int type,
                                int configuration_type,
                                int sw_only,
                                DNX_SAND_U32_RANGE* queue_range) {
    bcm_error_t rc = BCM_E_NONE;    
    int *queue_region_config = NULL;
    int queue_config_type = -1;
    int core_index = 0;
    int region;
    int is_run_allocation;
    DNX_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    DNX_SAND_U32_RANGE queue_range_copy;
    uint32 hr_port;
    bcm_gport_t sw_state_isq_port;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(queue_range);
    sal_memcpy(&queue_range_copy, queue_range, sizeof(DNX_SAND_U32_RANGE));

    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }

    if (queue_range->start > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("queue min %d invalid"), queue_range->start));
    }    

    if (queue_range->end > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("queue max %d invalid"), queue_range->end));
    }    
    /* Validate queue id */
    if ((queue_range->start % 1024) && configuration_type != BCM_DNX_COSQ_QUEUE_RANGE_SET_MAX) {
        if ((queue_range->start % 1024) != 4) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID min %d must be a multiple of 1024"), queue_range->start));
        } 
        queue_range->start = 0;
    }
    if (((queue_range->end + 1) % 1024) != 0 && queue_range->end != 3 && configuration_type != BCM_DNX_COSQ_QUEUE_RANGE_SET_MIN) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID max %d must be a multiple of 1024 then - 1"),queue_range->end));
    }
    if ((type != bcmCosqRangeFabricQueue) && (type != bcmCosqRangeShaperQueue) && (type != bcmCosqRangeMulticastQueue)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid range type"), type));
    }
    if (!sw_only) {
        rc = _bcm_cosq_dnx_vsq_category_set(unit, core_id, type, &queue_range_copy); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (type == bcmCosqRangeMulticastQueue) {
        queue_config_type = DNX_DEVICE_COSQ_QUEUE_REGION_MULTICAST;
        if (!sw_only) {
            rc = bcm_dnx_fabric_multicast_scheduler_mode_get(unit, core_id, &is_run_allocation);
            BCMDNX_IF_ERR_EXIT(rc);

            if (is_run_allocation) {
                /* 
                 * 1. Currently Range defined for the enhance FMQs is execpted to be of 1Ks This can be changed on a later release
                 * 2. Validate queue id: for FMQs the start region must be in multiples of 1024 
                 */ 
                if ((queue_range->start % 1024) != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID min %d must be a multiple of 1024"), queue_range->start));
                }
            }
        } else {
            is_run_allocation = TRUE;
        }
    } else if (type == bcmCosqRangeShaperQueue) {
        if (SOC_IS_QAX(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("type %d unsupported on this device"), type));
        }
        
        queue_config_type = DNX_DEVICE_COSQ_QUEUE_REGION_ISQ;
        is_run_allocation = TRUE;
    } else if (type == bcmCosqRangeFabricQueue) {
        queue_config_type = DNX_DEVICE_COSQ_QUEUE_REGION_UNICAST;
        is_run_allocation = TRUE;
    }
    if (!sw_only && type == bcmCosqRangeMulticastQueue) {
        sal_memcpy(queue_range,&queue_range_copy, sizeof(DNX_SAND_U32_RANGE));
        /* Set queue id range */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_enhanced_set,(unit, core_id, queue_range)));

    } else if (!sw_only && type == bcmCosqRangeShaperQueue) {
        BCM_DNX_CORES_ITER(core_id, core_index) {
            DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);

            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_ingress_shape_get, (unit, core_index, &isp_info)));
            BCMDNX_IF_ERR_EXIT(rc);
            hr_port = isp_info.sch_port;

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.isq_port.get(unit, core_index, &sw_state_isq_port));
            if ((queue_range->start / 1024) <= ((queue_range->end + 1) / 1024)) {
                if (sw_state_isq_port == BCM_GPORT_INVALID) {
                    /* Allocate hr resource only in case of not MAX*/
                    rc = bcm_dnx_cosq_isq_hr_allocate(unit, core_index, &hr_port);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                isp_info.enable = TRUE; /* must be enabled to set q range */
            } else {
                /* deallocate hr resource */
                if (sw_state_isq_port != BCM_GPORT_INVALID) {
                    rc = bcm_dnx_cosq_isq_hr_deallocate(unit, core_index, &hr_port);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                isp_info.enable = FALSE;
            }
            isp_info.sch_port = hr_port;
            isp_info.q_range.q_num_low = queue_range->start;
            isp_info.q_range.q_num_high = queue_range->end;
            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_set,(unit, core_index, &isp_info)));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (type == bcmCosqRangeFabricQueue) {
        sal_memcpy(queue_range,&queue_range_copy, sizeof(DNX_SAND_U32_RANGE));
        /* update state */
        rc = _bcm_dnx_cosq_ucast_qid_range_set(unit, core_id, queue_range->start, queue_range->end);
        BCMDNX_IF_ERR_EXIT(rc);
    }


    if (is_run_allocation) {
        BCMDNX_ALLOC(queue_region_config, sizeof(int) * DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit)*SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores , "queue_region");

        if (queue_region_config == NULL) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("resource memory allocation failur")));
        }
        sal_memset(queue_region_config, 0, sizeof(int) * DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit)*SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores);
        BCM_DNX_ASSYMETRIC_CORES_ITER(core_id, core_index) {
            for (region = (queue_range->start / 1024); region < ((queue_range->end + 1) / 1024); region++) {
                queue_region_config[region + (core_index * DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit))] = queue_config_type;
            }
        }
        rc = _bcm_dnx_am_cosq_process_queue_region(unit, core_id, queue_config_type, queue_region_config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    if (queue_region_config != NULL) {
       BCM_FREE(queue_region_config);
    }
    BCMDNX_FUNC_RETURN;
}
/* test a credit request profile for conditions needed for moving to a different credit request mode */
static int
_bcm_dnx_cosq_credit_watchdog_test_profile(int unit, int profile, int cr_wd_mode)
{
    bcm_cosq_delay_tolerance_t profile_data;
    int rc = bcm_dnx_cosq_delay_tolerance_level_get(unit, profile, &profile_data);
    BCMDNX_INIT_FUNC_DEFS;
    if (rc != BCM_E_UNAVAIL) {
        BCMDNX_IF_ERR_EXIT(rc);
        if (profile_data.credit_request_watchdog_delete_queue_thresh) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can not enter the %s credit watchdog mode when a credit watchdog delete queue threshold is set.\n"
              "You may want to disable it for user defined credit request profile number %d (tolerance level %d)"),
              cr_wd_mode == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE ? "common status message" : "aggressive status message",
              profile - (BCM_COSQ_DELAY_TOLERANCE_02 - 2), profile));
        } else if (cr_wd_mode == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE &&
                   profile_data.credit_request_watchdog_status_msg_gen) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can not enter the common status message credit watchdog mode when a credit watchdog status message threshold is set.\n"
              "You may want to disable it for user defined credit request profile number %d (tolerance level %d)"),
              profile - (BCM_COSQ_DELAY_TOLERANCE_02 - 2), profile));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_watchdog_range_set(
        int unit, 
        int core_id, 
        uint32 flags,
        bcm_cosq_range_t *range, 
        int common_message_time) 
{

    int8 orig_crwd_mode = 0;
    uint32 orig_scan_time_ns = 0, exact_credit_watchdog_scan_time_nano = 0;
    int fail = 0;
    int8 credit_watchdog_mode;
    DNX_TMC_ITM_CR_WD_INFO info, info2;
    int enabled, profile;
    int changed_mode = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);
    if (core_id != BCM_CORE_ALL && (core_id < 0 || core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }
    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
    if (range->is_enabled && (flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_ENABLE)) {
        if (/*range->is_enabled < (uint32)BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MIN ||*/ range->is_enabled > BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MAX) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid enable value: %d, should be between %d - %d"), range->is_enabled,
              BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MIN, BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MAX));
        } 
        if (range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE && !(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("common FSM mode is only supported in 86660\n")));
        }
        if (common_message_time >= 0 && (!DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, orig_crwd_mode) || 
            (range->is_enabled != CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("common message time can only be set in common message time mode")));
        }
    } else if (common_message_time >= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("can only set common message time using bcmCosqWatchdogQueue")));
    }

    if ((flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MIN) && 
        (range->range_start > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit) || range->range_start < 0)) { /* Validate queue id */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid start queue number: %d, is not between 0 - %d"), range->range_start, DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)));
    } 
    if ((flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MAX) && 
        (range->range_end > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit) || range->range_end < 0)) { /* Validate queue id */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid end queue number: %d, is not between 0 - %d"), range->range_end, DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)));
    } 
    if ((flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MIN) && (flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MAX) && 
        range->range_start > range->range_end) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue range: %d - %d, is not between 0 - %d"), range->range_start, range->range_end, DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)));
    } 
    DNX_TMC_ITM_CR_WD_INFO_clear(&info);
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_get, (unit, core_id, &info)));
    fail = 1; /* get credit watchdog configuration if error happens from here on */
    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
    BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, orig_scan_time_ns));

    /* The MBCM_DNX_DRIVER_CALL initializing the required variable */ 
    /* coverity[uninit_use:FALSE] */
    enabled = info.min_scan_cycle_period_micro;
    if (common_message_time >= 0) {
        if (common_message_time == 2 * JER2_ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000) {
            /* If over max scan time, use max scan time and mark mode to use two scans */
            range->is_enabled = CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1;
            common_message_time = JER2_ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000;
        }
        if (!enabled) { /* If changing common message time, do not change enabled or not */
            BCMDNX_IF_ERR_EXIT(DNX_SET_CREDIT_WATCHDOG_MODE(unit, range->is_enabled)); /* update the stored mode */
            range->is_enabled = BCM_FABRIC_WATCHDOG_QUEUE_DISABLE;
        }
    }
    if (flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_ENABLE) {
        if (range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_DISABLE) {
            enabled = 0;
        } else {
            BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
            changed_mode = !DNX_IS_CREDIT_WATCHDOG_MODE(unit, range->is_enabled, credit_watchdog_mode);
            if (credit_watchdog_mode == CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1 &&
                range->is_enabled == CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE && common_message_time < 0) {
                range->is_enabled = CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1; /* do not change common FSM sub mode if not requested to do so */
            }
            enabled = 1;
                /* if moving to a different credit watchdog mode, check if allowed to move to the new mode */
            if (changed_mode &&
               (range->is_enabled != BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_NORMAL || DNX_IS_CREDIT_WATCHDOG_FAST_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode))) {
                /* check that no profile with aging exists */
                for (profile = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED; profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY; ++profile) {
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                }
                for (profile = BCM_COSQ_DELAY_TOLERANCE_02; profile <= BCM_COSQ_DELAY_TOLERANCE_14; ++profile) {
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                }
                if (SOC_IS_JERICHO(unit)) {
                    for (profile = BCM_COSQ_DELAY_TOLERANCE_16; profile <= BCM_COSQ_DELAY_TOLERANCE_23; ++profile) {
                        BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                    } 
                }
            }
            BCMDNX_IF_ERR_EXIT(DNX_SET_CREDIT_WATCHDOG_MODE(unit, range->is_enabled)); /* update the stored mode */
        }
    }
    if (flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MIN) {
        info.bottom_queue = range->range_start;
        if (info.top_queue < range->range_start) {
            info.top_queue = range->range_start;
        }
    }
    if (flags & BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MAX) {
        info.top_queue = range->range_end;
        if (info.bottom_queue > range->range_end) {
            info.bottom_queue = range->range_end;
        }
    }
    if (enabled) {
        /* The MBCM_DNX_DRIVER_CALL initializing the required variable */ 
        /* coverity[uninit_use:FALSE] */
        uint32 queue_number = info.top_queue + 1 - info.bottom_queue;
        uint32 nof_ns_in_20_ticks, scan_time_ns;
        DNX_BCM_SAND_IF_ERR_EXIT(jer2_arad_ticks_to_time((unit), 20, TRUE, 1, &nof_ns_in_20_ticks));
        /* Get the default watchdog scan time for the mode (or the one given in common_message_time) and set it in SW */
        DNX_TMC_ITM_CR_WD_INFO_clear(&info2);

        BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
        BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));

        info2.min_scan_cycle_period_micro = (common_message_time >= 0) ? common_message_time : (
            (changed_mode || !DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) ? 0 : exact_credit_watchdog_scan_time_nano / 1000);
        info2.top_queue = info2.bottom_queue = info2.max_flow_msg_gen_rate_nano = JER2_ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, core_id, &info2, &info2)));

        BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
        scan_time_ns = info2.min_scan_cycle_period_micro; /* exact scan time */
        info.min_scan_cycle_period_micro = exact_credit_watchdog_scan_time_nano / 1000; /* rounded scan time in common FSM mode */

        /* Set the time in nanoseconds to scan each queue, may be later limited by the range of the hardware field.
         * time = max{0.5*full_scan/nof_queues, full_scan/nof_queues - 20*clock_cycle}
         * We try to be precise (not have scans longer than the declared scan time, and not have burstiness.
         */
        info.max_flow_msg_gen_rate_nano = (scan_time_ns / 2) / queue_number;
        queue_number = scan_time_ns / queue_number;
        if (queue_number > nof_ns_in_20_ticks) {
            queue_number -= nof_ns_in_20_ticks;
            if (info.max_flow_msg_gen_rate_nano < queue_number ) {
                info.max_flow_msg_gen_rate_nano = queue_number;
            }
        }

        /* if moving to a different credit watchdog mode, adjust existing profiles */
        BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (changed_mode && !DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
            bcm_cosq_delay_tolerance_t profile_data;
            int status_msg_threshold = range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_FAST_STATUS_MESSAGE ?
              DNX_TMC_ITM_CREDIT_WATCHDOG_AGGRESSIVE_WD_STATUS_MSG_MESSAGE_THRESHOLD :
              DNX_TMC_ITM_CREDIT_WATCHDOG_NORMAL_STATUS_MSG_THRESHOLD;
            /* Change existing credit watchdog status message thresholds to the default for the new mode */
            for (profile = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED; profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY; ++profile) {
                BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_get(unit, profile, &profile_data));
                if (profile_data.credit_request_watchdog_status_msg_gen && 
                    profile_data.credit_request_watchdog_status_msg_gen != status_msg_threshold) {
                    profile_data.credit_request_watchdog_status_msg_gen = status_msg_threshold;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, profile, &profile_data));
                }
            }
            for (profile = BCM_COSQ_DELAY_TOLERANCE_02; profile <= BCM_COSQ_DELAY_TOLERANCE_14; ++profile) {
                int rc = bcm_dnx_cosq_delay_tolerance_level_get(unit, profile, &profile_data);
                if (rc == BCM_E_UNAVAIL) {
                    continue;
                }
                BCMDNX_IF_ERR_EXIT(rc);
                if (profile_data.credit_request_watchdog_status_msg_gen && 
                    profile_data.credit_request_watchdog_status_msg_gen != status_msg_threshold) {
                    profile_data.credit_request_watchdog_status_msg_gen = status_msg_threshold;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_delay_tolerance_level_set(unit, profile, &profile_data));
                }
            }
        }
    } else {
        if (common_message_time >= 0) {
            /* Set the scan time for the common mode in SW, and not in HW */
            DNX_TMC_ITM_CR_WD_INFO_clear(&info2);
            info2.min_scan_cycle_period_micro = common_message_time;
            info2.top_queue = info2.bottom_queue = info2.max_flow_msg_gen_rate_nano = JER2_ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
            DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, core_id, &info2, &info2)));
        }
        info.min_scan_cycle_period_micro = 0;
        BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (DNX_IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
            uint32 exp = 0; /* find the (negative) exponent of the scan time compared to the max scan time */
            BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
            for (; exp <= JER2_ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES &&
                 exact_credit_watchdog_scan_time_nano != JER2_ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS << exp;
                 ++exp);
            if  (exp > JER2_ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Invalid scan time for common message time mode: %uns"), exact_credit_watchdog_scan_time_nano));
            }
            /* store data the (disabled) credit watchdog mode and scan time in HW for warm boot */
            info.max_flow_msg_gen_rate_nano = credit_watchdog_mode + exp;
        } else {
            /* store data the (disabled) credit watchdog mode in HW for warm boot */
            info.max_flow_msg_gen_rate_nano = credit_watchdog_mode;
        }
    }
    BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    /* If the scan time of the common message time mode was changed, change the delete time exponents to match new scan time */
    if (common_message_time >= 0 && !changed_mode && orig_scan_time_ns != exact_credit_watchdog_scan_time_nano) {
        uint32 bigger, smaller, *shift;
        info2.min_scan_cycle_period_micro = info2.max_flow_msg_gen_rate_nano = 0;
        info2.top_queue = info2.bottom_queue = JER2_ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
        if (exact_credit_watchdog_scan_time_nano > orig_scan_time_ns) {
            bigger = exact_credit_watchdog_scan_time_nano;
            smaller = orig_scan_time_ns;
            shift = &info2.min_scan_cycle_period_micro;
        } else {
            bigger = orig_scan_time_ns;
            smaller = exact_credit_watchdog_scan_time_nano;
            shift = &info2.max_flow_msg_gen_rate_nano;
        }
        for (*shift = 1; smaller << *shift != bigger; ++*shift) {
            if (*shift >= JER2_ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can not adjust delete times moving from scan time %u to scan time %u"),
                  (unsigned)orig_scan_time_ns, (unsigned)exact_credit_watchdog_scan_time_nano));
            }
        }
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, core_id, &info2, &info2)));
    }

    /* Change the credit watchdog scan configuration */
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_wd_set, (unit, core_id, &info, &info2)));
    fail = 0;

exit:
    if (fail) { /* If failed, restore the original credit watchdog mode */
        BCMDNX_IF_ERR_CONT(DNX_SET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
        BCMDNX_IF_ERR_EXIT(DNX_GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    }
    BCMDNX_FUNC_RETURN;
}

/*
 * Get queue range or enable/disable for credit watchdog
 * Set VOQ range
 */
int
_bcm_dnx_cosq_credit_watchdog_range_get(
        int unit, 
        int core_id, 
        bcm_cosq_range_t *range)
{
    int8 credit_watchdog_mode;
    DNX_TMC_ITM_CR_WD_INFO info;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);       


    DNX_TMC_ITM_CR_WD_INFO_clear(&info);
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_cr_wd_get,(unit, core_id, &info)));
    range->range_start = info.bottom_queue;
    range->range_end = info.top_queue;
    BCMDNX_IF_ERR_EXIT(DNX_GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    range->is_enabled = (info.min_scan_cycle_period_micro) ? DNX_GET_CREDIT_WATCHDOG_MODE_BASE(credit_watchdog_mode) : BCM_FABRIC_WATCHDOG_QUEUE_DISABLE;

exit:
    BCMDNX_FUNC_RETURN;
}
int 
bcm_dnx_cosq_control_range_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    DNX_SAND_U32_RANGE queue_range;
    uint32 index;
    int core = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* Parameters Check */
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);

    switch (type) 
    {
        case bcmCosqThresholdDramMixDbuff :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "getting Dram mixed dbuff thresholds\n")));
            /* check validity of Gport */
            if(0 == BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_dram_mix_dbuff_threshold_get, (unit, core, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbCommittedMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_committed_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbCommittedMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_committed_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbEligibleMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_eligible_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbEligibleMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_eligible_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;
        case bcmCosqRangeMulticastQueue:
        case bcmCosqRangeShaperQueue:
        case bcmCosqRangeFabricQueue:
        case bcmCosqRecycleQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_queue_range_get(unit, core, type, &queue_range));
            range->range_start = queue_range.start;
            range->range_end = queue_range.end;
            break;
        case bcmCosqWatchdogQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_range_get(unit, core, range));
            break;
        case bcmCosqStatIfQueues:
        case bcmCosqStatIfScrubberQueues:
            if (!BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_stat_if_queue_range_get, (unit, core, (type == bcmCosqStatIfScrubberQueues) ? 1:0, &(range->range_start), &(range->range_end))));
            break;
        default :
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given type %d is invalid\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_control_range_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    DNX_SAND_U32_RANGE queue_range;
    uint32 index = 0;
    int core = 0;
    uint32 watchdog_flags = BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MAX | BCM_DNX_COSQ_CREDIT_WATHDOG_USE_MIN | BCM_DNX_COSQ_CREDIT_WATHDOG_USE_ENABLE;
    BCMDNX_INIT_FUNC_DEFS;

    /* Parameters Check */
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);

    switch (type) {
        case bcmCosqThresholdDramMixDbuff :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Dram mixed dbuff thresholds\n")));
            /* check validity of Gport */
            if(0 == BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_dram_mix_dbuff_threshold_set, (unit, core, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbCommittedMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_committed_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbCommittedMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_committed_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbEligibleMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_eligible_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbEligibleMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ocb_control_range_ocb_eligible_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;
        case bcmCosqRangeMulticastQueue:
        case bcmCosqRangeShaperQueue:
        case bcmCosqRangeFabricQueue:
        case bcmCosqRecycleQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            queue_range.start = range->range_start;
            queue_range.end = range->range_end;
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_queue_range_set(unit, core, type, BCM_DNX_COSQ_QUEUE_RANGE_SET_BOTH, FALSE, &queue_range));
            break;
        case bcmCosqWatchdogQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_credit_watchdog_range_set(unit, core, watchdog_flags, range, 0));
            break;

        case bcmCosqStatIfQueues:
        case bcmCosqStatIfScrubberQueues:
            if (!BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_stat_if_queue_range_set, (unit, core, (type == bcmCosqStatIfScrubberQueues) ? 1:0, range->range_start, range->range_end)));
            break;
        default :
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given type %d is invalid\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_dnx_cosq_control_set(int unit,
                           bcm_gport_t port,
                           bcm_cos_queue_t cosq,
                           bcm_cosq_control_t type,
                           int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;
    bcm_gport_t sysport;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* device wide settings */ 
    if (port == 0 || BCM_COSQ_GPORT_IS_CORE(port)) {
        rc = _bcm_dnx_cosq_control_device_set(unit, port, cosq, type, arg);
    } else if (!BCM_GPORT_IS_SET(port)) {
        rc = _bcm_dnx_cosq_ingress_port_set(unit, port, type, arg);
    }
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_dnx_cosq_control_fmq_set(unit, port, cosq, type, arg);
    }

    /* E2E scheduler */
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_dnx_cosq_control_e2e_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_e2e_port_tc_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_e2e_port_tcg_set(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduler */
    /* Egress scheduler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DNX_PORT_IS_INTERFACE(port_index)) {  
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_control_egress_interface_scheduler_set(unit, port, cosq, type, arg);
        } else {
            /* Egress scheduler port */
            rc = _bcm_dnx_cosq_control_egress_port_scheduler_set(unit, port, cosq, type, arg);
        }        
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port))) {
        rc = _bcm_dnx_cosq_control_egress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TC(port)) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_egress_port_tc_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TCG(port)) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_egress_port_tcg_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress Queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_dnx_cosq_control_ingress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_dnx_cosq_control_flow_set(unit, port, cosq, type, arg);
    } 
    else if (BCM_GPORT_IS_CONGESTION(port)) { 
        rc = _bcm_dnx_cosq_control_congestion_port_set(unit, port, cosq, type, arg);
    }
    else if (BCM_GPORT_IS_PROFILE(port)) { 
        rc = _bcm_dnx_cosq_control_profile_set(unit, port, cosq, type, arg);
    }
    /* System port */
    else if (BCM_GPORT_IS_SYSTEM_PORT(port))
    {
        rc = _bcm_dnx_cosq_control_system_port_set(unit, port, cosq, type, arg);
    }
    /* modport  */
    else if (BCM_GPORT_IS_MODPORT(port))
    {
        rc = bcm_dnx_stk_gport_sysport_get(unit, port, &sysport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped"), unit, port));
        }
        rc = _bcm_dnx_cosq_control_system_port_set(unit, sysport, cosq, type, arg);
    }    
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d,port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:

    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_control_get(int unit,
                     bcm_gport_t port,
                     bcm_cos_queue_t cosq,
                     bcm_cosq_control_t type,
                     int *arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;
    bcm_gport_t sysport;


    BCMDNX_INIT_FUNC_DEFS;

    /* device wide settings */ 
    if (port == 0 || BCM_COSQ_GPORT_IS_CORE(port)) {
        rc = _bcm_dnx_cosq_control_device_get(unit, port, cosq, type, arg);
    } else if (!BCM_GPORT_IS_SET(port)) {
        rc = _bcm_dnx_cosq_ingress_port_get(unit, port, type, arg);
    }

    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_dnx_cosq_control_fmq_get(unit,port,cosq,type,arg);
    } 
   
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_dnx_cosq_control_flow_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_dnx_cosq_control_e2e_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_e2e_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_e2e_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduelr */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DNX_PORT_IS_INTERFACE(port_index)) {
            /* Egress scheduler interface */
            rc = _bcm_dnx_cosq_control_egress_interface_scheduler_get(unit, port, cosq, type, arg);
        }
        else {
            rc = _bcm_dnx_cosq_control_egress_port_scheduler_get(unit, port, cosq, type, arg);
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_egress_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(port) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_dnx_cosq_control_egress_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port)))
    {
        rc = _bcm_dnx_cosq_control_egress_queue_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dnx_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_dnx_cosq_control_ingress_queue_get(unit, port, cosq, type, arg);
    } 
    else if (BCM_GPORT_IS_CONGESTION(port)) { 
        rc = _bcm_dnx_cosq_control_congestion_port_get(unit, port, cosq, type, arg);
    }
    else if (BCM_GPORT_IS_PROFILE(port)) { 
        rc = _bcm_dnx_cosq_control_profile_get(unit, port, cosq, type, arg);
    }
    /* System port */
    else if (BCM_GPORT_IS_SYSTEM_PORT(port))
    {
        rc = _bcm_dnx_cosq_control_system_port_get(unit, port, cosq, type, arg);
    }
    /* modport  */
    else if (BCM_GPORT_IS_MODPORT(port))
    {
        rc = bcm_dnx_stk_gport_sysport_get(unit, port, &sysport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped"), unit, port));
        }
        rc = _bcm_dnx_cosq_control_system_port_get(unit, sysport, cosq, type, arg);
    }     
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* consider adding support gettting the requested gport. given different input gport types */
int
bcm_dnx_cosq_gport_handle_get(int unit,
                                bcm_cosq_gport_type_t gport_type,
                                bcm_cosq_gport_info_t *gport_info)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_cosq_gport_info_core_t gport_core_info;
	uint32     tm_port;
    int core;
	soc_port_t port;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (gport_info == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("gport info needs specified, cannot be NULL")));
    }

    switch (gport_type) {
        case bcmCosqGportTypeE2EPort:
            BCM_COSQ_GPORT_E2E_PORT_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeUnicastEgress:
            BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeMulticastEgress:
            BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeCompositeFlow2:
            if(BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport);
            } else if(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_info->in_gport)) {
                core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_info->in_gport);
            } else {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler/VoQ Connector gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            } 
            break;

        case bcmCosqGportTypeSchedCIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport) ;
            BCM_COSQ_GPORT_SCHED_CIR_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeSchedPIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport) ;
            BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;
          case bcmCosqGportTypeLocalPort:
            {
              int my_modid;

              rc = bcm_dnx_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  gport_info->out_gport = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {
					  core = SOC_DNX_MODID_TO_CORE(unit, my_modid, BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport));
					  tm_port = BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport);
					  rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
					  BCMDNX_IF_ERR_EXIT(rc);
      
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,port);
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_dnx_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);

                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), gport_info->in_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }
                      
                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(gport_info->out_gport,gport_info->in_gport);                
              } else {
                  rc = BCM_E_PORT;           
              }
            }
            break;            
        case bcmCosqGportTypeLocalPortTC: 
        case bcmCosqGportTypeLocalPortTCG:
        case bcmCosqGportTypeE2EPortTC: 
        case bcmCosqGportTypeE2EPortTCG:
          {
              bcm_gport_t local_port = -1;
              bcm_port_t temp_port;
              int my_modid;

              rc = bcm_dnx_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              /* Supported only in case of not Port-TC enable */
              if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Gport (0x%x) Port-TC is not supported for this device \n"), gport_info->in_gport));
                  rc = BCM_E_UNAVAIL;
                  break;
              }
              rc = BCM_E_NONE;   
              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  local_port = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {					  
					  core = SOC_DNX_MODID_TO_CORE(unit, my_modid, BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport));
					  tm_port = BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport);
					  rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
					  BCMDNX_IF_ERR_EXIT(rc);
      
                      BCM_GPORT_LOCAL_SET(local_port,port);
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_dnx_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);
                      
                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), modport_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }

                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(local_port,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(local_port,gport_info->in_gport);                
                  
              } else {
                  rc = BCM_E_PORT;           
              }
              if (rc == BCM_E_NONE) {              
                temp_port = BCM_GPORT_LOCAL_GET(local_port);
                switch (gport_type)
                {
                case bcmCosqGportTypeLocalPortTC: 
                  BCM_COSQ_GPORT_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeLocalPortTCG:
                  BCM_COSQ_GPORT_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTC: 
                  BCM_COSQ_GPORT_E2E_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTCG:
                  BCM_COSQ_GPORT_E2E_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                /* must have default. Otherwise, compilation error */
                /* coverity[dead_error_begin : FALSE] */
                default:
                  rc = BCM_E_INTERNAL;      
                  break;
                }
              }
          }
            break;
        case bcmCosqGportTypeGlobalFmqRoot:
            BCM_COSQ_GPORT_FMQ_ROOT_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqGuaranteed:
            BCM_COSQ_GPORT_FMQ_GUARANTEED_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffortAggregate:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT_AGR_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort0:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT0_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort1:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT1_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort2:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT2_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqClass1:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFmqClass2:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFmqClass3:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFmqClass4:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalIsqRoot:
            BCM_COSQ_GPORT_ISQ_ROOT_SET(gport_info->out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshLocal:
        case bcmCosqGportTypeGlobalFabricMeshDev0:
        case bcmCosqGportTypeGlobalFabricMeshDev1:
        case bcmCosqGportTypeGlobalFabricMeshDev2:
        case bcmCosqGportTypeGlobalFabricMeshDev3:
        case bcmCosqGportTypeGlobalFabricMeshDev4:
        case bcmCosqGportTypeGlobalFabricMeshDev5:
        case bcmCosqGportTypeGlobalFabricMeshDev6:
        case bcmCosqGportTypeGlobalFabricMeshDev7:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
        case bcmCosqGportTypeGlobalFabricClosFabric:
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
        {
            gport_core_info.gport_type = gport_type;
            gport_core_info.flags = 0;
            gport_core_info.cosq = 0;
            gport_core_info.in_gport = 0;
            rc = bcm_dnx_cosq_gport_handle_core_get(unit, BCM_CORE_ALL, &gport_core_info, &gport_info->out_gport);
            BCMDNX_IF_ERR_EXIT(rc);            
            break;
        }
        case bcmCosqGportTypeSched:
            {
              uint32 fap_port;
              bcm_cos_t priority;
              DNX_TMC_SCH_SE_ID se_id;
              int flow_id ;
              bcm_gport_t port_gport;

              rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, gport_info->in_gport, 0, &port_gport);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_SCHEDULER(port_gport)) {
                  /* Nothing to do */
                  gport_info->out_gport = port_gport;
                  break;
              }

              /* API is releavant for port TC or other Port physical gports */              
              rc = _bcm_dnx_cosq_fap_port_get(unit, port_gport, &fap_port, &core, NULL);
              if (rc != BCM_E_NONE) {
                   LOG_ERROR(BSL_LS_BCM_COSQ,
                             (BSL_META_U(unit,
                                         "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport_info->in_gport, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
                  BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid fap port %d,  for gport (0x%x)"), unit, fap_port, gport_info->in_gport));
              }

              if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport) || BCM_COSQ_GPORT_IS_PORT_TC(port_gport)) {
                  /* Port-TC */
                  /* validate priority */
                  rc = _bcm_dnx_cosq_port_priority_validate(unit,gport_info->in_gport,gport_info->cosq);
                  if (rc != BCM_E_NONE) {
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                                (BSL_META_U(unit,
                                            "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport_info->in_gport, gport_info->cosq, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                  }
                  priority = gport_info->cosq;
              } else {
                  priority = DNX_COSQ_PB_DEFAULT_PORT_TC;
              }
              
              rc = _bcm_dnx_cosq_port2se_id(unit,core,fap_port,priority,&se_id);            
              if (rc != BCM_E_NONE || se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                  BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
              }
              flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
              if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on JER2_QAX (32k on QUX) flow range, as the user would expect*/
                  flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
              }
              BCM_GPORT_SCHEDULER_CORE_SET(gport_info->out_gport, flow_id, core); 
            }
            break;
        case bcmCosqGportTypeFabricPipe:
            BCM_COSQ_GPORT_FABRIC_PIPE_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeEgress:
            BCM_COSQ_GPORT_FABRIC_PIPE_EGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeIngress:
            BCM_COSQ_GPORT_FABRIC_PIPE_INGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        default :
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid Handle type (%d) requested\n"), gport_type));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DNXC_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_handle_core_get( 
    int unit, 
    int core, 
    bcm_cosq_gport_info_core_t *gport_info, 
    bcm_gport_t *out_gport)
{

    int my_modid;

    BCMDNX_INIT_FUNC_DEFS;

    switch (gport_info->gport_type) 
    {
        /* mesh scheme */
        case bcmCosqGportTypeGlobalFabricMeshLocal:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL_SET(*out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshDev0:
            BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid)); 
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                if (my_modid == 0) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            /* dest dev 0 should address current fap id */
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, my_modid);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 1) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 2) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 3) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev4:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 4) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev5:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 5) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 5);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev6:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 6) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 6);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev7:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 7) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 7);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev2:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV2_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev3:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV3_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonMc:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMc:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMesh:
            BCM_COSQ_GPORT_FABRIC_MESH_SCOPE_SET(*out_gport);
            break;

        /*close scheme */
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BESTEFFORT_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonUnicastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_UNICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonMulticastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_MULTICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClos:
            BCM_COSQ_GPORT_FABRIC_CLOS_SCOPE_SET(*out_gport);
            break;
        case bcmCosqGportTypeFabricRxUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_TDM_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_TDM_SET(*out_gport, core);
            break;
        /* FMQ/ISQ handle */
        case bcmCosqGportTypeGlobalFmqRoot:
            BCM_COSQ_GPORT_FMQ_ROOT_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqGuaranteed:
            BCM_COSQ_GPORT_FMQ_GUARANTEED_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffortAggregate:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT_AGR_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort0:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT0_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort1:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT1_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort2:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT2_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqClass1:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 1);
            break;
        case bcmCosqGportTypeGlobalFmqClass2:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 2);
            break;
        case bcmCosqGportTypeGlobalFmqClass3:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 3);
            break;
        case bcmCosqGportTypeGlobalFmqClass4:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 4);
            break;
        case bcmCosqGportTypeGlobalIsqRoot:
            BCM_COSQ_GPORT_ISQ_ROOT_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeCore:
            BCM_COSQ_GPORT_CORE_SET(*out_gport, core);
            break;
        default:
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            break;
    }

    /* set core */
    if (BCM_GPORT_IS_FABRIC_MESH(*out_gport) || BCM_GPORT_IS_FABRIC_CLOS(*out_gport))
    {
        BCM_DNX_SCHEDULER_ONLY_CORE_SET(*out_gport, core);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fc_path_add(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* Common implementation with the remove function */
    rc = _bcm_dnx_cosq_fc_path_add_remove(unit,
                                            FALSE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;

    /* Input Validation */
    if (source == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control source not specified\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control source not specified")));
    }
    if (target == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control target is NULL\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control target is NULL")));
    }

    /* Different functions for Generation/Reception */
    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_dnx_cosq_generation_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_dnx_cosq_reception_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, invalid flow control direction %d\n"), unit, fc_direction));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("invalid flow control direction")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* Common implementation with the remove function */
    rc = _bcm_dnx_cosq_fc_path_add_remove(unit,
                                            TRUE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_pfc_config_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid config parameter %p"), unit, config));
    }
    
    /* PFC FC settings include the following:
     * 1. Global thresholds (VSQ global) 
     * 2. PFC VSQ FC thresholds (VSQ PFC)
     * 3. LLFC VSQ FC thresholds (VSQ LLFC)                              
     */
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        if (BCM_COSQ_GPORT_IS_VSQ_GL(gport)) {
           rc = _bcm_dnx_cosq_vsq_gl_fc_threshold_set(unit, gport, cosq, flags, config);
        } else {
           rc = _bcm_dnx_cosq_vsq_fc_threshold_set(unit, gport, cosq, flags, config);
        } 
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_pfc_config_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        /* 1. vsq gl flow control thresholds */
        if (BCM_COSQ_GPORT_IS_VSQ_GL(gport)) {
           rc = _bcm_dnx_cosq_vsq_gl_fc_threshold_get(unit, gport, cosq, flags, config);
        } else if (BCM_COSQ_GPORT_IS_VSQ_PG(gport) || BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(gport)) {
           rc = _bcm_dnx_cosq_vsq_fc_threshold_get(unit, gport, cosq, flags, config); 
        } else {
          /* not supported gport */
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
        }
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_dnx_cosq_fc_port_threshold_init(int unit, soc_port_t port, int *mc_reserved_pds, int is_dynamic)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_egress_thresh_key_info_t thresh_key;
    int                     is_allocated, is_last, core;
    int                     template, old_template, tc;  
    uint32                  nof_priorities, num_of_channels, port_rate, tm_port;
    soc_port_if_t           interface_type;
    DNX_TMC_EGR_QUEUING_CGM_INIT_THRESHOLDS cgm_init_thresholds;

    BCMDNX_INIT_FUNC_DEFS;

    DNXC_IF_ERR_EXIT(dnx_port_sw_db_interface_type_get(unit, port, &interface_type));
    if (interface_type == SOC_PORT_IF_NULL) {
        *mc_reserved_pds = 0;
        return BCM_E_NONE;
    }

    /* IF rate mbps */
    rc = dnx_port_sw_db_interface_rate_get(unit, port, &port_rate);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    if(nof_priorities == 0)
    {
      rc = BCM_E_INTERNAL;
      BCMDNX_IF_ERR_EXIT(rc);
    }

    DNXC_IF_ERR_EXIT(dnx_port_sw_db_num_of_channels_get(unit, port, &num_of_channels));

    DNXC_IF_ERR_EXIT(dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core));

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_init_thresholds, (unit, port_rate, nof_priorities,num_of_channels, &cgm_init_thresholds)));
    /* override in case of dynamic port */
    if(is_dynamic) {
        cgm_init_thresholds.mc_reserved_pds = 0;
    }
    *mc_reserved_pds = cgm_init_thresholds.mc_reserved_pds;
 
    /* Old data get */
    rc = _bcm_dnx_am_template_cosq_egr_thresh_data_get(unit, core, port, &thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* PORT */
    thresh_key.port_fc_packet_descriptors = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_packet_descriptors_min = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_packet_descriptors_alpha = 0;
    thresh_key.port_fc_data_buffers = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_data_buffers_min = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_data_buffers_alpha = 0;
    thresh_key.unsch_drop_packet_descriptors = cgm_init_thresholds.port_mc_drop_pds;
    thresh_key.unsch_drop_packet_descriptors_min = cgm_init_thresholds.port_mc_drop_pds;
    thresh_key.unsch_drop_packet_descriptors_alpha = 0;
    thresh_key.unsch_drop_data_buffers = cgm_init_thresholds.port_mc_drop_dbs;

    /* PORT UC DROP (Device)  */
    thresh_key.sch_drop_packet_descriptors = cgm_init_thresholds.drop_pds_th;
    thresh_key.sch_drop_data_buffers = cgm_init_thresholds.drop_dbs_th;

    /* QUEUE */
    for(tc = 0; tc < nof_priorities; tc++)
    {
      thresh_key.sch_fc_data_buffers_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_data_buffers_min_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_data_buffers_alpha_tc[tc] = 0;
      thresh_key.sch_drop_data_buffers_tc[tc] = cgm_init_thresholds.drop_dbs_th;
      thresh_key.sch_drop_packet_descriptors_tc[tc] = cgm_init_thresholds.drop_pds_th_tc;
    }

    /* MC per TC/DP */
    if((!SOC_IS_JERICHO(unit)) && (cgm_init_thresholds.port_mc_drop_pds > DNX_COSQ_JER2_ARAD_MAX_QUEUE_PD_THRESH))
    {
      /* This value is now used for queue thresholds */
      cgm_init_thresholds.port_mc_drop_pds = 4050;
      
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_dbs / 10;

      }
    }
    else
    {
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;
    
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_dbs / 10;
      }
    }

    /* Reserved MC PDs */
    for (tc = 0; tc < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++) {
        thresh_key.unsch_drop_packet_descriptors_available_tc[tc] = *mc_reserved_pds;
    }

    /* Set new object */
    rc = _bcm_dnx_am_template_cosq_egr_thresh_exchange(unit,core,port,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        /* Set new profile */
        rc = _bcm_dnx_cosq_egress_thresh_profile_set(unit,port,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_jer2_arad_cosq_egress_thresh_profile_data_set(unit,core,template,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
  BCMDNX_FUNC_RETURN;
}

/*
 * initialization corresponding to the configuration indicated via SOC properties
 * All consistency checks and ressetting the configuration to be consistent has been
 * already done during soc_init(). Reference drv.c. Thus no consistency checks are
 * done during bcm_dnx_init()/cosq_init().
 */
static int
_bcm_dnx_cosq_fc_init(int unit)
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    DNX_TMC_FC_CAL_IF_INFO        cal_if_info;
    DNX_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    DNX_TMC_FC_CAL_MODE           cal_mode_ndx = 0;
    DNX_TMC_FC_DIRECTION       direction_ndx;
    DNX_TMC_FC_GEN_CALENDAR      *gen_cal_buff = NULL;
    int                      oob_if, ilkn_if, core;
    uint32                   dnx_sand_rc = DNX_SAND_OK, dev_id, flags;
    int                      cal_index /*rx_cal_len, tx_cal_len*/;
    int                      is_coldboot = TRUE;
    DNX_TMC_FC_ILKN_LLFC_INFO     llfc_info;
    pbmp_t                  ports_map;
    soc_port_t              port_i;
    int                     fc_mode;
    uint32                  phy_port;
    int                     any_port_with_1_priority = 0;
    int total_mc_reserved_pds_sp0[2], total_mc_reserved_pds_sp1[2];
    soc_port_if_t           interface_type;
    uint32                  nof_priorities, tm_port;
    int                     tc, dp;
    int                     mc_reserved_pds;    
    bcm_cosq_egress_multicast_config_t sp_config;
    int                     nof_tc_to_sp0;
    JER2_ARAD_FC_ILKN_RETRANSMIT_CAL_CFG ilkn_rt_cal;
    DNX_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int                           priority = 0;
    bcm_gport_t             gport;

    uint32 profile;
    bcm_dnx_cosq_egress_queue_mapping_info_t *mapping_info = NULL;
    uint32 offset;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    
    dev_id =  (unit);

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_ALLOC(mapping_info, sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t), "egress queue mapping info handle memory");
    if (mapping_info == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate egress queue mapping info handle memory\n"), unit));
    }
    sal_memset(mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));

    BCMDNX_ALLOC(cal_buff, (sizeof(DNX_TMC_FC_REC_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    BCMDNX_ALLOC(gen_cal_buff, (sizeof(DNX_TMC_FC_GEN_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "gen fc calender");
    if (gen_cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory\n"), unit));
    }

    if (is_coldboot) {
        /* By default all zeros */
        if (SOC_IS_JERICHO(unit)) {
            for (priority = 0; priority < DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD; priority++) {
                DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_fc_generic_pfc_mapping_init(unit, priority, SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps), &generic_bm));
            }
        }
        else {
            DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_fc_generic_pfc_mapping_init(unit, 0, SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps), &generic_bm));
        }
    }

    /* process OOB configuration */
    for (oob_if = 0; oob_if < SOC_DNX_CONFIG(unit)->tm.max_oob_ports; oob_if++) {
        if (SOC_DNX_CONFIG(unit)->tm.fc_oob_mode[oob_if] == SOC_DNX_FC_CAL_MODE_DISABLE) {
            continue;
        }

        if (SOC_DNX_CONFIG(unit)->tm.fc_oob_type[oob_if] == DNX_TMC_FC_CAL_TYPE_NONE) {
            continue;
        }

        if ((SOC_DNX_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DNX_FC_CAL_MODE_RX_ENABLE) ||
            (SOC_DNX_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DNX_FC_CAL_MODE_TX_ENABLE) ) {
            cal_mode_ndx = (SOC_DNX_CONFIG(unit)->tm.fc_oob_type[oob_if] == DNX_TMC_FC_CAL_TYPE_ILKN || 
                            SOC_DNX_CONFIG(unit)->tm.fc_oob_type[oob_if] == DNX_TMC_FC_CAL_TYPE_COE || 
                            SOC_DNX_CONFIG(unit)->tm.fc_oob_type[oob_if] == DNX_TMC_FC_CAL_TYPE_E2E) ? 
                            DNX_TMC_FC_CAL_MODE_ILKN_OOB : DNX_TMC_FC_CAL_MODE_SPI_OOB;
        }

        if (is_coldboot) {
            /* OOB interfaces can only be uni-directional */
            if (SOC_DNX_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DNX_FC_CAL_MODE_RX_ENABLE) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.rx.valid.set(unit, oob_if, TRUE));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.rx.intf.set(unit, oob_if, oob_if));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.rx.cal_mode_ndx.set(unit, oob_if, cal_mode_ndx));
            }

            if (SOC_DNX_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DNX_FC_CAL_MODE_TX_ENABLE) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.valid.set(unit, oob_if, TRUE));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.intf.set(unit, oob_if, oob_if));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.cal_mode_ndx.set(unit, oob_if, cal_mode_ndx));
            }
        }
    }

    /* process Inband configuration */
    if (is_coldboot) {
        BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
        BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
        BCM_PBMP_ITER(ports_map, port_i) 
        {
            /* skip stat ports */
            soc_rc = dnx_port_sw_db_flags_get(unit, port_i, &flags);
            DNXC_IF_ERR_EXIT(soc_rc);
            if (DNX_PORT_IS_STAT_INTERFACE(flags)) {
                continue;
            }

            soc_rc = dnx_port_sw_db_interface_type_get(unit, port_i, &interface_type);        
            DNXC_IF_ERR_EXIT(soc_rc);

            if (interface_type == SOC_PORT_IF_NULL || interface_type == SOC_PORT_IF_CPU ||
                interface_type == SOC_PORT_IF_OLP || interface_type == SOC_PORT_IF_RCY ||
                interface_type == SOC_PORT_IF_SAT || interface_type == SOC_PORT_IF_IPSEC ||
                interface_type == SOC_PORT_IF_ERP || interface_type == SOC_PORT_IF_OAMP ||
                interface_type == SOC_PORT_IF_ILKN || interface_type == SOC_PORT_IF_TM_INTERNAL_PKT) {
                continue;
            }

            soc_rc = dnx_port_sw_db_first_phy_port_get(unit, port_i, &phy_port);
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error retreiving phy_port for port (0x%x)\n"), unit, port_i));
            }

            if (!SOC_IS_QAX(unit)) {
                fc_mode = SOC_DNX_CONFIG(unit)->tm.fc_inband_mode[port_i][DNX_TMC_CONNECTION_DIRECTION_RX];
                /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
                switch(fc_mode)
                {
                case 0:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 0);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 1:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 2:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlPFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 3:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlSAFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                default:
                    break;
                }

                fc_mode = SOC_DNX_CONFIG(unit)->tm.fc_inband_mode[port_i][DNX_TMC_CONNECTION_DIRECTION_TX];
                /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
                switch(fc_mode)
                {
                case 0:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 0);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 1:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 2:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlPFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlPFCRefreshTime, -1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 3:
                    rc = bcm_dnx_port_control_set(unit, port_i, bcmPortControlSAFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                default:
                    break;
                }
            }
        }
    }

    /* Process ILKN In-band configuration */
    if (!SOC_IS_QUX(unit)) {
        for (ilkn_if = 0; ilkn_if < SOC_DNX_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
            if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_type[ilkn_if] != DNX_TMC_FC_CAL_INB_TYPE_ILKN) {
                continue;
            }
        
            DNX_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
            if ((SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DNX_FC_CAL_MODE_RX_ENABLE) ||
               (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DNX_FC_CAL_MODE_TX_ENABLE)) {
               cal_mode_ndx = DNX_TMC_FC_CAL_MODE_ILKN_INBND;
            }

            /* inband interfaces can be bi-directional */
            if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DNX_FC_CAL_MODE_RX_ENABLE) {
                if (is_coldboot) 
                {
                    cal_if_info.enable = TRUE;
                    cal_if_info.cal_len = SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_RX];

                    for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                        DNX_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                        (cal_buff + cal_index)->destination = DNX_TMC_FC_REC_CAL_DEST_NONE;
                        (cal_buff + cal_index)->id = 0;
                    }

                    cal_if_info.cal_reps = SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_RX];
            
                    soc_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_rec_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, cal_buff)));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Inband(Rx) calender(%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.rx.valid.set(unit, ilkn_if, TRUE));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.rx.intf.set(unit, ilkn_if, ilkn_if));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.rx.cal_mode_ndx.set(unit, ilkn_if, cal_mode_ndx));
                }
            }

            if (is_coldboot) {
                /* inband-llfc configuration */
                DNX_TMC_FC_ILKN_LLFC_INFO_clear(&llfc_info);

                if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] != SOC_DNX_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
                    llfc_info.cal_channel = (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] == SOC_DNX_FC_INBAND_INTLKN_CAL_LLFC_MODE1) ?
                                   DNX_TMC_FC_ILKN_CAL_LLFC_CH_0 : DNX_TMC_FC_ILKN_CAL_LLFC_CH_16N;
                    llfc_info.multi_use_mask = 0;
                }
                else if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if] != SOC_DNX_FC_INBAND_INTLKN_LLFC_MUB_DISABLE) {
                    llfc_info.cal_channel = DNX_TMC_FC_ILKN_CAL_LLFC_NONE;
                    llfc_info.multi_use_mask = SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if];
                } else {
                    llfc_info.cal_channel = DNX_TMC_FC_ILKN_CAL_LLFC_NONE;
                    llfc_info.multi_use_mask = 0;
                }

                direction_ndx = DNX_TMC_FC_DIRECTION_REC;      
                if (!SOC_IS_ARDON(unit)) {
                    soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_ilkn_llfc_set,(dev_id, ilkn_if, direction_ndx, &llfc_info));
                    if (SOC_FAILURE(soc_rc)) {
                       rc = soc_rc;
                       BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Rx) llfc (%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }                
                }

                direction_ndx = DNX_TMC_FC_DIRECTION_GEN;
                flags = 0;
                PBMP_IL_ITER(unit, port_i)  {
                    DNXC_IF_ERR_EXIT(dnx_port_sw_db_protocol_offset_get(unit, port_i, 0, &offset));
                    if (offset == ilkn_if) {
                        DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
                        break;
                    }
                }
            
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            /* Disable LLFC TX on ELK interface */
            if (SOC_DNX_IS_ELK_ENABLE(unit) && DNX_PORT_IS_ELK_INTERFACE(flags)) {
                llfc_info.cal_channel = DNX_TMC_FC_ILKN_CAL_LLFC_NONE;
            }
#endif 

                if (!SOC_IS_ARDON(unit)) {
                    soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_ilkn_llfc_set, (dev_id, ilkn_if, direction_ndx, &llfc_info));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Tx) llfc (%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }                
                }

                /* mub channel configuration */
                direction_ndx = DNX_TMC_FC_DIRECTION_REC;
                if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_RX] != SOC_DNX_FC_INBAND_INTLKN_CHANNEL_MUB_DISABLE) {
                    soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_ilkn_mub_channel_set,(unit, ilkn_if, direction_ndx, SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_RX]));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Rx)(%d) MUB channel setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }
                }
                direction_ndx = DNX_TMC_FC_DIRECTION_GEN;
                if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_TX] != SOC_DNX_FC_INBAND_INTLKN_CHANNEL_MUB_DISABLE) {
                    soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_ilkn_mub_channel_set,(unit, ilkn_if, direction_ndx, SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_TX]));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Tx)(%d) MUB channel setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }
                }
            }

            if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DNX_FC_CAL_MODE_TX_ENABLE) {
                if (is_coldboot)
                {
                    cal_if_info.enable = TRUE;
                    cal_if_info.cal_len = SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_TX];

                    for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                        DNX_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                        (gen_cal_buff + cal_index)->source = DNX_TMC_FC_GEN_CAL_SRC_CONST;
                        (gen_cal_buff + cal_index)->id = 0;
                    }

                    cal_if_info.cal_reps = SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_TX];
        
                    soc_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, gen_cal_buff)));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Inband(Tx) calender(%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.valid.set(unit, ilkn_if, TRUE));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.intf.set(unit, ilkn_if, ilkn_if));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.cal_mode_ndx.set(unit, ilkn_if, cal_mode_ndx));
                }
            }
        }
    }

    if (is_coldboot) 
    {
        if (SOC_IS_ARADPLUS_AND_BELOW(unit) && 
            SOC_IS_ARAD_B0_AND_ABOVE(unit))
        {
            /* Handle ILKN Retransmit calendars for Arad B0 */
            for (ilkn_if = 0; ilkn_if < SOC_DNX_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
                JER2_ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
                switch(SOC_DNX_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_RX])
                {
                case 0:
                    ilkn_rt_cal.enable = 0;
                    break;
                case 1:
                    /* The RX calendar is hard coded in the HW */
                    /* It needs 1 entry to support Retransmit on one interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 1;
                    break;
                case 2:
                    /* The RX calendar is hard coded in the HW */
                    /* It needs 3 entries to support Retransmit for both interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 3; 
                    break;
                default:
                    ilkn_rt_cal.enable = 0;
                    break;
                }
            
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            dnx_sand_rc = jer2_arad_fc_ilkn_retransmit_cal_set_unsafe(dev_id, (ilkn_if == 0 ? JER2_ARAD_NIF_ILKN_ID_A : JER2_ARAD_NIF_ILKN_ID_B), JER2_ARAD_FC_DIRECTION_REC, &ilkn_rt_cal);        
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in ILKN Retransmit RX calender(%d) setting, dnx_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, dnx_sand_rc, rc));
            }
#endif 

                JER2_ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
                switch(SOC_DNX_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][DNX_TMC_CONNECTION_DIRECTION_TX])
                {
                case 0:
                    ilkn_rt_cal.enable = 0;
                    break;
                case 1:
                    /* The TX calendar is hard coded in the SW */
                    /* It needs 1 entry to support Retransmit on one interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 1;
                    break;
                case 2:
                    /* The TX calendar is hard coded in the SW */
                    /* It needs 2 entries to support Retransmit for both interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 2; 
                    break;
                default:
                    ilkn_rt_cal.enable = 0;
                    break;
                }
            
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            dnx_sand_rc = jer2_arad_fc_ilkn_retransmit_cal_set_unsafe(dev_id, (ilkn_if == 0 ? JER2_ARAD_NIF_ILKN_ID_A : JER2_ARAD_NIF_ILKN_ID_B), JER2_ARAD_FC_DIRECTION_GEN, &ilkn_rt_cal);        
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in ILKN Retransmit TX calender(%d) setting, dnx_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, dnx_sand_rc, rc));
            }
#endif 
            }
        }

        if (SOC_IS_ARDON(unit)) {
            rc = jer2_arad_fc_init_shr_mapping(unit);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_init_pfc_mapping,(unit));
        if (SOC_FAILURE(soc_rc)) {
            rc = soc_rc;
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to set PFC/TC mapping, error 0x%x\n"), unit, rc));
        }

        profile = DNX_COSQ_PB_EGR_QUEUE_DEFAULT_PROFILE_MAP;

        /* Set default configuration */
        SOC_DNX_CORES_ITER(BCM_CORE_ALL, core) {
            rc = _bcm_dnx_cosq_gport_egress_queue_mapping_hw_get(unit, profile, core, mapping_info);
            BCMDNX_IF_ERR_EXIT(rc);

            /* state restored during warmboot */
            rc = _bcm_dnx_am_template_egress_queue_mapping_init(unit, profile, core, mapping_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        total_mc_reserved_pds_sp0[0] = 0;
        total_mc_reserved_pds_sp0[1] = 0;
        total_mc_reserved_pds_sp1[0] = 0;
        total_mc_reserved_pds_sp1[1] = 0;

        /* EGQ Threshold Settings */

        DNXC_IF_ERR_EXIT(dnx_port_sw_db_valid_ports_get(unit, 0, &ports_map)); 

        BCM_PBMP_ITER(ports_map, port_i) {

            DNXC_IF_ERR_EXIT(dnx_port_sw_db_interface_type_get(unit, port_i, &interface_type));
            DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
                          
            if ((DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags)|| 
                 (interface_type == SOC_PORT_IF_ERP) || (interface_type == SOC_PORT_IF_NOCXN))) {
                continue;
            }
            rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
            if(rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting port nof_priorities %d\n"), unit, rc, port_i));
            }

            if(nof_priorities == 1) {
                any_port_with_1_priority = 1;
                break;
            }
        }

        BCM_PBMP_ITER(ports_map, port_i) {

            DNXC_IF_ERR_EXIT(dnx_port_sw_db_interface_type_get(unit, port_i, &interface_type));
            DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
            if (!(DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags) || 
                  (interface_type == SOC_PORT_IF_ERP) || (interface_type == SOC_PORT_IF_NOCXN))) {

                /* init tc/dp map table */
                rc = _bcm_dnx_cosq_gport_egress_map_init(unit, port_i);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set fc port thresholds */
                rc = _bcm_dnx_cosq_fc_port_threshold_init(unit, port_i, &mc_reserved_pds, 0);
                if(rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting port rate %d\n"), unit, rc, port_i));
                }

                rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
                if(rc != BCM_E_NONE) {
                  BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting parent nif for port %d\n"), unit, rc, port_i));
                }

                rc = dnx_port_sw_db_local_to_tm_port_get(unit, port_i, &tm_port, &core);
                if (rc != BCM_E_NONE)
                {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting tm port and core for port %d\n"), unit, rc, port_i));
                }
             
                if (SOC_IS_ARDON(unit)) {
                      total_mc_reserved_pds_sp0[core] += (mc_reserved_pds * nof_priorities);
                } else {
                    if(any_port_with_1_priority == 1 || SOC_DNX_CONFIG(unit)->jer2_arad->init.dynamic_port_enable) {
                           total_mc_reserved_pds_sp0[core] += (mc_reserved_pds * nof_priorities);
                    } else {
                           total_mc_reserved_pds_sp0[core] += ((mc_reserved_pds * nof_priorities) / 2);
                           total_mc_reserved_pds_sp1[core] += ((mc_reserved_pds * nof_priorities) / 2);
                    }
                }
            }
        }

        SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
        {
            dnx_sand_rc = _bcm_dnx_cosq_default_thresholds_set(unit,core, any_port_with_1_priority, total_mc_reserved_pds_sp0[core], total_mc_reserved_pds_sp1[core]);
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
            }
        }

        BCM_COSQ_GPORT_CORE_SET(gport, BCM_CORE_ALL);
        /* MC TC to SP Mapping */
        if (SOC_IS_ARDON(unit)) {
            /* TC0-TC7 to SP0 */
            nof_tc_to_sp0 = 8;
        } else {
            /* TC0-TC3 to SP0 */
            nof_tc_to_sp0 = 4;
        }
        sp_config.unscheduled_se = 1;   /* Pool eligibility */
        sp_config.unscheduled_sp = bcmCosqEgressMulticastServicePool0;   /* Pool ID */
        for(tc = 0; tc < nof_tc_to_sp0 ; tc++)
        {
            sp_config.priority = tc;         /* TC group */
            for (dp = 0; dp < DNX_DEVICE_COSQ_EGR_NOF_DP; dp++)
            {
              rc = bcm_dnx_cosq_gport_egress_multicast_config_set(unit, gport, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
              BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* TC4-TC7 to SP0\SP1 */
        sp_config.unscheduled_se = 1;   /* Pool eligibility */
        sp_config.unscheduled_sp = ((any_port_with_1_priority == 1 || SOC_DNX_CONFIG(unit)->jer2_arad->init.dynamic_port_enable == 1) ? bcmCosqEgressMulticastServicePool0 : bcmCosqEgressMulticastServicePool1);   /* Pool ID */
        for(tc = nof_tc_to_sp0; tc < 8; tc++)
        {
            sp_config.priority = tc;         /* TC group */
            for (dp = 0; dp < DNX_DEVICE_COSQ_EGR_NOF_DP; dp++)
            {
                rc = bcm_dnx_cosq_gport_egress_multicast_config_set(unit, gport, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
     
        /* Enable device-level flow control */
        rc = bcm_dnx_cosq_control_set(unit, 0, 0, bcmCosqControlFlowControlEnable, 1);
        if(rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error(%d) in enabling device-level flow control\n"), unit, rc));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    if (gen_cal_buff != NULL) {
       BCM_FREE(gen_cal_buff);
    }

    BCM_FREE(cal_buff);
    BCM_FREE(gen_cal_buff);
    BCM_FREE(mapping_info);

    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_default_thresholds_set(int unit, int core, int any_port_with_1_priority, int total_mc_reserved_pds_sp0, int total_mc_reserved_pds_sp1)
{
    DNX_TMC_EGR_QUEUING_DEV_TH  *dev_thresh = NULL;
    JER2_ARAD_EGR_FC_DEVICE_THRESH dev_fc_thresh, dev_fc_thresh_exact;
    JER2_ARAD_EGR_FC_OFP_THRESH  fc_mc_thresh, exact_fc_mc_thresh;
    uint32  dnx_sand_rc=0;
    bcm_error_t              rc = BCM_E_NONE;
    int tc;
    BCMDNX_INIT_FUNC_DEFS;

    /* Global Drop Thresholds */
    BCMDNX_ALLOC(dev_thresh, sizeof(DNX_TMC_EGR_QUEUING_DEV_TH), "_bcm_dnx_cosq_fc_init.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    DNX_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_dev_get,(unit, core,dev_thresh)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
    }

    if (unit >= BCM_LOCAL_UNITS_MAX){
        BCM_ERR_EXIT_NO_MSG(BCM_E_UNIT);
    }
    if (SOC_IS_ARDON(unit)) { 
        dev_thresh->global.uc.descriptors = 6000;
        dev_thresh->global.mc.descriptors = 10000;
        dev_thresh->global.total.descriptors = 16000;
        dev_thresh->pool[0].mc.descriptors = 10000;
        dev_thresh->pool[1].mc.descriptors = 10000;
          
        dev_thresh->global.uc.buffers = 6000;
        dev_thresh->global.mc.buffers = 3000;
        dev_thresh->global.total.buffers = 6000;
        dev_thresh->pool[0].mc.buffers = 3000;
        dev_thresh->pool[1].mc.buffers = 3000;
          
        dev_thresh->pool[0].reserved.buffers = 400;
        dev_thresh->pool[1].reserved.buffers = 0;
    } else {
       
        dev_thresh->global.uc.descriptors = 6000;
        dev_thresh->global.mc.descriptors = 26000;
        dev_thresh->global.total.descriptors = 32000;
        dev_thresh->pool[0].mc.descriptors = 13000;
        dev_thresh->pool[1].mc.descriptors = 13000;
          
        dev_thresh->global.uc.buffers = 6000;
        dev_thresh->global.mc.buffers = 6000;
        dev_thresh->global.total.buffers = 12000;
        dev_thresh->pool[0].mc.buffers = 3000;
        dev_thresh->pool[1].mc.buffers = 3000;
        
        dev_thresh->pool[0].reserved.buffers = 600;
        dev_thresh->pool[1].reserved.buffers = 600;
    }

    if((total_mc_reserved_pds_sp0 + total_mc_reserved_pds_sp1) > (2*DNX_COSQ_MAX_SP_PD_THRESH) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Allocated more Reserved Packet Descriptors than allowed by the device.")));
    }
      dev_thresh->pool[0].reserved.descriptors = total_mc_reserved_pds_sp0;
      dev_thresh->pool[1].reserved.descriptors = total_mc_reserved_pds_sp1;


    if (SOC_IS_ARDON(unit)) {
        if(SOC_DNX_CONFIG(unit)->jer2_arad->init.eg_cgm_scheme == JER2_ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
        {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][7].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = 6500;

                dev_thresh->pool_tc[0][0].mc.buffers = 1500;
                dev_thresh->pool_tc[0][1].mc.buffers = 1500;
                dev_thresh->pool_tc[0][2].mc.buffers = 1500;
                dev_thresh->pool_tc[0][3].mc.buffers = 1500;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1500;
                dev_thresh->pool_tc[0][6].mc.buffers = 1500;
                dev_thresh->pool_tc[0][7].mc.buffers = 1500;
                dev_thresh->pool_tc[1][0].mc.buffers = 1500;
                dev_thresh->pool_tc[1][1].mc.buffers = 1500;
                dev_thresh->pool_tc[1][2].mc.buffers = 1500;
                dev_thresh->pool_tc[1][3].mc.buffers = 1500;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1500;
                dev_thresh->pool_tc[1][6].mc.buffers = 1500;
                dev_thresh->pool_tc[1][7].mc.buffers = 1500;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;

        } else {

                /* Strict Priority */
                dev_thresh->pool_tc[0][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[0][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[0][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[0][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[0][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[0][7].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[1][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[1][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[1][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[1][7].mc.descriptors = 13000;

                dev_thresh->pool_tc[0][0].mc.buffers = 3000;
                dev_thresh->pool_tc[0][1].mc.buffers = 2400;
                dev_thresh->pool_tc[0][2].mc.buffers = 2100;
                dev_thresh->pool_tc[0][3].mc.buffers = 1800;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1200;
                dev_thresh->pool_tc[0][6].mc.buffers = 900;
                dev_thresh->pool_tc[0][7].mc.buffers = 600;
                dev_thresh->pool_tc[1][0].mc.buffers = 3000;
                dev_thresh->pool_tc[1][1].mc.buffers = 2400;
                dev_thresh->pool_tc[1][2].mc.buffers = 2100;
                dev_thresh->pool_tc[1][3].mc.buffers = 1800;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1200;
                dev_thresh->pool_tc[1][6].mc.buffers = 900;
                dev_thresh->pool_tc[1][7].mc.buffers = 600;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;
        }
    } else {
        if(SOC_DNX_CONFIG(unit)->jer2_arad->init.eg_cgm_scheme == JER2_ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
        {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:6500;

                dev_thresh->pool_tc[0][0].mc.buffers = 1500;
                dev_thresh->pool_tc[0][1].mc.buffers = 1500;
                dev_thresh->pool_tc[0][2].mc.buffers = 1500;
                dev_thresh->pool_tc[0][3].mc.buffers = 1500;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:1500;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;

        } else {

                /* Strict Priority - if 1 priority, then set thresholds in spaces of 12.5%, otherwise - 25% */
                dev_thresh->pool_tc[0][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[0][1].mc.descriptors = any_port_with_1_priority ? 11375:9750;
                dev_thresh->pool_tc[0][2].mc.descriptors = any_port_with_1_priority ? 9750:6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = any_port_with_1_priority ? 8125:3250;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? 6500:0;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? 4875:0;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? 3250:0;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? 1625:0;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:13000;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:9750;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:3250;

                dev_thresh->pool_tc[0][0].mc.buffers = 3000;
                dev_thresh->pool_tc[0][1].mc.buffers = any_port_with_1_priority ? 2625:2250;
                dev_thresh->pool_tc[0][2].mc.buffers = any_port_with_1_priority ? 2250:1500;
                dev_thresh->pool_tc[0][3].mc.buffers = any_port_with_1_priority ? 1875:750;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? 1125:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? 750:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? 375:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:3000;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:2250;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:750;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;
        }
    }
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_dev_set,(unit, core,dev_thresh)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
    }

#ifdef BCM_88675_SUPPORT
    if (SOC_IS_JERICHO(unit))
    {
        BCMDNX_IF_ERR_EXIT(soc_jer2_jer_sp_tc_init(unit, core, dev_thresh));
    }
#endif /* BCM_88675_SUPPORT */
    
    /* Global FC Thresholds */
    jer2_arad_JER2_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh);
    jer2_arad_JER2_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh_exact);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_dev_fc_get,(unit, core, &dev_fc_thresh)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
    }
     
    if (SOC_IS_ARDON(unit)) {
          dev_fc_thresh.scheduled.buffers = 3200;
          dev_fc_thresh.scheduled.descriptors = 3200;
          dev_fc_thresh.global.descriptors = 15700;
          dev_fc_thresh.global.buffers = 5800;
          dev_fc_thresh.unscheduled.descriptors = 9500;
          dev_fc_thresh.unscheduled.buffers = 2700;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[0].buffers = 2700;
          dev_fc_thresh.unscheduled_pool[1].buffers = 2700;
    }else {
          
          dev_fc_thresh.scheduled.buffers = 6100;
          dev_fc_thresh.scheduled.descriptors = 6100;
          dev_fc_thresh.global.descriptors = 31500;
          dev_fc_thresh.global.buffers = 11800;
          dev_fc_thresh.unscheduled.descriptors = 25000;
          dev_fc_thresh.unscheduled.buffers = 5500;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 12500;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 12500;
          dev_fc_thresh.unscheduled_pool[0].buffers = 2750;
          dev_fc_thresh.unscheduled_pool[1].buffers = 2750;
    }
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_dev_fc_set,(unit, core, &dev_fc_thresh, &dev_fc_thresh_exact)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
    }

    /* Global MC FC Thresholds */
    jer2_arad_JER2_ARAD_EGR_FC_OFP_THRESH_clear(&fc_mc_thresh);
    jer2_arad_JER2_ARAD_EGR_FC_OFP_THRESH_clear(&exact_fc_mc_thresh);
    for(tc = 0; tc < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_fc_get,(unit,core,JER2_ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
        }
        
        if (SOC_IS_ARDON(unit)) {
            if(SOC_DNX_CONFIG(unit)->jer2_arad->init.eg_cgm_scheme == JER2_ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE) {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
            } else {
                /* Strict Priority */
                switch(tc) {
                case 0:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                case 1:
                    fc_mc_thresh.mc.descriptors = 10000;
                    fc_mc_thresh.mc.buffers = 2200;
                    break;
                case 2:
                    fc_mc_thresh.mc.descriptors = 8750;
                    fc_mc_thresh.mc.buffers = 1925;
                    break;
                case 3:
                    fc_mc_thresh.mc.descriptors = 7500;
                    fc_mc_thresh.mc.buffers = 1650;
                    break;
                case 4:
                    fc_mc_thresh.mc.descriptors = 6250;
                    fc_mc_thresh.mc.buffers = 1375;
                    break;
                case 5:
                    fc_mc_thresh.mc.descriptors = 5000;
                    fc_mc_thresh.mc.buffers = 1100;
                    break;
                case 6:
                    fc_mc_thresh.mc.descriptors = 3750;
                    fc_mc_thresh.mc.buffers = 825;
                    break;
                case 7:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                }
            }
        } else {
            if(SOC_DNX_CONFIG(unit)->jer2_arad->init.eg_cgm_scheme == JER2_ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
            {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
            } else {
                /* Strict Priority */
                switch(tc)
                {
                case 0:
                case 4:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                case 1:
                case 5:
                    fc_mc_thresh.mc.descriptors = 9375;
                    fc_mc_thresh.mc.buffers = 2062;
                    break;
                case 2:
                case 6:
                    fc_mc_thresh.mc.descriptors = 6250;
                    fc_mc_thresh.mc.buffers = 1375;
                    break;
                case 3:
                case 7:
                    fc_mc_thresh.mc.descriptors = 3125;
                    fc_mc_thresh.mc.buffers = 687;
                    break;
                } 
            }
        }
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_fc_set,(unit, core ,JER2_ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh,&exact_fc_mc_thresh)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
        }
    }
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_jer2_arad_cosq_get_queue_mc_sp(int unit, int local_port_id, int cosq, int* sp)
{
    uint32  dnx_sand_rc = DNX_SAND_OK;
    int tc_ndx, dp_ndx, found, rv;
    DNX_TMC_EGR_Q_PRIORITY egr_prio;
    JER2_ARAD_EGR_QUEUING_MC_COS_MAP mc_tc_map;
    int profile = 0;
    uint32 tm_port;
    int core;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    if(sp == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("SP cannot be NULL")));
    }
    *sp = -1;

    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_tm_port_get(unit, local_port_id, &tm_port, &core));

    /* PORT --> PROFILE */
    rv = (MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_profile_map_get,(unit, core, tm_port, (uint32*)&profile)));
    BCMDNX_IF_ERR_EXIT(rv);
   
    found = FALSE;
    for(tc_ndx = 0; tc_ndx < DNX_DEVICE_COSQ_EGR_NOF_TC; tc_ndx++) {
      for(dp_ndx = 0; dp_ndx < DNX_DEVICE_COSQ_EGR_NOF_DP; dp_ndx++) {
        /* PROFILE/QUEUE --> TC/DP */
        rv = (MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_prio_get,(unit,core,JER2_ARAD_EGR_MCAST_TO_UNSCHED,tc_ndx,dp_ndx,profile,&egr_prio)));
        BCMDNX_IF_ERR_EXIT(rv);
        
        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if(cosq == egr_prio.tc) { 
          /* TC/DP --> MC SP */
          dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_cos_map_get,(unit, core, tc_ndx, dp_ndx, &mc_tc_map)));
          DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
          
          if(found == TRUE)
          {
            if(*sp != mc_tc_map.pool_id)
            {
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) cannot be mapped to use more than one service pool"), local_port_id, cosq));
            }
          }
          else
          {
            /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            *sp = mc_tc_map.pool_id;
          }

          found = TRUE;
        }
      }
    }

    if(!found){
      /* Couldnt find service pool mapping */
      *sp = -1;
    }

exit:
    BCMDNX_FUNC_RETURN;  
}

int
_bcm_jer2_arad_cosq_update_reserved_pd_threshold_all_sps(int unit)
{
    int     rc = BCM_E_NONE;
    int     total_pd_sp0[SOC_DNX_DEFS_MAX(NOF_CORES)] = {0}, total_pd_sp1[SOC_DNX_DEFS_MAX(NOF_CORES)] = {0}, core;
    DNX_TMC_EGR_QUEUING_DEV_TH  *dev_thresh[SOC_DNX_DEFS_MAX(NOF_CORES)] = {NULL};
    uint32  dnx_sand_rc = DNX_SAND_OK;
    bcm_dnx_cosq_egress_thresh_key_info_t thresh_key;
    int pool_id = 0, tc;
    bcm_port_t               port_i = 0;
    soc_port_if_t interface;  
    uint32  nof_priorities, tm_port, flags;
    pbmp_t ports_bm;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    SOC_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        BCMDNX_ALLOC(dev_thresh[core], sizeof(DNX_TMC_EGR_QUEUING_DEV_TH), "_bcm_jer2_arad_cosq_update_reserved_pd_threshold_all_sps.dev_thresh");
        if (dev_thresh[core] == NULL) {        
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
        }
        DNX_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh[core]);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_dev_get,(unit, core, dev_thresh[core])));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }
    
    /* Recalculate both Service Pools values */
    rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_bm);
    BCMDNX_IF_ERR_EXIT(rc);

    PBMP_ITER(ports_bm, port_i)
    {  
      /* skip non real ports (NOCXN)*/
      BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_interface_type_get(unit, port_i, &interface));
      if((interface == SOC_PORT_IF_ERP) || (interface == SOC_PORT_IF_NOCXN) || (port_i >= SOC_DNX_DEFS_GET(unit, nof_logical_ports))) {
        continue;
      }

      DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
      if (DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags)) {
          continue;
      }

      rc = dnx_port_sw_db_local_to_tm_port_get(unit, port_i, &tm_port, &core);
      BCMDNX_IF_ERR_EXIT(rc);
     
      rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
      BCMDNX_IF_ERR_EXIT(rc);

      for (tc = 0; tc < nof_priorities; tc++) 
      {
        /* Validate that only one SP is used */
        /* Return the used SP ID */
        rc = _bcm_jer2_arad_cosq_get_queue_mc_sp(unit, port_i, tc, &pool_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if(pool_id == -1) continue;

        /* PORT --> RESERVED MC PD */
        rc = _bcm_dnx_am_template_cosq_egr_thresh_data_get(unit,core,port_i,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);

        if(thresh_key.unsch_drop_packet_descriptors_available_tc[tc] > DNX_COSQ_JER2_ARAD_MAX_QUEUE_PD_THRESH)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) reserved PD value (%d) is above max (%d)"), 
                                            port_i, tc, thresh_key.unsch_drop_packet_descriptors_available_tc[tc], DNX_COSQ_JER2_ARAD_MAX_QUEUE_PD_THRESH));
        }

        if(pool_id == 0) {
          total_pd_sp0[core] += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
        else if(pool_id == 1) {
          total_pd_sp1[core] += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
      }
    } /* End of BCM_PBMP_ITER */

    SOC_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        if(total_pd_sp0[core] > DNX_COSQ_JER2_ARAD_MAX_SP_PD_THRESH)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 0 max reserved PD value (%d) is above max (%d) core (%d)"),
                                            total_pd_sp0, DNX_COSQ_JER2_ARAD_MAX_SP_PD_THRESH, core));
        }
        if(total_pd_sp1[core] > DNX_COSQ_JER2_ARAD_MAX_SP_PD_THRESH) 
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 1 max reserved PD value (%d) is above max (%d) core (%d)"),
                                            total_pd_sp0, DNX_COSQ_JER2_ARAD_MAX_SP_PD_THRESH, core));
        }

        /* Update the total with the new value */  
        if(dev_thresh[core]->pool[0].reserved.descriptors != total_pd_sp0[core])
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 0 max reserved PD value (%d) is different than sum of queues thresholds (%d),"
                                                            "core (%d)"),
                                            dev_thresh[core]->pool[0].reserved.descriptors, total_pd_sp0[core], core));
        }
        if(dev_thresh[core]->pool[1].reserved.descriptors != total_pd_sp1[core])
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 1 max reserved PD value (%d) is different than sum of queues thresholds (%d),"
                                                            "core (%d)"),
                                            dev_thresh[core]->pool[1].reserved.descriptors, total_pd_sp1[core], core));
        }
    }

    
exit:
    SOC_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        BCM_FREE(dev_thresh[core]);
    }

    BCMDNX_FUNC_RETURN;
}


int
_bcm_dnx_cosq_qid_type_get(int unit, int core, int base_qid, int *gport,
                             int *is_multicast, int *is_unicast, int *is_isq, int *queue_type)
{
    int                 rc = BCM_E_NONE;
    int                 dnx_sand_rc;
    DNX_SAND_U32_RANGE      queue_range;
    int is_run_allocation;
    DNX_TMC_ITM_INGRESS_SHAPE_INFO isp_info;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_multicast != NULL) {
        (*is_multicast) = FALSE;
    }
    if (is_unicast != NULL) {
        (*is_unicast) = FALSE;
    }
    if (is_isq != NULL) {
        (*is_isq) = FALSE;
    }

    if (queue_type != NULL) {
        (*queue_type) = 0;
    }
    rc = bcm_dnx_fabric_multicast_scheduler_mode_get(unit, core, &is_run_allocation);
    BCMDNX_IF_ERR_EXIT(rc);
    if (is_run_allocation) {
        /* Get multicast queue id range */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_enhanced_get,(unit, core, &queue_range)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    } else {
        queue_range.end = DNX_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MAX;
        queue_range.start = DNX_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MIN;
    }

    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
        BCM_GPORT_MCAST_QUEUE_GROUP_SET((*gport), base_qid);
        if (is_multicast != NULL) {
            (*is_multicast) = TRUE;
        }
        if (queue_type != NULL) {
            (*queue_type) = DNX_DEVICE_COSQ_QUEUE_REGION_MULTICAST;
        }
    }
    else {
        /* Get ISQ queue range */
        DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_get,(unit, core, &isp_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
            BCM_COSQ_GPORT_ISQ_SET((*gport), base_qid);
            if (is_isq != NULL) {
                (*is_isq) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DNX_DEVICE_COSQ_QUEUE_REGION_ISQ;
            }
        } 
        else {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET((*gport), base_qid);
            if (is_unicast != NULL) {
                (*is_unicast) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DNX_DEVICE_COSQ_QUEUE_REGION_UNICAST;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * local Functions
 */
static int
_bcm_dnx_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    DNX_TMC_ITM_QUEUE_INFO queue_info, queue_info_original;    
    DNX_TMC_ITM_QT_NDX sched_mode;
    uint32 base_queue, queue;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency checks */
    rc = _bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, mode, &sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    if (sched_mode == DNX_TMC_ITM_QT_NDX_INVALID){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid mode %d"), unit, mode));
    }

    if (weight != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid weight %d"), unit, weight));
    }

    /* consistency check to determine if {gport, cosq} is valid */  
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Invalid gport 0x%x type.\n"), gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    
    /* consistency check to determine if {gport, cosq} is valid */    
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if (sw_state_num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (cosq < 0 || cosq >= sw_state_num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
          rc = BCM_E_PARAM;
          BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (SOC_IS_ARADPLUS(unit)) { /* check if the base queue is mapped to a module using the same credit module as the requested profile */
        uint32 credit_value_type = DNX_TMC_FAP_CREDIT_VALUE_LOCAL, found_type;
        int perform_check = 1;
        if (!BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) { /* FMQs who use local credit */
            /* find the credit value used according to the fap mapped to the queue */
            DNX_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
            uint32 fap_id;
            int local_fap_id;

            DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
                (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(base_queue), &queue_map_info)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                perform_check = 0;
            } else {
                if (JER2_ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
                    fap_id = queue_map_info.fap_id;
                } else { /* direct mapping mode */
                    bcm_gport_t sysport_gport, modport_gport;
                    BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_sysport_gport_get(unit, sysport_gport, &modport_gport));
                    fap_id = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
                }
                /* We found the mapped FAP ID, now find the credit value type from it, if it is not the local fap */
                BCMDNX_IF_ERR_EXIT(bcm_dnx_stk_my_modid_get(unit, &local_fap_id));
                if (local_fap_id != fap_id) {
                    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_module_to_credit_worth_map_get, (unit, fap_id, &credit_value_type)));
                }
            }
            if (perform_check) {
                DNX_TMC_ITM_CR_REQUEST_INFO cr_req_info;
                DNX_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
                DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_cr_request_get, (unit, sched_mode, &cr_req_info)));
                found_type = cr_req_info.is_remote_credit_value ? DNX_TMC_FAP_CREDIT_VALUE_REMOTE : DNX_TMC_FAP_CREDIT_VALUE_LOCAL;
                if (credit_value_type != found_type) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The credit size of the selected profile is not of the type expected for unit %u mapped to the queue: %s."
                      "\nThe credit size of a unit can be set using bcm_cosq_credit_size_set()"),
                      (unsigned)fap_id, credit_value_type == DNX_TMC_FAP_CREDIT_VALUE_LOCAL ? "local" : "remote"));
                } 
            }
        }
    }
    queue = base_queue + cosq;

    /* retrieve current configuration */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit, core, queue, &queue_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    sal_memcpy(&queue_info_original, &queue_info, sizeof(DNX_TMC_ITM_QUEUE_INFO));
    /* update configuration */
    queue_info.cr_req_type_ndx = sched_mode;
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_set,(unit, core, queue, &queue_info_original, &queue_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 dnx_sand_rc, nof_remote_cores, region;
    bcm_dnx_cosq_gport_info_t *child_info;
    int flow_id_index, orig_sub_flow0_id, orig_sub_flow1_id;
    bcm_dnx_cosq_class_info_t info;
    int updated_type;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    DNX_TMC_SCH_FLOW exact_flow_config;
    DNX_TMC_SCH_SE_INFO *parent_se = NULL;
    DNX_TMC_SCH_FLOW *parent_flow_config = NULL;
    int                        core, i, flow_id;
    DNX_TMC_SCH_SE_ID          sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    /* Consitency checks */

    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_ALLOC(parent_flow_config, sizeof(DNX_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(DNX_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL) ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    DNX_TMC_SCH_SE_INFO_clear(parent_se);
    DNX_TMC_SCH_FLOW_clear(unit, parent_flow_config);

    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on JER2_QAX*/
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &gport, core);
    }
    /* validate child element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, dnx_device_cosq_gport_child_element, &child_info); 
    BCMDNX_IF_ERR_EXIT(rc);
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* validate hookup */
    /* get parent element scheduling mode */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, cs_info->id, parent_se, parent_flow_config)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, child_info->actual_flow_id, weight));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, child_info->actual_flow_id, mode));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id != sw_state_default_se) {

       /* get parent element information for child hookup corresponding to child scheduling mode */
       rc = _bcm_dnx_cosq_credit_class_info_get(unit, core, parent_se, mode, &info);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
       }

       rc = _bcm_dnx_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in adjusting flow type for weight/weight mode, error 0x%x"), unit, rc));
       }
       
       /* hookup hierarchy */
       cs_info->se_type = parent_se->type;
       cs_info->id = parent_se->id;
       switch (cs_info->se_type) {
       case DNX_TMC_SCH_SE_TYPE_HR:
           cs_info->se_info.hr.sp_class = updated_type;
           cs_info->se_info.hr.weight = weight;
           break;
           
       case DNX_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;
            
       default:
           break;
       }
    }

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);
        child_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t                      rc = BCM_E_NONE;    
    uint32                           dnx_sand_rc;
    bcm_dnx_cosq_gport_info_t        *gport_info;
    DNX_TMC_SCH_SE_INFO              *parent_se = NULL;
    DNX_TMC_SCH_FLOW                 *parent_flow_config = NULL;
    int                              flow_id_index, gport_mode;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    bcm_dnx_cosq_class_info_t        info;
    int                             core ;
    DNX_TMC_SCH_SE_ID               sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;

    /* Consitency checks */
    gport_info = NULL ;   
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }


    BCMDNX_ALLOC(parent_flow_config, sizeof(DNX_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(DNX_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL)  ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    DNX_TMC_SCH_SE_INFO_clear(parent_se);
    DNX_TMC_SCH_FLOW_clear(unit, parent_flow_config);


    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on JER2_QAX*/
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &gport, core);
    }
    /* validate child element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, dnx_device_cosq_gport_child_element, &gport_info);
    BCMDNX_IF_ERR_EXIT(rc);
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* get child element scheduling mode */
    rc = _bcm_dnx_cosq_mode_get(unit, core, gport_info->flow_config, gport_info->is_sf2, &gport_mode);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving child element scheduling mode, error 0x%x"), unit, rc));
    }

    (*mode) = gport_mode;

    /* retrieve weight */
    /* get parent element scheduling mode */
    flow_id_index = (gport_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(gport_info->flow_config->sub_flow[flow_id_index].credit_source);

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id == sw_state_default_se) {
        /* retrieve element weight from state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, gport_info->actual_flow_id, weight));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.get(unit, core, gport_info->actual_flow_id, mode));
    }
    else {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, cs_info->id, parent_se, parent_flow_config)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* get parent element information for child hookup corresponding to child scheduling mode */
        rc = _bcm_dnx_cosq_credit_class_info_get(unit, core, parent_se, gport_mode, &info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
        }

        /* determine parent weight mode */
        if (info.weight_mode == DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) {
            (*weight) = 0;
        }
        else if (info.weight_mode == DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) {
            switch (cs_info->se_type) {
                case DNX_TMC_SCH_SE_TYPE_HR:
                    (*weight) = cs_info->se_info.hr.weight;
                    break;

                case DNX_TMC_SCH_SE_TYPE_CL:
                    (*weight) = cs_info->se_info.cl.weight;
                    break;

                default:
                    (*weight) = 0;
                    break;
            }
        }
        else if (info.weight_mode == DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) {
            rc = _bcm_dnx_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (info.weight_mode == DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) {
            rc = _bcm_dnx_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    DNX_TMC_ITM_QUEUE_INFO queue_info;    
    uint32 base_queue, queue;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    if (mode == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointer(mode) not being passed")));
    }
    DNX_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency check to determine if {gport, cosq} is valid */  
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Invalid gport 0x%x type.\n"), gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
 
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if (sw_state_num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }

    if (cosq < 0 || cosq >= sw_state_num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);     
    }    

    if (weight != NULL) {
        (*weight) = 0;
    }    
    
    queue = base_queue + cosq;

    /* retrieve current configuration */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit, core, queue, &queue_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_DNX_UNIT_CHECK(unit);
    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */

    rc = _bcm_dnx_cosq_user_q_type_to_delay_tolerance(unit, queue_info.cr_req_type_ndx, mode);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Choose Strict priority to Connect to. SP range: H/L and  
 * Medium (PB only)
 */
static int
_bcm_dnx_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port, rate;    
    int core;
    DNX_TMC_EGR_OFP_SCH_INFO info;    

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    DNX_TMC_EGR_OFP_SCH_INFO_clear(&info);

    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }
      
    /* valid */
    if (!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP2)) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range is SP0-SP2")));
    }

    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* Set egress ofp scheduler info */
    rc = _bcm_dnx_cosq_mode_sp_to_egr_ofp_interface_prio(unit, mode,&(info.nif_priority));
    BCMDNX_IF_ERR_EXIT(rc);
   
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* update port sw rate to mark calendar as modified */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_single_port_rate_sw_get,(unit, core, tm_port, &rate)));  
    DNX_BCM_SAND_IF_ERR_EXIT(bcm_dnx_cosq_gport_bandwidth_set(unit, gport, 0, 0, rate, BCM_COSQ_BW_NOT_COMMIT));

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Get the strict priority that the port is connected to. 
 * SP range: H/L and Medium (PB only)
 */
static int
_bcm_dnx_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;
    int core, is_high_priority;
    DNX_TMC_EGR_OFP_SCH_INFO info;       

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    /* clear */
    DNX_TMC_EGR_OFP_SCH_INFO_clear(&info);
      
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_is_high_priority_port_get,(unit, core, tm_port, &is_high_priority)));

    if (is_high_priority) {
        *mode = BCM_COSQ_SP0;
    } else {
        *mode = BCM_COSQ_SP1;
    }

    *weight = -1;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the structure of wfq scheduler given
 * bcm mode (SP) and weight
 */
static int
_bcm_dnx_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(uint8 is_ucast_egress_queue,
                                                        int mode,
                                                        int weight,
                                                        DNX_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);

    if (mode != -1) {
        /* SP */
        /* 0 - indicate SP High */
        /* > 0 - indicate lower priority */
        if (is_ucast_egress_queue == DNX_SAND_TRUE) {
            sch_wfq_p->sched_weight = (mode == DNX_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;
            sch_wfq_p->unsched_weight = (mode == DNX_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;
        } else {
            sch_wfq_p->sched_weight = (mode == DNX_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;  
            sch_wfq_p->unsched_weight = (mode == DNX_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;  
        }
    } else {
        /* Take weight into consideration */
        if (is_ucast_egress_queue == DNX_SAND_TRUE) {
            sch_wfq_p->sched_weight = weight;
        } else {
            sch_wfq_p->unsched_weight = weight;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the bcm mode (SP) and weight from structure of wfq scheduler
 * 
 */
static int
_bcm_dnx_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(uint8 is_ucast_egress_queue,
                                                        DNX_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p,
                                                        int *mode,
                                                        int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    if (is_ucast_egress_queue == DNX_SAND_TRUE) {
        if (sch_wfq_p->sched_weight == 0) {
            *mode = DNX_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->unsched_weight == 0) {
                *mode = DNX_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->sched_weight;
            }
        }
    } else {
        if (sch_wfq_p->unsched_weight == 0) {
            *mode = DNX_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->sched_weight == 0) {
                *mode = DNX_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->unsched_weight;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority TC-X to the TCG-Y
 */
static int
_bcm_dnx_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_QUEUING_TCG_INFO info;
    DNX_TMC_EGR_Q_PRIO prio;
    DNX_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= DNX_TMC_TCG_MIN && mode <= DNX_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;
    /* Clear */
    DNX_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    info.tcg_ndx[prio] = tcg;
   
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_ofp_tcg_set,(unit,core,tm_port,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
static int
_bcm_dnx_cosq_gport_egress_port_tc_sched_get(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int *mode,
                                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_QUEUING_TCG_INFO info;
    DNX_TMC_EGR_Q_PRIO prio;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    /* Clear */
    DNX_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *mode = info.tcg_ndx[prio] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority (HR) TC-X to the TCG-Y
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tc_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_SCH_PORT_INFO info;
    DNX_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= DNX_TMC_TCG_MIN && mode <= DNX_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;

    /* Clear */
    DNX_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_get,(unit,core,tm_port,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    info.tcg_ndx[cosq] = tcg;
   
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit,core,tm_port,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_SCH_PORT_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    DNX_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_get,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *mode = info.tcg_ndx[cosq] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_egress_fill_tcg_weight_from_mode_weight(int unit,
                                                        int mode,
                                                        int weight,
                                                        uint32* tcg_weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (mode == BCM_COSQ_SP0) {
      *tcg_weight = 0; /* SP */
    } else if (mode == -1) {
      /* Take weight into consideration */
      *tcg_weight = weight;
    } else if (mode == BCM_COSQ_NONE) {
      *tcg_weight = -1;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - invalid mode given. mode: %d, weight: %d"), mode, weight));
    }
    

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_SCH_TCG_WEIGHT info;
    DNX_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DNX_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    DNX_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tcg_weight_get,(unit, core, tm_port, tcg_ndx, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    info.tcg_weight_valid = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    if (info.tcg_weight_valid) {
      info.tcg_weight = weight;
    }
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tcg_weight_set,(unit, core, tm_port, tcg_ndx, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int *mode,
                                                int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_SCH_TCG_WEIGHT info;
    DNX_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Clear */
    DNX_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tcg_weight_get,(unit, core, tm_port, tcg_ndx, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *mode = (info.tcg_weight_valid) ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
static int
_bcm_dnx_cosq_gport_egress_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_TCG_SCH_WFQ info;
    DNX_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_SP0) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0 or NONE ")));
    }
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DNX_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    DNX_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    info.tcg_weight_valid  = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    
    rc = _bcm_dnx_cosq_egress_fill_tcg_weight_from_mode_weight(unit,mode,weight,&info.tcg_weight);
    BCMDNX_IF_ERR_EXIT(rc);
   
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_tcg_weight_set,(unit,core,tm_port,tcg_ndx,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
static int
_bcm_dnx_cosq_gport_egress_port_tcg_sched_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             int *mode,
                                             int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_TCG_SCH_WFQ info;
    DNX_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    
    BCMDNX_NULL_CHECK(weight);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    DNX_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *mode = info.tcg_weight_valid ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Configure the SP to connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
static int
_bcm_dnx_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_OFP_SCH_INFO info;
    DNX_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    uint8 is_ucast_egress_queue;
    int queue_id;
    int max_cosq_num;        

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* clear */
    DNX_TMC_EGR_OFP_SCH_INFO_clear(&info);
          
    max_cosq_num = DNX_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((mode == -1) || (mode >= BCM_COSQ_SP0 && mode <= BCM_COSQ_SP1))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0-1 ")));
    }

    rc = _bcm_dnx_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, max_cosq_num for this ofp: %d"), queue_id,max_cosq_num));
    }    

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 1 && ((weight) <= (DNX_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
        
    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = DNX_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = DNX_SAND_FALSE;
    }

    /* Fill WFQ SCH structure */
    rc = _bcm_dnx_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(is_ucast_egress_queue,mode,weight,sch_wfq_p);
    BCMDNX_IF_ERR_EXIT(rc);
            
    /* Set configuration */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Set weight, sp between FMQ class
 */
static int
_bcm_dnx_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;  
    int index, core, gport_cores;
    DNX_TMC_MULT_FABRIC_INFO info;            

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (mode == -1 && (weight < 0 || weight > DNX_COSQ_FMQ_MAX_BE_WEIGHT)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
    }
      
    /* clear */
    DNX_TMC_MULT_FABRIC_INFO_clear(&info);

    /* Get cores */
    gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(gport);
    SOC_DNX_CORE_VALIDATE(unit, gport_cores, TRUE);

    BCM_DNX_CORES_ITER(gport_cores, core) {
        /* Get configuration */
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (mode != -1) {
            /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
            info.best_effort.wfq_enable = DNX_SAND_FALSE;
            for (index = 0; index < DNX_COSQ_FMQ_NOF_BE; index++) {
                info.best_effort.be_sch_port[index].weight = 0;
            }
        } else {
            /* Set weight configuration */
            info.best_effort.wfq_enable = DNX_SAND_TRUE;

            if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
                info.best_effort.be_sch_port[0].weight = weight;
            } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
                info.best_effort.be_sch_port[1].weight = weight;
            } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
                info.best_effort.be_sch_port[2].weight = weight;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
            }
        }

        /* Set configuration */
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_set,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Retrieve weight, sp between FMQ class
 */
static int
_bcm_dnx_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t rc = BCM_E_NONE;  
    DNX_TMC_MULT_FABRIC_INFO info;            
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate */
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
      
    /* Get core */
    core = BCM_GPORT_SCHEDULER_CORE_GET(gport);

    /* Get with BCM_CORE_ALL assumes symetric configuration,
       in this case use core 0 to get information */
    if(core == BCM_CORE_ALL) {
        core = 0;
    }
          
    /* Get configuration */
    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(info.best_effort.wfq_enable)) {
        /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
        *mode = 0;
        *weight = -1;
    } else {
        *mode = -1;

        /* weight configuration */
        if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
            *weight = info.best_effort.be_sch_port[0].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
            *weight = info.best_effort.be_sch_port[1].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
            *weight = info.best_effort.be_sch_port[2].weight;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Get the SP that the port connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
static int
_bcm_dnx_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc, tm_port;    
    int core;
    DNX_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    DNX_TMC_EGR_OFP_SCH_INFO info;
    uint8 is_ucast_egress_queue;
    int max_cosq_num, queue_id;        

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
    BCM_DNX_UNIT_CHECK(unit);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    DNX_TMC_EGR_OFP_SCH_INFO_clear(&info);

    max_cosq_num = DNX_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);
    
    rc = _bcm_dnx_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, queue_id can be in range of 0-1 or High/Low priorities"), queue_id));
    }

    /* Get existed configuration. */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* Fill mode, weight */
    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = DNX_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = DNX_SAND_FALSE;
    }

    rc = _bcm_dnx_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(is_ucast_egress_queue,sch_wfq_p,mode,weight);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set single port rate.
 */
static int
_bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32          tm_port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    soc_port_t      port;
    int core;          

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    
    
    /* Verify */
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > DNX_TMC_IF_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));   
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(flags & BCM_COSQ_BW_NOT_COMMIT)) {
        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_single_port_rate_hw_set,(unit, core, tm_port));   
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* currently only BCM_COSQ_BW_NOT_COMMIT flag is supported */
    if ((flags & ~(BCM_COSQ_BW_NOT_COMMIT)) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: ?%d\nFlags must be set to 0"), flags)); 
    }

exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get OFP shaping rate, get single port rate.
 */
static int
_bcm_dnx_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;  
    uint32 tm_port;
    soc_port_t port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;

    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
    BCM_DNX_UNIT_CHECK(unit);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    *kbits_sec_min = 0;
    *flags = 0;

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (q-pair) shaping rate, set single port rate.
 */
static int
_bcm_dnx_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    DNX_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc); 

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    if (kbits_sec_max > DNX_TMC_IF_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }       

    /* Set configuration */
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_port_priority_rate_sw_set,(unit, core, tm_port ,prio, kbits_sec_max));                   
    BCMDNX_IF_ERR_EXIT(rc);    
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_port_priority_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (q-pair) shaping rate
 */
static int
_bcm_dnx_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    DNX_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_port_priority_rate_hw_get,(unit, core, tm_port ,prio, kbits_sec_max));                 
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }        

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (HR) shaping rate, set single port rate.
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > DNX_TMC_SCH_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_port_priority_rate_set,(unit, core, tm_port ,cosq, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (HR) shaping rate
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                uint32 *kbits_sec_min,
                                                uint32 *kbits_sec_max,
                                                uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_port_priority_rate_get,(unit, core, tm_port, cosq, kbits_sec_max));                  
    BCMDNX_IF_ERR_EXIT(rc);    

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_bcm_cosq_to_tcg(int unit,
                                int cosq,
                                DNX_TMC_TCG_NDX *tcg)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (cosq < DNX_TMC_TCG_MIN || cosq > DNX_TMC_TCG_MAX) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
    }
    *tcg = cosq;
    
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure TCG shaping rate
 */
static int
_bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    DNX_TMC_TCG_NDX tcg;
    int core;
    soc_port_t port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > DNX_TMC_IF_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    /* Set configuration */    
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_tcg_rate_sw_set,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);   
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_tcg_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);   

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TCG shapring rate
 */
static int
_bcm_dnx_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    DNX_TMC_TCG_NDX tcg;
    soc_port_t port;
    DNX_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_tcg_rate_hw_get,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == DNX_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_dnx_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }            

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure TCG shaping rate - E2E
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    DNX_TMC_TCG_NDX tcg;
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tcg"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > DNX_TMC_SCH_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_tcg_rate_set,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get E2E Port-TCG shapring rate
 */
static int
_bcm_dnx_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    DNX_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only E2E port tcg"), unit, gport));
    }

    rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_tcg_rate_get,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;
    
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set configuration per interface.
 */
static int
_bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"),flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_interface_shaper_set,(unit, core, tm_port, DNX_TMC_OFP_SHPR_UPDATE_MODE_OVERRIDE,kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get configuration of OFP shaping rate, get configuration per interface.
 */
static int
_bcm_dnx_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of interface gport"), cosq));
    }

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_interface_shaper_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_MULT_FABRIC_INFO info;   
    int core, gport_cores; 

    BCMDNX_INIT_FUNC_DEFS;
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid minimum kbits per second parameter %d\n"), unit, kbits_sec_min));
    }
    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter %d\n"), unit, flags));
    }

    /* Get cores */
    gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(gport);
    SOC_DNX_CORE_VALIDATE(unit, gport_cores, TRUE);

    BCM_DNX_CORES_ITER(gport_cores, core) {
        /* Get existing configuration */
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
            info.max_rate = kbits_sec_max;
        } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
            info.guaranteed.gr_shaper.rate = kbits_sec_max;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
            info.best_effort.be_shaper.rate = kbits_sec_max;
        }
        
        /* Set configuration */
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_set,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_MULT_FABRIC_INFO info;  
    int core;  

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }

    /* Get core */
    core = BCM_GPORT_SCHEDULER_CORE_GET(gport);

    /* Get with BCM_CORE_ALL assumes symetric configuration,
       in this case use core 0 to get information */
    if(core == BCM_CORE_ALL) {
        core = 0;
    }

    /* Get existing configuration */
    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;

    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
        *kbits_sec_max = info.max_rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
        *kbits_sec_max = info.guaranteed.gr_shaper.rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        *kbits_sec_max = info.best_effort.be_shaper.rate;
    }      

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    DNX_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    uint32 dnx_sand_rc;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
 
    /* Set ISQ range in hardware (symmetric configuration for all cores)*/
    BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
     
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_get,(unit, core, &isp_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        BCM_DNX_UNIT_CHECK(unit);

        isp_info.rate = kbits_sec_max;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_set,(unit, core, &isp_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

 exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;    
    DNX_TMC_ITM_INGRESS_SHAPE_INFO isp_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
 
    /* Set ISQ range in hardware */
    DNX_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_ingress_shape_get,(unit, BCM_CORE_ALL, &isp_info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *kbits_sec_max = isp_info.rate;
    *kbits_sec_min = 0;
    *flags = 0;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;

}

static int
_bcm_dnx_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       dnx_sand_rc = 0;
    bcm_dnx_cosq_gport_info_t *port_info;
    DNX_TMC_SCH_FLOW          exact_flow_config;
    int                       flow_id_index, i, flow_id, orig_sub_flow0_id, orig_sub_flow1_id;
    int                       orig_sub_flow0_update_bw_only, orig_sub_flow1_update_bw_only;
    int                       core ;
    uint32                    nof_remote_cores, region;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (kbits_sec_min != 0) {
        /* no guaranteed rate supported for this type */
        LOG_WARN(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit(%d) kbits_sec_min(%d > 0) unsupported gport(0x%08x)\n"),
                             unit, kbits_sec_min, gport));
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &gport, core);
    }
    /* validate port element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
    /*
     * Note that we are changing here, intentionally, the actual data on 'port_info->flow_config'.
     * If OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is non-zero and 'spn_COSQ_RUNTIME_PERFORMANCE_OPTIMIZE_ENABLE' is non-zero,
     * this block is on the tree and reading it will result in the (correct) new data.
     */
    (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_rate = kbits_sec_max;

    /* set all symmetric connections */
    if (port_info->is_connector) {
        region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
        nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

    orig_sub_flow0_update_bw_only = port_info->flow_config->sub_flow[0].update_bw_only ;
    orig_sub_flow1_update_bw_only = port_info->flow_config->sub_flow[1].update_bw_only ;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

        port_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        port_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        port_info->flow_config->sub_flow[0].update_bw_only = 1;
        port_info->flow_config->sub_flow[1].update_bw_only = 1;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
            port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif
    port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
    port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t                       rc = BCM_E_NONE;
    bcm_dnx_cosq_gport_info_t         *port_info;
    int                               flow_id_index;
    int                               base_flow_id = 0, is_connector, gport_sf2_type,numq = 0;
    int                              core ;
    uint8                            sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* consistency check to determine if cosq is valid */
    is_connector = (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ? TRUE : FALSE;
    if (is_connector == TRUE) {
        /* determine flow id */
        base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DNX_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == TRUE) {
            /* determine flow id */
            base_flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        }
    }

    if (is_connector) {
        if (SOC_IS_QAX(unit)) {
            base_flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, base_flow_id);
        }
        /* retrieve connector group state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) has an invalid num_cos of %d"), unit, base_flow_id, sw_state_num_cos));
        }
        numq = sw_state_num_cos;
    }

    if (is_connector) {
        if (cosq >= numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if ( (cosq != 0) && (cosq != -1) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else { /* should never reach here */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x), gport type should be connector or scheduler"), unit, gport));
    }
    
    /* misc consistency checks */
    if (kbits_sec_max == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, kbits_sec_max parameter"), unit));
    }
    if (kbits_sec_min != NULL) {
        (*kbits_sec_min) = 0;
    }
    if (flags != NULL) {
        (*flags) = 0;
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &gport, core);
    }
    /* validate port element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
    (*kbits_sec_max) = (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_rate;

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
 _bcm_dnx_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_max > DNX_TMC_SCH_MAX_RATE_KBPS_JER2_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d out of range max %d"), kbits_sec_max, DNX_TMC_SCH_MAX_RATE_KBPS_JER2_ARAD(unit)));
    }    

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(flags & BCM_COSQ_BW_NOT_COMMIT)) {
        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_single_port_rate_hw_set,(unit, core, tm_port));  
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* currently only BCM_COSQ_BW_NOT_COMMIT flag is supported */
    if ((flags & ~(BCM_COSQ_BW_NOT_COMMIT)) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: ?%d\nFlags must be set to 0"), flags)); 
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, kbits_sec_max));


exit:
    BCMDNX_FUNC_RETURN;
}


static int
 _bcm_dnx_cosq_gport_e2e_port_bandwidth_get(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 *kbits_sec_min,
                                              uint32 *kbits_sec_max,
                                              uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;/*always 0*/
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) get e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

static int
 _bcm_dnx_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d\nkbits_sec_min must be set to 0"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_if_shaper_rate_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), unit, gport, kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

static int
 _bcm_dnx_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_if_shaper_rate_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), 
                          unit, gport, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_sched_cl_weight_get(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                       *weight,
                                            bcm_dnx_cosq_gport_info_t *port_info)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dnx_cosq_class_info_t  class_info;
    int                        weight_ap;
    uint32                     dnx_sand_rc;
    DNX_TMC_SCH_SE_CL_CLASS_INFO  *class_type = NULL;
    int                        core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    (*weight) = 0;

    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != DNX_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d, must be 0 or -1"), unit, cosq));
    }

    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }    

    rc = _bcm_dnx_cosq_credit_class_info_get(unit, core, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }
    if (weight_ap >= class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    BCMDNX_ALLOC(class_type, sizeof(DNX_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    if (class_type == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d,could not allocate class type"),unit));
    }

    DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, port_info->se_config->type_info.cl.id, class_type)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, dnx_sand_rc, rc));
        goto err;
    }

    (*weight) = class_type->weight[weight_ap];

   BCM_FREE(class_type);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (class_type != NULL) {
       BCM_FREE(class_type);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_flow_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dnx_cosq_gport_info_t  *port_info;
    int                        flow_id_index, core;    

    
    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;

    if(!BCM_GPORT_IS_FABRIC_CLOS(port) && !BCM_GPORT_IS_FABRIC_MESH(port)) {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    switch(type) {

        case bcmCosqControlBandwidthBurstMax:
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }      
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            if (SOC_IS_QAX(unit)) {
                _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
            (*arg) = (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_burst;

            break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port)  || BCM_GPORT_IS_FABRIC_CLOS(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }

            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if(BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/

                if (SOC_IS_QAX(unit)) {
                    _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
                }

                /* validate port element */
                rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dnx_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
                if (port_info == NULL) {
                     LOG_ERROR(BSL_LS_BCM_COSQ,
                               (BSL_META_U(unit,
                                           "unit %d, resource memory allocation failure\n"), unit));
                    rc = BCM_E_MEMORY;
                    goto err;
                }

                flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;

                if ((port_info->flow_config)->is_slow_enabled == FALSE) {
                    (*arg) = 0;
                }
                else {
                    (*arg) = ((port_info->flow_config)->sub_flow[flow_id_index].slow_rate_ndx == 0)? 1:2 ;
                }

            }
            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port))) 
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure CLOS FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
            if (rc != BCM_E_NONE) {
                goto err;
            }
           break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:
            if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port))) {
                rc = BCM_E_PARAM;
                goto err;
            }

            if (SOC_IS_QAX(unit)) {
                _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dnx_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            rc = _bcm_dnx_cosq_control_sched_cl_weight_get(unit, port, cosq, type, arg, port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case bcmCosqControlSpLevelMax:
            break;

        case bcmCosqControlSp0WeightMax:
            break;
        case bcmCosqControlSp1WeightMax:
            break;
        case bcmCosqControlSp2WeightMax:
            break;
        case bcmCosqControlSp3WeightMax:
            break;
        case bcmCosqControlSp4WeightMax:
            break;
        case bcmCosqControlSp5WeightMax:
            break;
        case bcmCosqControlSp6WeightMax:
            break;
        case bcmCosqControlSp7WeightMax:
            break;
        case bcmCosqControlSp8WeightMax:
            break;
        case bcmCosqControlSp9WeightMax:
            break;
        case bcmCosqControlSp10WeightMax:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_hr_fc_validate_info_get(int unit, int hr_mode, bcm_cos_queue_t cosq, int arg, int *hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int cos;
   
    
    BCMDNX_INIT_FUNC_DEFS;
    cos = (cosq == -1) ? arg : cosq;

    if (cosq != -1) {
        if (arg != BCM_COSQ_HIGH_PRIORITY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Flow control not supported for cos %d and arg 0x%x\n"), unit, cosq, arg));
        }
    }

    switch (hr_mode) {
        case DNX_TMC_SCH_HR_MODE_SINGLE_WFQ:
            switch (cos) {
                case 0: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_SINGLE_CLASS_AF1_WFQ; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case DNX_TMC_SCH_HR_MODE_DUAL_WFQ:
            switch (cos) {
                case 0: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case DNX_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            switch (cos) {
                case 0: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 8: (*hr_class) = DNX_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Unknown HR mode %d\n"), unit, hr_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_hr_fc_update(int unit, int profile, int hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_SCH_PORT_HP_CLASS_INFO class_info;
    uint32 dnx_sand_rc;           

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_SCH_PORT_HP_CLASS_INFO_clear(&class_info);

    /* retrieve profile */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_hp_class_conf_get,(unit, &class_info)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    /* update profile */
    class_info.lowest_hp_class[profile] = hr_class;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_hp_class_conf_set,(unit, &class_info)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_petrs_cosq_port_hr_flow_control_set(int unit, bcm_gport_t port, bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type, int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    int hr_mode, hr_class;
    int old_profile, profile, is_last, is_allocated;
    int core;
    DNX_TMC_SCH_PORT_INFO port_info;
    uint32 dnx_sand_rc, tm_port;        

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_SCH_PORT_INFO_clear(&port_info);

    /* determine fap port */
    rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    if (rc != BCM_E_NONE) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (tm_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, tm_port, port));
    }

    /* get associated configuration */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_get,(unit, core, tm_port, &port_info)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retrieving scheduler info port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, tm_port, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    hr_mode = port_info.hr_mode;

    /* consistency checks and new class info */
    rc = _bcm_dnx_cosq_hr_fc_validate_info_get(unit, hr_mode, cosq, arg, &hr_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* get new profile */
    rc = _bcm_dnx_am_template_cosq_port_hr_fc_exchange(unit, core, tm_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* if required update device configuration */
    if (is_allocated == TRUE) {
        rc = _bcm_dnx_cosq_hr_fc_update(unit, profile, hr_class);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* if required update port configuration */
    if ( (old_profile != profile) || (port_info.lowest_hp_class != hr_class) ) {
        port_info.lowest_hp_class = hr_class;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, tm_port, &port_info)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, tm_port, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowControlPriority:
            /* Supported only in case of not Port-TC enable */
            if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
                rc = _bcm_petrs_cosq_port_hr_flow_control_set(unit, port, cosq, type, arg);
            }
            break;
        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_control_e2e_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(arg);

    switch(type) {
        case bcmCosqControlFlowControlPriority:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_sched_cl_weight_set(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                        weight,
                                            bcm_dnx_cosq_gport_info_t *port_info)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dnx_cosq_class_info_t        class_info;
    int                              weight_ap;
    uint32                           dnx_sand_rc;
    DNX_TMC_SCH_SE_CL_CLASS_INFO        *class_type = NULL, *exact_class_type = NULL;
    bcm_dnx_cosq_sched_class_data_t  class_data;
    int                              *weights, flags = 0;
    int                              is_last, class_template, is_allocated;
    DNX_TMC_SCH_FLOW                 *exact_flow_config = NULL;
    int                              core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != DNX_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
    }
    if(weight < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Weight must be positive %d\n"), unit, weight));
    }

    /* determine if the attachment point is valid */
    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }    

    rc = _bcm_dnx_cosq_credit_class_info_get(unit, core, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }
    if (weight_ap >= class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    /* retrieve class data */
    BCMDNX_ALLOC(class_type, sizeof(DNX_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    BCMDNX_ALLOC(exact_class_type, sizeof(DNX_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    if ( (class_type == NULL) || (exact_class_type == NULL) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("memory allocation failed")));
    }

    DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);
    DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(exact_class_type);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, port_info->se_config->type_info.cl.id, class_type)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    weights = (int *)class_type->weight;
    DNX_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, class_type->mode, class_type->enhanced_mode, class_type->weight_mode, weights);

    /* update the new template data */
    class_data.weights[weight_ap] = weight;

    /* get new template */
    rc = _bcm_dnx_am_template_cosq_sched_class_exchange(unit, core, flags, (int *)&class_data, port_info->se_config->type_info.cl.id, &is_last, &class_template, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);
   
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, template Sched(cl), Allocated(%s), is_last(%s), oldTemplate(%d), Template(%d)\n"), ((is_allocated == TRUE) ? "TRUE" : "FALSE"), ((is_last == TRUE) ? "TRUE" : "FALSE"), port_info->se_config->type_info.cl.id, class_template));

    /* if required update h/w with template */
    if (is_allocated == TRUE) {
        /* update class information */
        class_type->weight[weight_ap] = weight;
        class_type->id = class_template;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_set,(unit, core, class_template, class_type, exact_class_type)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in class type for class index(%d)\n"), unit, class_template));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }

    /* map the new CL profile */
    port_info->se_config->type_info.cl.id = class_template;
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, port_info->se_id, port_info->se_config, port_info->flow_config, exact_flow_config)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type cl\n"), unit, port_info->se_id));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(class_type);
    BCM_FREE(exact_class_type);
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_flow_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       dnx_sand_rc = 0;    
    bcm_dnx_cosq_gport_info_t *port_info;
    DNX_TMC_SCH_FLOW          exact_flow_config;
    int                       flow_id_index, is_slow_enabled, slow_rate_index;
    int                       core = 0, i, flow_id, orig_sub_flow0_id, orig_sub_flow1_id;
    uint32                    region, nof_remote_cores;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        if(!BCM_GPORT_IS_FABRIC_CLOS(port) && !BCM_GPORT_IS_FABRIC_MESH(port)) {
            rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    switch(type) {

        /* Set burst max for flow shaper */
        case bcmCosqControlBandwidthBurstMax:
        {
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }  
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            if (SOC_IS_QAX(unit)) {
                _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            /* Validate arg */
            if (arg < 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, arg %d invalid\n"), unit, arg));
                rc = BCM_E_PARAM;
                goto err;
            }

            flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
            /*
             * Note that we are changing here, intentionally, the actual data on 'port_info->flow_config'.
             * If OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is non-zero and 'spn_COSQ_RUNTIME_PERFORMANCE_OPTIMIZE_ENABLE' is non-zero,
             * this block is on the tree and reading it will result in the (correct) new data.
             */
            (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_burst = arg;

            /* set all symmetric connections */
            if (port_info->is_connector) {
                region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
                nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
            } else {
                nof_remote_cores = 1;
            }

            orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
            orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

            for (i = 0; i < nof_remote_cores; i++) {           
                flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

                port_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                               nof_remote_cores, i);
                port_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                              nof_remote_cores, i);

                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));

                if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                    {
                        port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                        port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                    }
/* } */
#endif
                    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
                }
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
        }
        break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_GPORT_IS_FABRIC_CLOS(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/
                int  orig_sub_flow0_update_bw_only, orig_sub_flow1_update_bw_only;

                if ( (arg != 0) && (arg != 1) && (arg != 2) ) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid arg %d for type %d\n"), unit, arg, type));
                    goto err;
                }

                if (SOC_IS_QAX(unit)) {
                    _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
                }
                /* validate port element */
                rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dnx_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
                if (port_info == NULL) {
                     LOG_ERROR(BSL_LS_BCM_COSQ,
                               (BSL_META_U(unit,
                                           "unit %d, resource memory allocation failure\n"), unit));
                    rc = BCM_E_MEMORY;
                    goto err;
                }

                is_slow_enabled = (arg == 0) ? FALSE : TRUE;
                slow_rate_index = 1;
                if (is_slow_enabled) {
                    slow_rate_index = (arg == 1) ? 0 : 1;
                }

                flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;

                (port_info->flow_config)->is_slow_enabled = is_slow_enabled;
                if (is_slow_enabled == FALSE) {
                    /* set to default value */
                    (port_info->flow_config)->sub_flow[0].slow_rate_ndx = slow_rate_index;
                    if (port_info->is_composite) {
                        (port_info->flow_config)->sub_flow[1].slow_rate_ndx = slow_rate_index;
                    }
                }
                else {
                    (port_info->flow_config)->sub_flow[flow_id_index].slow_rate_ndx = slow_rate_index;
                }

                /* set all symmetric connections */
                if (port_info->is_connector) {
                    region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
                    nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
                } else {
                    nof_remote_cores = 1;
                }

                orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
                orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

                orig_sub_flow0_update_bw_only = port_info->flow_config->sub_flow[0].update_bw_only ;
                orig_sub_flow1_update_bw_only = port_info->flow_config->sub_flow[1].update_bw_only ;

                for (i = 0; i < nof_remote_cores; i++) {           
                    flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

                    port_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                                   nof_remote_cores, i);
                    port_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                                   nof_remote_cores, i);
                    port_info->flow_config->sub_flow[0].update_bw_only = 0;
                    port_info->flow_config->sub_flow[1].update_bw_only = 0;
                    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));
                    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                        {
                            port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                            port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                        }
/* } */
#endif
                        port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
                        port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
                        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
                    }
                }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                {
                    port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                    port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                }
/* } */
#endif
                port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
                port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
            }

            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port))) 
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure CLOS FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            rc = _bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
            if (rc != BCM_E_NONE) {
                goto err;
            }
           break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:
            if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port))) {
                rc = BCM_E_PARAM;
                goto err;
            }
            if (SOC_IS_QAX(unit)) {
                _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &port, core);
            }
            /* validate port element */
            rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dnx_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            rc = _bcm_dnx_cosq_control_sched_cl_weight_set(unit, port, cosq, type, arg, port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_congestion_port_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{  
    soc_error_t               rv = SOC_E_NONE;
    bcm_port_t                congestion_port = 0;
    DNX_TMC_FC_HCFC_WATCHDOG  hcfc_watchdog;

    BCMDNX_INIT_FUNC_DEFS;

    congestion_port = BCM_GPORT_CONGESTION_GET(port);
    sal_memset(&hcfc_watchdog, 0x0, sizeof(DNX_TMC_FC_HCFC_WATCHDOG));

    switch(type) {
        /* Set watchdog period */
        case bcmCosqControlFlowControlErrWatchdog:
            {
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));

                hcfc_watchdog.enable = arg ? TRUE : FALSE;
                hcfc_watchdog.period = arg;

                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_set,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in setting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));
            }
            break;
        /* Set fc indication that will be sent when watch-dog error is reported */
        case bcmCosqControlFlowControlErrHandle:
            {  
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));

                hcfc_watchdog.error_status = arg ? 1 : 0;

                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_set,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in setting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));
            }
            break;
        default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_congestion_port_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg)
{  
    soc_error_t               rv = SOC_E_NONE;
    bcm_port_t                congestion_port = 0;
    DNX_TMC_FC_HCFC_WATCHDOG  hcfc_watchdog;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    congestion_port = BCM_GPORT_CONGESTION_GET(port);
    sal_memset(&hcfc_watchdog, 0x0, sizeof(DNX_TMC_FC_HCFC_WATCHDOG));

    switch(type) {
        /* Get watchdog period */
        case bcmCosqControlFlowControlErrWatchdog:
            {
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));

                (*arg) = hcfc_watchdog.period;

            }
            break;
        /* Get fc indication that will be sent when watch-dog error is reported */
        case bcmCosqControlFlowControlErrHandle:
            {  
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));

                (*arg) = hcfc_watchdog.error_status;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_control_profile_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{
    int rate_class, rv;

    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
        /* set ocb only */
        case bcmCosqControlOCBOnly:
            {
                rate_class = BCM_GPORT_PROFILE_GET(port); 
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_profile_ocb_only_set,(unit, rate_class, arg)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in setting ocb only for rate class %d, error 0x%x\n"), unit, rate_class, rv));
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_profile_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg)
{
    int rate_class, rv;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    switch(type) {
        /* get ocb only */
        case bcmCosqControlOCBOnly:
            {
                rate_class = BCM_GPORT_PROFILE_GET(port); 
                rv = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_profile_ocb_only_get,(unit, rate_class, arg)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting ocb only for rate class %d, error 0x%x\n"), unit, rate_class, rv));
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_jer2_arad_cosq_control_multicast_ingress_priority_scheduler_set(int unit, 
                                                                int cosq, 
                                                                int arg)
{

    uint32 dnx_sand_rc;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;

    if(!DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    if(arg != BCM_COSQ_HIGH_PRIORITY && arg != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter %d"), arg));
    }
    enable = (arg == BCM_COSQ_HIGH_PRIORITY)?TRUE:FALSE;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_traffic_class_multicast_priority_map_set,(unit, cosq, enable)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}

static int
_bcm_jer2_arad_cosq_control_multicast_ingress_priority_scheduler_get(int unit, 
                                                                int cosq, 
                                                                int *arg)
{
    uint32 dnx_sand_rc;
    uint8 enable = 0;
    BCMDNX_INIT_FUNC_DEFS; 
    BCMDNX_NULL_CHECK(arg);

    if(!DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_traffic_class_multicast_priority_map_get,(unit, cosq, &enable)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *arg = (enable) ? 
        BCM_COSQ_HIGH_PRIORITY : 
        BCM_COSQ_LOW_PRIORITY;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port scheduler 
 */
static int
_bcm_dnx_cosq_control_egress_port_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;

    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                if (arg < 0) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: negative parameter\n")));
                    rc = BCM_E_PARAM;
                }
                if (arg > DNX_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: more than max burst\n")));
                    rc = BCM_E_PARAM;
                }
                BCM_IF_ERROR_RETURN(rc);

                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_single_port_max_burst_set,(unit, core, tm_port, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if(!SOC_IS_ARAD_B1_AND_BELOW(unit)){
            rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_max_credit_empty_port_set,(unit, arg)));
            DNX_BCM_SAND_IF_ERR_EXIT(rc);
        } else {
           BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
static int
_bcm_dnx_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                DNX_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                
                rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit, cosq, &prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DNX_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n")));
                }

                /* Set Port-TC rate Info */
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_port_priority_max_burst_set,(unit,core,tm_port,prio,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_port_priority_max_burst_for_empty_queues_set,(unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_port_priority_max_burst_for_fc_queues_set, (unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }
 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
static int
_bcm_dnx_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                DNX_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DNX_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst %d\n"), arg));                    
                }

                /* Set Port-TC rate Info */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_tcg_max_burst_set,(unit, core, tm_port, tcg, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
static int
_bcm_dnx_cosq_control_egress_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
    case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                DNX_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DNX_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT || arg < 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst, %d\n") , arg));                    
                }

                /* Set conifguration */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_tcg_max_burst_set,(unit, core, tm_port, tcg, arg));                      
                BCMDNX_IF_ERR_EXIT(rc);
                
            break;
            }
        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
static int
_bcm_dnx_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                /* Validate gport */
                rc = _bcm_dnx_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DNX_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n"))); 
                }

                /* Set conifguration */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_port_priority_max_burst_set,(unit, core, tm_port, cosq, arg));                 
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;
        case bcmCosqControlPrioritySelect: 
            {
                soc_port_t local_port;
                if ((arg != BCM_COSQ_HIGH_PRIORITY) && (arg != BCM_COSQ_LOW_PRIORITY))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: need to specific high/low priority \n")));
                }
                local_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port);
                rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_prio_propagation_port_set, (unit, local_port, cosq, arg==BCM_COSQ_HIGH_PRIORITY ? 1:0));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port pc 
 */
static int
_bcm_dnx_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
      
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                DNX_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Set arg*/
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_port_priority_max_burst_get,(unit,core,tm_port,prio,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_port_priority_max_burst_for_empty_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_port_priority_max_burst_for_fc_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
static int
_bcm_dnx_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                /* Validate gport */
                rc = _bcm_dnx_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_port_priority_max_burst_get,(unit, core, tm_port, cosq, (uint32*) arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;
        case bcmCosqControlPrioritySelect: 
            {
                soc_port_t local_port;
                int val = 0;
                local_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port);
                rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_prio_propagation_port_get, (unit, local_port, cosq, &val));
                *arg = (val == 1)? BCM_COSQ_HIGH_PRIORITY:BCM_COSQ_LOW_PRIORITY;
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
static int
_bcm_dnx_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;
                uint32 tm_port; 
                DNX_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_sch_tcg_max_burst_get,(unit, core, tm_port, tcg, (uint32*)arg));                              
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
static int
_bcm_dnx_cosq_control_egress_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port;
                DNX_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_dnx_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_egq_tcg_max_burst_get,(unit, core, tm_port, tcg, (uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port scheduler 
 */
static int
_bcm_dnx_cosq_control_egress_port_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);
  
    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ofp_rates_single_port_max_burst_get,(unit, core, tm_port,(uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if (!SOC_IS_ARAD_B1_AND_BELOW(unit)) {
            rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ofp_rates_max_credit_empty_port_get, (unit, arg))); 
                DNX_BCM_SAND_IF_ERR_EXIT(rc);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress interface scheduler (father of port)
 */
static int
_bcm_dnx_cosq_control_egress_interface_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    soc_port_t  local_port;
    bcm_gport_t local_gport;
    soc_port_t  port_i;
    bcm_gport_t gport_i;
    uint32      tm_port;
    soc_pbmp_t  ports_bm;
    int         core, local_mode, mode_i, weight, is_channelized;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL));
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &local_port));
      
    switch(type) {
        case bcmCosqControlSingleCalendarMode:
            BCM_GPORT_LOCAL_SET(local_gport, local_port);

            /* calendar mode is supported only for channelized nif */
            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_is_channelized_port_get(unit, local_port, &is_channelized));
            if (!is_channelized) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Changing calendar mode is allowed only for channelized interfaces")));
            }

            /* changing calendar mode is allowed only when all ports that belong to the NIF are at the same priority */
            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_ports_to_same_interface_get(unit, local_port, &ports_bm));
            BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_sched_get(unit, local_gport, 0, &local_mode, &weight));

            SOC_PBMP_ITER(ports_bm, port_i) {
                    BCM_GPORT_LOCAL_SET(gport_i,port_i);
                    BCMDNX_IF_ERR_EXIT(bcm_dnx_cosq_gport_sched_get(unit, gport_i, 0, &mode_i, &weight));
                    if (local_mode != mode_i) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Changing calendar mode is allowed only when all ports on the interface are at the same priority")));
                        break;
                    }
            }
            if (arg == 1) {
                /* single calendar per NIF */
                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_is_single_cal_mode_set(unit, local_port, TRUE));
            } else {
                /* two calendars per nif (low and high priority calendars) */
                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_is_single_cal_mode_set(unit, local_port, FALSE));
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress interface scheduler (father of port)
 */
static int
_bcm_dnx_cosq_control_egress_interface_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
         default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    DNX_TMC_MULT_FABRIC_INFO info;  
    int core, gport_cores;
    
    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || BCM_COSQ_GPORT_IS_FMQ_ROOT(port)
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                if (arg > DNX_COSQ_FMQ_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid max_burst %d \n"), unit, arg));  
                }

                /* Get cores */
                gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(port);
                SOC_DNX_CORE_VALIDATE(unit, gport_cores, TRUE);

                BCM_DNX_CORES_ITER(gport_cores, core) {

                    /* Get existing configuration */
                    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                        info.guaranteed.gr_shaper.max_burst = arg;
                    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) { /* Best effort */
                        info.best_effort.be_shaper.max_burst = arg;
                    } else {
                        if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                            info.max_burst = arg;
                        } else {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                        }
                    }

                    /* Set configuration */
                    rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_set,(unit, core, &info)));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            break;

        default:
            DNXC_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("Invalid type %d"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg)
{
    bcm_error_t rc = BCM_E_NONE;   
    DNX_TMC_MULT_FABRIC_INFO info;
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(arg);    
    
    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || BCM_COSQ_GPORT_IS_FMQ_ROOT(port)
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                /* Get core */
                core = BCM_GPORT_SCHEDULER_CORE_GET(port);

                /* Get with BCM_CORE_ALL assumes symetric configuration,
                   in this case use core 0 to get information */
                if(core == BCM_CORE_ALL) {
                    core = 0;
                }

                /* Get existing configuration */
                rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_credit_source_get,(unit, core, &info)));
                BCMDNX_IF_ERR_EXIT(rc);

                if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                    *arg = info.guaranteed.gr_shaper.max_burst;
                } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
                    /* Best effort */
                    *arg = info.best_effort.be_shaper.max_burst;
                } else {
                    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                        *arg = info.max_burst;
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                    }
                }
            }
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d\n"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_ingress_port_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int arg)
{
    int rc;
    uint32 flags = 0;
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
       case bcmCosqControlIngressPortDropUntaggedPCP:
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
            }
            config.untagged_pcp = arg;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_prd_config_set,(unit, port, flags, &config)));
#endif 
            break;
        case bcmCosqControlIngressPortDropTpid1:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_set, (unit, port, flags, 0, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid2:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_set, (unit, port, flags, 1 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid3:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_set, (unit, port, flags, 2 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid4:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_set, (unit, port, flags, 3 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreIpDscp:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_ip_dscp_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreMplsExp:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_mpls_exp_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreInnerTag:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_inner_tag_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgonreOuterTag:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_outer_tag_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_ingress_port_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int *arg)
{
    bcm_error_t           rc = BCM_E_NONE;    
    uint32 flags = 0;
    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
    }
    switch(type) {
       case bcmCosqControlIngressPortDropUntaggedPCP:
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
            }
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_prd_config_get,(unit, port, flags, &config)));
            *arg = config.untagged_pcp;
#endif 
            break;
        case bcmCosqControlIngressPortDropTpid1:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_get, (unit, port, flags, 0, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid2:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_get, (unit, port, flags, 1, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid3:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_get, (unit, port, flags, 2, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid4:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_get, (unit, port, flags, 3, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreIpDscp:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_ip_dscp_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreMplsExp:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_mpls_exp_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreInnerTag:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_inner_tag_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgonreOuterTag:
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_ignore_outer_tag_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_device_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                dnx_sand_rc = 0;
    uint32                flags = 0;
    soc_error_t           rv;
    int core_id;
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_slow_max_rates_set,(unit, (type == bcmCosqControlFlowSlowRate1) ? 1:2 , arg)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in configuring device slow rates (0x%x) dnx_sand error 0x%x, error 0x%x\n"), unit, arg, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            break;
        case bcmCosqControlAdmissionTestProfileA:
            {
                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;              
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }

                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_admit_test_tmplt_get, (unit, core_id, DNX_TMC_ITM_ADMIT_TST_00, &info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

                info.test_a.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_a.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_a.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_a.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_a.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_a.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                /* For now: assume only admission test 00 is used */
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_admit_test_tmplt_set,(unit, core_id, DNX_TMC_ITM_ADMIT_TST_00,&info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
            }
            break;
        case bcmCosqControlAdmissionTestProfileB:
            {
                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;               
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }
                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_admit_test_tmplt_get,(unit, core_id, DNX_TMC_ITM_ADMIT_TST_00,&info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

                info.test_b.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_b.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_b.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_b.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_b.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_b.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                /* For now: assume only admission test 00 is used */
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_admit_test_tmplt_set,(unit, core_id, DNX_TMC_ITM_ADMIT_TST_00,&info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
            }            
            break;
        case bcmCosqControlFlowControlEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dnx_dbg_flow_control_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        case bcmCosqControlEgressBandwidthEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dnx_dbg_egress_shaping_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        
        case bcmCosqControlMulticastPriorityIngressScheduling:
              rc = _bcm_jer2_arad_cosq_control_multicast_ingress_priority_scheduler_set(unit, cosq, arg);
              BCMDNX_IF_ERR_EXIT(rc);
        break;

        case bcmCosqControlDropLimitAlpha: /* enable/disable fair adaptive tail drop */
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            }
            DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_fair_adaptive_tail_drop_enable_set, (unit, arg)));
            break;
        case bcmCosqControlPriorityPropagationEnable:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_prio_propagation_enable_set, (unit, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid1:
        case bcmCosqControlIngressPortDropTpid2:
            if (SOC_IS_JERICHO_PLUS_ONLY(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("port %d is invalid. configuration of TPID is per port."), port));
            }
            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_set, (unit, port, flags,(type == bcmCosqControlIngressPortDropTpid1 ? 0 : 1), arg)); 
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_control_device_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int *arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                flags = 0, dnx_sand_rc = 0;
    soc_error_t           rv;
    int                   core_id;
    DNX_TMC_SCH_SLOW_RATE   slow_max_rates;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:
            DNX_TMC_SCH_SLOW_RATE_clear(&slow_max_rates);

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_slow_max_rates_get,(unit, (type == bcmCosqControlFlowSlowRate1)? 1:2 , arg)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving device slow rates dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            break;
        case bcmCosqControlAdmissionTestProfileA:
        case bcmCosqControlAdmissionTestProfileB:
            {
                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }
                
                DNX_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_admit_test_tmplt_get,(unit, core_id, DNX_TMC_ITM_ADMIT_TST_00,&info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

                *arg = 0;
                if (type == bcmCosqControlAdmissionTestProfileA)
                {
                  DNX_COSQ_ADMISSION_TEST_ADD(*arg,info.test_a);
                } else {
                  DNX_COSQ_ADMISSION_TEST_ADD(*arg,info.test_b);
                }                             
            }
            break;
        case bcmCosqControlFlowControlEnable:
            {   
                uint8   enable;
                rv = soc_dnx_dbg_flow_control_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1 : 0;
            }
            break;
        case bcmCosqControlEgressBandwidthEnable:
            {
                uint8   enable;
                rv = soc_dnx_dbg_egress_shaping_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1: 0;
            }
            break;  
        
        case bcmCosqControlMulticastPriorityIngressScheduling:
          rc = _bcm_jer2_arad_cosq_control_multicast_ingress_priority_scheduler_get(unit, cosq, arg);
          BCMDNX_IF_ERR_EXIT(rc);
          break;

        case bcmCosqControlDropLimitAlpha: /* check if fair adaptive tail drop is enabled */
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            } else {
                uint8 enabled = 0;
                DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_fair_adaptive_tail_drop_enable_get, (unit, &enabled)));
                *arg = enabled;
            }
            break;
        case bcmCosqControlPriorityPropagationEnable:
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_prio_propagation_enable_get, (unit, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid1:
        case bcmCosqControlIngressPortDropTpid2:
            if (SOC_IS_JERICHO_PLUS_ONLY(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("port %d is invalid. configuration of TPID is per port."), port));
            }
            rc =  MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_tpid_get, (unit, port, flags, (type == bcmCosqControlIngressPortDropTpid1 ? 0 : 1), (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set system port cosq control
 */
static int
_bcm_dnx_cosq_control_system_port_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg)
{
    bcm_error_t rc = BCM_E_NONE;       
    int base_qid, qid;
    int core = BCM_CORE_ALL;
	uint8 valid;
	uint8 sw_only; 
    uint32 base_qid_temp;

    BCMDNX_INIT_FUNC_DEFS;
 
    SOC_DNX_CORES_ITER(BCM_CORE_ALL, core)
    {
    	/* obtaining queue from system port */
    	rc = jer2_arad_sw_db_sysport2queue_get(unit, core, BCM_GPORT_SYSTEM_PORT_ID_GET(port), &valid, &sw_only, &base_qid_temp);
    	BCMDNX_IF_ERR_EXIT(rc);
    	
    	if (valid != TRUE)
    	{
    		BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, system port %d have no valid queue"), unit, port));
    	}
        base_qid = base_qid_temp;
        qid = base_qid + cosq;

        switch(type) {
            case bcmCosqControlDefaultInvalidQueue:
            {
                if (qid >= SOC_DNX_DEFS_GET(unit, nof_queues_per_pipe)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid queue id %d"), unit, qid));
                }

                rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_default_invalid_queue_set, (unit, core, qid, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;
    		
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
        }


    }
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve system port cosq control
 */
static int
_bcm_dnx_cosq_control_system_port_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 base_qid, qid = 0;
    int core = BCM_CORE_ALL;
	uint8 valid;
	uint8 sw_only; 
    uint32 base_qid_temp;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    SOC_DNX_CORES_ITER(BCM_CORE_ALL, core)
    {

    	/* obtaining queue from system port */
    	rc =jer2_arad_sw_db_sysport2queue_get(unit, core, BCM_GPORT_SYSTEM_PORT_ID_GET(port), &valid, &sw_only, &base_qid_temp);
    	BCMDNX_IF_ERR_EXIT(rc);
    	if (valid != TRUE)
    	{
    		BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, system port %d have no valid queue"), unit, port));
    	}

        base_qid = base_qid_temp;
        qid = base_qid + cosq;
        
        switch(type) {
            case bcmCosqControlDefaultInvalidQueue:
            {
               
                rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_default_invalid_queue_get,(unit, core, &qid, arg));
                BCMDNX_IF_ERR_EXIT(rc);

            }
            break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
        }

    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set ingress queue control
 */
static int
_bcm_dnx_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                dnx_sand_rc = 0;        
    int base_qid, qid;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }

    if (!(type == bcmCosqControlDefaultInvalidQueue && arg == 0)) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, base_qid, &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"), unit, base_qid, sw_state_num_cos));
        }

        if (cosq < 0 || cosq >= sw_state_num_cos) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
        }
    }

    qid = base_qid + cosq;

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {
                DNX_TMC_ITM_CR_DISCOUNT_INFO discount_data;
                int new_discount_cls, is_allocated, old_discount_cls;
                
                DNX_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_data);
                if (DNX_TMC_ITM_COMPENSATION_LEGACY_MODE(unit)) {
                    bcm_cosq_pkt_size_adjust_info_t adjust_info; 

                    adjust_info.source_info.source_type = bcmCosqPktSizeAdjustSourceScheduler;
                    adjust_info.source_info.source_id = 0;

                    adjust_info.gport = port;
                    adjust_info.cosq = cosq;
                    adjust_info.flags = 0;
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_set(unit, &adjust_info, arg));
                } else {
                    /* in wide PDM mode with compensation tag there is a new mechanism for scheduler compensation */             
                    if (DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit))
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, scheduler compensation has a new mechanism"), unit));
                    }
                    
                    if (arg < DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL || arg > DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                    }

                    /* Get old data */
                    
                    /* Set data configuration */
                    discount_data.discount = arg;
                    
                    /* Exchange SW Data */
                    rc = _bcm_dnx_am_template_queue_discount_cls_exchange(unit, 0 , qid,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    if (is_allocated) {
                   /* Set new profile data */
                        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_cr_discount_set,(unit,new_discount_cls,&discount_data)));
                        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                   
                    }
                    
                    /* Set new mapping */
                    rc = _bcm_dnx_cosq_voq_class_mapping_set(unit,core,qid,BCM_DNX_COSQ_DISCOUNT_CLS,new_discount_cls);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                if (SOC_IS_QAX(unit)) {
                    /* Feature is not supported for JER2_QAX. */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcmCosqControlHeaderUpdateField type is not supported")));
                }
                
                if (arg < 0 || arg > DNX_TMC_MAX_SIGNATURE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument signature %d parameter"), unit, arg));    
                }

                rc = _bcm_dnx_cosq_voq_class_mapping_set(unit,core,qid,BCM_DNX_COSQ_QUEUE_SIGNATURE,arg);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        
        case bcmCosqControlDefaultInvalidQueue:
        {
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport type %d"), unit, port));
            }

            if (qid >= SOC_DNX_DEFS_GET(unit, nof_queues_per_pipe)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid queue id %d"), unit, qid));
            }

            rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_default_invalid_queue_set, (unit, core, qid, arg));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve ingress queue control
 */
static int
_bcm_dnx_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 base_qid, qid = 0;
    uint32 dnx_sand_rc;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);


    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }

    if (type != bcmCosqControlDefaultInvalidQueue) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"), unit, base_qid, sw_state_num_cos));     
        }

        if (cosq < 0 || cosq >= sw_state_num_cos) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
        } 
    }

    qid = base_qid + cosq;
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                DNX_TMC_ITM_CR_DISCOUNT_INFO discount_data;
                
                if (DNX_TMC_ITM_COMPENSATION_LEGACY_MODE(unit)) {
                    bcm_cosq_pkt_size_adjust_info_t adjust_info; 

                    adjust_info.source_info.source_type = bcmCosqPktSizeAdjustSourceScheduler;
                    adjust_info.source_info.source_id = 0;

                    adjust_info.gport = port;
                    adjust_info.cosq = cosq;
                    adjust_info.flags = 0;
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_get(unit, &adjust_info, arg));
                } else {
                    /* in wide PDM mode with compensation tag there is a new mechanism for scheduler compensation */             
                    if (DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) 
                    {
                        *arg = 0;
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, scheduler compensation has a new mechanism"), unit));
                    }

                    /* Get old data */
                    rc = _bcm_dnx_am_template_queue_discount_cls_data_get(unit,0,qid,&discount_data);
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    *arg = discount_data.discount;
                }
            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                DNX_TMC_ITM_QUEUE_INFO info;

                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit,core,qid,&info)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
/*
 * COVERITY
 *
 * The variable info is assigned inside MBCM_DNX_DRIVER_CALL.
 */
/* coverity[uninit_use : FALSE] */
                *arg = info.signature;
            }
            break;
        
        case bcmCosqControlDefaultInvalidQueue:
        {
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport type %d"), unit, port));
            }

            rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_default_invalid_queue_get,(unit, core, &qid, arg));
            BCMDNX_IF_ERR_EXIT(rc);

            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(port, core, qid);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(port, core, qid);
            }
        }
        break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
static int
_bcm_dnx_cosq_control_egress_queue_set(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32      dnx_sand_rc = 0, tm_port = 0;        
    int         core;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {                

                DNX_TMC_PORT_HEADER_TYPE header_type = 0, header_type_incoming;
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_TYPE cr_discnt_type_ndx = 0, discount_type = 0;
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data, discount_data_complement;
                int new_discount_cls, is_allocated, old_discount_cls, discount_profile_complement;
                uint32 ref_count_complement;
                
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data_complement);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                if (arg < DNX_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL || arg > DNX_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                }

                /* Get old data */
                rc = _bcm_dnx_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Set data configuration */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    discount_data.uc_credit_discount = arg;
                }
                else
                {
                    discount_data.mc_credit_discount = arg;
                }
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_egr_hdr_credit_discount_select_get,(unit, core, tm_port,&discount_type)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc); 

                discount_profile_complement = (discount_type == 0) ? 1 : 0;
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_header_type_get,(unit, core, tm_port, &header_type_incoming, &header_type)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc); 

                rc = _bcm_dnx_am_template_egress_port_discount_cls_per_header_type_ref_get(unit, core, discount_profile_complement, header_type, &ref_count_complement);
                BCMDNX_IF_ERR_EXIT(rc);

                if(ref_count_complement != 0) 
                {
                    rc = _bcm_dnx_am_template_egress_port_discount_cls_per_header_type_tdata_get(unit, core, discount_profile_complement, header_type, &discount_data_complement);
                    BCMDNX_IF_ERR_EXIT(rc);
                    if(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port) && discount_data.uc_credit_discount == discount_data_complement.uc_credit_discount) 
                    {
                        discount_data.mc_credit_discount = discount_data_complement.mc_credit_discount;
                    } 
                    else if(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port) && discount_data.mc_credit_discount == discount_data_complement.mc_credit_discount)
                    {
                        discount_data.uc_credit_discount = discount_data_complement.uc_credit_discount;
                    }
                }
                /* Exchange SW Data */
                rc = _bcm_dnx_am_template_egress_port_discount_cls_exchange(unit, core, tm_port,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                cr_discnt_type_ndx = new_discount_cls;

                if (is_allocated) {
                   dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_header_type_get,(unit,core,tm_port,&header_type_incoming,&header_type)));
                   DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

                   /* Set new profile data, data is being set from header type and discount type */                   
                   dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_egr_hdr_credit_discount_type_set,(unit,core,header_type,cr_discnt_type_ndx,&discount_data)));
                   DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                                                 
                }                

                /* Set new mapping port to discount type */
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_port_egr_hdr_credit_discount_select_set,(unit,core,tm_port,cr_discnt_type_ndx)));
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);          

            }
            break;      
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:

    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
static int
_bcm_dnx_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg)
{
    bcm_error_t rc = BCM_E_NONE;      
    int         core;
    uint32      tm_port = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    rc = _bcm_dnx_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data;                
                
                DNX_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                /* Get old data */
                rc = _bcm_dnx_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                                            
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    *arg = discount_data.uc_credit_discount;
                }
                else
                {
                    *arg = discount_data.mc_credit_discount;                    
                }                  
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_profile_mapping_get(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
    int qid, base_queue, profile_id;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
    switch(profile_mapping->profile_type) {
    case bcmCosqIngressQueueToRateClass:
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_COSQ_GPORT_IS_ISQ(gport_to_map)) {
            base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport_to_map);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_to_map);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"),
                         unit, base_queue, sw_state_num_cos));
        }
        if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
        }
        qid = base_queue + cosq;
        rv = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, &profile_id);
        BCMDNX_IF_ERR_EXIT(rv);
        BCM_GPORT_PROFILE_SET(profile_mapping->mapped_profile, profile_id);
        break;
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_profile_mapping_set(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
    int base_queue, qid, profile_id;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
    if (BCM_GPORT_IS_PROFILE(profile_mapping->mapped_profile)){
        profile_id = BCM_GPORT_PROFILE_GET(profile_mapping->mapped_profile);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of mapped profile must be BCM_GPORT_PROFILE_TYPE. gport %d is not supported."), profile_mapping->mapped_profile));
    }
    switch(profile_mapping->profile_type) {
    case bcmCosqIngressQueueToRateClass:
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_COSQ_GPORT_IS_ISQ(gport_to_map)) {
            base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport_to_map);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_to_map);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
        }

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"),
                         unit, base_queue, sw_state_num_cos));
        }
        if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
        }
        qid = base_queue + cosq;

        rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set(unit,core,qid,profile_id);
        BCMDNX_IF_ERR_EXIT(rv);
        break;
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Verify that mapping queues from a rate class with attributes as in data_rate_class_old, 
 * to a rate class with attributes as in data_rate_class_new is legal. 
 * number of queues to be mapped is nof_queues_mapped
 * 
 * Note: Actually the only constrains we have is validating for the tail drop resources  
 */
static int
_bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               int core,
                                                               uint8 is_ocb_only,
                                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 reservation_change[][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES])
{
    bcm_error_t rv = BCM_E_NONE;
    int32 old_guaranteed = 0, new_guaranteed = 0;
    soc_dnx_guaranteed_q_resource_t guaranteed_q_resource;  /* legacy -- used for Jericho and earlier */
    DNX_TMC_ITM_GUARANTEED_RESOURCE guaranteed_resources; /* used for JER2_QAX and later */
    soc_dnx_guaranteed_pair_t *guaranteed_pair;
    int core_index;
    int thresh_type, thresh_type_begin, thresh_type_end;

    BCMDNX_INIT_FUNC_DEFS;
    /* 
     *  calculte: for tail drop in bds and byts:
     *  (unused guaranteed size) + old_rate_class.min_size - new_rate_class.min_size <
     *  (used guaranteed size / 50)
     */
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != SOC_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }
    if (nof_queues_mapped < 0){
        /*Illegal nof_queues_mapped*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number of queues mapped(%d) into rate class"), unit, nof_queues_mapped));
    }

    if (!SOC_IS_QAX(unit) || !is_ocb_only) {
        /* do nothing for is_ocb_only=TRUE on JER2_QAX */

        if (SOC_IS_QAX(unit)) {
            thresh_type_begin = 0;
            thresh_type_end = DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES;
        } else {
            thresh_type_begin = 0;
            thresh_type_end = 1;
        }
        
        
        for (thresh_type = thresh_type_begin; thresh_type < thresh_type_end; thresh_type++) {
            BCM_DNX_CORES_ITER(core, core_index) {
                if (SOC_IS_QAX(unit)) {
                    rv = sw_state_access[unit].dnx.soc.jer2_qax.tm.guaranteed_info.get(unit, core_index, &guaranteed_resources);
                    BCMDNX_IF_ERR_EXIT(rv);
                    
                    guaranteed_pair = &guaranteed_resources.guaranteed[thresh_type];
                    
                    old_guaranteed = data_rate_class_old->queue_quaranteed_size[thresh_type];
                    new_guaranteed = data_rate_class_new->queue_quaranteed_size[thresh_type];
                } else {
                    /* Jericho and earlier */
                    rv = sw_state_access[unit].dnx.soc.jer2_arad.tm.guaranteed_q_resource.get(unit, core_index, &guaranteed_q_resource);
                    BCMDNX_IF_ERR_EXIT(rv);
                    guaranteed_pair = is_ocb_only ? &guaranteed_q_resource.ocb : &guaranteed_q_resource.dram;
                    
                    if (SOC_DNX_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DNX_GUARANTEED_Q_RESOURCE_MEMORY) {
                        old_guaranteed = data_rate_class_old->queue_quaranteed_size[DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                        new_guaranteed = data_rate_class_new->queue_quaranteed_size[DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                    } else if (SOC_DNX_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DNX_GUARANTEED_Q_RESOURCE_BDS){
                        old_guaranteed = data_rate_class_old->queue_min_size_bds;
                        new_guaranteed = data_rate_class_new->queue_min_size_bds;
                    } else {
                        /*Illegal guaranteed_q_mode*/
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, Invalid guaranteed queue mode 0x%x"), unit, SOC_DNX_CONFIG(unit)->tm.guaranteed_q_mode));
                    }
                }
                reservation_change[core_index][thresh_type] = (new_guaranteed - old_guaranteed) * nof_queues_mapped;
                
                if (((int32)(guaranteed_pair->total - (guaranteed_pair->used))) - reservation_change[core_index][thresh_type] < guaranteed_pair->used / 50) { 
                    /* This check can be later changed to verify against a configurable threshold */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Ran out of resource to reserve/guarantee for queue")));
                }
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: Remapp an ingres queue to a rate class directly.
 * stages: 
 * 1. Validate that remapping the queue is legal for all dependent features. (taildrop) 
 * 2. Update SW state: template maneger
 * 3. Update HW: remp queue (qid)
 */
static int
_bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core, 
                                                        int qid,
                                                        int rate_class)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class_new, data_rate_class_old;
    int old_rate_class;
    int32 reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    uint8 is_ocb_only;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&data_rate_class_new, 0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class_old, 0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
     rv = _bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
     BCMDNX_IF_ERR_EXIT(rv);

     /* 1. Validate that remapping the queue is legal for all dependent features. */
     /* 1.1 Get old and new rate class attributes. */
     rv = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, &old_rate_class);
     BCMDNX_IF_ERR_EXIT(rv);
     if (old_rate_class != rate_class) {

         rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, old_rate_class, &data_rate_class_old);
         BCMDNX_IF_ERR_EXIT(rv);

         rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class_new);
         BCMDNX_IF_ERR_EXIT(rv);
      
         rv = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_queue_is_ocb_only_get, (unit, core, qid, &is_ocb_only)); 
         BCMDNX_IF_ERR_EXIT(rv);

         /*1.2 Validate that expected tail drop configuration is legal, and get the expected tail drop reservation change */
         rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &data_rate_class_new, 1, reservation_change);
         BCMDNX_IF_ERR_EXIT(rv);
         
         /* 
          * 3. Update HW, Update SW state, map queue to new rate class 
          */
         /* update mapping:*/
         rv = _bcm_dnx_cosq_voq_class_mapping_set(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, rate_class);
         BCMDNX_IF_ERR_EXIT(rv);
         /* update tail drop reservation */
         BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core, is_ocb_only, reservation_change))); 
     }
exit:
    BCMDNX_FUNC_RETURN;

}
/* 
 * Purpose: Set mapping between voq and rate class
 */ 
static int
_bcm_dnx_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dnx_cosq_queue_profile_type_t profile_type,
                                      int profile)
{
    uint32                dnx_sand_rc = 0;    
    DNX_TMC_ITM_QUEUE_INFO info, info_original;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_ITM_QUEUE_INFO_clear(&info);    

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit, core, voq, &info))); 
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    sal_memcpy(&info_original, &info, sizeof(DNX_TMC_ITM_QUEUE_INFO));
    switch(profile_type) {
        case BCM_DNX_COSQ_RATE_CLS:
            info.rate_cls = profile;
            break;
        case BCM_DNX_COSQ_DISCOUNT_CLS:
            info.credit_cls = profile;
            break;
        case BCM_DNX_COSQ_VSQ_CC:
            info.vsq_connection_cls = profile;
            break;
        case BCM_DNX_COSQ_VSQ_TC:
            info.vsq_traffic_cls = profile;
            break;
      case BCM_DNX_COSQ_QUEUE_SIGNATURE:
            info.signature = profile;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_set,(unit, core, voq, &info_original, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Get mapping between voq and rate class
 */ 
static int
_bcm_dnx_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dnx_cosq_queue_profile_type_t profile_type,
                                      int* profile)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                dnx_sand_rc = 0;    
    DNX_TMC_ITM_QUEUE_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_ITM_QUEUE_INFO_clear(&info);    

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit,core,voq,&info)));
    DNX_SAND_IF_ERR_EXIT(dnx_sand_rc);

    switch(profile_type) {
        case BCM_DNX_COSQ_RATE_CLS:
            *profile = info.rate_cls;
            break;
        case BCM_DNX_COSQ_DISCOUNT_CLS:
            *profile = info.credit_cls;
            break;
        case BCM_DNX_COSQ_VSQ_CC:
            *profile = info.vsq_connection_cls;
            break;
        case BCM_DNX_COSQ_VSQ_TC:
            *profile = info.vsq_traffic_cls;
            break;
      case BCM_DNX_COSQ_QUEUE_SIGNATURE:
            *profile = info.signature;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_dnx_cosq_dram_bounds_default_set(int unit, DNX_TMC_ITM_DRAM_BOUND_INFO* dram_bound_info)
{
    uint32 dram_bound_buffer_factor =  3;
    uint32 dram_recovery_failure_dividor = 2; /* divide by 2 --  0.5 */
    uint32 min_free_buffer = 1000;
    uint32 min_free_pd =  1000;
    uint32 dram_recovery_multiplier =  4;
    uint32 min_packet_size =  64; /* in bytes */
    uint32 q_on_threshold = 38 * 1024; /* in bytes -- for 100G port */
    uint32 bundle_size = 4 *1024; /* in bytes */

    DNX_TMC_ITM_DRAM_BOUND_THRESHOLD* dram_threshold;

    BCMDNX_INIT_FUNC_DEFS;

    /*      DRAM bound FADT Buffers */
    dram_threshold = DNX_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info, DNX_TMC_INGRESS_DRAM_BOUND, DNX_TMC_INGRESS_THRESHOLD_SRAM_BYTES);

    dram_threshold->free_max_threshold = 4 * 1024 * 16; /* 16K * 0.25 */
    dram_threshold->free_min_threshold = min_free_buffer * 16; 
    dram_threshold->max_threshold = dram_bound_buffer_factor * q_on_threshold; 
    dram_threshold->min_threshold = bundle_size;
    dram_threshold->alpha = 1; /* Alpha DP  -- Approximate a line to Max threshold -- Log(Max_Threshold/Max_Free) */
    
    /* DRAM bound FADT PD */
    dram_threshold = DNX_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info, DNX_TMC_INGRESS_DRAM_BOUND, DNX_TMC_INGRESS_THRESHOLD_SRAM_PDS);

    dram_threshold->free_max_threshold = 8 * 1024; /* 32K x 0.25 */
    dram_threshold->free_min_threshold =  min_free_pd;
    dram_threshold->max_threshold = dram_bound_buffer_factor * q_on_threshold / min_packet_size;
    dram_threshold->min_threshold = bundle_size / min_packet_size; 
    /* Alpha DP --  Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
    dram_threshold->alpha = -2;


    /*      Recovery Failure  FADT  Buffers */
    dram_threshold = DNX_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info,
                                                            DNX_TMC_INGRESS_DRAM_BOUND_RECOVERY_FAILURE, DNX_TMC_INGRESS_THRESHOLD_SRAM_BYTES);

    dram_threshold->free_max_threshold = 4 * 1024 * 16; /* 16K * 0.25 */
    dram_threshold->free_min_threshold = DNX_SAND_MIN( min_free_buffer * 4 * 16, dram_threshold->free_max_threshold);
    dram_threshold->max_threshold = dram_bound_buffer_factor  * q_on_threshold / dram_recovery_failure_dividor;
    dram_threshold->min_threshold = bundle_size;
    /* Alpha DP 0= Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
    dram_threshold->alpha = 0;

    /*     Recovery Failure  FADT PDs */
    dram_threshold = DNX_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info,
                                                            DNX_TMC_INGRESS_DRAM_BOUND_RECOVERY_FAILURE, DNX_TMC_INGRESS_THRESHOLD_SRAM_PDS);

    dram_threshold->free_max_threshold = 8 * 1024; /* 32K x 0.25 */
    dram_threshold->free_min_threshold = 
            DNX_SAND_MIN(min_free_pd * 4, dram_threshold->free_max_threshold); /* Min( Min-Free-Buffer x  4 , Max-Free) */
    
    dram_threshold->max_threshold = dram_bound_buffer_factor * q_on_threshold / dram_recovery_failure_dividor / min_packet_size;
   dram_threshold->min_threshold = bundle_size / min_packet_size;
   /* Alpha DP 0= Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
   dram_threshold->alpha = -3;
   
   
   dram_bound_info->qsize_recovery_th = DNX_SAND_MIN( bundle_size* dram_recovery_multiplier, 
                                                      dram_bound_info->sram_words_dram_threshold[DNX_TMC_INGRESS_DRAM_BOUND].free_max_threshold / dram_recovery_failure_dividor);

    BCMDNX_FUNC_RETURN;
}
                                      

/* 
 * Purpose: Configure default values in HW rate class information 
 */
int
_bcm_dnx_cosq_voq_rate_class_default_set(int unit,
                                           int rate_class,
                                           bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t *exact_rate_class_info = NULL;
    int tc, ocb_voq_threshold_id;
    int index;
    bcm_dnx_cosq_ingress_threshold_type_e thresh_type;
    
    DNX_TMC_MGMT_OCB_VOQ_INFO ocb_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(rate_class_info);

    /* 
     * exact_rate_class_info is not being used, but it takes a lot of space in the stack.
     * So we allocate it on the heap and free it at the end of the function
     */
    BCMDNX_ALLOC(exact_rate_class_info, (sizeof(bcm_dnx_cosq_ingress_rate_class_info_t)), "exact rate class info");
    if (exact_rate_class_info == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }

    sal_memset(rate_class_info,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    DNX_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);

    
    DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
    BCMDNX_IF_ERR_EXIT(jer2_arad_mgmt_ocb_voq_info_defaults_set(unit, &ocb_info));
#endif 


    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        /* max queue size */
        rate_class_info->queue_max_size_bds[index] = DNX_COSQ_JER2_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL;
        rate_class_info->queue_alpha_bds[index] = JER2_ARAD_PLUS_MAX_ALPHA;
        
        for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
            
            DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
            /* we might need to set different default values for words/sram words/ sram pds */
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = 
                (thresh_type == DNX_COSQ_INGRESS_THRESHOLD_SRAM_PDS) ? DNX_COSQ_PB_ING_QUEUE_MAX_SRAM_PDS_DEFAULT_VAL : 
                    SOC_DNX_DEFS_GET(unit, dnx_cosq_pb_ing_queue_max_size_default_val); 
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = rate_class_info->queue_fadt_tail_drop[index][thresh_type].max;
#endif 
            /* 
               for devices prior to jer2_qax, alpha should be explicitely turn on.
               for JER2_QAX, alpha is always effective.
               for JER2_QAX, set alpha to 0m to achieve regulat tail drop behaviour
            */
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = SOC_IS_QAX(unit) ? 0 : JER2_ARAD_PLUS_MAX_ALPHA; 
        
        }

        /* WRED */
        rate_class_info->wred_enable[index] = 0;  
    }
    
    
    DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
    /* ECN configuration */
    rate_class_info->ecn_wred_enable = 0;              
    rate_class_info->ecn_queue_max_size = SOC_IS_ARADPLUS(unit) ? 
            SOC_DNX_DEFS_GET(unit, dnx_cosq_pb_ing_queue_max_size_default_val) / 2 : JER2_ARAD_MAX_QUEUE_SIZE_BYTES;
    rate_class_info->ecn_queue_max_size_bds = DNX_COSQ_JER2_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL / 2;
#endif 


    /* Guaranteed queue size */
    for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
            rate_class_info->queue_quaranteed_size[thresh_type] = 0;
    }
    rate_class_info->queue_min_size_bds = 0;

    rate_class_info->wred_exp_wq = DNX_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL;

    /* ocb information */
    for(tc = 0; tc < DNX_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DNX_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){                  
            rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
            }
        }
    }
   
    /* system RED rate class */
    DNX_TMC_ITM_SYS_RED_QT_INFO_clear(&rate_class_info->sys_red_qt);
    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        DNX_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&rate_class_info->sys_red_qt_dp[index]);
    }

    
    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on JER2_QAX only */
        _bcm_dnx_cosq_dram_bounds_default_set(unit,&rate_class_info->dram_bound_info);

    }

    
    rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, rate_class, rate_class_info, exact_rate_class_info);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    if (exact_rate_class_info != NULL) {
        BCM_FREE(exact_rate_class_info);
    }
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Get in HW rate class information 
 */
static int
_bcm_dnx_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info)
{
    uint32                dnx_sand_rc = 0;    
    int index;
    int tc, ocb_voq_threshold_id;
    DNX_TMC_MGMT_OCB_VOQ_INFO ocb_info;
    DNX_TMC_ITM_TAIL_DROP_INFO tail_drop_info;
    DNX_TMC_ITM_FADT_DROP_INFO fadt_drop_info;
    DNX_TMC_ITM_WRED_QT_DP_INFO wred_info;
    DNX_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    DNX_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    DNX_TMC_ITM_GUARANTEED_INFO guaranteed_info;
    bcm_dnx_cosq_ingress_threshold_type_e thresh_type;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(rate_class_info);
    
    DNX_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);


    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        {
            /* FADT / tail drop */
            
            DNX_TMC_ITM_FADT_DROP_INFO_clear(&fadt_drop_info);

            DNXC_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_itm_fadt_tail_drop_get,(unit,rate_class,index,&fadt_drop_info)));

            /* set the values */
            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = fadt_drop_info.max_threshold[thresh_type];
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = fadt_drop_info.min_threshold[thresh_type];
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = fadt_drop_info.adjust_factor[thresh_type];

            }
            /* not in use for JER2_QAX and later */
            rate_class_info->queue_max_size_bds[index] = fadt_drop_info.max_inst_q_size_bds;
            rate_class_info->queue_alpha_bds[index] = fadt_drop_info.adjust_factor_bds;
            

        }
        /* WRED */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_get,(unit,rate_class,index,&wred_info)));

        rate_class_info->wred_min_avrg_th[index] = wred_info.min_avrg_th;
        rate_class_info->wred_max_avrg_th[index] = wred_info.max_avrg_th;
        rate_class_info->wred_max_probability[index] = wred_info.max_probability;
        rate_class_info->wred_enable[index] = wred_info.wred_en;              

    }

    if (!SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_get,(unit, rate_class, BCM_DNX_ECN_DP, &wred_info)));
        rate_class_info->ecn_wred_min_avrg_th = wred_info.min_avrg_th;
        rate_class_info->ecn_wred_max_avrg_th = wred_info.max_avrg_th;
        rate_class_info->ecn_wred_max_probability = wred_info.max_probability;
        rate_class_info->ecn_wred_enable = wred_info.wred_en;              

        DNX_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_tail_drop_get,(unit, rate_class, BCM_DNX_ECN_DP, &tail_drop_info)));
        /* The mbcm call initializes the variable tail_drop_info */
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size = tail_drop_info.max_inst_q_size;
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size_bds = tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    sal_memset(&guaranteed_info, 0x0, sizeof(guaranteed_info));
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_committed_q_size_get,(unit, rate_class, &guaranteed_info)));
    rate_class_info->queue_min_size_bds = guaranteed_info.guaranteed_size_bds;
    for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        rate_class_info->queue_quaranteed_size[thresh_type] = guaranteed_info.guaranteed_size[thresh_type];
    }

    /* wred exp */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_exp_wq_get,(unit,rate_class,&(rate_class_info->wred_exp_wq))));
    /* ocb information */
    for(tc = 0; tc < DNX_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DNX_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
            dnx_sand_rc = jer2_arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                        
            rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
            rate_class_info->ocb_info[tc][index].dram_admission_exempt = ocb_info.dram_admission_exempt;
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
            }
        }
    }

    /* System RED */
    DNX_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_queue_size_boundaries_get,(unit, rate_class, &sys_red_qt_info)));
    for (index = 0; index < DNX_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
         rate_class_info->sys_red_qt.queue_size_boundaries[index] = sys_red_qt_info.queue_size_boundaries[index];
    }

    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        DNX_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_q_based_get,(unit, rate_class, index, &sys_red_qt_dp_info)));
        rate_class_info->sys_red_qt_dp[index].adm_th = sys_red_qt_dp_info.adm_th;
        rate_class_info->sys_red_qt_dp[index].drp_prob_high = sys_red_qt_dp_info.drp_prob_high;
        rate_class_info->sys_red_qt_dp[index].drp_prob_low  = sys_red_qt_dp_info.drp_prob_low;
        rate_class_info->sys_red_qt_dp[index].drp_th = sys_red_qt_dp_info.drp_th;
        rate_class_info->sys_red_qt_dp[index].enable = sys_red_qt_dp_info.enable;
        rate_class_info->sys_red_qt_dp[index].prob_th = sys_red_qt_dp_info.prob_th;
    }

    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on JER2_QAX only */
        /* call the driver */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_itm_dram_bound_get,(unit,rate_class,&rate_class_info->dram_bound_info))); 
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
static int
_bcm_dnx_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dnx_cosq_ingress_rate_class_info_t *exact_rate_class_info)
{
    uint32                dnx_sand_rc = 0;    
    int index;
    int tc, ocb_voq_threshold_id;
    DNX_TMC_MGMT_OCB_VOQ_INFO ocb_info, ocb_exact_info;
    DNX_TMC_ITM_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    DNX_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    soc_dnx_config_t *dnx = SOC_DNX_CONFIG(unit);
    DNX_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    DNX_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    DNX_TMC_ITM_GUARANTEED_INFO guaranteed_info, exact_guaranteed_info;

    DNX_TMC_ITM_FADT_DROP_INFO fadt_info, exact_fadt_info;
    bcm_dnx_cosq_ingress_threshold_type_e thresh_type;

    uint8 wred_gen_enable = FALSE;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(rate_class_info);    
    
    DNX_TMC_ITM_TAIL_DROP_INFO_clear(&exact_tail_drop_info);
    DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);

    DNX_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);

    dnx = SOC_DNX_CONFIG(unit);

    sal_memcpy(exact_rate_class_info, rate_class_info, sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        /* tail drop + FADT */
        {
            
            DNX_TMC_ITM_FADT_DROP_INFO_clear(&fadt_info);
            DNX_TMC_ITM_FADT_DROP_INFO_clear(&exact_fadt_info);

            /* set the values */
            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                fadt_info.max_threshold[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].max;
                fadt_info.min_threshold[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].min;
                fadt_info.adjust_factor[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha;

            }
            fadt_info.max_inst_q_size_bds = rate_class_info->queue_max_size_bds[index];
            fadt_info.adjust_factor_bds = rate_class_info->queue_alpha_bds[index];

            /* call the driver */
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_itm_fadt_tail_drop_set,(unit,rate_class,index,&fadt_info, &exact_fadt_info)));
            /* copy actual settings */
            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = exact_fadt_info.max_threshold[thresh_type];
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = exact_fadt_info.min_threshold[thresh_type];
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = exact_fadt_info.adjust_factor[thresh_type];

            }
            exact_rate_class_info->queue_max_size_bds[index] = exact_fadt_info.max_inst_q_size_bds;
            exact_rate_class_info->queue_alpha_bds[index] = exact_fadt_info.adjust_factor_bds;

        }


        /* WRED */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_get,(unit,rate_class,index,&wred_info)));

        wred_info.max_avrg_th = rate_class_info->wred_max_avrg_th[index];
        wred_info.min_avrg_th = rate_class_info->wred_min_avrg_th[index];
        wred_info.max_probability = rate_class_info->wred_max_probability[index];
        wred_info.wred_en = rate_class_info->wred_enable[index];
        wred_info.ignore_packet_size = (dnx->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dnx->tm.wred_packet_size;
        
        BCMDNX_IF_ERR_EXIT (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_set,(unit,rate_class,index,&wred_info,&exact_wred_info)));

        /* Set exact rate class information according to exact wred information */
        exact_rate_class_info->wred_min_avrg_th[index] = exact_wred_info.min_avrg_th;
        exact_rate_class_info->wred_max_avrg_th[index] = exact_wred_info.max_avrg_th;
        exact_rate_class_info->wred_max_probability[index] = exact_wred_info.max_probability;
        exact_rate_class_info->wred_enable[index] = exact_wred_info.wred_en;
        wred_gen_enable = exact_wred_info.wred_en ? TRUE : wred_gen_enable;
    }

    if (!SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        DNX_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        wred_info.max_avrg_th = rate_class_info->ecn_wred_max_avrg_th;
        wred_info.min_avrg_th = rate_class_info->ecn_wred_min_avrg_th;
        wred_info.max_probability = rate_class_info->ecn_wred_max_probability;
        wred_info.wred_en = rate_class_info->ecn_wred_enable;
        wred_info.ignore_packet_size = (dnx->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dnx->tm.wred_packet_size;
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_set,(unit, rate_class, BCM_DNX_ECN_DP, &wred_info, &exact_wred_info)));
        exact_rate_class_info->ecn_wred_min_avrg_th = exact_wred_info.min_avrg_th;
        exact_rate_class_info->ecn_wred_max_avrg_th = exact_wred_info.max_avrg_th;
        exact_rate_class_info->ecn_wred_max_probability = exact_wred_info.max_probability;
        exact_rate_class_info->ecn_wred_enable = exact_wred_info.wred_en;              

        DNX_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        tail_drop_info.max_inst_q_size = rate_class_info->ecn_queue_max_size;
        tail_drop_info.max_inst_q_size_bds = rate_class_info->ecn_queue_max_size_bds;
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_tail_drop_set,(unit, rate_class, BCM_DNX_ECN_DP, &tail_drop_info, &exact_tail_drop_info)));
        exact_rate_class_info->ecn_queue_max_size = exact_tail_drop_info.max_inst_q_size;
        exact_rate_class_info->ecn_queue_max_size_bds = exact_tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    guaranteed_info.guaranteed_size_bds = rate_class_info->queue_min_size_bds;

    for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        guaranteed_info.guaranteed_size[thresh_type] = rate_class_info->queue_quaranteed_size[thresh_type];
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_committed_q_size_set,(unit, rate_class, &guaranteed_info, &exact_guaranteed_info)));

    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    exact_rate_class_info->queue_min_size_bds = exact_guaranteed_info.guaranteed_size_bds;
    for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        exact_rate_class_info->queue_quaranteed_size[thresh_type] = exact_guaranteed_info.guaranteed_size[thresh_type];
    }

    /* wred exp */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_wred_exp_wq_set,(unit,rate_class,rate_class_info->wred_exp_wq, wred_gen_enable)));
    exact_rate_class_info->wred_exp_wq = rate_class_info->wred_exp_wq;

    /* ocb information */
    for(tc = 0; tc < DNX_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DNX_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
            dnx_sand_rc = jer2_arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                        
            ocb_info.voq_eligible = rate_class_info->ocb_info[tc][index].voq_eligible;
            ocb_info.dram_admission_exempt = rate_class_info->ocb_info[tc][index].dram_admission_exempt;

            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                ocb_info.th_buffers[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id];
                ocb_info.th_words[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id];
            }
            dnx_sand_rc = jer2_arad_mgmt_ocb_voq_eligible_set(unit, index, rate_class, tc, &ocb_info, &ocb_exact_info);
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                        
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                exact_rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_exact_info.th_buffers[ocb_voq_threshold_id];
                exact_rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_exact_info.th_words[ocb_voq_threshold_id];
            }
            exact_rate_class_info->ocb_info[tc][index].voq_eligible = rate_class_info->ocb_info[tc][index].voq_eligible;
            exact_rate_class_info->ocb_info[tc][index].dram_admission_exempt = rate_class_info->ocb_info[tc][index].dram_admission_exempt;
        }
    }

    /* System RED */
    DNX_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    for (index = 0; index < DNX_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
        sys_red_qt_info.queue_size_boundaries[index] = rate_class_info->sys_red_qt.queue_size_boundaries[index];
    }
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_queue_size_boundaries_set,(unit, rate_class, &sys_red_qt_info, &exact_rate_class_info->sys_red_qt)));

    DNX_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
    for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
        sys_red_qt_dp_info.adm_th        = rate_class_info->sys_red_qt_dp[index].adm_th;
        sys_red_qt_dp_info.drp_prob_high = rate_class_info->sys_red_qt_dp[index].drp_prob_high;
        sys_red_qt_dp_info.drp_prob_low  = rate_class_info->sys_red_qt_dp[index].drp_prob_low;
        sys_red_qt_dp_info.drp_th        = rate_class_info->sys_red_qt_dp[index].drp_th;
        sys_red_qt_dp_info.enable        = rate_class_info->sys_red_qt_dp[index].enable;
        sys_red_qt_dp_info.prob_th       = rate_class_info->sys_red_qt_dp[index].prob_th;
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_q_based_set,(unit, rate_class, index, &sys_red_qt_dp_info)));
    }

    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on JER2_QAX only */
        /* call the driver */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_itm_dram_bound_set,(unit,rate_class,&rate_class_info->dram_bound_info, 
                                                                                      &exact_rate_class_info->dram_bound_info)));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
static int
_bcm_dnx_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dnx_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info)
{
    bcm_error_t rv = BCM_E_NONE;
    DNX_TMC_ITM_SYS_RED_DROP_PROB prob_info;

    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_ITM_SYS_RED_DROP_PROB_clear(&prob_info);

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_drop_prob_get,(unit, &prob_info)));
    prob_info.drop_probs[dp_pr] = rate_sys_red_dp_pr_info->sys_red_dp_pr_val;
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_sys_red_drop_prob_set,(unit, &prob_info)));

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

static bcm_dnx_cosq_ingress_threshold_type_e _bcm_dnx_cosq_gport_flags_to_ingress_threshold_type(uint32 flags)
{
    bcm_dnx_cosq_ingress_threshold_type_e threshold_type = DNX_COSQ_INGRESS_THRESHOLD_INVALID;

    if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
        if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
            threshold_type = DNX_COSQ_INGRESS_THRESHOLD_SRAM_BYTES;
        } else {
            threshold_type = DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES;
        }
    } else if ((flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) && (flags & BCM_COSQ_GPORT_SIZE_SRAM)) {
        threshold_type = DNX_COSQ_INGRESS_THRESHOLD_SRAM_PDS;
    }

    return threshold_type;
}
/* 
 * Purpose: retrieve queue maximal & guaranteed from gport size structure to a rate class data structure 
 */
static int
_bcm_dnx_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha)
{
    int index = 0;
    bcm_dnx_cosq_ingress_threshold_type_e threshold_type;
    int color_start, color_end;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);


    threshold_type = _bcm_dnx_cosq_gport_flags_to_ingress_threshold_type(flags);

    /* Change related information */        
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        data_rate_class->sys_red_qt.queue_size_boundaries[color] = gport_size->size_max;
    } else {
        if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
            /* Set all dp information */
            color_start = 0;
            color_end = DNX_DEVICE_COSQ_ING_NOF_DP -1;
        }
        else {
            /* Set specific dp */
            color_start = color;
            color_end = color;
        }
        for (index = color_start; index <= color_end; index++) {
            if (threshold_type == DNX_COSQ_INGRESS_THRESHOLD_INVALID) {
                if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                    /* not is use for JER2_QAX and later */
                    data_rate_class->queue_max_size_bds[index] = gport_size->size_max;
                    if (set_alpha) {
                        data_rate_class->queue_alpha_bds[index] = gport_size->size_alpha_max;
                    }
                }
                else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));

                }
            } else {
            
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].max =  gport_size->size_max;
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].min =  gport_size->size_fadt_min;
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].alpha =  gport_size->size_alpha_max;
            }
            
        }        
    }
    /* The concept of guaranteed is not supported by hardware for ingress replicated copies. We do not check that such queues are not guaranteed here */
    if (threshold_type == DNX_COSQ_INGRESS_THRESHOLD_INVALID) {
        if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            /* not is use for JER2_QAX and later */
            data_rate_class->queue_min_size_bds = gport_size->size_min;
        } 
    } else {
        data_rate_class->queue_quaranteed_size[threshold_type] = gport_size->size_min;
    }

exit:
    BCMDNX_FUNC_RETURN;
 
}

/* 
 * Purpose: retrieve queue maximal & guaranteed from rate class data structure to a gport size structure 
 */
static int
_bcm_dnx_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32 relevant_flags;

    uint32 jer2_qax_flags_mask = BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED;
    uint32 jer2_arad_flags_mask = BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED;

    bcm_dnx_cosq_ingress_threshold_type_e threshold_type;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);

    /* Validate params */
    relevant_flags = flags & (SOC_IS_QAX(unit) ? jer2_qax_flags_mask : jer2_arad_flags_mask);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && (!(flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED)) && ((color < 0) || (color >= DNX_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    threshold_type = _bcm_dnx_cosq_gport_flags_to_ingress_threshold_type(flags);

    if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
        gport_size->size_min = data_rate_class->queue_min_size_bds;

        gport_size->size_max = data_rate_class->queue_max_size_bds[color];
        gport_size->size_fadt_min = 0; /* not supported */
        gport_size->size_alpha_max = SOC_IS_ARADPLUS(unit) ? data_rate_class->queue_alpha_bds[color] : JER2_ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        gport_size->size_max = data_rate_class->sys_red_qt.queue_size_boundaries[color];
        gport_size->size_min = 0;
        gport_size->size_alpha_max = JER2_ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else {
        if (threshold_type != DNX_COSQ_INGRESS_THRESHOLD_INVALID) {
            /* guaranteed */
            gport_size->size_min = data_rate_class->queue_quaranteed_size[threshold_type];

            /* tail drop / FADT */
            gport_size->size_max = data_rate_class->queue_fadt_tail_drop[color][threshold_type].max;
            gport_size->size_fadt_min = data_rate_class->queue_fadt_tail_drop[color][threshold_type].min;
            gport_size->size_alpha_max = data_rate_class->queue_fadt_tail_drop[color][threshold_type].alpha;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));       
        }
    }        

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Verify param given to a gport color size API, 
 * maximal & guaranteed size
 */
static int
_bcm_dnx_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int*        set_alpha) 
{
    uint32 relevant_flags;
    uint32 jer2_qax_flags_mask = BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED;
    uint32 jer2_arad_flags_mask = BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED;

    BCMDNX_INIT_FUNC_DEFS;

    relevant_flags = flags & (SOC_IS_QAX(unit) ? jer2_qax_flags_mask : jer2_arad_flags_mask);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && 
        (!(flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED)) && 
        ((color < 0) || (color >= DNX_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 
    /* check that size_min is only used with the resource configured to be guaranteed for the device */
    if (gport_size->size_min) {
        if ((flags & BCM_COSQ_GPORT_SIZE_BYTES) && !SOC_IS_QAX(unit) && SOC_DNX_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DNX_GUARANTEED_Q_RESOURCE_MEMORY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by memory/bytes"), unit));
        }
        if ((flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && SOC_DNX_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DNX_GUARANTEED_Q_RESOURCE_BDS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by BDs"), unit));
        }
    }
    if (SOC_IS_ARADPLUS(unit) && (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC)) {
        if (gport_size->size_alpha_max < JER2_ARAD_PLUS_MIN_ALPHA || gport_size->size_alpha_max > JER2_ARAD_PLUS_MAX_ALPHA) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Illegal size_alpha_max value %d, must be in range %d..%d"),
              gport_size->size_alpha_max, JER2_ARAD_PLUS_MIN_ALPHA, JER2_ARAD_PLUS_MAX_ALPHA));
        }
        *set_alpha = 1;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Set queue maximal & guaranteed size of a rate class
 * if we called the function in advance mode queue to rate class mapping mode then 
 *    1. if the advance mode is not set then set it
 *    2. configure the rate class directly
 */
static int
_bcm_dnx_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t 
        data_rate_class, 
        data_rate_class_old, 
        exact_data_rate_class;
    uint32 
        ref_count[2]; /* for ocb_only and dram_mix */
    int set_alpha = 0;
    int32 reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int rate_class;
    int core_index, core_id = BCM_CORE_ALL; /*Rate classes are configured symmetrically between cores.*/
    int ocb_only;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class_old,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

     /*validate that we use the right mapping mode*/
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    /* 
     * Check that the system is in advance queue to rate class mapping mode, 
     *    if not set it to advance mode.
     */
    rv = _bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_dnx_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, &set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 1. Get rate class data */
    rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);        
    
    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /* Change related information */        
    rv = _bcm_dnx_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class,set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    for (ocb_only = FALSE; ocb_only <= (SOC_IS_QAX(unit) ? FALSE : TRUE); ocb_only++) {
        /* ocb only (TRUE) is not relavant for JER2_QAX and above */
        rv = jer2_arad_sw_db_rate_class_ref_count_get(unit, core_id, ocb_only, rate_class, &ref_count[ocb_only]); 
        BCMDNX_IF_ERR_EXIT(rv);

        /* check that the remaining resource level is not too low - currently 2% */
        /* reservation_change is calculated by this function */
        rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core_id, ocb_only, &data_rate_class_old, &data_rate_class, ref_count[ocb_only], reservation_change);
        BCMDNX_IF_ERR_EXIT(rv);
    }

    /*2. configure HW*/
    rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, rate_class, &data_rate_class, &exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    for (ocb_only = FALSE; ocb_only <= (SOC_IS_QAX(unit) ? FALSE : TRUE); ocb_only++) {
        /* ocb only (TRUE) is not relavant for JER2_QAX and above */

        /*recalculate the reservation_change*/
        rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core_id, ocb_only, &data_rate_class_old, &exact_data_rate_class, ref_count[ocb_only], reservation_change);
        BCMDNX_IF_ERR_EXIT(rv);

        /*Update HW: total reservation*/
        rv = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core_id, ocb_only, reservation_change)); /* update reservation */
        BCMDNX_IF_ERR_EXIT(rv);

        /* In STRICT mode need to change also total VSQ reserved resource */
        if (SOC_IS_JERICHO(unit) && SOC_DNX_CONFIG(unit)->jer2_jer->tm.cgm_mgmt_guarantee_mode == DNX_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
            BCM_DNX_CORES_ITER(core_id, core_index) {
                
                rv = _bcm_dnx_cosq_vsq_total_reserve_update(unit, core_index, ocb_only, reservation_change[core_index][0]);
                BCMDNX_IF_ERR_EXIT(rv);
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;

}

/*
 * Purpose: Set queue maximal & guaranteed size
 */
int
_bcm_dnx_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class_old, data_rate_class, exact_data_rate_class,cleared_data_rate;
    int base_qid, qid;
    int new_rate_class, new_rate_class2, old_rate_class, is_allocated, is_allocated2, is_last;
    int set_alpha = 0;
    int32 reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int core = BCM_CORE_ALL, core_index;
    uint8 is_ocb_only;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class_old,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    BCMDNX_NULL_CHECK(gport_size);

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));
    
    if (sw_state_num_cos <= 0) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"),
                     unit, base_qid, sw_state_num_cos));
    }
    if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }
    rv = _bcm_dnx_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, &set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    qid = base_qid + cosq;
    /*
     * Settings Tail drop & guaranteed parameters done in these stages:
     * 1. Get the current rate class template, and update its values with the function arguments.
     * 2. Check if a template with the new values exists or can be allocated.
     * 3. If a new template is needed, write it and see if the new values are legal, and get the exact template values.
     * 4. Write to software the template with the exact values, if it is a new one, also write it to hardware.
     * 5. If in stage 4, the template number changed, update the hardware.
     * 6. Write the final rate class template number for the queue.
     */
    /*Get the current rate class template, and update its values with the function arguments*/
    /*1.1 Get old rate class data */
    rv = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);

    /*1.2 copy data to use as the new */
    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /*1.3 Change related information */
    rv = _bcm_dnx_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class,set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_queue_is_ocb_only_get, (unit, core, base_qid, &is_ocb_only)); 
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &data_rate_class, 1, reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 2. Test if an update information in SW will succeed. If so, a later update with the exact information should also succeed. */
    rv = _bcm_dnx_am_template_queue_rate_cls_exchange_test(unit, core, qid, &data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rv);
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "exchange test:  is_last=%d new_rate_class=%d is_allocated=%d"), is_last, new_rate_class, is_allocated));

    /* 3. If this is a new template, write it to hardware, getting back the exact values written to hardware */
    if (is_allocated) {
        rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,new_rate_class,&data_rate_class,&exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
    } else {
        sal_memcpy(&exact_data_rate_class, &data_rate_class, sizeof(exact_data_rate_class));
    }
    /*recalculate the reservation_change*/
    /*base_qid*/
    rv = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &exact_data_rate_class, 1, reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);
    /*Update HW: total reservation*/
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core, is_ocb_only, reservation_change)));

    /* In STRICT mode need to change also total VSQ reserved resource */
    if (SOC_IS_JERICHO(unit) && SOC_DNX_CONFIG(unit)->jer2_jer->tm.cgm_mgmt_guarantee_mode == DNX_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
        BCM_DNX_CORES_ITER(core, core_index) {
            
            rv = _bcm_dnx_cosq_vsq_total_reserve_update(unit, core_index, is_ocb_only, reservation_change[core_index][0]);
            BCMDNX_IF_ERR_EXIT(rv);
        }
    }

    /* 4. Write to software the exact template */
    rv = _bcm_dnx_am_template_queue_rate_cls_exchange(unit, core, qid, &exact_data_rate_class, &old_rate_class, &is_last, &new_rate_class2, &is_allocated2);
    BCMDNX_IF_ERR_EXIT(rv); /* Should never fail */
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "exchange:       is_last=%d new_rate_class=%d is_allocated=%d"), is_last, new_rate_class2, is_allocated));

    if (new_rate_class2 != new_rate_class) { /* 5. If we now have a different template than previously found */
        if (is_allocated2) { /* If this is a new template, write it to hardware */
            rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, new_rate_class2, &exact_data_rate_class, &cleared_data_rate);
            BCMDNX_IF_ERR_EXIT(rv);
        }
        if (is_allocated) { /* Clear the template written to before */
            sal_memset(&data_rate_class, 0x0, sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
            rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, new_rate_class, &data_rate_class, &cleared_data_rate);
            BCMDNX_IF_ERR_EXIT(rv);
        }
    }
    /* 6. Map the queue to the new template in hardware */
    rv = _bcm_dnx_cosq_voq_class_mapping_set(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, new_rate_class2);
    BCMDNX_IF_ERR_EXIT(rv);

    /* last profile data */
    if (is_last && new_rate_class2 != old_rate_class) {
        /* clear profile data */
        sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
        rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,old_rate_class,&data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: retrieve queue maximal & guaranteed size of a rate class
 */
static int
_bcm_dnx_cosq_gport_rate_class_color_size_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size) 
{
    bcm_error_t rv = BCM_E_NONE;
    int rate_class;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

    /*validate profiles range*/
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    
    rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_dnx_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: retrieve queue maximal & guaranteed size
 */
static int
_bcm_dnx_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class;
    int base_qid, qid; 
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport %d is not allowed for minimal/guaranteed queue size by memory/bytes configuration"), unit, gport ));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));

    if (sw_state_num_cos <= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, voq %d not added"), unit, base_qid));
    }

    if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }

    qid = base_qid + cosq;
    /* Get old rate class data */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple != JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rv = _bcm_dnx_cosq_voq_class_mapping_get(unit,core,qid,BCM_DNX_COSQ_RATE_CLS,&rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_dnx_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
    } else
    {
        /* Get old rate class data */
        rv = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_dnx_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_voq_discard_retrieve_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps)
{
    int index = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(dps);
    BCMDNX_NULL_CHECK(nof_dps);

    if ((flags & BCM_COSQ_DISCARD_COLOR_ALL) == BCM_COSQ_DISCARD_COLOR_ALL) {
        /* The configuration is relevanat for all dps */
        for (index = 0; index < DNX_DEVICE_COSQ_ING_NOF_DP; index++) {
            dps[index] = index;
        }
        *nof_dps = DNX_DEVICE_COSQ_ING_NOF_DP;
        BCM_EXIT;        
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_GREEN) {
        dps[index++] = 0;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_YELLOW) {
        dps[index++] = 1;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_RED) {
        dps[index++] = 2;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_BLACK) {
        dps[index++] = 3;
    }

    *nof_dps = index;

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * System RED discard/drop probability set
 */
static int 
_bcm_dnx_cosq_sys_red_dp_pr_set(int unit,
                                  bcm_dnx_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int index = 0, is_last = 0, is_allocated = 0, dp_pr_idx = 0;
    int nof_drop_prec = 0;
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];

    bcm_dnx_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;
    int new_sys_red_dp_pr_ndx, old_sys_red_dp_pr_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    for (index = 0; index < nof_drop_prec; index++) {
        /* check if discard->drop_probability already exist in am */
        data_sys_red_dp_pr.sys_red_dp_pr_val = discard->drop_probability;

        /* Stage 1: Find new profile according to given settings */

        /* Update information in SW */
        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }
        rc = _bcm_dnx_am_template_system_red_dp_pr_exchange(unit, dp_pr_idx, &data_sys_red_dp_pr, &old_sys_red_dp_pr_ndx, 
                                                            &is_last, &new_sys_red_dp_pr_ndx, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Commit Changes in HW according to given thresholds */
        if (is_allocated) {
            rc = _bcm_dnx_cosq_sys_red_dp_pr_hw_set(unit,new_sys_red_dp_pr_ndx,&data_sys_red_dp_pr);
            BCMDNX_IF_ERR_EXIT(rc);        
        } 
        
        /* Clear old profile */
        if (is_last && new_sys_red_dp_pr_ndx != old_sys_red_dp_pr_ndx) {
            sal_memset(&data_sys_red_dp_pr, 0x0, sizeof(bcm_dnx_cosq_ingress_system_red_dp_pr_info_t));
            rc = _bcm_dnx_cosq_sys_red_dp_pr_hw_set(unit, old_sys_red_dp_pr_ndx, &data_sys_red_dp_pr);
            BCMDNX_IF_ERR_EXIT(rc);    
        }
       
        if (discard->flags & BCM_COSQ_DISCARD_ENABLE) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x1;
        } else {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x0;
        }

        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].adm_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th      = discard->max_thresh;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_th        = discard->max_thresh;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }
    }
   
exit:
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_sys_red_dp_pr_get(int unit,
                                  bcm_dnx_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int dp_pr_idx = 0x0, dp_index = 0x0;
    int nof_drop_prec = 0x0;
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];

    bcm_dnx_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit, discard->flags, drop_prec, &nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {
        /* Can get only one color value */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].adm_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_low;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;            
    } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_high;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].drp_th;
    } else {
        /* Must use one of these flags */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
    }

    rc = _bcm_dnx_am_template_system_red_dp_pr_data_get(unit, dp_pr_idx, &data_sys_red_dp_pr);
    BCMDNX_IF_ERR_EXIT(rc);

    discard->drop_probability = data_sys_red_dp_pr.sys_red_dp_pr_val;

    if (data_rate_class->sys_red_qt_dp[dp_index].enable == 0x1) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    } else {
        discard->flags &= BCM_COSQ_DISCARD_ENABLE;
    }

    discard->gain = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 relevant_flags, max_drop_probability, max_discard_gain;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        max_drop_probability = BCM_DNX_COSQ_DISCARD_SYSTEM_RED_FROP_PROB;
        relevant_flags = discard->flags;
        max_discard_gain = 0x0;
    } else {
        relevant_flags = discard->flags & (is_vsq ?
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES) :
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_MARK_CONGESTION | BCM_COSQ_DISCARD_BUFFER_DESC) );

        max_drop_probability = BCM_DNX_COSQ_DISCARD_FROP_PROB;
        max_discard_gain = DNX_COSQ_PB_WRED_WQ_MAX;
    }
    if (SOC_IS_QAX(unit)) {
        /* BCM_COSQ_DISCARD_BUFFER_DESC is not available in JER2_QAX and later */
        relevant_flags &= ~BCM_COSQ_DISCARD_BUFFER_DESC;

    }

    if (discard->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, discard->flags));
    }

    if (discard->drop_probability < 0 || discard->drop_probability > max_drop_probability) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid drop probability parameter %d"), unit, discard->drop_probability));
    }

    if (discard->gain < 0 || discard->gain > max_discard_gain) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gain parameter %d"), unit, discard->drop_probability));
    }
    
    if (discard->min_thresh > discard->max_thresh) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is over Max threshold %d"), 
                       unit, discard->min_thresh,discard->max_thresh));
    }

    if (discard->min_thresh < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is invalid"), 
                       unit, discard->min_thresh));
    }

    if (discard->max_thresh < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Max threshold %d is invalid"), 
                       unit, discard->max_thresh));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve WRED configuration from discard structure to a rate class data structure 
 */
static int
_bcm_dnx_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec, index;
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);
    /* Change Rate class configuration according to discard structure */
    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        data_rate_class->ecn_wred_enable = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? DNX_SAND_TRUE:DNX_SAND_FALSE;
        data_rate_class->ecn_wred_min_avrg_th = discard->min_thresh;
        data_rate_class->ecn_wred_max_avrg_th = discard->max_thresh;
        data_rate_class->ecn_wred_max_probability = discard->drop_probability;
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            data_rate_class->ecn_queue_max_size = discard->ecn_thresh;
            if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
                  "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
            }
            if (!SOC_IS_ARADPLUS(unit) && discard->ecn_thresh > JER2_ARAD_B0_MAX_ECN_QUEUE_BYTES && discard->ecn_thresh < JER2_ARAD_MAX_QUEUE_SIZE_BYTES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Arad B0/B1 ECN queue size limit in bytes can not be in the range of 0x%x-0x%lx.\n"),JER2_ARAD_B0_MAX_ECN_QUEUE_BYTES+1 ,JER2_ARAD_MAX_QUEUE_SIZE_BYTES-1));
            }
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            data_rate_class->ecn_queue_max_size_bds = discard->ecn_thresh;
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* system RED */
        rc = _bcm_dnx_cosq_sys_red_dp_pr_set(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);

        if (nof_drop_prec == 0) {
            /* Nothing to change, just exit */
            BCM_EXIT;
        }

        for (index = 0; index < nof_drop_prec; index++) {
            data_rate_class->wred_enable[drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? DNX_SAND_TRUE:DNX_SAND_FALSE;
            data_rate_class->wred_min_avrg_th[drop_prec[index]] = discard->min_thresh;
            data_rate_class->wred_max_avrg_th[drop_prec[index]] = discard->max_thresh;
            data_rate_class->wred_max_probability[drop_prec[index]] = discard->drop_probability;
        }

        /* WRED exp wq parameter is same for all dps and ECN */
        data_rate_class->wred_exp_wq = discard->gain;
    }
exit:
    BCMDNX_FUNC_RETURN;

}
/* 
 * Purpose: retrieve WRED configuration from a rate class data structure to a discard structure
 */
static int
_bcm_dnx_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec;
    uint32 relevant_flags;
    int drop_prec[DNX_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        if ((discard->flags & (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) ==
            (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
              "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* System RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                                           BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK |
                                           BCM_COSQ_DISCARD_PROBABILITY1 | BCM_COSQ_DISCARD_PROBABILITY2 |
                                           BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_SYSTEM | BCM_COSQ_DISCARD_COLOR_ALL);

        if (discard->flags != relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

    } else { /* not ECN not system RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

        if (!relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

        if (!(discard->flags & BCM_COSQ_DISCARD_BYTES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x\n"), unit, discard->flags));
        }
    }

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* get ECN WRED */
        discard->drop_probability = data_rate_class->ecn_wred_max_probability;
        discard->min_thresh = data_rate_class->ecn_wred_min_avrg_th;
        discard->max_thresh = data_rate_class->ecn_wred_max_avrg_th;
        if (data_rate_class->ecn_wred_enable == DNX_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        } else {
            discard->flags &= ~BCM_COSQ_DISCARD_ENABLE;
        }
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size;
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size_bds;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        /* system RED */
        rc = _bcm_dnx_cosq_sys_red_dp_pr_get(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);

    } else { /* get regular WRED */
        rc = _bcm_dnx_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);

        if (nof_drop_prec != 1) {
            /* Nothing to change, just exit */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
        }
        dp_index = drop_prec[0];

        /* Wred settings is defined by Rate Class profile */
        discard->drop_probability = data_rate_class->wred_max_probability[dp_index];
        discard->min_thresh = data_rate_class->wred_min_avrg_th[dp_index];
        discard->max_thresh = data_rate_class->wred_max_avrg_th[dp_index];
        if (data_rate_class->wred_enable[dp_index] == DNX_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set WRED configuration of a rate class
 */
static int
_bcm_dnx_cosq_gport_rate_class_discard_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cosq_gport_discard_t *discard)
{ 
    bcm_error_t rv = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t 
        data_rate_class, 
        exact_data_rate_class;
    int rate_class;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }
    /*validate profiles range*/
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
   
    /* 
     * Check that the system is in advance queue to rate class mapping mode, 
     *    if not set it to advance mode.
     */
    rv = _bcm_dnx_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rv);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    BCMDNX_NULL_CHECK(discard);

    rv = _bcm_dnx_cosq_gport_discard_verify(unit, discard ,0);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 1. Get rate class data */
    rv = _bcm_dnx_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 
     * Change related information
     * This method does not only configure data_rate_class but creates a system red template and access the HW 
     * So if we should fail at the HW configuration or the template configuration: we cannot recover
     */
    rv = _bcm_dnx_cosq_gport_discard_to_rate_class_data(unit, discard, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);
    /* 
     * checking that the remaining resource level is not too low - currently 2%
     * is not needed: relevent only for color size
     */
    /*2. configure HW*/
    rv = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_class,&exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);        

exit:
    BCMDNX_FUNC_RETURN;
} 

/* 
 * Purpose: Set WRED configuration
 */
static int
_bcm_dnx_cosq_gport_voq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class, exact_data_rate_class, cleared_data_rate;
    int new_rate_class,old_rate_class, is_allocated,is_last;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));

    if (sw_state_num_cos <= 0) {
        /* Not initalized VOQ */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("Unit(%d) Invalid VOQ %d parameter\n"),
                         unit, base_qid));
    }

    if (cosq < 0 || cosq >= sw_state_num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) Num cos is invalid. range is 0 - %d\n"),
                     unit, base_qid, sw_state_num_cos - 1));
    }

    rc = _bcm_dnx_cosq_gport_discard_verify(unit, discard, 0);
    BCMDNX_IF_ERR_EXIT(rc);
    
    qid = base_qid + cosq;

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_gport_discard_to_rate_class_data(unit, discard, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Settings WRED parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there aren't profiles that are free. This can be resolved if all configurations
       are given as exact */
     

    /* Stage 1: Find new profile according to given settings */

    /* Update information in SW */
    rc = _bcm_dnx_am_template_queue_rate_cls_exchange(unit, core, qid, &data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, new_rate_class, &data_rate_class, &exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(&exact_data_rate_class, &data_rate_class, sizeof(exact_data_rate_class));
    }
    /* Set new mapping */
    rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear old profile */
    if (is_last && new_rate_class != old_rate_class) {
        sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
        rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit,old_rate_class,&data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    rc = _bcm_dnx_am_template_queue_rate_cls_exchange(unit, core, qid, &exact_data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, new_rate_class, &exact_data_rate_class, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Set new mapping */
    rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Clear old profile */
    if (is_last && new_rate_class != old_rate_class) {
        sal_memset(&data_rate_class, 0x0, sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
        rc = _bcm_dnx_cosq_voq_rate_class_hw_set(unit, old_rate_class, &data_rate_class, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Retrieve WRED configuration of a rate class
 */
static int
_bcm_dnx_cosq_gport_rate_class_discard_get(int unit, 
                                             bcm_gport_t gport, 
                                             bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class;
    int rate_class;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));    

    /*validate profiles range*/
    if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }

    /* Get Rate class data */
    rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: Retrieve WRED configuration
 */
static int
_bcm_dnx_cosq_gport_voq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid;
    bcm_dnx_cosq_ingress_rate_class_info_t data_rate_class;
    uint8 sw_state_num_cos;
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));    

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)\n"), unit, gport));
    }

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));

    if (sw_state_num_cos == 0) {
        /* Not initalized VOQ */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("Unit(%d) Invalid VOQ %d parameter\n"),
                         unit, base_qid));
    }

    if (cosq < 0 || cosq >= sw_state_num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) Num cos is invalid. range is 0 - %d\n"),
                     unit, base_qid, sw_state_num_cos - 1));
    }
    qid = base_qid + cosq;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    /* Get Rate class data */
    if (queue_to_rate_class_mapping_is_simple != JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rc = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, qid, BCM_DNX_COSQ_RATE_CLS, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
    {
        rc = _bcm_dnx_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dnx_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping port to thresh_type
 */
int
_bcm_dnx_cosq_egress_thresh_map_get(int unit,
                                      int port,
                                      uint32 *profile)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_EGR_PORT_THRESH_TYPE thresh_type = DNX_TMC_EGR_PORT_NOF_THRESH_TYPES;    
    uint32 dnx_sand_rc;    
    int    core=0;
    uint32 tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_thresh_type_get,(unit,core,port,&thresh_type)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    *profile = thresh_type;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile for JER2_ARAD
 */

static int
_bcm_jer2_arad_cosq_egress_thresh_entry_get(int unit,
                                       int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 dnx_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    DNX_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    DNX_TMC_EGR_QUEUING_DEV_TH
        dev_thresh;
    DNX_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Clear */
    DNX_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    DNX_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    DNX_TMC_EGR_QUEUING_DEV_TH_clear(&dev_thresh);
    DNX_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    DNX_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Get scheduled fc */
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_fc_get,(unit, core, prio, threshold_type, &fc_ofp_thresh)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        thresh_info->sch_fc_packet_descriptors_tc[prio] = fc_ofp_thresh.packet_descriptors;
        thresh_info->sch_fc_data_buffers_tc[prio] = fc_ofp_thresh.words;/* queue_words_consumed parameter used for Data buffers in Arad */
        thresh_info->sch_fc_packet_descriptors_min_tc[prio] = fc_ofp_thresh.packet_descriptors_min;
        thresh_info->sch_fc_packet_descriptors_alpha_tc[prio] = fc_ofp_thresh.packet_descriptors_alpha;
        thresh_info->sch_fc_data_buffers_min_tc[prio] = fc_ofp_thresh.data_buffers_min;
        thresh_info->sch_fc_data_buffers_alpha_tc[prio] = fc_ofp_thresh.data_buffers_alpha;
    }
    
    /* Get scheduled drop and unscheduled drop with cosq == -1 */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_dev_get,(unit, core ,&dev_thresh)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* get special values (min, alpha)*/
    if (SOC_IS_JERICHO(unit)) {
        dnx_sand_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sch_unsch_drop_get_unsafe, (unit, core, threshold_type,&dev_thresh));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

    thresh_info->sch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].uc.descriptors;
    thresh_info->sch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].uc.buffers;
    thresh_info->unsch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors;
    thresh_info->unsch_drop_packet_descriptors_min = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors_min;
    thresh_info->unsch_drop_packet_descriptors_alpha = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors_alpha;
    thresh_info->unsch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].mc_shared.buffers;
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        thresh_info->unsch_drop_packet_descriptors_available_tc[prio] = dev_thresh.thresh_type[threshold_type].reserved[prio].descriptors;
    }

    /* Port FC Thresholds */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_fc_get,(unit, core, JER2_ARAD_EGR_Q_PRIO_ALL, threshold_type, &fc_ofp_thresh)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    thresh_info->port_fc_packet_descriptors = fc_ofp_thresh.packet_descriptors;
    thresh_info->port_fc_data_buffers = fc_ofp_thresh.data_buffers;
    thresh_info->port_fc_packet_descriptors_min = fc_ofp_thresh.packet_descriptors_min;
    thresh_info->port_fc_packet_descriptors_alpha = fc_ofp_thresh.packet_descriptors_alpha;
    thresh_info->port_fc_data_buffers_min = fc_ofp_thresh.data_buffers_min;
    thresh_info->port_fc_data_buffers_alpha = fc_ofp_thresh.data_buffers_alpha;


    /* Get scheduled drop */
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_sched_drop_get,(unit, prio, &drop_thresh)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        thresh_info->sch_drop_data_buffers_tc[prio] = drop_thresh.queue_words_consumed[threshold_type]; /* queue_words_consumed parameter used for Data buffers in Arad */
        thresh_info->sch_drop_packet_descriptors_tc[prio] = drop_thresh.queue_pkts_consumed[threshold_type];
    } 

    /* Get unscheduled drop */

    for (prio = 0; prio < DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD; prio++) {
        for (dp = 0; dp < DNX_DEVICE_COSQ_EGR_NOF_DP; dp++) {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_unsched_drop_get,(unit, core, prio, dp, &drop_thresh)));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

            thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp] = drop_thresh.queue_words_consumed[threshold_type];/* queue_words_consumed parameter used for Data buffers in Arad */
            thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed[threshold_type];

            thresh_info->unsch_drop_packet_descriptors_min_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed_min[threshold_type];
            thresh_info->unsch_drop_packet_descriptors_alpha_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed_alpha[threshold_type];
        }
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile
 */
int
_bcm_dnx_cosq_egress_thresh_entry_get(int unit,
                                        int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_jer2_arad_cosq_egress_thresh_entry_get(unit, core, profile, thresh_info);
    BCM_IF_ERROR_RETURN(rc);
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_egress_thresh_to_exact_thresh(int unit,
                                         uint32 thresh,
                                         uint32 *exact_thresh)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_NULL_CHECK(exact_thresh);

    *exact_thresh = thresh;
exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
static int
_bcm_dnx_cosq_egress_thresh_profile_set(int unit,
                                      int port,
                                      int profile)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_EGR_PORT_THRESH_TYPE thresh_type;
    uint32 dnx_sand_rc;    
    uint32 tm_port;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
    thresh_type = profile;

    rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_ofp_thresh_type_set,(unit, core, tm_port, thresh_type)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw
 */
static int
_bcm_dnx_cosq_egress_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_jer2_arad_cosq_egress_thresh_profile_data_set(unit, core, profile, thresh_info);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw for JER2_ARAD
 */
static int
_bcm_jer2_arad_cosq_egress_thresh_profile_data_set(int unit,
                                              int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 dnx_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    DNX_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    DNX_TMC_EGR_QUEUING_DEV_TH
        *dev_thresh = NULL;
    DNX_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_ALLOC(dev_thresh, sizeof(DNX_TMC_EGR_QUEUING_DEV_TH), "_bcm_jer2_arad_cosq_egress_thresh_profile_data_set.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    /* Clear */
    DNX_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    DNX_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    DNX_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);
    DNX_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    DNX_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Set scheduled fc - per Q */
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {

            
        fc_ofp_thresh.packet_descriptors = thresh_info->sch_fc_packet_descriptors_tc[prio];
        fc_ofp_thresh.packet_descriptors_min = thresh_info->sch_fc_packet_descriptors_min_tc[prio];
        fc_ofp_thresh.packet_descriptors_alpha = thresh_info->sch_fc_packet_descriptors_alpha_tc[prio];

        fc_ofp_thresh.data_buffers = thresh_info->sch_fc_data_buffers_tc[prio];/* queue_words_consumed parameter used for Data buffers in Arad */
        fc_ofp_thresh.data_buffers_min = thresh_info->sch_fc_data_buffers_min_tc[prio];
        fc_ofp_thresh.data_buffers_alpha = thresh_info->sch_fc_data_buffers_alpha_tc[prio];

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_sched_q_fc_thresh_set, (unit, core, prio, threshold_type, &fc_ofp_thresh)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
  
    }
    
    /* Port FC Thresholds - flow control*/

    fc_ofp_thresh.packet_descriptors = thresh_info->port_fc_packet_descriptors;
    fc_ofp_thresh.packet_descriptors_min = thresh_info ->port_fc_packet_descriptors_min;
    fc_ofp_thresh.packet_descriptors_alpha = thresh_info->port_fc_packet_descriptors_alpha;

    fc_ofp_thresh.data_buffers = thresh_info->port_fc_data_buffers;
    fc_ofp_thresh.data_buffers_min = thresh_info -> port_fc_data_buffers_min;
    fc_ofp_thresh.data_buffers_alpha = thresh_info -> port_fc_data_buffers_alpha;


    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_sched_port_fc_thresh_set, (unit, core, threshold_type, &fc_ofp_thresh))); 
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    /* Port&Queue Drop thresholds */
     
    dev_thresh->thresh_type[threshold_type].uc.descriptors = thresh_info->sch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].uc.buffers = thresh_info->sch_drop_data_buffers;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors = thresh_info->unsch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors_min = thresh_info->unsch_drop_packet_descriptors_min;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors_alpha = thresh_info->unsch_drop_packet_descriptors_alpha;
    dev_thresh->thresh_type[threshold_type].mc_shared.buffers = thresh_info->unsch_drop_data_buffers;
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        dev_thresh->thresh_type[threshold_type].reserved[prio].descriptors = thresh_info->unsch_drop_packet_descriptors_available_tc[prio];
    }
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sch_unsch_drop_set, (unit, core, threshold_type, dev_thresh)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* Set scheduled drop */
    for (prio = 0; prio < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {

        drop_thresh.queue_words_consumed[threshold_type] = thresh_info->sch_drop_data_buffers_tc[prio]; 
        drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->sch_drop_packet_descriptors_tc[prio];

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_sched_drop_set,(unit, core, threshold_type ,prio, &drop_thresh, &exact_drop_thresh)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    } 

    /* Set unscheduled drop */

    for (prio = 0; prio < DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD; prio++) {
        for (dp = 0; dp < DNX_DEVICE_COSQ_EGR_NOF_DP; dp++) {

            drop_thresh.queue_words_consumed[threshold_type] = thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed_min[threshold_type] = thresh_info->unsch_drop_packet_descriptors_min_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed_alpha[threshold_type] = thresh_info->unsch_drop_packet_descriptors_alpha_tc_dp[prio][dp];

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_unsched_drop_set,(unit, core, threshold_type, prio, dp, &drop_thresh, &exact_drop_thresh)));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }

    BCM_EXIT;
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
static int
_bcm_dnx_cosq_egress_interface_uc_thresh_profile_set(int unit,
                                                       int core,
                                      soc_port_if_t interface_type,
                                      uint32 internal_interface_id,
                                      int profile)
{
    uint32 dnx_sand_rc;    
    
    BCMDNX_INIT_FUNC_DEFS;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_if_uc_map_set, (unit, core, interface_type,internal_interface_id, profile)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control unicast in hw
 */
static int
_bcm_dnx_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  dnx_sand_rc;
    DNX_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    info.pd_th = thresh_profile->fc_packet_descriptors; 
    info.pd_th_min = thresh_profile->fc_packet_descriptors_min;
    info.pd_th_alpha = thresh_profile->fc_packet_descriptors_alpha;
    info.size256_th = thresh_profile->fc_words_consumed;
    info.size256_th_min = thresh_profile->fc_words_consumed_min;
    info.size256_th_alpha = thresh_profile->fc_packet_descriptors_alpha;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_if_fc_uc_set,(unit, core, profile, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control unicast from the hw
 */
static int
_bcm_dnx_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                                        int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  dnx_sand_rc;
    DNX_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_if_fc_uc_get,(unit, core, profile, &info)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    thresh_profile->fc_packet_descriptors = info.pd_th;
	thresh_profile->fc_packet_descriptors_min = info.pd_th_min;
    thresh_profile->fc_packet_descriptors_alpha = info.pd_th_alpha;	
    thresh_profile->fc_words_consumed = info.size256_th;
    thresh_profile->fc_words_consumed_min = info.size256_th_min;
    thresh_profile->fc_words_consumed_alpha = info.size256_th_alpha;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
static int
_bcm_dnx_cosq_egress_interface_mc_thresh_profile_set(int unit,
                                                       int core,
                                      soc_port_if_t interface_type,
                                      uint32 internal_interface_id,
                                      int profile)
{
    uint32 dnx_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_if_mc_map_set, (unit, core, interface_type,internal_interface_id, profile)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control multicast from the hw
 */
static int
_bcm_dnx_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  dnx_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_if_fc_mc_get,(unit, profile, &thresh_profile->packet_descriptors)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control multicast in hw
 */
static int
_bcm_dnx_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  dnx_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_if_fc_mc_set,(unit, core, profile, thresh_profile->packet_descriptors)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose:
 * Add egress thresh information to multiset, 
 * Information by gport,cosq and threshold type. 
 */
static int
_bcm_dnx_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_egress_thresh_key_info_t thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    int core, port;
    DNX_TMC_EGR_Q_PRIO prio;   
    uint32 exact_value, ofp_ndx;
    int start_prio, end_prio;
    soc_port_t lcl_port;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &ofp_ndx, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_dnx_am_template_cosq_egr_thresh_data_get(unit, core, port,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change data */     
    rc = _bcm_dnx_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value); 
    BCMDNX_IF_ERR_EXIT(rc);

    /* if cosq = -1 then prio is DNX_TMC_EGR_Q_PRIO_ALL */
    /* in this case need to go over all priorities from DNX_TMC_EGR_Q_PRIO_0 to DNX_TMC_EGR_Q_PRIO_7 */
    /* otherwise, need just to configure the selected priority */
    if(prio == DNX_TMC_EGR_Q_PRIO_ALL)
    {
      start_prio = DNX_TMC_EGR_Q_PRIO_0;
      end_prio = DNX_TMC_EGR_Q_PRIO_7;
    }
    else
    {
      start_prio = prio;
      end_prio = prio;
    }
    
    for(prio = start_prio; prio <= end_prio; prio++)
    {
      switch(threshold->type) {
          case bcmCosqThresholdBytes:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  thresh_key.sch_fc_words_consumed[prio] = exact_value;
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      thresh_key.sch_drop_words_consumed[prio] = exact_value;
                  } else {
                      thresh_key.unsch_drop_words_consumed[prio][threshold->dp] = exact_value;
                  }
              }
              break;     
          case bcmCosqThresholdPackets:
              /* Schedule or Unschedule */
              if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                  thresh_key.sch_drop_pkts_consumed[prio] = exact_value;
              } else {
                  thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp] = exact_value;
              }
              break;
          case bcmCosqThresholdPacketDescriptors    :
              /* FC or drop */
              if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                  if(cosq == -1) { /* PORT LEVEL */
                      thresh_key.port_fc_packet_descriptors = exact_value;
                      thresh_key.port_fc_packet_descriptors_min = exact_value;
                      thresh_key.port_fc_data_buffers_alpha = 0;
                  }
                  else
                  { /* QUEUE */
                      thresh_key.sch_fc_packet_descriptors_tc[cosq] = exact_value;
                      thresh_key.sch_fc_packet_descriptors_min_tc[cosq] = exact_value;
                      thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq] = 0;
                  }
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) {
                          thresh_key.sch_drop_packet_descriptors = exact_value;
                      }
                      else
                      {
                          thresh_key.sch_drop_packet_descriptors_tc[cosq] = exact_value;
                      }
                  } 
                  else /* Multicast queue, drop */
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_packet_descriptors = exact_value;
                          thresh_key.unsch_drop_packet_descriptors_min = exact_value; /* Legacy in jer2_jericho */
                          thresh_key.unsch_drop_packet_descriptors_alpha = 0; /* Legacy in jer2_jericho */
                      }
                      else
                      {                         
                          
                          thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp] = exact_value;
                          thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp] = exact_value; /* Legacy in jer2_jericho */
                          thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp] = 0; /* Legacy in jer2_jericho */
                      }
                  }
              }
              break;
          case bcmCosqThresholdDataBuffers:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  if(cosq == -1) {
                      thresh_key.port_fc_data_buffers = exact_value;
                      thresh_key.port_fc_data_buffers_min = exact_value;
                      thresh_key.port_fc_data_buffers_alpha = 0;
                  }
                  else
                  {
                      thresh_key.sch_fc_data_buffers_tc[cosq] = exact_value;
                      thresh_key.sch_fc_data_buffers_min_tc[cosq] = exact_value;
                      thresh_key.sch_fc_data_buffers_alpha_tc[cosq] = 0;
                  }
              } 
              else
              {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) { 
                          thresh_key.sch_drop_data_buffers = exact_value;
                         
                      }
                      else
                      {
                          thresh_key.sch_drop_data_buffers_tc[cosq] = exact_value;
                      }
                  }
                  else
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_data_buffers = exact_value;
                      }
                      else
                      {
                          thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp] = exact_value;
                      }
                  }
              }
              break;
          case bcmCosqThresholdAvailablePacketDescriptors:
              if(cosq < 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("For type bcmCosqThresholdAvailablePacketDescriptors the cosq must be greater or equal to 0\n\r")));
              }
              thresh_key.unsch_drop_packet_descriptors_available_tc[cosq] = exact_value;
              break;
          case bcmCosqThresholdPacketDescriptorsMin:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) 
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors_min = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors_min = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_min_tc[cosq] = exact_value;
                  }
              }
              break;
          case bcmCosqThresholdPacketDescriptorsMax:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if (((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_tc[cosq] = exact_value;
                  }
              }
              break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors_alpha = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors_alpha = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq] = exact_value;
                  }
              }
              break;

        case bcmCosqThresholdDataBuffersMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers_min = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_min_tc[cosq] = exact_value;
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_tc[cosq] = exact_value;
                }
            }
            break;
        case bcmCosqThresholdDataBuffersAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers_alpha = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_alpha_tc[cosq] = exact_value;
                }
            }
            break;
        default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
      }
    }

    /* Set new object */
    rc = _bcm_dnx_am_template_cosq_egr_thresh_exchange(unit, core, port,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &lcl_port));
        /* Set new profile */
        rc = _bcm_dnx_cosq_egress_thresh_profile_set(unit,lcl_port,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_dnx_cosq_egress_thresh_profile_data_set(unit, core, template,&thresh_key); 
        BCMDNX_IF_ERR_EXIT(rc);
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * get egress thresh information from multiset, 
 * Information by gport,cosq and threshold type. 
 */
static int
_bcm_dnx_cosq_gport_egress_thresh_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_egress_thresh_key_info_t thresh_key;
    int core;
    int port;
    DNX_TMC_EGR_Q_PRIO prio;
    uint32 ofp_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &ofp_ndx, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    if (prio == DNX_TMC_EGR_Q_PRIO_ALL) 
    {
        prio = DNX_TMC_EGR_Q_PRIO_0; /* read just prio 0*/
    }

    /* Data get */
    rc = _bcm_dnx_am_template_cosq_egr_thresh_data_get(unit, core, port ,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                threshold->value = thresh_key.sch_fc_words_consumed[prio];
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    threshold->value = thresh_key.sch_drop_words_consumed[prio];
                } else {
                    threshold->value = thresh_key.unsch_drop_words_consumed[prio][threshold->dp];
                }
            }
            break;     
        case bcmCosqThresholdPackets:
            /* Schedule or Unschedule */
            if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                threshold->value = thresh_key.sch_drop_pkts_consumed[prio];
            } else {
                threshold->value = thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp];
            }
            break;
        case bcmCosqThresholdPacketDescriptors     :
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_packet_descriptors;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_tc[cosq];
                }
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_packet_descriptors_tc[cosq];
                    }
                } 
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdDataBuffers:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_data_buffers;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_tc[cosq];
                }
            } 
            else
            {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_data_buffers_tc[cosq];
                    }
                }
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdAvailablePacketDescriptors:
            threshold->value = thresh_key.unsch_drop_packet_descriptors_available_tc[cosq];
            break;
        case bcmCosqThresholdPacketDescriptorsMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_min;
                }
                else
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp];
                }
            }
            else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors_min;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_min_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdPacketDescriptorsMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                  if (cosq == -1)
                  {
                      threshold->value = thresh_key.unsch_drop_packet_descriptors;
                  }
                  else
                  {
                      threshold->value = thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp];
                  }
            }
            else if (((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdPacketDescriptorsAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_alpha;
                }
                else
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp];
                }
            }
            else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors_alpha;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers_min;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_min_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers_alpha;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_alpha_tc[cosq];
                }
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
static int
_bcm_dnx_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dnx_cosq_ingress_rate_class_info_t* data_rate_cls)
{
    int tc = threshold->tc;
    int vsq_category = threshold->vsq_category;
    int index;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    BCMDNX_NULL_CHECK(data_rate_cls);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            for (index = 0; index < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS ; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_words[index] = 
                    threshold->value / DNX_DEVICE_DNX_COSQ_OCB_16BYTES_RESOLUTION;
            }
            break;     
        case bcmCosqThresholdDbuffs:
            for (index = 0; index < DNX_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS ; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_buffers[index] = threshold->value;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(threshold->flags & BCM_COSQ_THRESHOLD_SET)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = TRUE;
    }
    else if(threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = FALSE;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Set Egress device wide flow control scheduled thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc; 
    int core, core_iterator;
       
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_fc_set,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_unicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc; 
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        if (cosq == -1) /* global */
        {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_fc_set,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_multicast)));
        }
        else /* specific TC */
        {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_tc_fc_set,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value)));
        }
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled pool thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_fc_set, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_service_pool_0 + pool)));
        DNX_BCM_SAND_IF_ERR_EXIT(rc);
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control global thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_all_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_fc_set, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_total)));
        DNX_BCM_SAND_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    int core, core_iterator;
    uint32 dnx_sand_rc;       
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
 
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_fc_get,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_unicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }   

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc;       
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        if (cosq == -1) /* global */
        {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_fc_get,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_multicast)));
        }
        else /* specific TC */
        {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_tc_fc_get,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value))));
        }
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
 
    uint32 dnx_sand_rc; 
    int core, core_iterator;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers 
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
 
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_fc_get, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_service_pool_0 + pool)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }
        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control global thresholds 
 */
static int
_bcm_dnx_cosq_gport_egress_device_all_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_fc_get, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_total)));
        DNX_BCM_SAND_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set FC threshold for scheduled traffic per {port,priority}
 */
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersAlpha)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (threshold->flags &  
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (cosq != -1 && !(DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    /* Make the Update */
    rc = _bcm_dnx_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get FC threshold for scheduled traffic per {port,priority}
 */
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API\n"), unit));
    }

    if (cosq != -1 && !(DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersAlpha)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    /* Get information from SW */
    rc = _bcm_dnx_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set threshold for traffic per interface
 */
static int
_bcm_dnx_cosq_gport_interface_egress_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    uint32 exact_value;
    uint32 tm_port;
    soc_port_t lcl_port;
    uint32 interface_id_internal;
    soc_port_if_t interface_type;
    int core;      

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes

          || threshold->type == bcmCosqThresholdDataBuffers  
          || threshold->type == bcmCosqThresholdDataBuffersMin 
          || threshold->type == bcmCosqThresholdDataBuffersMax 
          || threshold->type == bcmCosqThresholdDataBuffersAlpha

          || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha    )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }


    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL));

    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &lcl_port));

    /*tm port and core to egq interface*/
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port2egress_offset, (unit, core, tm_port, &interface_id_internal)));

    /*port interface type*/
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_interface_type_get(unit, lcl_port, &interface_type));


    /* Change data */     
    rc = _bcm_dnx_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value);
    BCMDNX_IF_ERR_EXIT(rc);

    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      if (!(threshold->flags &  BCM_COSQ_THRESHOLD_FLOW_CONTROL )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }

      /* Old data get */
        rc = _bcm_dnx_am_template_cosq_egr_interface_unicast_thresh_data_get(unit,core ,interface_id_internal,&uc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        
        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            /* Schedule or Unschedule */
            uc_thresh_key.fc_packet_descriptors = exact_value;
            uc_thresh_key.fc_packet_descriptors_min = exact_value;
            uc_thresh_key.fc_packet_descriptors_alpha = 0;

            break;

          case bcmCosqThresholdPacketDescriptorsMin:
            uc_thresh_key.fc_packet_descriptors_min = exact_value;
            break;
          case bcmCosqThresholdPacketDescriptorsMax:
            uc_thresh_key.fc_packet_descriptors = exact_value;
            break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
            uc_thresh_key.fc_packet_descriptors_alpha = exact_value;
            break;
          case bcmCosqThresholdDataBuffers:
          case bcmCosqThresholdBytes:
            uc_thresh_key.fc_words_consumed = exact_value;
            uc_thresh_key.fc_words_consumed_min = exact_value;
            uc_thresh_key.fc_words_consumed_alpha = 0;
            break;
          case bcmCosqThresholdDataBuffersMin:
            uc_thresh_key.fc_words_consumed_min = exact_value;
            break;
          case bcmCosqThresholdDataBuffersMax:
            uc_thresh_key.fc_words_consumed = exact_value;
            break;
          case bcmCosqThresholdDataBuffersAlpha:
            uc_thresh_key.fc_words_consumed_alpha = exact_value;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));             
        }

        /* Set new object */
        rc = _bcm_dnx_am_template_cosq_egr_interface_unicast_thresh_exchange(unit, core, interface_id_internal,&uc_thresh_key,&old_template,&is_last,&template,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        if (old_template != template) {
          /* Set new profile */
          rc = _bcm_dnx_cosq_egress_interface_uc_thresh_profile_set(unit,core, interface_type, interface_id_internal,template); 
          BCMDNX_IF_ERR_EXIT(rc);
        }

        if (is_allocated) {
          /* Set new data for a specific profile */
          rc = _bcm_dnx_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit,core, template,&uc_thresh_key);
          BCMDNX_IF_ERR_EXIT(rc);
        }

    }
    else
    {
      /* Multicast */
      if (!(threshold->flags & BCM_COSQ_THRESHOLD_DROP)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }
        rc = _bcm_dnx_am_template_cosq_egr_interface_multicast_thresh_data_get(unit,core ,interface_id_internal,&mc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);

        switch(threshold->type) {   
          case bcmCosqThresholdPacketDescriptors     :
            mc_thresh_key.packet_descriptors = exact_value;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

        /* Set new object */
        rc = _bcm_dnx_am_template_cosq_egr_interface_multicast_thresh_exchange(unit, core ,interface_id_internal,&mc_thresh_key,&old_template,&is_last,&template,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        if (old_template != template) {
          /* Set new profile */
          rc = _bcm_dnx_cosq_egress_interface_mc_thresh_profile_set(unit,core, interface_type, interface_id_internal, template); 
          BCMDNX_IF_ERR_EXIT(rc);
        }

        if (is_allocated) {
        /* Set new data for a specific profile */
          rc = _bcm_dnx_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit,core, template,&mc_thresh_key);
          BCMDNX_IF_ERR_EXIT(rc);
        }

    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get threshold traffic per interface
 */
static int
_bcm_dnx_cosq_gport_interface_egress_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dnx_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    int core;
    soc_port_t lcl_port;
    uint32 tm_port;
    uint32 interface_id_internal;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mc_thresh_key,0x0,sizeof(bcm_dnx_cosq_egress_interface_multicast_thresh_key_info_t));
    /* Verify */
    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if (!( threshold->type == bcmCosqThresholdDataBuffers  
          || threshold->type == bcmCosqThresholdDataBuffersMin 
          || threshold->type == bcmCosqThresholdDataBuffersMax 
          || threshold->type == bcmCosqThresholdDataBuffersAlpha

          || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha     )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }


    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL));

    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &lcl_port));

    /*tm port and core to egq interface*/
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port2egress_offset, (unit, core, tm_port, &interface_id_internal)));

    /* Get information from SW */
    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      if (!(threshold->flags &  BCM_COSQ_THRESHOLD_FLOW_CONTROL )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }
        rc = _bcm_dnx_am_template_cosq_egr_interface_unicast_thresh_data_get(unit, core , interface_id_internal,&uc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        threshold->value = mc_thresh_key.packet_descriptors;

        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            /* Schedule or Unschedule */
            threshold->value = uc_thresh_key.fc_packet_descriptors;
            break;
          case bcmCosqThresholdPacketDescriptorsMin: 
            threshold->value = uc_thresh_key.fc_packet_descriptors_min;
            break;
          case bcmCosqThresholdPacketDescriptorsMax:
            threshold->value = uc_thresh_key.fc_packet_descriptors;
            break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
            threshold->value = uc_thresh_key.fc_packet_descriptors_alpha;
            break;
          case bcmCosqThresholdDataBuffers:
          case bcmCosqThresholdBytes:
            threshold->value = uc_thresh_key.fc_words_consumed;
            break;
          case bcmCosqThresholdDataBuffersMin:
            threshold->value = uc_thresh_key.fc_words_consumed_min;
            break;
          case bcmCosqThresholdDataBuffersMax:
            threshold->value= uc_thresh_key.fc_words_consumed;
            break;
          case bcmCosqThresholdDataBuffersAlpha:
            threshold->value = uc_thresh_key.fc_words_consumed_alpha;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field")));
        }
    }
    else
      {
        if (!(threshold->flags &  BCM_COSQ_THRESHOLD_DROP )) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
        }
        rc = _bcm_dnx_am_template_cosq_egr_interface_multicast_thresh_data_get(unit, core ,interface_id_internal,&mc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            threshold->value = mc_thresh_key.packet_descriptors;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field")));
        }
   }


exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of scheduled traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    /* Check correct threshold types */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_set,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_unicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);      
    }
          
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc = DNX_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_set,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_multicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of all traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_drop_set, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_total)));     
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);   
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set per TC.
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersAlpha))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if(cosq < 0 || cosq >= JER2_ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sp_tc_drop_set ,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);       
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersAlpha))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if(cosq < 0 || cosq >= JER2_ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_sp_tc_drop_get ,(unit, core, cosq, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);       
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
    
/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{

    uint32 dnx_sand_rc = DNX_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }   

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {      
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_set,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, threshold->value, soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);       
    }

    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_gport_egress_device_mc_sp_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{

    uint32 dnx_sand_rc = DNX_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }   

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {      
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_get,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_service_pool_0 +  sp)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);       
    }

    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of scheduled traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core=0;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_get,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_unicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);      
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptors     ))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_global_drop_get,(unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_multicast)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);      
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of all traffic drop threshold set.
 */
static int
_bcm_dnx_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc = DNX_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdDataBuffers 
          || threshold->type == bcmCosqThresholdPacketDescriptors     ))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DNX_CORES_ITER(core_iterator, core)
    {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_egr_queuing_global_drop_get, (unit, core, (soc_dnx_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dnx_cosq_threshold_global_type_total)));     
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);   
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Purpose: 
 * Set unscheduled traffic drop thresholds per port
 */
static int
_bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold-> type == bcmCosqThresholdPacketDescriptorsAlpha)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST ) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    
    if(cosq != -1 && !(threshold->flags & BCM_COSQ_THRESHOLD_PER_DP)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (cosq != -1 && threshold->dp > DNX_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if (cosq != -1 && !(DNX_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }
    /* SW multiset Update */
    rc = _bcm_dnx_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get scheduled traffic drop thresholds per port
 */
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    /* Get information from SW */
    rc = _bcm_dnx_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set scheduled traffic drop thresholds per port
 */
static int
_bcm_dnx_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptors    )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    /* SW multiset Update */
    rc = _bcm_dnx_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Conversion from cosq parameter to egress queue id
 */
static int
_bcm_dnx_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq)
{
    bcm_error_t rv = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *queue_id = 0;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *queue_id = 1;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            *queue_id = cosq;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }
    
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_egress_cosq_validate(int unit, int cosq)
{
    bcm_error_t rv = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (!( ((cosq >= -1) && (cosq <= 7)) || (cosq == BCM_COSQ_HIGH_PRIORITY) || (cosq == BCM_COSQ_LOW_PRIORITY)))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority)
{
    bcm_error_t rv = BCM_E_NONE;
    

    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *priority = 0;
            break;

        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *priority = 1;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Purpose: 
 * Get unscheduled traffic drop thresholds per port
 */
static int
_bcm_dnx_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int max_cosq_num; 

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    max_cosq_num = DNX_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((cosq >= -1 && cosq <= max_cosq_num) ||
          (cosq >= BCM_COSQ_HIGH_PRIORITY && cosq <= BCM_COSQ_LOW_PRIORITY))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d, cosq can be in range of 0-1 or High/Low priorities"), cosq));
    }
    
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors 
          || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    
    if(cosq != -1 && !(threshold->flags & BCM_COSQ_THRESHOLD_PER_DP)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (threshold->dp > DNX_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }

    /* Get information from SW */
    rc = _bcm_dnx_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get all info for a specific profile from hw
 */
int
_bcm_dnx_cosq_gport_egress_queue_mapping_hw_get(int unit,
                                                  int profile,
                                                  int core,
                                                  bcm_dnx_cosq_egress_queue_mapping_info_t* mapping_info)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_EGR_Q_PRIO_MAPPING_TYPE index_type;
    bcm_cos_t index_pri; 
    bcm_color_t index_dp;
    DNX_TMC_EGR_Q_PRIORITY egr_prio;
    
    BCMDNX_INIT_FUNC_DEFS;

    for (index_type = 0; index_type < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DNX_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DNX_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_prio_get,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);

                mapping_info->queue_mapping[index_type][index_pri][index_dp].dp = egr_prio.dp;
                mapping_info->queue_mapping[index_type][index_pri][index_dp].tc = egr_prio.tc;                
            }
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set new profile for egress queue mapping
 */
static int
_bcm_dnx_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dnx_cosq_egress_queue_mapping_info_t* mapping_info)
{   
    bcm_error_t rc = BCM_E_NONE;
    int index_dp,index_pri,index_type;
    DNX_TMC_EGR_Q_PRIORITY egr_prio;      
    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Run over all data and commit to hw */
    for (index_type = 0; index_type < DNX_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DNX_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DNX_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                egr_prio.dp = mapping_info->queue_mapping[index_type][index_pri][index_dp].dp;
                egr_prio.tc = mapping_info->queue_mapping[index_type][index_pri][index_dp].tc;

                rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_prio_set,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping egress queue
 *
 */
static int
_bcm_dnx_cosq_gport_egress_queue_map_get(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dnx_cosq_egress_queue_mapping_info_t mapping_info;
    DNX_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    DNX_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));
    DNX_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(offset);

    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Unicast type */
    map_type = DNX_TMC_EGR_UCAST_TO_SCHED;
    *offset = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * init egress port to a specific configuration (out_tc,out_dp)
 */
int
_bcm_dnx_cosq_gport_egress_map_init(int unit, bcm_port_t port)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port, nof_priorities;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_dnx_cosq_egress_queue_mapping_info_t mapping_info;
    int tc, dp, priority;

    BCMDNX_INIT_FUNC_DEFS;

    rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    sal_memset(&mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));

    /* Get Old data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    for(tc = 0; tc < DNX_DEVICE_COSQ_EGR_NOF_TC ; tc++)
    {
        /*select Q*/
        switch(nof_priorities) {
            case 1:
              priority = 0;
              break;
            case 2:
              priority = (tc<4 ? 0 : 1);
              break;
            case 8:
            default:
              priority = tc;
              break;
        }


        for (dp = 0; dp < DNX_DEVICE_COSQ_EGR_NOF_DP; dp++)
        {
            /* set unsched traffic mapping */
            mapping_info.queue_mapping[DNX_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[DNX_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].tc = priority;

            /* set sched traffic mapping*/
            mapping_info.queue_mapping[DNX_TMC_EGR_UCAST_TO_SCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[DNX_TMC_EGR_UCAST_TO_SCHED][tc][dp].tc = priority;
        }
    }

    /* Exchange data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_dnx_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;

}

/* 
 * Purpose:
 * Map egress queue to a specific priority (offset)
 */
static int
_bcm_dnx_cosq_gport_egress_queue_map_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_t ingress_pri,
                                           bcm_color_t ingress_dp,
                                           bcm_cos_queue_t offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    int is_last,is_allocated;
    int old_profile, new_profile;
    bcm_dnx_cosq_egress_queue_mapping_info_t mapping_info;
    DNX_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    uint32 tm_port;
    DNX_TMC_EGR_Q_PRIO tc;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (offset < 0 || offset >= DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid offset parameter %d"), offset));
    }

    /* Get Old data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - preserve dp, change new tc (offset) */
    /* Unicast type and Scheduled to Multicast */
    map_type = DNX_TMC_EGR_UCAST_TO_SCHED;

    rc =  _bcm_dnx_cosq_bcm_cosq_to_egr_q_prio(unit, offset, &tc);
    BCMDNX_IF_ERR_EXIT(rc);

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = tc;

    /* Exchange data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile,& is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_dnx_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
        }

    /* Map port to new profile */   
    rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress port to a specific multicast configuration (out_tc,out_dp)
 */
static int
_bcm_dnx_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_dnx_cosq_egress_queue_mapping_info_t mapping_info;
    DNX_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    int queue_id;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }
  
    if (!(flags == BCM_COSQ_MULTICAST_SCHEDULED)) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->scheduled_dp < 0 || config->scheduled_dp > DNX_DEVICE_COSQ_EGR_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid scheduled_dp parameter %d"), config->scheduled_dp));
    }

    rc = _bcm_dnx_egress_queue_from_cosq(unit, &queue_id, config->priority);
    BCMDNX_IF_ERR_EXIT(rc);

    if (queue_id < 0 || queue_id >= DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid config->priority parameter %d"), queue_id));
    }

    /* Get Old data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - change new tc, new dp (scheduled_tc,scheduled_dp) */
    /* Schedule Multicast type */
    map_type = DNX_TMC_EGR_MCAST_TO_UNSCHED;

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp = config->scheduled_dp;
    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = queue_id;

    /* Exchange data */
    rc = _bcm_dnx_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_dnx_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);     

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
static int
_bcm_dnx_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dnx_cosq_egress_queue_mapping_info_t mapping_info;
    DNX_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    DNX_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dnx_cosq_egress_queue_mapping_info_t));
    DNX_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (flags & BCM_COSQ_MULTICAST_UNSCHEDULED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Multicast type */
    map_type = DNX_TMC_EGR_MCAST_TO_UNSCHED;
    config->scheduled_dp = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp;
    config->priority = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress device to a specific multicast configuration (out_tc,out_dp)
 */
static int
_bcm_dnx_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 dnx_sand_rv;   
    DNX_TMC_EGR_QUEUING_MC_COS_MAP info;
    int core , core_iterator;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);
    BCM_DNX_UNIT_CHECK(unit);

    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags & BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->unscheduled_se < 0 || config->unscheduled_se > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_se parameter %d"), config->unscheduled_se));
    }

    if (config->unscheduled_sp < 0 || config->unscheduled_sp > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_sp parameter %d"), config->unscheduled_sp));
    }

    if (gport == 0)
    {
        core_iterator = 0;
    }
    else if (BCM_COSQ_GPORT_IS_CORE(gport))
    {
        core_iterator = BCM_COSQ_GPORT_CORE_GET(gport);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalide gport type %d"), gport));
    }
      
    BCM_DNX_CORES_ITER(core_iterator, core)
    {
        /* Get Old data */
        dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_cos_map_get,(unit, core, ingress_pri, ingress_dp, &info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);

    
        info.tc_group = config->priority;
        info.pool_eligibility = config->unscheduled_se;
        info.pool_id = config->unscheduled_sp;

        /* Set data */
        dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_cos_map_set,(unit, core, ingress_pri, ingress_dp, &info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
static int
_bcm_dnx_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 dnx_sand_rv;   
    DNX_TMC_EGR_QUEUING_MC_COS_MAP info;
    int core, core_iterator;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DNX_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DNX_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags == BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (gport == 0)
    {
        core_iterator = 0;
    }
    else if (BCM_COSQ_GPORT_IS_CORE(gport))
    {
        core_iterator = BCM_COSQ_GPORT_IS_CORE(gport);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalide gport type %d"), gport));
    }

    BCM_DNX_CORES_ITER(core_iterator, core)
    {

        /* Get Old data */
        dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_egr_queuing_mc_cos_map_get,(unit, core, ingress_pri, ingress_dp, &info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);

        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->priority = info.tc_group;
        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_se = info.pool_eligibility;
        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_sp = info.pool_id;
        BCM_EXIT;
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set tc packet to FMQ queue mapping
 * Valid when enhance is disable 
 */
static int
_bcm_dnx_cosq_fmq_mapping_set(int unit, 
                                     bcm_port_t port,
                                     bcm_cos_t priority, 
                                     bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_TR_CLS tc;
    DNX_TMC_MULT_FABRIC_CLS fabric_cls;
    uint32 dnx_sand_rv;   

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (priority < 0 || priority >= DNX_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
    }

    if (cosq < 0 || cosq > DNX_COSQ_FMQ_MAX_CLS_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
    }

    tc = priority;
    fabric_cls = cosq;

    dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_traffic_class_to_multicast_cls_map_set,(unit,tc,fabric_cls)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : retrieve FMQ queue mapping from packet TC.
 * Valid when enhance is disable 
 */
static int
_bcm_dnx_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    DNX_TMC_TR_CLS tc;
    DNX_TMC_MULT_FABRIC_CLS fabric_cls = 0;
    uint32 dnx_sand_rv;        

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (priority < 0 || priority >= DNX_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
    }

    tc = priority;
 
    dnx_sand_rv = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_traffic_class_to_multicast_cls_map_get,(unit,tc,&fabric_cls)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rv);

    *cosq = fabric_cls;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_e2e_hr_modify(int unit, bcm_gport_t port, int numq, uint32 flags, bcm_gport_t *gport, int is_composite, int is_dual, int hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    bcm_gport_t              port_gport;
    uint32                   fap_port;
    DNX_TMC_SCH_SE_ID        se_id;
    uint32                   dnx_sand_rc;    
    DNX_TMC_SCH_PORT_INFO    port_info;
    DNX_TMC_SCH_SE_INFO      se_info;
    DNX_TMC_SCH_FLOW         sch_flow, exact_sch_flow;
    int                      hr_class, old_profile, is_last, profile, is_allocated, flow_id, core;
    bcm_cos_queue_t          cosq;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_SCH_PORT_INFO_clear(&port_info);
    DNX_TMC_SCH_SE_INFO_clear(&se_info);
    DNX_TMC_SCH_FLOW_clear(unit,&sch_flow);
    DNX_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);


    if ( !( BCM_COSQ_GPORT_IS_E2E_PORT((*gport)) || BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport)) ||
            (BCM_COSQ_GPORT_IS_E2E_PORT_TC((*gport)) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport 0x%x, modify only supported for e2e ports"), unit, (*gport)));
    }

    if ( (is_composite) || (is_dual) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, is not supported for dual and composite, is_composite: %d, is_dual: %d"), unit,is_composite, is_dual));
    }

    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, (*gport), 0, &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);
    if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) ) {
         BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
    }

    /* Verify PORT-TC */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {
        rc = _bcm_dnx_cosq_port_priority_validate(unit,port_gport,numq);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* Verify numq */
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
        }
    }

    /* numq determine cosq index.
     * In case of E2E gport - numq = 0 (Petra-B compatbility).
     * In case of Port TC: numq = priority_ndx
     */
    cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) ? DNX_COSQ_PB_DEFAULT_PORT_TC:numq;

    if (BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport))) {
        {
            rc = _bcm_dnx_cosq_core_get(unit, *gport, 0, &core) ;
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                      "failed to get core for *gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)*gport, (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
            fap_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);
            rc = _bcm_dnx_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {          
            fap_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port_gport);
            rc = _bcm_dnx_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else {
            flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);
            se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
            if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        }

        /* configure scheduler element */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, se_id, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        se_info.type_info.hr.mode = hr_mode;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, se_id, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }
    else {
        rc = _bcm_dnx_cosq_fap_port_get(unit, port_gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, fap_port, port));
        }

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_get,(unit, core, fap_port, &port_info)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler info port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, fap_port, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
        if (SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.hr_modes[cosq] = hr_mode;
        } else {
            port_info.hr_mode = hr_mode;
        }

        /* Port-TC feature: no need to support HR flow control class. since for each HR there is respective flow control priority */
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.hr_fc_default_template_data.get(unit, &hr_class));
            port_info.lowest_hp_class = hr_class;

            /* set default flow control mapping. It is a default profile that is always allocated */
            rc = _bcm_dnx_am_template_cosq_port_hr_fc_exchange(unit, core, fap_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, fap_port, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_hr_mode_get(int unit, uint32 flags, int *hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    int                      hr_mode_mask;


    BCMDNX_INIT_FUNC_DEFS;

    hr_mode_mask = flags & DNX_DEVICE_COSQ_HR_MASK;
    switch (hr_mode_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ:
            (*hr_mode) = DNX_TMC_SCH_HR_MODE_DUAL_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED:
            (*hr_mode) = DNX_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ:
            (*hr_mode) = DNX_TMC_SCH_HR_MODE_SINGLE_WFQ;
            break;
        default:
            (*hr_mode) = DNX_TMC_SCH_HR_MODE_NONE;
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid hr mode flags parameter 0x%x\n"), unit, hr_mode_mask));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_hr_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   dnx_sand_rc;
    DNX_TMC_SCH_FLOW           flow_config, exact_flow_config;
    DNX_TMC_SCH_SE_INFO        se_config;
    DNX_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      hr_mode, core ;
    int                      flow_id = -1, comp_flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DNX_DEVICE_COSQ_HR_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    rc = _bcm_dnx_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* handle BCM_COSQ_GPORT_REPLACE - for e2e ports only */
    if (flags & BCM_COSQ_GPORT_REPLACE) {
        rc = _bcm_dnx_cosq_sched_e2e_hr_modify(unit, port, numq, flags, gport, is_composite, is_dual, hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    
    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
        if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
        }

        /* validate flow id */
        if (!JER2_ARAD_SCH_SE_IS_HR(se_index)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE-HR"), unit, flow_id));
        }
    }

    rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, res_flags, is_composite, FALSE, is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_dnx_se_composite_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_HR, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit %d, hr resource gport_add, flow_id (%d/0x%x) se_index(%d/0x%x\n"), 
                          unit, flow_id, flow_id, se_index, se_index));

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, is_composite(%s) is_dual(%s)\n"), unit, 
                            (is_composite==1) ? "TRUE":"FALSE",
                 (is_dual==1) ? "TRUE":"FALSE"));

    DNX_TMC_SCH_FLOW_clear(unit,&flow_config);

    flow_config.flow_type = DNX_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[0].credit_source.id)));

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, subflow 0 credit source se_type(%d) sp_class(%d) id(%d))\n"), unit,
                            flow_config.sub_flow[0].credit_source.se_type, flow_config.sub_flow[0].credit_source.se_info.hr.sp_class,
                 flow_config.sub_flow[0].credit_source.id));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    DNX_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = DNX_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = DNX_TMC_SCH_SE_TYPE_HR;
    se_config.type_info.hr.mode = hr_mode;
    se_config.is_dual = FALSE;
    se_config.group = DNX_TMC_SCH_GROUP_AUTO;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", dnx_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
       if(unit >=0 && unit < BCM_LOCAL_UNITS_MAX) {
            bcm_dnx_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, is_dual, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_cl_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual,
                         int is_cl_hr)
{
    bcm_error_t                      rc = BCM_E_NONE;
    uint32                           dnx_sand_rc;
    DNX_TMC_SCH_FLOW                     flow_config, exact_flow_config;
    DNX_TMC_SCH_SE_INFO                  se_config;
    DNX_TMC_SCH_SE_ID                    se_index, dual_se_index = 0;    
    int                              is_enhanced = FALSE, hr_mode;
    uint32                           relevant_flags, res_flags = 0, enhanced_mask;
    int                              flow_id = -1, comp_flow_id, dual_flow_id, flow_region;
    int                              cl_mode = 0, enhanced_mode = 0, weight_mode = 0, cid;
    bcm_dnx_cosq_sched_class_data_t  class_data;
    int                              class_flags = BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID;
    int                              is_allocated, class_template;
    int                              is_odd_even;
    uint8                            is_interdigitated;
    int                              core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & ( (BCM_COSQ_GPORT_SCHEDULER | DNX_DEVICE_COSQ_CL_MASK | BCM_COSQ_GPORT_COMPOSITE |
        DNX_DEVICE_COSQ_CL_ENHANCED_MASK | DNX_DEVICE_COSQ_DUAL_SHAPER_MASK |
        DNX_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_WITH_ID) | (DNX_DEVICE_COSQ_FQ_MASK) | (DNX_DEVICE_COSQ_HR_MASK) );

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    enhanced_mask = flags & DNX_DEVICE_COSQ_CL_ENHANCED_MASK;
    switch (enhanced_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            is_enhanced = TRUE;
            break; 
        default:
            is_enhanced = FALSE;
            break; 
    }

    if ( (is_enhanced == TRUE) && ( (is_composite == TRUE) || (is_dual == TRUE) ) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Enhanced cl configuration and composite/dual can not be together specified"), unit));
    }

    /* consistency checks */
    rc = _bcm_dnx_cosq_sched_cl_verify_flags_mode_get(unit, flags, &cl_mode, &enhanced_mode, &weight_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cl element flags not correct, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (is_cl_hr) {
        rc = _bcm_dnx_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit, mbcm_dnx_sch_flow2se_id, (unit, flow_id))); 
        if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }
        /* validate flow id */
        /* The macro JER2_ARAD_SCH_SE_IS_CL may be used for signed varibles also */
        /* coverity[unsigned_compare : FALSE] */
        if (!JER2_ARAD_SCH_SE_IS_CL(se_index)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE-CL\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }
    }

    if (is_cl_hr) {
        rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, res_flags, is_composite, FALSE, is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    else {
        /* allocate flow */
        rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, DNX_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_CL, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (is_composite) {
        flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(flow_id);
        rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector region configuration get, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rc = _bcm_dnx_se_composite_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_CL, is_odd_even, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    if (is_dual) {
        rc = _bcm_dnx_se_dual_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting dual flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* get cid */
    rc = _bcm_dnx_sched_cl_profile_get(unit, cl_mode, enhanced_mode, weight_mode, TRUE, &cid);
    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* initialize se */
    se_index =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
    if (is_dual) {
        dual_se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, dual_flow_id)));
    }

    DNX_TMC_SCH_FLOW_clear(unit, &flow_config);

    flow_config.flow_type = DNX_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[0].credit_source.id)));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    DNX_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = DNX_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = DNX_TMC_SCH_SE_TYPE_CL;
    se_config.type_info.cl.id = cid;
    se_config.is_dual = is_dual;
    se_config.group = DNX_TMC_SCH_GROUP_AUTO;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, se_index, "cl", dnx_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);

    /* Update reference count */
    /* retrieve current template data */
    rc = _bcm_dnx_am_template_cosq_sched_class_data_get(unit, core, cid, (int *)&class_data);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving SE(%d) class data cid(%d), error 0x%x\n"), unit, se_index, cid, rc));
        goto err;
    }

    class_template = cid;
    rc = _bcm_dnx_am_template_cosq_sched_class_allocate(unit, core, class_flags, (int *)&class_data, &is_allocated, &class_template);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in incrementing reference count for class template cid(%d), error 0x%x\n"), unit, cid, rc));
        goto err;
    }

    if (is_dual) {
        flow_config.sub_flow[0].id = dual_flow_id;

        se_config.id = dual_se_index;
        se_config.state = DNX_TMC_SCH_SE_STATE_ENABLE;
        if (is_cl_hr) {
            se_config.type = DNX_TMC_SCH_SE_TYPE_HR;
            se_config.type_info.hr.mode = hr_mode;
        }
        else {
            se_config.type = DNX_TMC_SCH_SE_TYPE_FQ;
            se_config.type_info.fq.no_info = 0;
        }
        se_config.is_dual = is_dual;
        se_config.group = DNX_TMC_SCH_GROUP_AUTO;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, dual_se_index, &se_config, &flow_config, &exact_flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", dnx_sand_rc, rc));
            goto err;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dnx_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_CL, flow_id);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_fq_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   dnx_sand_rc;
    DNX_TMC_SCH_FLOW           flow_config, exact_flow_config;
    DNX_TMC_SCH_SE_INFO        se_config;
    DNX_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      flow_id = -1, comp_flow_id, core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DNX_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
        if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }

        /* validate flow id */
        if (!JER2_ARAD_SCH_SE_IS_FQ(se_index)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE-FQ\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }

    }

    /* allocate flow */
    rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, DNX_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_flags, is_composite, FALSE, is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, fq se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_dnx_se_composite_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_FQ, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, fq se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));

    DNX_TMC_SCH_FLOW_clear(unit, &flow_config);

    flow_config.flow_type = DNX_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[0].credit_source.id)));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    DNX_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = DNX_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = DNX_TMC_SCH_SE_TYPE_FQ;
    se_config.type_info.fq.no_info = 0;
    se_config.is_dual = FALSE; /* Always set with CL element */
    se_config.group = DNX_TMC_SCH_GROUP_AUTO;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", dnx_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dnx_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, is_dual, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_FQ, flow_id);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t                 rc = BCM_E_NONE;
    uint32                      resource_count = 0;
    int                         is_hr = FALSE, is_cl = FALSE, is_fq = FALSE, is_cl_fq = FALSE, is_cl_hr = FALSE;
    uint32                      relevant_flags, fap_port;
    int                         shaper_mask;
    int                         is_composite, is_dual = FALSE;
    int                         flow_id = 0, sf2_id = 0, se_index, core;
    DNX_TMC_SCH_SE_ID           se_id;
    int                         dual_flow_id, dual_se_index;
    bcm_gport_t                 alternate_gport;
    bcm_cos_queue_t             cosq = 0;
    int                         is_reserved;
    int                         sched_id = 0;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_dnx_cosq_core_get(unit, port, 0, &core) ;
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
                "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* basic consistency checks */

    if (gport == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error gport is NULL"), unit));
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DNX_DEVICE_COSQ_HR_MASK | DNX_DEVICE_COSQ_CL_MASK | DNX_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | DNX_DEVICE_COSQ_CL_ENHANCED_MASK | DNX_DEVICE_COSQ_DUAL_SHAPER_MASK | DNX_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if (flags & DNX_DEVICE_COSQ_CL_MASK) {
        is_cl = TRUE;
        resource_count++;
    }
    if (flags & DNX_DEVICE_COSQ_FQ_MASK) {
        is_fq = TRUE;
        resource_count++;
    }
    if (flags & DNX_DEVICE_COSQ_HR_MASK) {
        is_hr = TRUE;
        resource_count++;
    }
    if ((resource_count == 2) && (is_cl == TRUE) && (is_fq == TRUE)) {
        is_cl_fq = TRUE;
        resource_count--; /* consider it one resource of a cl_fq type */
    }
    else if ((resource_count == 2) && (is_cl == TRUE) && (is_hr == TRUE)) {
        is_cl_hr = TRUE;
        resource_count--; /* consider it one resource of a cl_hr type */
    }

    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"), unit, flags, resource_count));
    }
                 
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
    shaper_mask = relevant_flags & DNX_DEVICE_COSQ_DUAL_SHAPER_MASK;
    if (shaper_mask) {
        switch (shaper_mask) {
            case BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER:
                is_dual = TRUE;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Shaper flags 0x%x\n"), unit, shaper_mask));
                break;
        }
    }

    if ( (is_dual) && (is_cl == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, dual Shaper configuration requires specifing a CL scheduler element\n"), unit));
    }

    /* if cl and fq were both specified make sure that dual shaper is specified */
    if ( (is_cl_fq) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and FQ scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    /* if cl and hr were both specified make sure that dual shaper is specified */
    /* In order to support {cl, hr} configuration it is necessary to specify    */
    /* {sched, cl, hr, dual} flags. This s unlike {cl, fq} configuration where  */
    /* {fq} flag need not be specified. Thus fq is assumed to be default mode   */
    /* for dual configuration and fq scheduler does not require any additional  */
    /* qualifier.                                                               */
    if ( (is_cl_hr) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and HR scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    if ( (is_composite == TRUE) && (is_dual == TRUE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, composite and dual Shaper configuration cannot be specified at same time\n"), unit));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        if (!(BCM_GPORT_IS_SCHEDULER(*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified \n"), unit, (*gport)));
        }

    }
    /* Verify numq for other scheduler elements other than HRs */
    if ((is_cl_fq) || (is_cl) || (is_fq) || (is_cl_hr)) {
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d\n"), unit, flags));
        }
    }

    if ((is_cl_fq) || (is_cl) || (is_cl_hr)) {
        rc = _bcm_dnx_cosq_sched_cl_add(unit, port, numq, flags, gport, is_composite, is_dual, is_cl_hr);
    }
    else if (is_fq) {
        rc = _bcm_dnx_cosq_sched_fq_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else if (is_hr) {
        rc = _bcm_dnx_cosq_sched_hr_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else {
        rc = BCM_E_PARAM;
    }

    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* allocate resource for flow */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, (*gport), 0, &alternate_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (BCM_GPORT_IS_SCHEDULER(alternate_gport)) {
        flow_id = BCM_GPORT_SCHEDULER_GET(alternate_gport);
        if (SOC_IS_QAX(unit)) {
            /*
             * If sched_id > max_flows it means that it is a fmq_class,
             * so no need to add offset to flow_id, because flow_id already
             * comes with the offset.
             */
            sched_id = BCM_GPORT_SCHEDULER_GET(*gport);
            if (sched_id < DNX_COSQ_SCH_MAX_FLOW_ID(unit)) {
                flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id);
            }
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport) ||
             (BCM_COSQ_GPORT_IS_E2E_PORT_TC(alternate_gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable)) {

        /* numq determine cosq index.
         * In case of E2E gport - numq = 1 (Petra-B compatbility) => cosq = 0.
         * In case of Port TC: cosq = numq 
         */
        cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport)) ? DNX_COSQ_PB_DEFAULT_PORT_TC:numq;

        rc = _bcm_dnx_cosq_fap_port_get(unit, alternate_gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), alternate_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* verify priority */
        if (BCM_COSQ_GPORT_IS_PORT_TC(alternate_gport) && SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
            rc = _bcm_dnx_cosq_port_priority_validate(unit,alternate_gport,cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify failed for gport: 0x%x, cosq %d error(0x%x)\n"), alternate_gport, cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
       
        rc = _bcm_dnx_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);
        if (rc != BCM_E_NONE || se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, fap_port));
        }

        flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
        /*
         * If this is a 'replace' operation then delete flow id from data base (if
         * it is there).
         */
        if (flags & BCM_COSQ_GPORT_REPLACE) {
            bcm_dnx_vig_delete_this_flow(unit, core, Vig_db[unit], flow_id) ;
        }
    }
/* } */
#endif

    se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
    if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
    }

    rc = _bcm_dnx_cosq_is_se_reserved(unit,core,se_index,&is_reserved);
    if (rc != BCM_E_NONE){
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get reserved se: 0x%x, error(0x%x)\n"), se_index, rc));
         goto err;
    }

    if (!(flags & BCM_COSQ_GPORT_REPLACE ) || (!is_reserved)) { /* Allocate SW DB in case of REPLACE is unset (allocate new SE) or SE is not a reserved SE. */
        /* initialize SE state */

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));

        /* need to take care of dual shaper allocation case */
        if (is_dual) {
            rc = _bcm_dnx_se_dual_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &dual_flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
                /*
                 * If this is a 'replace' operation then delete flow id from data base (if
                 * it is there).
                 */
                if (flags & BCM_COSQ_GPORT_REPLACE) {
                    bcm_dnx_vig_delete_this_flow(unit, core, Vig_db[unit], dual_flow_id) ;
                }
            }
/* } */
#endif
            dual_se_index = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, dual_flow_id)));
            if (dual_se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, dual_flow_id));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, dual_se_index, DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));

        }

        /* initialize coresponding flow state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));


        /* allocate resource for sub-flow 2 */
        if ( (is_composite) || (is_dual) ) {
            if (is_composite) {
                rc = _bcm_dnx_se_composite_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }
            if (is_dual) {
                rc = _bcm_dnx_se_dual_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }


            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, sf2_id));
                goto err;
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, sf2_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, sf2_id, BCM_COSQ_SP0));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_connector_gport_add(int unit,
                                    int core,
                                    int src_modid,
                                    uint32 nof_remote_cores,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    uint32 relevant_flags;
    int is_non_contiguous;
    int is_composite;
    int flow_id = -1;
    int res_flags = 0;
    int cur_flow_id, cur_connector, cur_comp_flow_id, flow_id_i;   
    DNX_TMC_SCH_FLOW flow_config, exact_flow_config;
    bcm_gport_t ingr_port;
    uint8 src_modid_uint8[sizeof(int)];
    uint32 byte_data;
    int i;
    uint8 flow_cleanup = 0, connector_cleanup = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (core == -1)
    {
        rc = _bcm_dnx_cosq_core_get(unit, *gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_VOQ_CONNECTOR | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((numq < 0) || (numq > DNX_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if ((numq % DNX_DEVICE_COSQ_COS_ALLOC_SZ) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number cos levels (%d) should be multiplier of %d"), unit, numq, DNX_DEVICE_COSQ_COS_ALLOC_SZ));
    }

    is_non_contiguous = (relevant_flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;

        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR((*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified "), unit, (*gport)));
        }

        flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET((*gport));
        if (SOC_IS_QAX(unit)) { /*HW limits flow ids to upper 64k for JER2_QAX (32k for QUX)*/
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id); 
        }
        rc = _bcm_dnx_cosq_validate_connector_id(unit, is_non_contiguous, is_composite, numq, flow_id); 
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector id %d"), unit, flow_id));
        }
    }

    /* Get modid of source */
    if (src_modid == -1) {
        if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
            rc = bcm_dnx_stk_sysport_gport_get(unit, port, &ingr_port);
            
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for connector cannot be performed"), unit, port));
            }
            /* get system port to mod/port mapping */
            src_modid = BCM_GPORT_MODPORT_MODID_GET(ingr_port);
        } else if (BCM_GPORT_IS_MODPORT(port)) {
            src_modid = BCM_GPORT_MODPORT_MODID_GET(port);
        } else if (BCM_GPORT_IS_LOCAL(port)) {
            int modid;
            /* Get my modid since it is local */
            rc = bcm_dnx_stk_my_modid_get(unit, &modid);
            src_modid = (uint8)modid;
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("my modid wasnt set correctly")));
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) ingress port parameter not initialized"), unit));
        }
    }

    /* cast from int to uint8[sizeof(int)] */
    for (i=0; i < sizeof(int); i++) {
        SHR_BITCOPY_RANGE(&byte_data, 0 , (uint32*)&src_modid, i*8 , 8);
        src_modid_uint8[i] = byte_data & 0xFF;
    }

    
    /* allocate resource */
    rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, nof_remote_cores, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, DNX_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, src_modid_uint8, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, connector resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }    

    /* configure resources */
    for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
        _bcm_dnx_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);

        DNX_TMC_SCH_FLOW_clear(unit, &flow_config);

        flow_config.flow_type = DNX_TMC_FLOW_SIMPLE;
        flow_config.is_slow_enabled = FALSE;

        flow_config.sub_flow[0].is_valid = TRUE;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[0].credit_source.id)));

        if (is_composite) {
            rc = _bcm_dnx_composite_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
           
            flow_config.sub_flow[1].is_valid = TRUE;

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
        }
        
        /* set all symmetric connections */
        for (i = 0; i < nof_remote_cores; i++) {
            flow_id_i = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_flow_id, nof_remote_cores, i);
            flow_config.sub_flow[0].id = flow_id_i;
            if (is_composite) {
                flow_config.sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_comp_flow_id, nof_remote_cores, i);
            }

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id_i, &flow_config, &exact_flow_config)));
            if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, dnx_sand error 0x%x, error 0x%x\n"), unit, flow_id_i, dnx_sand_rc, rc));
                goto err;
            }
        }

        /* set flow weight and mode */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, cur_flow_id, 0));
        flow_cleanup = 1;
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, cur_flow_id, BCM_COSQ_SP0));

        if (is_composite) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, cur_comp_flow_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, cur_comp_flow_id, BCM_COSQ_SP0));
        }
    }

    /* data structure for connector group */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.set(unit, core, flow_id, numq));
    connector_cleanup = 1;
#ifdef BCM_DNX_COSQ_CONN_NO_MODID_OPTIMIZATION
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.src_modid.set(unit, core, flow_id, src_modid));
#endif /* BCM_DNX_COSQ_CONN_NO_MODID_OPTIMIZATION */

    /* update handle */
    if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET((*gport), flow_id, core); 

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Connector Gport(%d:0x%x)\n"), (*gport), (*gport)));


    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    if (flow_id != -1) {
        bcm_dnx_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, DNX_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, flow_id);

        if (connector_cleanup) {
           bcm_dnx_cosq_connector_config_t zero = {0};
           BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, flow_id, &zero));
        }

        if (flow_cleanup) {
            bcm_dnx_cosq_connector_config_t zero = {0};
            for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
                _bcm_dnx_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite,FALSE, &cur_flow_id);
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_flow_id, &zero));
                if (is_composite) {
                    rc = _bcm_dnx_composite_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_comp_flow_id, &zero));
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int 
bcm_dnx_cosq_ingress_queue_bundle_gport_add(int unit, 
                                              bcm_cosq_ingress_queue_bundle_gport_config_t *config, 
                                              bcm_gport_t *gport)
{

    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Null config pointer")));
    }
    if (config->flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP || config->flags & BCM_COSQ_GPORT_ISQ) {
        rc = _bcm_dnx_cosq_ucast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (config->flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        rc = _bcm_dnx_cosq_mcast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Ingress queues add bundle not support for flags(0x%x)"), unit, config->flags));
    }
exit:
    BCMDNX_FUNC_RETURN;
    
}
/*
 * Get the system port destination according to different destination types, 
 * If the destination is in a different TM domain in a stacking configuration than stk_exist == 1, and base queue should be mapped to it. 
 */ 
static int
_bcm_dnx_cosq_ingress_queue_get_sysport_destination(
   int unit, 
   int core,
   uint8 is_ucast,
   uint8 is_flow,
   bcm_gport_t port, 
   int *sysport,
   int *stk_exist)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t sysport_gport = 0xffffffff; /* Assigning all 1s, in case we accidently access it without assigning real value */
    bcm_gport_t port_gport;
    int         tmp_port;
    BCMDNX_INIT_FUNC_DEFS;

   /* When recieve ISQ Class HR , return port accordingly */
    if (is_ucast)
    {
        if (BCM_COSQ_GPORT_IS_ISQ_ROOT(port)) {
           rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, port, 0, &port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if (!(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                rc = bcm_dnx_cosq_resource_gport_port_get(unit, port, &tmp_port);
                if (rc != BCM_E_NONE || tmp_port == DNX_COSQ_SCH_PORT_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }
    }
    else /*(!is_ucast)*/
    {
        /* When recieve FMQ Class HR , return port accordingly */
        if (BCM_COSQ_GPORT_IS_FMQ_CLASS(port)) {
           rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, port, 0, &port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                rc = bcm_dnx_cosq_resource_gport_port_get(unit, port, &tmp_port);
                if (rc != BCM_E_NONE || tmp_port == DNX_COSQ_SCH_PORT_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }    
    }
    /* retrieve system port from port */
    if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
        sysport_gport = port;
    } else {
        rc = bcm_dnx_stk_gport_sysport_get(unit, port, &sysport_gport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for unicast queue group cannot be performed"), unit, port));
        }
    }    
    /* get system port to mod/port mapping */
    *sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, *sysport));
    /* Handle stacking sysport, removed: || (BCM_COSQ_GPORT_WITH_ID & flags) */
    if (!(is_flow) && is_ucast) {
        rc = _bcm_dnx_cosq_stk_sysport_set(unit, core, sysport_gport, stk_exist);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("Unit(%d) sysport(0x%08x) Fail to handle Stacking (%d)"), unit, *sysport, rc));
        }
    } else {
        *stk_exist = 0;
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * This function is used updates the rate classes ref_count, and tail drop reservation.
 * The input struct bcm_dnx_cosq_queue_attributes_verify_t is used too:
 * 1. Update the reference count for rate classes.
 * 2. Updating tail drop reservation. 
 * 3. Update delay tolerence level ref count in case of deletion. 
 */
static int
_bcm_dnx_cosq_ingress_queue_bundle_ref_count_update(
   int unit,
   int core_id,
   uint8 is_add,
   bcm_dnx_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    uint32    
        ref_count;
    uint8 
        queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int 
        index, 
        is_allocated;
    bcm_dnx_cosq_ingress_rate_class_info_t 
        data_rate_cls;
    DNX_TMC_ITM_QT_NDX
        user_q_type;
    int
        hw_q_type;
    int 
        core_index;
    int32 
        reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES],
        ocb_reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int thresh_type;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(reservation_change, 0, sizeof(reservation_change));
    sal_memset(reservation_change, 0, sizeof(ocb_reservation_change));

    BCM_DNX_CORES_ITER(core_id, core_index) {
        /*Update delay tolerence level in case of deletion*/
        if (SOC_IS_JERICHO(unit)) {
            if (!is_add) {
                for (index = 0; index < queue_attributes_verify[core_index].nof_delay_tolerance; index++) {
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, queue_attributes_verify[core_index].queue_attributes[index].delay_tolerance_level, &user_q_type));
                    DNX_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.q_type_ref_count.get(unit, hw_q_type, &ref_count));
                    ref_count += queue_attributes_verify[core_index].delay_tolerance_nof_additions[index];
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.q_type_ref_count.set(unit, hw_q_type, ref_count));
                }
            }
        }
        /*Update rate class mapping*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
        for (index = 0; index < queue_attributes_verify[core_index].nof_rate_class; index++) {
            if (!is_add) {
                BCMDNX_IF_ERR_EXIT(jer2_arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_exchange(
                   unit,
                   core_index, 
                   FALSE, 
                   DNX_TMC_ITM_NOF_RATE_CLASSES, 
                   queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                   queue_attributes_verify[core_index].nof_dram_mixed_queues_per_rate_class[index]));

                if (!SOC_IS_QAX(unit)) {
                        /* ocb_only should not be called on JER2_QAX */
                        BCMDNX_IF_ERR_EXIT(jer2_arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_exchange(
                                                   unit,
                                                   core_index, 
                                                   TRUE, 
                                                   DNX_TMC_ITM_NOF_RATE_CLASSES, 
                                                   queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                                                   queue_attributes_verify[core_index].nof_ocb_only_queues_per_rate_class[index]));
                }
            }
            if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
                sal_memset(&data_rate_cls, 0x0,sizeof(bcm_dnx_cosq_ingress_rate_class_info_t));
                BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_queue_rate_cls_ref_get(unit, 
                                                                               queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                                                                               &ref_count));
                if (ref_count == 0) {
                    /*If ref_count == 0 - retrive configuration from HW*/
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_voq_rate_class_hw_get(unit, 
                                                                             queue_attributes_verify[core_index].queue_attributes[index].rate_class,
                                                                             &data_rate_cls));
                } else {
                    /*If ref_count == 0 - retrive configuration from allocation manager*/
                    BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_queue_rate_cls_tdata_get(unit, 
                                                                                     queue_attributes_verify[core_index].queue_attributes[index].rate_class,
                                                                                     &data_rate_cls));
                }
                BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_queue_rate_cls_allocate_group(unit, 
                                                                                      BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID, 
                                                                                      &data_rate_cls, 
                                                                                      queue_attributes_verify[core_index].rate_class_nof_additions[index],
                                                                                      &is_allocated, 
                                                                                      (int*)&(queue_attributes_verify[core_index].queue_attributes[index].rate_class)));
            }
        }
        if (!SOC_IS_QAX(unit)) {
            /* ocb_only is not relevant for JER2_QAX and above */
            ocb_reservation_change[core_index][0] = queue_attributes_verify[core_index].ocb_reservation_change;
        }
    }

    for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        BCM_DNX_CORES_ITER(core_id, core_index) {
            reservation_change[core_index][thresh_type] = queue_attributes_verify[core_index].reservation_change[thresh_type];
        }
    }
    /* update tail drop reservation */
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core_id, FALSE, reservation_change))); 
    if (!SOC_IS_QAX(unit)) {
        /* ocb_only is not relevant for JER2_QAX and above */
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dyn_total_thresh_set,(unit, core_id, TRUE, ocb_reservation_change))); 
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * This function is used for:
 * 1. Verifing that a created/deleted queue bundle's attribues are valid. 
 * 1.1. Credit request profiles and rate classes are in valid range. 
 * 1.2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 1.2. Updating the reference count for both of them will not result out of range values. 
 * 2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 3. Calculation and verifying the validity of tail drop reservation update.
 */
static int 
_bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify(
   int unit, 
   int core_id,
   int base_queue,
   uint8 is_add,
   bcm_cosq_ingress_queue_bundle_gport_config_t *config,
   bcm_dnx_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32      credit_request_profile_nof_additions_mapping[SOC_DNX_DEFS_MAX(NOF_CREDIT_REQUEST_PROFILES)];
    uint32      rate_class_nof_additions_mapping[DNX_TMC_ITM_NOF_RATE_CLASSES];
    uint32      ref_count;
    int         cosq = 0;

    DNX_TMC_ITM_QT_NDX user_q_type;
    int hw_q_type;
    /* Need to use it as pointer in order to aviod stack use coverity defect */
    bcm_dnx_cosq_ingress_rate_class_info_t *rate_class_info_dummy = NULL;
    bcm_dnx_cosq_ingress_rate_class_info_t rate_class_info;
    bcm_dnx_cosq_ingress_rate_class_info_t rate_class_info_sum;
    bcm_dnx_cosq_ingress_rate_class_info_t rate_class_info_ocb_sum;
    int32 reservation_change[SOC_DNX_DEFS_MAX(NOF_CORES)][DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    uint8 is_ocb_only;
    int core;
    int         addition = is_add ? 1 : -1;
    uint8       queue_to_rate_class_mapping_is_simple = JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int thresh_type;


    /*verify rate classes*/
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(queue_attributes_verify, 0, SOC_DNX_DEFS_MAX(NOF_CORES) * sizeof(bcm_dnx_cosq_queue_attributes_verify_t));
    BCMDNX_ALLOC(rate_class_info_dummy, sizeof(*rate_class_info_dummy), "_bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify.rate_class_info_dummy");
    if(rate_class_info_dummy == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("Memory allocation failue\n")));
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    BCM_DNX_CORES_ITER(core_id, core) {
        int         nof_rate_class = 0;
        int         rate_class = 0;
        int         rate_class_nof_additions = 0;
        int         nof_ocb_only_queues_per_rate_class = 0;
        int         nof_dram_mixed_queues_per_rate_class = 0;

        int         nof_credit_request_profile = 0;
        int         credit_request_profile = 0;
        int         credit_request_profile_nof_additions = 0;

        int         numq = config->numq;

        sal_memset(&rate_class_nof_additions_mapping, 0xff, sizeof(rate_class_nof_additions_mapping));
        sal_memset(&credit_request_profile_nof_additions_mapping, 0xff, sizeof(credit_request_profile_nof_additions_mapping));

        sal_memset(rate_class_info_dummy, 0, sizeof(*rate_class_info_dummy));
        sal_memset(&rate_class_info, 0, sizeof(rate_class_info));
        sal_memset(&rate_class_info_sum, 0, sizeof(rate_class_info_sum));
        sal_memset(&rate_class_info_ocb_sum, 0, sizeof(rate_class_info_ocb_sum));
        
        /*verify credit request profiles*/
        if (!is_add) {
            for (cosq = 0; cosq < config->numq; cosq++){
                int weight;
                bcm_gport_t gport;
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, base_queue);
                rc = _bcm_dnx_cosq_gport_ucast_queue_sched_get(unit, gport, cosq, &(config->queue_atrributes[cosq].delay_tolerance_level) ,&weight);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        for (credit_request_profile = config->queue_atrributes[0].delay_tolerance_level, nof_credit_request_profile = 0, cosq = 0;
             cosq <= numq;
             cosq++, credit_request_profile_nof_additions += addition) {
            if (cosq != numq && credit_request_profile == config->queue_atrributes[cosq].delay_tolerance_level) {
                continue;
            }
            /*Verify the delay tolerance level validity*/
            if (!((credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_15) ||
                  (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
                  (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_16 && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_23))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The delay tolerance level %d is not legal."),unit, credit_request_profile)); 
            }
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
            DNX_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

            /*Verify the HW q type translated form the delay tolerance level*/
            if (!(0 <= hw_q_type && hw_q_type < SOC_DNX_DEFS_GET(unit, nof_credit_request_profiles))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The credit request profile %d is not legal."),unit, credit_request_profile)); 
            }
            /* 
             * If we didn't see this profile before (credit_request_profile_nof_additions_mapping[credit_request_profile] == 0xffffffff) 
             * Then update the credit_request_profile_nof_additions_mapping array and increas the nof_credit_request_profile counter.
             */
            if (credit_request_profile_nof_additions_mapping[hw_q_type] == 0xffffffff) {
                credit_request_profile_nof_additions_mapping[hw_q_type] = nof_credit_request_profile;
                queue_attributes_verify[core].queue_attributes[credit_request_profile_nof_additions_mapping[hw_q_type]].delay_tolerance_level = credit_request_profile;
                nof_credit_request_profile++;
            }
            queue_attributes_verify[core].delay_tolerance_nof_additions[credit_request_profile_nof_additions_mapping[hw_q_type]] += credit_request_profile_nof_additions;
            credit_request_profile_nof_additions = 0;
            credit_request_profile = config->queue_atrributes[cosq].delay_tolerance_level;
        }
        queue_attributes_verify[core].nof_delay_tolerance = nof_credit_request_profile;

        /*if jer2_jericho verify that the expected ref count is legel.*/
        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
            for (cosq = 0; cosq < queue_attributes_verify[core].nof_rate_class; cosq++) {
                credit_request_profile = queue_attributes_verify[core].queue_attributes[cosq].delay_tolerance_level;
                credit_request_profile_nof_additions = queue_attributes_verify[core].delay_tolerance_nof_additions[cosq];

                BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
                DNX_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.soc.jer2_arad.tm.q_type_ref_count.get(unit, hw_q_type, &ref_count));
                ref_count += credit_request_profile_nof_additions;
                if (ref_count > SOC_DNX_DEFS_GET(unit, nof_queues))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the credit request profile %d, the ref_count %d is out of range."),unit, credit_request_profile, ref_count));
                }
            }
        }

        if (!is_add) {
            for (cosq = 0; cosq < config->numq; cosq++){
                 rc = _bcm_dnx_cosq_voq_class_mapping_get(unit, core, base_queue + cosq, BCM_DNX_COSQ_RATE_CLS, &(config->queue_atrributes[cosq].rate_class));
                 BCMDNX_IF_ERR_EXIT(rc);
            }
        } 
        for (rate_class = config->queue_atrributes[0].rate_class, nof_rate_class = 0, cosq = 0, is_ocb_only = FALSE;
             cosq <= numq;
             cosq++, 
             rate_class_nof_additions += addition,
             nof_ocb_only_queues_per_rate_class += is_ocb_only ? addition : 0,
             nof_dram_mixed_queues_per_rate_class += is_ocb_only ? 0 :addition) {
            if (!SOC_IS_ARADPLUS_AND_BELOW(unit) && !SOC_IS_QAX(unit)) {
                rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_queue_is_ocb_only_get, (unit, core, base_queue + cosq, &is_ocb_only)); 
                BCMDNX_IF_ERR_EXIT(rc);
            }
            if (cosq != numq && rate_class == config->queue_atrributes[cosq].rate_class) {
                continue;
            }
            /* 
             * If we didn't see this rate class before (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) 
             * Then update the rate_class_nof_additions_mapping array and increas the nof_rate_class counter.
             */
            if (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) {
                rate_class_nof_additions_mapping[rate_class] = nof_rate_class;
                queue_attributes_verify[core].queue_attributes[rate_class_nof_additions_mapping[rate_class]].rate_class = rate_class;
                nof_rate_class++;
            }
            queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[rate_class_nof_additions_mapping[rate_class]]+= nof_ocb_only_queues_per_rate_class;
            queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[rate_class_nof_additions_mapping[rate_class]]+= nof_dram_mixed_queues_per_rate_class;
            queue_attributes_verify[core].rate_class_nof_additions[rate_class_nof_additions_mapping[rate_class]] += rate_class_nof_additions;
            nof_ocb_only_queues_per_rate_class = 0;
            nof_dram_mixed_queues_per_rate_class = 0;
            rate_class_nof_additions = 0;
            rate_class = config->queue_atrributes[cosq].rate_class;
        }
        queue_attributes_verify[core].nof_rate_class = nof_rate_class;

        /*verify rate class attributes*/
        for (cosq = 0; cosq < queue_attributes_verify[core].nof_rate_class; cosq++) {
            rate_class = queue_attributes_verify[core].queue_attributes[cosq].rate_class;
            if(rate_class < 0 || rate_class > DNX_TMC_ITM_RATE_CLASS_MAX) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
            }

            rate_class_nof_additions = queue_attributes_verify[core].rate_class_nof_additions[cosq];
            if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
                BCMDNX_IF_ERR_EXIT(_bcm_dnx_am_template_queue_rate_cls_ref_get(unit, rate_class, &ref_count));
                /* 
                 * We cannot allcoate new rate class on creation of a queue. 
                 * The only exeption is rate class 0, which is the default rate class. 
                 */
                if (is_add && ref_count == 0 && rate_class != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to rate class %d, since it is not configured."),unit, rate_class)); 
                }
                if (ref_count == 0) {
                    /*If rate ref_count == 0 init rate class*/
                    rc = _bcm_dnx_cosq_voq_rate_class_default_set(unit, rate_class, &rate_class_info);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    rc = _bcm_dnx_am_template_queue_rate_cls_tdata_get(unit, rate_class, &rate_class_info); 
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                ref_count += rate_class_nof_additions;
                if (ref_count > (SOC_DNX_DEFS_GET(unit, nof_queues) * SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
                }           
            } else {
                BCMDNX_IF_ERR_EXIT(jer2_arad_sw_db_rate_class_ref_count_get(unit, core, 2, (uint32)rate_class, &ref_count));
                ref_count += rate_class_nof_additions;
                if (ref_count > SOC_DNX_DEFS_GET(unit, nof_queues)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
                }
                if (queue_to_rate_class_mapping_is_simple == JER2_ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED && 
                    is_add && 
                    rate_class != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to a rate class %d != 0, when the queue-to-rate class made is undefined."), unit, rate_class)); 
                }
                rc = _bcm_dnx_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, queue_attributes_verify[core].queue_attributes[cosq].delay_tolerance_level, &user_q_type));
            DNX_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

            if (!SOC_IS_QAX(unit))
            { 
                /* the following code is not relevant for JER2_QAX and later */
                /* ocb only */
                rate_class_info_ocb_sum.queue_quaranteed_size[DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES] += queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[cosq] * rate_class_info.queue_quaranteed_size[DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                rate_class_info_ocb_sum.queue_min_size_bds += queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[cosq] * rate_class_info.queue_min_size_bds;

                rc = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, TRUE, rate_class_info_dummy, &rate_class_info_ocb_sum, 1, reservation_change);
                BCMDNX_IF_ERR_EXIT(rc);
                queue_attributes_verify[core].ocb_reservation_change += reservation_change[core][DNX_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];

                /* bds threshold */
                rate_class_info_sum.queue_min_size_bds += queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[cosq] * rate_class_info.queue_min_size_bds;

            }

            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                rate_class_info_sum.queue_quaranteed_size[thresh_type] += queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[cosq] * rate_class_info.queue_quaranteed_size[thresh_type];
            }

            rc = _bcm_dnx_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, FALSE, rate_class_info_dummy, &rate_class_info_sum, 1, reservation_change);
            BCMDNX_IF_ERR_EXIT(rc);
            for (thresh_type = 0; thresh_type < DNX_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                queue_attributes_verify[core].reservation_change[thresh_type] += reservation_change[core][thresh_type];
            }
        }
    }

exit:
    BCM_FREE(rate_class_info_dummy);
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_mcast_gport_add(int unit,
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    bcm_error_t rc = BCM_E_NONE;
    int         is_non_contiguous = FALSE;    
    int         base_fmq = 0, fmq = 0, start_fmq = 0, end_fmq;
    int         alloc_flags = 0;
    int         is_composite = FALSE;
    int         base_flow_id = DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    int         sysport = 0;
    int         mcast_sched_mode = 0;

    uint32 relevant_flags, dnx_sand_rc;
    int flow_quartet;
    int flow_id = 0;
    int core = BCM_CORE_ALL, core_index;
    int stk_exist;
    DNX_TMC_ITM_QUEUE_INFO queue_info, old_queue_info;
    bcm_dnx_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DNX_DEFS_MAX(NOF_CORES)];
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(gport);
    BCMDNX_NULL_CHECK(config);

    port = config->port;
    numq = config->numq; 
    flags = config->flags;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add multicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP 
                              | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    if ((numq < 0) || (numq > DNX_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        base_fmq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(*gport);
       
        rc = bcm_dnx_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
        BCMDNX_IF_ERR_EXIT(rc);
        
        rc = bcm_dnx_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
        BCMDNX_IF_ERR_EXIT(rc);

        if (base_fmq > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range "), unit, base_fmq));
        }

        if (base_fmq < start_fmq || base_fmq > end_fmq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range of multicast fabric queues "), unit, base_fmq));
        }

        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(*gport);
        if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, base_fmq, core));
        }
        alloc_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
    } else {
       BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit(%d) add mc q gport(0x%08x) not supported without with_id"), unit, base_fmq));
    }
    /*validate rate class mapping params */
    /* base_queue - relevant for deletion only*/
    rc = _bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, 0, TRUE, config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, sysport));

    rc = bcm_dnx_fabric_multicast_scheduler_mode_get(unit, core, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Only 4 multicast queues allocated if we are in mode 0 - these are not managed by alloc_mngr.c *
     * so we do not want to allocate them here.  If in mode 1 4k queues are available so allocate.   *
     */
    if (mcast_sched_mode != 0) {

        rc = _bcm_dnx_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               FALSE,/*is_ucast*/
                                                               FALSE,/*is_flow*/
                                                               port,
                                                               &sysport, 
                                                               &stk_exist);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {
        sysport = JER2_ARAD_NOF_SYS_PHYS_PORTS_GET(unit) - 1;
    }

    if (mcast_sched_mode == 0) {
        if ((BCM_COSQ_GPORT_WITH_ID & flags) && (base_fmq != 0)) {
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, mode incompatible with base FMQ(%d) !=0\n"), unit, base_fmq));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            base_fmq = 0;
        }
    } else if (base_fmq != 0) { /*In all modes we reserved base_fmq - no need to allocate*/
        /* call queue allocation wrapper function which    */
        /* calls lower level function - if with_id is set, */
        /* the user has alloc-ed, pass this flag also      */       
        rc = bcm_dnx_am_ingress_voq_allocate(unit,
                                             core,
                                             alloc_flags,
                                             is_non_contiguous,
                                             numq,
                                             DNX_DEVICE_COSQ_QUEUE_REGION_MULTICAST,
                                             &base_fmq);
        
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) gport add fmq group not available (%d)"), unit, port, rc));
        }
    }
    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index){
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.set(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_fmq), numq));
    }

    for (flow_quartet = 0, fmq = base_fmq; 
         fmq < (base_fmq + numq);
         flow_quartet++, fmq+=DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        DNX_TMC_IPQ_QUARTET_MAP_INFO queue2flow;

        DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

        _bcm_dnx_flow_id_get(unit, core,
                               base_flow_id, 
                               (fmq - base_fmq) /* cos */,
                               is_non_contiguous,
                               is_composite,
                               FALSE /*is_remove*/,
                               &flow_id);

        queue2flow.flow_quartet_index = DNX_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;
        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_set,
            (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(fmq), &queue2flow)));
        
        rc = dnx_handle_sand_result(dnx_sand_rc);

        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "soc_dnx_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), fmq, sysport));
        }

        /* Rotate between using default flow ids which are reserved */
        flow_id++;
    }

    /*Set Queue profiles - credit request profile and rate class acording to config info*/
    for (cosq = 0; cosq < numq; cosq++) {
        DNX_TMC_ITM_QUEUE_INFO_clear(&queue_info);
        /* retrieve current configuration */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit, core, base_fmq + cosq, &queue_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        sal_memcpy(&old_queue_info, &queue_info, sizeof(DNX_TMC_ITM_QUEUE_INFO));

        /* update configuration */
        /*Map each queue offset to relevant rate class*/
        queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

        /*Map each queue offset to relevant crefit request profile*/
        rc = _bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
        BCMDNX_IF_ERR_EXIT(rc);  

        old_queue_info.cr_req_type_ndx = DNX_TMC_ITM_QT_NDX_INVALID;
        old_queue_info.rate_cls = DNX_TMC_ITM_NOF_RATE_CLASSES;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_set,(unit, core, base_fmq + cosq, &old_queue_info, &queue_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }
    /*Update SW state for rate class mapping*/
    rc = _bcm_dnx_cosq_ingress_queue_bundle_ref_count_update(unit, core, TRUE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);  

    BCM_GPORT_MCAST_QUEUE_GROUP_CORE_QUEUE_SET(*gport, core, base_fmq);

exit:
BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    int         rc = BCM_E_NONE;
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    int         is_non_contiguous = FALSE;
    int         is_flow = FALSE;
    int         is_composite = FALSE;
    int         is_isq = FALSE;
    int         dnx_sand_rc = 0;
    int         sysport = 0;
    int         flow_id, flow_quartet;
    int         base_voq = 0, voq = 0;
    int         alloc_flags = 0;
    bcm_gport_t tmp_gport = 0;
    unsigned    direct_mode = 0;
    int stk_exist = 0x0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
    DNX_TMC_ITM_QUEUE_INFO queue_info, old_queue_info;
    bcm_dnx_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DNX_DEFS_MAX(NOF_CORES)];
    BCMDNX_INIT_FUNC_DEFS;

    /*Verify unit*/
    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(gport);
    numq = config->numq;
    if ((numq < 0) || (numq > DNX_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, numq));
    }
    port = config->port;
    flags = config->flags;
    tmp_gport = *gport;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add unicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));    

    if(JER2_ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        direct_mode = 1;
    }

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_TM_FLOW_ID & flags) {
        is_flow = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    if (BCM_COSQ_GPORT_ISQ & flags) {
        is_isq = TRUE;
    }
    if (BCM_COSQ_GPORT_SW_ONLY & flags) {
        if (!SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) failed, sw_only configuration not allowed%d"), unit));
        }
        is_sw_only = TRUE;
    }

    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        
        if (is_isq) {
            base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(tmp_gport);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(tmp_gport);
        } else {
            base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(tmp_gport);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(tmp_gport);
        }

        if (base_voq > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, queue out of range %d"), unit, tmp_gport, base_voq));
        }
        if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, tmp_gport, core));
        }

        alloc_flags |= BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
    } else {
        tmp_gport = -1;
        *gport = -1;
        core = config->local_core_id;
        if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q  without_id failed, core out of range %d"), unit, core));
        }
    }
    /*validate rate class mapping params */
    /* base_queue - relevant for deletion only*/
    rc =_bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, 0, TRUE, config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add uc gport(0x%08x) flags: interdig(%d) flow(%d) composite(%d)\n"), unit, port, is_non_contiguous, is_flow, is_composite));
    /* Prosses config->port to get the relvent destination sysport*/
    rc = _bcm_dnx_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               TRUE, /*is_ucast*/
                                                               is_flow,
                                                               port, 
                                                               &sysport,
                                                               &stk_exist);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit=%d, port=0x%x, is_flow=%d, direct_mode=%d, sysport=0x%x\n"), unit, port, is_flow, direct_mode, sysport));
    if (stk_exist == 0x1) {
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "%s(): stk_exist=%d. exit ucas_cos_add().\n\n"), FUNCTION_NAME(), stk_exist));
        BCM_EXIT;
    }
    /* call queue allocation wrapper function which    */
    /* calls lower level function - if with_id is set, */
    /* the user has alloc-ed, pass this flag also      */
    if (core == BCM_CORE_ALL && !SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit) && !(BCM_DNX_AM_FLAG_ALLOC_WITH_ID & alloc_flags)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) Cannot allocate ingress queue without ID in asymmetric mode."), unit));
    }
    rc = bcm_dnx_am_ingress_voq_allocate(unit,
                                         core,
                                         alloc_flags,
                                         is_non_contiguous,
                                         numq,
                                         (is_isq) ? DNX_DEVICE_COSQ_QUEUE_REGION_ISQ: DNX_DEVICE_COSQ_QUEUE_REGION_UNICAST,
                                         &base_voq);

    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) base_voq(%d) numq_queue(%d) gport add voq group not available (%d)"), unit, base_voq, numq, rc));
    }
    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index){
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.set(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), numq));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "voq allocated(0x%08x)\n"), base_voq));

    /*VOQ to flow mapping*/
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq+=DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        DNX_TMC_IPQ_QUARTET_MAP_INFO queue2flow;
        DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);
        /*
         * This is a default flow. later on, when connection is made between flow and queue,
         * a meaningful value will be loaded. Validity checks within 'mbcm_dnx_ipq_queue_to_flow_mapping_set'
         * take that into accoungt.
         */
        flow_id = DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START ;

        queue2flow.flow_quartet_index = DNX_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_set,
            (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        rc = dnx_handle_sand_result(dnx_sand_rc);
        if (rc != BCM_E_NONE) {
            if (is_flow) {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_dnx_ipq_queue_to_flow_mapping_set() failed queue(%d)\n"), voq));
            } else {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_dnx_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), voq, sysport));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    /*SYSPORT to BASEQ MAPPING, SYSPORT MAPPING not required in case of FLOW based forwarding */
    if (!is_flow) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_destination_id_packets_base_queue_id_set,
            (unit, core, sysport, TRUE /* queue is valid */,is_sw_only, base_voq)));
        rc = dnx_handle_sand_result(dnx_sand_rc); /* set sysport to base queue mapping */
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "soc_dnx_ipq_destination_id_packets_base_queue_id_set() failed" \
                                  "base queue(%d) sysport(%d)\n"), base_voq, sysport));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /*Set Queue profiles - credit request profile and rate class acording to config info*/
    for (cosq = 0; cosq < numq; cosq++) {
        DNX_TMC_ITM_QUEUE_INFO_clear(&queue_info);
        /* retrieve current configuration */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_get,(unit, core, base_voq + cosq, &queue_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        sal_memcpy(&old_queue_info, &queue_info, sizeof(DNX_TMC_ITM_QUEUE_INFO));

        /* update configuration */
        /*Map each queue offset to relevant rate class*/
        queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

        /*Map each queue offset to relevant crefit request profile*/
        rc = _bcm_dnx_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
        BCMDNX_IF_ERR_EXIT(rc);  

        old_queue_info.cr_req_type_ndx = DNX_TMC_ITM_QT_NDX_INVALID;
        old_queue_info.rate_cls = DNX_TMC_ITM_NOF_RATE_CLASSES;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_queue_info_set,(unit, core, base_voq + cosq, &old_queue_info, &queue_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }     
    /*Update SW state for rate class mapping*/
    rc = _bcm_dnx_cosq_ingress_queue_bundle_ref_count_update(unit, core, TRUE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);  

    if (is_isq) {
        *gport = BCM_COSQ_GPORT_ISQ_CORE_QUEUE_SET(tmp_gport, core, base_voq);
    } else {                                
        *gport = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(tmp_gport, core, base_voq);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           dnx_sand_rc;
    bcm_dnx_cosq_gport_info_t        *gport_info;
    uint8                        is_non_contiguous;
    int                              base_flow_id, flow_region, is_odd_even;
    DNX_TMC_SCH_QUARTET_MAPPING_INFO     quartet_mapping_info;
    int                              core ;
    uint8                            sw_state_num_cos;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);

    if (SOC_IS_QAX(unit)) {
        base_flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, base_flow_id);
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &gport, BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport));
    }

    /* retrieve connector group state */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
    if (sw_state_num_cos <= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport get flow internal state retreival error"), unit, base_flow_id));
    }


    /* validate gport (connector) */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dnx_device_cosq_gport_child_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* retrieve flow to queue mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_flow_to_queue_mapping_get,
        (unit, core, DNX_TMC_SCH_FLOW_TO_QRTT_ID(base_flow_id), &quartet_mapping_info)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreving flow (%d) queue mapping, dnx_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, dnx_sand_rc, rc));
        goto err;
    }
    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    BCM_GPORT_MODPORT_SET((*physical_port), quartet_mapping_info.fip_id, 0);

    /* update parameters */
    (*flags) = BCM_COSQ_GPORT_VOQ_CONNECTOR;
    (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    (*num_cos_levels) = sw_state_num_cos;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_hr_gport_get(int unit, bcm_dnx_cosq_gport_info_t *gport_info,
                                   DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch (se_config->type_info.hr.mode) {
        case DNX_TMC_SCH_HR_MODE_SINGLE_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ;
            break;

        case DNX_TMC_SCH_HR_MODE_DUAL_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ;
            break;

        case DNX_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED;
            break;

        case DNX_TMC_SCH_HR_MODE_NONE:
        case DNX_TMC_SCH_SE_HR_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_cl_gport_get(int unit, int core, bcm_dnx_cosq_gport_info_t *gport_info,
                                   DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           dnx_sand_rc;
    int                              cl_type_ndx;
    DNX_TMC_SCH_SE_CL_CLASS_INFO         class_type;
    bcm_dnx_cosq_gport_info_t        *dual_gport_info;
    bcm_gport_t                      pir_gport;
    uint32                           hr_flags = 0;
    DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode = DNX_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES;

    BCMDNX_INIT_FUNC_DEFS;
    dual_gport_info = NULL ;
    DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

    cl_type_ndx = se_config->type_info.cl.id;
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, cl_type_ndx, &class_type)));
    /*
     * Condition related to unit is only added here to appease coverity. It is not
     * really necassary.
     */
    if (DNX_SAND_FAILURE(dnx_sand_rc) || (unit >= BCM_MAX_NUM_UNITS)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, dnx_sand_rc, rc));
        goto err;
    }

    switch (class_type.mode) {
        case DNX_TMC_SCH_CL_MODE_1:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP;
            break;

        case DNX_TMC_SCH_CL_MODE_2:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ;
            break;

        case DNX_TMC_SCH_CL_MODE_3:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP;
            break;

        case DNX_TMC_SCH_CL_MODE_4:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ;
            break;

        case DNX_TMC_SCH_CL_MODE_5:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ;
            break;

        case DNX_TMC_SCH_CL_MODE_NONE:
        case DNX_TMC_SCH_CL_CLASS_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (class_type.mode != DNX_TMC_SCH_CL_MODE_1) {
        switch (class_type.weight_mode) {
            case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET;
                break;

            case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_ipf_mode_get,(unit, &ipf_mode)));
                if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, dnx_sand_rc, rc));
                    goto err;
                }
                if(ipf_mode == DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT;
                }
                else if(ipf_mode == DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL;
                }
                else{
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, invalid ipf mode %d\n"), unit, ipf_mode));
                    rc = BCM_E_PARAM;
                    goto err;
                }
                break;

            case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS;
                break;

            case DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            default:
            break;
        }
    }

    switch (class_type.enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ;
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ;
            break;

        case DNX_TMC_SCH_CL_ENHANCED_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (se_config->is_dual) {
        (*flags) |= BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER;

        /* determine type of dual shaper */

        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(pir_gport, gport_info->flow_id, core);

        rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, pir_gport, 0, dnx_device_cosq_gport_parent_element, &dual_gport_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
        if (dual_gport_info == NULL) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "unit %d, resource memory allocation failure\n"), unit));
            rc = BCM_E_MEMORY;
            goto err;
        }

        if (dual_gport_info->is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        switch ((dual_gport_info->se_config)->type) {
            case DNX_TMC_SCH_SE_TYPE_HR:
                rc = _bcm_dnx_cosq_sched_hr_gport_get(unit, dual_gport_info, dual_gport_info->se_config, dual_gport_info->flow_config, &hr_flags);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                (*flags) |= (hr_flags);
                break;

            default:
                break;
       }
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /* Not really needed. Just to aviod coverity defect */
    if(unit < BCM_LOCAL_UNITS_MAX) {
        if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
        {
            /*
             * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
             * {provided pointer is not NULL}.
             */
            if (dual_gport_info) {
                BCM_FREE(dual_gport_info->flow_config);
                BCM_FREE(dual_gport_info->se_config);
                BCM_FREE(dual_gport_info);
            }
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (dual_gport_info) {
        BCM_FREE(dual_gport_info->flow_config);
        BCM_FREE(dual_gport_info->se_config);
        BCM_FREE(dual_gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_gport_t                      res_gport;
    bcm_dnx_cosq_gport_info_t        *gport_info;
    int                              core ;
    int                              flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, gport, 0,  &res_gport);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_GPORT_SCHEDULER_GET(res_gport));
            BCM_GPORT_SCHEDULER_CORE_SET(res_gport, flow_id, core);
    }
    /* validate gport (scheduler) */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, res_gport, 0, dnx_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    switch ((gport_info->se_config)->type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_dnx_cosq_sched_hr_gport_get(unit, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case DNX_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_dnx_cosq_sched_cl_gport_get(unit, core, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case DNX_TMC_SCH_SE_TYPE_FQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_FQ;
            (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_dnx_cosq_gport_info_t        *gport_info;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    /* validate gport (scheduler) */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dnx_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    switch ((gport_info->se_config)->type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_dnx_cosq_sched_hr_gport_get(unit, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case DNX_TMC_SCH_SE_TYPE_CL:
        case DNX_TMC_SCH_SE_TYPE_FQ:
        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    uint8                    is_dest_valid = FALSE;
    uint8                    is_isq = FALSE;
    int                          dnx_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    uint32                       dest_base_queue = 0;
    uint32                       queue_region;
    DNX_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    unsigned indirect_mode = 1;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
    uint8 nof_iter = 0;
    uint8 sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;
    if(JER2_ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }

    *flags = 0;
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    if (base_voq >= SOC_DNX_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) delete uc q gport(0x%08x) failed, core out of range %d"), unit, gport, core));
    }
    DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
        (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = dnx_handle_sand_result(dnx_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_dnx_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    /* determine if this queue group is non-flow based */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
          (_BSL_BCM_MSG("retrieving base queue for dest port(%d) failed, dnx_sand error (0x%x), error 0x%x"), 
          sysport, dnx_sand_rc, rc));
    }

    if (indirect_mode) {
        /* From the queue to flow mapping, get the system port */
        BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);

        /* return the physical port given the system port */
        rc = bcm_dnx_stk_sysport_gport_get(unit, sysport_gport, physical_port);

        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
              (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), unit, sysport, base_voq));
        }
    } else { /* direct mode */
        BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, queue2flow.fap_port_id);
    }
    /* update parameters */
    /*If dest_base_queue != base_voq, then we should use tm flow ID */
    (*flags) |= (dest_base_queue != base_voq) ? BCM_COSQ_GPORT_TM_FLOW_ID : 0;
    if (is_isq) {
        (*flags) |= BCM_COSQ_GPORT_ISQ;
    } else {
        (*flags) |= BCM_COSQ_GPORT_UCAST_QUEUE_GROUP;
    }
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_dnx_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }
    
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter){
            *num_cos_levels = sw_state_num_cos;
        }
        nof_iter++;
    }
exit:
BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    int                          dnx_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    int                          start_fmq = 0, end_fmq;
    DNX_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    uint32                       queue_region;
    unsigned                    indirect_mode = 1;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iter = 0;
    uint8                       sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    if(JER2_ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }

    *flags = 0;
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
        
    rc = bcm_dnx_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = bcm_dnx_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (base_voq > DNX_DEVICE_DNX_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range"),
          unit, base_voq));
    }
    
    if (base_voq < start_fmq || base_voq > end_fmq) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range of multicast fabric queues"),
          unit, base_voq));
    }

    DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
        (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = dnx_handle_sand_result(dnx_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_dnx_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    if (indirect_mode) {
        if (sysport == DNX_TMC_SYS_PHYS_PORT_INVALID) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            /* From the queue to flow mapping, get the system port */
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);
    
            rc = bcm_dnx_stk_sysport_gport_get(unit, sysport_gport, physical_port);
    
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                  (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), 
                  unit, queue2flow.system_physical_port, base_voq));
            }
        }
    } else {
        if (queue2flow.fap_id == DNX_TMC_MAX_FAP_ID) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            bcm_port_t fap_port;
            rc = bcm_dnx_tm_port_get(unit, core, queue2flow.fap_port_id, &fap_port);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, fap_port);
        }
    }

    /* update parameters */
    (*flags) |= BCM_COSQ_GPORT_MCAST_QUEUE_GROUP;
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_dnx_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }

    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter) {
            *num_cos_levels = sw_state_num_cos;
        }
        nof_iter++;
    }

exit:
BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq)
{
    int                              rc = BCM_E_NONE;
    int                              is_parent_reserved_res = FALSE;
    bcm_dnx_cosq_gport_info_t        *child_info ;
    bcm_dnx_cosq_gport_info_t        *parent_info ;
    uint32                           dnx_sand_rc, nof_remote_cores, region;
    int                              child_mode, flow_id_index;
    DNX_TMC_SCH_SE_INFO             *default_se_info = NULL;
    DNX_TMC_SCH_FLOW                *default_sch_flow = NULL;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    DNX_TMC_SCH_FLOW                     exact_flow_config;
    int                              parent_se_port, dummy_tc;
    bcm_gport_t                      parent_port;
    int                              core, flow_id, i, orig_sub_flow0_id, orig_sub_flow1_id;
    DNX_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, sched_port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for sched_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)sched_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    
    BCMDNX_ALLOC(default_se_info, sizeof(DNX_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(default_sch_flow, sizeof(DNX_TMC_SCH_FLOW), "sch flow");

    if ( (default_se_info == NULL) || (default_sch_flow == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    DNX_TMC_SCH_FLOW_clear(unit, default_sch_flow);
    DNX_TMC_SCH_SE_INFO_clear(default_se_info);

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_dnx_cosq_parent_gport_to_resource_gport(unit, sched_port, 0, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &parent_port, core);
        _bcm_dnx_cosq_gport_jer2_qax_flow_id_add(unit, &input_port, core);
    }
    /* validate parent element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, parent_port, 0, dnx_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* validate child element */
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, input_port, cosq, dnx_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info->is_se) {
        rc = _bcm_dnx_cosq_se_id2port(unit, core, parent_info->se_id, &parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE)
        {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Error retreving port id from SE %d\n"), unit,parent_info->se_id));          
          goto err;
        }     
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( (parent_info->is_se) &&
                        ( (parent_se_port != DNX_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info->se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    /* consistency checks. */
    /* verify child scheduler connection to parent scheduler              */
    if ( (parent_info->se_config)->id !=
                       (child_info->flow_config)->sub_flow[flow_id_index].credit_source.id ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* if already detached return error */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (parent_info->se_id == sw_state_default_se) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, detach operation on input_port:cos(0x%x:%d) error, already detached\n"), unit, input_port, cosq));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* verify reference count is greater then 0 */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, (parent_info->se_config)->id, &sw_state_ref_cnt));

        if (sw_state_ref_cnt <= DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) Parent SE(%d) reference count is 0\n"),
                                  unit, (parent_info->se_config)->id));
            rc = BCM_E_INTERNAL;
            goto err;
        }
    }

    /* detach by setting to default SE */
    /* determine scheduling mode of child with respect to parent */
    rc = _bcm_dnx_cosq_mode_get(unit, core, child_info->flow_config, child_info->is_sf2, &child_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving child element scheduling mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* retrieve default SE configuration */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, sw_state_default_se, default_se_info, default_sch_flow)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
                "unit %d, error in retreiving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, sw_state_default_se, dnx_sand_rc, rc));
        goto err;
    }

    /* attach to default / reserved SE */
    cs_info->se_type = default_se_info->type;
    cs_info->id = sw_state_default_se;

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);

        child_info->flow_config->sub_flow[0].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    /* decrement reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, (parent_info->se_config)->id, sw_state_ref_cnt - 1));
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCM_FREE(default_se_info);
   BCM_FREE(default_sch_flow);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info);
        }
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info);
    }
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_gport_delete(int unit, bcm_gport_t gport)
{
    int                              rc = BCM_E_NONE;
    int                              is_port_reserved_res = FALSE, is_enhanced = FALSE;
    int                              enhanced_mode;
    bcm_dnx_cosq_gport_info_t        *port_info ;
    bcm_dnx_cosq_gport_info_t        *dual_port_info ;
    DNX_TMC_SCH_FLOW                 exact_flow_config;
    bcm_gport_t                      pir_gport;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    uint32                           dnx_sand_rc, flags = 0;
    int                              second_flow_id; /* composite or dual */
    int                              res_flow_id; /* fq adjustment for low level alloaction */
    int                              is_last;
    int                              core ;
    DNX_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;
    bcm_dnx_cosq_flow_config_t       flow_zero = {0};
    bcm_dnx_cosq_se_config_t         se_zero = {0};
    int                              flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    dual_port_info = NULL ;
    port_info = NULL ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    
    /* validate gport element */
    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_GPORT_SCHEDULER_GET(gport));
        BCM_GPORT_SCHEDULER_CORE_SET(gport, flow_id, core);
    }
    rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dnx_device_cosq_gport_sched_nocirpir_ds_element, &port_info); 
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* make sure the gport is a SE */
    if ( !(port_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, gport));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if scheduler element is a reserved resource              */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (port_info->is_se) {
        if (port_info->se_id == sw_state_default_se) {
            is_port_reserved_res = TRUE;
        }
        if (is_port_reserved_res == TRUE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "unit %d, gport(0x%x) is a reserved resource and cannot be deleted\n"), unit, gport));
             rc = BCM_E_PARAM;
             goto err;
        }
    }

    /* check if the SE is not referenced */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, port_info->se_id, &sw_state_ref_cnt));

    if (sw_state_ref_cnt > DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) reference count(%d) not zero \n"),
                              unit, port_info->se_id, sw_state_ref_cnt));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* check if the SE is detached */
    cs_info = &(port_info->flow_config->sub_flow[0].credit_source);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id != sw_state_default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }
    if (port_info->is_composite == TRUE) {
        cs_info = &(port_info->flow_config->sub_flow[1].credit_source);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (cs_info->id != sw_state_default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* if dual shaper configuration, check that dual SE is not referenced */
    if (port_info->is_dual) {
        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(pir_gport, gport, core);

        rc = _bcm_dnx_cosq_alloc_n_gport_validate_info_get(unit, pir_gport, 0, dnx_device_cosq_gport_parent_element, &dual_port_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
        if (dual_port_info == NULL) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                       "unit %d, resource memory allocation failure\n"), unit));
            rc = BCM_E_MEMORY;
            goto err;
        }

        if (dual_port_info->is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        cs_info = &(dual_port_info->flow_config->sub_flow[0].credit_source);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (cs_info->id != sw_state_default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* disable SE */
    (port_info->se_config)->state = DNX_TMC_SCH_SE_STATE_DISABLE;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, port_info->se_id, port_info->se_config, port_info->flow_config, &exact_flow_config)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, port_info->se_id, dnx_sand_rc, rc));
        goto err;
    }

    if (port_info->is_dual) {
        (dual_port_info->se_config)->state = DNX_TMC_SCH_SE_STATE_DISABLE;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, dual_port_info->se_id, dual_port_info->se_config, dual_port_info->flow_config, &exact_flow_config)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, dual_port_info->se_id, dnx_sand_rc, rc));
            goto err;
        }
    }

    /* free template resources */
    if ((port_info->se_config)->type == DNX_TMC_SCH_SE_TYPE_CL) {
        rc = _bcm_dnx_am_template_cosq_sched_class_free(unit, core, (port_info->se_config)->type_info.cl.id, &is_last);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in freeing class template cid(%d), error 0x%x\n"), unit, (port_info->se_config)->type_info.cl.id, rc));
            goto err;
        }

        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "DBG unit %d, CL template(%d) is_last(%s)\n"), unit, (port_info->se_config)->type_info.cl.id, ((is_last == TRUE) ? "TRUE" : "FALSE")));

    }

    /* free resources */
    switch ((port_info->se_config)->type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, FALSE, port_info->is_dual, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_HR, port_info->flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case DNX_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_dnx_cosq_sched_enhanced_mode_get(unit, core, port_info->se_config, &is_enhanced, &enhanced_mode);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, is_enhanced, port_info->is_dual, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_CL, port_info->flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case DNX_TMC_SCH_SE_TYPE_FQ:
        default:
            res_flow_id = port_info->flow_id;

            rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, FALSE, port_info->is_dual, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_FQ, res_flow_id);

            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;
    }


    /* free flow resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, port_info->flow_id, &flow_zero));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        bcm_dnx_vig_delete_this_flow(unit, core, Vig_db[unit], port_info->flow_id) ;
    }
/* } */
#endif

    if ( (port_info->is_composite) || (port_info->is_dual) ) {
        if (port_info->is_composite) {
            rc = _bcm_dnx_se_composite_flow_id_get(unit, port_info->flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (port_info->is_dual) {
            rc = _bcm_dnx_se_dual_flow_id_get(unit, port_info->flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, port_info->flow_id));
            goto err;
        }

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, second_flow_id, &flow_zero));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
        {
            bcm_dnx_vig_delete_this_flow(unit,core,Vig_db[unit], second_flow_id) ;
        }
/* } */
#endif
    }

    /* free SE resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, port_info->se_id, &se_zero));
    if (port_info->is_dual) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, dual_port_info->se_id, &se_zero));
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
        if (dual_port_info) {
            BCM_FREE(dual_port_info->flow_config);
            BCM_FREE(dual_port_info->se_config);
            BCM_FREE(dual_port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_dnx_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
    if (dual_port_info) {
        BCM_FREE(dual_port_info->flow_config);
        BCM_FREE(dual_port_info->se_config);
        BCM_FREE(dual_port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_connector_gport_delete(int unit, bcm_gport_t gport)
{
    int                               rc = BCM_E_NONE;
    uint32                            dnx_sand_rc, nof_remote_cores, region;
    uint32                            flags = 0;
    uint8                             is_non_contiguous, is_composite;
    int                               base_flow_id, numq, flow_region, is_odd_even;
    int                               cur_flow_id, cur_connector, cur_comp_flow_id;    
    DNX_TMC_SCH_FLOW                  flow_config, exact_flow_config;
    int                              core, i, flow_id;
    DNX_TMC_SCH_SE_ID                 sw_state_default_se;
    uint8                             sw_state_num_cos;
    bcm_dnx_cosq_connector_config_t   zero = {0};

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    if (SOC_IS_QAX(unit)) {
        base_flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, base_flow_id);
    }
    /* consistency check - flow withen valid range */
    if (base_flow_id >= SOC_DNX_CONFIG(unit)->tm.max_connectors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid base connector id %d"),unit, base_flow_id));
    }

    /* retrieve connector group state */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
    numq = sw_state_num_cos;

    if (numq == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
    }

    /* determine flow attributes */
    flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    DNX_TMC_SCH_FLOW_clear(unit, &flow_config);

    /* consistency check - all flows are detached */
    is_composite = FALSE;
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_get,(unit, core, cur_flow_id, &flow_config)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, dnx_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, dnx_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        if (cur_connector == 0) {
            /* determine flow attributes */
            is_composite = ( (flow_config.sub_flow[0].is_valid == TRUE) &&
                            (flow_config.sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
        }

        if (is_composite) {
            rc = _bcm_dnx_composite_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite,&cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        /* consistency check, check that the flows match up */
        if (cur_flow_id != flow_config.sub_flow[0].id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, flow id mismatch Expected/Actual(%d / %d)\n"), unit, cur_flow_id, flow_config.sub_flow[0].id));
        }
        if (is_composite) {
            if (cur_comp_flow_id != flow_config.sub_flow[1].id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, Comp flow id mismatch Expected/Actual(%d / %d)"), unit, cur_comp_flow_id, flow_config.sub_flow[1].id));
            }
        }

        /* check that the flows are detached */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (flow_config.sub_flow[0].credit_source.id != sw_state_default_se) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow id (%d) not detached"), unit, cur_flow_id));
        }
        if (is_composite) {
            if (flow_config.sub_flow[1].credit_source.id != sw_state_default_se) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Comp flow id (%d) not detached"), unit, cur_comp_flow_id));
            }
        }
    }

    region = _BCM_DNX_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(base_flow_id);
    nof_remote_cores = SOC_DNX_CONFIG(unit)->jer2_arad->region_nof_remote_cores[core][region];


    /* delete all flows */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        /* set all symmetric connections */
        for (i = 0; i < nof_remote_cores; i++) {
            flow_id = _BCM_DNX_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_flow_id, nof_remote_cores, i);
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_get,(unit, core, flow_id, &flow_config)));
            if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, dnx_sand error 0x%x, error 0x%x\n"), unit, flow_id, dnx_sand_rc, rc));
                BCM_ERR_EXIT_NO_MSG(rc);
            }

            flow_config.sub_flow[0].is_valid = FALSE;
            if (is_composite) {
                flow_config.sub_flow[1].is_valid = FALSE;
            }

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_set,(unit, core, flow_id, &flow_config, &exact_flow_config)));
            if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, dnx_sand error 0x%x, error 0x%x\n"), unit, flow_id, dnx_sand_rc, rc));
                BCM_ERR_EXIT_NO_MSG(rc);
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                bcm_dnx_vig_delete_this_flow(unit, core, Vig_db[unit], flow_id) ;
            }
/* } */
#endif
        }
    }

    /* free resources */
    rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, DNX_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, base_flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error freeing connector resources (baseFlowId: %d) from resource manager, error 0x%x\n"), unit, base_flow_id, rc));
        BCM_ERR_EXIT_NO_MSG(rc);
    }

    /* free flow resources */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_flow_id, &zero));

        if (is_composite) {
            rc = _bcm_dnx_composite_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_comp_flow_id, &zero));
        }
    }

    /* free connector group resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, base_flow_id, &zero));

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_mcast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE;
    int                         dnx_sand_rc = 0;
    int                         base_voq = 0, voq = 0, numq = 0, queue_region;
    DNX_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         alloc_flags = 0, flow_quartet;
    DNX_SAND_U32_RANGE              mc_queue_range;
    int                         mcast_sched_mode = 0;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iters = 0; 
    int                         numq_tmp = -1;
    bcm_dnx_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DNX_DEFS_MAX(NOF_CORES)];
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
    uint8                       sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* determine base queue id */
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);

    /* consistency checks */
    if (base_voq >= SOC_DNX_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    /* determine queue region mode */
    queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_dnx_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve queue group state */
    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        /* consistency check that it is withen the multicast queue range */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_mult_fabric_enhanced_get,(unit, core_index, &mc_queue_range)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
              (_BSL_BCM_MSG("Unit (%d), retreiving multicast queue range failed, dnx_sand error (0x%x), error 0x%x"), unit, dnx_sand_rc, rc));
        }

        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if ( (base_voq < mc_queue_range.start) || (base_voq > mc_queue_range.end) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("base voq is out of the provided range")));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        numq = sw_state_num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }
    config.numq = numq;
    rc = _bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, base_voq, FALSE, &config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);
    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
            (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
          (_BSL_BCM_MSG("soc_dnx_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DNX_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not dsconnected"), unit, voq));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_qrtt_unmap,
            (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), dnx_sand error 0x%x, error 0x%x\n"), voq, dnx_sand_rc, rc));
            if (flow_quartet == 0) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    result = bcm_dnx_fabric_multicast_scheduler_mode_get(unit, core, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(result);
    
    /* free resources */

    /* If multicast scheduling mode=0, queues 0-3 are used - these aren't reserved through alloc manager. *
     * otherwise, 1k queues can be used for multicast and these are managed by alloc manager              *
     */
    if (mcast_sched_mode != 0 && base_voq != 0) { /*In all modes we reserved base_fmq - no need to deallocate*/
        result = bcm_dnx_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    }

    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos != 0) {
            bcm_dnx_cosq_voq_config_t zero = {0};
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.set(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &zero));
        }
    }   
    BCMDNX_IF_ERR_EXIT(rc);

    /* When deleting a new voq it is unmapped from some rate class*/
    rc = _bcm_dnx_cosq_ingress_queue_bundle_ref_count_update(unit, core, FALSE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_ucast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE,
                                is_dest_valid, is_dest = FALSE;
    uint8                   is_isq = FALSE;
    int                         dnx_sand_rc = 0;
    int                         base_voq = 0,voq = 0, numq = 0, queue_region;
    DNX_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         sysport = 0, alloc_flags = 0, flow_quartet;
    uint32                      dest_base_queue = 0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE, nof_iters = 0;
    int                        numq_tmp = -1;
    bcm_dnx_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DNX_DEFS_MAX(NOF_CORES)];
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
    uint8                       sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;

   /* determine base queue id */
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    /* consistency checks */
    if (base_voq >= SOC_DNX_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x failed, core out of range %d"), unit, gport, core));
    }

    /* determine queue region mode */
    queue_region = BCM_DEVICE_DNX_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_dnx_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve queue group state */
    

    /* retrieve queue group state */
    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        numq = sw_state_num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }
    config.numq = numq;
    rc = _bcm_dnx_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, base_voq, FALSE, &config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);
    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_to_flow_mapping_get,
            (unit, core ,DNX_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
              (_BSL_BCM_MSG("soc_dnx_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* determine state */
        if (flow_quartet == 0) {
            sysport = queue2flow.system_physical_port;
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (DNX_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DNX_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not disconnected"), unit, voq));
        }
    }

    /* determine if this queue group is non-flow based */
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
          (_BSL_BCM_MSG("retreiving base queue for dest port(%d) failed, dnx_sand error (0x%x), error 0x%x"), sysport, dnx_sand_rc, rc));
    }

    if (dest_base_queue == base_voq) {
        is_dest = TRUE;

        /* disable configuration */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_destination_id_packets_base_queue_id_set,
            (unit, core, sysport, FALSE, is_sw_only, dest_base_queue)));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(dnx_translate_sand_success_failure(dnx_sand_rc),
              (_BSL_BCM_MSG("disabling base queue for dest port(%d) failed, dnx_sand error (0x%x), error 0x%x"), sysport, dnx_sand_rc, rc));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DNX_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_qrtt_unmap,
            (unit, core, DNX_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), dnx_sand error 0x%x, error 0x%x\n"), voq, dnx_sand_rc, rc));
            if ( (flow_quartet == 0) && (is_dest == FALSE) ) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    /* free resources */
    result = bcm_dnx_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos != 0) {
            bcm_dnx_cosq_voq_config_t zero = {0};
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.set(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit, core_index, base_voq), &zero));
        }
    }   

    BCMDNX_IF_ERR_EXIT(rc);

    /* When deleting a new voq it is unmapped from some rate class*/
    rc = _bcm_dnx_cosq_ingress_queue_bundle_ref_count_update(unit, core, FALSE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(result);
exit:
BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid)
{
    int rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    (*cid) = -1;
    switch(weight_mode) {
        case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
            switch (mode) {
                case DNX_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_ind;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_ind_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_ind_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_ind;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_ind_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_ind_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_ind;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_ind_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_ind_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_1:
                case DNX_TMC_SCH_CL_MODE_2:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            switch (mode) {
                case DNX_TMC_SCH_CL_MODE_1:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode1;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode1_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode1_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_2:
                case DNX_TMC_SCH_CL_MODE_3:
                case DNX_TMC_SCH_CL_MODE_4:
                case DNX_TMC_SCH_CL_MODE_5:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
            switch (mode) {
                case DNX_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_des;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_des_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_des_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_des;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_des_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_des_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_des;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_des_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_des_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case DNX_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_des;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_des_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_des_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
            switch (mode) {
                case DNX_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_cls;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_cls_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode3_cls_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_cls;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_cls_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode4_cls_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_cls;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_cls_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode5_cls_elp_fq;
                            break;
                    }
                    break;
                case DNX_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case DNX_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_cls;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_cls_ehp_fq;
                            break;
                        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dnx_cosq_cl_cid_mode2_cls_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (validate_only == TRUE) {
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    
    if ((*cid) != -1) {
        BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
        BCM_EXIT;
    }

    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid CL settings")));

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_sched_cl_verify_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode)
{
    int rc = BCM_E_NONE;
    int cl_type_flags, cl_enhanced_flags, cl_weight_flags, cid;
    DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE configured_ipf_mode = DNX_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES;
    DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode;
    int  dnx_sand_rc = 0;



    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    cl_type_flags = (flags & DNX_DEVICE_COSQ_CL_MASK);
    cl_enhanced_flags = (flags & DNX_DEVICE_COSQ_CL_ENHANCED_MASK);
    cl_weight_flags = (flags & DNX_DEVICE_COSQ_CL_WFQ_MASK);

    /* consistency check of cl type */
    switch (cl_type_flags) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP:
            (*cl_mode) = DNX_TMC_SCH_CL_MODE_1;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ:
            (*cl_mode) = DNX_TMC_SCH_CL_MODE_2;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP:
            (*cl_mode) = DNX_TMC_SCH_CL_MODE_3;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ:
            (*cl_mode) = DNX_TMC_SCH_CL_MODE_4;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ:
            (*cl_mode) = DNX_TMC_SCH_CL_MODE_5;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl type flags parameter 0x%x\n"), unit, cl_type_flags));
            rc = BCM_E_PARAM;
            break;
    }

    /* consistency check of cl enhanced mode */
    switch (cl_enhanced_flags) {
        case 0:
            (*enhanced_mode) = DNX_TMC_CL_ENHANCED_MODE_DISABLED;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            (*enhanced_mode) = DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
            (*enhanced_mode) = DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl enhanced flags parameter 0x%x\n"), unit, cl_enhanced_flags));
            rc = BCM_E_PARAM;
            break;
    }
    /* consistency check of cl weight mode */
    switch (cl_weight_flags) {
        case 0:
            (*weight_mode) = DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL:
            ipf_mode = (BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT == cl_weight_flags) ? DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE : DNX_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL; 
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_ipf_mode_get,(unit, &configured_ipf_mode)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, get ipf mode, dnx_sand error 0x%x, error 0x%x\n"), unit, dnx_sand_rc, rc));
                break;
            }
            /* ipf mode not initialized*/
            if (configured_ipf_mode == DNX_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES){
                uint32 dnx_sand_rc;
                dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_ipf_mode_set,(unit, ipf_mode)));
                if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                    rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, set ipf mode %d, dnx_sand error 0x%x, error 0x%x\n"), unit, ipf_mode, dnx_sand_rc, rc));
                    break;
                }
            }
            else if(configured_ipf_mode != ipf_mode){
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, you can not use inverse and proportinal Independent per flow CL\n"), unit));
                rc = BCM_E_PARAM;
                break;
            }
            (*weight_mode) = DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET:
            (*weight_mode) = DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS:
            (*weight_mode) = DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl weight flags parameter 0x%x\n"), unit, cl_weight_flags));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);

    /* consistency check across {type, enhanced mode, weight mode } */
    rc = _bcm_dnx_sched_cl_profile_get(unit, (*cl_mode), (*enhanced_mode), (*weight_mode), TRUE, &cid);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* static */ int
_bcm_dnx_sched_cl_nbr_discrete_levels_get(int unit, int cl_mode, int *nbr_levels)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch(cl_mode) {
        case DNX_TMC_SCH_CL_MODE_1:
            (*nbr_levels) = 0;
            break;

        case DNX_TMC_SCH_CL_MODE_2:
            (*nbr_levels) = 2;
            break;

        case DNX_TMC_SCH_CL_MODE_3:
            (*nbr_levels) = 3;
            break;

        case DNX_TMC_SCH_CL_MODE_4:
            (*nbr_levels) = 3;
            break;

        case DNX_TMC_SCH_CL_MODE_5:
            (*nbr_levels) = 4;
            break;

        default:
            (*nbr_levels) = 0;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* static */ int
_bcm_dnx_sched_cl_default_cl_weights_get(int unit, int cl_mode, int *weights)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(weights, 0, (sizeof(int) * DNX_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));

    switch(cl_mode) {
        case DNX_TMC_SCH_CL_MODE_1:
            break;

        case DNX_TMC_SCH_CL_MODE_2:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            break;

        case DNX_TMC_SCH_CL_MODE_3:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case DNX_TMC_SCH_CL_MODE_4:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case DNX_TMC_SCH_CL_MODE_5:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            *(weights + 3) = 8;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_sched_cl_dynamic_profile_init(int unit)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_sched_class_template_add(int unit, int core,
                                    int mode,
                                    int enhanced_mode,
                                    int weight_mode,
                                    int *weights,
                                    int flags,
                                    int *template,
                                    int *is_allocated,
                                    int ref_cnt)
{
    int                              rc = BCM_E_NONE;
    bcm_dnx_cosq_sched_class_data_t  class_data;
    int                              expected_template = -1;
    int                              ref_count, count;



    BCMDNX_INIT_FUNC_DEFS;
    ref_count = (ref_cnt > 0) ? ref_cnt : 1;

    /* consistency check */
    if (flags & BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID) {
        expected_template = (*template);
    }

    DNX_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, mode, enhanced_mode, weight_mode, weights);

    for (count = 0; count < ref_count; count++) {
        rc = _bcm_dnx_am_template_cosq_sched_class_allocate(unit, core, flags, (int *)&class_data, is_allocated, template);

        BCMDNX_IF_ERR_EXIT(rc);

        /* consistency check */
        if (expected_template != -1) {
            rc = (expected_template != (*template)) ? BCM_E_INTERNAL : rc; 
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Unexpected Sched Class Template, Expected(%d) Actual(%d)\n"), unit, expected_template, (*template)));        
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * initialize cl profiles.
 * Only fixed profiles are initialized
 *
 * Consider adding support for profile management via template (discrete weights)
 */
static int
_bcm_dnx_sched_cl_profile_init(int unit)
{
    int rc = BCM_E_NONE;
    DNX_TMC_SCH_SE_CL_CLASS_TABLE *cl_class_table = NULL, *exact_cl_class_table = NULL;
    uint32 dnx_sand_rc;    
    int weights[DNX_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS];
    int template, flags = BCM_DNX_AM_TEMPLATE_FLAG_ALLOC_WITH_ID, is_allocated;    
    int core ;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    BCMDNX_ALLOC(cl_class_table, sizeof(DNX_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }
    BCMDNX_ALLOC(exact_cl_class_table, sizeof(DNX_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (exact_cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    BCM_DNX_CORES_ITER(BCM_CORE_ALL, core){
        DNX_TMC_SCH_SE_CL_CLASS_TABLE_clear(cl_class_table);
        DNX_TMC_SCH_SE_CL_CLASS_TABLE_clear(exact_cl_class_table);    
    
        cl_class_table->nof_class_types = bcm_dnx_cosq_cl_cid_last;
    
        /* weight mode - independent */
        sal_memset(weights, 0, (sizeof(int) * DNX_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));
    
        /* initialization of default templates. Default templates are allocated thus giving them */
        /* a reference count of one. This will ensure (without any additional checks) that the   */
        /* default templates nver get freed.                                                     */
        rc = _bcm_dnx_am_template_cosq_sched_class_init(unit);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 3
         */
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_ind, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_ind_ehp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_ind_elp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode3_ind;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_ind_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_ind_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 4
         */
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_ind, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_ind_ehp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_ind_elp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode4_ind;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_ind_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_ind_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 5
         */
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_ind, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_ind_ehp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_ind_elp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode5_ind;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_ind_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_ind_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 1
         */
        /* weight mode - none.  setting weights mode to DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST */
        /* causes error.  Instead set h/w to DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW. */
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode1, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode1_ehp_fq, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode1_elp_fq, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode1;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode1_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode1_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_1, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * When discrete weight functionality will be supported this will be via
         * template management
         */
        /* weight mode - discrete flow */
        /*
         * discrete flow - mode 3
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_3, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_des, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_des_ehp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_des_elp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode3_des;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_des_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_des_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 4
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_4, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_des, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_des_ehp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_des_elp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode4_des;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_des_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_des_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 5
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_5, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_des, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_des_ehp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_des_elp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode5_des;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_des_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_des_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 2
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_2, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_des, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_des_ehp_fq, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_des_elp_fq, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode2_des;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode2_des_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode2_des_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /* weight mode - discrete per class flow */
        /*
         * discrete per class flow - mode 3
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_3, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_cls, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_cls_ehp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode3_cls_elp_fq, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode3_cls;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_cls_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode3_cls_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_3, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 4
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_4, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_cls, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_cls_ehp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode4_cls_elp_fq, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode4_cls;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_cls_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode4_cls_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_4, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 5
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_5, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_cls, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_cls_ehp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode5_cls_elp_fq, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode5_cls;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_cls_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode5_cls_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_5, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 2
         */
        _bcm_dnx_sched_cl_default_cl_weights_get(unit, DNX_TMC_SCH_CL_MODE_2, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_cls, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_cls_ehp_fq, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DNX_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dnx_cosq_cl_cid_mode2_cls_elp_fq, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dnx_cosq_cl_cid_mode2_cls;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_DISABLED, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode2_cls_ehp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dnx_cosq_cl_cid_mode2_cls_elp_fq;
        rc = _bcm_dnx_sched_class_template_add(unit, core, DNX_TMC_SCH_CL_MODE_2, DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP, DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * configure h/w
         */
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_table_set,(unit, core, cl_class_table, exact_cl_class_table)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up cl param table\n"), unit));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }
    rc = _bcm_dnx_sched_cl_dynamic_profile_init(unit);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(cl_class_table);
    BCM_FREE(exact_cl_class_table);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_priority_mode_to_nof_priorities(int unit, 
                                                DNX_TMC_EGR_PORT_PRIORITY_MODE priority_mode, 
                                                int* nof_priorities)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (priority_mode)
    {
    case DNX_TMC_EGR_PORT_ONE_PRIORITY:
      *nof_priorities = 1;
      break;
    case DNX_TMC_EGR_PORT_TWO_PRIORITIES:
      *nof_priorities = 2;
      break;
    case DNX_TMC_EGR_PORT_EIGHT_PRIORITIES:
      *nof_priorities = 8;
      break;
    default:
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priority type is invalid"), unit));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_sched_init(int unit)
{
    bcm_error_t                 rc = BCM_E_NONE;
    int                         flow_id = 0, core = 0;
    int                         priority_i = 0;
    bcm_port_t                  port_i = 0;
    bcm_gport_t                 gport = 0;
    uint32                      res_mngr_flags = 0, nof_priorities = 0, fap_port, flags;
    uint32                      dnx_sand_rc;
    DNX_TMC_SCH_FLOW            flow_config, exact_flow_config;
    DNX_TMC_SCH_SE_INFO         se_config;
    DNX_TMC_SCH_SE_ID           se_index = 0;            
    int                         index;
    int                         is_coldboot = TRUE;
    pbmp_t                      ports_map;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if (is_coldboot) {
        BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {

                /*Init ISQ port to invalid port*/
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.isq_port.set(unit, core, BCM_GPORT_INVALID));
                /* initialize FMQ class resources as not being allocated */
                for (index = 0; index < DNX_DEVICE_FMQ_CLASS_PORTS; index++) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, BCM_GPORT_INVALID));
                }

        }

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_ipf_mode_set,(unit, DNX_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
          rc = dnx_translate_sand_success_failure(dnx_sand_rc);
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in setting ipf initial value, dnx_sand error 0x%x, rc error 0x%x"), unit, dnx_sand_rc, rc));
        }
    }

    /* HR resources for ports. */
    /* In JER2_ARAD each Port-TC has HR resource */
    res_mngr_flags = BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
    rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_map);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                           "unit %d, failed to get ports bmp, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCM_PBMP_ITER(ports_map, port_i) {

        DNXC_IF_ERR_EXIT(dnx_port_sw_db_flags_get(unit, port_i, &flags));
        if (!(DNX_PORT_IS_ELK_INTERFACE(flags) || DNX_PORT_IS_STAT_INTERFACE(flags))) {
            BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); 
            rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                continue;
            }
            if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Invalid fap port %d\n"), fap_port));
                continue;
            }

            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities));
            
            for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
            {
              dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
              if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                  rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                  BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, dnx_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, dnx_sand_rc, rc));
              }
               
              if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit))
              {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                  continue;
              }
              flow_id =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_index)));

              if (!SOC_WARM_BOOT(unit)) {
                rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                LOG_VERBOSE(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));
                }
                if (is_coldboot) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0)); 
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
                }
            }
        }
    }
    res_mngr_flags = 0x0;

    BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        /* additional HR resource allocated to hookup objects just created */
        if (!SOC_WARM_BOOT(unit)) {
            rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, DNX_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            se_index =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.set(unit, core, se_index));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_flow.set(unit, core, flow_id));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_type.set(unit, DNX_TMC_SCH_SE_TYPE_FQ));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se_class.set(unit, 0));
            LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                "unit %d, default fq for hookup, flow_id(%d/0x%x) se_index(%d/0x%x)\n"), unit, flow_id, flow_id, se_index, se_index));

            DNX_TMC_SCH_FLOW_clear(unit, &flow_config);

            flow_config.flow_type = DNX_TMC_FLOW_AGGREGATE;
            flow_config.is_slow_enabled = FALSE;
            flow_config.sub_flow[0].is_valid = TRUE;
            flow_config.sub_flow[0].id = flow_id;

            flow_config.sub_flow[0].credit_source.se_type = DNX_TMC_SCH_SE_TYPE_HR;
            flow_config.sub_flow[0].credit_source.se_info.hr.sp_class = DNX_TMC_SCH_FLOW_HR_CLASS_EF1;
            flow_config.sub_flow[0].credit_source.id = DNX_TMC_HR_SE_ID_MIN_JER2_ARAD; /* connect to first HR */
            /* Set SE to be disabled so it wont grant credits */
            flow_config.sub_flow[0].shaper.max_burst = 0x0;

            DNX_TMC_SCH_SE_INFO_clear(&se_config);
            se_config.id = se_index;
            se_config.state = DNX_TMC_SCH_SE_STATE_ENABLE;
            se_config.type = DNX_TMC_SCH_SE_TYPE_FQ;
            se_config.type_info.fq.no_info=0;
            se_config.is_dual = FALSE;
            se_config.group = DNX_TMC_SCH_GROUP_AUTO;

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
            if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
    if (is_coldboot) {
        /* state restored during warmboot */
        rc = _bcm_dnx_sched_cl_profile_init(unit);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl profile init failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /*ingress scheduler init*/
    if (!SOC_IS_QAX(unit)) { 
        if (is_coldboot) 
        {
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_init, (unit)));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    SOC_DNX_WARMBOOT_RELEASE_HW_MUTEX(rc);
    if(rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              " Failed while executing the macro SOC_DNX_WARMBOOT_RELEASE_HW_MUTEX.\n")));
    }
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control reception (Inband/Out-of-band) */
static int
_bcm_dnx_cosq_cal_reception_fc_path_add(int unit,
                           int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port)
{
    bcm_error_t                     rc = BCM_E_NONE;
    soc_error_t                     soc_rc = SOC_E_NONE;
    DNX_TMC_FC_CAL_IF_INFO          cal_if_info;
    DNX_TMC_FC_REC_CALENDAR         *cal_buff = NULL;
    DNX_TMC_FC_REC_CAL_DEST         cal_dest = DNX_TMC_FC_REC_CAL_DEST_NONE, 
                                    cal_dest_ori = DNX_TMC_FC_REC_CAL_DEST_NONE;
    DNX_TMC_FC_PFC_GENERIC_BITMAP   generic_bm;    
    bcm_dnx_cosq_rx_cal_t           _rx_cal;
    int                             is_llfc;
    int                      valid, nof_ilkn_ports;
    uint32                   flow_id, cl_id, target_id=0;
    int                     core=0;
    bcm_port_t target_port = 0;
    uint32 phy_port = 0;
    int is_interface_port = 0;
    _bcm_dnx_pfc_bitmap_type pfc_bmp_type;
    uint32 base_queue_pair, nof_priorities;
    uint32 target_tm_port;
    int old_generic_bm_id = 0, generic_bm_is_last = 0, new_generic_bm_id = -1, generic_bm_is_allocated = 0;
    int pfc_bitmap_class = 0;
    int is_fc_mub = 0;
    DNX_TMC_FC_PFC_GEN_BMP_SRC_TYPE   pfc_src_type = DNX_TMC_FC_PFC_GEN_BMP_SRC_TYPES;
    uint32 is_pfc_gen_valid = 0;
    DNX_TMC_FC_PFC_MAP pfc_map;
    uint32 protocol_offset = 0, interface_type = 0;

    BCMDNX_INIT_FUNC_DEFS;

    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT;
    BCM_DNX_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DNX_DEFS_GET(unit, nof_interlaken_ports);  

    if (source->flags & BCM_COSQ_FC_MUB) {
        is_fc_mub = 1;
    }

    DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

    if (!is_fc_mub) {
        BCMDNX_ALLOC(cal_buff, (sizeof(DNX_TMC_FC_REC_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
        if (cal_buff == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }

        DNX_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        if (is_fc_inband) {
            if (fc_calender_port >= nof_ilkn_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        }
        else {
            if (fc_calender_port >= SOC_DNX_MAX_OOB_PORTS) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        }

        if ((_rx_cal.valid != TRUE) && (BCM_GPORT_IS_SCHEDULER(target->port) == 0x0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
        }

        /* retrieve calender setting */
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_rec_cal_get,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _rx_cal.intf, soc_rc));
        }
    
        if (is_fc_inband) {
            /* check it does not overlap with the LLFC calender space */
            if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] != SOC_DNX_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
                if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DNX_FC_INBAND_INTLKN_CAL_LLFC_MODE1) {
                    if (source->calender_index == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                }
                else if (SOC_DNX_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DNX_FC_INBAND_INTLKN_CAL_LLFC_MODE2) {
                    if ((source->calender_index % 16) == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                }
            }
        }
    }

    rc = _bcm_dnx_cosq_fap_port_get(unit, target->port, &target_tm_port, &core, &is_interface_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    is_llfc = (is_interface_port) ? TRUE : FALSE;

    if (SOC_IS_ARDON(unit)) {
        if (!BCM_GPORT_IS_SCHEDULER(target->port) && !BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port))  {
            /* Unknow case */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Setting Schedualer CL as target gport (0x%x) supported only for Ardon (FCV)"), target->port));
        }

        valid = is_for_delete ? 0x0 : 0x1;
       
        if (BCM_GPORT_IS_SCHEDULER(target->port)) {
            /* 
             * Mapping FCV calander bit map to SCH CL 
             * Source is calender_index. Target is CL index. 
             * extract CL index: Target Scheduler gport =  (64 * 1024) + CL_Index * 4
             */
            flow_id = BCM_GPORT_SCHEDULER_GET(target->port);
            cl_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit, mbcm_dnx_sch_flow2se_id, (unit, flow_id)));

            rc = jer2_arad_fc_shr_mapping(unit, source->calender_index, cl_id, 0x0 /* select */, valid);
            BCMDNX_IF_ERR_EXIT(rc);
        } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port)) {
            /* 
             * Mapping FCV calander bit map to Pair-Queue 
             * Source is calender_index. Target is pair-queue index. 
             */
            rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.get(unit, target_port, &base_queue_pair);
            BCMDNX_IF_ERR_EXIT(rc);

            pfc_map.mode = DNX_TMC_FC_PFC_MAP_EGQ;
            pfc_map.index = base_queue_pair + target->cosq;
            pfc_map.valid = valid;
            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_mapping_set, (unit, source->calender_index/DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD, source->calender_index%DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);
        }
    } 
    else if(target->flags & BCM_COSQ_FC_RETRANSMIT){
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, use SOC Property to set ILKN Retransmit Entry for Jericho\n"), unit));
        }
        else {
            /* ILKN Retransmit Entry */
            cal_dest = DNX_TMC_FC_REC_CAL_DEST_RETRANSMIT;        
            target_id = fc_calender_port;
            is_llfc = FALSE;
        }
    }
    else if (is_llfc) {
        /* support LLFC setting for OOB interface. Inband Interface calender settings  */
        /* are via SOC properties.                                                     */
        if (is_fc_inband) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, LLFC setting not valid for inband interface (%d)\n"), unit, fc_calender_port));
        }

        /* validate source flags */
        if ((source->flags & (~(BCM_COSQ_FC_MUB))) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
        }

        /* validate source cos */
        if (!((source->cosq == 0) || (source->cosq == -1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq specified(0x%x)"), unit, source->cosq));
        }

        /* validate target cos */
        if (target->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
        }

        target_id = 0;
        cal_dest = DNX_TMC_FC_REC_CAL_DEST_NIF_LL;            

         /*get target type*/
         rc = dnx_port_sw_db_interface_type_get(unit, target_port, &interface_type);
         BCMDNX_IF_ERR_EXIT(rc);

         if((interface_type == SOC_PORT_IF_ILKN) && !SOC_IS_ARADPLUS_AND_BELOW(unit)) {
             rc = dnx_port_sw_db_protocol_offset_get(unit, target_port, 0, &protocol_offset /* ilkn id */);
             BCMDNX_IF_ERR_EXIT(rc);

             /*get nif port*/
             rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_ilkn_nif_port_get, (unit, protocol_offset, &target_id)); 
             BCMDNX_IF_ERR_EXIT(rc);
         } else {
             rc = dnx_port_sw_db_first_phy_port_get(unit, target_port, &phy_port /*one based*/);
             if (rc != BCM_E_NONE) {
                 BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error retreiving phy port for port (0x%x)\n"), unit, target->port));
             }
             target_id = phy_port - 1;
         }
    }
    else { /* PFC Configuration (Not LLFC or Retransmit) */
        /* validate source flags */
        if ((source->flags & (~(BCM_COSQ_FC_MUB))) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* validate target flags */
        if ((target->cosq >= 0) && (target->cosq <= 7)) {   /* Reaction point: port+cosq */ 
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
            }
        }
        
        if (target->cosq == -1) {                           /* Reaction point: port */ 
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
            }
        }        

        /* validate source cos */
        if ((source->cosq != -1) && (source->cosq != 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq specified(0x%x)"), unit, source->cosq));
        }

        /* validate target cos */
        if ((target->cosq < -1) || (target->cosq > 7)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
        }

        rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.get(unit, target_port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Check if the port has 8 queues/priorities - set DEST TYPE accordingly */
        rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, target_port, &nof_priorities);
        DNXC_IF_ERR_EXIT(rc);

        DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

        if (!is_for_delete) {
            if (target->cosq == -1) { /* Reaction point: port */ 
                if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) || is_fc_mub) {
                    cal_dest = DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT;
                }
                else {
                    if (nof_priorities == 8) {
                        cal_dest = DNX_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY;
                        target_id = base_queue_pair;
                    }
                    else if (nof_priorities == 2) {
                        cal_dest = DNX_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY;
                        target_id = base_queue_pair;
                    }
                    else if (nof_priorities == 1) {
                        cal_dest = DNX_TMC_FC_REC_CAL_DEST_PFC; 
                        target_id = base_queue_pair + target->cosq;
                    }
                    target_id += ((core == 1) ? JER2_ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                }
            }
            else {                    /* Reaction point: port+cosq */
                if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                    cal_dest = DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_UP;
                }
                else if (target->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                    cal_dest = DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_DOWN;
                }
                else if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) || is_fc_mub){
                    cal_dest = DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC;                
                }
                else {
                    cal_dest = DNX_TMC_FC_REC_CAL_DEST_PFC;
                    target_id = base_queue_pair + target->cosq;
                    target_id += ((core == 1) ? JER2_ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                }
            }
        }

        if (is_fc_mub) {
            cal_dest_ori = DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC;
        }
        else {
            cal_dest_ori = (cal_buff + source->calender_index)->destination;
        }

        if ((cal_dest_ori == DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC) || (cal_dest == DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC))
        {
            /* get pfc generic bitmap class */
            if (SOC_IS_JERICHO(unit)) {
                if (!is_fc_mub) {
                    pfc_bitmap_class = (is_fc_inband) ? (fc_calender_port) : (fc_calender_port+6);
                }
                else {
                    pfc_bitmap_class = fc_calender_port;
                }
            }
            else {
                pfc_bitmap_class = 0;
            }

            pfc_src_type = (is_fc_mub) ? (DNX_TMC_FC_PFC_GEN_BMP_SRC_MUB) : 
                                         ((is_fc_inband)? (DNX_TMC_FC_PFC_GEN_BMP_SRC_ILKN_INB) : 
                                                          (DNX_TMC_FC_PFC_GEN_BMP_SRC_OOB));

            /* check if pfc generic bitmap can be used */
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, pfc_bitmap_class, &is_pfc_gen_valid)));
            if (is_pfc_gen_valid == FALSE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_pfc_bitmap_get(unit, pfc_bmp_type, target_port, target->cosq, &generic_bm));
            }

            if (!is_fc_mub) 
            {
                if (cal_dest_ori == DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC) {
                    old_generic_bm_id = (cal_buff + source->calender_index)->id;
                }
                else {
                    old_generic_bm_id = SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
                }

                rc = _bcm_dnx_am_template_fc_generic_pfc_mapping_exchange(unit, pfc_bitmap_class, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, new_generic_bm_id, TRUE)));
                }

                if (cal_dest == DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC) {
                    target_id = new_generic_bm_id;
                }

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, old_generic_bm_id, FALSE)));
                }
            }
            else {
                new_generic_bm_id = source->calender_index;
            
                rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, new_generic_bm_id, &generic_bm);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, source->calender_index, (!is_for_delete))));

                target_id = new_generic_bm_id;
            }
        }
    }

    if (!is_fc_mub) {
        /* Delete only */
        if (is_for_delete) {
            cal_dest = DNX_TMC_FC_REC_CAL_DEST_NONE;
        }

        /* update calender entry */
        (cal_buff + source->calender_index)->destination = cal_dest;
        (cal_buff + source->calender_index)->id = target_id;

        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_rec_cal_set,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) setting, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"), _rx_cal.intf, soc_rc));
        }
    }

exit:
    if (cal_buff != NULL) {    
        BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           )
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    uint32                   dnx_sand_rc;
    DNX_TMC_FC_CAL_IF_INFO        cal_if_info;
    DNX_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    int                      cal_index, nof_ilkn_ports;
    bcm_dnx_cosq_rx_cal_t   _rx_cal;
    DNX_TMC_FC_REC_CAL_DEST       cal_dest = DNX_TMC_FC_REC_CAL_DEST_NONE;
    uint32                   dev_id;
    int                      internal_target_id;
    int                      queue_id;
    DNX_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int bm_tmp, generic_bm_id;
    uint8                 queue_found = FALSE;
    uint32                    fap_port = 0, tc = 0;
    soc_port_t port;
    int                     core=0; 
    int pfc_bitmap_class = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DNX_DEFS_GET(unit, nof_interlaken_ports);

    /* Init values */    
    dev_id =  (unit);

    BCMDNX_ALLOC(cal_buff, (sizeof(DNX_TMC_FC_REC_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    DNX_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
    for (cal_index = 0; cal_index < DNX_TMC_FC_OOB_CAL_LEN_MAX; cal_index++) {
        DNX_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
    }

    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.rx.get(unit, fc_calender_port, &_rx_cal));
    }
    else {
        if (fc_calender_port >= SOC_DNX_MAX_OOB_PORTS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.rx.get(unit, fc_calender_port, &_rx_cal));
    }

    if (_rx_cal.valid != TRUE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
    }

    /* Get Calender setting */
    soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_rec_cal_get,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
    if (SOC_FAILURE(soc_rc)) {
        BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _rx_cal.intf, soc_rc));
    }

    if ( (source->calender_index < 0) || (source->calender_index >= cal_if_info.cal_len) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, out of range calender index (%d)\n"), unit, source->calender_index));
    }

    /* Calendar entry is according to SOURCE, so we have only one target */
    cal_dest = cal_buff[source->calender_index].destination;
    internal_target_id = cal_buff[source->calender_index].id;

    if(*target_count >= max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if(cal_dest == DNX_TMC_FC_REC_CAL_DEST_RETRANSMIT)
    {
        target[*target_count].flags = BCM_COSQ_FC_RETRANSMIT;
        
        /* NIF ID to GPORT */
        rc = bcm_dnx_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, internal_target_id, &target[*target_count].port);
        BCMDNX_IF_ERR_EXIT(rc);

        *target_count += 1;
    }
    else if(cal_dest == DNX_TMC_FC_REC_CAL_DEST_NIF_LL)
    {
        target[*target_count].cosq = -1;
        
        /* NIF ID to GPORT */
        rc = bcm_dnx_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, cal_buff[source->calender_index].id, &target[*target_count].port);
        BCMDNX_IF_ERR_EXIT(rc);

        *target_count += 1;
    }
    else if(cal_dest == DNX_TMC_FC_REC_CAL_DEST_GENERIC_PFC)
    {
        generic_bm_id = cal_buff[source->calender_index].id;

        if (SOC_IS_JERICHO(unit)) {
            pfc_bitmap_class = (is_fc_inband) ? (fc_calender_port) : (fc_calender_port+6);
        }
        else {
            pfc_bitmap_class = 0;
        }

        /* Get the current Profile */
        rc = _bcm_dnx_am_template_fc_generic_pfc_mapping_data_get(unit, pfc_bitmap_class, generic_bm_id, &generic_bm); 
        BCMDNX_IF_ERR_EXIT(rc);

        for(queue_id = 0; queue_id < DNX_TMC_FC_PFC_GENERIC_BITMAP_SIZE; queue_id++)
        {
            bm_tmp = generic_bm.bitmap[queue_id / 32];
            if(bm_tmp & DNX_SAND_BIT(queue_id % 32))
            {
                /* Queue Pair to FAP Port / TC */
                dnx_sand_rc = jer2_arad_egr_queuing_q_pair_port_tc_find(dev_id, queue_id, &queue_found, &fap_port, &tc);
                DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

                /* FAP Port to Local Port */
                rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
                BCMDNX_IF_ERR_EXIT(rc);

                if(*target_count >= max_target) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
                }

                /* Local Port to GPORT */
                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);
            
                target[*target_count].cosq = tc;

                *target_count += 1;
            }
        } /* queue_id loop */        
    }
    else if(cal_dest == DNX_TMC_FC_REC_CAL_DEST_PFC)
    {
        /* Queue Pair to FAP Port / TC */
        dnx_sand_rc = jer2_arad_egr_queuing_q_pair_port_tc_find(dev_id, cal_buff[source->calender_index].id, &queue_found, &fap_port, &tc);
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        /* FAP Port to Local Port */
        rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        target[*target_count].cosq = tc;
        *target_count += 1;
    }
    else if(cal_dest == DNX_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY || cal_dest == DNX_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY)
    {     
        /* FAP Port to Local Port */
        rc = dnx_port_sw_db_tm_to_local_port_get(unit, core, cal_buff[source->calender_index].id, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        *target_count += 1;
    }

exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}


static int _bcm_dnx_cosq_pfc_bitmap_get(int unit, 
                                          _bcm_dnx_pfc_bitmap_type pfc_bmp_type, 
                                          bcm_port_t port, 
                                          bcm_cos_queue_t cosq, 
                                          DNX_TMC_FC_PFC_GENERIC_BITMAP *generic_bm)
{
    soc_error_t rc = SOC_E_NONE;

    uint32 base_queue_pair, nof_priorities;
    soc_pbmp_t same_interface_ports;
    soc_port_t port_i;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* Mapping PFC source to port target */
    if (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT) {
        /* get base queue and nof priorities of port */
        rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
        DNXC_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        DNXC_IF_ERR_EXIT(rc);

        SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair, nof_priorities);

        generic_bm->core = core;
    }
    /* Mapping PFC source to port target */
    else if ((pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT_TC) ||
             (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_UP) || 
             (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_DOWN)) {
        /* get base queue and nof priorities of port */
        rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
        DNXC_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        DNXC_IF_ERR_EXIT(rc);

        if (cosq > nof_priorities) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, cosq (%d) out of range [0, %d]\n"), unit, cosq, (nof_priorities-1)));
        }

        if (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT_TC) {
            SHR_BITSET_RANGE(generic_bm->bitmap, (base_queue_pair + cosq), 1);
        }      
        else if (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_UP) {
            SHR_BITSET_RANGE(generic_bm->bitmap, (base_queue_pair + cosq), (nof_priorities - cosq));
        }
        else {
            SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair, (cosq + 1));
        }

        generic_bm->core = core;
    }
    /* Mapping PFC source to relevant priority in all ports on same interface */
    else if (pfc_bmp_type == _BCM_DNX_PFC_BITMAP_INTF_TC) {
        /* get all the local port belong to specific interface */
        rc = dnx_port_sw_db_ports_to_same_interface_get(unit, port, &same_interface_ports);
        DNXC_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        DNXC_IF_ERR_EXIT(rc);

        SOC_PBMP_ITER(same_interface_ports, port_i) {
            /* get base queue of each port */
            rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
            DNXC_IF_ERR_EXIT(rc);

            if (cosq > nof_priorities) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, cosq (%d) out of range [0, %d]\n"), unit, cosq, (nof_priorities-1)));
            }

            SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair + cosq, 1);
        }

        generic_bm->core = core;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid pfc_bmp_type(0x%x)"), unit, pfc_bmp_type));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control reception (Inband) */
static int
_bcm_dnx_cosq_noncal_reception_fc_path_add(int unit,
                                             int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port)
{
    bcm_error_t rc = BCM_E_NONE;
    soc_error_t soc_rc = SOC_E_NONE;
    int is_llfc;
    DNX_TMC_FC_REC_INBND_INFO inbnd_info;
    int core;
    int is_safc = 0;
    uint32 internal_id = 0;
    uint32 source_tm_port;
    DNX_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int old_generic_bm_id = 0, generic_bm_is_last = 0, new_generic_bm_id = -1, generic_bm_is_allocated = 0;
    int cur_generic_bm_id = 0;
    DNX_TMC_FC_PFC_MAP pfc_map;
    uint32 phy_port = 0;
    int cosq_index = 0, cosq_start = 0, cosq_end = 0;
    bcm_dnx_cosq_pfc_rx_type_t cur_pfc_type = _BCM_DNX_COSQ_PFC_RX_NONE, 
                               ori_pfc_type = _BCM_DNX_COSQ_PFC_RX_NONE;
    uint32 source_phy_port, target_phy_port;

    bcm_port_t source_port = 0, target_port = 0;
    int is_interface_port = 0;
    _bcm_dnx_pfc_bitmap_type pfc_bmp_type;
    uint32 base_queue_pair = 0, queue_pair_index = 0;
    uint32 nof_priorities = 0, priority_bmp = 0;
    bcm_dnx_cosq_pfc_rx_type_t sw_state_rx_pfc_map_info;
    DNX_TMC_FC_PFC_GEN_BMP_SRC_TYPE   pfc_src_type = DNX_TMC_FC_PFC_GEN_BMP_SRC_NIF;
    uint32 is_pfc_gen_valid = 0;

    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_FC_REC_INBND_INFO_clear(&inbnd_info);

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    rc = bcm_dnx_cosq_user_port_get(unit, source->port, &source_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = dnx_port_sw_db_local_to_out_port_priority_get(unit, source_port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    if (IS_CPU_PORT(unit, source_port)) { /* enable CFC to react to CMIC FC */
        /* consistency checks */
        if ((source->cosq < -1) || (source->cosq >= (int)nof_priorities)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

       /* validate target port and taget cos */
        if (!(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
            BCMDNX_IF_ERR_EXIT(rc);

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(%d) and target port (%d) do not match"), unit, source_port, target_port));
            }

            if ((target->cosq != 0) && (target->cosq != -1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source cosq(%d) and target cosq (%d) do not match\n"), unit, source->cosq, target->cosq));
            }
        }

        if (source->cosq == -1) {
            for (cosq_index = 0; cosq_index < nof_priorities; cosq_index++) {
                SHR_BITSET(&priority_bmp, cosq_index);
            }
        }
        else {
            SHR_BITSET(&priority_bmp, source->cosq);
        }

        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_cmic_rx_set,(unit, source_port, priority_bmp, !is_for_delete));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CMIC FC on port(%d), error 0x%x\n"), unit, source->port, soc_rc));
        }
    }
    else if (is_llfc) { /* Reaction point: Interface */       
        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* validate target flags */
        if ((target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
        }

        /* validate target port and taget cos */
        if (!(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            rc = _bcm_dnx_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
            BCMDNX_IF_ERR_EXIT(rc);

            if (!is_interface_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port target(0x%x), it should be interface gport"), unit, target->port));
            }

            rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
            BCMDNX_IF_ERR_EXIT(rc);

            /* check target interface == source interface */
            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
            BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

            if (source_phy_port != target_phy_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
            }

            if (target->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
            }
        }      

        /* if enable llfc reception on NIF, disable llfc in mac and port register */
        inbnd_info.mode = DNX_TMC_FC_INBND_MODE_LL;

        /* Delete only */
        if (is_for_delete) {
            /* if disable llfc reception on NIF, disable llfc in mac and port register */
            inbnd_info.mode = DNX_TMC_FC_INBND_MODE_DISABLED;
        }

        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_set,(unit, source_port, 0, inbnd_info.mode));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config LLFC port(%d), error 0x%x\n"), unit, source->port, soc_rc));
        }
    }
    else {
        rc = dnx_port_sw_db_first_phy_port_get(unit, source_port, &phy_port);
        DNXC_IF_ERR_EXIT(rc);
#ifdef BCM_JER2_JERICHO_SUPPORT
        if (SOC_IS_JERICHO(unit)) {
            rc = MBCM_DNX_DRIVER_CALL(unit,
                    mbcm_dnx_qsgmii_offsets_remove,
                    (unit, phy_port, &phy_port));
            DNXC_IF_ERR_EXIT(rc);
        }
#endif
        internal_id = phy_port - 1;

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, source_port, &source_tm_port, &core);
        DNXC_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_tm_port_to_base_q_pair_get(unit, core, source_tm_port, &base_queue_pair);
        DNXC_IF_ERR_EXIT(rc);
        
        if (target->cosq == -1) { /* Reaction point: port */
            /* validate source flags */
            if ((source->flags & (~(BCM_COSQ_FC_INHERIT_UP||BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            }

            /* validate target flags */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
            }

            /* validate source cosq */
            if ((source->cosq < 0) || (source->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
            }

            /* validate target port and target cosq */
            if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
                rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

                if (source_phy_port != target_phy_port) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
                }

                if ((target->cosq != 0) && (target->cosq != -1)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
                }
            }

            cosq_start = cosq_end = source->cosq;
            if (source->flags & BCM_COSQ_FC_INHERIT_UP) {
                cosq_start = source->cosq;
                cosq_end = DNX_TMC_EGR_NOF_Q_PRIO_JER2_ARAD - 1;            
            }
            if (source->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                cosq_start = 0;
                cosq_end = source->cosq;            
            }
            cur_pfc_type = _BCM_DNX_COSQ_PFC_RX_PORT_OVER;

            /* check if pfc generic bitmap can be used */
            pfc_src_type = DNX_TMC_FC_PFC_GEN_BMP_SRC_NIF;
            BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, source->cosq, &is_pfc_gen_valid)));
            if (is_pfc_gen_valid == FALSE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
            }

            /*
             * check if current pfc map type conflict with existing configuration 
             * only one pfc map type can be configured on the same interface
             */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.get(unit, internal_id, &sw_state_rx_pfc_map_info));
            if ((sw_state_rx_pfc_map_info != _BCM_DNX_COSQ_PFC_RX_NONE) && 
                (sw_state_rx_pfc_map_info != _BCM_DNX_COSQ_PFC_RX_DEFAULT) &&
                (sw_state_rx_pfc_map_info != cur_pfc_type)) {

                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, unexpected pfc map type(%d) conflict with existing pfc map type(%d)\n"), unit,
                cur_pfc_type, sw_state_rx_pfc_map_info));
            }

            /* set info of pfc generic bitmap */
            DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
            if (!is_for_delete) {
                rc = _bcm_dnx_cosq_pfc_bitmap_get(unit, _BCM_DNX_PFC_BITMAP_PORT, 
                                                    source_port, source->cosq, &generic_bm);
                BCMDNX_IF_ERR_EXIT(rc);
            }

            for (cosq_index = cosq_start; cosq_index <= cosq_end; cosq_index++) {
                /* get info of pfc mapping from HW */
                soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_mapping_get, (unit, internal_id, cosq_index, &pfc_map));
                BCMDNX_IF_ERR_EXIT(soc_rc);

                if (pfc_map.mode == DNX_TMC_FC_PFC_MAP_GENERIC_BITMAP) {
                    old_generic_bm_id = pfc_map.index;
                }
                else {
                    old_generic_bm_id = SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
                }

                rc = _bcm_dnx_am_template_fc_generic_pfc_mapping_exchange(unit, cosq_index, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, new_generic_bm_id, TRUE)));
                }
                cur_generic_bm_id = new_generic_bm_id;

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, old_generic_bm_id, FALSE)));
                }

                /* set info of pfc mapping */
                if ((cur_pfc_type == _BCM_DNX_COSQ_PFC_RX_PORT_OVER) && (!is_for_delete)) {
                    pfc_map.mode = DNX_TMC_FC_PFC_MAP_GENERIC_BITMAP;
                    pfc_map.index = cur_generic_bm_id;
                    pfc_map.valid = 1;
                }
                else {
                    queue_pair_index = base_queue_pair + cosq_index;
                    queue_pair_index += ((core == 1) ? JER2_ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                    
                    pfc_map.mode = DNX_TMC_FC_PFC_MAP_EGQ;                    
                    pfc_map.index = queue_pair_index;
                    pfc_map.valid = 1;
                }

                /* set HW for pfc mapping */
                soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_mapping_set, (unit, internal_id, cosq_index, &pfc_map));
                BCMDNX_IF_ERR_EXIT(soc_rc);
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, cur_pfc_type));
            }
            else {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, _BCM_DNX_COSQ_PFC_RX_NONE));
            }
        }
        else { /* Reaction point: port+cosq */
            /* validate source flags */
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            }

            /* validate target flags */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
            }

            /* validate source cosq */
            if ((source->cosq < 0) || (source->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
            }

            /* validate target cosq */
            if ((target->cosq < 0) || (target->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
            }

            /* validate target port and target cosq */
            if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
                rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
                BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

                if (source_phy_port != target_phy_port) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
                }
            }

            cosq_index = source->cosq;
            /* set info of pfc generic bitmap */
            DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

            if (target->flags & (BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN)) {
                cur_pfc_type = _BCM_DNX_COSQ_PFC_RX_PORT_OVER;

                /* check if pfc generic bitmap can be used */
                pfc_src_type = DNX_TMC_FC_PFC_GEN_BMP_SRC_NIF;
                BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, source->cosq, &is_pfc_gen_valid)));
                if (is_pfc_gen_valid == FALSE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
                }

                if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_UP;
                }
                else if (target->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC_INHERIT_DOWN;
                }
                else {
                    pfc_bmp_type = _BCM_DNX_PFC_BITMAP_PORT_TC;                
                }
                if (!is_for_delete) {
                    rc = _bcm_dnx_cosq_pfc_bitmap_get(unit, pfc_bmp_type, 
                                                    source_port, source->cosq, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }

            /* get info of pfc mapping from HW */
            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_mapping_get, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);

            if (pfc_map.mode == DNX_TMC_FC_PFC_MAP_GENERIC_BITMAP) {
                ori_pfc_type = _BCM_DNX_COSQ_PFC_RX_PORT_OVER;
                old_generic_bm_id = pfc_map.index;
            }
            else {
                old_generic_bm_id = SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
            }

            if ((ori_pfc_type == _BCM_DNX_COSQ_PFC_RX_PORT_OVER) || (cur_pfc_type == _BCM_DNX_COSQ_PFC_RX_PORT_OVER))
            {
                rc = _bcm_dnx_am_template_fc_generic_pfc_mapping_exchange(unit, cosq_index, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, new_generic_bm_id, TRUE)));
                }
                cur_generic_bm_id = new_generic_bm_id;

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DNX_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    DNX_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, old_generic_bm_id, FALSE)));
                }
            }

            /* set info of pfc mapping */
            if ((cur_pfc_type == _BCM_DNX_COSQ_PFC_RX_PORT_OVER) && (!is_for_delete)) {
                pfc_map.mode = DNX_TMC_FC_PFC_MAP_GENERIC_BITMAP;
                pfc_map.index = cur_generic_bm_id;
                pfc_map.valid = 1;
            } else {
                queue_pair_index = base_queue_pair + target->cosq;
                queue_pair_index += ((core == 1) ? JER2_ARAD_EGR_NOF_BASE_Q_PAIRS : 0);

                pfc_map.mode = DNX_TMC_FC_PFC_MAP_EGQ;
                pfc_map.index = queue_pair_index;
                pfc_map.valid = 1;
            }

            /* set HW for pfc mapping */
            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_mapping_set, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);

            if (cur_pfc_type != _BCM_DNX_COSQ_PFC_RX_PORT_OVER) {
                rc = bcm_port_control_get(unit, source_port, bcmPortControlSAFCReceive, &is_safc);
                BCMDNX_IF_ERR_EXIT(rc);

                if(is_safc) {
                    inbnd_info.mode = DNX_TMC_FC_INBND_MODE_SAFC;
                }
                else {
                    inbnd_info.mode = DNX_TMC_FC_INBND_MODE_PFC;
                }

                /* Delete only */
                if (is_for_delete) {
                    inbnd_info.mode = DNX_TMC_FC_INBND_MODE_DISABLED;
                }

                soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_set,(unit, source_port, 0, inbnd_info.mode));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), error 0x%x\n"), unit, source->port, soc_rc));
                }
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, cur_pfc_type));
            }
            else {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, _BCM_DNX_COSQ_PFC_RX_NONE));
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             )
{
    bcm_error_t rc = BCM_E_NONE;
    soc_error_t soc_rc = SOC_E_NONE;
    int is_llfc;
    soc_port_t port;
    DNX_TMC_FC_INBND_MODE mode;
    uint32
        phy_port;
    soc_pbmp_t
        pbmp;
    uint32 
        interface_i;
    uint32 flags = 0;
    soc_port_if_t interface_type;
    bcm_dnx_cosq_pfc_rx_type_t sw_state_rx_pfc_map_info;
    uint32 priority_bmp = 0;
    int is_ena = 0;

    BCMDNX_INIT_FUNC_DEFS;

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    if(*target_count >= max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if (!is_llfc) 
    {
        
        /* Check all interfaces for FC configuration */

        rc = dnx_port_sw_db_valid_ports_get(unit, 0, &pbmp);
        DNXC_IF_ERR_EXIT(rc);

        SOC_PBMP_ITER(pbmp, port)
        {
            /* only relevant to network interface */
            rc = dnx_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(rc) || (!DNX_PORT_IS_NETWORK_INTERFACE(flags))) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = dnx_port_sw_db_interface_type_get(unit, port, &interface_type);        
            if (SOC_FAILURE(soc_rc) || 
			    (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            rc = dnx_port_sw_db_first_phy_port_get(unit, port, &phy_port);
            DNXC_IF_ERR_EXIT(rc);

#ifdef BCM_JER2_JERICHO_SUPPORT
            if (SOC_IS_JERICHO(unit)) {
                rc = MBCM_DNX_DRIVER_CALL(unit,
                        mbcm_dnx_qsgmii_offsets_remove,
                        (unit, phy_port, &phy_port));
                DNXC_IF_ERR_EXIT(rc);
            }
#endif

            interface_i = phy_port - 1;


            /* Get FC Configuration */
            soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, port, 0, &mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), error 0x%x\n"), unit, port, soc_rc));
            }

            /* Target is relevant only for PFC */
            if(mode == DNX_TMC_FC_INBND_MODE_PFC || mode == DNX_TMC_FC_INBND_MODE_SAFC)
            {
                if(*target_count >= max_target) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
                }
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.rx_pfc_map_info.get(unit, interface_i, &sw_state_rx_pfc_map_info));
                if (sw_state_rx_pfc_map_info == _BCM_DNX_COSQ_PFC_RX_PORT_OVER) {
                    target[*target_count].flags = BCM_COSQ_FC_PORT_OVER_PFC;
                }
                else if (sw_state_rx_pfc_map_info == _BCM_DNX_COSQ_PFC_RX_INTF_COSQ) {
                    target[*target_count].flags = BCM_COSQ_FC_INTF_COSQ_PFC;
                }

                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                *target_count += 1;
            }
        }/* internal id loop */
    }

    /* get CMIC FC configuration */
    PBMP_ITER(PBMP_CMIC(unit), port) {
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_cmic_rx_get,(unit, port, &priority_bmp, &is_ena));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to get CMIC FC on port(%d), error 0x%x\n"), unit, port, soc_rc));
        }
        BCM_DNX_UNIT_CHECK(unit);

        if (!is_ena) {
            continue;
        }

        if(*target_count >= max_target) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
        }

        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);
        *target_count += 1;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* retrieve VSQ information */
static int
_bcm_dnx_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type, vsq_type_info;
    int ct_id;
    int cc_id;
    int traffic_class;
    bcm_gport_t src_port = -1;   
    int pp_vsq_id;
    int core_id;     
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_info);
    
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport type is not vsq (0x%x)"), unit, vsq));
    }
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
    ct_id = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    traffic_class = BCM_COSQ_GPORT_VSQ_TC_GET(vsq);
    cc_id = BCM_COSQ_GPORT_VSQ_CC_GET(vsq);
    pp_vsq_id = BCM_COSQ_GPORT_VSQ_PP_GET(vsq);
    
    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        vsq_type = BCM_DNX_COSQ_GPORT_VSQ_TYPE_GET(vsq);
        vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq);
        if (vsq_type == BCM_DNX_COSQ_VSQ_TYPE_PFC) {
          src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
          traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
        } else if (vsq_type == BCM_DNX_COSQ_VSQ_TYPE_LLFC) {
          src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);
        }
    } else {
            uint8  enable = 0;
            uint32 src_pp_port = -1;
            if (BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(vsq)) {
                BCMDNX_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_src_port_get, (unit,
                                                                                                  BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), 
                                                                                                  BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(vsq),
                                                                                                  &src_pp_port,
                                                                                                  &enable)));
            } else if (BCM_COSQ_GPORT_IS_VSQ_PG(vsq)) {
                BCMDNX_IF_ERR_EXIT(MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_vsq_pg_mapping_get, (unit,
                                                                                                    BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), 
                                                                                                    BCM_COSQ_GPORT_VSQ_PG_GET(vsq),
                                                                                                    0, 
                                                                                                    &src_pp_port,
                                                                                                    &enable)));
            }
            if (enable) {
                BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_pp_to_local_port_get, (unit, BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), src_pp_port, &src_port)));
            } else {
                src_port = -1;
            }
    }
    vsq_info->flags = _SHR_COSQ_GPORT_VSQ_FLAGS_GET(vsq);
    if (ct_id != -1) {
        vsq_info->ct_id = ct_id;
    }
    if (cc_id != -1) {
        vsq_info->cc_id = cc_id;
    }
    if (traffic_class != -1) {
        vsq_info->traffic_class = traffic_class;
    }
    if (src_port != -1) {
        vsq_info->src_port = src_port;
    }
    if (pp_vsq_id != -1) {
        vsq_info->pp_vsq_id = pp_vsq_id;
    }
    if (core_id != -1) {
        BCM_COSQ_GPORT_CORE_SET(vsq_info->core_id, core_id);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* given a interface retrieve inband flow control information for that interface */
/* (SOC_PB_FC_GEN_INBND_INFO sructure)                                               */
static int
_bcm_dnx_cosq_interface_fc_info_get(int unit, bcm_gport_t port, DNX_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t  rc = BCM_E_NONE;
    bcm_port_t user_port;
    BCMDNX_INIT_FUNC_DEFS;  

    if ( !(BCM_GPORT_IS_MODPORT(port) || BCM_GPORT_IS_LOCAL(port) || !(BCM_GPORT_IS_SET(port))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for (0x%x)"), unit, port));
    }

    rc = bcm_dnx_cosq_user_port_get(unit, port, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_get,(unit, user_port, inbnd_info));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* given a VSQ retrieve inband flow control information for an interface         */
/* (SOC_PB_FC_GEN_INBND_INFO structure)                                              */
static int
_bcm_dnx_cosq_vsq_fc_info_get(int unit, bcm_gport_t vsq_port, DNX_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t          rc = BCM_E_NONE;
    bcm_cosq_vsq_info_t  vsq_info;


    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_dnx_cosq_vsq_info_get(unit, vsq_port, &vsq_info);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dnx_cosq_interface_fc_info_get(unit, vsq_info.src_port, inbnd_info);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control generation (Inband/Out-of-band) */
static int
_bcm_dnx_cosq_cal_generation_fc_path_add(int unit,
                                           int is_for_delete,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_fc_endpoint_t *target,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_calender,
                                           int is_fc_inband, 
                                           int fc_calender_port)                      
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    bcm_dnx_cosq_tx_cal_t   _tx_cal;
    DNX_TMC_FC_CAL_IF_INFO       cal_if_info;
    DNX_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    int                      priority;
    DNX_TMC_FC_GEN_CAL_SRC       cal_src = 0;
    int                      cal_id[BCM_DNX_COSQ_FC_CAL_ID_NUM], cal_id_entries = 0, cur_entry;
    int                      restore = FALSE;
    bcm_dnx_cosq_vsq_type_t  vsq_group_type;
    DNX_TMC_ITM_VSQ_GROUP        dnx_tmcvsq_group;
    int                      vsq_index, nof_ilkn_ports;
    uint32                   vsq_fc_id = 0;
    uint32 target_id;
    uint32 phy_port;

    int is_fc_mub = 0;
    DNX_TMC_FC_ILKN_MUB_GEN_CAL  mub_cal_info;
    bcm_port_t source_port;
    int is_interface_port = 0;
    int core = 0;
    int pool_id = 0;
    uint8 is_ocb_only = 0;

    DNX_TMC_FC_HCFC_BITMAP hcfc_bitmap;
    int bit;
    int i;
    bcm_cos_queue_t src_cosq = 0;

    int flag_count = 0;
    uint32                     glb_res_src_bitmap = 0;
    DNX_TMC_FC_GLB_RES_TYPE    glb_res_dst = 0;
    uint32 source_tm_port = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DNX_DEFS_GET(unit, nof_interlaken_ports);   

    cal_src = DNX_TMC_FC_GEN_CAL_SRC_CONST;
    for (i = 0; i < BCM_DNX_COSQ_FC_CAL_ID_NUM; i++) {
        cal_id[i] = 0;
    }

    if (target->flags & BCM_COSQ_FC_MUB) {
        is_fc_mub = 1;
    }

    if (is_fc_mub == 0) {
        BCMDNX_ALLOC(cal_buff, (sizeof(DNX_TMC_FC_GEN_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
        if (cal_buff == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }

        DNX_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        /* consistency checks */
        if (is_fc_inband) {
            if (fc_calender_port >= nof_ilkn_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
        }
        else {
            if (fc_calender_port >= SOC_DNX_MAX_OOB_PORTS) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
        }
        if (_tx_cal.valid != TRUE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, tx calender not valid for port(%d)\n"), unit, fc_calender_port));
        }
  
        /* retrieve calender setting */
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_cal_get,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
        }
    }
    else {
        /* retrieve calender setting */
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_ilkn_mub_gen_cal_get,(unit, fc_calender_port, &mub_cal_info));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) retreive, error 0x%x\n"), unit, fc_calender_port, soc_rc));
        }  
    }
     
    if(target->flags & BCM_COSQ_FC_RETRANSMIT)
    {
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, use SOC Property to set ILKN Retransmit Entry for Jericho\n"), unit));
        }
        else {
            /* ILKN Retransmit Entry  - Arad Only */
            cal_src = DNX_TMC_FC_GEN_CAL_SRC_RETRANSMIT;
            cal_id_entries = 1;
            cal_id[0] = fc_calender_port;
        }
    }
    else if(source->flags & BCM_COSQ_FC_HCFC_BITMAP)
    {
        sal_memset(&hcfc_bitmap, 0x0, sizeof(DNX_TMC_FC_HCFC_BITMAP));

        /* validate target flags */
        if ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
        }

        /* validate target cosq */
        if (target->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
        }

        /* validate source cosq */
        if (SOC_IS_JERICHO(unit)) {
            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
            /* validate source flags */
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP | BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | 
                                      BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP|BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                    BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            /* validate source priority */
            rc = _bcm_dnx_cosq_internal_priority_get(unit, source->priority, &priority);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
            }

            /* get core, ocb and set global resource mask for jer2_jericho */
            if (SOC_IS_JERICHO(unit)) {
                is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
                core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);

                if (SOC_IS_QAX(unit)) {
                    if (is_ocb_only) {
                        glb_res_src_bitmap |= (1 << DNX_TMC_FC_GLB_RES_TYPE_OCB);
                    } else {
                        glb_res_src_bitmap |= (1 << DNX_TMC_FC_GLB_RES_TYPE_DRAM);
                    }

                    if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                        if (pool_id == 0) {
                            glb_res_src_bitmap |= (1 << DNX_TMC_FC_GLB_RES_TYPE_POOL0);
                        } else if(pool_id == 1) {
                            glb_res_src_bitmap |= (1 << DNX_TMC_FC_GLB_RES_TYPE_POOL1);
                        }
                    }

                    if (source->flags & BCM_COSQ_FC_HEADROOM) {
                        glb_res_src_bitmap |= (1 << DNX_TMC_FC_GLB_RES_TYPE_OCB_HEADROOM);
                    }
                } else {
                    if (is_ocb_only) {
                        glb_res_dst = (pool_id == 0)?(DNX_TMC_FC_GLB_RES_TYPE_OCB_P0):(DNX_TMC_FC_GLB_RES_TYPE_OCB_P1);
                    } else {
                        glb_res_dst = (pool_id == 0)?(DNX_TMC_FC_GLB_RES_TYPE_MIX_P0):(DNX_TMC_FC_GLB_RES_TYPE_MIX_P1);
                    }

                    if (source->flags & BCM_COSQ_FC_BDB) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_BDB);
                    }
                    if (source->flags & BCM_COSQ_FC_MINI_DB) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_MINI_MC_DB);
                    }
                    if (source->flags & BCM_COSQ_FC_FULL_DB) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_MC_DB);
                    }
                    if (source->flags & BCM_COSQ_FC_OCB_DB) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_OCB_DB);
                    }
                    if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                        glb_res_src_bitmap |= (1<<glb_res_dst);
                    }
                }
                soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_glb_rcs_mask_set, (unit, core, (priority == 0), glb_res_dst, glb_res_src_bitmap));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting global resource mask, error 0x%x\n"), unit, soc_rc));
                }
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_glb_hcfc_bitmap_get, (unit, core, (priority == 0), is_ocb_only, pool_id, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in retreiving hcfc bitmap for global VSQ, error 0x%x\n"), unit, soc_rc));
            }

            bit = source->calender_index;
            if (is_for_delete) {
                hcfc_bitmap.bitmap[bit/32] &= ~(0x1 << (bit % 32));
            }
            else {
                hcfc_bitmap.bitmap[bit/32] |= (0x1 << (bit % 32));
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_glb_hcfc_bitmap_set, (unit, core, (priority == 0), is_ocb_only, pool_id, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting hcfc bitmap for global VSQ, error 0x%x\n"), unit, soc_rc));
            }
        }
        else if (vsq_info->flags == BCM_COSQ_VSQ_CTTC) {
            /* validate source flags */
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            if (SOC_IS_JERICHO(unit)) {
                src_cosq = BCM_COSQ_GPORT_VSQ_TC_GET(source->port);
                /*
                is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(source->port);
                */
                core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
            }
            else {
                src_cosq = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(source->port);
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_cat_2_tc_hcfc_bitmap_get, (unit, core, src_cosq, is_ocb_only, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in retreiving hcfc bitmap for cat2+tc, error 0x%x\n"), unit, soc_rc));
            }

            bit = source->calender_index;
            if (is_for_delete) {
                hcfc_bitmap.bitmap[bit/32] &= ~(0x1 << (bit % 32));
            }
            else {
                hcfc_bitmap.bitmap[bit/32] |= (0x1 << (bit % 32));
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_cat_2_tc_hcfc_bitmap_set, (unit, core, src_cosq, is_ocb_only, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting hcfc bitmap for cat2+tc, error 0x%x\n"), unit, soc_rc));
            }
        }
        else if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
            /* validate source flags */
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }   
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, hcfc bitmap can only mapped from global VSQ, cat2+tc VSQ and PP VSQ, error 0x%x\n"), unit, rc));
        }

        cal_src = DNX_TMC_FC_GEN_CAL_SRC_HCFC;
        cal_id_entries = 1;
        cal_id[0] = source->calender_index;
    }
    else if (vsq_info->flags == BCM_COSQ_VSQ_GL) 
    {
        /* Global resources */

        /* consistency checks */
        /* validate source flags and source cosq*/
        if(SOC_IS_JERICHO(unit))
        {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            flag_count = _bcm_cosq_bit_count_get(source->flags & (BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB));
            if (flag_count > 1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos: indicate pool id*/
            if (!((source->cosq == 0) || (source->cosq == -1))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        /* validate target flags */
        if ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
        }

        /* validate target cos */
        if (!((target->cosq == 0) || (target->cosq == -1)) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
        }

        /* validate source priority */
        rc = _bcm_dnx_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
        }

        if(SOC_IS_JERICHO(unit))
        {
            cal_src = DNX_TMC_FC_GEN_CAL_SRC_GLB_RCS;
            cal_id_entries = 0; 
            if (SOC_IS_QAX(unit)) {
                /* The CAL ID separate HP(0,1,2,3,4) form LP(5,6,7,8) */
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if (source->cosq == 0) {
                        /* ID = HP ? 2 : 7 */
                        cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_P0 : DNX_TMC_FC_CAL_GLB_RCS_ID_P0 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_QAX;
                    } else if (source->cosq == 1){
                        /* ID = HP ? 3 : 8 */
                        cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_P1 : DNX_TMC_FC_CAL_GLB_RCS_ID_P1 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_QAX;
                    }
                }

                if (source->flags & BCM_COSQ_FC_HEADROOM) {
                    /* ID = 4  for HP, no LP for headroom resource */
                    cal_id[cal_id_entries++] = DNX_TMC_FC_CAL_GLB_RCS_ID_HEADROOM;
                }

                if ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) {
                    /* ID = HP ? 0 : 5 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_MIX : DNX_TMC_FC_CAL_GLB_RCS_ID_MIX + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_QAX;
                } else {
                    /* ID = HP ? 1 : 6 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_OCB : DNX_TMC_FC_CAL_GLB_RCS_ID_OCB + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_QAX;
                }
                cal_id_entries = 1;
            } else {
                /* The CAL ID separate HP(0,1,2) form LP(3,4,5) */
                if (source->flags & BCM_COSQ_FC_BDB) {
                    /* ID = HP ? 0 : 8 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_BDB : DNX_TMC_FC_CAL_GLB_RCS_ID_BDB + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_MINI_DB) {
                    /* ID = HP ? 1 : 9 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_UNI : DNX_TMC_FC_CAL_GLB_RCS_ID_UNI + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_FULL_DB) {
                    /* ID = HP ? 2 : 10 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_MUL : DNX_TMC_FC_CAL_GLB_RCS_ID_MUL + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_OCB_DB) {
                    /* ID = HP ? 3 : 11 */
                    cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_DB : DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_DB + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) {
                        if (source->cosq == 0) {
                            /* ID = HP ? 4 : 12 */
                            cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 : DNX_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                        } else {
                            /* ID = HP ? 5 : 13 */
                           cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 : DNX_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                        }
                    } else {
                        if (source->cosq == 0) {
                            /* ID = HP ? 6 : 14 */
                            cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 : DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;                    
                        } else {
                            /* ID = HP ? 7 : 15 */
                            cal_id[cal_id_entries++] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 : DNX_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS;            
                        }
                    }
                }
                if(cal_id_entries != 1) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source->flags (%d)\n"), unit, source->flags));
                }
                cal_id_entries = 1;
            }
        }
        else {
            /* The CAL ID separate HP(0,1,2) form LP(3,4,5) */
            cal_src = DNX_TMC_FC_GEN_CAL_SRC_GLB_RCS;
            /* ID = HP ? 0 : 3 */
            cal_id[0] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_BDB : DNX_TMC_FC_CAL_GLB_RCS_ID_BDB + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_ARAD;
            /* ID = HP ? 1 : 4 */
            cal_id[1] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_UNI : DNX_TMC_FC_CAL_GLB_RCS_ID_UNI + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_ARAD;
            /* ID = HP ? 2 : 5 */
            cal_id[2] = (priority == 0) ? DNX_TMC_FC_CAL_GLB_RCS_ID_MUL : DNX_TMC_FC_CAL_GLB_RCS_ID_MUL + DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_ARAD;

            /* We need an entry per every GLB RCS type - total of 3 */
            cal_id_entries = DNX_TMC_FC_NOF_CAL_GLB_RCS_IDS_JER2_ARAD;
        }
    }
    else if(BCM_COSQ_GPORT_IS_VSQ(source->port)) 
    {
        /* port/interface resources */

        /* consistency checks */
        /* validate source flags and target flags */
        if ( (source->flags != 0) || ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
        }

        /* validate source cosq and target cosq */
        if (SOC_IS_JERICHO(unit) && vsq_info->flags == BCM_COSQ_VSQ_PFC) {
            if ((source->cosq < 0 ) || (source->cosq >= DNX_COSQ_FC_NOF_PRIORITIES)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = -1; /* Not used for retrieve vsq index */
        }
        else {
            if ((source->cosq != 0) && (source->cosq != -1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = source->cosq;
        }

        if ((target->cosq != 0) && (target->cosq != -1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq target(%d)\n"), unit, target->cosq));
        }

        /* retrieve vsq index */
        rc = _bcm_dnx_cosq_gport_vsq_gport_get(unit, source->port, src_cosq, &core, &is_ocb_only, &vsq_group_type, &vsq_index);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x\n"), unit, source->port, rc));
        }

        rc = _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&dnx_tmcvsq_group);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in _bcm_dnx_cosq_bcm_vsq_type_to_tmc_vsq_type 0x%x\n"), unit, rc));
        }

        rc = (MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_fc_vsq_index_group2global, (unit, dnx_tmcvsq_group, vsq_index, source->cosq, is_ocb_only, vsq_info->src_port, &vsq_fc_id)));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in mbcm_dnx_fc_vsq_index_group2global 0x%x\n"), unit, rc));
        }

        if (SOC_IS_JERICHO(unit))
        {
            if (dnx_tmcvsq_group == DNX_TMC_ITM_VSQ_GROUP_STTSTCS_TAG) {
                /* Group D */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_STTSTCS_TAG;                
            }
            else if(dnx_tmcvsq_group == DNX_TMC_ITM_VSQ_GROUP_LLFC) {
                /* Group E */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_LLFC_VSQ;
            }
            else if(dnx_tmcvsq_group == DNX_TMC_ITM_VSQ_GROUP_PFC) {
                /* Group F */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_PFC_VSQ;
            }
            else
            {
                /* Group A/B/C/D */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_STE;
            }
        }
        else
        {
            if(dnx_tmcvsq_group == DNX_TMC_ITM_VSQ_GROUP_LLFC) {
                /* Group E */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_LLFC_VSQ;
            }
            else if(dnx_tmcvsq_group == DNX_TMC_ITM_VSQ_GROUP_PFC) {
                /* Group F */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_PFC_VSQ;
            }
            else
            {
                /* Group A/B/C/D */
                cal_src = DNX_TMC_FC_GEN_CAL_SRC_STE;
            }
        }        

        cal_id_entries = 1;
        cal_id[0] = vsq_fc_id;
    }
    else
    {
        /* NIF RX Indication */
        /* consistency checks */
        /* validate source flags and target flags */
        if ( (source->flags != 0) || ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
        }

        /* validate source cosq and target cosq */
        if (((source->cosq != 0) && (source->cosq != -1)) ||
            ((target->cosq != 0) && (target->cosq != -1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d), target(%d)\n"), unit, source->cosq, target->cosq));
        }

        /* validate source port */
        rc = _bcm_dnx_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (!is_interface_port) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port source(0x%x), it should be interface gport\n"), unit, source->port));
        }

        rc = bcm_dnx_cosq_user_port_get(unit, source->port, &source_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_first_phy_port_get(unit, source_port, &phy_port /*one based*/);
        BCMDNX_IF_ERR_EXIT(rc);

        target_id = phy_port - 1;

        cal_src = DNX_TMC_FC_GEN_CAL_SRC_LLFC;
        cal_id_entries = 1;
        cal_id[0] = target_id;
    }

    /* Delete case */
    if (is_for_delete) {
        cal_src = DNX_TMC_FC_GEN_CAL_SRC_CONST;
        for (i = 0; i < cal_id_entries; i++) {
            cal_id[i] = 0;
        }
    }

    /* update calender { */
    if (is_fc_mub == 0) {
        if (target->calender_index + cal_id_entries > cal_if_info.cal_len) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, out of range calender index (%d)\n"), unit, (target->calender_index + (cal_id_entries - 1))));
        }

        for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {    
            (cal_buff + target->calender_index + cur_entry)->source = cal_src;
            (cal_buff + target->calender_index + cur_entry)->id = cal_id[cur_entry];
        }
    }
    else {
        if (target->calender_index + cal_id_entries > DNX_TMC_FC_ILKN_MUB_GEN_CAL_LEN) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, out of range calender index\n"), unit));
        }
        
        for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {    
            mub_cal_info.entries[target->calender_index + cur_entry].source = cal_src;
            mub_cal_info.entries[target->calender_index + cur_entry].id = cal_id[cur_entry];
        }
    }
    /* update calender } */

    /* configure calender { */
    if (is_fc_mub == 0) {
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_cal_set,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            restore = TRUE;
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s Tx calender(%d) setup, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
        }
    }
    else {
        soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_ilkn_mub_gen_cal_set,(unit, fc_calender_port, &mub_cal_info));
        if (SOC_FAILURE(soc_rc)) {
            restore = TRUE;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) setup, error 0x%x\n"), unit, fc_calender_port, soc_rc));
        }
    }
    /* configure calender } */

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    if (restore == TRUE) {
        if (is_fc_mub == 0) {
            for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
                (cal_buff + target->calender_index + cur_entry)->source = DNX_TMC_FC_GEN_CAL_SRC_NONE;
                (cal_buff + target->calender_index + cur_entry)->id = 0;
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_cal_set,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));        
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s Tx calender(%d) setup, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
            }
        }
        else {
            for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {    
                mub_cal_info.entries[target->calender_index + cur_entry].source = DNX_TMC_FC_GEN_CAL_SRC_NONE;
                mub_cal_info.entries[target->calender_index + cur_entry].id = 0;
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_ilkn_mub_gen_cal_set,(unit, fc_calender_port, &mub_cal_info));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) setup, error 0x%x\n"), unit, fc_calender_port, soc_rc));
            }            
        }
    }

    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cal_generation_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count             /* INOUT */
                                           )                       
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    bcm_dnx_cosq_tx_cal_t    _tx_cal;
    DNX_TMC_FC_CAL_IF_INFO       cal_if_info;
    DNX_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    int                      cal_index, nof_ilkn_ports;
    DNX_TMC_FC_GEN_CAL_SRC       cal_src = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    nof_ilkn_ports = SOC_DNX_DEFS_GET(unit, nof_interlaken_ports);

    /* Init values */   

    if(*target_count >= max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    BCMDNX_ALLOC(cal_buff, (sizeof(DNX_TMC_FC_GEN_CALENDAR) * DNX_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    DNX_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
    for (cal_index = 0; cal_index < DNX_TMC_FC_OOB_CAL_LEN_MAX; cal_index++) {
        DNX_TMC_FC_GEN_CALENDAR_clear((cal_buff + cal_index));
    }

    /* Get the calendar type */
    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
    }
    else {
        if (fc_calender_port >= SOC_DNX_MAX_OOB_PORTS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
    }
    if (_tx_cal.valid != TRUE) {
        /* No calendar */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, No calendar for calendar port(%d)\n"), unit, fc_calender_port));
    }

    /* Get the calender setting */
    soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_cal_get,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));

    if (SOC_FAILURE(soc_rc)) {
        BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
    }

    /* Search for the Target */
    for(cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++)
    {
        cal_src = cal_buff[cal_index].source;

        /* Need to handle RETRANSMIT ONLY - other srouces ignores target information */
        if(cal_src == DNX_TMC_FC_GEN_CAL_SRC_RETRANSMIT)
        {
            if(*target_count >= max_target) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
            }

            target[*target_count].calender_index = cal_index;

            /* NIF ID to GPORT */
            rc = bcm_dnx_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, cal_buff[cal_index].id, &target[*target_count].port);
            BCMDNX_IF_ERR_EXIT(rc);

            *target_count += 1;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control generation (Inband) */
static int
_bcm_dnx_cosq_noncal_generation_fc_path_add(int unit,
                                              int is_for_delete,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_fc_endpoint_t *target,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int is_fc_calender,            /* not used */
                                              int is_fc_inband,              /* not used */
                                              int fc_calender_port)          /* not used */
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    int                      priority;
    DNX_TMC_FC_GEN_INBND_INFO    inbnd_info;
    DNX_TMC_FC_INGR_GEN_GLB_HP_MODE glb_hp_mode;
    int is_llfc;
    int core = 0;
    int is_safc = 0;
    bcm_cosq_vsq_info_t  temp_vsq_info;
    bcm_port_t source_port = 0, target_port = -1;
    bcm_cos_queue_t src_cosq = 0;
    int is_interface_port = 0;
    uint32                     glb_res_src_bitmap = 0;
    DNX_TMC_FC_GLB_RES_TYPE    glb_res_dst = 0;
    int pool_id = 0;    
    int is_ocb_only = 0;
    uint32 source_tm_port = 0;
    DNX_TMC_FC_INBND_MODE fc_mode = DNX_TMC_FC_INBND_MODE_DISABLED;

    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    /* consistency checks */
    if ( (source->calender_index != 0) || (target->calender_index != 0) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, calender not valid source (%d), target (%d)\n"), unit, source->calender_index, target->calender_index));
    }

    if ( vsq_info->flags == BCM_COSQ_VSQ_CTTC ) {
        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
        }

        /* validate source cosq */
        if (source->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        /* validate target cos */
        if ((target->cosq < 0 ) || (target->cosq >= DNX_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        /* validate fc mode */
        rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, target_port, TRUE, &fc_mode));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, target_port));
        }

        if ((fc_mode != DNX_TMC_FC_INBND_MODE_PFC) && (fc_mode != DNX_TMC_FC_INBND_MODE_SAFC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, target_port));
        }

        if (SOC_IS_JERICHO(unit)) {
            src_cosq = BCM_COSQ_GPORT_VSQ_TC_GET(source->port);
            is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(source->port);
            core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
        }
        else {
            src_cosq = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(source->port);
        }

		inbnd_info.mode = fc_mode;
        inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_VSQ_CAT2TC;
        if (SOC_IS_JERICHO(unit)) {
            inbnd_info.core = core;
            inbnd_info.pfc.is_ocb_only = is_ocb_only;
        }
        inbnd_info.pfc.cat2_tc = src_cosq;

        /* retreive information */
        rc = _bcm_dnx_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }

        /* update info */
        if (is_for_delete) {
            inbnd_info.pfc.cat2_tc_bitmap &= ~(1 << target->cosq);
        }
        else {
            inbnd_info.pfc.cat2_tc_bitmap |= (1 << target->cosq);
        }

        /* configure */
        rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }
    }
    else if ( (vsq_info->flags == BCM_COSQ_VSQ_LLFC) || (vsq_info->flags == BCM_COSQ_VSQ_PFC) ) {
        /* interface resources */

        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }
        
        /* validate target flags */
        if (SOC_IS_JERICHO(unit)) {
            if (target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags (0x%x)\n"), unit, target->flags));
            }
        }
        else {
            if ((target->flags & ~(BCM_COSQ_FC_INHERIT_UP | BCM_COSQ_FC_INHERIT_DOWN | BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) ||
                ((vsq_info->flags == BCM_COSQ_VSQ_PFC) &&
                 (target->flags & BCM_COSQ_FC_INHERIT_UP) &&
                 (target->flags & BCM_COSQ_FC_INHERIT_DOWN)) ||
                ((vsq_info->flags == BCM_COSQ_VSQ_LLFC) &&
                 ((target->flags & BCM_COSQ_FC_INHERIT_UP) || 
                 (target->flags & BCM_COSQ_FC_INHERIT_DOWN))) ) {

                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags (0x%x)\n"), unit, target->flags));
            }
        }

        /* validate source cosq */
        if (source->cosq != -1 && vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }
        source_port = vsq_info->src_port;

        /* validate target port, cosq */
        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            /* validate target port */
            rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(0x%x) and target port (0x%x) do not match\n"), unit, source_port, target_port));
            }

            /* validate target cosq */
            if (((vsq_info->flags == BCM_COSQ_VSQ_LLFC)&& (target->cosq != -1)) || 
                ((vsq_info->flags == BCM_COSQ_VSQ_PFC) && ((target->cosq < 0) || (target->cosq > 7)))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
            }
        }

        rc = _bcm_dnx_cosq_vsq_fc_info_get(unit, source->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
        }

        if ((vsq_info->flags == BCM_COSQ_VSQ_LLFC) && (inbnd_info.cb.glbl_rcs_low != 0)) {            
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "unit %d, Enabling Inband LLFC on port (%d) disabling Global Low priorities flow control\n"), unit, target->port));
        }

        /* update info */
        if (vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
            inbnd_info.mode = DNX_TMC_FC_INBND_MODE_LL;
            inbnd_info.ll.gen_src = DNX_TMC_FC_GEN_SRC_VSQ_LLFC;
            inbnd_info.ll.vsq_llfc_enable = (is_for_delete)?(0):1;
            inbnd_info.cb.glbl_rcs_low = 0;
            inbnd_info.cb.inherit = DNX_TMC_FC_INBND_CB_INHERIT_DISABLED;
        }
        else if(vsq_info->flags == BCM_COSQ_VSQ_PFC)
        {
            rc = _bcm_dnx_cosq_vsq_info_get(unit, source->port, &temp_vsq_info);   
            BCMDNX_IF_ERR_EXIT(rc);

            rc = bcm_dnx_port_control_get(unit, temp_vsq_info.src_port, bcmPortControlSAFCTransmit, &is_safc);
            BCMDNX_IF_ERR_EXIT(rc);

            if(is_safc)
            {
              inbnd_info.mode = DNX_TMC_FC_INBND_MODE_SAFC;
            }
            else
            {
              inbnd_info.mode = DNX_TMC_FC_INBND_MODE_PFC;
            }
            inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_VSQ_PFC;
            inbnd_info.pfc.vsq_pfc_enable = (is_for_delete)?(0):1;

            if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                inbnd_info.pfc.inherit = DNX_TMC_FC_INBND_PFC_INHERIT_UP;
            }
            else if (target->flags &   BCM_COSQ_FC_INHERIT_DOWN) {
                inbnd_info.pfc.inherit = DNX_TMC_FC_INBND_PFC_INHERIT_DOWN;
            }
            else{
                inbnd_info.pfc.inherit = DNX_TMC_FC_INBND_PFC_INHERIT_DISABLED;
            }
        }

        if (is_for_delete) {
            inbnd_info.mode = DNX_TMC_FC_INBND_MODE_DISABLED;
        }

        /* configure info */
        rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_set,(unit, source_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, source->port, rc));
        }
    }
    else if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        /* global resources */

        /* consistency checks */
        /* validate source flags and source cos */
        if (SOC_IS_JERICHO(unit)) {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos */
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }


        /* validate source priority */
        rc = _bcm_dnx_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
        }

        /* validate target flags and target port*/
        if (SOC_IS_JERICHO(unit)) {
            if (target->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
            }

            rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }
        }
        else {
            if (priority == 0) {
                if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_ALL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x), Need to set *_ALL flag\n"), unit, target->flags));
                }
            }
            else {
                if (target->flags != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
                }

                rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
                if (rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
                }
            }
        }

        /* validate target cos */
        if ((target->cosq < -1 ) || (target->cosq >= DNX_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        if ((priority == 1) && (target->cosq == -1 )) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, LLFC can't be triggered by Global resources low\n"), unit));            
        }

        /* validate fc mode */
        if (target_port != -1) { 
            soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, target_port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, target_port));
            }

            if (target->cosq == -1) {
                /* target is LLFC */
                if (fc_mode != DNX_TMC_FC_INBND_MODE_LL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband LLFC on port (%d), please call port API to enable LLFC on port first\n"), unit, target_port));
                }
            }
            else {
                /* target is PFC/SAFC */
                if ((fc_mode != DNX_TMC_FC_INBND_MODE_PFC) && (fc_mode != DNX_TMC_FC_INBND_MODE_SAFC)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, target_port));
                }
            }
        }

        /* get core, ocb and set global resource mask for jer2_jericho */
        if (SOC_IS_JERICHO(unit)) {
            is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
            core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);

            if (SOC_IS_QAX(unit)) {
                if (is_ocb_only) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_OCB);
                } else {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_DRAM);
                }

                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if (pool_id == 0) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_POOL0);
                    } else if(pool_id == 1) {
                        glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_POOL1);
                    }
                }

                if (source->flags & BCM_COSQ_FC_HEADROOM) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_OCB_HEADROOM);
                }
            } else {
                if (is_ocb_only) {
                    glb_res_dst = (pool_id == 0)?(DNX_TMC_FC_GLB_RES_TYPE_OCB_P0):(DNX_TMC_FC_GLB_RES_TYPE_OCB_P1);
                } else {
                    glb_res_dst = (pool_id == 0)?(DNX_TMC_FC_GLB_RES_TYPE_MIX_P0):(DNX_TMC_FC_GLB_RES_TYPE_MIX_P1);
                }
                if (source->flags & BCM_COSQ_FC_BDB) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_BDB);
                }
                if (source->flags & BCM_COSQ_FC_MINI_DB) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_MINI_MC_DB);
                }
                if (source->flags & BCM_COSQ_FC_FULL_DB) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_MC_DB);
                }
                if (source->flags & BCM_COSQ_FC_OCB_DB) {
                    glb_res_src_bitmap |= (1<<DNX_TMC_FC_GLB_RES_TYPE_OCB_DB);
                }
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    glb_res_src_bitmap |= (1<<glb_res_dst);
                }
            }

            soc_rc = MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_glb_rcs_mask_set, (unit, core, (priority == 0), glb_res_dst, glb_res_src_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting global resource mask, error 0x%x\n"), unit, soc_rc));
            }
        }

        BCM_DNX_UNIT_CHECK(unit);

        if (priority == 0) {
            /* Global High Prioriry */
            if (SOC_IS_JERICHO(unit)) {
                inbnd_info.core = core;
                if (target->cosq == -1) {
                    /* target is LLFC */
                    inbnd_info.mode = DNX_TMC_FC_INBND_MODE_LL;
                    inbnd_info.ll.gen_src = DNX_TMC_FC_GEN_SRC_GLB_HIGH;

                    /* update info */
                    inbnd_info.ll.glbl_rcs_enable = ((is_for_delete)?0:1);
                }
                else {
                    /* target is PFC */
                    inbnd_info.mode = fc_mode;
                    inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_GLB_HIGH;
                    inbnd_info.pfc.is_ocb_only = is_ocb_only;
                    inbnd_info.pfc.glbl_rcs_pool = pool_id;

                    /* retreive information */
                    rc = _bcm_dnx_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
                    if (rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
                    }

                    /* update info */
                    if (is_for_delete) {
                        inbnd_info.pfc.glbl_rcs_high &= ~(1 << target->cosq);
                    }
                    else {
                        inbnd_info.pfc.glbl_rcs_high |= 1 << target->cosq;
                    }
                }

                /* configure */
                rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
                if (rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
                }
            }
            else {
                /* target is both LLFC and PFC */
                glb_hp_mode = DNX_TMC_FC_INGR_GEN_GLB_HP_MODE_ALL;
                soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_glb_hp_set,(unit, glb_hp_mode));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting InBand (LLFC) Hi Priorirty Flow Control, error: 0x%x\n"), unit, soc_rc));
                }
            }
        }
        else {
            inbnd_info.mode = fc_mode;
            inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_GLB_LOW;            
            if (SOC_IS_JERICHO(unit)) {
                inbnd_info.core = core;
                inbnd_info.pfc.is_ocb_only = is_ocb_only;
                inbnd_info.pfc.glbl_rcs_pool = pool_id;
            }

            /* retreive information */
            rc = _bcm_dnx_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            /* update state */
            if (is_for_delete) {
                inbnd_info.pfc.glbl_rcs_low &= ~(1 << target->cosq);
            }
            else {
                inbnd_info.pfc.glbl_rcs_low |= (1 << target->cosq);
            }

            /* configure */
            rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
            }
        }
    }
    else {
        /* consistency checks */
        /* validate source flags */
        if ((source->flags & ~(BCM_COSQ_FC_ETH_PORT)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
        }

        /* validate source cosq */
        if ((source->cosq != 0) && (source->cosq != -1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        /* validate target cos */
        if ((target->cosq < -1 ) || (target->cosq >= DNX_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        /* validate source port */
        rc = _bcm_dnx_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (!is_interface_port) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port source(0x%x), it should be interface gport\n"), unit, source->port));
        }

        rc = bcm_dnx_cosq_user_port_get(unit, source->port, &source_port);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* validate target port */
        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            /* validate target port */
            rc = bcm_dnx_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(0x%x) and target port (0x%x) do not match\n"), unit, source_port, target_port));
            }
        }

        /* validate fc mode */
        soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, source_port, TRUE, &fc_mode));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, source_port));
        }

        if (target->cosq == -1) {
            /* target is LLFC */
            if (fc_mode != DNX_TMC_FC_INBND_MODE_LL) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband LLFC on port (%d), please call port API to enable LLFC on port first\n"), unit, source_port));
            }
        }
        else {
            /* target is PFC/SAFC */
            if ((fc_mode != DNX_TMC_FC_INBND_MODE_PFC) && (fc_mode != DNX_TMC_FC_INBND_MODE_SAFC)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, source_port));
            }
        }

        is_llfc = (target->cosq == -1) ? TRUE : FALSE;

        if (is_llfc) {
            inbnd_info.mode = DNX_TMC_FC_INBND_MODE_LL;
            inbnd_info.ll.gen_src = DNX_TMC_FC_GEN_SRC_NIF;

            /* update info */
            inbnd_info.ll.nif_enable = is_for_delete ? 0 : 1;
        }
        else {          
            inbnd_info.mode = fc_mode;
            inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_NIF;

            /* retreive information */
            rc = _bcm_dnx_cosq_interface_fc_info_get(unit, source->port, &inbnd_info);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, source->port, rc));
            }

            /* update info */
            if (is_for_delete) {
                inbnd_info.pfc.nif_cls_bitmap &= ~(1 << target->cosq);
            }
            else {
                inbnd_info.pfc.nif_cls_bitmap |= (1 << target->cosq);
            }
        }

        /* configure */
        rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_set,(unit, source_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_noncal_generation_fc_path_get(int unit,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int max_target,
                                              bcm_cosq_fc_endpoint_t *target, /* OUT */
                                              int *target_count               /* INOUT */
                                              )                
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    int                      priority;
    DNX_TMC_FC_GEN_INBND_INFO    inbnd_info;
    int                      i;
    soc_port_t               port;
    int                      pool_id = 0;
    uint32                   pfc_bitmap[1] = {0};
    DNX_TMC_FC_INBND_MODE    fc_mode;
    uint32                   flags = 0;
    pbmp_t                   ports_map;
    soc_port_if_t            interface_type;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    DNX_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    if(*target_count >= max_target) BCM_EXIT;

    if ( (vsq_info->flags == BCM_COSQ_VSQ_LLFC) || (vsq_info->flags == BCM_COSQ_VSQ_PFC) ) {
        /* interface resources */
        /* consistency checks */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        rc = _bcm_dnx_cosq_vsq_fc_info_get(unit, source->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
        }

        if (inbnd_info.pfc.inherit == DNX_TMC_FC_INBND_PFC_INHERIT_UP) {
            target[*target_count].flags = BCM_COSQ_FC_INHERIT_UP;
        }
        else if (inbnd_info.pfc.inherit == DNX_TMC_FC_INBND_PFC_INHERIT_DOWN) {
            target[*target_count].flags = BCM_COSQ_FC_INHERIT_DOWN;
        }

        if(inbnd_info.mode != DNX_TMC_FC_INBND_MODE_DISABLED)
        {
            *target_count += 1;
        }
    }
    else if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        /* global resources */

        /* validate source flags and source cos */
        if (SOC_IS_JERICHO(unit)) {
            if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos */
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        /* validate source priority */
        rc = _bcm_dnx_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
        }

        if ((priority == 0) && !SOC_IS_JERICHO(unit)) {
            /* Target is irrelevant */
            goto exit;
        }
            
        /* Check all interfaces for FC configuration */
        soc_rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_map);
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) in dnx_port_sw_db_valid_ports_get\n"), unit, soc_rc));
        }

        SOC_PBMP_ITER(ports_map, port)
        {
            /* only relevant to network interface */
            soc_rc = dnx_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(soc_rc) || (!DNX_PORT_IS_NETWORK_INTERFACE(flags))) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = dnx_port_sw_db_interface_type_get(unit, port, &interface_type);        
            if (SOC_FAILURE(soc_rc) ||
			    (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            /* Get FC mode */
            soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, port));
            }

            /* Target is relevant only for PFC */
            if ((fc_mode == DNX_TMC_FC_INBND_MODE_PFC) || (fc_mode == DNX_TMC_FC_INBND_MODE_SAFC))
            {
                inbnd_info.mode = fc_mode;
                if (SOC_IS_JERICHO(unit)) {
                    inbnd_info.core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);;
                    inbnd_info.pfc.glbl_rcs_pool = pool_id;
                    inbnd_info.pfc.is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY)?1:0;;
                }
                inbnd_info.pfc.gen_src = ((priority == 0)? DNX_TMC_FC_GEN_SRC_GLB_HIGH : DNX_TMC_FC_GEN_SRC_GLB_LOW);

                /* Get FC Configuration */
                soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_get,(unit, port, &inbnd_info));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to get CBFC port(%d), error 0x%x\n"), unit, port, soc_rc));
                }

                *pfc_bitmap = ((priority == 0)? (inbnd_info.pfc.glbl_rcs_high) : (inbnd_info.pfc.glbl_rcs_low));
                for(i = 0; i < 8; i++)
                {
                    if(SHR_BITGET(pfc_bitmap, i))
                    {
                        if(*target_count >= max_target) {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
                        }

                        target[*target_count].cosq = i;
                        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                        *target_count += 1;
                    }
                }
            }
        } /* Internal ID Loop */
    }
    else if(target->flags & BCM_COSQ_FC_ETH_PORT)
    {
        /* Check all interfaces for FC configuration */
        soc_rc = dnx_port_sw_db_valid_ports_get(unit, 0, &ports_map);
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) in dnx_port_sw_db_valid_ports_get\n"), unit, soc_rc));
        }
        
        SOC_PBMP_ITER(ports_map, port)
        {
            /* only relevant to network interface */
            soc_rc = dnx_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(soc_rc) || (!DNX_PORT_IS_NETWORK_INTERFACE(flags))) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = dnx_port_sw_db_interface_type_get(unit, port, &interface_type);        
            if (SOC_FAILURE(soc_rc) ||
			    (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            /* Get FC mode */
            soc_rc = MBCM_DNX_SOC_DRIVER_CALL(unit,mbcm_dnx_fc_inbnd_mode_get,(unit, port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, port));
            }

            inbnd_info.mode = fc_mode;
            if ((inbnd_info.mode == DNX_TMC_FC_INBND_MODE_PFC) || (inbnd_info.mode == DNX_TMC_FC_INBND_MODE_SAFC)) {
                inbnd_info.pfc.gen_src = DNX_TMC_FC_GEN_SRC_NIF;
            }
            else if (inbnd_info.mode == DNX_TMC_FC_INBND_MODE_LL) {
                inbnd_info.ll.gen_src = DNX_TMC_FC_GEN_SRC_NIF;
            }
            else {
                continue;
            }

            /* Get FC Configuration */
            soc_rc = MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fc_gen_inbnd_get,(unit, port, &inbnd_info));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), dnx_sand error 0x%x\n"), unit, port, soc_rc));
            }

            /* Target is relevant only for PFC */
            if((inbnd_info.mode == DNX_TMC_FC_INBND_MODE_PFC) || (inbnd_info.mode == DNX_TMC_FC_INBND_MODE_SAFC))
            {
                for(i = 0; i < 8; i++)
                {
                    if(SHR_BITGET(&inbnd_info.pfc.nif_cls_bitmap, i))
                    {
                        if(*target_count >= max_target) {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
                        }

                        target[*target_count].cosq = i;
                        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                        *target_count += 1;
                    }
                }
            }
            else if (inbnd_info.mode == DNX_TMC_FC_INBND_MODE_LL) 
            {
                if(*target_count >= max_target) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
                }
                
                target[*target_count].cosq = -1;
                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                *target_count += 1;
            }
        } /* Internal ID Loop */
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_link_fc_verify(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid flags parameter 0x%x\n"), unit, target->flags));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (source->cosq != -1)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, target->cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_link_fc_add(int unit,
                       int is_for_delete,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 dnx_sand_rc;
    DNX_TMC_FABRIC_FC info_rx;
    DNX_TMC_FABRIC_FC info_tx;
    DNX_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_FABRIC_FC_clear(unit, &info_rx);
    DNX_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DNX_FABRIC_PORT_TO_LINK(unit, source->port);
    rc = _bcm_dnx_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_get,(unit, &info_rx,&info_tx)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, dnx_sand error 0x%x\n"), unit, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = (is_for_delete == FALSE)?TRUE:FALSE; 
        direction = DNX_TMC_CONNECTION_DIRECTION_TX;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_set,(unit, direction, &info_tx)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, dnx_sand error 0x%x\n"), unit, link, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = TRUE; 
        direction = DNX_TMC_CONNECTION_DIRECTION_RX;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, dnx_sand error 0x%x\n"), unit, link, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_link_fc_delete(int unit,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 dnx_sand_rc;
    DNX_TMC_FABRIC_FC info_rx;
    DNX_TMC_FABRIC_FC info_tx;
    DNX_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    DNX_TMC_FABRIC_FC_clear(unit, &info_rx);
    DNX_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DNX_FABRIC_PORT_TO_LINK(unit, source->port);
    _bcm_dnx_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_get,(unit, &info_rx, &info_tx)));
    if(DNX_SAND_FAILURE(dnx_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, dnx_sand error 0x%x\n"), unit, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = FALSE; 
        direction = DNX_TMC_CONNECTION_DIRECTION_TX;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_set,(unit, direction,&info_tx)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, dnx_sand error 0x%x\n"), unit, link, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = FALSE; 
        direction = DNX_TMC_CONNECTION_DIRECTION_RX;
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, dnx_sand error 0x%x\n"), unit, link, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}



static int
_bcm_dnx_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (source == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control source not specified"), unit));
    }
    if (target == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control target not specified"), unit));
    }

    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_dnx_cosq_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_dnx_cosq_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow control direction %d"), unit, fc_direction));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_calender, is_fc_inband;
    uint32               fc_calender_port;
    bcm_cosq_vsq_info_t  vsq_info;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_dnx_link_fc_add(unit, is_for_delete, fc_direction,source,target);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        /* Port is incoming nif port */
        if(BCM_COSQ_GPORT_IS_VSQ(source->port))
        {
            /* vsq validation and retrieve vsq inormation */
            rc = _bcm_dnx_cosq_vsq_info_get(unit, source->port, &vsq_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else
        {
            sal_memset(&vsq_info, 0, sizeof(vsq_info));
        }
    
        if (target->port == BCM_GPORT_TYPE_NONE) {
            is_fc_calender = FALSE;
            is_fc_inband = TRUE;
            fc_calender_port = -1;
        }
        else {
            if ( !(BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_CONGESTION(target->port) || BCM_GPORT_IS_LOCAL(target->port) || 
                  ((SOC_PORT_VALID(unit, target->port)) && (IS_PORT(unit, target->port)))   ) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unexpected target port (0x%x)"), unit, target->port));
            }
    
            /* determine if calender based flow control generation */
            rc = bcm_dnx_cosq_fc_port_info_get(unit, target->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
        if (is_fc_calender || target->flags & BCM_COSQ_FC_HCFC_BITMAP) {
            /*
             * COVERITY *
             * Coverity note: Overruning callee's array of size 328 by passing argument "source->port"(which evaluates to 328) in call to "_bcm_dnx_cosq_cal_generation_fc_path_add". 
             * In check there are no overun. */
            /* coverity[overrun-call] */
            rc = _bcm_dnx_cosq_cal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_dnx_cosq_noncal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port;

    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_dnx_link_fc_add(unit, is_for_delete, fc_direction,source,target);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        /* Port is incoming nif port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)) {
            rc = bcm_dnx_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
    
            if (is_fc_calender) {
               rc = _bcm_dnx_cosq_cal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            else {
                rc = _bcm_dnx_cosq_noncal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else {
            
            /*        bcm_dnx_cosq_control_set(), Type => bcmCosqControlFlowControlPriority */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for source port (0x%x)"), unit, source->port));
        }
    
    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_generation_fc_path_get(int unit,
                                       bcm_cosq_fc_direction_type_t fc_direction,
                                       bcm_cosq_fc_endpoint_t *source,
                                       int target_max,
                                       bcm_cosq_fc_endpoint_t *target, /* OUT */
                                       int *target_count)              /* OUT */
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_inband;
    uint32               fc_calender_port, calender_port_max;
    uint32               nof_ilkn_ports;
    bcm_cosq_vsq_info_t  vsq_info;
    bcm_dnx_cosq_tx_cal_t   _tx_cal;
    
    BCMDNX_INIT_FUNC_DEFS;

    /* Init the results counter */

    nof_ilkn_ports = SOC_DNX_DEFS_GET(unit, nof_interlaken_ports);
    
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    }
    else {
        /* Port is incoming NIF */
    
        /* retrieve VSQ inormation */
        rc = _bcm_dnx_cosq_vsq_info_get(unit, source->port, &vsq_info);
        BCMDNX_IF_ERR_EXIT(rc);
        
        for(is_fc_inband = 0; is_fc_inband < 2; is_fc_inband++)
        {
            calender_port_max = is_fc_inband ? nof_ilkn_ports : SOC_DNX_MAX_OOB_PORTS;

            for(fc_calender_port = 0; fc_calender_port < calender_port_max; fc_calender_port++)
            {
                if (is_fc_inband) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
                }
                else {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
                }

                if (_tx_cal.valid != TRUE) {
                    continue;
                }
                
                /* Get CAL FC Targets */
                rc = _bcm_dnx_cosq_cal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, is_fc_inband, fc_calender_port, target_max, 
                                                            target, target_count);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* Get NON-CAL FC Targets */
        rc = _bcm_dnx_cosq_noncal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, target_max, 
                                                           target, target_count);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init values */
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    }
    else {
        /* Port is incoming nif port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)) 
        {
          /* Get FC info according to source port */
          rc = bcm_dnx_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                &is_fc_inband, &fc_calender_port);
          BCMDNX_IF_ERR_EXIT(rc);

          if (is_fc_calender) {
             rc = _bcm_dnx_cosq_cal_reception_fc_path_get(unit, fc_direction, source,
                                    is_fc_inband, fc_calender_port, target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
          else {
              rc = _bcm_dnx_cosq_noncal_reception_fc_path_get(unit, fc_direction, source,
                                                                target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_generation_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) 
    {

        /*Port is link port*/
         rc =  _bcm_dnx_link_fc_delete(unit,fc_direction,source,target); 
        BCMDNX_IF_ERR_EXIT(rc);
    
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
        BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_reception_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_dnx_link_fc_delete(unit,fc_direction,source,target); 

        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
        BCMDNX_FUNC_RETURN;
}

/*
 * Local Functions (Resource allocation)
 */
int
_bcm_dnx_flow_region_config(int unit, int core, int region_start, int region_end,
                              int is_interdigitated, int is_oddEven)
{
    bcm_error_t rc = BCM_E_NONE;    
    DNX_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 dnx_sand_rc;
    int cur_region;

   BCMDNX_INIT_FUNC_DEFS;

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, FLOW REGION Start(%d), End(%d), isInterdigitated %s, isOddEven %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE"), ((is_oddEven) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    DNX_TMC_SCH_GLOBAL_PER1K_INFO_clear(&per1k_info);    
    per1k_info.is_interdigitated = is_interdigitated;
    per1k_info.is_odd_even = is_oddEven;

    /* Currently flexibility to configure this is not there */
    per1k_info.is_cl_cir = TRUE;

    if ( (region_start < (DNX_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1)) ||
         (region_end > ((DNX_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1) +
                        (DNX_DEVICE_COSQ_CONFIG_FLOW_REGIONS(unit) - 1))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }

    for (cur_region = region_start; cur_region <= region_end; cur_region++) {

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_per1k_info_set,(unit, core, cur_region, &per1k_info)));

        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config flow region %d, dnx_sand error 0x%x\n"), unit, cur_region, dnx_sand_rc));
            DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_flow_region_config_get(int unit, int core, int flow_region, uint8 *p_is_interdigitated, int *p_is_oddEven)
{
    bcm_error_t rc = BCM_E_NONE;    
    DNX_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 dnx_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_per1k_info_get,(unit, core, flow_region, &per1k_info)));

    if(DNX_SAND_FAILURE(dnx_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to get flow flow_region %d, dnx_sand error 0x%x\n"), unit, flow_region, dnx_sand_rc));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_interdigitated = per1k_info.is_interdigitated;
    /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_oddEven = per1k_info.is_odd_even;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* This is a callback function, registered to the alloc manager to be called 
 * whenever a new 1k region is allocated.  At that time, we need to set the
 * region to be interdigitated or not.
 */
int
_bcm_dnx_queue_region_config(int unit, int core, int region_start, int region_end,
                               int is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;  

   BCMDNX_INIT_FUNC_DEFS;
   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, QUEUE REGION Start(%d), End(%d), isInterdigitated %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if ( (region_start > (DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ||
         (region_end > (DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ipq_queue_interdigitated_mode_set,
        (unit, core, region_start, is_interdigitated)));
    rc = dnx_handle_sand_result(dnx_sand_rc);

    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ, \
                (BSL_META_U(unit, \
                            "soc_dnx_ipq_queue_interdigitated_mode_set() failed \
                            base queue %d\n"),
                 region_start*1024));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_queue_region_config_get(int unit, int core, int queue_region, uint8 *is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;   

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    if ( (queue_region < 0) || (queue_region > (DNX_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid range for queue region %d"),unit, queue_region ));
    }
    if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_queue_interdigitated_mode_get,(unit, core, queue_region, is_interdigitated)));
    if (DNX_SAND_FAILURE(dnx_sand_rc)) {
        rc = dnx_translate_sand_success_failure(dnx_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving queue region %d, dnx_sand error 0x%x, error 0x%x\n"), unit, queue_region, dnx_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Support Functions - Flow 
 */

int
_bcm_dnx_flow_id_get(int unit, int core, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int is_remove, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    if (core == BCM_CORE_ALL) {
        /*
         * Get operation for all cores: Read from core '0'.
         */
        core = 0 ;
    } else {
        if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for getting flow id."), unit, core));
        }
    }
    flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_remove) {
        (*flow) = DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    }
    else{
        if (is_non_contiguous) {
            if (is_odd_even) {
                (*flow) = (is_composite) ? (base_flow_id + cos * 4) : 
                                                  (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            } else {
                /*Does not matter if composite or not composite*/
                (*flow) = (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            }
        }
        else {
            (*flow) = (is_composite) ? (base_flow_id + cos * 2) : (base_flow_id + cos);
        }

        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_composite_flow_id_get(int unit, int core, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_composite) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, core %d, flow %d, must be composite flow"),unit, core, base_flow_id));
    }

    rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, cos, is_non_contiguous, is_composite, FALSE,flow);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_odd_even && is_non_contiguous) {
        (*flow)=(*flow)&0x2 ? ((*flow)-2) : ((*flow)+2);        
    } else {
        (*flow)++;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* static */ int
_bcm_dnx_se_flow_id_get(int unit, int flow_id, DNX_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case DNX_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case DNX_TMC_SCH_SE_TYPE_HR:
        case DNX_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) && (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case DNX_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_se_composite_flow_id_get(int unit, int flow_id, DNX_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (type) {
        case DNX_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = flow_id + 1;
            } else {
                (*flow) = flow_id + 2;
            }
            break;

        case DNX_TMC_SCH_SE_TYPE_HR:
        case DNX_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 2;
            break;

        case DNX_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = (flow_id & 0x1) ? (flow_id - 1) : (flow_id + 1);
            } else {
                (*flow) = (flow_id & 0x2) ? (flow_id - 2) : (flow_id + 2);
            }
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_dnx_se_dual_flow_id_get(int unit, int flow_id, DNX_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case DNX_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;
            break;

        case DNX_TMC_SCH_SE_TYPE_HR:
        case DNX_TMC_SCH_SE_TYPE_FQ:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            break;

        case DNX_TMC_SCH_SE_TYPE_NONE:
        default:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;

            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if ( (is_interdigitated == FALSE) && (is_composite == FALSE) ) {
        (*nbr_flow_quartets) = 1;
    }
    else if ( (is_interdigitated == TRUE) && (is_composite == TRUE) ) {
        (*nbr_flow_quartets) = 4;
    }
    else {
        (*nbr_flow_quartets) = 2;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cl_mode1_mode_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            DNX_TMC_SCH_SE_INFO *se_config,
                                            DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP4; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP3; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP4; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cl_mode2_mode_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            DNX_TMC_SCH_SE_INFO *se_config,
                                            DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cl_mode3_mode_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            DNX_TMC_SCH_SE_INFO *se_config,
                                            DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cl_mode4_mode_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            DNX_TMC_SCH_SE_INFO *se_config,
                                            DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP2; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP2; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_cl_mode5_mode_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            DNX_TMC_SCH_SE_INFO *se_config,
                                            DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP1; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
static int
_bcm_dnx_cosq_mode_get(int unit, int core, DNX_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_id_index;
    DNX_TMC_SCH_SUBFLOW *sub_flow_config;
    DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    DNX_TMC_SCH_SE_INFO *parent_se = NULL;
    DNX_TMC_SCH_FLOW *parent_flow_config = NULL;
    DNX_TMC_SCH_SE_CL_CLASS_INFO class_type;
    uint32 dnx_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    flow_id_index = (is_sf2 == TRUE) ? 1 : 0;
    sub_flow_config = &(flow_config->sub_flow[flow_id_index]);
    cs_info = &(sub_flow_config->credit_source);

    switch (cs_info->se_type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            switch (cs_info->se_info.hr.sp_class) {
                case DNX_TMC_SCH_FLOW_HR_CLASS_EF1:              (*mode) = BCM_COSQ_SP0;  break;
                case DNX_TMC_SCH_FLOW_HR_CLASS_EF2:              (*mode) = BCM_COSQ_SP1;  break;
                case DNX_TMC_SCH_FLOW_HR_CLASS_EF3:              (*mode) = BCM_COSQ_SP2;  break;
                case DNX_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ:   (*mode) = BCM_COSQ_SP3;  break;
                case DNX_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1:       (*mode) = BCM_COSQ_SP4;  break;
                case DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ:     (*mode) = BCM_COSQ_SP3;  break;
                case DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ:     (*mode) = BCM_COSQ_SP4;  break;
                case DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2:         (*mode) = BCM_COSQ_SP5;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1:     (*mode) = BCM_COSQ_SP3;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2:     (*mode) = BCM_COSQ_SP4;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3:     (*mode) = BCM_COSQ_SP5;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4:     (*mode) = BCM_COSQ_SP6;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5:     (*mode) = BCM_COSQ_SP7;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6:     (*mode) = BCM_COSQ_SP8;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ: (*mode) = BCM_COSQ_SP9;  break;
                case DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2:     (*mode) = BCM_COSQ_SP10; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_SCH_SE_TYPE_CL:            

            BCMDNX_ALLOC(parent_flow_config, sizeof(DNX_TMC_SCH_FLOW), "sch flow");
            BCMDNX_ALLOC(parent_se, sizeof(DNX_TMC_SCH_SE_INFO), "se");
            if ( (parent_flow_config == NULL) ||(parent_se == NULL) ) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            DNX_TMC_SCH_SE_INFO_clear(parent_se);
            DNX_TMC_SCH_FLOW_clear(unit, parent_flow_config);
            DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            /* retrieve parent element */
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core,cs_info->id, parent_se, parent_flow_config)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up scheduler element %d, type %s, dnx_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, "cl", dnx_sand_rc, rc));
                goto err;
            }

            /* determine parent element attribute */
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, parent_se->type_info.cl.id, &class_type)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, parent_se->type_info.cl.id, dnx_sand_rc, rc));
                goto err;
            }

            /* map the element attribute to user specified scheduling discipline */
            switch (class_type.mode) {
                case DNX_TMC_SCH_CL_MODE_1:
                    rc = _bcm_dnx_cosq_cl_mode1_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case DNX_TMC_SCH_CL_MODE_2:
                    rc = _bcm_dnx_cosq_cl_mode2_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case DNX_TMC_SCH_CL_MODE_3:
                    rc = _bcm_dnx_cosq_cl_mode3_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case DNX_TMC_SCH_CL_MODE_4:
                    rc = _bcm_dnx_cosq_cl_mode4_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case DNX_TMC_SCH_CL_MODE_5:
                    rc = _bcm_dnx_cosq_cl_mode5_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                default: rc = BCM_E_PARAM; goto err; break;
            }
           BCM_FREE(parent_flow_config);
           BCM_FREE(parent_se);
            break;

        case DNX_TMC_SCH_SE_TYPE_FQ: (*mode) = BCM_COSQ_SP0; break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (parent_flow_config != NULL)
       BCM_FREE(parent_flow_config);
    if (parent_se != NULL) 
       BCM_FREE(parent_se);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_class_cl_mode1_info_get(int unit, DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dnx_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_class_cl_mode2_info_get(int unit, DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dnx_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_class_cl_mode3_info_get(int unit, DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dnx_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;
              
        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_class_cl_mode4_info_get(int unit, DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dnx_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_credit_class_cl_mode5_info_get(int unit, DNX_TMC_SCH_SE_INFO *se_config, DNX_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dnx_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {

        case DNX_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0:
                         DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the "flow mode info" that corresponds to the attach point (i.e. mode) of
 * the child. The "flow info mode" contains information of flow type to be configured in child
 * flow and the parents weight mode corresponding to this attach point.
 */
static int
_bcm_dnx_cosq_credit_class_info_get(int unit, int core, DNX_TMC_SCH_SE_INFO *se_config, int mode, bcm_dnx_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 dnx_sand_rc;    
    DNX_TMC_SCH_SE_CL_CLASS_INFO class_type;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch(se_config->type) {
        case DNX_TMC_SCH_SE_TYPE_HR:
            switch (se_config->type_info.hr.mode) {
                case DNX_TMC_SCH_HR_MODE_SINGLE_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                case DNX_TMC_SCH_HR_MODE_DUAL_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP5: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                case DNX_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_CLASS_EF3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP4: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP5: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP6: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP7: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP8: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP9: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ, DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP10: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, DNX_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_SCH_SE_TYPE_CL:            
            DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, se_config->type_info.cl.id, &class_type)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, se_config->type_info.cl.id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            switch (class_type.mode) {
                case DNX_TMC_SCH_CL_MODE_1:
                    rc = _bcm_dnx_cosq_credit_class_cl_mode1_info_get(unit, se_config, &class_type,mode, info); break;
                case DNX_TMC_SCH_CL_MODE_2:
                    rc = _bcm_dnx_cosq_credit_class_cl_mode2_info_get(unit, se_config, &class_type,mode, info); break;
                case DNX_TMC_SCH_CL_MODE_3:
                    rc = _bcm_dnx_cosq_credit_class_cl_mode3_info_get(unit, se_config, &class_type,mode, info); break;
                case DNX_TMC_SCH_CL_MODE_4:
                    rc = _bcm_dnx_cosq_credit_class_cl_mode4_info_get(unit, se_config, &class_type,mode, info); break;
                case DNX_TMC_SCH_CL_MODE_5:
                    rc = _bcm_dnx_cosq_credit_class_cl_mode5_info_get(unit, se_config, &class_type,mode, info); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case DNX_TMC_SCH_SE_TYPE_FQ:
            switch(mode) {
                case BCM_COSQ_SP0: DNX_DEVICE_COSQ_CLASS_INFO_INIT(info, -1, DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
static int
_bcm_dnx_cosq_sched_enhanced_mode_get(int unit, int core, DNX_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode)
{
    bcm_error_t                rc = BCM_E_NONE;
    uint32                     dnx_sand_rc;    
    DNX_TMC_SCH_SE_CL_CLASS_INFO   class_type;


    BCMDNX_INIT_FUNC_DEFS;
    switch (sch_info->type) {
        case DNX_TMC_SCH_SE_TYPE_CL:            
            DNX_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_class_type_params_get,(unit, core, sch_info->type_info.cl.id, &class_type)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), dnx_sand error 0x%x, error 0x%x\n"), unit, sch_info->type_info.cl.id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            (*enhanced_mode) = class_type.enhanced_mode;
            (*is_enhanced) = ( (class_type.enhanced_mode == DNX_TMC_CL_ENHANCED_MODE_ENABLED_HP) ||
                  (class_type.enhanced_mode == DNX_TMC_CL_ENHANCED_MODE_ENABLED_LP) ) ? TRUE : FALSE;
            break;

        case DNX_TMC_SCH_SE_TYPE_HR:
        case DNX_TMC_SCH_SE_TYPE_FQ:
        default:
            (*is_enhanced) = FALSE;
            (*enhanced_mode) = DNX_TMC_SCH_CL_ENHANCED_MODE_LAST; /* not valid */
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the cl discrete weight  as viewed by the user application.
 */
static int
_bcm_dnx_cosq_cl_sched_weight_get(int unit, DNX_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dnx_cosq_class_info_t *info, int *weight)
{
    bcm_error_t                rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (cs_info->se_info.cl.sp_class) {
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL0;
            break;

        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL1;
            break;

        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL2;
            break;

        case DNX_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL3;
            break;

        default:
            rc = BCM_E_INTERNAL;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


static int
_bcm_dnx_cosq_credit_class_weight_validate(int unit, int weight, bcm_dnx_cosq_class_info_t *info, int *updated_type)
{
    bcm_error_t rc = BCM_E_NONE;
    int discrete_weight_index = 0;


    BCMDNX_INIT_FUNC_DEFS;
    switch (info->weight_mode) {
        case DNX_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case DNX_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
             if (weight <= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             else if (weight > info->max_weight) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
        case DNX_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
             if (weight >= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
            
             for (discrete_weight_index = 0; (weight != 0) &&
                    (discrete_weight_index < BCM_DEVICE_DNX_COSQ_DWEIGHT_MAX_INDEX);
                                                              discrete_weight_index++) {
                 weight++;
             }
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             if (discrete_weight_index > info->max_discrete_class) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type + (discrete_weight_index - 1);
          
             break;

        default:
             rc = BCM_E_PARAM;
             break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_port_tcg_validate(int unit, bcm_gport_t gport, DNX_TMC_TCG_NDX tcg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* retrieve port */
    rc = bcm_dnx_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (tcg >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities, gport, tcg, rc));
    }

    if (nof_priorities != DNX_COSQ_TCG_NOF_PRIORITIES_SUPPORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d TCG is not supported for given port 0x%x. "), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* retrieve port */
    rc = bcm_dnx_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (cosq >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities - 1, gport, cosq, rc));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Note:
 *   This procedure uses sal_alloc() to allocate memory and load pointer
 *   into '*info_p'. If loaded value is NULL then no memory has been
 *   allocated.
 *   When OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is zero, then the caller is
 *   assumed to free allocated memory using sal_free() {provided pointer
 *   to memory block is not NULL}.
 */
static int
_bcm_dnx_cosq_alloc_n_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t in_cosq, int flags, bcm_dnx_cosq_gport_info_t **info_p)
{
    bcm_error_t rc ;
    int is_child, is_parent, is_sched_object_ns, is_connnector_object;
    uint8 is_connector, is_se ;
    uint8 is_non_contiguous, is_composite, is_dual ;
    uint8 is_sf2 ;
    int is_odd_even ;
    int base_flow_id, flow_id, sf2_id, flow_region;
    DNX_TMC_SCH_SE_ID se_id ;
    int pass2 ;
    bcm_dnx_cosq_gport_info_t *info ;
    DNX_TMC_SCH_FLOW *flow_config;
    DNX_TMC_SCH_SE_INFO *se_config;
    uint32 dnx_sand_rc, tm_port;
    int gport_sf2_type;
    int priority ;
    int state_check, is_warmboot_phase, is_reserved ;
    int fap_port, core;
    uint8 sw_state_num_cos;
    uint32 sw_state_ref_cnt;
      /*
       * Flag. Indicating whether entry corresponding to indicated flow id
       * has been found. The index indicates the stage.
       */
    int entry_was_found[2] = {0,0} ;
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
      /*
       * Indication, for cache, on source of flow_id. A match is full
       * only if both 'flow_id' and 'source_of_flow_id' are the same.
       */
    int source_of_flow_id ;
      /*
       * Storage of flow id after first stage. used to detect change
       * on second stage within this procedure.
       */
    int first_stage_flow_id ;
    bcm_dnx_cosq_vig_leaf_t vig_leaf ;
      /*
       * Pointer to data section on leaf allocated for info
       * collected by this procedure for the 'base_flow_id'.
       */
    bcm_dnx_cosq_vig_leaf_t *base_vig_leaf_on_tree ;
      /*
       * Pointer to data section on leaf allocated for info
       * collected by this procedure for the 'final_flow_id'.
       */
    bcm_dnx_cosq_vig_leaf_t *final_vig_leaf_on_tree ;
/* } */
#endif
    BCMDNX_INIT_FUNC_DEFS ;

    /*
     * Initialize pointer to 'flow info' area to NULL to indicate it has not yet
     * been allocated and loaded by meaningful info. It will only be loaded at the
     * exit (or just going to exit) of this procedure.
     */
    *info_p = NULL ;
    info = NULL ;

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
      sal_memset(&(vig_leaf.gport_info),0x0,sizeof(vig_leaf.gport_info)) ;
      vig_leaf.valid = 0 ;
      vig_leaf.is_base_flow = 0 ;
      vig_leaf.is_final_flow = 0 ;
      vig_leaf.base_flow_id = (int)(-1) ;
      base_vig_leaf_on_tree = NULL ;
    } else {
      BCMDNX_ALLOC(info, sizeof(*info), "flow info") ;
      if (info) {
        sal_memset(info,0x0,sizeof(*info)) ;
        BCMDNX_ALLOC(info->flow_config, sizeof(*(info->flow_config)), "sch flow") ;
        BCMDNX_ALLOC(info->se_config, sizeof(*(info->se_config)), "se") ;
      }
      if ( (info == NULL) ||((info->flow_config) == NULL) ||((info->se_config) == NULL) ) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "unit %d, resource memory allocation failure\n"), unit));
        if(info) {
            BCM_FREE(info->se_config);
            BCM_FREE(info->flow_config);
        }
        BCM_FREE(info);
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
      }
    }

    final_vig_leaf_on_tree = NULL;
/* } */
#else
/* { */
    BCMDNX_ALLOC(info, sizeof(*info), "flow info") ;
    if (info) {
        sal_memset(info,0x0,sizeof(*info)) ;
        BCMDNX_ALLOC(info->flow_config, sizeof(*(info->flow_config)), "sch flow") ;
        BCMDNX_ALLOC(info->se_config, sizeof(*(info->se_config)), "se") ;
    }
    if ( (info == NULL) ||((info->flow_config) == NULL) ||((info->se_config) == NULL) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                          "unit %d, resource memory allocation failure\n"), unit));
        if (info) {
            BCM_FREE(info->se_config);
            BCM_FREE(info->flow_config);
        }
        BCM_FREE(info);
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

/* } */
#endif

    rc = BCM_E_NONE;
    is_connector = FALSE ;
    is_se = FALSE ;
    is_non_contiguous = FALSE ;
    is_composite = FALSE ;
    is_dual = FALSE ;
    is_sf2 = FALSE;
    is_odd_even = TRUE;
    base_flow_id = -1 ;
    flow_id = -1 ;
    sf2_id = -1 ;
    se_id = 0;
    pass2 = FALSE ;
    priority = 0;
    state_check = FALSE ;
    is_warmboot_phase = FALSE ;
    {
        rc = _bcm_dnx_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        /*
         * Note that vig_leaf.gport_info.flow_config and vig_leaf.gport_info.se_config
         * are not loaded here. They will be loaded when 'lookup' is invoked.
         */
        flow_config = &(vig_leaf.flow_config) ;
        se_config = &(vig_leaf.se_config);
    }
    else
    {
        /* coverity[deref_ptr:FALSE] */
        flow_config = info->flow_config;
        se_config = info->se_config;
    }
/* } */
#else
/* { */
    /* coverity[deref_ptr:FALSE] */
    flow_config = info->flow_config;
    se_config = info->se_config;
/* } */
#endif
    /*
     * First stage (for getting flow_id)
     */
    DNX_TMC_SCH_FLOW_clear(unit, flow_config);
    DNX_TMC_SCH_SE_INFO_clear(se_config);    

    is_child = (flags & dnx_device_cosq_gport_child_element) ? TRUE : FALSE;
    is_parent = (flags & dnx_device_cosq_gport_parent_element) ? TRUE : FALSE;
    is_sched_object_ns = (flags & dnx_device_cosq_gport_sched_nocirpir_ds_element) ? TRUE : FALSE;
    is_connnector_object = (flags & dnx_device_cosq_gport_connector_element) ? TRUE : FALSE;

#ifdef BCM_WARM_BOOT_SUPPORT
    BCM_DNX_UNIT_CHECK(unit);

    if (SOC_WARM_BOOT(unit)) {
        is_warmboot_phase = TRUE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /*
     * consistency checks
     */
    if (is_child) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), gport));
        }
    }  

    if (is_parent) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), gport));
        }
    }

    if (is_sched_object_ns) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected sched object name space gport type, 0x%x"), gport));
        }
    }

    if (is_connnector_object) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
        }

        if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
            BCM_INT_DNX_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
            if (gport_sf2_type != BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) {
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
            }
        }
    }

    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
            BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        if ((in_cosq != 0) && (in_cosq != -1)) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        if ((in_cosq < 0) || (in_cosq > DNX_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        if ((in_cosq < 0) || (in_cosq > DNX_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_connector = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DNX_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == FALSE) {
            is_se = TRUE;
            if ((in_cosq != 0) && (in_cosq != -1)) { 
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
            }
        }
        else {
            if ((in_cosq < 0) || (in_cosq > DNX_DEVICE_COSQ_MAX_COS)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
            }
        }
    }
    /*
     * Determine whether the gport is valid (pass1).
     * Also,classify the source for getting flow_id (for OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY)
     */
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /*
     * This is not necessary. Just precaution.
     */
    source_of_flow_id = 0 ;
/* } */
#endif
    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        /*
         * Reminder: For JER2_ARAD, returned 'core' should be '0'.
         */
        rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
            priority = DNX_COSQ_PB_DEFAULT_PORT_TC;
        } else {
            /* Port-TC */
            /* validate priority */
            rc = _bcm_dnx_cosq_port_priority_validate(unit,gport,in_cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport, in_cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            priority = in_cosq ;
        }

        rc = _bcm_dnx_cosq_port2se_id(unit,core,tm_port,priority,&se_id);
        if (rc != BCM_E_NONE || se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, tm_port));
        }

        base_flow_id = flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_id)));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_E2E_PORT ;
/* } */
#endif
        /* retrieve SE info */
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        base_flow_id = flow_id = BCM_GPORT_SCHEDULER_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_SCHEDULER ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_CIR_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_SCHED_CIR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_PIR_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_SCHED_PIR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_VOQ_CONNECTOR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        is_sf2 = TRUE;
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = DNX_COSQ_VIG_SRC_FID_COMPOSITE_SF2 ;
/* } */
#endif
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, /* port */0));
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /*
     * End of first stage (for getting flow_id). Beginning of second stage.
     * At this point, flow_id has been calculated (and is equal to 'base_flow_id').
     */
    first_stage_flow_id = flow_id ;

    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        if (Vig_db[unit]) {
            entry_was_found[0] =
                bcm_dnx_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&base_vig_leaf_on_tree) ;
            if (entry_was_found[0]) {
                /*
                 * Matching entry has been found. Use information on data base for second stage.
                 * Pointer to structure of type 'bcm_dnx_cosq_vig_leaf_t' (on data base)
                 * is returned on base_vig_leaf_on_tree.
                 */
                /*
                 * Found entry must be marked as 'base flow'.
                 */
                if (!(base_vig_leaf_on_tree->is_base_flow)) {
                    rc = BCM_E_INTERNAL ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Found base flow entry (but is not marked as such)\r\n")) ) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                /*
                 * Info on leaf/element (on data base) should be valid.
                 */
                {
                    /*
                     * Point 'flow_config' and 'se_config' to locations in found entry
                     * and do not reread them from HW again.
                     */
                    info = &(base_vig_leaf_on_tree->gport_info) ;
                    flow_config = info->flow_config ;
                    se_config = info->se_config ;
                    se_id = info->se_id ;
                    *info_p = info ;
                }
            } else {
                /*
                 * No matching entry has been found. Data need to be collected and
                 * inserted into binary tree.
                 * Empy element (invalid) is pointed by 'base_vig_leaf_on_tree'.
                 */
            }
        } else {
            /*
             * Data base has not yet been initialized. Do all required initializations,
             * collect VIG info and load into db.
             */
            rc = bcm_dnx_vig_db_create(unit,(bcm_dnx_cosq_vig_leaf_t **)&Vig_db[unit]) ;
            if (rc != 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "failed to create binary tree: error0x%08lX\r\n"), (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            entry_was_found[0] =
                bcm_dnx_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&base_vig_leaf_on_tree) ;
        }
        /*
         * At this point, the data base (direct table/tree) is set.
         * 'base_vig_leaf_on_tree' is pointed to corresponding element/leaf.
         * If 'entry_was_found[0]' is not set then we need to load entry with
         * data collected so far.
         * Otherwise, found entry is valid and contains collected data which will be
         * used below until a new flow_id is indicated (or current flow_id is
         * also used as new).
         */
    }
/* } */
#endif
    if ( (is_se) && (base_flow_id != -1) ) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'se_id' needs
             * to be calculated (jer2_arad_sch_flow2se_id()).
             */
            se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, base_flow_id)));
        }
        if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE associated with flow %d"), unit, base_flow_id));
        }
    }

    if (is_connector) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'flow_config' needs
             * to be loaded from chip memory (jer2_arad_sch_flow_get()).
             */
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_get,(unit, core, base_flow_id, flow_config)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retrieving sch flow (%d), dnx_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
    else if (is_se) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'flow_config' and
             * 'se_config' need to be loaded from chip memory (jer2_arad_sch_aggregate_get()).
             */
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, se_config, flow_config)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retrieving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, se_id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
      if (!entry_was_found[0])
      {
        /*
         * If matching entry in data base has NOT been found then insert new
         * entry into data base.
         *
         * Insert info collected on 'vig_leaf' into data base (tree/direct table)
         */
        bcm_dnx_cosq_gport_info_t *loc_info ;

        vig_leaf.gport = (int)gport ;
        vig_leaf.is_base_flow = 1 ;
        vig_leaf.base_flow_id = base_flow_id ;
        vig_leaf.source_of_flow_id = source_of_flow_id ;
        /*
         * copy info collected on 'vig_leaf' to element on data base (pointed by )
         */
        *base_vig_leaf_on_tree = vig_leaf ;

        /* update data structure */
        base_vig_leaf_on_tree->gport_info.is_connector = is_connector;
        base_vig_leaf_on_tree->gport_info.is_se = is_se;
        base_vig_leaf_on_tree->gport_info.is_sf2 = is_sf2;
        base_vig_leaf_on_tree->gport_info.flow_id = flow_id;
        if (is_se) {
            base_vig_leaf_on_tree->gport_info.se_id = se_id;
        }
        base_vig_leaf_on_tree->gport_info.actual_flow_id = flow_id;
        if (is_sf2) {
            base_vig_leaf_on_tree->gport_info.actual_flow_id = sf2_id;
        }
        base_vig_leaf_on_tree->gport = (int)gport ;
        /*
         * Info is of type 'bcm_dnx_cosq_gport_info_t'. We now need to update it
         * with pointers (on newly allocated tree) to some of collected data.
         */
        loc_info = &(base_vig_leaf_on_tree->gport_info) ;
        flow_config = loc_info->flow_config = &(base_vig_leaf_on_tree->flow_config) ;
        se_config = loc_info->se_config = &(base_vig_leaf_on_tree->se_config) ;
        /*
         * Later on, just before exit-without-errors, we shall mark info on
         * element/leaf (on data base) as valid.
         * Also, if, at exit, we find that first_stage flow_id remained as the final
         * one then we may need to update some items on the data base.
         */
      }
    }
/* } */
#endif

    is_composite = ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                            (flow_config->sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
    flow_region = BCM_DEVICE_DNX_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_dnx_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    /* determine if pass2 is required */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        if (se_config->is_dual == TRUE) {
            if (is_sched_object_ns == TRUE) {
                is_dual = TRUE;
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d,gport 0x%08lX, not a dual configuration for se 0x%x"), unit, gport, se_id));
            }
        }
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) {
        if (se_config->is_dual == FALSE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        if (se_config->is_dual == FALSE) {
            LOG_INFO(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                "Flow id (%d) PIR not marked as dual (first_stage_flow_id %d). gport 0x%08lX\r\n"),
                  flow_id,first_stage_flow_id,(unsigned long)gport) ) ;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
        rc = _bcm_dnx_se_dual_flow_id_get(unit, base_flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &flow_id);
        BCMDNX_IF_ERR_EXIT(rc);
        se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, flow_id)));
        if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE associated with flow %d"), unit, flow_id));
        }
        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        
        rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite, FALSE,&flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        if (is_connector) {
            rc = _bcm_dnx_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite, FALSE, &flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            pass2 = TRUE;

            rc = _bcm_dnx_composite_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite,&sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_dnx_se_composite_flow_id_get(unit, base_flow_id, DNX_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        /*
         * END OF SECOND STAGE. If flow_id has been changed, mark it.
         */
        if (flow_id != first_stage_flow_id)
        {
            /*
             * Initial flow_id ('base_flow_id') was changed. We need to use
             * another entry for the new flow id. This is done at exit.
             * Note that the 'base' entry has, by now, either been found or newly created
             * and, in any case, it is in the data base.
             * If we have 'entry not found' on first stage then force 'not found'
             * on this second stage. We do this to keep consistency. {The scenario of
             * 'not found' on first and 'found' on second could be due to 'remnants' of a previous
             * storage (with different 'source_of_flow_id'). Remember that we mark 'not found' if
             * there is no match on 'source_of_flow_id'}
             */
            entry_was_found[1] =
                bcm_dnx_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&final_vig_leaf_on_tree) ;
            if (!entry_was_found[0]) { /* Flow id found on second stage but not on first stage */
                final_vig_leaf_on_tree->valid = 0 ;
                entry_was_found[1] = 0 ;
            }
            if (entry_was_found[1]) {
                /*
                 * Matching entry has been found. Return to caller with pointer to
                 * information on data base.
                 * Note that this entry needs to have 'final_vig_leaf_on_tree->is_final_flow' set!!
                 */
                if (final_vig_leaf_on_tree->is_final_flow == 0)
                {
                    /*
                     * Should not happen!
                     */
                    rc = BCM_E_PARAM ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Found valid entry (but not marked final)\r\n")) ) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                /*
                 * Info on element/leaf (on data base) should be valid.
                 */
                {
                    info = &(final_vig_leaf_on_tree->gport_info) ;
                    *info_p = info ;
                    goto exit ;
                }
            } else {
                /*
                 * No matching entry has been found. Data need to be collected and
                 * inserted into data base. Element on db is pointed by 'final_vig_leaf_on_tree'
                 */
                flow_config = &(vig_leaf.flow_config) ;
                se_config = &(vig_leaf.se_config);
            }
        }
        else
        {
            /*
             * Flow_id has NOT change on second stage
             *
             */
            if (entry_was_found[0])
            {
                /*
                 * Entry HAS been found on first stage.
                 * No need to update information collected above. Go to exit.
                 */
                goto exit ;
            }
            else
            {
                /*
                 * Entry HAS NOT been found on first stage
                 * We need to proceeed and load entry just before exit.
                 */
            }
        }
    }
/* } */
#endif
    /* pass 2 processing */
    if (pass2 == TRUE) {
        if (is_connector) {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_flow_get,(unit, core, flow_id, flow_config)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving sch flow (%d), dnx_sand error 0x%x, error 0x%x\n"), unit, flow_id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
        else if (is_se) {
            dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, se_config, flow_config)));
            if (DNX_SAND_FAILURE(dnx_sand_rc)) {
                rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving scheduler element %d, dnx_sand error 0x%x, error 0x%x\n"), unit, se_id, dnx_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }

    /* state consistency check */
    /* NOTE: if required checking can be based on any additional flags that may be later added */
    if ( (is_warmboot_phase == FALSE) &&
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if (is_connector) {
            _bcm_dnx_cosq_is_conn_reserved(unit, base_flow_id, &is_reserved);
            if (is_reserved != TRUE) {
                state_check = TRUE;
            }
        }
        else if (is_se) {
            fap_port = DNX_COSQ_SCH_PORT_ID_INVALID(unit);
            _bcm_dnx_cosq_is_se_reserved(unit, core, se_id, &is_reserved);
            rc = _bcm_dnx_cosq_se_id2port(unit, core, se_id, &fap_port, &priority);
            if (rc != BCM_E_NONE) {
                state_check = TRUE;
            }
            else if ( (is_reserved != TRUE) && (fap_port == DNX_COSQ_SCH_PORT_ID_INVALID(unit)) ) {
                state_check = TRUE;
            }
        }
    }
    if (state_check == TRUE) {
        if (is_connector) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
            if ((sw_state_num_cos == 0) || (in_cosq >= sw_state_num_cos) ) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else if (is_se) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
            if (sw_state_ref_cnt == 0) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    {
        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
        {
            if (!entry_was_found[0])
            {
              /*
               * Note that we enter here also when no match was found on both
               * first stage and second stage.
               * If entry was not found on first stage then this is a good place
               * (after all validity checks) to mark collected info (in data base)
               * as valid.
               * At any point before this one, then, it is not marked as valid so
               * that any validity fail blocks update of the data base.
               */
              base_vig_leaf_on_tree->gport_info.is_non_contiguous = is_non_contiguous;
              base_vig_leaf_on_tree->gport_info.is_dual = is_dual;
              base_vig_leaf_on_tree->gport_info.is_composite = is_composite;
              if (flow_id == first_stage_flow_id)
              {
                if (is_se) {
                    base_vig_leaf_on_tree->gport_info.se_id = se_id;
                }
                if (is_sf2) {
                    base_vig_leaf_on_tree->gport_info.actual_flow_id = sf2_id;
                }
                /*
                 * Mark this entry as 'containing info on final flow'.
                 */
                base_vig_leaf_on_tree->is_final_flow = 1 ;
                /*
                 * We load 'info' here since this is the final flow.
                 */
                info = &(base_vig_leaf_on_tree->gport_info) ;
              }
              base_vig_leaf_on_tree->valid = 1 ;
            }
            if (flow_id != first_stage_flow_id)
            {
                /*
                 * If flow_id has changed on the second stage then a new entry needs to
                 * be updated in the data base. Entry is pointed by 'final_vig_leaf_on_tree'
                 */

                /* update data structure */
                vig_leaf.gport_info.is_connector = is_connector;
                vig_leaf.gport_info.is_se = is_se;
                vig_leaf.gport_info.is_composite = is_composite;
                vig_leaf.gport_info.is_non_contiguous = is_non_contiguous;
                vig_leaf.gport_info.is_dual = is_dual;
                vig_leaf.gport_info.is_sf2 = is_sf2;
                vig_leaf.gport_info.flow_id = flow_id;
                if (is_se) {
                    vig_leaf.gport_info.se_id = se_id;
                }
                vig_leaf.gport_info.actual_flow_id = flow_id;
                if (is_sf2) {
                    vig_leaf.gport_info.actual_flow_id = sf2_id;
                }
                vig_leaf.gport = (int)gport ;
                vig_leaf.source_of_flow_id = source_of_flow_id ;
                vig_leaf.base_flow_id = base_flow_id ;
                /*
                 * Mark this entry as 'containing info on final flow'.
                 */
                vig_leaf.is_final_flow = 1 ;
                *final_vig_leaf_on_tree = vig_leaf ;
                /*
                 * Info is of type 'bcm_dnx_cosq_gport_info_t'. We now need to update it
                 * with pointers (on newly allocated tree) to some of collected data.
                 */
                info = &(final_vig_leaf_on_tree->gport_info) ;
                info->flow_config = &(final_vig_leaf_on_tree->flow_config) ;
                info->se_config = &(final_vig_leaf_on_tree->se_config) ;
                /*
                 * Mark info on leaf (on tree) as valid.
                 */
                final_vig_leaf_on_tree->valid = 1 ;
            }
            else
            {
                /*
                 * flow_id has NOT changed on the second stage so the 'base' entry
                 * (which is, by now, also the 'final' entry) needs to be used for update here.
                 */
                if (entry_was_found[0])
                {
                    /*
                     * flow_id has NOT changed on the second stage and 'base' entry has been found.
                     * In that case, program flow should take it to 'exit' so we should never get here!
                     */
                    rc = BCM_E_INTERNAL ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "flow_id NOT changed on 2nd and 'base' entry was found but - program did not go to exit: error(0x%08lX)\r\n"), (unsigned long)rc)) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
        }
        else
        {
            /* update data structure */
            info->is_connector = is_connector;
            info->is_se = is_se;
            info->is_composite = is_composite;
            info->is_non_contiguous = is_non_contiguous;
            info->is_dual = is_dual;
            info->is_sf2 = is_sf2;
            info->flow_id = flow_id;
            if (is_se) {
                info->se_id = se_id;
            }
            info->actual_flow_id = flow_id;
            if (is_sf2) {
                info->actual_flow_id = sf2_id;
            }
        }
    }
/* } */
#else
/* { */
    /* update data structure */
    info->is_connector = is_connector;
    info->is_se = is_se;
    info->is_composite = is_composite;
    info->is_non_contiguous = is_non_contiguous;
    info->is_dual = is_dual;
    info->is_sf2 = is_sf2;
    info->flow_id = flow_id;
    if (is_se) {
        info->se_id = se_id;
    }
    info->actual_flow_id = flow_id;
    if (is_sf2) {
        info->actual_flow_id = sf2_id;
    }
/* } */
#endif
    /*
     * Only now load pointer to allocated memory into place (to be used
     * by the caller).
     */
    *info_p = info ;

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id)
{
    int rc = BCM_E_NONE;

   
    BCMDNX_INIT_FUNC_DEFS;
    if (is_non_contiguous) {
        if (!(flow_id & 0x2)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector 0x%x not at an offset of 2\n"), unit, flow_id));
            rc = BCM_E_PARAM;
        }
    }
    switch (is_non_contiguous) {
        case TRUE:
            switch (is_composite) {
                case TRUE:
                    if (((flow_id - 0x2) % (num_cos * 4)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*4, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if (((flow_id - 0x2) % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*2, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        case FALSE:
            switch (is_composite) {
                case TRUE:
                    if ((flow_id % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*2, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if ((flow_id % num_cos) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        default: rc = BCM_E_PARAM; break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, int allow_core_all, bcm_gport_t *parent_port)
{
    bcm_error_t rc = BCM_E_NONE;
    int sched_id, core;
    bcm_gport_t sw_state_isq_port, sw_state_fmq_class_port;



    BCMDNX_INIT_FUNC_DEFS;
    (*parent_port) = sched_port;

    if (BCM_GPORT_IS_SCHEDULER(sched_port)) {
        sched_id = BCM_GPORT_SCHEDULER_GET(sched_port);
        rc = _bcm_dnx_cosq_core_get(unit, sched_port, allow_core_all, &core);
        BCMDNX_IF_ERR_EXIT(rc);

        if (sched_id >= DNX_COSQ_SCH_MAX_FLOW_ID(unit)) {
            switch (sched_id) {
                case _SHR_GPORT_FMQ_CLASS1:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 0, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-1 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS2:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 1, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-2 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS3:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 2, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-3 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS4:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 3, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-4 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_ISQ_ROOT:
                  BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.isq_port.get(unit, core, &sw_state_isq_port));
                  if (sw_state_isq_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, ISQ resource not allocated, need to set isq range\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_isq_port;
                    break;
            default:
              (*parent_port) = sched_port;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Utility Functions
 */


/* function which returns pbmp or internal port associated with the given FAP port */
int
bcm_dnx_tm_port_get(int unit, int core, int p_fap_port, bcm_port_t* port)
{
    soc_port_t out_port;
    BCMDNX_INIT_FUNC_DEFS;

    if (core == BCM_CORE_ALL) {
        /*
         * Get operation for all cores: Read from core '0'.
         */
        core = 0 ;
    } else {
        if ((core < 0 || core >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for getting flow id."), unit, core));
        }
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_tm_to_local_port_get,(unit, core, p_fap_port, &out_port)));

   *port = out_port;

exit:
    BCMDNX_FUNC_RETURN;
}

/* Returns the FAP port associated with the given mod:port gport */
static int
_bcm_dnx_cosq_fap_port_get(int unit, bcm_gport_t gport, uint32 *p_fap_port, int* core, int *is_interface)
{
    bcm_port_t port = 0;
    int is_interface_gport = FALSE;
    bcm_port_t     mod_port; 
    bcm_module_t    modid, base_modid;
    int                 rv = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);

        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DNX_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }

    } else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);
        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            port -= BCM_DNX_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }
    } else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);        
    } else if (BCM_GPORT_IS_MODPORT(gport)) {
        mod_port = BCM_GPORT_MODPORT_PORT_GET(gport);
        modid = BCM_GPORT_MODPORT_MODID_GET(gport);

        rv = bcm_dnx_stk_my_modid_get(unit, &base_modid);
        BCMDNX_IF_ERR_EXIT(rv);

        if (SOC_DNX_IS_MODID_AND_BASE_MODID_ON_SAME_FAP(unit, modid, base_modid)){

            *core = SOC_DNX_MODID_TO_CORE(unit, base_modid, modid);
            rv = dnx_port_sw_db_tm_to_local_port_get(unit, *core, mod_port, (soc_port_t *)&port);
            BCMDNX_IF_ERR_EXIT(rv);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
        }

        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DNX_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }
        
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    } else if ((SOC_PORT_VALID(unit, port)) && (IS_PORT(unit, port))) {
        port = gport;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_local_to_tm_port_get, (unit, port, p_fap_port, core)));

    if (is_interface != NULL) {
        (*is_interface) = is_interface_gport;
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) port(%d) fap_port(%d)\n"), unit, port, *p_fap_port));
    
exit:
    BCMDNX_FUNC_RETURN;
}
/*************************************************************
*  NAME
*    _bcm_dnx_cosq_core_get
*  TYPE:
*    PROC
*  DATE:
*    13/11/2014
*  FUNCTION:
*    Given 'unit' and 'gport', get corresponding core.
*  INPUT:
*    Direct:
*      int unit -
*        Identifier of device to access.
*      bcm_gport_t gport -
*        Identifier of gport to deduce 'core' from.
*      int *core -
*        This procedure loads pointed memory by identifier of
*        corresponding 'core'
*    Indirect:
*      None
*  OUTPUT:
*    Direct:
*      BCM_E_NONE or error code as per bcm_error_t.
*    Indirect:
*      *core 
*  REMARKS:
*    
*  See also:
*    BCM_GPORT_IS_SCHEDULER, BCM_COSQ_GPORT_IS_VOQ_CONNECTOR
**************************************************************/
int
_bcm_dnx_cosq_core_get(int unit, bcm_gport_t gport, int allow_core_all, int *core)
{
  uint32 fap_port ;

  BCMDNX_INIT_FUNC_DEFS ;
  BCMDNX_NULL_CHECK(core) ;
  if (SOC_DNX_DEFS_GET(unit, nof_cores) <= 1)
  {
    *core = 0 ;
  }
  else if (BCM_COSQ_GPORT_IS_CORE(gport)) {
    *core = BCM_COSQ_GPORT_CORE_GET(gport);
  }
  else if (BCM_GPORT_IS_SCHEDULER(gport))
  {
    *core = BCM_GPORT_SCHEDULER_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))
  {
    *core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport))
  {
    *core = BCM_COSQ_GPORT_SCHED_CIR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport))
  {
    *core = BCM_COSQ_GPORT_SCHED_PIR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport))
  {
    *core = BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_GET(gport) ;
  }
  else
  {
    BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_fap_port_get(unit,gport,&fap_port,core, NULL)) ;
  }

  /* If extracted core is out of bounds then return with error. */
  SOC_DNX_CORE_VALIDATE(unit, (*core), allow_core_all);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port)
{
    int rc = BCM_E_NONE;
    bcm_port_t port = 0;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);

        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            port -= BCM_DNX_PORT_INTERFACE_START;
        }        
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);

        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            port -= BCM_DNX_PORT_INTERFACE_START;
        }
    }
    else if (BCM_GPORT_IS_MODPORT(gport)) {
        port = BCM_GPORT_MODPORT_PORT_GET(gport);

        if (BCM_DNX_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DNX_PORT_INTERFACE_START;
        }
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    }
    else if ((SOC_PORT_VALID(unit, gport)) && (IS_PORT(unit, gport))) {
        port = gport;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    (*user_port) = port;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port)
{
    int rc = BCM_E_NONE;
    bcm_port_t user_port;
    int congestion_port;
    uint32 ilkn_id = 0;
    soc_port_if_t interface_type;

    BCMDNX_INIT_FUNC_DEFS;

    /* check if it is a congestion port */
    if (BCM_GPORT_IS_CONGESTION(gport)) {
        congestion_port = BCM_GPORT_CONGESTION_GET(gport);
        if (congestion_port >= SOC_DNX_CONFIG(unit)->tm.max_oob_ports) {
            DNXC_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("invalid congestion port (%d)"),congestion_port));
        }

        (*is_fc_calender) = TRUE;
        (*is_fc_inband) = FALSE;
        (*fc_calender_port) = congestion_port;
    } else {

        rc = bcm_dnx_cosq_user_port_get(unit, gport, &user_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_interface_type_get(unit, user_port, &interface_type);
        BCMDNX_IF_ERR_EXIT(rc);

        if (interface_type == SOC_PORT_IF_ILKN) {
            rc = dnx_port_sw_db_protocol_offset_get(unit, user_port, 0, &ilkn_id);
            BCMDNX_IF_ERR_EXIT(rc);

            if (ilkn_id >= SOC_DNX_CONFIG(unit)->tm.max_interlaken_ports) {
                DNXC_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("invalid interlaken id (%d)"),ilkn_id));
            }

            (*is_fc_calender) = TRUE;
            (*is_fc_inband) = TRUE;
            (*fc_calender_port) = ilkn_id;
        }
        else {
            (*is_fc_calender) = FALSE;
            (*is_fc_inband) = TRUE;
            (*fc_calender_port) = -1;
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

static unsigned int
_bcm_cosq_bit_count_get(uint32 value)
{ 
    uint32 count = 0; 

    while (value > 0) {           /* until all bits are zero  */
        if ((value & 1) == 1) {   /* check lower bit */
            count++; 
        } 
        value >>= 1;              /* shift bits, removing lower bit */
    } 

    return count;
} 


/*
 * element (data structure) allocation
 */
/* This function to be populated if we allocate dynamically memory for */
/* flow_hd, se_hd, connector_hd, voq_hd rather than having this fixed  */
/* in the bcm_dnx_cosq_config_t structure                              */
/* structure.                                                          */            
/* static */ bcm_dnx_cosq_list_hd_t *
_bcm_dnx_cosq_listhd_alloc(int unit)
{
    return(NULL);
}

static int
_bcm_dnx_cosq_fmq_hr_port_allocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int rc = BCM_E_NONE;
    int index = 0;
    DNX_TMC_SCH_PORT_INFO port_info;
    uint32 dnx_sand_rc;
    int* hr_fmq_array = NULL;
    soc_port_t logical_port = 0;
    bcm_core_t core_1;

    BCMDNX_INIT_FUNC_DEFS;

    /* 
     * FMQ and ISQ HRs are being assumed to be allocated after soc init.
     * All HRs that are currently used are Ports-HRs
     * FMQ and ISQ HRs must be allocated from a free PS.
     * So first find a free PS and then allocate HRs.
     * This being handled in the following API.
     */ 
    rc = soc_jer2_arad_fmq_base_hr_get(unit, core, &hr_fmq_array);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Allocate unused local ports */
    for (index = 0; index < nbr_ports; index++) {
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
        rc = _bcm_dnx_port_find_free_port_and_allocate(unit, core, SOC_PORT_IF_NOCXN, 0, &logical_port);
        BCMDNX_IF_ERR_EXIT(rc);
#endif 
      
        rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.set(unit, logical_port, hr_fmq_array[index]);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, logical_port, &tm_ports[index], &core_1);
        BCMDNX_IF_ERR_EXIT(rc);

        if(core != core_1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Core validation failed")));
        }

        rc = jer2_arad_egr_dsp_pp_to_base_q_pair_set(unit, core, tm_ports[index], hr_fmq_array[index]);
        BCMDNX_IF_ERR_EXIT(rc); 
        
        if (hr_fmq_array[index] % 8 == 0) { /* Set new configured PS */
            dnx_sand_rc = jer2_arad_egr_dsp_pp_priorities_mode_set(unit, core, tm_ports[index], DNX_TMC_EGR_PORT_ONE_PRIORITY);
            BCMDNX_IF_ERR_EXIT(dnx_sand_rc);
        } 

        /* Update only SW */
        BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
    }  

    for (index = 0; index < nbr_ports; index++) {
        /* Set port enable */        
        DNX_TMC_SCH_PORT_INFO_clear(&port_info);
        port_info.enable = TRUE;
        DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }        
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, tm_ports[index], &port_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
        BCM_DNX_UNIT_CHECK(unit);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_fmq_hr_port_deallocate(int unit, int core, int nbr_ports, uint32 *tm_ports)
{
    int rc = BCM_E_NONE;
    int index = 0;
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    for (index = 0; index < nbr_ports; index++) {
        BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, tm_ports[index], &port));
        BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_port_remove(unit, port));
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_isq_hr_port_allocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    DNX_TMC_SCH_PORT_INFO port_info;
    uint32 dnx_sand_rc; 
    int hr_isq;
    soc_port_t logical_port = -1;
    bcm_core_t core_index, core_tmp;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    BCM_DNX_CORES_ITER(core, core_index) {
        /* 
         * FMQ and ISQ HRs are being assumed to be allocated after soc init.
         * All HRs that are currently used are Ports-HRs
         * FMQ and ISQ HRs must be allocated from a free PS.
         * for JER2_ARAD first find a free PS and then allocate HRs.
         * This being handled in the following API.
         */ 
        rc = soc_jer2_arad_isq_hr_get(unit, core_index, &hr_isq);
        BCMDNX_IF_ERR_EXIT(rc);
        
        DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
        /* Allocate unused local ports */
        rc = _bcm_dnx_port_find_free_port_and_allocate(unit, core_index, SOC_PORT_IF_NOCXN, 0, &logical_port);
        BCMDNX_IF_ERR_EXIT(rc);
#endif 

        rc = sw_state_access[unit].dnx.soc.jer2_arad.tm.logical_ports_info.base_q_pair.set(unit, logical_port, hr_isq);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = dnx_port_sw_db_local_to_tm_port_get(unit, logical_port, tm_port, &core_tmp);
        BCMDNX_IF_ERR_EXIT(rc);
        if (core_tmp != core_index) {
            BCMDNX_IF_ERR_EXIT(BCM_E_CONFIG);
        }
        dnx_sand_rc = jer2_arad_egr_dsp_pp_to_base_q_pair_set(unit, core_index, *tm_port, hr_isq);
        BCMDNX_IF_ERR_EXIT(dnx_sand_rc); 
        
        if (hr_isq % 8 == 0) { /* Set new configured PS */
            rc = jer2_arad_egr_dsp_pp_priorities_mode_set(unit, core_index, *tm_port, DNX_TMC_EGR_PORT_ONE_PRIORITY);
            BCMDNX_IF_ERR_EXIT(rc);
        } 
        /* Update only SW */
        BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
                             
        /* Set port enable */        
        DNX_TMC_SCH_PORT_INFO_clear(&port_info);
        port_info.enable = TRUE;
        DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }    
        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core_index, *tm_port, &port_info)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_isq_hr_port_deallocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_tm_to_local_port_get(unit, core, *tm_port, &port));
    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_port_remove(unit, port));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * External Functions
 */
int
bcm_dnx_cosq_fmq_hr_allocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    DNX_TMC_SCH_SE_ID se_id[DNX_DEVICE_FMQ_CLASS_PORTS];
    int flow_id[DNX_DEVICE_FMQ_CLASS_PORTS];
    DNX_TMC_SCH_SE_INFO se_info;
    DNX_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    bcm_gport_t sw_state_fmq_class_port;    
    
    BCMDNX_INIT_FUNC_DEFS;

    if (nbr_ports > DNX_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("core %d, number of ports %d, is out of range"), core, nbr_ports));
    }

    DNX_TMC_SCH_SE_INFO_clear(&se_info);
    DNX_TMC_SCH_FLOW_clear(unit, &sch_flow);
    DNX_TMC_SCH_FLOW_clear(unit, &exact_sch_flow);

    rc = _bcm_dnx_cosq_fmq_hr_port_allocate(unit, core, nbr_ports, tm_ports);
    BCMDNX_IF_ERR_EXIT(rc);

    /* enable the HR scheduler elements */
    for (index = 0; index < nbr_ports; index++) {        

        /* retrieve corresponding SE element */
        rc = _bcm_dnx_cosq_port2se_id(unit, core, tm_ports[index], DNX_COSQ_PB_DEFAULT_PORT_TC, &(se_id[index]));
        BCMDNX_IF_ERR_EXIT(rc);
        if (se_id[index] == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("error in retreiving seId for fapPort(%d)"), tm_ports[index]));
        }

        /* retrieve corresponding flow id */
        flow_id[index] = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,((se_id[index]))));
        if (flow_id[index] == DNX_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("error in retreiving FlowId for seId(0x%x)"), se_id[index]));
        }

        rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, BCM_DNX_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id[index]);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* configure scheduler element */
        dnx_sand_rc =  (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id[index], &se_info, &sch_flow)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        se_info.state = DNX_TMC_SCH_SE_STATE_ENABLE;
        se_info.type_info.hr.mode = DNX_TMC_SCH_HR_MODE_SINGLE_WFQ;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_id[index], &se_info, &sch_flow, &exact_sch_flow)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

    /* update local data structures with FMQ Class Schedulers */
    for (index = 0; index < nbr_ports; index++) {
        /* scheduler gport format */
        BCM_GPORT_SCHEDULER_CORE_SET(sw_state_fmq_class_port, flow_id[index], core);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, sw_state_fmq_class_port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_ucast_qid_range_set(int unit, int core, int qid_start, int qid_end)
{   
    int                      rc = BCM_E_NONE;
    int                     core_index;


    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_WARM_BOOT(unit)) {
        BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
            if (qid_start != -1) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.ucast_qid_start.set(unit, core_index, qid_start));
            }
            if (qid_end != -1) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.ucast_qid_end.set(unit, core_index, qid_end));
            }
        }
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_ucast_qid_range_get(int unit, int core, int *qid_start, int *qid_end)
{   
    int                      rc = BCM_E_NONE;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.ucast_qid_start.get(unit, core_index, qid_start));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.ucast_qid_end.get(unit, core_index, qid_end));

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_is_se_reserved(int unit, int core, int se_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;
    int fap_port;
    bcm_cos_t priority;
    DNX_TMC_SCH_SE_ID sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;
    
    (*is_reserved) = FALSE;
    
    if ( (se_id >= SOC_DNX_CONFIG(unit)->tm.port_hr_se_min) && (se_id <= SOC_DNX_CONFIG(unit)->tm.port_hr_se_max) ) {
            rc = _bcm_dnx_cosq_se_id2port(unit, core, se_id, &fap_port, &priority);
            if (rc == BCM_E_NONE) {
                if (DNX_COSQ_SCH_PORT_ID_INVALID(unit) != fap_port) {
                    (*is_reserved) = TRUE;
                }
            }
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (se_id == sw_state_default_se) {
        (*is_reserved) = TRUE;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_dnx_cosq_is_conn_reserved(int unit, int conn_id, int *is_reserved)
{
    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    if ( (conn_id >= DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) &&
         (conn_id < (DNX_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START +
                         DNX_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS)) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_is_queue_reserved(int unit, int queue_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    /*         changes associatd with enhanced FMQ mode                               */
    /*         currently the following range is always reserved in allocation manager */
    /*         during init phase. This will change once enhanced mode is supported.   */
    if ( (queue_id >= DNX_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MIN) && (queue_id <= DNX_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MAX) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fmq_hr_deallocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    int flow_id;
    uint32 dnx_sand_rc;
    DNX_TMC_SCH_SE_ID se_id;
    DNX_TMC_SCH_SE_INFO se_info;
    DNX_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    if (nbr_ports > DNX_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, number of ports %d, is out of range"), unit, nbr_ports));
    }

    DNX_TMC_SCH_SE_INFO_clear(&se_info);
    DNX_TMC_SCH_FLOW_clear(unit,&sch_flow);
    DNX_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);

    for (index = 0; index < nbr_ports; index++) {
        /* retrieve corresponding SE element */
        rc = _bcm_dnx_cosq_port2se_id(unit, core, tm_ports[index], DNX_COSQ_PB_DEFAULT_PORT_TC, &se_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
            DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"),tm_ports[index]));
        }

        /* retrieve corresponding flow id */
        flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,((se_id))));
        if (flow_id == DNX_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
        }

        /* free HR resources */
        rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, BCM_DNX_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* configure scheduler element */
        dnx_sand_rc =  (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

        se_info.state = DNX_TMC_SCH_SE_STATE_DISABLE;
        se_info.type_info.hr.mode = DNX_TMC_SCH_HR_MODE_SINGLE_WFQ;

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    }

    rc = _bcm_dnx_cosq_fmq_hr_port_deallocate(unit, core, nbr_ports, tm_ports);
    BCMDNX_IF_ERR_EXIT(rc);

    for (index = 0; index < nbr_ports; index++) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, BCM_GPORT_INVALID));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_isq_hr_allocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    uint32 dnx_sand_rc;
    DNX_TMC_SCH_SE_ID se_id;
    int flow_id;
    DNX_TMC_SCH_SE_INFO se_info;
    DNX_TMC_SCH_FLOW  sch_flow, exact_sch_flow;    
    bcm_gport_t sw_state_isq_port;
    
    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_SCH_SE_INFO_clear(&se_info);
    DNX_TMC_SCH_FLOW_clear(unit,&sch_flow);
    DNX_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);

    rc = _bcm_dnx_cosq_isq_hr_port_allocate(unit, core, tm_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* enable the HR scheduler elements */
    /* retrieve corresponding SE element */
    rc = _bcm_dnx_cosq_port2se_id(unit, core, *tm_port, DNX_COSQ_PB_DEFAULT_PORT_TC,&(se_id));
    BCMDNX_IF_ERR_EXIT(rc);

    if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
        DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"), *tm_port));
    }

    /* retrieve corresponding flow id */
    flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,((se_id))));
    if (flow_id == DNX_COSQ_SCH_FLOW_ID_INVALID(unit)) {
        DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
    }

    /* reserve HR in allocation manager */
    rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, BCM_DNX_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* configure scheduler element */
    dnx_sand_rc =  (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    se_info.state = DNX_TMC_SCH_SE_STATE_ENABLE;
    se_info.type_info.hr.mode = DNX_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    /* scheduler gport format */
    BCM_GPORT_SCHEDULER_CORE_SET(sw_state_isq_port, flow_id, core);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.isq_port.set(unit, core, sw_state_isq_port));

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_isq_hr_deallocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    int flow_id;
    uint32 dnx_sand_rc;
    DNX_TMC_SCH_SE_ID se_id;
    DNX_TMC_SCH_SE_INFO se_info;
    DNX_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;
    
    DNX_TMC_SCH_SE_INFO_clear(&se_info);
    DNX_TMC_SCH_FLOW_clear(unit,&sch_flow);
    DNX_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);
    
    /* retrieve corresponding SE element */
    rc = _bcm_dnx_cosq_port2se_id(unit, core, *tm_port, DNX_COSQ_PB_DEFAULT_PORT_TC, &se_id);
    BCMDNX_IF_ERR_EXIT(rc);

    if (se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
        DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"), *tm_port));
    }

    /* retrieve corresponding flow id */
    flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,((se_id))));
    if (flow_id == DNX_COSQ_SCH_FLOW_ID_INVALID(unit)) {
        DNXC_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
    }

    /* free HR resources */
    rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, BCM_DNX_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* configure scheduler element */
    dnx_sand_rc =  (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    se_info.state = DNX_TMC_SCH_SE_STATE_DISABLE;
    se_info.type_info.hr.mode = DNX_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
    
    rc = _bcm_dnx_cosq_isq_hr_port_deallocate(unit, core, tm_port);
    BCMDNX_IF_ERR_EXIT(rc);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.isq_port.set(unit, core, BCM_GPORT_INVALID));

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_dnx_cosq_fmq_vsq_category_mode_set(int unit, int core, bcm_fabric_vsq_category_mode_t vsq_category_mode)
{
    int                     core_index;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_ASSYMETRIC_CORES_ITER(core, core_index) {
        if (vsq_category_mode < 0 || vsq_category_mode > bcmFabricVsqCatagoryMode2) {
            LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"unit %d, error in setting vsq category mode %d\n"), unit, vsq_category_mode));
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("vsq_category_mode invalid")));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.vsq_category_mode.set(unit, core_index, vsq_category_mode));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_fmq_vsq_category_mode_get(int unit, int core, bcm_fabric_vsq_category_mode_t *vsq_category_mode)
{
    int rc = BCM_E_NONE;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_category_mode);

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.ingress.vsq_category_mode.get(unit, core_index, vsq_category_mode));

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_ingress_tc_mapping_set(int unit, 
                                       bcm_port_t port,
                                       bcm_cos_t priority, 
                                       bcm_cos_queue_t cosq)
{
  int rc = BCM_E_NONE;
  int dnx_sand_rc = DNX_SAND_OK;
  DNX_TMC_ITM_TC_MAPPING tc_mapping;
  int tc = 0, new_tc = 0, dest_ndx = 0, dest_base_queue = 0, is_allocated, is_last, new_mapping_profile;
  uint32 old_profile;
  int is_flow;
  int nof_quartet,quartet_index;
  DNX_TMC_IPQ_EXPLICIT_MAPPING_MODE_INFO mapping_mode_info;
  uint32 flow_mapping_queue_base_offset;
  int core_id = BCM_CORE_ALL, core = BCM_CORE_ALL;
  uint8 sw_state_num_cos;
  BCMDNX_INIT_FUNC_DEFS;
  DNX_TMC_ITM_TC_MAPPING_clear(&tc_mapping);

  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (priority < 0 || priority >= DNX_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
  }

  if (cosq < 0 || cosq >= DNX_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
    dest_base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
    is_flow = 1;
  }
  else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) 
  {
    dest_base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
    is_flow = 1;
     
  } 
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(port);
      core = BCM_COSQ_GPORT_ISQ_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
    dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
    core = BCM_CORE_ALL; /* Currently the mapping is symmetric. Consider to get the core of the system port or should allways be symeric? */
    is_flow = 0;
  }
  else 
  {
    /* Protected by higher level function, but added just to be on the safe side */
    BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
  }
  if (core == BCM_CORE_ALL && !SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, API bcm_cosq_port_mapping_set() cannot configure both cores if device is if configured asymmetriclly."), unit));
  }
  if (core != BCM_CORE_ALL && SOC_DNX_CORE_MODE_IS_SYMMETRIC(unit) && !SOC_DNX_CORE_MODE_IS_SINGLE_CORE(unit)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, API bcm_cosq_port_mapping_set() cannot configure one core if device is if configured symmetriclly."), unit));
  }
  tc = priority;
  new_tc = cosq;
  SOC_DNX_ASSYMETRIC_CORES_ITER(core, core_id) {
      if(is_flow) {
        /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
        /*get VOQ configuration from dest_base_queue*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DNX_DEVICE_DNX_VOQ_HD_ELEMENT(unit ,core_id, dest_base_queue), &sw_state_num_cos));
        /*dest_ndx not configed*/
        if (sw_state_num_cos ==  0) {
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }
        nof_quartet = (sw_state_num_cos)/4;

        /*dest_ndx is the flow id before mapped into VOQ: dest_base_queue - (global offset)*/
        rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_explicit_mapping_mode_info_get,(unit, &mapping_mode_info)));
        BCMDNX_IF_ERR_EXIT(rc);

        /* The MBCM_DNX_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        flow_mapping_queue_base_offset = (mapping_mode_info.queue_id_add_not_decrement) ? mapping_mode_info.base_queue_id : 0;
        dest_ndx = dest_base_queue - flow_mapping_queue_base_offset;

        /* Get old data */
        rc = _bcm_dnx_am_template_ingress_flow_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Set data configuration */
        tc_mapping.new_tc[tc] = new_tc;

        /* Exchange SW Data */
        rc = _bcm_dnx_am_template_ingress_flow_tc_mapping_exchange(unit, core_id, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);   
      } else {
        /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
        nof_quartet = 1;

        /* Get old data */
        rc = _bcm_dnx_am_template_ingress_uc_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Set data configuration */
        tc_mapping.new_tc[tc] = new_tc;

        /* Exchange SW Data */
        rc = _bcm_dnx_am_template_ingress_uc_tc_mapping_exchange(unit, core_id, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);
      }

      if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_dnx_cosq_ingress_tc_mapping_hw_set(unit, core, new_mapping_profile, is_flow, &tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);
      }

      /*for each quartet(dest_ndx + (quartet_index * 4)) configure its profile using new_mapping_profile*/
      for (quartet_index = 0; quartet_index < nof_quartet; quartet_index++) {
          /* Set new mapping */
          dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_tc_profile_set,(unit, core, is_flow, dest_ndx + (quartet_index * 4), new_mapping_profile)));
          DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);
      }
  }
  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

static int _bcm_dnx_cosq_ingress_tc_mapping_hw_set(int unit,
                                                     int core_id,
                                                     int profile,
                                                     int is_flow,
                                                     DNX_TMC_ITM_TC_MAPPING *tc_mapping)
{
  int rc = BCM_E_NONE;
  int dnx_sand_rc = DNX_SAND_OK;
  int i;

  BCMDNX_INIT_FUNC_DEFS;
  for(i=0; i < DNX_TMC_NOF_TRAFFIC_CLASSES ; i++)
  {
    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_tc_profile_map_set,(unit, core_id, profile, is_flow, i, tc_mapping->new_tc[i])));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                   
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_ingress_tc_mapping_get(int unit, 
                                       bcm_port_t port,
                                       bcm_cos_t priority, 
                                       bcm_cos_queue_t *cosq)
{
  int rc = BCM_E_NONE;
  DNX_TMC_ITM_TC_MAPPING tc_mapping;
  int dest_ndx=0;
  int is_flow;
  int core_id;

  BCMDNX_INIT_FUNC_DEFS;
  DNX_TMC_ITM_TC_MAPPING_clear(&tc_mapping);


  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (priority < 0 || priority >= DNX_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
    dest_ndx = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    core_id = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
    is_flow = 1;
  }
  else if(BCM_GPORT_IS_MCAST_QUEUE_GROUP(port))
  {
    dest_ndx = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    core_id = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
    is_flow = 1;
  }
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_ndx = BCM_COSQ_GPORT_ISQ_QID_GET(port);
      core_id = BCM_COSQ_GPORT_ISQ_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
    dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
    core_id = BCM_CORE_ALL; /* Consider to get the core of the system port or should allways be symeric?*/
    is_flow = 0;
  }
  else 
  {
    /* Protected by higher level function, but added just to be on the safe side */
    return BCM_E_PARAM;
  }

  if(is_flow)
  {
    /* Get old data */
    rc = _bcm_dnx_am_template_ingress_flow_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);
  }
  else
  {
    /* Get old data */
    rc = _bcm_dnx_am_template_ingress_uc_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);
  }

  if(cosq != NULL)
  {
    *cosq = tc_mapping.new_tc[priority];
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

static int _bcm_dnx_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int priority, int generic_bm_id, DNX_TMC_FC_PFC_GENERIC_BITMAP *bitmap)
{
    int rc = BCM_E_NONE;
    int dnx_sand_rc = DNX_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_fc_pfc_generic_bitmap_set,(unit, priority, generic_bm_id, bitmap)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);                   

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

static int _bcm_dnx_cosq_stk_sysport_set(int unit, int core, bcm_gport_t sysport_gport, int *stk_exist)
{
    
    DNXC_LEGACY_FIXME_ASSERT;
#ifdef FIXME_DNX_LEGACY
    int 
        rv = BCM_E_NONE,
        dnx_sand_rc = DNX_SAND_OK,
        local_modid;
    uint32
        sysport_modid,
        is_same_domain = 0x0,
        dest_base_queue = 0x0;
    bcm_gport_t
        sysport,
        modport_gport;
    int 
        sysport_domain;
    uint8 
        is_sw_only = FALSE; /*We want to write to HW.*/

    BCMDNX_INIT_FUNC_DEFS;
 
    BCM_DNX_UNIT_CHECK(unit);
    if (stk_exist == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("NULL argument")));
    }

    *stk_exist = 0x0;

    /* Get local modid*/ 
    rv = bcm_dnx_stk_my_modid_get(unit, &local_modid);
    if (rv) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "local modid invalid bcm_dnx_stk_my_modid_get() rv=%s\n"), bcm_errmsg(rv)));
        BCMDNX_IF_ERR_EXIT(rv);
    }

    /* Get mod/fap id from sysyport */ 
    rv = bcm_dnx_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
    BCMDNX_IF_ERR_EXIT(rv);
    sysport_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);

    /* check if modid in other TM doamin */

    rv = bcm_dnx_stk_modid_to_domain_find(unit, local_modid, sysport_modid, &is_same_domain);
    DNX_BCM_SAND_IF_ERR_EXIT(rv);

     if (is_same_domain == 0x0) {

         /* Get sysport TM-domain */
         rv = bcm_dnx_stk_domain_modid_get(unit, sysport_modid, &sysport_domain);
         DNX_BCM_SAND_IF_ERR_EXIT(rv);

         /* Set dest_base_queue {16:6 all ones, 5:0 tmd}*/
         dest_base_queue = ((uint32)sysport_domain) | (0x7ff << 6);

         /* connect VOQ to sysport */
         sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
         dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_ipq_destination_id_packets_base_queue_id_set,(unit, core, sysport, TRUE /* queue is valid */,is_sw_only ,dest_base_queue)));
         rv = dnx_handle_sand_result(dnx_sand_rc); /* set sysport to base queue mapping */
         if (rv != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "soc_dnx_ipq_destination_id_packets_base_queue_id_set() failed \"base queue(%d) sysport(%d)\n"), dest_base_queue, sysport));
         }

         *stk_exist = 0x1;
     }            

exit:
    BCMDNX_FUNC_RETURN;
#endif 
    return -1;
}




static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }

    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_sched_set, (unit, gport, weight)));

exit:    
    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{

    BCMDNX_INIT_FUNC_DEFS;
         
    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_sched_get, (unit, gport, weight)));
        
    BCMDNX_FUNC_RETURN;   
}

static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    DNX_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core;
    BCMDNX_INIT_FUNC_DEFS;

    /*
     * For ingress scheduler, user may either configure both cores the same way or
     * each core on its own.
     * In the former case, user
     *   (a) 'sets' using 'BCM_CORE_ALL' (and software configures both cores the same way)
     *   (b) 'gets' using 'BCM_CORE_ALL' (and software queries only port '0')
     * This explains the few following lines.
     * In the latter case, using BCM_CORE_ALL for 'get' operation is an error.
     */
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_slow_start_get, (unit, core, &clos_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            /*Enable/Disable slow start mechanism for multicast queues*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_enable;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  

}

static int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    DNX_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DNX_CORES_ITER(core, index)
    {
        BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_slow_start_get, (unit, index, &clos_info)));

        /*setting all shaper fields to don't touch (0xffffffff)*/
        DNX_TMC_ING_SCH_CLOS_INFO_SHAPERS_dont_touch(&clos_info);

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                /*Enable/Disable slow start mechanism for multicast queues*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                 break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_slow_start_set, (unit, index, &clos_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  

}

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    DNX_TMC_ING_SCH_SHAPER   shaper_info;
    int                      core;
    BCMDNX_INIT_FUNC_DEFS;

    /*
     * For ingress scheduler, user may either configure both cores the same way or
     * each core on its own.
     * In the former case, user
     *   (a) 'sets' using 'BCM_CORE_ALL' (and software configures both cores the same way)
     *   (b) 'gets' using 'BCM_CORE_ALL' (and software queries only port '0')
     * This explains the few following lines.
     * In the latter case, using BCM_CORE_ALL for 'get' operation is an error.
     */
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_slow_start_get, (unit, core, &shaper_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  
}

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    DNX_TMC_ING_SCH_SHAPER    shaper_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DNX_CORES_ITER(core, index)
    {
        /*setting slow start shaper fields to don't touch (0xffffffff)*/
        shaper_info.slow_start_enable = DNX_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_0 = DNX_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_1 = DNX_TMC_ING_SCH_DONT_TOUCH;        

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_slow_start_set, (unit, index, &shaper_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  
}

static int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
BCMDNX_INIT_FUNC_DEFS;

    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }
  
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_sched_set, (unit, gport, weight)));
      
exit:    
    BCMDNX_FUNC_RETURN;   
}

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{
    BCMDNX_INIT_FUNC_DEFS;

    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_sched_get, (unit, gport, weight)));
  
    BCMDNX_FUNC_RETURN;   
}

int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    *kbits_sec_min = 0;
    *flags = 0;

    
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_bandwidth_get, (unit, gport, kbits_sec_max)));
        
    BCMDNX_FUNC_RETURN;
}


int
_bcm_dnx_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }  

    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_bandwidth_set, (unit, gport, kbits_sec_max)));
      
exit:    
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;
      
    *kbits_sec_min = 0;
    *flags = 0;
     
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_bandwidth_get, (unit, gport, kbits_sec_max))); 

    BCMDNX_FUNC_RETURN;
}

int
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }

    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_bandwidth_set, (unit, gport, kbits_sec_max))); 
exit:        
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_WARM_BOOT_SUPPORT_SW_DUMP
int
_bcm_dnx_cosq_sw_dump(int unit)
{
    int                                 rc = BCM_E_NONE;
    int                                 nbr_entry, base_qid = 0, base_cid = 0, nbr_cos = 0, nbr_se;
    bcm_gport_t                         conn_gport, physical_port, se_gport;
    int                                 num_cos_levels, flow_id, dual_flow_id, dual_se_id;
    int                                 is_non_contiguous = 0, is_composite, is_dual;
    uint32                              flags;
    uint8                              *se_info = NULL;
    int                                 hd_core;
    int core = 0 ;
    uint8                               sw_state_num_cos;
    uint8                               sw_state_flags;
    int                                 sw_state_weight;
    uint32                              sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_ALLOC(se_info, sizeof(uint8) * ((SOC_DNX_CONFIG(unit)->tm.max_ses / 8) + 1), "temp se info");
    if (se_info == NULL) {
        return(BCM_E_MEMORY);
    }
    sal_memset(se_info, 0, sizeof(uint8) * ((SOC_DNX_CONFIG(unit)->tm.max_ses / 8) + 1));


    LOG_CLI((BSL_META_U(unit,
                        "\nVoQ State\n")));
    for (nbr_entry = 0, base_qid = 0;
           nbr_entry < (DNX_DEVICE_DNX_VOQ_HD_SIZE(unit) + 1) / DNX_DEVICE_COSQ_COS_ALLOC_SZ;
                                        base_qid += DNX_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, base_qid, &sw_state_num_cos));

        if (sw_state_num_cos == 0) {
            continue;
        }
        hd_core = DNX_DEVICE_DNX_VOQ_HD_CORE(unit ,base_qid);
        LOG_CLI((BSL_META_U(unit,
                            "  baseVoq(%d), core(%d) numCos(%d)\n"), DNX_DEVICE_DNX_VOQ_HD_ID(unit, core, base_qid), hd_core, sw_state_num_cos));
    }
    BCM_DNX_CORES_ITER(BCM_CORE_ALL, core) {
        LOG_CLI((BSL_META_U(unit,
                        "\nConnector State\n")));
        for (nbr_entry = 0, base_cid = 0;
               nbr_entry < (DNX_DEVICE_DNX_COSQ_MAX_FLOW(unit) + 1) / DNX_DEVICE_COSQ_COS_ALLOC_SZ;
                                            base_cid += DNX_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_cid, &sw_state_num_cos));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, core, base_cid, &sw_state_flags));
            if (sw_state_num_cos == 0) {
                continue;
            }
            LOG_CLI((BSL_META_U(unit,
                                "  baseConn(%d), numCos(%d), flags(0x%04X)\n"), base_cid, sw_state_num_cos, (unsigned short)sw_state_flags));
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(conn_gport, base_cid, core);
            rc = bcm_dnx_cosq_gport_get(unit, conn_gport, &physical_port, &num_cos_levels, &flags);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, conn_gport, rc));
                BCM_EXIT;
            }
            is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
            is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
            for (nbr_cos = 0; nbr_cos < sw_state_num_cos; nbr_cos++) {
                rc = _bcm_dnx_flow_id_get(unit, core, base_cid, nbr_cos, is_non_contiguous, is_composite, FALSE,&flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                    BCM_EXIT;
                }
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                LOG_CLI((BSL_META_U(unit,
                                    "    cos(%d), flow(%d), weight(%d)\n"), nbr_cos, flow_id, sw_state_weight));
    
                if (is_composite) {
                    rc = _bcm_dnx_composite_flow_id_get(unit, core, base_cid, nbr_cos, is_non_contiguous, is_composite, &flow_id);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                        BCM_EXIT;
                    }
    
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                    LOG_CLI((BSL_META_U(unit,
                                        "    cos(%d), composite-flow(%d), weight(%d)\n"), nbr_cos, flow_id, sw_state_weight));
                }
            }
        }
    
        LOG_CLI((BSL_META_U(unit,
                            "\nSE State\n")));
    
        for (nbr_se = 0; nbr_se < SOC_DNX_CONFIG(unit)->tm.max_ses; nbr_se++) {
    
            /* check that the element is not already processed */
            if (se_info[(nbr_se / 8)] & (1 << (nbr_se % 8))) {
                continue;
            }
    
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, nbr_se, &sw_state_ref_cnt));
    
            if (sw_state_ref_cnt == 0) {
                continue;
            }
    
            /* update temp state to indicate element processed */
            se_info[(nbr_se / 8)] |= (1 << (nbr_se % 8));
    
            LOG_CLI((BSL_META_U(unit,
                                "  SE(%d), ref_cnt(%d)\n"), nbr_se,
                     (sw_state_ref_cnt - DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));
    
            flow_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,( nbr_se)));
            BCM_GPORT_SCHEDULER_CORE_SET(se_gport, flow_id, core);
    
            rc = bcm_dnx_cosq_gport_get(unit, se_gport, &physical_port, &num_cos_levels, &flags);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, se_gport, rc));
                BCM_EXIT;
            }
    
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));

            LOG_CLI((BSL_META_U(unit,
                                "    flow(%d), weight(%d)\n"), flow_id, sw_state_weight));
    
            is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
            is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
            is_dual = (flags & BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER) ? TRUE : FALSE;
    
            if (is_composite) {
                rc = _bcm_dnx_composite_flow_id_get(unit, core, base_cid, nbr_se, is_non_contiguous, is_composite, &flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_se, rc));
                    BCM_EXIT;
                }
    
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                LOG_CLI((BSL_META_U(unit,
                                    "    Composite Flow(%d), weight(%d)\n"), flow_id, sw_state_weight));
            }
    
            if (is_dual) {
    
                rc = _bcm_dnx_se_dual_flow_id_get(unit, flow_id, DNX_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                    BCM_EXIT;
                }
    
                dual_se_id = (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_flow2se_id,(unit, dual_flow_id)));
                if (dual_se_id == DNX_COSQ_SCH_SE_ID_INVALID(unit)) {
                    rc = BCM_E_INTERNAL;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, dual_flow_id));
                    BCM_EXIT;
                }
    
                /* update temp state to indicate element processed */
                se_info[(nbr_se / 8)] |= (1 << (dual_se_id % 8));
    
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, dual_se_id, &sw_state_ref_cnt));

                if ( sw_state_ref_cnt == 0 ) {
                    rc = BCM_E_INTERNAL;
                    BCM_EXIT;
                }
                LOG_CLI((BSL_META_U(unit,
                                    "    SE-Dual(%d), ref_cnt(%d)\n"), nbr_se,
                         (sw_state_ref_cnt - DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, dual_flow_id, &sw_state_weight));

                LOG_CLI((BSL_META_U(unit,
                                    "    flow(%d), weight(%d)\n"), dual_flow_id, sw_state_weight));
            }
        }
        LOG_CLI((BSL_META_U(unit,"\n")));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(se_info);
    BCMDNX_FUNC_RETURN;
}
#endif /* BCM_WARM_BOOT_SUPPORT_SW_DUMP */


static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
 
    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;   
}

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_clos_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

static int 
_bcm_dnx_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_ingress_scheduler_mesh_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;  
}

/* when a port added or removed (dynamic port) the coresspoding hr should be added or removed */
int 
_bcm_dnx_cosq_hr_handle(int unit, int port, int enable)
{
    int                         core, priority_i, flow_id, rc;
    uint32                      fap_port, nof_priorities;
    DNX_TMC_SCH_PORT_INFO       port_info;
    bcm_gport_t                 gport;
    uint32                      res_mngr_flags = 0, dnx_sand_rc = 0;
    DNX_TMC_SCH_SE_ID           se_index = 0;
    bcm_dnx_cosq_flow_config_t  flow_zero = {0};
    bcm_dnx_cosq_se_config_t    se_zero = {0};

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(dnx_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));
    DNX_TMC_SCH_PORT_INFO_clear(&port_info);
    BCM_COSQ_GPORT_E2E_PORT_SET(gport, port);

    /* A new port is added*/
    if (enable) 
    {   
        /* Set default port information */
        port_info.enable = TRUE;
        DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }

        rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, fap_port, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* allocate hr */ 
         res_mngr_flags = BCM_DNX_AM_FLAG_ALLOC_WITH_ID;
         
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                 rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                     (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, dnx_sand error 0x%x, rc error 0x%x"),
                                                                                                        unit, fap_port, priority_i, dnx_sand_rc, rc));
             }
              
             if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }

             /* allocate port HRs */
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DNX_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));
             /*  allocate flow */
             flow_id =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_index)));

             rc = bcm_dnx_am_cosq_scheduler_allocate(unit, core, 1, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, DNX_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }
             LOG_VERBOSE(BSL_LS_BCM_COSQ,
                         (BSL_META_U(unit,
                                     "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));

             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
         }
    }
    else /* An exising port is deleted */
    {
        /* Set default port information */
        port_info.enable = FALSE;
        DNX_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,DNX_TMC_SCH_HR_MODE_NONE);
        if (!SOC_DNX_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = DNX_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_NONE;
        }

        rc = _bcm_dnx_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DNX_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(DNX_SAND_FAILURE(dnx_sand_rc)) {
            rc = dnx_translate_sand_success_failure(dnx_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, dnx_sand error 0x%x, error 0x%x\n"), unit, fap_port, dnx_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        /* release hr */
         res_mngr_flags = 0;
        
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             /* retrieve flow id */
             dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(DNX_SAND_FAILURE(dnx_sand_rc)) {
                 rc = dnx_translate_sand_success_failure(dnx_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, dnx_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, dnx_sand_rc, rc));
             }
              
             if (se_index == DNX_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }
             flow_id =  (MBCM_DNX_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dnx_sch_se2flow_id,(se_index)));

             /* free HR resources */
             rc = bcm_dnx_am_cosq_scheduler_deallocate(unit, core, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1,DNX_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }

             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, flow_id, &flow_zero));
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dnx.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, se_index, &se_zero));
         }

    }

exit:
    BCMDNX_FUNC_RETURN;
}


/* Configure Weighted Random Early Discard (WRED).
   global drop per DP , and ECN enabled or not*/
int bcm_dnx_cosq_discard_set(
    int unit, 
    uint32 flags) 
{
    uint32 discard_dp, enable_ecn = flags & BCM_COSQ_DISCARD_MARK_CONGESTION;
    int ecn_not_supported = SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit);

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);

    /* check unsupported flags */
    if (enable_ecn) {
        if (ecn_not_supported) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        flags &= ~BCM_COSQ_DISCARD_MARK_CONGESTION;
    }
    if (flags & ~(BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag. Supported flags are: BCM_COSQ_DISCARD_ENABLE, "
                                                "BCM_COSQ_DISCARD_COLOR_BLACK, BCM_COSQ_DISCARD_COLOR_RED, BCM_COSQ_DISCARD_COLOR_YELLOW, "
                                                "BCM_COSQ_DISCARD_COLOR_ALL and BCM_COSQ_DISCARD_MARK_CONGESTION")));    
    }

    switch (flags) {
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL):
            /* Drop all packets */
            discard_dp = 0;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW):
            /* Drop all packets with DP 1 or above */
            discard_dp = 1;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED):
            /* Drop all packets with DP 2 or above */
            discard_dp = 2;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK):
            /* Drop all packets with DP 3 or above */
            discard_dp = 3;
            break;
        case 0:
            /* No discard per DP */
            discard_dp = 4;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag combination\n"))); 
        } 

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dp_discard_set,(unit, discard_dp)));

    if (!ecn_not_supported) {
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_enable_ecn,(unit, enable_ecn)));
    }
    
exit:              
    BCMDNX_FUNC_RETURN;   
}

/* Get configuration of Weighted Random Early Discard (WRED).
   global drop per DP, and ECN enabled */
int bcm_dnx_cosq_discard_get(
    int unit, 
    uint32 *flags)
{
    uint32 dnx_sand_rc = 0, discard_dp = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);

    dnx_sand_rc = (MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_dp_discard_get,(unit, &discard_dp)));
    DNX_BCM_SAND_IF_ERR_EXIT(dnx_sand_rc);

    if (discard_dp > 3) { /* No discard per DP */
        *flags = 0;
    } 
    else { 
        /* BCM_COSQ_DISCARD_ENABLE is set */
        *flags = BCM_COSQ_DISCARD_ENABLE;

        switch (discard_dp) {
        case 0:
            /* Drop all packets */
            *flags |= BCM_COSQ_DISCARD_COLOR_ALL;
            break;
        case 1:
            /* Drop all packets with DP 1 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW);
            break;
        case 2:
            /* Drop all packets with DP 2 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED);
            break;
        default: /* case 3 */
            /* Drop all packets with DP 3 or above */
            *flags |= BCM_COSQ_DISCARD_COLOR_BLACK;
        }
    }

    if (!SOC_DNX_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit,mbcm_dnx_itm_get_ecn_enabled,(unit, &discard_dp)));
        if (discard_dp) {
            *flags |= BCM_COSQ_DISCARD_MARK_CONGESTION;
        }
    }
    
exit:              
    BCMDNX_FUNC_RETURN;
}

int dnx_bcm_cosq_before_traffic_validation(int unit)
{
  int rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;

    /* Check each queue */
    /* Check only using single SP */
    /* Check PD values are below 4k */
    /* Add reserved value to SP Max Reserved */
    /* Check each service pool */
    /* Check MAX value is below 13k */
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "skip_before_traffic_validation", 0) == 0)
    {
      rv = _bcm_jer2_arad_cosq_update_reserved_pd_threshold_all_sps(unit);
        BCMDNX_IF_ERR_EXIT(rv);
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:              
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int
bcm_dnx_cosq_dest_credit_size_set(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 credit_size)
{
    uint32 credit_worth_local = -1, credit_worth_remote = -1;
    uint32 credit_value_type = DNX_TMC_FAP_CREDIT_VALUE_LOCAL;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    if (!(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_credit_worth_get,(unit, &credit_worth_local)));
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_credit_worth_remote_get,(unit, &credit_worth_remote)));
    if (credit_size == credit_worth_local) {
		credit_value_type = DNX_TMC_FAP_CREDIT_VALUE_LOCAL;
    } else if (credit_size == credit_worth_remote) {
        credit_value_type = DNX_TMC_FAP_CREDIT_VALUE_REMOTE;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Credit size %u is different from both local=%u and remote=%u credit sizes."),
          (unsigned)credit_size, (unsigned)credit_worth_local, (unsigned)credit_worth_remote));
    }
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_module_to_credit_worth_map_set, (unit, dest_modid, credit_value_type)));

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int 
bcm_dnx_cosq_dest_credit_size_get(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 *credit_size)
{
    uint32 credit_worth_local = -1, credit_worth_remote = -1;
    uint32 credit_value_type = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DNX_UNIT_CHECK(unit);
    if (!(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_module_to_credit_worth_map_get, (unit, dest_modid, &credit_value_type)));
    if (credit_value_type == DNX_TMC_FAP_CREDIT_VALUE_LOCAL) {
		DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_credit_worth_get,(unit, &credit_worth_local)));
        *credit_size = credit_worth_local;
    } else if (credit_value_type == DNX_TMC_FAP_CREDIT_VALUE_REMOTE) {
		DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mgmt_credit_worth_remote_get,(unit, &credit_worth_remote)));
        *credit_size = credit_worth_remote;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("The credit size of FAP ID %u was not set."),
          (unsigned)dest_modid));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_flow_control_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 flow_control_mask)
{
    DNX_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    DNX_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        fc_map.bfmc0_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        fc_map.bfmc1_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        fc_map.bfmc2_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        fc_map.gfmc_lb_fc_map = flow_control_mask;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mult_fabric_flow_control_set, (unit, &fc_map)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_gport_flow_control_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 *flow_control_mask)
{
    DNX_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(flow_control_mask);

    DNX_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);
    DNX_BCM_SAND_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_mult_fabric_flow_control_get, (unit, &fc_map)));

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        *flow_control_mask = fc_map.bfmc0_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        *flow_control_mask = fc_map.bfmc1_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        *flow_control_mask = fc_map.bfmc2_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        *flow_control_mask = fc_map.gfmc_lb_fc_map;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_slow_profile_set(
    int unit, 
    bcm_cosq_slow_level_t *slow_level, 
    bcm_cosq_slow_profile_attributes_t *attr)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(slow_level);
    BCMDNX_NULL_CHECK(attr);

    if ((slow_level->profile != 1) && (slow_level->profile != 2))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level profile %d must be 1 or 2"), unit, slow_level->profile));
    }
    if (slow_level->level > 7)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level %d must be between 0a and 7"), unit, slow_level->level));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_slow_max_rates_per_level_set, (unit, slow_level->core, slow_level->level, slow_level->profile, attr->max_rate)));

exit:
    BCMDNX_FUNC_RETURN;

}

/* Set flow factor per level configuration. */
int bcm_dnx_cosq_slow_profile_get(
    int unit, 
    bcm_cosq_slow_level_t *slow_level, 
    bcm_cosq_slow_profile_attributes_t *attr)
{

    int slow_rate_val;
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_NULL_CHECK(slow_level);
    BCMDNX_NULL_CHECK(attr);

    if ((slow_level->profile != 1) && (slow_level->profile != 2))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level profile %d must be 1 or 2"), unit, slow_level->profile));
    }
    if (slow_level->level > 7)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level %d must be between 0a and 7"), unit, slow_level->level));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_sch_slow_max_rates_per_level_get, (unit, slow_level->core, slow_level->level, slow_level->profile, &slow_rate_val)));

    attr->max_rate = slow_rate_val;

exit:
    BCMDNX_FUNC_RETURN;

}

/*Shift the gports flow_id by 64k*/
void
_bcm_dnx_cosq_gport_jer2_qax_flow_id_add(int unit, bcm_gport_t *gport, int core) {
    int flow_id = 0, gport_sf2_type = 0;
    bcm_gport_t sf2_gport = 0;

    if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(*gport));
        BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(*gport, flow_id, core); 
    } else if (BCM_GPORT_IS_SCHEDULER(*gport)) {
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        /*
         * If flow_id > max_flows it means that it is a fmq_class,
         * so no need to add offset to flow_id, because flow_id already
         * comes with the offset.
         */
        if (flow_id < DNX_COSQ_SCH_MAX_FLOW_ID(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, flow_id);
        }
        BCM_GPORT_SCHEDULER_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_SCHED_CIR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_SCHED_CIR_GET(*gport));
        BCM_COSQ_GPORT_SCHED_CIR_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_SCHED_PIR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_SCHED_PIR_GET(*gport));
        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_JER2_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_COMPOSITE_SF2_GET(*gport));

        /* determine sf2 type to create suitable gport */
        BCM_INT_DNX_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, *gport);
        if (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) { /* connector */
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(sf2_gport, flow_id, core);
        } else { /* scheduler */
            BCM_GPORT_SCHEDULER_CORE_SET(sf2_gport, flow_id, core);
        }

        BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_SET(*gport, sf2_gport, core);
    }
}

static int
_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int *delta)
{
    int index = 0, core = 0, rc = BCM_E_NONE;
    DNX_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;
    int qid = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(adjust_info);
    BCMDNX_NULL_CHECK(delta);

    /* retrieve information and translate to internal types */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport) || BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) {

        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport)) { /* credit class compensation */
            qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(adjust_info->gport);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(adjust_info->gport);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport)) { /* credit class compensation */
            qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(adjust_info->gport);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(adjust_info->gport);
        } else if (BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) { /* credit class compensation */
            qid = BCM_COSQ_GPORT_ISQ_QID_GET(adjust_info->gport);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(adjust_info->gport);
        }

        adjust_type = DNX_TMC_ITM_PKT_SIZE_ADJUST_QUEUE;
        qid += adjust_info->cosq;
        core = 0; /* both cores are configured symmetrically currently */
        /* get current discount class profile */
        rc = _bcm_dnx_am_template_queue_discount_cls_mapping_get(unit, core, qid, &index);
        BCMDNX_IF_ERR_EXIT(rc);

    } else if (BCM_GPORT_IS_PROFILE(adjust_info->gport)) { /* append size ptr compensation (per OutLif profile)*/

        index = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        core = 0; /* both cores are set in the same way */
        adjust_type = DNX_TMC_ITM_PKT_SIZE_ADJUST_APPEND_SIZE_PTR;

    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, (adjust_info->gport)));
    }

    /* get compensation delta */
    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_credits_adjust_size_get ,(unit, core, index, adjust_type, delta)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

static int
_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    int index = 0, core = 0, rc = BCM_E_NONE, core_index;
    int qid = 0, old_discount_cls, is_last, is_allocated;
    DNX_TMC_ITM_CR_DISCOUNT_INFO discount_data;
    DNX_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(adjust_info);

    /* retrieve information and translate to internal types */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport) || BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) {

        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport)) { /* credit class compensation */
            qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(adjust_info->gport);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(adjust_info->gport);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport)) { /* credit class compensation */
            qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(adjust_info->gport);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(adjust_info->gport);
        } else if (BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) { /* credit class compensation */
            qid = BCM_COSQ_GPORT_ISQ_QID_GET(adjust_info->gport);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(adjust_info->gport);
        }

        qid += adjust_info->cosq;

        /* exchange to new class */
        DNX_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_data);
        discount_data.discount = delta;
        rc = _bcm_dnx_am_template_queue_discount_cls_exchange(unit, 0 /* currently both cores are configured symmetrically */, 
                                                              qid, &discount_data, &old_discount_cls, &is_last, &index, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        BCM_DNX_CORES_ITER(BCM_CORE_ALL, core_index) { /* configure both cores */
            /* configure compensation delta profile */
            adjust_type = DNX_TMC_ITM_PKT_SIZE_ADJUST_QUEUE;
            if (is_allocated) {
                rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_credits_adjust_size_set, (unit, core_index, index, adjust_type, delta)));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* set new queue to discount class profile mapping, configures both cores */
        rc = _bcm_dnx_cosq_voq_class_mapping_set(unit, core, qid, BCM_DNX_COSQ_DISCOUNT_CLS, index);
        BCMDNX_IF_ERR_EXIT(rc);
  
    } else if (BCM_GPORT_IS_PROFILE(adjust_info->gport)) { /* append size ptr compensation (per OutLif profile)*/

        index = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        core = BCM_CORE_ALL; /* both cores are set in the same way */
        adjust_type = DNX_TMC_ITM_PKT_SIZE_ADJUST_APPEND_SIZE_PTR;

        /* configure compensation delta */
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_credits_adjust_size_set, (unit, core, index, adjust_type, delta)));
        BCMDNX_IF_ERR_EXIT(rc);

    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, (adjust_info->gport)));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_crps_get
 *  Purpose
 *    get the compensation delta which is configure for CRPS ingress PP or ingress TM (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
static int
_bcm_cosq_gport_pkt_size_adjust_crps_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int * delta)
{
    DNX_TMC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int tableIndex, profileIndex;
    int core;
    uint32 tm_port, pp_port;
    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP) ? DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP : DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_outLif_delta_get, (unit, 0, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInTM)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );
            tableIndex = (int)pp_port;
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_crps_get
 *  Purpose
 *    set the compensation delta which is configure for CRPS ingress PP or ingress TM (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
static int
_bcm_cosq_gport_pkt_size_adjust_crps_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    DNX_TMC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int core, template, temp;
    int is_last, is_allocated;
    int tableIndex, profileIndex;
    int oldProfileIndex = 0;
    uint32 tm_port, pp_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP) ? DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP : DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_outLif_delta_set, (unit, SOC_CORE_ALL, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInTM)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get,
                    (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DNX_UNIT_CHECK(unit);
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_crps_pktSize_compensation_exchange(
                    unit, core, dnx_am_template_crps_intm_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, tableIndex, profileIndex)));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );
            tableIndex = (int)pp_port;
            /* get from HW the prev profile for this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));

            /* unit check was added to satisfy the coverity */        
            BCM_DNX_UNIT_CHECK(unit);                        
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_crps_pktSize_compensation_exchange(
                    unit, core, dnx_am_template_crps_inpp_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, tableIndex, profileIndex)));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
	BCMDNX_FUNC_RETURN;	
}




/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_stat_report_get
 *  Purpose
 *    get the compensation delta which is configure for statistics interface ingress or egress (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
static int
_bcm_cosq_gport_pkt_size_adjust_stat_report_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int * delta)
{
    DNX_TMC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int tableIndex, profileIndex;
    int core;
    uint32 tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) ? DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN : DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_outLif_delta_get, (unit, 0, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportOut)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}



/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_stat_report_set
 *  Purpose
 *    get the compensation delta which is configure for statistics interface ingress or egress (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */


static int
_bcm_cosq_gport_pkt_size_adjust_stat_report_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    DNX_TMC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int core, template, temp;
    int is_last, is_allocated;
    int tableIndex, profileIndex;
    int oldProfileIndex = 0;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) ? DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN : DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_outLif_delta_set, (unit, SOC_CORE_ALL, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) 
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get,
                                                           (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DNX_UNIT_CHECK(unit); /* Coverity Fix */
            /* exchange from DB the profile index for t his port */
            BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_stat_interface_pktSize_compensation_exchange(
                        unit, core, dnx_am_template_stat_interface_ing_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
                /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, tableIndex, profileIndex)));
        } else if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportOut) {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( dnx_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_delta_and_profile_get,
                    (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DNX_UNIT_CHECK(unit); /* Coverity Fix */
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_stat_interface_pktSize_compensation_exchange(
                    unit, core, dnx_am_template_stat_interface_egr_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, tableIndex, profileIndex)));
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
        }
    }
exit:
	BCMDNX_FUNC_RETURN;	
}

int bcm_dnx_cosq_gport_pkt_size_adjust_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(adjust_info->source_info.source_type)
    {
        case bcmCosqPktSizeAdjustSourceScheduler:
            if (!DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) || DNX_TMC_ITM_COMPENSATION_LEGACY_MODE(unit))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, per packer scheduler compensation is not enabled"), unit));
            }
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_set(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceCrpsInPP:
        case bcmCosqPktSizeAdjustSourceCrpsInTM:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_crps_set(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceStatReportIn:
        case bcmCosqPktSizeAdjustSourceStatReportOut:
             BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_stat_report_set(unit, adjust_info, delta));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_dnx_cosq_gport_pkt_size_adjust_set called with invalid source_info enum value")));
            break;
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_pkt_size_adjust_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int *delta)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(adjust_info->source_info.source_type)
    {
        case bcmCosqPktSizeAdjustSourceScheduler:
            if (!DNX_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) || DNX_TMC_ITM_COMPENSATION_LEGACY_MODE(unit))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, per packer scheduler compensation is not enabled"), unit));
            }
            BCMDNX_IF_ERR_EXIT(_bcm_dnx_cosq_gport_pkt_size_adjust_scheduler_get(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceCrpsInPP:
        case bcmCosqPktSizeAdjustSourceCrpsInTM:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_crps_get(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceStatReportIn:
        case bcmCosqPktSizeAdjustSourceStatReportOut:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_stat_report_get(unit, adjust_info, delta));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_dnx_cosq_gport_pkt_size_adjust_get called with invalid source_info enum value")));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_pkt_size_adjust_delta_map_set(
        int unit,
        int delta,
        int final_delta)
{
    int old_profile, is_last, new_profile, is_allocated, rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_dnx_cosq_pkt_size_adjust_delta_map_set() is not supported for this device type.")));
    }

    /* delta range validation */
    if (delta < DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL || delta > DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_dnx_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

   /* final delta range validation */
    if (final_delta < DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL || final_delta > DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_dnx_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

    rc = _bcm_dnx_am_template_scheduler_adjust_size_final_delta_mapping_exchange(unit,
                                                                                 0/*both cores are symmetric */, delta, &final_delta, 
                                                                                 &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* commit profile value to HW, both cores are configured the same */
    if (is_allocated) {
        rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_sch_final_delta_set, (unit, SOC_CORE_ALL, new_profile, final_delta)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* map original delta to new final delta profile */
    rc = (MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_itm_sch_final_delta_map_set, (unit, SOC_CORE_ALL, delta, new_profile)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_pkt_size_adjust_delta_map_get(
        int unit,
        int delta,
        int *final_delta)
{
    int rc;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(final_delta);

    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_dnx_cosq_pkt_size_adjust_delta_map_get() is not supported for this device type.")));
    }

    /* delta range validation */
    if (delta < DNX_COSQ_PB_CR_DISCOUNT_MIN_VAL || delta > DNX_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_dnx_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

    /* get final delta from original delta, both cores are configured in the same way */
    rc = _bcm_dnx_am_template_scheduler_adjust_size_final_delta_mapping_data_get(unit, 0, delta , final_delta);
    BCMDNX_IF_ERR_EXIT(rc);


exit:
    BCMDNX_FUNC_RETURN;
}


/*
 *  Name
 *    _bcm_dnx_cosq_pkt_size_compensation_profiles_crps_init
 *  Purpose
 *    init the packet size compensations profiles.
 *  Arguments
 *    IN unit
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
static
int _bcm_dnx_cosq_pkt_size_compensation_profiles_crps_init(int unit)
{
    int core, commandId;
    int delta = 2; /* to compensate for 2 bytes DRAM CRC */
    int template = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* INIT compensation for IQM DC delta */
    SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_crps_pktSize_compensation_init(unit, core, dnx_am_template_crps_intm_port_compensation_profile, delta, template) );
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, template, delta)));

        /* loop of 2, for two CMDS_ID */
        for (commandId=0; commandId<2; commandId++)
        {
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, commandId, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, MAX_PORTS_IN_CORE, template)));
        }
        /* unit check was added to satisfy the coverity */        
        BCM_DNX_UNIT_CHECK(unit);
    }

    /* INIT compensation for IRPP DC delta */
    SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_crps_pktSize_compensation_init(unit, core, dnx_am_template_crps_inpp_port_compensation_profile, delta, template) );
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, template, delta)));

        /* loop of 2, for two CMDS_ID */
        for (commandId=0; commandId<2; commandId++)
        {
            DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, commandId, DNX_TMC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, MAX_PORTS_IN_CORE, template)));
        }
        /* unit check was added to satisfy the coverity */
        BCM_DNX_UNIT_CHECK(unit);
    }

exit:
    BCMDNX_FUNC_RETURN;
}



/*
 *  Name
 *    _bcm_dnx_cosq_pkt_size_compensation_profiles_stat_interface_init
 *  Purpose
 *    init the packet size compensations profiles.
 *  Arguments
 *    IN unit
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
static
int _bcm_dnx_cosq_pkt_size_compensation_profiles_stat_interface_init(int unit)
{
    int core;
    int delta = 2; /* to compensate for 2 bytes DRAM CRC */
    int template = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* INIT compensation for IQMT ING delta */
    SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_stat_interface_pktSize_compensation_init(unit, core, dnx_am_template_stat_interface_ing_port_compensation_profile, delta, template) );
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, template, delta)));


        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, 0, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, MAX_PORTS_IN_CORE, template)));
        BCM_DNX_UNIT_CHECK(unit); /* Coverity Fix */
        
    }

    /* INIT compensation for IQMT EGR delta */
    SOC_DNX_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dnx_am_template_crps_pktSize_compensation_init(unit, core, dnx_am_template_stat_interface_egr_port_compensation_profile, delta, template) );
        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_profile_delta_set, (unit, core, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, template, delta)));


        DNXC_SAND_IF_ERR_RETURN(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_cnt_ingress_compensation_port_profile_set, (unit, core, 0, DNX_TMC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, MAX_PORTS_IN_CORE, template)));
        BCM_DNX_UNIT_CHECK(unit); /* Coverity Fix */
        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_icgm_resource_stat_get(int unit,
                                     bcm_cosq_icgm_resource_stat_key_t *stat_key,
                                     uint64 *value)
{
    bcm_error_t rv = BCM_E_NONE;
    int core_id = -1;
    bcm_gport_t core_gport = 0;
    DNX_TMC_ITM_CGM_RSRC_STAT_TYPE type = 0;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rv);        

    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(stat_key);
    BCMDNX_NULL_CHECK(value);

    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_icgm_resource_stat_get() is not supported for this device.")));
    }

    core_gport = stat_key->gport;

    if (SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores == 1 && core_gport == 0) {
        core_id = 0;
    } else if (BCM_COSQ_GPORT_IS_CORE(core_gport)) {
        core_id = BCM_COSQ_GPORT_CORE_GET(core_gport);
        if (((core_id < 0) || (core_id >= SOC_DNX_CONFIG(unit)->core_mode.nof_active_cores))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid core id %d"), unit, core_id));
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport 0x%x type."), unit, core_gport));
    }

    switch (stat_key->stat_type) {
        case bcmCosqICgmMinFreeBDB:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_BDB;
            break;

        case bcmCosqICgmMinFreeOcbBuffers:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_OCB_BUFFERS;
            break;

        case bcmCosqICgmMinFreeMiniMcBuffers:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_MINI_MC_BUFFERS;
            break;

        case bcmCosqICgmMinFreeFullMcBuffers:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_FULL_MC_BUFFERS;
            break;

        case bcmCosqICgmMinFreeVoqDramBDB:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_VOQ_DRAM_BDB;
            break;

        case bcmCosqICgmMinFreeVoqOcbBDB:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_VOQ_OCB_BDB;
            break;

        case bcmCosqICgmMinFreeSramBuffers:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_SRAM_BUFFERS;
            break;

        case bcmCosqICgmMinFreeSramPDB:
            type = DNX_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_SRAM_PDB;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown resource statistic type.")));
    }

    rv = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_min_free_resources_stat_get, (unit, core_id, type, value));
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dnx_cosq_max_latency_pkts_get(int unit,
                                    bcm_gport_t gport,
                                    uint32 flags,
                                    int max_count,
                                    bcm_cosq_max_latency_pkts_t *max_latency_pkts,
                                    int *actual_count)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DNX_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(max_latency_pkts);  
    
    rc = MBCM_DNX_SOC_DRIVER_CALL(unit, mbcm_dnx_itm_max_latency_pkts_get,(unit, max_count, (void*)max_latency_pkts, actual_count));
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;

}



            
#ifdef FIXME_DNX_LEGACY
int 
bcm_dnx_cosq_ingress_port_drop_enable_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int *enable_mode)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_enable_get, (unit, port, flags, enable_mode)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_ingress_port_drop_enable_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int enable_mode)
{
    int port_ext_type;
    uint32 soc_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    switch (enable_mode) {
    case bcmCosqIngressPortDropDisable:
    case bcmCosqIngressPortDropEnableHardStage:
        /*valid input*/
        break;
    case bcmCosqIngressPortDropEnableHardAndSoftStage:
        if (!SOC_IS_JERICHO_PLUS_ONLY(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop enable mode %d is invalid"), unit ,port, enable_mode));
        }
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop enable mode %d is invalid"), unit ,port, enable_mode));
        break;
    }

    if (_BCM_DNX_EXTENDER_IS_INIT(unit)) {
        BCMDNX_IF_ERR_EXIT(bcm_dnx_port_control_get(unit, port, bcmPortControlExtenderType, &port_ext_type));
        if (port_ext_type == BCM_PORT_EXTENDER_TYPE_SWITCH)
        {
            soc_flags |= DNX_TMC_PORT_PRD_F_PORT_EXTERNDER;
        }
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_enable_set, (unit, port, soc_flags, enable_mode))); 

exit:
    BCMDNX_FUNC_RETURN;
}
/* soc_color_t */
int 
bcm_dnx_cosq_ingress_port_drop_map_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_cosq_ingress_port_drop_map_t map, 
    uint32 key, 
    int *priority)
{
    
    soc_dnx_prd_map_t prd_map;
    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    /* Check if the key matches to the correct map, and clear the map indication */
    switch (map) 
    {
    case bcmCosqIngressPortDropTmTcDpPriorityTable:
        /* TM map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdTmTcDpPriorityTable; 
        break;
    case bcmCosqIngressPortDropIpDscpToPriorityTable:
        /* IP map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdIpDscpToPriorityTable;
        break;
    case bcmCosqIngressPortDropEthPcpDeiToPriorityTable:
        /* ETH map size is 16x2b - key should be 4b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdEthPcpDeiToPriorityTable;
        break;
    case bcmCosqIngressPortDropMplsExpToPriorityTable:
        /* MPLS map size is 8x2b - key should be 3b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdMplsExpToPriorityTable;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid map %d"), unit ,map));
        break;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_map_get, (unit, port, flags, prd_map, key, priority)));

    if ((*priority < SOC_DNX_COSQ_PORT_PRIORITY_MIN) || (*priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit ,*priority));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_ingress_port_drop_map_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_cosq_ingress_port_drop_map_t map, 
    uint32 key, 
    int priority)
{
    soc_dnx_prd_map_t prd_map;

    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit , port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    switch (map)
    {
    case bcmCosqIngressPortDropTmTcDpPriorityTable:
        /* TM map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdTmTcDpPriorityTable;
        break;
    case bcmCosqIngressPortDropIpDscpToPriorityTable:
        /* IP map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdIpDscpToPriorityTable;
        break;
    case bcmCosqIngressPortDropEthPcpDeiToPriorityTable:
        /* ETH map size is 16x2b - key should be 4b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdEthPcpDeiToPriorityTable;
        break;
    case bcmCosqIngressPortDropMplsExpToPriorityTable:
        /* MPLS map size is 8x2b - key should be 3b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_CLEAR(key);
        prd_map = socDnxPrdMplsExpToPriorityTable;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid map %d"), unit ,map));
        break;
    }

    if ((priority < SOC_DNX_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }
    
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_map_set, (unit, port, flags, prd_map, key, priority)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_ingress_port_drop_threshold_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int priority,
    uint32 *value)
{
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((priority < SOC_DNX_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_threshold_get, (unit, port, flags, priority, value)));
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_dnx_cosq_ingress_port_drop_threshold_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int priority,
    uint32 value)
{
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((priority < SOC_DNX_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_threshold_set, (unit, port, flags, priority, value)));
exit:
    BCMDNX_FUNC_RETURN;
}


            
int bcm_dnx_cosq_ingress_port_drop_default_priority_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 default_priority) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if (default_priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , default_priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_default_priority_set, (unit, port, flags, default_priority)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_default_priority_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags,
    uint32 *default_priority) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_default_priority_get, (unit, port, flags, default_priority)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_custom_ether_type_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 ether_type_code,
    uint32 ether_type_val) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_custom_ether_type_set, (unit, port, flags, ether_type_code, ether_type_val)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_custom_ether_type_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 ether_type_code,
    uint32 *ether_type_val) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_custom_ether_type_get, (unit, port, flags, ether_type_code, ether_type_val)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_control_frame_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_cosq_ingress_drop_control_frame_config_t *control_frame_config) {

    DNX_TMC_PORT_PRD_CONTROL_PLANE prd_ctrl_plane;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    COMPILER_64_COPY(prd_ctrl_plane.mac_da_val, control_frame_config->mac_da_val);
    COMPILER_64_COPY(prd_ctrl_plane.mac_da_mask, control_frame_config->mac_da_mask);
    prd_ctrl_plane.ether_type_code = control_frame_config->ether_type_code;
    prd_ctrl_plane.ether_type_code_mask = control_frame_config->ether_type_code_mask;
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_control_frame_set, (unit, port, flags, &prd_ctrl_plane)));
exit:
    BCMDNX_FUNC_RETURN; 
}

int bcm_dnx_cosq_ingress_port_drop_control_frame_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_ingress_drop_control_frame_config_t *control_frame_config) {

    DNX_TMC_PORT_PRD_CONTROL_PLANE prd_ctrl_plane;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_control_frame_get, (unit, port, flags, &prd_ctrl_plane)));

    COMPILER_64_COPY(control_frame_config->mac_da_val, prd_ctrl_plane.mac_da_val);
    COMPILER_64_COPY(control_frame_config->mac_da_mask, prd_ctrl_plane.mac_da_mask);
    control_frame_config->ether_type_code = prd_ctrl_plane.ether_type_code;
    control_frame_config->ether_type_code_mask = prd_ctrl_plane.ether_type_code_mask;
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_flex_key_construct_set(
    int unit, 
    bcm_cosq_ingress_drop_flex_key_construct_id_t *key_id, 
    uint32 flags, 
    bcm_cosq_ingress_drop_flex_key_construct_t *flex_key_config) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, key_id->port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,key_id->port));
    }
    if (!SOC_PORT_VALID(unit, key_id->port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), key_id->port));
    }
    if (flex_key_config->array_size != BCM_COSQ_INGRESS_PORT_DROP_MAX_FLEX_KEY_FIELDS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: offset array size %d is invalid - shold be %d ."), 
                                          unit ,key_id->port, flex_key_config->array_size, DNX_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_flex_key_construct_set, (unit, key_id->port, flags, flex_key_config->offset_array, flex_key_config->array_size))); 
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_flex_key_construct_get(
    int unit, 
    bcm_cosq_ingress_drop_flex_key_construct_id_t *key_id, 
    uint32 flags, 
    bcm_cosq_ingress_drop_flex_key_construct_t *flex_key_config) 
{
    int i;
    uint32 offset_array[DNX_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS];
    uint32 array_size;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, key_id->port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,key_id->port));
    }
    if (!SOC_PORT_VALID(unit, key_id->port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), key_id->port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_flex_key_construct_get, (unit, key_id->port, flags, offset_array, &array_size)));
    for (i = 0; i < DNX_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS; ++i) {
        flex_key_config->offset_array[i] = offset_array[i];
    }
    flex_key_config->array_size = array_size;
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_ingress_port_drop_flex_key_entry_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 key_index,
    bcm_cosq_ingress_drop_flex_key_entry_t *flex_key_info) {

    DNX_TMC_PORT_PRD_FLEX_KEY_ENTRY prd_key_entry;
    int i;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }
    if (flex_key_info->priority > SOC_DNX_COSQ_PORT_PRIORITY_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , flex_key_info->priority));
    }

    prd_key_entry.ether_code = flex_key_info->ether_code.value;
    prd_key_entry.ether_code_mask = flex_key_info->ether_code.mask;
    prd_key_entry.priority = flex_key_info->priority;
    prd_key_entry.num_key_fields = flex_key_info->num_key_fields;
    for (i = 0; i < prd_key_entry.num_key_fields; ++i) {
        prd_key_entry.key_fields_values[i] = flex_key_info->key_fields[i].value;
        prd_key_entry.key_fields_masks[i] = flex_key_info->key_fields[i].mask;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_flex_key_entry_set, (unit, port, flags, key_index, &prd_key_entry)));
exit:
    BCMDNX_FUNC_RETURN; 
}

int bcm_dnx_cosq_ingress_port_drop_flex_key_entry_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 key_index,
    bcm_cosq_ingress_drop_flex_key_entry_t *flex_key_info) {

    DNX_TMC_PORT_PRD_FLEX_KEY_ENTRY prd_key_entry;
    int i;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DNX_DRIVER_CALL(unit, mbcm_dnx_port_prd_flex_key_entry_get, (unit, port, flags, key_index, &prd_key_entry)));
    flex_key_info->ether_code.value = prd_key_entry.ether_code;
    flex_key_info->ether_code.mask = prd_key_entry.ether_code_mask;
    flex_key_info->priority = prd_key_entry.priority;
    flex_key_info->num_key_fields = prd_key_entry.num_key_fields;
    for (i = 0; i < prd_key_entry.num_key_fields; ++i) {
        flex_key_info->key_fields[i].value = prd_key_entry.key_fields_values[i];
        flex_key_info->key_fields[i].mask = prd_key_entry.key_fields_masks[i];
    }
exit:
    BCMDNX_FUNC_RETURN;
}
#endif 

int bcm_dnx_cosq_gport_fadt_threshold_set(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold ) {

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_FUNC_RETURN;
}

int bcm_dnx_cosq_gport_fadt_threshold_get(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold ) {

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_FUNC_RETURN;
}
