/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * File:	async.c
 * Purpose:	Asynchronous BCM API routines
 * Generator:	mkdispatch 1.54
 */

#include <bcm/types.h>
#include <bcm/async.h>
#include <bcm/auth.h>
#include <bcm/bcmi2c.h>
#include <bcm/bfd.h>
#include <bcm/bregex.h>
#include <bcm/cosq.h>
#include <bcm/custom.h>
#include <bcm/eav.h>
#include <bcm/ecn.h>
#include <bcm/error.h>
#include <bcm/extender.h>
#include <bcm/fabric.h>
#include <bcm/failover.h>
#include <bcm/fcmap.h>
#include <bcm/fcoe.h>
#include <bcm/field.h>
#include <bcm/init.h>
#include <bcm/ipfix.h>
#include <bcm/ipmc.h>
#include <bcm/ipsec.h>
#include <bcm/knet.h>
#include <bcm/l2.h>
#include <bcm/l2gre.h>
#include <bcm/l3.h>
#include <bcm/lb.h>
#include <bcm/link.h>
#include <bcm/macsec.h>
#include <bcm/mcast.h>
#include <bcm/mim.h>
#include <bcm/mirror.h>
#include <bcm/module.h>
#include <bcm/mpls.h>
#include <bcm/multicast.h>
#include <bcm/nat.h>
#include <bcm/niv.h>
#include <bcm/oam.h>
#include <bcm/oob.h>
#include <bcm/pkt.h>
#include <bcm/policer.h>
#include <bcm/port.h>
#include <bcm/proxy.h>
#include <bcm/pstats.h>
#include <bcm/ptp.h>
#include <bcm/qos.h>
#include <bcm/range.h>
#include <bcm/rate.h>
#include <bcm/rx.h>
#include <bcm/sat.h>
#include <bcm/stack.h>
#include <bcm/stat.h>
#include <bcm/stg.h>
#include <bcm/subport.h>
#include <bcm/switch.h>
#include <bcm/time.h>
#include <bcm/topo.h>
#include <bcm/trill.h>
#include <bcm/trunk.h>
#include <bcm/tsn.h>
#include <bcm/tunnel.h>
#include <bcm/tx.h>
#include <bcm/txbeacon.h>
#include <bcm/udf.h>
#include <bcm/vlan.h>
#include <bcm/vswitch.h>
#include <bcm/vxlan.h>
#include <bcm/wlan.h>

#include <bcm_int/async_req.h>
#include <bcm_int/async_server.h>
#include <shared/alloc.h>

#ifdef	BCM_ASYNC_SUPPORT

extern void bcm_async_run(bcm_async_req_t *);

void
_bcm_shutdown_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SHUTDOWN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args._shutdown.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_async(
	int unit,
	char * type,
	char * subtype,
	int remunit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach.unit = unit;
	async->args.attach.type = type;
	async->args.attach.subtype = subtype;
	async->args.attach.remunit = remunit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_check_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH_CHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach_check.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_early_txrx_async(
	int unit,
	char * type,
	char * subtype,
	int remunit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH_EARLY_TXRX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach_early_txrx.unit = unit;
	async->args.attach_early_txrx.type = type;
	async->args.attach_early_txrx.subtype = subtype;
	async->args.attach_early_txrx.remunit = remunit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_max_async(
	int * max_units,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH_MAX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach_max.max_units = max_units;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_register_async(
	int unit,
	bcm_attach_cb_t cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach_register.unit = unit;
	async->args.attach_register.cb = cb;
	async->args.attach_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_attach_unregister_async(
	int unit,
	bcm_attach_cb_t cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ATTACH_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.attach_unregister.unit = unit;
	async->args.attach_unregister.cb = cb;
	async->args.attach_unregister.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_egress_get_async(
	int unit,
	int port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_egress_get.unit = unit;
	async->args.auth_egress_get.port = port;
	async->args.auth_egress_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_egress_set_async(
	int unit,
	int port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_egress_set.unit = unit;
	async->args.auth_egress_set.port = port;
	async->args.auth_egress_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mac_add_async(
	int unit,
	int port,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MAC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_add.unit = unit;
	async->args.auth_mac_add.port = port;
	async->args.auth_mac_add.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mac_control_get_async(
	int unit,
	bcm_auth_mac_control_t type,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MAC_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_control_get.unit = unit;
	async->args.auth_mac_control_get.type = type;
	async->args.auth_mac_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mac_control_set_async(
	int unit,
	bcm_auth_mac_control_t type,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MAC_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_control_set.unit = unit;
	async->args.auth_mac_control_set.type = type;
	async->args.auth_mac_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mac_delete_async(
	int unit,
	int port,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MAC_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_delete.unit = unit;
	async->args.auth_mac_delete.port = port;
	async->args.auth_mac_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mac_delete_all_async(
	int unit,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MAC_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_delete_all.unit = unit;
	async->args.auth_mac_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mode_get_async(
	int unit,
	int port,
	uint32 * modep,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mode_get.unit = unit;
	async->args.auth_mode_get.port = port;
	async->args.auth_mode_get.modep = modep;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_mode_set_async(
	int unit,
	int port,
	uint32 mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mode_set.unit = unit;
	async->args.auth_mode_set.port = port;
	async->args.auth_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_auth_unauth_callback_async(
	int unit,
	bcm_auth_cb_t func,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_AUTH_UNAUTH_CALLBACK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_unauth_callback.unit = unit;
	async->args.auth_unauth_callback.func = func;
	async->args.auth_unauth_callback.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_BFD

void
bcm_bfd_auth_sha1_get_async(
	int unit,
	int index,
	bcm_bfd_auth_sha1_t * sha1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_AUTH_SHA1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_auth_sha1_get.unit = unit;
	async->args.bfd_auth_sha1_get.index = index;
	async->args.bfd_auth_sha1_get.sha1 = sha1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_auth_sha1_set_async(
	int unit,
	int index,
	bcm_bfd_auth_sha1_t * sha1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_AUTH_SHA1_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_auth_sha1_set.unit = unit;
	async->args.bfd_auth_sha1_set.index = index;
	async->args.bfd_auth_sha1_set.sha1 = sha1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_auth_simple_password_get_async(
	int unit,
	int index,
	bcm_bfd_auth_simple_password_t * sp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_AUTH_SIMPLE_PASSWORD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_auth_simple_password_get.unit = unit;
	async->args.bfd_auth_simple_password_get.index = index;
	async->args.bfd_auth_simple_password_get.sp = sp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_auth_simple_password_set_async(
	int unit,
	int index,
	bcm_bfd_auth_simple_password_t * sp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_AUTH_SIMPLE_PASSWORD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_auth_simple_password_set.unit = unit;
	async->args.bfd_auth_simple_password_set.index = index;
	async->args.bfd_auth_simple_password_set.sp = sp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_discard_stat_get_async(
	int unit,
	bcm_bfd_discard_stat_t * discarded_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_DISCARD_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_discard_stat_get.unit = unit;
	async->args.bfd_discard_stat_get.discarded_info = discarded_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_discard_stat_set_async(
	int unit,
	bcm_bfd_discard_stat_t * discarded_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_DISCARD_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_discard_stat_set.unit = unit;
	async->args.bfd_discard_stat_set.discarded_info = discarded_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_create_async(
	int unit,
	bcm_bfd_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_create.unit = unit;
	async->args.bfd_endpoint_create.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_destroy_async(
	int unit,
	bcm_bfd_endpoint_t endpoint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_destroy.unit = unit;
	async->args.bfd_endpoint_destroy.endpoint = endpoint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_get_async(
	int unit,
	bcm_bfd_endpoint_t endpoint,
	bcm_bfd_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_get.unit = unit;
	async->args.bfd_endpoint_get.endpoint = endpoint;
	async->args.bfd_endpoint_get.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_poll_async(
	int unit,
	bcm_bfd_endpoint_t endpoint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_POLL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_poll.unit = unit;
	async->args.bfd_endpoint_poll.endpoint = endpoint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_endpoint_stat_get_async(
	int unit,
	bcm_bfd_endpoint_t endpoint,
	bcm_bfd_endpoint_stat_t * ctr_info,
	uint32 options,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_ENDPOINT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_endpoint_stat_get.unit = unit;
	async->args.bfd_endpoint_stat_get.endpoint = endpoint;
	async->args.bfd_endpoint_stat_get.ctr_info = ctr_info;
	async->args.bfd_endpoint_stat_get.options = options;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_event_register_async(
	int unit,
	bcm_bfd_event_types_t event_types,
	bcm_bfd_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_event_register.unit = unit;
	async->args.bfd_event_register.event_types = event_types;
	async->args.bfd_event_register.cb = cb;
	async->args.bfd_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_event_unregister_async(
	int unit,
	bcm_bfd_event_types_t event_types,
	bcm_bfd_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_event_unregister.unit = unit;
	async->args.bfd_event_unregister.event_types = event_types;
	async->args.bfd_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_status_multi_get_async(
	int unit,
	int max_endpoints,
	bcm_bfd_status_t * status_arr,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_STATUS_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_status_multi_get.unit = unit;
	async->args.bfd_status_multi_get.max_endpoints = max_endpoints;
	async->args.bfd_status_multi_get.status_arr = status_arr;
	async->args.bfd_status_multi_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_tx_start_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_TX_START;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_tx_start.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_bfd_tx_stop_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_BFD_TX_STOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.bfd_tx_stop.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_BFD */

void
bcm_clear_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.clear.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_multi_profile_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	int array_size,
	bcm_cosq_bst_profile_t * profile_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_MULTI_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_multi_profile_get.unit = unit;
	async->args.cosq_bst_multi_profile_get.gport = gport;
	async->args.cosq_bst_multi_profile_get.cosq = cosq;
	async->args.cosq_bst_multi_profile_get.bid = bid;
	async->args.cosq_bst_multi_profile_get.array_size = array_size;
	async->args.cosq_bst_multi_profile_get.profile_array = profile_array;
	async->args.cosq_bst_multi_profile_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_multi_profile_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	int array_size,
	bcm_cosq_bst_profile_t * profile_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_MULTI_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_multi_profile_set.unit = unit;
	async->args.cosq_bst_multi_profile_set.gport = gport;
	async->args.cosq_bst_multi_profile_set.cosq = cosq;
	async->args.cosq_bst_multi_profile_set.bid = bid;
	async->args.cosq_bst_multi_profile_set.array_size = array_size;
	async->args.cosq_bst_multi_profile_set.profile_array = profile_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_profile_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	bcm_cosq_bst_profile_t * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_profile_get.unit = unit;
	async->args.cosq_bst_profile_get.gport = gport;
	async->args.cosq_bst_profile_get.cosq = cosq;
	async->args.cosq_bst_profile_get.bid = bid;
	async->args.cosq_bst_profile_get.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_profile_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	bcm_cosq_bst_profile_t * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_profile_set.unit = unit;
	async->args.cosq_bst_profile_set.gport = gport;
	async->args.cosq_bst_profile_set.cosq = cosq;
	async->args.cosq_bst_profile_set.bid = bid;
	async->args.cosq_bst_profile_set.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_clear_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_clear.unit = unit;
	async->args.cosq_bst_stat_clear.gport = gport;
	async->args.cosq_bst_stat_clear.cosq = cosq;
	async->args.cosq_bst_stat_clear.bid = bid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_extended_clear_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_bst_stat_id_t bid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_EXTENDED_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_extended_clear.unit = unit;
	async->args.cosq_bst_stat_extended_clear.id = id;
	async->args.cosq_bst_stat_extended_clear.bid = bid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_extended_get_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_bst_stat_id_t bid,
	uint32 options,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_EXTENDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_extended_get.unit = unit;
	async->args.cosq_bst_stat_extended_get.id = id;
	async->args.cosq_bst_stat_extended_get.bid = bid;
	async->args.cosq_bst_stat_extended_get.options = options;
	async->args.cosq_bst_stat_extended_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_extended_get32_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_bst_stat_id_t bid,
	uint32 options,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_EXTENDED_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_extended_get32.unit = unit;
	async->args.cosq_bst_stat_extended_get32.id = id;
	async->args.cosq_bst_stat_extended_get32.bid = bid;
	async->args.cosq_bst_stat_extended_get32.options = options;
	async->args.cosq_bst_stat_extended_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	uint32 options,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_get.unit = unit;
	async->args.cosq_bst_stat_get.gport = gport;
	async->args.cosq_bst_stat_get.cosq = cosq;
	async->args.cosq_bst_stat_get.bid = bid;
	async->args.cosq_bst_stat_get.options = options;
	async->args.cosq_bst_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_get32_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_bst_stat_id_t bid,
	uint32 options,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_get32.unit = unit;
	async->args.cosq_bst_stat_get32.gport = gport;
	async->args.cosq_bst_stat_get32.cosq = cosq;
	async->args.cosq_bst_stat_get32.bid = bid;
	async->args.cosq_bst_stat_get32.options = options;
	async->args.cosq_bst_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_multi_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 options,
	int max_values,
	bcm_bst_stat_id_t * id_list,
	uint64 * values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_multi_get.unit = unit;
	async->args.cosq_bst_stat_multi_get.gport = gport;
	async->args.cosq_bst_stat_multi_get.cosq = cosq;
	async->args.cosq_bst_stat_multi_get.options = options;
	async->args.cosq_bst_stat_multi_get.max_values = max_values;
	async->args.cosq_bst_stat_multi_get.id_list = id_list;
	async->args.cosq_bst_stat_multi_get.values = values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_multi_get32_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 options,
	int max_values,
	bcm_bst_stat_id_t * id_list,
	uint32 * values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_multi_get32.unit = unit;
	async->args.cosq_bst_stat_multi_get32.gport = gport;
	async->args.cosq_bst_stat_multi_get32.cosq = cosq;
	async->args.cosq_bst_stat_multi_get32.options = options;
	async->args.cosq_bst_stat_multi_get32.max_values = max_values;
	async->args.cosq_bst_stat_multi_get32.id_list = id_list;
	async->args.cosq_bst_stat_multi_get32.values = values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_bst_stat_sync_async(
	int unit,
	bcm_bst_stat_id_t bid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BST_STAT_SYNC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_bst_stat_sync.unit = unit;
	async->args.cosq_bst_stat_sync.bid = bid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_buffer_id_multi_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_dir_t direction,
	int array_max,
	bcm_cosq_buffer_id_t * buf_id_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_BUFFER_ID_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_buffer_id_multi_get.unit = unit;
	async->args.cosq_buffer_id_multi_get.gport = gport;
	async->args.cosq_buffer_id_multi_get.cosq = cosq;
	async->args.cosq_buffer_id_multi_get.direction = direction;
	async->args.cosq_buffer_id_multi_get.array_max = array_max;
	async->args.cosq_buffer_id_multi_get.buf_id_array = buf_id_array;
	async->args.cosq_buffer_id_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_create_async(
	int unit,
	bcm_cosq_classifier_t * classifier,
	int * classifier_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_create.unit = unit;
	async->args.cosq_classifier_create.classifier = classifier;
	async->args.cosq_classifier_create.classifier_id = classifier_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_destroy_async(
	int unit,
	int classifier_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_destroy.unit = unit;
	async->args.cosq_classifier_destroy.classifier_id = classifier_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_get_async(
	int unit,
	int classifier_id,
	bcm_cosq_classifier_t * classifier,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_get.unit = unit;
	async->args.cosq_classifier_get.classifier_id = classifier_id;
	async->args.cosq_classifier_get.classifier = classifier;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_id_get_async(
	int unit,
	bcm_cosq_classifier_t * classifier,
	int array_count,
	bcm_cos_t * priority_array,
	bcm_cos_queue_t * cosq_array,
	int * classifier_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_id_get.unit = unit;
	async->args.cosq_classifier_id_get.classifier = classifier;
	async->args.cosq_classifier_id_get.array_count = array_count;
	async->args.cosq_classifier_id_get.priority_array = priority_array;
	async->args.cosq_classifier_id_get.cosq_array = cosq_array;
	async->args.cosq_classifier_id_get.classifier_id = classifier_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_mapping_clear_async(
	int unit,
	bcm_gport_t port,
	int classifier_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_MAPPING_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_mapping_clear.unit = unit;
	async->args.cosq_classifier_mapping_clear.port = port;
	async->args.cosq_classifier_mapping_clear.classifier_id = classifier_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_mapping_get_async(
	int unit,
	bcm_gport_t port,
	int classifier_id,
	bcm_gport_t * queue_group,
	bcm_cos_t priority,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_mapping_get.unit = unit;
	async->args.cosq_classifier_mapping_get.port = port;
	async->args.cosq_classifier_mapping_get.classifier_id = classifier_id;
	async->args.cosq_classifier_mapping_get.queue_group = queue_group;
	async->args.cosq_classifier_mapping_get.priority = priority;
	async->args.cosq_classifier_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_mapping_multi_get_async(
	int unit,
	bcm_gport_t port,
	int classifier_id,
	bcm_gport_t * queue_group,
	int array_max,
	bcm_cos_t * priority_array,
	bcm_cos_queue_t * cosq_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_MAPPING_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_mapping_multi_get.unit = unit;
	async->args.cosq_classifier_mapping_multi_get.port = port;
	async->args.cosq_classifier_mapping_multi_get.classifier_id = classifier_id;
	async->args.cosq_classifier_mapping_multi_get.queue_group = queue_group;
	async->args.cosq_classifier_mapping_multi_get.array_max = array_max;
	async->args.cosq_classifier_mapping_multi_get.priority_array = priority_array;
	async->args.cosq_classifier_mapping_multi_get.cosq_array = cosq_array;
	async->args.cosq_classifier_mapping_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_mapping_multi_set_async(
	int unit,
	bcm_gport_t port,
	int classifier_id,
	bcm_gport_t queue_group,
	int array_count,
	bcm_cos_t * priority_array,
	bcm_cos_queue_t * cosq_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_MAPPING_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_mapping_multi_set.unit = unit;
	async->args.cosq_classifier_mapping_multi_set.port = port;
	async->args.cosq_classifier_mapping_multi_set.classifier_id = classifier_id;
	async->args.cosq_classifier_mapping_multi_set.queue_group = queue_group;
	async->args.cosq_classifier_mapping_multi_set.array_count = array_count;
	async->args.cosq_classifier_mapping_multi_set.priority_array = priority_array;
	async->args.cosq_classifier_mapping_multi_set.cosq_array = cosq_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_classifier_mapping_set_async(
	int unit,
	bcm_gport_t port,
	int classifier_id,
	bcm_gport_t queue_group,
	bcm_cos_t priority,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CLASSIFIER_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_classifier_mapping_set.unit = unit;
	async->args.cosq_classifier_mapping_set.port = port;
	async->args.cosq_classifier_mapping_set.classifier_id = classifier_id;
	async->args.cosq_classifier_mapping_set.queue_group = queue_group;
	async->args.cosq_classifier_mapping_set.priority = priority;
	async->args.cosq_classifier_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_config_get_async(
	int unit,
	int * numq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_config_get.unit = unit;
	async->args.cosq_config_get.numq = numq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_config_set_async(
	int unit,
	int numq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_config_set.unit = unit;
	async->args.cosq_config_set.numq = numq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_congestion_mapping_get_async(
	int unit,
	int fabric_modid,
	bcm_cosq_congestion_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONGESTION_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_congestion_mapping_get.unit = unit;
	async->args.cosq_congestion_mapping_get.fabric_modid = fabric_modid;
	async->args.cosq_congestion_mapping_get.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_congestion_mapping_set_async(
	int unit,
	int fabric_modid,
	bcm_cosq_congestion_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONGESTION_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_congestion_mapping_set.unit = unit;
	async->args.cosq_congestion_mapping_set.fabric_modid = fabric_modid;
	async->args.cosq_congestion_mapping_set.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_extended_get_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_cosq_control_data_t * control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_EXTENDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_extended_get.unit = unit;
	async->args.cosq_control_extended_get.id = id;
	async->args.cosq_control_extended_get.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_extended_set_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_cosq_control_data_t * control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_EXTENDED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_extended_set.unit = unit;
	async->args.cosq_control_extended_set.id = id;
	async->args.cosq_control_extended_set.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_get.unit = unit;
	async->args.cosq_control_get.port = port;
	async->args.cosq_control_get.cosq = cosq;
	async->args.cosq_control_get.type = type;
	async->args.cosq_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_range_get_async(
	int unit,
	bcm_gport_t port,
	uint32 flags,
	bcm_cosq_control_range_type_t type,
	bcm_cosq_range_t * range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_range_get.unit = unit;
	async->args.cosq_control_range_get.port = port;
	async->args.cosq_control_range_get.flags = flags;
	async->args.cosq_control_range_get.type = type;
	async->args.cosq_control_range_get.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_range_set_async(
	int unit,
	bcm_gport_t port,
	uint32 flags,
	bcm_cosq_control_range_type_t type,
	bcm_cosq_range_t * range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_RANGE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_range_set.unit = unit;
	async->args.cosq_control_range_set.port = port;
	async->args.cosq_control_range_set.flags = flags;
	async->args.cosq_control_range_set.type = type;
	async->args.cosq_control_range_set.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_control_set_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_set.unit = unit;
	async->args.cosq_control_set.port = port;
	async->args.cosq_control_set.cosq = cosq;
	async->args.cosq_control_set.type = type;
	async->args.cosq_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_cpu_cosq_enable_get_async(
	int unit,
	bcm_cos_queue_t cosq,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CPU_COSQ_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_cpu_cosq_enable_get.unit = unit;
	async->args.cosq_cpu_cosq_enable_get.cosq = cosq;
	async->args.cosq_cpu_cosq_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_cpu_cosq_enable_set_async(
	int unit,
	bcm_cos_queue_t cosq,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_CPU_COSQ_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_cpu_cosq_enable_set.unit = unit;
	async->args.cosq_cpu_cosq_enable_set.cosq = cosq;
	async->args.cosq_cpu_cosq_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_delay_tolerance_level_get_async(
	int unit,
	int delay_tolerance_level,
	bcm_cosq_delay_tolerance_t * delay_tolerance,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DELAY_TOLERANCE_LEVEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_delay_tolerance_level_get.unit = unit;
	async->args.cosq_delay_tolerance_level_get.delay_tolerance_level = delay_tolerance_level;
	async->args.cosq_delay_tolerance_level_get.delay_tolerance = delay_tolerance;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_delay_tolerance_level_set_async(
	int unit,
	int delay_tolerance_level,
	bcm_cosq_delay_tolerance_t * delay_tolerance,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DELAY_TOLERANCE_LEVEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_delay_tolerance_level_set.unit = unit;
	async->args.cosq_delay_tolerance_level_set.delay_tolerance_level = delay_tolerance_level;
	async->args.cosq_delay_tolerance_level_set.delay_tolerance = delay_tolerance;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_dest_credit_size_get_async(
	int unit,
	bcm_module_t dest_modid,
	uint32 * credit_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DEST_CREDIT_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_dest_credit_size_get.unit = unit;
	async->args.cosq_dest_credit_size_get.dest_modid = dest_modid;
	async->args.cosq_dest_credit_size_get.credit_size = credit_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_dest_credit_size_set_async(
	int unit,
	bcm_module_t dest_modid,
	uint32 credit_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DEST_CREDIT_SIZE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_dest_credit_size_set.unit = unit;
	async->args.cosq_dest_credit_size_set.dest_modid = dest_modid;
	async->args.cosq_dest_credit_size_set.credit_size = credit_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_discard_get_async(
	int unit,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DISCARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_get.unit = unit;
	async->args.cosq_discard_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_discard_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_cos_queue_t cosq,
	uint32 color,
	int * drop_start,
	int * drop_slope,
	int * average_time,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DISCARD_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_port_get.unit = unit;
	async->args.cosq_discard_port_get.port = port;
	async->args.cosq_discard_port_get.cosq = cosq;
	async->args.cosq_discard_port_get.color = color;
	async->args.cosq_discard_port_get.drop_start = drop_start;
	async->args.cosq_discard_port_get.drop_slope = drop_slope;
	async->args.cosq_discard_port_get.average_time = average_time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_discard_port_set_async(
	int unit,
	bcm_port_t port,
	bcm_cos_queue_t cosq,
	uint32 color,
	int drop_start,
	int drop_slope,
	int average_time,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DISCARD_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_port_set.unit = unit;
	async->args.cosq_discard_port_set.port = port;
	async->args.cosq_discard_port_set.cosq = cosq;
	async->args.cosq_discard_port_set.color = color;
	async->args.cosq_discard_port_set.drop_start = drop_start;
	async->args.cosq_discard_port_set.drop_slope = drop_slope;
	async->args.cosq_discard_port_set.average_time = average_time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_discard_set_async(
	int unit,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_DISCARD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_set.unit = unit;
	async->args.cosq_discard_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_event_register_async(
	int unit,
	bcm_cosq_event_types_t event_types,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_event_register.unit = unit;
	async->args.cosq_event_register.event_types = event_types;
	async->args.cosq_event_register.port = port;
	async->args.cosq_event_register.cosq = cosq;
	async->args.cosq_event_register.cb = cb;
	async->args.cosq_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_event_unregister_async(
	int unit,
	bcm_cosq_event_types_t event_types,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_event_unregister.unit = unit;
	async->args.cosq_event_unregister.event_types = event_types;
	async->args.cosq_event_unregister.port = port;
	async->args.cosq_event_unregister.cosq = cosq;
	async->args.cosq_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_fabric_distribution_add_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	int num_cos_levels,
	uint32 flags,
	bcm_gport_t * req_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_FABRIC_DISTRIBUTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_fabric_distribution_add.unit = unit;
	async->args.cosq_fabric_distribution_add.ds_id = ds_id;
	async->args.cosq_fabric_distribution_add.num_cos_levels = num_cos_levels;
	async->args.cosq_fabric_distribution_add.flags = flags;
	async->args.cosq_fabric_distribution_add.req_gport = req_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_fabric_distribution_get_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	int * num_cos_levels,
	bcm_gport_t * req_gport,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_FABRIC_DISTRIBUTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_fabric_distribution_get.unit = unit;
	async->args.cosq_fabric_distribution_get.ds_id = ds_id;
	async->args.cosq_fabric_distribution_get.num_cos_levels = num_cos_levels;
	async->args.cosq_fabric_distribution_get.req_gport = req_gport;
	async->args.cosq_fabric_distribution_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_fc_path_add_async(
	int unit,
	bcm_cosq_fc_direction_type_t fc_direction,
	bcm_cosq_fc_endpoint_t * source,
	bcm_cosq_fc_endpoint_t * target,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_FC_PATH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_fc_path_add.unit = unit;
	async->args.cosq_fc_path_add.fc_direction = fc_direction;
	async->args.cosq_fc_path_add.source = source;
	async->args.cosq_fc_path_add.target = target;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_fc_path_delete_async(
	int unit,
	bcm_cosq_fc_direction_type_t fc_direction,
	bcm_cosq_fc_endpoint_t * source,
	bcm_cosq_fc_endpoint_t * target,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_FC_PATH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_fc_path_delete.unit = unit;
	async->args.cosq_fc_path_delete.fc_direction = fc_direction;
	async->args.cosq_fc_path_delete.source = source;
	async->args.cosq_fc_path_delete.target = target;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_fc_path_get_async(
	int unit,
	bcm_cosq_fc_direction_type_t fc_direction,
	bcm_cosq_fc_endpoint_t * source,
	int target_max,
	bcm_cosq_fc_endpoint_t * target,
	int * target_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_FC_PATH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_fc_path_get.unit = unit;
	async->args.cosq_fc_path_get.fc_direction = fc_direction;
	async->args.cosq_fc_path_get.source = source;
	async->args.cosq_fc_path_get.target_max = target_max;
	async->args.cosq_fc_path_get.target = target;
	async->args.cosq_fc_path_get.target_count = target_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_add_async(
	int unit,
	bcm_gport_t port,
	int numq,
	uint32 flags,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_add.unit = unit;
	async->args.cosq_gport_add.port = port;
	async->args.cosq_gport_add.numq = numq;
	async->args.cosq_gport_add.flags = flags;
	async->args.cosq_gport_add.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_attach_async(
	int unit,
	bcm_gport_t sched_port,
	bcm_gport_t input_port,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_attach.unit = unit;
	async->args.cosq_gport_attach.sched_port = sched_port;
	async->args.cosq_gport_attach.input_port = input_port;
	async->args.cosq_gport_attach.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_attach_get_async(
	int unit,
	bcm_gport_t sched_port,
	bcm_gport_t * input_port,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_attach_get.unit = unit;
	async->args.cosq_gport_attach_get.sched_port = sched_port;
	async->args.cosq_gport_attach_get.input_port = input_port;
	async->args.cosq_gport_attach_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_bandwidth_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 * kbits_sec_min,
	uint32 * kbits_sec_max,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_bandwidth_get.unit = unit;
	async->args.cosq_gport_bandwidth_get.gport = gport;
	async->args.cosq_gport_bandwidth_get.cosq = cosq;
	async->args.cosq_gport_bandwidth_get.kbits_sec_min = kbits_sec_min;
	async->args.cosq_gport_bandwidth_get.kbits_sec_max = kbits_sec_max;
	async->args.cosq_gport_bandwidth_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_bandwidth_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 kbits_sec_min,
	uint32 kbits_sec_max,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_bandwidth_set.unit = unit;
	async->args.cosq_gport_bandwidth_set.gport = gport;
	async->args.cosq_gport_bandwidth_set.cosq = cosq;
	async->args.cosq_gport_bandwidth_set.kbits_sec_min = kbits_sec_min;
	async->args.cosq_gport_bandwidth_set.kbits_sec_max = kbits_sec_max;
	async->args.cosq_gport_bandwidth_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_child_get_async(
	int unit,
	bcm_gport_t in_gport,
	bcm_cos_queue_t cosq,
	bcm_gport_t * out_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_CHILD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_child_get.unit = unit;
	async->args.cosq_gport_child_get.in_gport = in_gport;
	async->args.cosq_gport_child_get.cosq = cosq;
	async->args.cosq_gport_child_get.out_gport = out_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_color_size_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_color_t color,
	uint32 flags,
	bcm_cosq_gport_size_t * gport_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_COLOR_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_color_size_get.unit = unit;
	async->args.cosq_gport_color_size_get.gport = gport;
	async->args.cosq_gport_color_size_get.cosq = cosq;
	async->args.cosq_gport_color_size_get.color = color;
	async->args.cosq_gport_color_size_get.flags = flags;
	async->args.cosq_gport_color_size_get.gport_size = gport_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_color_size_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_color_t color,
	uint32 flags,
	bcm_cosq_gport_size_t * gport_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_COLOR_SIZE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_color_size_set.unit = unit;
	async->args.cosq_gport_color_size_set.gport = gport;
	async->args.cosq_gport_color_size_set.cosq = cosq;
	async->args.cosq_gport_color_size_set.color = color;
	async->args.cosq_gport_color_size_set.flags = flags;
	async->args.cosq_gport_color_size_set.gport_size = gport_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_congestion_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_congestion_info_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_CONGESTION_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_congestion_config_get.unit = unit;
	async->args.cosq_gport_congestion_config_get.gport = gport;
	async->args.cosq_gport_congestion_config_get.cosq = cosq;
	async->args.cosq_gport_congestion_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_congestion_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_congestion_info_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_CONGESTION_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_congestion_config_set.unit = unit;
	async->args.cosq_gport_congestion_config_set.gport = gport;
	async->args.cosq_gport_congestion_config_set.cosq = cosq;
	async->args.cosq_gport_congestion_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_connection_get_async(
	int unit,
	bcm_cosq_gport_connection_t * gport_connect,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_CONNECTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_connection_get.unit = unit;
	async->args.cosq_gport_connection_get.gport_connect = gport_connect;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_connection_set_async(
	int unit,
	bcm_cosq_gport_connection_t * gport_connect,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_CONNECTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_connection_set.unit = unit;
	async->args.cosq_gport_connection_set.gport_connect = gport_connect;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_delete_async(
	int unit,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_delete.unit = unit;
	async->args.cosq_gport_delete.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_destmod_attach_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_t ingress_port,
	bcm_module_t dest_modid,
	int fabric_egress_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DESTMOD_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_destmod_attach.unit = unit;
	async->args.cosq_gport_destmod_attach.gport = gport;
	async->args.cosq_gport_destmod_attach.ingress_port = ingress_port;
	async->args.cosq_gport_destmod_attach.dest_modid = dest_modid;
	async->args.cosq_gport_destmod_attach.fabric_egress_port = fabric_egress_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_destmod_detach_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_t ingress_port,
	bcm_module_t dest_modid,
	int fabric_egress_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DESTMOD_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_destmod_detach.unit = unit;
	async->args.cosq_gport_destmod_detach.gport = gport;
	async->args.cosq_gport_destmod_detach.ingress_port = ingress_port;
	async->args.cosq_gport_destmod_detach.dest_modid = dest_modid;
	async->args.cosq_gport_destmod_detach.fabric_egress_port = fabric_egress_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_detach_async(
	int unit,
	bcm_gport_t sched_port,
	bcm_gport_t input_port,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_detach.unit = unit;
	async->args.cosq_gport_detach.sched_port = sched_port;
	async->args.cosq_gport_detach.input_port = input_port;
	async->args.cosq_gport_detach.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_discard_extended_get_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_cosq_gport_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_EXTENDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_extended_get.unit = unit;
	async->args.cosq_gport_discard_extended_get.id = id;
	async->args.cosq_gport_discard_extended_get.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_discard_extended_set_async(
	int unit,
	bcm_cosq_object_id_t * id,
	bcm_cosq_gport_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_EXTENDED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_extended_set.unit = unit;
	async->args.cosq_gport_discard_extended_set.id = id;
	async->args.cosq_gport_discard_extended_set.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_discard_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_gport_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_get.unit = unit;
	async->args.cosq_gport_discard_get.gport = gport;
	async->args.cosq_gport_discard_get.cosq = cosq;
	async->args.cosq_gport_discard_get.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_discard_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_gport_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_set.unit = unit;
	async->args.cosq_gport_discard_set.gport = gport;
	async->args.cosq_gport_discard_set.cosq = cosq;
	async->args.cosq_gport_discard_set.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_dynamic_sched_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_dynamic_state_t state,
	int * weight,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DYNAMIC_SCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_dynamic_sched_get.unit = unit;
	async->args.cosq_gport_dynamic_sched_get.gport = gport;
	async->args.cosq_gport_dynamic_sched_get.cosq = cosq;
	async->args.cosq_gport_dynamic_sched_get.state = state;
	async->args.cosq_gport_dynamic_sched_get.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_dynamic_sched_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_dynamic_state_t state,
	int weight,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_DYNAMIC_SCHED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_dynamic_sched_set.unit = unit;
	async->args.cosq_gport_dynamic_sched_set.gport = gport;
	async->args.cosq_gport_dynamic_sched_set.cosq = cosq;
	async->args.cosq_gport_dynamic_sched_set.state = state;
	async->args.cosq_gport_dynamic_sched_set.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_map_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t ingress_pri,
	bcm_color_t ingress_dp,
	bcm_cos_queue_t * offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_map_get.unit = unit;
	async->args.cosq_gport_egress_map_get.gport = gport;
	async->args.cosq_gport_egress_map_get.ingress_pri = ingress_pri;
	async->args.cosq_gport_egress_map_get.ingress_dp = ingress_dp;
	async->args.cosq_gport_egress_map_get.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_map_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t ingress_pri,
	bcm_color_t ingress_dp,
	bcm_cos_queue_t offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_map_set.unit = unit;
	async->args.cosq_gport_egress_map_set.gport = gport;
	async->args.cosq_gport_egress_map_set.ingress_pri = ingress_pri;
	async->args.cosq_gport_egress_map_set.ingress_dp = ingress_dp;
	async->args.cosq_gport_egress_map_set.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_mapping_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t * int_pri,
	bcm_cos_t * cos,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_mapping_get.unit = unit;
	async->args.cosq_gport_egress_mapping_get.gport = gport;
	async->args.cosq_gport_egress_mapping_get.int_pri = int_pri;
	async->args.cosq_gport_egress_mapping_get.cos = cos;
	async->args.cosq_gport_egress_mapping_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_mapping_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t int_pri,
	bcm_cos_t cos,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_mapping_set.unit = unit;
	async->args.cosq_gport_egress_mapping_set.gport = gport;
	async->args.cosq_gport_egress_mapping_set.int_pri = int_pri;
	async->args.cosq_gport_egress_mapping_set.cos = cos;
	async->args.cosq_gport_egress_mapping_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_multicast_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t ingress_pri,
	bcm_color_t ingress_dp,
	uint32 flags,
	bcm_cosq_egress_multicast_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MULTICAST_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_multicast_config_get.unit = unit;
	async->args.cosq_gport_egress_multicast_config_get.gport = gport;
	async->args.cosq_gport_egress_multicast_config_get.ingress_pri = ingress_pri;
	async->args.cosq_gport_egress_multicast_config_get.ingress_dp = ingress_dp;
	async->args.cosq_gport_egress_multicast_config_get.flags = flags;
	async->args.cosq_gport_egress_multicast_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_egress_multicast_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_t ingress_pri,
	bcm_color_t ingress_dp,
	uint32 flags,
	bcm_cosq_egress_multicast_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_EGRESS_MULTICAST_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_egress_multicast_config_set.unit = unit;
	async->args.cosq_gport_egress_multicast_config_set.gport = gport;
	async->args.cosq_gport_egress_multicast_config_set.ingress_pri = ingress_pri;
	async->args.cosq_gport_egress_multicast_config_set.ingress_dp = ingress_dp;
	async->args.cosq_gport_egress_multicast_config_set.flags = flags;
	async->args.cosq_gport_egress_multicast_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_enable_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_enable_get.unit = unit;
	async->args.cosq_gport_enable_get.gport = gport;
	async->args.cosq_gport_enable_get.cosq = cosq;
	async->args.cosq_gport_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_enable_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_enable_set.unit = unit;
	async->args.cosq_gport_enable_set.gport = gport;
	async->args.cosq_gport_enable_set.cosq = cosq;
	async->args.cosq_gport_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_fadt_threshold_get_async(
	int unit,
	uint32 flags,
	bcm_cosq_fadt_info_t * fadt_info,
	bcm_cosq_fadt_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_FADT_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_fadt_threshold_get.unit = unit;
	async->args.cosq_gport_fadt_threshold_get.flags = flags;
	async->args.cosq_gport_fadt_threshold_get.fadt_info = fadt_info;
	async->args.cosq_gport_fadt_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_fadt_threshold_set_async(
	int unit,
	uint32 flags,
	bcm_cosq_fadt_info_t * fadt_info,
	bcm_cosq_fadt_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_FADT_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_fadt_threshold_set.unit = unit;
	async->args.cosq_gport_fadt_threshold_set.flags = flags;
	async->args.cosq_gport_fadt_threshold_set.fadt_info = fadt_info;
	async->args.cosq_gport_fadt_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_flow_control_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_t int_pri,
	uint32 * flow_control_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_FLOW_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_flow_control_get.unit = unit;
	async->args.cosq_gport_flow_control_get.port = port;
	async->args.cosq_gport_flow_control_get.int_pri = int_pri;
	async->args.cosq_gport_flow_control_get.flow_control_mask = flow_control_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_flow_control_set_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_t int_pri,
	uint32 flow_control_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_FLOW_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_flow_control_set.unit = unit;
	async->args.cosq_gport_flow_control_set.port = port;
	async->args.cosq_gport_flow_control_set.int_pri = int_pri;
	async->args.cosq_gport_flow_control_set.flow_control_mask = flow_control_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t * physical_port,
	int * num_cos_levels,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_get.unit = unit;
	async->args.cosq_gport_get.gport = gport;
	async->args.cosq_gport_get.physical_port = physical_port;
	async->args.cosq_gport_get.num_cos_levels = num_cos_levels;
	async->args.cosq_gport_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_handle_core_get_async(
	int unit,
	bcm_core_t core,
	bcm_cosq_gport_info_core_t * gport_info,
	bcm_gport_t * out_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_HANDLE_CORE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_handle_core_get.unit = unit;
	async->args.cosq_gport_handle_core_get.core = core;
	async->args.cosq_gport_handle_core_get.gport_info = gport_info;
	async->args.cosq_gport_handle_core_get.out_gport = out_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_handle_get_async(
	int unit,
	bcm_cosq_gport_type_t gport_type,
	bcm_cosq_gport_info_t * gport_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_HANDLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_handle_get.unit = unit;
	async->args.cosq_gport_handle_get.gport_type = gport_type;
	async->args.cosq_gport_handle_get.gport_info = gport_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_mapping_get_async(
	int unit,
	bcm_port_t ing_port,
	bcm_cos_t int_pri,
	uint32 flags,
	bcm_gport_t * gport,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_mapping_get.unit = unit;
	async->args.cosq_gport_mapping_get.ing_port = ing_port;
	async->args.cosq_gport_mapping_get.int_pri = int_pri;
	async->args.cosq_gport_mapping_get.flags = flags;
	async->args.cosq_gport_mapping_get.gport = gport;
	async->args.cosq_gport_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_mapping_set_async(
	int unit,
	bcm_port_t ing_port,
	bcm_cos_t int_pri,
	uint32 flags,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_mapping_set.unit = unit;
	async->args.cosq_gport_mapping_set.ing_port = ing_port;
	async->args.cosq_gport_mapping_set.int_pri = int_pri;
	async->args.cosq_gport_mapping_set.flags = flags;
	async->args.cosq_gport_mapping_set.gport = gport;
	async->args.cosq_gport_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_multipath_add_async(
	int unit,
	bcm_gport_t multipath_gport,
	bcm_gport_t member_gport,
	bcm_cos_queue_t member_gport_cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_MULTIPATH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_multipath_add.unit = unit;
	async->args.cosq_gport_multipath_add.multipath_gport = multipath_gport;
	async->args.cosq_gport_multipath_add.member_gport = member_gport;
	async->args.cosq_gport_multipath_add.member_gport_cosq = member_gport_cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_multipath_delete_async(
	int unit,
	bcm_gport_t multipath_gport,
	bcm_gport_t member_gport,
	bcm_cos_queue_t member_gport_cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_MULTIPATH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_multipath_delete.unit = unit;
	async->args.cosq_gport_multipath_delete.multipath_gport = multipath_gport;
	async->args.cosq_gport_multipath_delete.member_gport = member_gport;
	async->args.cosq_gport_multipath_delete.member_gport_cosq = member_gport_cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_multipath_get_async(
	int unit,
	bcm_gport_t multipath_gport,
	int member_gport_max,
	bcm_gport_t * member_gport_array,
	bcm_cos_queue_t * member_gport_cosq_array,
	int * member_gport_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_MULTIPATH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_multipath_get.unit = unit;
	async->args.cosq_gport_multipath_get.multipath_gport = multipath_gport;
	async->args.cosq_gport_multipath_get.member_gport_max = member_gport_max;
	async->args.cosq_gport_multipath_get.member_gport_array = member_gport_array;
	async->args.cosq_gport_multipath_get.member_gport_cosq_array = member_gport_cosq_array;
	async->args.cosq_gport_multipath_get.member_gport_count = member_gport_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_parent_get_async(
	int unit,
	bcm_gport_t child_port,
	bcm_cos_queue_t cos,
	bcm_gport_t * parent_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_PARENT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_parent_get.unit = unit;
	async->args.cosq_gport_parent_get.child_port = child_port;
	async->args.cosq_gport_parent_get.cos = cos;
	async->args.cosq_gport_parent_get.parent_port = parent_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_pkt_size_adjust_get_async(
	int unit,
	bcm_cosq_pkt_size_adjust_info_t * adjust_info,
	int * delta,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_PKT_SIZE_ADJUST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_pkt_size_adjust_get.unit = unit;
	async->args.cosq_gport_pkt_size_adjust_get.adjust_info = adjust_info;
	async->args.cosq_gport_pkt_size_adjust_get.delta = delta;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_pkt_size_adjust_set_async(
	int unit,
	bcm_cosq_pkt_size_adjust_info_t * adjust_info,
	int delta,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_PKT_SIZE_ADJUST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_pkt_size_adjust_set.unit = unit;
	async->args.cosq_gport_pkt_size_adjust_set.adjust_info = adjust_info;
	async->args.cosq_gport_pkt_size_adjust_set.delta = delta;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_pon_link_sla_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_pon_link_sla_t * link_sla,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_PON_LINK_SLA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_pon_link_sla_get.unit = unit;
	async->args.cosq_gport_pon_link_sla_get.gport = gport;
	async->args.cosq_gport_pon_link_sla_get.link_sla = link_sla;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_pon_link_sla_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_pon_link_sla_t * link_sla,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_PON_LINK_SLA_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_pon_link_sla_set.unit = unit;
	async->args.cosq_gport_pon_link_sla_set.gport = gport;
	async->args.cosq_gport_pon_link_sla_set.link_sla = link_sla;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_queue_attach_async(
	int unit,
	uint32 flags,
	bcm_gport_t ingress_queue,
	bcm_cos_t ingress_int_pri,
	bcm_gport_t egress_queue,
	bcm_cos_t egress_int_pri,
	int * attach_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_QUEUE_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_queue_attach.unit = unit;
	async->args.cosq_gport_queue_attach.flags = flags;
	async->args.cosq_gport_queue_attach.ingress_queue = ingress_queue;
	async->args.cosq_gport_queue_attach.ingress_int_pri = ingress_int_pri;
	async->args.cosq_gport_queue_attach.egress_queue = egress_queue;
	async->args.cosq_gport_queue_attach.egress_int_pri = egress_int_pri;
	async->args.cosq_gport_queue_attach.attach_id = attach_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_queue_attach_get_async(
	int unit,
	bcm_gport_t ingress_queue,
	bcm_cos_t ingress_int_pri,
	bcm_gport_t * egress_queue,
	bcm_cos_t * egress_int_pri,
	int attach_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_QUEUE_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_queue_attach_get.unit = unit;
	async->args.cosq_gport_queue_attach_get.ingress_queue = ingress_queue;
	async->args.cosq_gport_queue_attach_get.ingress_int_pri = ingress_int_pri;
	async->args.cosq_gport_queue_attach_get.egress_queue = egress_queue;
	async->args.cosq_gport_queue_attach_get.egress_int_pri = egress_int_pri;
	async->args.cosq_gport_queue_attach_get.attach_id = attach_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_queue_detach_async(
	int unit,
	bcm_gport_t ingress_queue,
	bcm_cos_t ingress_int_pri,
	int attach_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_QUEUE_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_queue_detach.unit = unit;
	async->args.cosq_gport_queue_detach.ingress_queue = ingress_queue;
	async->args.cosq_gport_queue_detach.ingress_int_pri = ingress_int_pri;
	async->args.cosq_gport_queue_detach.attach_id = attach_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_reattach_async(
	int unit,
	bcm_gport_t sched_port,
	bcm_gport_t input_port,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_REATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_reattach.unit = unit;
	async->args.cosq_gport_reattach.sched_port = sched_port;
	async->args.cosq_gport_reattach.input_port = input_port;
	async->args.cosq_gport_reattach.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_report_threshold_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_report_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_REPORT_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_report_threshold_get.unit = unit;
	async->args.cosq_gport_report_threshold_get.gport = gport;
	async->args.cosq_gport_report_threshold_get.cosq = cosq;
	async->args.cosq_gport_report_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_report_threshold_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_report_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_REPORT_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_report_threshold_set.unit = unit;
	async->args.cosq_gport_report_threshold_set.gport = gport;
	async->args.cosq_gport_report_threshold_set.cosq = cosq;
	async->args.cosq_gport_report_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_sched_config_get_async(
	int unit,
	bcm_gport_t gport,
	int sched_mode,
	int int_pri,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_config_get.unit = unit;
	async->args.cosq_gport_sched_config_get.gport = gport;
	async->args.cosq_gport_sched_config_get.sched_mode = sched_mode;
	async->args.cosq_gport_sched_config_get.int_pri = int_pri;
	async->args.cosq_gport_sched_config_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_sched_config_set_async(
	int unit,
	bcm_gport_t gport,
	int sched_mode,
	int int_pri,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_config_set.unit = unit;
	async->args.cosq_gport_sched_config_set.gport = gport;
	async->args.cosq_gport_sched_config_set.sched_mode = sched_mode;
	async->args.cosq_gport_sched_config_set.int_pri = int_pri;
	async->args.cosq_gport_sched_config_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_sched_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int * mode,
	int * weight,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_get.unit = unit;
	async->args.cosq_gport_sched_get.gport = gport;
	async->args.cosq_gport_sched_get.cosq = cosq;
	async->args.cosq_gport_sched_get.mode = mode;
	async->args.cosq_gport_sched_get.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_sched_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int mode,
	int weight,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_set.unit = unit;
	async->args.cosq_gport_sched_set.gport = gport;
	async->args.cosq_gport_sched_set.cosq = cosq;
	async->args.cosq_gport_sched_set.mode = mode;
	async->args.cosq_gport_sched_set.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_size_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 * bytes_min,
	uint32 * bytes_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_size_get.unit = unit;
	async->args.cosq_gport_size_get.gport = gport;
	async->args.cosq_gport_size_get.cosq = cosq;
	async->args.cosq_gport_size_get.bytes_min = bytes_min;
	async->args.cosq_gport_size_get.bytes_max = bytes_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_size_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 bytes_min,
	uint32 bytes_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_SIZE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_size_set.unit = unit;
	async->args.cosq_gport_size_set.gport = gport;
	async->args.cosq_gport_size_set.cosq = cosq;
	async->args.cosq_gport_size_set.bytes_min = bytes_min;
	async->args.cosq_gport_size_set.bytes_max = bytes_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_gport_stat_profile_t * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_config_get.unit = unit;
	async->args.cosq_gport_stat_config_get.gport = gport;
	async->args.cosq_gport_stat_config_get.lgl_gport = lgl_gport;
	async->args.cosq_gport_stat_config_get.cosq = cosq;
	async->args.cosq_gport_stat_config_get.flags = flags;
	async->args.cosq_gport_stat_config_get.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_gport_stat_profile_t profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_config_set.unit = unit;
	async->args.cosq_gport_stat_config_set.gport = gport;
	async->args.cosq_gport_stat_config_set.lgl_gport = lgl_gport;
	async->args.cosq_gport_stat_config_set.cosq = cosq;
	async->args.cosq_gport_stat_config_set.flags = flags;
	async->args.cosq_gport_stat_config_set.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_enable_get_async(
	int unit,
	bcm_gport_t gport,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_enable_get.unit = unit;
	async->args.cosq_gport_stat_enable_get.gport = gport;
	async->args.cosq_gport_stat_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_enable_set_async(
	int unit,
	bcm_gport_t gport,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_enable_set.unit = unit;
	async->args.cosq_gport_stat_enable_set.gport = gport;
	async->args.cosq_gport_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_gport_stats_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_get.unit = unit;
	async->args.cosq_gport_stat_get.gport = gport;
	async->args.cosq_gport_stat_get.cosq = cosq;
	async->args.cosq_gport_stat_get.stat = stat;
	async->args.cosq_gport_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_gport_stats_t stat,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_set.unit = unit;
	async->args.cosq_gport_stat_set.gport = gport;
	async->args.cosq_gport_stat_set.cosq = cosq;
	async->args.cosq_gport_stat_set.stat = stat;
	async->args.cosq_gport_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_stat_sync_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_gport_stats_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_stat_sync_get.unit = unit;
	async->args.cosq_gport_stat_sync_get.gport = gport;
	async->args.cosq_gport_stat_sync_get.cosq = cosq;
	async->args.cosq_gport_stat_sync_get.stat = stat;
	async->args.cosq_gport_stat_sync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_statistic_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_gport_stats_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_statistic_get.unit = unit;
	async->args.cosq_gport_statistic_get.gport = gport;
	async->args.cosq_gport_statistic_get.lgl_gport = lgl_gport;
	async->args.cosq_gport_statistic_get.cosq = cosq;
	async->args.cosq_gport_statistic_get.flags = flags;
	async->args.cosq_gport_statistic_get.stat = stat;
	async->args.cosq_gport_statistic_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_statistic_multi_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	int stat_count,
	bcm_cosq_gport_stats_t * stats_array,
	int value_count,
	uint64 * value_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_statistic_multi_get.unit = unit;
	async->args.cosq_gport_statistic_multi_get.gport = gport;
	async->args.cosq_gport_statistic_multi_get.lgl_gport = lgl_gport;
	async->args.cosq_gport_statistic_multi_get.cosq = cosq;
	async->args.cosq_gport_statistic_multi_get.stat_count = stat_count;
	async->args.cosq_gport_statistic_multi_get.stats_array = stats_array;
	async->args.cosq_gport_statistic_multi_get.value_count = value_count;
	async->args.cosq_gport_statistic_multi_get.value_array = value_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_statistic_multi_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	int stat_count,
	bcm_cosq_gport_stats_t * stats_array,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_statistic_multi_set.unit = unit;
	async->args.cosq_gport_statistic_multi_set.gport = gport;
	async->args.cosq_gport_statistic_multi_set.lgl_gport = lgl_gport;
	async->args.cosq_gport_statistic_multi_set.cosq = cosq;
	async->args.cosq_gport_statistic_multi_set.stat_count = stat_count;
	async->args.cosq_gport_statistic_multi_set.stats_array = stats_array;
	async->args.cosq_gport_statistic_multi_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_statistic_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t lgl_gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_gport_stats_t stat,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_statistic_set.unit = unit;
	async->args.cosq_gport_statistic_set.gport = gport;
	async->args.cosq_gport_statistic_set.lgl_gport = lgl_gport;
	async->args.cosq_gport_statistic_set.cosq = cosq;
	async->args.cosq_gport_statistic_set.flags = flags;
	async->args.cosq_gport_statistic_set.stat = stat;
	async->args.cosq_gport_statistic_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_threshold_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_threshold_get.unit = unit;
	async->args.cosq_gport_threshold_get.gport = gport;
	async->args.cosq_gport_threshold_get.cosq = cosq;
	async->args.cosq_gport_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_threshold_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_threshold_set.unit = unit;
	async->args.cosq_gport_threshold_set.gport = gport;
	async->args.cosq_gport_threshold_set.cosq = cosq;
	async->args.cosq_gport_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_traverse_async(
	int unit,
	bcm_cosq_gport_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_traverse.unit = unit;
	async->args.cosq_gport_traverse.cb = cb;
	async->args.cosq_gport_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_add_async(
	int unit,
	bcm_gport_t vsq,
	bcm_gport_t queue,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_add.unit = unit;
	async->args.cosq_gport_vsq_add.vsq = vsq;
	async->args.cosq_gport_vsq_add.queue = queue;
	async->args.cosq_gport_vsq_add.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_create_async(
	int unit,
	bcm_cosq_vsq_info_t * vsq_info,
	bcm_gport_t * vsq_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_create.unit = unit;
	async->args.cosq_gport_vsq_create.vsq_info = vsq_info;
	async->args.cosq_gport_vsq_create.vsq_gport = vsq_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_delete_async(
	int unit,
	bcm_gport_t vsq,
	bcm_gport_t queue,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_delete.unit = unit;
	async->args.cosq_gport_vsq_delete.vsq = vsq;
	async->args.cosq_gport_vsq_delete.queue = queue;
	async->args.cosq_gport_vsq_delete.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_delete_all_async(
	int unit,
	bcm_gport_t vsq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_delete_all.unit = unit;
	async->args.cosq_gport_vsq_delete_all.vsq = vsq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_destroy_async(
	int unit,
	bcm_gport_t vsq_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_destroy.unit = unit;
	async->args.cosq_gport_vsq_destroy.vsq_gport = vsq_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_gport_vsq_get_async(
	int unit,
	bcm_gport_t vsq,
	int queue_max,
	bcm_gport_t * queue_array,
	bcm_cos_queue_t * cosq_array,
	int * queue_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_GPORT_VSQ_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_vsq_get.unit = unit;
	async->args.cosq_gport_vsq_get.vsq = vsq;
	async->args.cosq_gport_vsq_get.queue_max = queue_max;
	async->args.cosq_gport_vsq_get.queue_array = queue_array;
	async->args.cosq_gport_vsq_get.cosq_array = cosq_array;
	async->args.cosq_gport_vsq_get.queue_count = queue_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_icgm_resource_stat_get_async(
	int unit,
	bcm_cosq_icgm_resource_stat_key_t * stat_key,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_ICGM_RESOURCE_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_icgm_resource_stat_get.unit = unit;
	async->args.cosq_icgm_resource_stat_get.stat_key = stat_key;
	async->args.cosq_icgm_resource_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_control_frame_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_CONTROL_FRAME_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_control_frame_get.unit = unit;
	async->args.cosq_ingress_port_drop_control_frame_get.port = port;
	async->args.cosq_ingress_port_drop_control_frame_get.flags = flags;
	async->args.cosq_ingress_port_drop_control_frame_get.control_frame_config = control_frame_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_control_frame_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_CONTROL_FRAME_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_control_frame_set.unit = unit;
	async->args.cosq_ingress_port_drop_control_frame_set.port = port;
	async->args.cosq_ingress_port_drop_control_frame_set.flags = flags;
	async->args.cosq_ingress_port_drop_control_frame_set.control_frame_config = control_frame_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_custom_ether_type_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 ether_type_code,
	uint32 * ether_type_val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_CUSTOM_ETHER_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_custom_ether_type_get.unit = unit;
	async->args.cosq_ingress_port_drop_custom_ether_type_get.port = port;
	async->args.cosq_ingress_port_drop_custom_ether_type_get.flags = flags;
	async->args.cosq_ingress_port_drop_custom_ether_type_get.ether_type_code = ether_type_code;
	async->args.cosq_ingress_port_drop_custom_ether_type_get.ether_type_val = ether_type_val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_custom_ether_type_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 ether_type_code,
	uint32 ether_type_val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_CUSTOM_ETHER_TYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_custom_ether_type_set.unit = unit;
	async->args.cosq_ingress_port_drop_custom_ether_type_set.port = port;
	async->args.cosq_ingress_port_drop_custom_ether_type_set.flags = flags;
	async->args.cosq_ingress_port_drop_custom_ether_type_set.ether_type_code = ether_type_code;
	async->args.cosq_ingress_port_drop_custom_ether_type_set.ether_type_val = ether_type_val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_default_priority_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 * default_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_DEFAULT_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_default_priority_get.unit = unit;
	async->args.cosq_ingress_port_drop_default_priority_get.port = port;
	async->args.cosq_ingress_port_drop_default_priority_get.flags = flags;
	async->args.cosq_ingress_port_drop_default_priority_get.default_priority = default_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_default_priority_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 default_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_DEFAULT_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_default_priority_set.unit = unit;
	async->args.cosq_ingress_port_drop_default_priority_set.port = port;
	async->args.cosq_ingress_port_drop_default_priority_set.flags = flags;
	async->args.cosq_ingress_port_drop_default_priority_set.default_priority = default_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_enable_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int * enable_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_enable_get.unit = unit;
	async->args.cosq_ingress_port_drop_enable_get.port = port;
	async->args.cosq_ingress_port_drop_enable_get.flags = flags;
	async->args.cosq_ingress_port_drop_enable_get.enable_mode = enable_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_enable_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int enable_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_enable_set.unit = unit;
	async->args.cosq_ingress_port_drop_enable_set.port = port;
	async->args.cosq_ingress_port_drop_enable_set.flags = flags;
	async->args.cosq_ingress_port_drop_enable_set.enable_mode = enable_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_flex_key_construct_get_async(
	int unit,
	bcm_cosq_ingress_drop_flex_key_construct_id_t * key_id,
	uint32 flags,
	bcm_cosq_ingress_drop_flex_key_construct_t * flex_key_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_FLEX_KEY_CONSTRUCT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_flex_key_construct_get.unit = unit;
	async->args.cosq_ingress_port_drop_flex_key_construct_get.key_id = key_id;
	async->args.cosq_ingress_port_drop_flex_key_construct_get.flags = flags;
	async->args.cosq_ingress_port_drop_flex_key_construct_get.flex_key_config = flex_key_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_flex_key_construct_set_async(
	int unit,
	bcm_cosq_ingress_drop_flex_key_construct_id_t * key_id,
	uint32 flags,
	bcm_cosq_ingress_drop_flex_key_construct_t * flex_key_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_FLEX_KEY_CONSTRUCT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_flex_key_construct_set.unit = unit;
	async->args.cosq_ingress_port_drop_flex_key_construct_set.key_id = key_id;
	async->args.cosq_ingress_port_drop_flex_key_construct_set.flags = flags;
	async->args.cosq_ingress_port_drop_flex_key_construct_set.flex_key_config = flex_key_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_flex_key_entry_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 key_index,
	bcm_cosq_ingress_drop_flex_key_entry_t * flex_key_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_FLEX_KEY_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_flex_key_entry_get.unit = unit;
	async->args.cosq_ingress_port_drop_flex_key_entry_get.port = port;
	async->args.cosq_ingress_port_drop_flex_key_entry_get.flags = flags;
	async->args.cosq_ingress_port_drop_flex_key_entry_get.key_index = key_index;
	async->args.cosq_ingress_port_drop_flex_key_entry_get.flex_key_info = flex_key_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_flex_key_entry_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 key_index,
	bcm_cosq_ingress_drop_flex_key_entry_t * flex_key_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_FLEX_KEY_ENTRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_flex_key_entry_set.unit = unit;
	async->args.cosq_ingress_port_drop_flex_key_entry_set.port = port;
	async->args.cosq_ingress_port_drop_flex_key_entry_set.flags = flags;
	async->args.cosq_ingress_port_drop_flex_key_entry_set.key_index = key_index;
	async->args.cosq_ingress_port_drop_flex_key_entry_set.flex_key_info = flex_key_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_map_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_cosq_ingress_port_drop_map_t map,
	uint32 key,
	int * priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_map_get.unit = unit;
	async->args.cosq_ingress_port_drop_map_get.port = port;
	async->args.cosq_ingress_port_drop_map_get.flags = flags;
	async->args.cosq_ingress_port_drop_map_get.map = map;
	async->args.cosq_ingress_port_drop_map_get.key = key;
	async->args.cosq_ingress_port_drop_map_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_map_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_cosq_ingress_port_drop_map_t map,
	uint32 key,
	int priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_map_set.unit = unit;
	async->args.cosq_ingress_port_drop_map_set.port = port;
	async->args.cosq_ingress_port_drop_map_set.flags = flags;
	async->args.cosq_ingress_port_drop_map_set.map = map;
	async->args.cosq_ingress_port_drop_map_set.key = key;
	async->args.cosq_ingress_port_drop_map_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_threshold_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int priority,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_threshold_get.unit = unit;
	async->args.cosq_ingress_port_drop_threshold_get.port = port;
	async->args.cosq_ingress_port_drop_threshold_get.flags = flags;
	async->args.cosq_ingress_port_drop_threshold_get.priority = priority;
	async->args.cosq_ingress_port_drop_threshold_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_port_drop_threshold_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int priority,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_PORT_DROP_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_port_drop_threshold_set.unit = unit;
	async->args.cosq_ingress_port_drop_threshold_set.port = port;
	async->args.cosq_ingress_port_drop_threshold_set.flags = flags;
	async->args.cosq_ingress_port_drop_threshold_set.priority = priority;
	async->args.cosq_ingress_port_drop_threshold_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_ingress_queue_bundle_gport_add_async(
	int unit,
	bcm_cosq_ingress_queue_bundle_gport_config_t * config,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INGRESS_QUEUE_BUNDLE_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_ingress_queue_bundle_gport_add.unit = unit;
	async->args.cosq_ingress_queue_bundle_gport_add.config = config;
	async->args.cosq_ingress_queue_bundle_gport_add.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_mapping_get_async(
	int unit,
	bcm_cos_t priority,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_mapping_get.unit = unit;
	async->args.cosq_mapping_get.priority = priority;
	async->args.cosq_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_mapping_set_async(
	int unit,
	bcm_cos_t priority,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_mapping_set.unit = unit;
	async->args.cosq_mapping_set.priority = priority;
	async->args.cosq_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_max_latency_pkts_get_async(
	int unit,
	bcm_gport_t gport,
	uint32 flags,
	int max_count,
	bcm_cosq_max_latency_pkts_t * max_latency_pkts,
	int * actual_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_MAX_LATENCY_PKTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_max_latency_pkts_get.unit = unit;
	async->args.cosq_max_latency_pkts_get.gport = gport;
	async->args.cosq_max_latency_pkts_get.flags = flags;
	async->args.cosq_max_latency_pkts_get.max_count = max_count;
	async->args.cosq_max_latency_pkts_get.max_latency_pkts = max_latency_pkts;
	async->args.cosq_max_latency_pkts_get.actual_count = actual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_class_mapping_get_async(
	int unit,
	bcm_gport_t port,
	int array_max,
	bcm_cosq_pfc_class_mapping_t * mapping_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_CLASS_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_class_mapping_get.unit = unit;
	async->args.cosq_pfc_class_mapping_get.port = port;
	async->args.cosq_pfc_class_mapping_get.array_max = array_max;
	async->args.cosq_pfc_class_mapping_get.mapping_array = mapping_array;
	async->args.cosq_pfc_class_mapping_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_class_mapping_set_async(
	int unit,
	bcm_gport_t port,
	int array_count,
	bcm_cosq_pfc_class_mapping_t * mapping_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_CLASS_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_class_mapping_set.unit = unit;
	async->args.cosq_pfc_class_mapping_set.port = port;
	async->args.cosq_pfc_class_mapping_set.array_count = array_count;
	async->args.cosq_pfc_class_mapping_set.mapping_array = mapping_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_pfc_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_config_get.unit = unit;
	async->args.cosq_pfc_config_get.gport = gport;
	async->args.cosq_pfc_config_get.cosq = cosq;
	async->args.cosq_pfc_config_get.flags = flags;
	async->args.cosq_pfc_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_pfc_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_config_set.unit = unit;
	async->args.cosq_pfc_config_set.gport = gport;
	async->args.cosq_pfc_config_set.cosq = cosq;
	async->args.cosq_pfc_config_set.flags = flags;
	async->args.cosq_pfc_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_config_get_async(
	int unit,
	int priority,
	bcm_cosq_pfc_deadlock_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_config_get.unit = unit;
	async->args.cosq_pfc_deadlock_config_get.priority = priority;
	async->args.cosq_pfc_deadlock_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_config_set_async(
	int unit,
	int priority,
	bcm_cosq_pfc_deadlock_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_config_set.unit = unit;
	async->args.cosq_pfc_deadlock_config_set.priority = priority;
	async->args.cosq_pfc_deadlock_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_info_get_async(
	int unit,
	int priority,
	bcm_cosq_pfc_deadlock_info_t * pfc_deadlock_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_info_get.unit = unit;
	async->args.cosq_pfc_deadlock_info_get.priority = priority;
	async->args.cosq_pfc_deadlock_info_get.pfc_deadlock_info = pfc_deadlock_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_queue_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cosq_pfc_deadlock_queue_config_t * q_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_QUEUE_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_queue_config_get.unit = unit;
	async->args.cosq_pfc_deadlock_queue_config_get.gport = gport;
	async->args.cosq_pfc_deadlock_queue_config_get.q_config = q_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_queue_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cosq_pfc_deadlock_queue_config_t * q_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_QUEUE_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_queue_config_set.unit = unit;
	async->args.cosq_pfc_deadlock_queue_config_set.gport = gport;
	async->args.cosq_pfc_deadlock_queue_config_set.q_config = q_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_queue_status_get_async(
	int unit,
	bcm_gport_t gport,
	uint8 * deadlock_status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_QUEUE_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_queue_status_get.unit = unit;
	async->args.cosq_pfc_deadlock_queue_status_get.gport = gport;
	async->args.cosq_pfc_deadlock_queue_status_get.deadlock_status = deadlock_status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_recovery_event_register_async(
	int unit,
	bcm_cosq_pfc_deadlock_recovery_event_cb_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_RECOVERY_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_recovery_event_register.unit = unit;
	async->args.cosq_pfc_deadlock_recovery_event_register.callback = callback;
	async->args.cosq_pfc_deadlock_recovery_event_register.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pfc_deadlock_recovery_event_unregister_async(
	int unit,
	bcm_cosq_pfc_deadlock_recovery_event_cb_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PFC_DEADLOCK_RECOVERY_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pfc_deadlock_recovery_event_unregister.unit = unit;
	async->args.cosq_pfc_deadlock_recovery_event_unregister.callback = callback;
	async->args.cosq_pfc_deadlock_recovery_event_unregister.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pkt_size_adjust_delta_map_get_async(
	int unit,
	int delta,
	int * final_delta,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PKT_SIZE_ADJUST_DELTA_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pkt_size_adjust_delta_map_get.unit = unit;
	async->args.cosq_pkt_size_adjust_delta_map_get.delta = delta;
	async->args.cosq_pkt_size_adjust_delta_map_get.final_delta = final_delta;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_pkt_size_adjust_delta_map_set_async(
	int unit,
	int delta,
	int final_delta,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PKT_SIZE_ADJUST_DELTA_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_pkt_size_adjust_delta_map_set.unit = unit;
	async->args.cosq_pkt_size_adjust_delta_map_set.delta = delta;
	async->args.cosq_pkt_size_adjust_delta_map_set.final_delta = final_delta;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_bandwidth_get_async(
	int unit,
	bcm_port_t port,
	bcm_cos_queue_t cosq,
	uint32 * kbits_sec_min,
	uint32 * kbits_sec_max,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_bandwidth_get.unit = unit;
	async->args.cosq_port_bandwidth_get.port = port;
	async->args.cosq_port_bandwidth_get.cosq = cosq;
	async->args.cosq_port_bandwidth_get.kbits_sec_min = kbits_sec_min;
	async->args.cosq_port_bandwidth_get.kbits_sec_max = kbits_sec_max;
	async->args.cosq_port_bandwidth_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_bandwidth_set_async(
	int unit,
	bcm_port_t port,
	bcm_cos_queue_t cosq,
	uint32 kbits_sec_min,
	uint32 kbits_sec_max,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_bandwidth_set.unit = unit;
	async->args.cosq_port_bandwidth_set.port = port;
	async->args.cosq_port_bandwidth_set.cosq = cosq;
	async->args.cosq_port_bandwidth_set.kbits_sec_min = kbits_sec_min;
	async->args.cosq_port_bandwidth_set.kbits_sec_max = kbits_sec_max;
	async->args.cosq_port_bandwidth_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_mapping_get_async(
	int unit,
	bcm_port_t port,
	bcm_cos_t priority,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_get.unit = unit;
	async->args.cosq_port_mapping_get.port = port;
	async->args.cosq_port_mapping_get.priority = priority;
	async->args.cosq_port_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_mapping_multi_get_async(
	int unit,
	bcm_port_t port,
	int count,
	bcm_cos_t * priority_array,
	bcm_cos_queue_t * cosq_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_multi_get.unit = unit;
	async->args.cosq_port_mapping_multi_get.port = port;
	async->args.cosq_port_mapping_multi_get.count = count;
	async->args.cosq_port_mapping_multi_get.priority_array = priority_array;
	async->args.cosq_port_mapping_multi_get.cosq_array = cosq_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_mapping_multi_set_async(
	int unit,
	bcm_port_t port,
	int count,
	bcm_cos_t * priority_array,
	bcm_cos_queue_t * cosq_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_multi_set.unit = unit;
	async->args.cosq_port_mapping_multi_set.port = port;
	async->args.cosq_port_mapping_multi_set.count = count;
	async->args.cosq_port_mapping_multi_set.priority_array = priority_array;
	async->args.cosq_port_mapping_multi_set.cosq_array = cosq_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_mapping_set_async(
	int unit,
	bcm_port_t port,
	bcm_cos_t priority,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_set.unit = unit;
	async->args.cosq_port_mapping_set.port = port;
	async->args.cosq_port_mapping_set.priority = priority;
	async->args.cosq_port_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_sched_get_async(
	int unit,
	bcm_pbmp_t pbm,
	int * mode,
	int weights[BCM_COS_COUNT],
	int * delay,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_SCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_sched_get.unit = unit;
	async->args.cosq_port_sched_get.pbm = pbm;
	async->args.cosq_port_sched_get.mode = mode;
	async->args.cosq_port_sched_get.weights = (int *)weights;
	async->args.cosq_port_sched_get.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_port_sched_set_async(
	int unit,
	bcm_pbmp_t pbm,
	int mode,
	const int weights[BCM_COS_COUNT],
	int delay,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PORT_SCHED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_sched_set.unit = unit;
	async->args.cosq_port_sched_set.pbm = pbm;
	async->args.cosq_port_sched_set.mode = mode;
	async->args.cosq_port_sched_set.weights = (int *)weights;
	async->args.cosq_port_sched_set.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_priority_get_async(
	int unit,
	int start_queue,
	int end_queue,
	int * pri_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_priority_get.unit = unit;
	async->args.cosq_priority_get.start_queue = start_queue;
	async->args.cosq_priority_get.end_queue = end_queue;
	async->args.cosq_priority_get.pri_profile_id = pri_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_priority_profile_get_async(
	int unit,
	int pri_profile_id,
	int * count,
	bcm_cosq_gport_priority_profile_t * pri_profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PRIORITY_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_priority_profile_get.unit = unit;
	async->args.cosq_priority_profile_get.pri_profile_id = pri_profile_id;
	async->args.cosq_priority_profile_get.count = count;
	async->args.cosq_priority_profile_get.pri_profile = pri_profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_priority_profile_set_async(
	int unit,
	int pri_profile_id,
	int count,
	bcm_cosq_gport_priority_profile_t * pri_profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PRIORITY_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_priority_profile_set.unit = unit;
	async->args.cosq_priority_profile_set.pri_profile_id = pri_profile_id;
	async->args.cosq_priority_profile_set.count = count;
	async->args.cosq_priority_profile_set.pri_profile = pri_profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_priority_set_async(
	int unit,
	int start_queue,
	int end_queue,
	int pri_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_priority_set.unit = unit;
	async->args.cosq_priority_set.start_queue = start_queue;
	async->args.cosq_priority_set.end_queue = end_queue;
	async->args.cosq_priority_set.pri_profile_id = pri_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_profile_mapping_get_async(
	int unit,
	bcm_gport_t gport_to_map,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_switch_profile_mapping_t * profile_mapping,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PROFILE_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_profile_mapping_get.unit = unit;
	async->args.cosq_profile_mapping_get.gport_to_map = gport_to_map;
	async->args.cosq_profile_mapping_get.cosq = cosq;
	async->args.cosq_profile_mapping_get.flags = flags;
	async->args.cosq_profile_mapping_get.profile_mapping = profile_mapping;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_profile_mapping_set_async(
	int unit,
	bcm_gport_t gport_to_map,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_switch_profile_mapping_t * profile_mapping,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_PROFILE_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_profile_mapping_set.unit = unit;
	async->args.cosq_profile_mapping_set.gport_to_map = gport_to_map;
	async->args.cosq_profile_mapping_set.cosq = cosq;
	async->args.cosq_profile_mapping_set.flags = flags;
	async->args.cosq_profile_mapping_set.profile_mapping = profile_mapping;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_qcn_config_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_qcn_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_QCN_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_qcn_config_get.unit = unit;
	async->args.cosq_qcn_config_get.port = port;
	async->args.cosq_qcn_config_get.cosq = cosq;
	async->args.cosq_qcn_config_get.flags = flags;
	async->args.cosq_qcn_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_qcn_config_set_async(
	int unit,
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	uint32 flags,
	bcm_cosq_qcn_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_QCN_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_qcn_config_set.unit = unit;
	async->args.cosq_qcn_config_set.port = port;
	async->args.cosq_qcn_config_set.cosq = cosq;
	async->args.cosq_qcn_config_set.flags = flags;
	async->args.cosq_qcn_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_resource_allocation_get_async(
	int unit,
	uint32 flags,
	bcm_cosq_resource_t resource,
	bcm_cosq_allocation_entity_t * target,
	bcm_cosq_resource_amounts_t * amounts,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_RESOURCE_ALLOCATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_resource_allocation_get.unit = unit;
	async->args.cosq_resource_allocation_get.flags = flags;
	async->args.cosq_resource_allocation_get.resource = resource;
	async->args.cosq_resource_allocation_get.target = target;
	async->args.cosq_resource_allocation_get.amounts = amounts;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_resource_allocation_set_async(
	int unit,
	uint32 flags,
	bcm_cosq_resource_t resource,
	bcm_cosq_allocation_entity_t * target,
	bcm_cosq_resource_amounts_t * amounts,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_RESOURCE_ALLOCATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_resource_allocation_set.unit = unit;
	async->args.cosq_resource_allocation_set.flags = flags;
	async->args.cosq_resource_allocation_set.resource = resource;
	async->args.cosq_resource_allocation_set.target = target;
	async->args.cosq_resource_allocation_set.amounts = amounts;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_safc_class_mapping_get_async(
	int unit,
	bcm_gport_t port,
	int array_max,
	bcm_cosq_safc_class_mapping_t * mapping_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SAFC_CLASS_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_safc_class_mapping_get.unit = unit;
	async->args.cosq_safc_class_mapping_get.port = port;
	async->args.cosq_safc_class_mapping_get.array_max = array_max;
	async->args.cosq_safc_class_mapping_get.mapping_array = mapping_array;
	async->args.cosq_safc_class_mapping_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_safc_class_mapping_set_async(
	int unit,
	bcm_gport_t port,
	int array_count,
	bcm_cosq_safc_class_mapping_t * mapping_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SAFC_CLASS_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_safc_class_mapping_set.unit = unit;
	async->args.cosq_safc_class_mapping_set.port = port;
	async->args.cosq_safc_class_mapping_set.array_count = array_count;
	async->args.cosq_safc_class_mapping_set.mapping_array = mapping_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_sched_get_async(
	int unit,
	int * mode,
	int weights[BCM_COS_COUNT],
	int * delay,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_get.unit = unit;
	async->args.cosq_sched_get.mode = mode;
	async->args.cosq_sched_get.weights = (int *)weights;
	async->args.cosq_sched_get.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_sched_set_async(
	int unit,
	int mode,
	const int weights[BCM_COS_COUNT],
	int delay,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SCHED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_set.unit = unit;
	async->args.cosq_sched_set.mode = mode;
	async->args.cosq_sched_set.weights = (int *)weights;
	async->args.cosq_sched_set.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_sched_weight_max_get_async(
	int unit,
	int mode,
	int * weight_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SCHED_WEIGHT_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_weight_max_get.unit = unit;
	async->args.cosq_sched_weight_max_get.mode = mode;
	async->args.cosq_sched_weight_max_get.weight_max = weight_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_service_pool_get_async(
	int unit,
	bcm_service_pool_id_t id,
	bcm_cosq_service_pool_t * cosq_service_pool,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SERVICE_POOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_service_pool_get.unit = unit;
	async->args.cosq_service_pool_get.id = id;
	async->args.cosq_service_pool_get.cosq_service_pool = cosq_service_pool;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_service_pool_set_async(
	int unit,
	bcm_service_pool_id_t id,
	bcm_cosq_service_pool_t cosq_service_pool,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SERVICE_POOL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_service_pool_set.unit = unit;
	async->args.cosq_service_pool_set.id = id;
	async->args.cosq_service_pool_set.cosq_service_pool = cosq_service_pool;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_slow_profile_get_async(
	int unit,
	bcm_cosq_slow_level_t * slow_level,
	bcm_cosq_slow_profile_attributes_t * attr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SLOW_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_slow_profile_get.unit = unit;
	async->args.cosq_slow_profile_get.slow_level = slow_level;
	async->args.cosq_slow_profile_get.attr = attr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_slow_profile_set_async(
	int unit,
	bcm_cosq_slow_level_t * slow_level,
	bcm_cosq_slow_profile_attributes_t * attr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SLOW_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_slow_profile_set.unit = unit;
	async->args.cosq_slow_profile_set.slow_level = slow_level;
	async->args.cosq_slow_profile_set.attr = attr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_src_vsqs_gport_add_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_src_vsqs_gport_config_t * config,
	bcm_gport_t * src_port_vsq_gport,
	bcm_gport_t * pg_base_vsq_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SRC_VSQS_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_src_vsqs_gport_add.unit = unit;
	async->args.cosq_src_vsqs_gport_add.port = port;
	async->args.cosq_src_vsqs_gport_add.config = config;
	async->args.cosq_src_vsqs_gport_add.src_port_vsq_gport = src_port_vsq_gport;
	async->args.cosq_src_vsqs_gport_add.pg_base_vsq_gport = pg_base_vsq_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_src_vsqs_gport_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_src_vsqs_gport_config_t * config,
	bcm_gport_t * src_port_vsq_gport,
	bcm_gport_t * pg_base_vsq_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SRC_VSQS_GPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_src_vsqs_gport_get.unit = unit;
	async->args.cosq_src_vsqs_gport_get.port = port;
	async->args.cosq_src_vsqs_gport_get.config = config;
	async->args.cosq_src_vsqs_gport_get.src_port_vsq_gport = src_port_vsq_gport;
	async->args.cosq_src_vsqs_gport_get.pg_base_vsq_gport = pg_base_vsq_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_config_get_async(
	int unit,
	int stat_count,
	bcm_cosq_stat_t * stat_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_config_get.unit = unit;
	async->args.cosq_stat_config_get.stat_count = stat_count;
	async->args.cosq_stat_config_get.stat_array = stat_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_config_set_async(
	int unit,
	int stat_count,
	bcm_cosq_stat_t * stat_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_config_set.unit = unit;
	async->args.cosq_stat_config_set.stat_count = stat_count;
	async->args.cosq_stat_config_set.stat_array = stat_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_get.unit = unit;
	async->args.cosq_stat_get.gport = gport;
	async->args.cosq_stat_get.cosq = cosq;
	async->args.cosq_stat_get.stat = stat;
	async->args.cosq_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_get32_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_get32.unit = unit;
	async->args.cosq_stat_get32.gport = gport;
	async->args.cosq_stat_get32.cosq = cosq;
	async->args.cosq_stat_get32.stat = stat;
	async->args.cosq_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_set.unit = unit;
	async->args.cosq_stat_set.gport = gport;
	async->args.cosq_stat_set.cosq = cosq;
	async->args.cosq_stat_set.stat = stat;
	async->args.cosq_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_set32_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_set32.unit = unit;
	async->args.cosq_stat_set32.gport = gport;
	async->args.cosq_stat_set32.cosq = cosq;
	async->args.cosq_stat_set32.stat = stat;
	async->args.cosq_stat_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_sync_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_sync_get.unit = unit;
	async->args.cosq_stat_sync_get.gport = gport;
	async->args.cosq_stat_sync_get.cosq = cosq;
	async->args.cosq_stat_sync_get.stat = stat;
	async->args.cosq_stat_sync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_stat_sync_get32_async(
	int unit,
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_sync_get32.unit = unit;
	async->args.cosq_stat_sync_get32.gport = gport;
	async->args.cosq_stat_sync_get32.cosq = cosq;
	async->args.cosq_stat_sync_get32.stat = stat;
	async->args.cosq_stat_sync_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subport_flow_control_get_async(
	int unit,
	bcm_gport_t subport,
	bcm_gport_t * sched_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBPORT_FLOW_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subport_flow_control_get.unit = unit;
	async->args.cosq_subport_flow_control_get.subport = subport;
	async->args.cosq_subport_flow_control_get.sched_port = sched_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subport_flow_control_set_async(
	int unit,
	bcm_gport_t subport,
	bcm_gport_t sched_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBPORT_FLOW_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subport_flow_control_set.unit = unit;
	async->args.cosq_subport_flow_control_set.subport = subport;
	async->args.cosq_subport_flow_control_set.sched_port = sched_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subscriber_map_add_async(
	int unit,
	bcm_cosq_subscriber_map_t * map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subscriber_map_add.unit = unit;
	async->args.cosq_subscriber_map_add.map = map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subscriber_map_delete_async(
	int unit,
	bcm_cosq_subscriber_map_t * map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subscriber_map_delete.unit = unit;
	async->args.cosq_subscriber_map_delete.map = map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subscriber_map_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subscriber_map_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subscriber_map_get_async(
	int unit,
	bcm_cosq_subscriber_map_t * map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subscriber_map_get.unit = unit;
	async->args.cosq_subscriber_map_get.map = map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_subscriber_traverse_async(
	int unit,
	bcm_cosq_subscriber_map_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_subscriber_traverse.unit = unit;
	async->args.cosq_subscriber_traverse.cb = cb;
	async->args.cosq_subscriber_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_control_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_control_get.unit = unit;
	async->args.cosq_tas_control_get.port = port;
	async->args.cosq_tas_control_get.type = type;
	async->args.cosq_tas_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_control_set_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_control_set.unit = unit;
	async->args.cosq_tas_control_set.port = port;
	async->args.cosq_tas_control_set.type = type;
	async->args.cosq_tas_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_commit_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_id_t pid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_COMMIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_commit.unit = unit;
	async->args.cosq_tas_profile_commit.port = port;
	async->args.cosq_tas_profile_commit.pid = pid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_create_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_t * profile,
	bcm_cosq_tas_profile_id_t * pid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_create.unit = unit;
	async->args.cosq_tas_profile_create.port = port;
	async->args.cosq_tas_profile_create.profile = profile;
	async->args.cosq_tas_profile_create.pid = pid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_destroy_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_id_t pid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_destroy.unit = unit;
	async->args.cosq_tas_profile_destroy.port = port;
	async->args.cosq_tas_profile_destroy.pid = pid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_destroy_all_async(
	int unit,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_destroy_all.unit = unit;
	async->args.cosq_tas_profile_destroy_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_id_t pid,
	bcm_cosq_tas_profile_t * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_get.unit = unit;
	async->args.cosq_tas_profile_get.port = port;
	async->args.cosq_tas_profile_get.pid = pid;
	async->args.cosq_tas_profile_get.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_set_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_id_t pid,
	bcm_cosq_tas_profile_t * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_set.unit = unit;
	async->args.cosq_tas_profile_set.port = port;
	async->args.cosq_tas_profile_set.pid = pid;
	async->args.cosq_tas_profile_set.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_status_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_id_t pid,
	bcm_cosq_tas_profile_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_status_get.unit = unit;
	async->args.cosq_tas_profile_status_get.port = port;
	async->args.cosq_tas_profile_status_get.pid = pid;
	async->args.cosq_tas_profile_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_profile_traverse_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_profile_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_PROFILE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_profile_traverse.unit = unit;
	async->args.cosq_tas_profile_traverse.port = port;
	async->args.cosq_tas_profile_traverse.cb = cb;
	async->args.cosq_tas_profile_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tas_status_get_async(
	int unit,
	bcm_gport_t port,
	bcm_cosq_tas_status_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TAS_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tas_status_get.unit = unit;
	async->args.cosq_tas_status_get.port = port;
	async->args.cosq_tas_status_get.type = type;
	async->args.cosq_tas_status_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_TCB

void
bcm_cosq_tcb_buffer_multi_get_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	int array_max,
	bcm_cosq_tcb_buffer_t * buffer_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_BUFFER_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_buffer_multi_get.unit = unit;
	async->args.cosq_tcb_buffer_multi_get.buffer_id = buffer_id;
	async->args.cosq_tcb_buffer_multi_get.array_max = array_max;
	async->args.cosq_tcb_buffer_multi_get.buffer_array = buffer_array;
	async->args.cosq_tcb_buffer_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_cb_register_async(
	int unit,
	bcm_cosq_tcb_callback_t fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CB_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_cb_register.unit = unit;
	async->args.cosq_tcb_cb_register.fn = fn;
	async->args.cosq_tcb_cb_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_cb_unregister_async(
	int unit,
	bcm_cosq_tcb_callback_t fn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CB_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_cb_unregister.unit = unit;
	async->args.cosq_tcb_cb_unregister.fn = fn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_config_get_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	bcm_cosq_tcb_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_config_get.unit = unit;
	async->args.cosq_tcb_config_get.buffer_id = buffer_id;
	async->args.cosq_tcb_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_config_set_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	bcm_cosq_tcb_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_config_set.unit = unit;
	async->args.cosq_tcb_config_set.buffer_id = buffer_id;
	async->args.cosq_tcb_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_control_get_async(
	int unit,
	int buffer_id,
	bcm_cosq_tcb_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_control_get.unit = unit;
	async->args.cosq_tcb_control_get.buffer_id = buffer_id;
	async->args.cosq_tcb_control_get.type = type;
	async->args.cosq_tcb_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_control_set_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	bcm_cosq_tcb_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_control_set.unit = unit;
	async->args.cosq_tcb_control_set.buffer_id = buffer_id;
	async->args.cosq_tcb_control_set.type = type;
	async->args.cosq_tcb_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_event_multi_get_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	int array_max,
	bcm_cosq_tcb_event_t * event_array,
	int * array_count,
	int * overflow_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_EVENT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_event_multi_get.unit = unit;
	async->args.cosq_tcb_event_multi_get.buffer_id = buffer_id;
	async->args.cosq_tcb_event_multi_get.array_max = array_max;
	async->args.cosq_tcb_event_multi_get.event_array = event_array;
	async->args.cosq_tcb_event_multi_get.array_count = array_count;
	async->args.cosq_tcb_event_multi_get.overflow_count = overflow_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_gport_threshold_mapping_get_async(
	int unit,
	bcm_cosq_object_id_t * id,
	int * profile_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_GPORT_THRESHOLD_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_gport_threshold_mapping_get.unit = unit;
	async->args.cosq_tcb_gport_threshold_mapping_get.id = id;
	async->args.cosq_tcb_gport_threshold_mapping_get.profile_index = profile_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_gport_threshold_mapping_set_async(
	int unit,
	bcm_cosq_object_id_t * id,
	int profile_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_GPORT_THRESHOLD_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_gport_threshold_mapping_set.unit = unit;
	async->args.cosq_tcb_gport_threshold_mapping_set.id = id;
	async->args.cosq_tcb_gport_threshold_mapping_set.profile_index = profile_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_threshold_profile_create_async(
	int unit,
	int flags,
	bcm_cosq_buffer_id_t buffer_id,
	bcm_cosq_tcb_threshold_profile_t * threshold,
	int * profile_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_THRESHOLD_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_threshold_profile_create.unit = unit;
	async->args.cosq_tcb_threshold_profile_create.flags = flags;
	async->args.cosq_tcb_threshold_profile_create.buffer_id = buffer_id;
	async->args.cosq_tcb_threshold_profile_create.threshold = threshold;
	async->args.cosq_tcb_threshold_profile_create.profile_index = profile_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_threshold_profile_destroy_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	int profile_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_THRESHOLD_PROFILE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_threshold_profile_destroy.unit = unit;
	async->args.cosq_tcb_threshold_profile_destroy.buffer_id = buffer_id;
	async->args.cosq_tcb_threshold_profile_destroy.profile_index = profile_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_cosq_tcb_threshold_profile_get_async(
	int unit,
	bcm_cosq_buffer_id_t buffer_id,
	int profile_index,
	bcm_cosq_tcb_threshold_profile_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_TCB_THRESHOLD_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_tcb_threshold_profile_get.unit = unit;
	async->args.cosq_tcb_threshold_profile_get.buffer_id = buffer_id;
	async->args.cosq_tcb_threshold_profile_get.profile_index = profile_index;
	async->args.cosq_tcb_threshold_profile_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_TCB */

void
bcm_cosq_voq_connector_gport_add_async(
	int unit,
	bcm_cosq_voq_connector_gport_t * config,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_COSQ_VOQ_CONNECTOR_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_voq_connector_gport_add.unit = unit;
	async->args.cosq_voq_connector_gport_add.config = config;
	async->args.cosq_voq_connector_gport_add.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_custom_port_get_async(
	int unit,
	bcm_port_t port,
	int type,
	int max_len,
	uint32 * args,
	int * actual_len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_CUSTOM_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_port_get.unit = unit;
	async->args.custom_port_get.port = port;
	async->args.custom_port_get.type = type;
	async->args.custom_port_get.max_len = max_len;
	async->args.custom_port_get.args = args;
	async->args.custom_port_get.actual_len = actual_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_custom_port_set_async(
	int unit,
	bcm_port_t port,
	int type,
	int len,
	uint32 * args,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_CUSTOM_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_port_set.unit = unit;
	async->args.custom_port_set.port = port;
	async->args.custom_port_set.type = type;
	async->args.custom_port_set.len = len;
	async->args.custom_port_set.args = args;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_custom_register_async(
	int unit,
	bcm_custom_cb_t func,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_CUSTOM_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_register.unit = unit;
	async->args.custom_register.func = func;
	async->args.custom_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_custom_unregister_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_CUSTOM_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_unregister.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_detach_late_txrx_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_DETACH_LATE_TXRX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.detach_late_txrx.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_detach_retry_get_async(
	int unit,
	bcm_detach_retry_t * retry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_DETACH_RETRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.detach_retry_get.unit = unit;
	async->args.detach_retry_get.retry = retry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_detach_retry_set_async(
	int unit,
	bcm_detach_retry_t * retry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_DETACH_RETRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.detach_retry_set.unit = unit;
	async->args.detach_retry_set.retry = retry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_bandwidth_get_async(
	int unit,
	bcm_port_t port,
	bcm_eav_stream_class_t type,
	uint32 * bytes_sec,
	uint32 * bytes_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_bandwidth_get.unit = unit;
	async->args.eav_bandwidth_get.port = port;
	async->args.eav_bandwidth_get.type = type;
	async->args.eav_bandwidth_get.bytes_sec = bytes_sec;
	async->args.eav_bandwidth_get.bytes_burst = bytes_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_bandwidth_set_async(
	int unit,
	bcm_port_t port,
	bcm_eav_stream_class_t type,
	uint32 bytes_sec,
	uint32 bytes_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_bandwidth_set.unit = unit;
	async->args.eav_bandwidth_set.port = port;
	async->args.eav_bandwidth_set.type = type;
	async->args.eav_bandwidth_set.bytes_sec = bytes_sec;
	async->args.eav_bandwidth_set.bytes_burst = bytes_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_control_get_async(
	int unit,
	bcm_eav_control_t type,
	uint32 * arg,
	uint32 * arg2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_control_get.unit = unit;
	async->args.eav_control_get.type = type;
	async->args.eav_control_get.arg = arg;
	async->args.eav_control_get.arg2 = arg2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_control_set_async(
	int unit,
	bcm_eav_control_t type,
	uint32 arg,
	uint32 arg2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_control_set.unit = unit;
	async->args.eav_control_set.type = type;
	async->args.eav_control_set.arg = arg;
	async->args.eav_control_set.arg2 = arg2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_link_status_get_async(
	int unit,
	bcm_port_t port,
	int * link,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_LINK_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_link_status_get.unit = unit;
	async->args.eav_link_status_get.port = port;
	async->args.eav_link_status_get.link = link;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_link_status_set_async(
	int unit,
	bcm_port_t port,
	int link,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_LINK_STATUS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_link_status_set.unit = unit;
	async->args.eav_link_status_set.port = port;
	async->args.eav_link_status_set.link = link;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_pcp_mapping_get_async(
	int unit,
	bcm_eav_stream_class_t type,
	int * pcp,
	int * remapped_pcp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_PCP_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_pcp_mapping_get.unit = unit;
	async->args.eav_pcp_mapping_get.type = type;
	async->args.eav_pcp_mapping_get.pcp = pcp;
	async->args.eav_pcp_mapping_get.remapped_pcp = remapped_pcp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_pcp_mapping_set_async(
	int unit,
	bcm_eav_stream_class_t type,
	int pcp,
	int remapped_pcp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_PCP_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_pcp_mapping_set.unit = unit;
	async->args.eav_pcp_mapping_set.type = type;
	async->args.eav_pcp_mapping_set.pcp = pcp;
	async->args.eav_pcp_mapping_set.remapped_pcp = remapped_pcp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_port_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_PORT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_port_enable_get.unit = unit;
	async->args.eav_port_enable_get.port = port;
	async->args.eav_port_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_port_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_PORT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_port_enable_set.unit = unit;
	async->args.eav_port_enable_set.port = port;
	async->args.eav_port_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_srp_mac_ethertype_get_async(
	int unit,
	bcm_mac_t mac,
	bcm_port_ethertype_t * ethertype,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_SRP_MAC_ETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_srp_mac_ethertype_get.unit = unit;
	async->args.eav_srp_mac_ethertype_get.mac = (uint8 *)mac;
	async->args.eav_srp_mac_ethertype_get.ethertype = ethertype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_srp_mac_ethertype_set_async(
	int unit,
	bcm_mac_t mac,
	bcm_port_ethertype_t ethertype,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_SRP_MAC_ETHERTYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_srp_mac_ethertype_set.unit = unit;
	async->args.eav_srp_mac_ethertype_set.mac = (uint8 *)mac;
	async->args.eav_srp_mac_ethertype_set.ethertype = ethertype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_timestamp_get_async(
	int unit,
	bcm_port_t port,
	uint32 * timestamp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_TIMESTAMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_timestamp_get.unit = unit;
	async->args.eav_timestamp_get.port = port;
	async->args.eav_timestamp_get.timestamp = timestamp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_timesync_mac_get_async(
	int unit,
	bcm_mac_t eav_mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_TIMESYNC_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_timesync_mac_get.unit = unit;
	async->args.eav_timesync_mac_get.eav_mac = (uint8 *)eav_mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_eav_timesync_mac_set_async(
	int unit,
	bcm_mac_t eav_mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EAV_TIMESYNC_MAC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.eav_timesync_mac_set.unit = unit;
	async->args.eav_timesync_mac_set.eav_mac = (uint8 *)eav_mac;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_ecn_map_create_async(
	int unit,
	uint32 flags,
	int * ecn_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_map_create.unit = unit;
	async->args.ecn_map_create.flags = flags;
	async->args.ecn_map_create.ecn_map_id = ecn_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_map_destroy_async(
	int unit,
	int ecn_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_map_destroy.unit = unit;
	async->args.ecn_map_destroy.ecn_map_id = ecn_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_map_get_async(
	int unit,
	int ecn_map_id,
	bcm_ecn_map_t * ecn_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_map_get.unit = unit;
	async->args.ecn_map_get.ecn_map_id = ecn_map_id;
	async->args.ecn_map_get.ecn_map = ecn_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_map_set_async(
	int unit,
	uint32 options,
	int ecn_map_id,
	bcm_ecn_map_t * ecn_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_map_set.unit = unit;
	async->args.ecn_map_set.options = options;
	async->args.ecn_map_set.ecn_map_id = ecn_map_id;
	async->args.ecn_map_set.ecn_map = ecn_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_port_map_get_async(
	int unit,
	bcm_gport_t port,
	bcm_ecn_port_map_t * ecn_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_PORT_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_port_map_get.unit = unit;
	async->args.ecn_port_map_get.port = port;
	async->args.ecn_port_map_get.ecn_map = ecn_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_port_map_set_async(
	int unit,
	bcm_gport_t port,
	bcm_ecn_port_map_t * ecn_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_PORT_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_port_map_set.unit = unit;
	async->args.ecn_port_map_set.port = port;
	async->args.ecn_port_map_set.ecn_map = ecn_map;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_ecn_responsive_protocol_get_async(
	int unit,
	uint8 ip_proto,
	int * responsive,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_RESPONSIVE_PROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_responsive_protocol_get.unit = unit;
	async->args.ecn_responsive_protocol_get.ip_proto = ip_proto;
	async->args.ecn_responsive_protocol_get.responsive = responsive;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_responsive_protocol_set_async(
	int unit,
	uint8 ip_proto,
	int responsive,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_RESPONSIVE_PROTOCOL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_responsive_protocol_set.unit = unit;
	async->args.ecn_responsive_protocol_set.ip_proto = ip_proto;
	async->args.ecn_responsive_protocol_set.responsive = responsive;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_traffic_action_config_get_async(
	int unit,
	bcm_ecn_traffic_action_config_t * ecn_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_TRAFFIC_ACTION_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_traffic_action_config_get.unit = unit;
	async->args.ecn_traffic_action_config_get.ecn_config = ecn_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_traffic_action_config_set_async(
	int unit,
	bcm_ecn_traffic_action_config_t * ecn_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_TRAFFIC_ACTION_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_traffic_action_config_set.unit = unit;
	async->args.ecn_traffic_action_config_set.ecn_config = ecn_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_traffic_map_get_async(
	int unit,
	bcm_ecn_traffic_map_info_t * map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_TRAFFIC_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_traffic_map_get.unit = unit;
	async->args.ecn_traffic_map_get.map = map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ecn_traffic_map_set_async(
	int unit,
	bcm_ecn_traffic_map_info_t * map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ECN_TRAFFIC_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ecn_traffic_map_set.unit = unit;
	async->args.ecn_traffic_map_set.map = map;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_PTP

void
bcm_esmc_QL_SSM_map_async(
	int unit,
	bcm_esmc_network_option_t opt,
	bcm_esmc_quality_level_t ql,
	uint8 * ssm_code,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_QL_SSM_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_QL_SSM_map.unit = unit;
	async->args.esmc_QL_SSM_map.opt = opt;
	async->args.esmc_QL_SSM_map.ql = ql;
	async->args.esmc_QL_SSM_map.ssm_code = ssm_code;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_SSM_QL_map_async(
	int unit,
	bcm_esmc_network_option_t opt,
	uint8 ssm_code,
	bcm_esmc_quality_level_t * ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_SSM_QL_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_SSM_QL_map.unit = unit;
	async->args.esmc_SSM_QL_map.opt = opt;
	async->args.esmc_SSM_QL_map.ssm_code = ssm_code;
	async->args.esmc_SSM_QL_map.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_g781_option_get_async(
	int unit,
	int stack_id,
	bcm_esmc_network_option_t * g781_option,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_G781_OPTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_g781_option_get.unit = unit;
	async->args.esmc_g781_option_get.stack_id = stack_id;
	async->args.esmc_g781_option_get.g781_option = g781_option;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_g781_option_set_async(
	int unit,
	int stack_id,
	bcm_esmc_network_option_t g781_option,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_G781_OPTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_g781_option_set.unit = unit;
	async->args.esmc_g781_option_set.stack_id = stack_id;
	async->args.esmc_g781_option_set.g781_option = g781_option;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_rx_callback_register_async(
	int unit,
	int stack_id,
	bcm_esmc_rx_cb rx_cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_RX_CALLBACK_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_rx_callback_register.unit = unit;
	async->args.esmc_rx_callback_register.stack_id = stack_id;
	async->args.esmc_rx_callback_register.rx_cb = rx_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_rx_callback_unregister_async(
	int unit,
	int stack_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_RX_CALLBACK_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_rx_callback_unregister.unit = unit;
	async->args.esmc_rx_callback_unregister.stack_id = stack_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_tunnel_get_async(
	int unit,
	int stack_id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_TUNNEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_tunnel_get.unit = unit;
	async->args.esmc_tunnel_get.stack_id = stack_id;
	async->args.esmc_tunnel_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_tunnel_set_async(
	int unit,
	int stack_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_TUNNEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_tunnel_set.unit = unit;
	async->args.esmc_tunnel_set.stack_id = stack_id;
	async->args.esmc_tunnel_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_esmc_tx_async(
	int unit,
	int stack_id,
	bcm_pbmp_t pbmp,
	bcm_esmc_pdu_data_t * esmc_pdu_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_ESMC_TX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.esmc_tx.unit = unit;
	async->args.esmc_tx.stack_id = stack_id;
	async->args.esmc_tx.pbmp = pbmp;
	async->args.esmc_tx.esmc_pdu_data = esmc_pdu_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_PTP */
#ifdef	INCLUDE_L3

void
bcm_extender_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_add_async(
	int unit,
	bcm_gport_t extender_port,
	bcm_extender_egress_t * extender_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_add.unit = unit;
	async->args.extender_egress_add.extender_port = extender_port;
	async->args.extender_egress_add.extender_egress = extender_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_delete_async(
	int unit,
	bcm_gport_t extender_port,
	bcm_extender_egress_t * extender_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_delete.unit = unit;
	async->args.extender_egress_delete.extender_port = extender_port;
	async->args.extender_egress_delete.extender_egress = extender_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_delete_all_async(
	int unit,
	bcm_gport_t extender_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_delete_all.unit = unit;
	async->args.extender_egress_delete_all.extender_port = extender_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_get_async(
	int unit,
	bcm_gport_t extender_port,
	bcm_extender_egress_t * extender_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_get.unit = unit;
	async->args.extender_egress_get.extender_port = extender_port;
	async->args.extender_egress_get.extender_egress = extender_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_get_all_async(
	int unit,
	bcm_gport_t extender_port,
	int array_size,
	bcm_extender_egress_t * extender_egress_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_get_all.unit = unit;
	async->args.extender_egress_get_all.extender_port = extender_port;
	async->args.extender_egress_get_all.array_size = array_size;
	async->args.extender_egress_get_all.extender_egress_array = extender_egress_array;
	async->args.extender_egress_get_all.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_egress_set_async(
	int unit,
	bcm_gport_t extender_port,
	int array_size,
	bcm_extender_egress_t * extender_egress_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_egress_set.unit = unit;
	async->args.extender_egress_set.extender_port = extender_port;
	async->args.extender_egress_set.array_size = array_size;
	async->args.extender_egress_set.extender_egress_array = extender_egress_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_encap_create_async(
	int unit,
	bcm_extender_encap_t * extender_encap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_ENCAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_encap_create.unit = unit;
	async->args.extender_encap_create.extender_encap = extender_encap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_encap_destroy_async(
	int unit,
	bcm_gport_t * extender_encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_ENCAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_encap_destroy.unit = unit;
	async->args.extender_encap_destroy.extender_encap_id = extender_encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_encap_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_ENCAP_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_encap_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_encap_get_async(
	int unit,
	bcm_extender_encap_t * extender_encap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_encap_get.unit = unit;
	async->args.extender_encap_get.extender_encap = extender_encap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_encap_traverse_async(
	int unit,
	bcm_extender_encap_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_ENCAP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_encap_traverse.unit = unit;
	async->args.extender_encap_traverse.cb = cb;
	async->args.extender_encap_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_forward_add_async(
	int unit,
	bcm_extender_forward_t * extender_forward_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_FORWARD_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_forward_add.unit = unit;
	async->args.extender_forward_add.extender_forward_entry = extender_forward_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_forward_delete_async(
	int unit,
	bcm_extender_forward_t * extender_forward_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_FORWARD_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_forward_delete.unit = unit;
	async->args.extender_forward_delete.extender_forward_entry = extender_forward_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_forward_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_FORWARD_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_forward_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_forward_get_async(
	int unit,
	bcm_extender_forward_t * extender_forward_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_FORWARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_forward_get.unit = unit;
	async->args.extender_forward_get.extender_forward_entry = extender_forward_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_forward_traverse_async(
	int unit,
	bcm_extender_forward_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_FORWARD_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_forward_traverse.unit = unit;
	async->args.extender_forward_traverse.cb = cb;
	async->args.extender_forward_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_port_add_async(
	int unit,
	bcm_extender_port_t * extender_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_port_add.unit = unit;
	async->args.extender_port_add.extender_port = extender_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_port_delete_async(
	int unit,
	bcm_gport_t extender_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_port_delete.unit = unit;
	async->args.extender_port_delete.extender_port_id = extender_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_port_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_port_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_port_get_async(
	int unit,
	bcm_extender_port_t * extender_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_port_get.unit = unit;
	async->args.extender_port_get.extender_port = extender_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_extender_port_traverse_async(
	int unit,
	bcm_extender_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_EXTENDER_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.extender_port_traverse.unit = unit;
	async->args.extender_port_traverse.cb = cb;
	async->args.extender_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_fabric_action_create_async(
	int unit,
	bcm_fabric_action_info_t * action_info,
	bcm_fabric_action_t * action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ACTION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_action_create.unit = unit;
	async->args.fabric_action_create.action_info = action_info;
	async->args.fabric_action_create.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_action_destroy_async(
	int unit,
	bcm_fabric_action_t action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ACTION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_action_destroy.unit = unit;
	async->args.fabric_action_destroy.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_action_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ACTION_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_action_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_action_get_async(
	int unit,
	bcm_fabric_action_t action_id,
	bcm_fabric_action_info_t * action_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_action_get.unit = unit;
	async->args.fabric_action_get.action_id = action_id;
	async->args.fabric_action_get.action_info = action_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_action_traverse_async(
	int unit,
	bcm_fabric_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_action_traverse.unit = unit;
	async->args.fabric_action_traverse.cb = cb;
	async->args.fabric_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_bandwidth_core_profile_get_async(
	int unit,
	int core,
	uint32 flags,
	int profile_count,
	bcm_fabric_bandwidth_profile_t * profile_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_BANDWIDTH_CORE_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_bandwidth_core_profile_get.unit = unit;
	async->args.fabric_bandwidth_core_profile_get.core = core;
	async->args.fabric_bandwidth_core_profile_get.flags = flags;
	async->args.fabric_bandwidth_core_profile_get.profile_count = profile_count;
	async->args.fabric_bandwidth_core_profile_get.profile_array = profile_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_bandwidth_core_profile_set_async(
	int unit,
	int core,
	uint32 flags,
	int profile_count,
	bcm_fabric_bandwidth_profile_t * profile_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_BANDWIDTH_CORE_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_bandwidth_core_profile_set.unit = unit;
	async->args.fabric_bandwidth_core_profile_set.core = core;
	async->args.fabric_bandwidth_core_profile_set.flags = flags;
	async->args.fabric_bandwidth_core_profile_set.profile_count = profile_count;
	async->args.fabric_bandwidth_core_profile_set.profile_array = profile_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_bandwidth_profile_get_async(
	int unit,
	int profile_count,
	bcm_fabric_bandwidth_profile_t * profile_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_BANDWIDTH_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_bandwidth_profile_get.unit = unit;
	async->args.fabric_bandwidth_profile_get.profile_count = profile_count;
	async->args.fabric_bandwidth_profile_get.profile_array = profile_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_bandwidth_profile_set_async(
	int unit,
	int profile_count,
	bcm_fabric_bandwidth_profile_t * profile_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_BANDWIDTH_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_bandwidth_profile_set.unit = unit;
	async->args.fabric_bandwidth_profile_set.profile_count = profile_count;
	async->args.fabric_bandwidth_profile_set.profile_array = profile_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_active_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_ACTIVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_active.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_get_async(
	int unit,
	int cindex,
	int * connection,
	bcm_gport_t * dest_port,
	bcm_cos_queue_t * dest_cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_get.unit = unit;
	async->args.fabric_calendar_get.cindex = cindex;
	async->args.fabric_calendar_get.connection = connection;
	async->args.fabric_calendar_get.dest_port = dest_port;
	async->args.fabric_calendar_get.dest_cosq = dest_cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_max_get_async(
	int unit,
	int * max_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_max_get.unit = unit;
	async->args.fabric_calendar_max_get.max_size = max_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_multi_get_async(
	int unit,
	int array_size,
	int * connection_array,
	bcm_gport_t * dest_port_array,
	bcm_cos_queue_t * dest_cosq_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_multi_get.unit = unit;
	async->args.fabric_calendar_multi_get.array_size = array_size;
	async->args.fabric_calendar_multi_get.connection_array = connection_array;
	async->args.fabric_calendar_multi_get.dest_port_array = dest_port_array;
	async->args.fabric_calendar_multi_get.dest_cosq_array = dest_cosq_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_multi_set_async(
	int unit,
	int array_size,
	int * connection_array,
	bcm_gport_t * dest_port_array,
	bcm_cos_queue_t * dest_cosq_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_multi_set.unit = unit;
	async->args.fabric_calendar_multi_set.array_size = array_size;
	async->args.fabric_calendar_multi_set.connection_array = connection_array;
	async->args.fabric_calendar_multi_set.dest_port_array = dest_port_array;
	async->args.fabric_calendar_multi_set.dest_cosq_array = dest_cosq_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_set_async(
	int unit,
	int cindex,
	int connection,
	bcm_gport_t dest_port,
	bcm_cos_queue_t dest_cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_set.unit = unit;
	async->args.fabric_calendar_set.cindex = cindex;
	async->args.fabric_calendar_set.connection = connection;
	async->args.fabric_calendar_set.dest_port = dest_port;
	async->args.fabric_calendar_set.dest_cosq = dest_cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_size_get_async(
	int unit,
	int * config_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_size_get.unit = unit;
	async->args.fabric_calendar_size_get.config_size = config_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_calendar_size_set_async(
	int unit,
	int config_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SIZE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_calendar_size_set.unit = unit;
	async->args.fabric_calendar_size_set.config_size = config_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_config_discard_get_async(
	int unit,
	bcm_fabric_config_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONFIG_DISCARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_config_discard_get.unit = unit;
	async->args.fabric_config_discard_get.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_config_discard_set_async(
	int unit,
	bcm_fabric_config_discard_t * discard,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONFIG_DISCARD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_config_discard_set.unit = unit;
	async->args.fabric_config_discard_set.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_congestion_size_get_async(
	int unit,
	bcm_module_t module_id,
	int * max_ports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONGESTION_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_congestion_size_get.unit = unit;
	async->args.fabric_congestion_size_get.module_id = module_id;
	async->args.fabric_congestion_size_get.max_ports = max_ports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_congestion_size_set_async(
	int unit,
	bcm_module_t module_id,
	int max_ports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONGESTION_SIZE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_congestion_size_set.unit = unit;
	async->args.fabric_congestion_size_set.module_id = module_id;
	async->args.fabric_congestion_size_set.max_ports = max_ports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_connection_bytes_get_async(
	int unit,
	int src_modid,
	int dst_modid,
	bcm_fabric_connection_mode_t mode,
	int link_fail_count,
	int * max_bytes,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONNECTION_BYTES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_connection_bytes_get.unit = unit;
	async->args.fabric_connection_bytes_get.src_modid = src_modid;
	async->args.fabric_connection_bytes_get.dst_modid = dst_modid;
	async->args.fabric_connection_bytes_get.mode = mode;
	async->args.fabric_connection_bytes_get.link_fail_count = link_fail_count;
	async->args.fabric_connection_bytes_get.max_bytes = max_bytes;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_connection_interval_get_async(
	int unit,
	int link_fail_count,
	int * connection_interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONNECTION_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_connection_interval_get.unit = unit;
	async->args.fabric_connection_interval_get.link_fail_count = link_fail_count;
	async->args.fabric_connection_interval_get.connection_interval = connection_interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_connection_max_get_async(
	int unit,
	int link_fail_count,
	int * connection,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONNECTION_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_connection_max_get.unit = unit;
	async->args.fabric_connection_max_get.link_fail_count = link_fail_count;
	async->args.fabric_connection_max_get.connection = connection;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_control_get_async(
	int unit,
	bcm_fabric_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_control_get.unit = unit;
	async->args.fabric_control_get.type = type;
	async->args.fabric_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_control_redundancy_register_async(
	int unit,
	bcm_fabric_control_redundancy_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONTROL_REDUNDANCY_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_control_redundancy_register.unit = unit;
	async->args.fabric_control_redundancy_register.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_control_redundancy_unregister_async(
	int unit,
	bcm_fabric_control_redundancy_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONTROL_REDUNDANCY_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_control_redundancy_unregister.unit = unit;
	async->args.fabric_control_redundancy_unregister.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_control_set_async(
	int unit,
	bcm_fabric_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_control_set.unit = unit;
	async->args.fabric_control_set.type = type;
	async->args.fabric_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_connection_get_async(
	int unit,
	int xbar,
	int src_modid,
	bcm_port_t src_xbport,
	int dst_modid,
	bcm_port_t * dst_xbport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_connection_get.unit = unit;
	async->args.fabric_crossbar_connection_get.xbar = xbar;
	async->args.fabric_crossbar_connection_get.src_modid = src_modid;
	async->args.fabric_crossbar_connection_get.src_xbport = src_xbport;
	async->args.fabric_crossbar_connection_get.dst_modid = dst_modid;
	async->args.fabric_crossbar_connection_get.dst_xbport = dst_xbport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_connection_set_async(
	int unit,
	int xbar,
	int src_modid,
	bcm_port_t src_xbport,
	int dst_modid,
	bcm_port_t dst_xbport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_connection_set.unit = unit;
	async->args.fabric_crossbar_connection_set.xbar = xbar;
	async->args.fabric_crossbar_connection_set.src_modid = src_modid;
	async->args.fabric_crossbar_connection_set.src_xbport = src_xbport;
	async->args.fabric_crossbar_connection_set.dst_modid = dst_modid;
	async->args.fabric_crossbar_connection_set.dst_xbport = dst_xbport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_connection_status_get_async(
	int unit,
	int src_modid,
	int dst_modid,
	bcm_fabric_connection_mode_t mode,
	uint64 * xbars,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_connection_status_get.unit = unit;
	async->args.fabric_crossbar_connection_status_get.src_modid = src_modid;
	async->args.fabric_crossbar_connection_status_get.dst_modid = dst_modid;
	async->args.fabric_crossbar_connection_status_get.mode = mode;
	async->args.fabric_crossbar_connection_status_get.xbars = xbars;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_enable_get_async(
	int unit,
	uint64 * xbars,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_enable_get.unit = unit;
	async->args.fabric_crossbar_enable_get.xbars = xbars;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_enable_set_async(
	int unit,
	uint64 xbars,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_enable_set.unit = unit;
	async->args.fabric_crossbar_enable_set.xbars = xbars;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_mapping_get_async(
	int unit,
	int modid,
	int switch_fabric_arbiter_id,
	int xbar,
	bcm_port_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_mapping_get.unit = unit;
	async->args.fabric_crossbar_mapping_get.modid = modid;
	async->args.fabric_crossbar_mapping_get.switch_fabric_arbiter_id = switch_fabric_arbiter_id;
	async->args.fabric_crossbar_mapping_get.xbar = xbar;
	async->args.fabric_crossbar_mapping_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_mapping_set_async(
	int unit,
	int modid,
	int switch_fabric_arbiter_id,
	int xbar,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_mapping_set.unit = unit;
	async->args.fabric_crossbar_mapping_set.modid = modid;
	async->args.fabric_crossbar_mapping_set.switch_fabric_arbiter_id = switch_fabric_arbiter_id;
	async->args.fabric_crossbar_mapping_set.xbar = xbar;
	async->args.fabric_crossbar_mapping_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_crossbar_status_get_async(
	int unit,
	uint64 * xbars,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_crossbar_status_get.unit = unit;
	async->args.fabric_crossbar_status_get.xbars = xbars;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_destination_link_min_get_async(
	int unit,
	uint32 flags,
	bcm_module_t module_id,
	int * num_of_links,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DESTINATION_LINK_MIN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_destination_link_min_get.unit = unit;
	async->args.fabric_destination_link_min_get.flags = flags;
	async->args.fabric_destination_link_min_get.module_id = module_id;
	async->args.fabric_destination_link_min_get.num_of_links = num_of_links;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_destination_link_min_set_async(
	int unit,
	uint32 flags,
	bcm_module_t module_id,
	int num_of_links,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DESTINATION_LINK_MIN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_destination_link_min_set.unit = unit;
	async->args.fabric_destination_link_min_set.flags = flags;
	async->args.fabric_destination_link_min_set.module_id = module_id;
	async->args.fabric_destination_link_min_set.num_of_links = num_of_links;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_control_get_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	bcm_fabric_distribution_control_t type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_control_get.unit = unit;
	async->args.fabric_distribution_control_get.ds_id = ds_id;
	async->args.fabric_distribution_control_get.type = type;
	async->args.fabric_distribution_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_control_set_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	bcm_fabric_distribution_control_t type,
	int value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_control_set.unit = unit;
	async->args.fabric_distribution_control_set.ds_id = ds_id;
	async->args.fabric_distribution_control_set.type = type;
	async->args.fabric_distribution_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_create_async(
	int unit,
	uint32 flags,
	bcm_fabric_distribution_t * ds_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_create.unit = unit;
	async->args.fabric_distribution_create.flags = flags;
	async->args.fabric_distribution_create.ds_id = ds_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_destroy_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_destroy.unit = unit;
	async->args.fabric_distribution_destroy.ds_id = ds_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_get_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	int max_count,
	int * dist_modids,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_get.unit = unit;
	async->args.fabric_distribution_get.ds_id = ds_id;
	async->args.fabric_distribution_get.max_count = max_count;
	async->args.fabric_distribution_get.dist_modids = dist_modids;
	async->args.fabric_distribution_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_distribution_set_async(
	int unit,
	bcm_fabric_distribution_t ds_id,
	int modid_count,
	int * dist_modids,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_distribution_set.unit = unit;
	async->args.fabric_distribution_set.ds_id = ds_id;
	async->args.fabric_distribution_set.modid_count = modid_count;
	async->args.fabric_distribution_set.dist_modids = dist_modids;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_connectivity_status_get_async(
	int unit,
	int link_partner_max,
	bcm_fabric_link_connectivity_t * link_partner_array,
	int * link_partner_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_CONNECTIVITY_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_connectivity_status_get.unit = unit;
	async->args.fabric_link_connectivity_status_get.link_partner_max = link_partner_max;
	async->args.fabric_link_connectivity_status_get.link_partner_array = link_partner_array;
	async->args.fabric_link_connectivity_status_get.link_partner_count = link_partner_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_connectivity_status_single_get_async(
	int unit,
	bcm_port_t link_id,
	bcm_fabric_link_connectivity_t * link_partner_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_CONNECTIVITY_STATUS_SINGLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_connectivity_status_single_get.unit = unit;
	async->args.fabric_link_connectivity_status_single_get.link_id = link_id;
	async->args.fabric_link_connectivity_status_single_get.link_partner_info = link_partner_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_control_get_async(
	int unit,
	bcm_port_t link,
	bcm_fabric_link_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_control_get.unit = unit;
	async->args.fabric_link_control_get.link = link;
	async->args.fabric_link_control_get.type = type;
	async->args.fabric_link_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_control_set_async(
	int unit,
	bcm_port_t link,
	bcm_fabric_link_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_control_set.unit = unit;
	async->args.fabric_link_control_set.link = link;
	async->args.fabric_link_control_set.type = type;
	async->args.fabric_link_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_remote_pipe_mapping_get_async(
	int unit,
	bcm_port_t port,
	bcm_fabric_link_remote_pipe_mapping_t * mapping_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_REMOTE_PIPE_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_remote_pipe_mapping_get.unit = unit;
	async->args.fabric_link_remote_pipe_mapping_get.port = port;
	async->args.fabric_link_remote_pipe_mapping_get.mapping_config = mapping_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_remote_pipe_mapping_set_async(
	int unit,
	bcm_port_t port,
	bcm_fabric_link_remote_pipe_mapping_t * mapping_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_REMOTE_PIPE_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_remote_pipe_mapping_set.unit = unit;
	async->args.fabric_link_remote_pipe_mapping_set.port = port;
	async->args.fabric_link_remote_pipe_mapping_set.mapping_config = mapping_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_status_get_async(
	int unit,
	bcm_port_t link_id,
	uint32 * link_status,
	uint32 * errored_token_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_status_get.unit = unit;
	async->args.fabric_link_status_get.link_id = link_id;
	async->args.fabric_link_status_get.link_status = link_status;
	async->args.fabric_link_status_get.errored_token_count = errored_token_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_threshold_add_async(
	int unit,
	uint32 flags,
	int * fifo_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLD_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_threshold_add.unit = unit;
	async->args.fabric_link_threshold_add.flags = flags;
	async->args.fabric_link_threshold_add.fifo_type = fifo_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_threshold_delete_async(
	int unit,
	int fifo_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLD_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_threshold_delete.unit = unit;
	async->args.fabric_link_threshold_delete.fifo_type = fifo_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_attach_async(
	int unit,
	int fifo_type,
	uint32 links_count,
	bcm_port_t * links,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_attach.unit = unit;
	async->args.fabric_link_thresholds_attach.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_attach.links_count = links_count;
	async->args.fabric_link_thresholds_attach.links = links;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_get_async(
	int unit,
	int fifo_type,
	uint32 count,
	bcm_fabric_link_threshold_type_t * type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_get.unit = unit;
	async->args.fabric_link_thresholds_get.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_get.count = count;
	async->args.fabric_link_thresholds_get.type = type;
	async->args.fabric_link_thresholds_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_pipe_get_async(
	int unit,
	int fifo_type,
	bcm_fabric_pipe_t pipe,
	uint32 flags,
	uint32 count,
	bcm_fabric_link_threshold_type_t * type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_PIPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_pipe_get.unit = unit;
	async->args.fabric_link_thresholds_pipe_get.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_pipe_get.pipe = pipe;
	async->args.fabric_link_thresholds_pipe_get.flags = flags;
	async->args.fabric_link_thresholds_pipe_get.count = count;
	async->args.fabric_link_thresholds_pipe_get.type = type;
	async->args.fabric_link_thresholds_pipe_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_pipe_set_async(
	int unit,
	int fifo_type,
	bcm_fabric_pipe_t pipe,
	uint32 flags,
	uint32 count,
	bcm_fabric_link_threshold_type_t * type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_PIPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_pipe_set.unit = unit;
	async->args.fabric_link_thresholds_pipe_set.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_pipe_set.pipe = pipe;
	async->args.fabric_link_thresholds_pipe_set.flags = flags;
	async->args.fabric_link_thresholds_pipe_set.count = count;
	async->args.fabric_link_thresholds_pipe_set.type = type;
	async->args.fabric_link_thresholds_pipe_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_retrieve_async(
	int unit,
	int fifo_type,
	uint32 links_count_max,
	bcm_port_t * links,
	uint32 * links_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_RETRIEVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_retrieve.unit = unit;
	async->args.fabric_link_thresholds_retrieve.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_retrieve.links_count_max = links_count_max;
	async->args.fabric_link_thresholds_retrieve.links = links;
	async->args.fabric_link_thresholds_retrieve.links_count = links_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_thresholds_set_async(
	int unit,
	int fifo_type,
	uint32 count,
	bcm_fabric_link_threshold_type_t * type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_THRESHOLDS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_thresholds_set.unit = unit;
	async->args.fabric_link_thresholds_set.fifo_type = fifo_type;
	async->args.fabric_link_thresholds_set.count = count;
	async->args.fabric_link_thresholds_set.type = type;
	async->args.fabric_link_thresholds_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_topology_get_async(
	int unit,
	bcm_module_t destination,
	int max_links_count,
	int * links_count,
	bcm_port_t * links_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_TOPOLOGY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_topology_get.unit = unit;
	async->args.fabric_link_topology_get.destination = destination;
	async->args.fabric_link_topology_get.max_links_count = max_links_count;
	async->args.fabric_link_topology_get.links_count = links_count;
	async->args.fabric_link_topology_get.links_array = links_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_link_topology_set_async(
	int unit,
	bcm_module_t destination,
	int links_count,
	bcm_port_t * links_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_LINK_TOPOLOGY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_link_topology_set.unit = unit;
	async->args.fabric_link_topology_set.destination = destination;
	async->args.fabric_link_topology_set.links_count = links_count;
	async->args.fabric_link_topology_set.links_array = links_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_modid_group_find_async(
	int unit,
	bcm_module_t modid,
	bcm_module_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODID_GROUP_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_modid_group_find.unit = unit;
	async->args.fabric_modid_group_find.modid = modid;
	async->args.fabric_modid_group_find.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_modid_group_get_async(
	int unit,
	bcm_module_t group,
	int modid_max_count,
	bcm_module_t * modid_array,
	int * modid_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODID_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_modid_group_get.unit = unit;
	async->args.fabric_modid_group_get.group = group;
	async->args.fabric_modid_group_get.modid_max_count = modid_max_count;
	async->args.fabric_modid_group_get.modid_array = modid_array;
	async->args.fabric_modid_group_get.modid_count = modid_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_modid_group_set_async(
	int unit,
	bcm_module_t group,
	int modid_count,
	bcm_module_t * modid_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODID_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_modid_group_set.unit = unit;
	async->args.fabric_modid_group_set.group = group;
	async->args.fabric_modid_group_set.modid_count = modid_count;
	async->args.fabric_modid_group_set.modid_array = modid_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_modid_local_mapping_get_async(
	int unit,
	bcm_module_t local_modid,
	bcm_module_t * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODID_LOCAL_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_modid_local_mapping_get.unit = unit;
	async->args.fabric_modid_local_mapping_get.local_modid = local_modid;
	async->args.fabric_modid_local_mapping_get.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_modid_local_mapping_set_async(
	int unit,
	bcm_module_t local_modid,
	bcm_module_t modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODID_LOCAL_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_modid_local_mapping_set.unit = unit;
	async->args.fabric_modid_local_mapping_set.local_modid = local_modid;
	async->args.fabric_modid_local_mapping_set.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_module_control_get_async(
	int unit,
	uint32 flags,
	bcm_module_t modid,
	bcm_fabric_module_control_t control,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODULE_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_module_control_get.unit = unit;
	async->args.fabric_module_control_get.flags = flags;
	async->args.fabric_module_control_get.modid = modid;
	async->args.fabric_module_control_get.control = control;
	async->args.fabric_module_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_module_control_set_async(
	int unit,
	uint32 flags,
	bcm_module_t modid,
	bcm_fabric_module_control_t control,
	int value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MODULE_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_module_control_set.unit = unit;
	async->args.fabric_module_control_set.flags = flags;
	async->args.fabric_module_control_set.modid = modid;
	async->args.fabric_module_control_set.control = control;
	async->args.fabric_module_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_multicast_get_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	int destid_count_max,
	int * destid_count,
	bcm_module_t * destid_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MULTICAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_multicast_get.unit = unit;
	async->args.fabric_multicast_get.group = group;
	async->args.fabric_multicast_get.flags = flags;
	async->args.fabric_multicast_get.destid_count_max = destid_count_max;
	async->args.fabric_multicast_get.destid_count = destid_count;
	async->args.fabric_multicast_get.destid_array = destid_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_multicast_multi_get_async(
	int unit,
	uint32 flags,
	uint32 ngroups,
	bcm_multicast_t * groups,
	bcm_fabric_module_vector_t * dest_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MULTICAST_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_multicast_multi_get.unit = unit;
	async->args.fabric_multicast_multi_get.flags = flags;
	async->args.fabric_multicast_multi_get.ngroups = ngroups;
	async->args.fabric_multicast_multi_get.groups = groups;
	async->args.fabric_multicast_multi_get.dest_array = dest_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_multicast_multi_set_async(
	int unit,
	uint32 flags,
	uint32 ngroups,
	bcm_multicast_t * groups,
	bcm_fabric_module_vector_t * dest_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MULTICAST_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_multicast_multi_set.unit = unit;
	async->args.fabric_multicast_multi_set.flags = flags;
	async->args.fabric_multicast_multi_set.ngroups = ngroups;
	async->args.fabric_multicast_multi_set.groups = groups;
	async->args.fabric_multicast_multi_set.dest_array = dest_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_multicast_set_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	uint32 destid_count,
	bcm_module_t * destid_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_MULTICAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_multicast_set.unit = unit;
	async->args.fabric_multicast_set.group = group;
	async->args.fabric_multicast_set.flags = flags;
	async->args.fabric_multicast_set.destid_count = destid_count;
	async->args.fabric_multicast_set.destid_array = destid_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_operating_interval_get_async(
	int unit,
	int link_fail_count,
	int * operating_interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_OPERATING_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_operating_interval_get.unit = unit;
	async->args.fabric_operating_interval_get.link_fail_count = link_fail_count;
	async->args.fabric_operating_interval_get.operating_interval = operating_interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_packet_adjust_get_async(
	int unit,
	int pkt_adjust_selector,
	int * pkt_adjust_len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PACKET_ADJUST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_packet_adjust_get.unit = unit;
	async->args.fabric_packet_adjust_get.pkt_adjust_selector = pkt_adjust_selector;
	async->args.fabric_packet_adjust_get.pkt_adjust_len = pkt_adjust_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_packet_adjust_set_async(
	int unit,
	int pkt_adjust_selector,
	int pkt_adjust_len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PACKET_ADJUST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_packet_adjust_set.unit = unit;
	async->args.fabric_packet_adjust_set.pkt_adjust_selector = pkt_adjust_selector;
	async->args.fabric_packet_adjust_set.pkt_adjust_len = pkt_adjust_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_pcp_dest_mode_config_get_async(
	int unit,
	uint32 flags,
	bcm_module_t modid,
	bcm_fabric_pcp_mode_config_t * pcp_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PCP_DEST_MODE_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_pcp_dest_mode_config_get.unit = unit;
	async->args.fabric_pcp_dest_mode_config_get.flags = flags;
	async->args.fabric_pcp_dest_mode_config_get.modid = modid;
	async->args.fabric_pcp_dest_mode_config_get.pcp_config = pcp_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_pcp_dest_mode_config_set_async(
	int unit,
	uint32 flags,
	bcm_module_t modid,
	bcm_fabric_pcp_mode_config_t * pcp_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PCP_DEST_MODE_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_pcp_dest_mode_config_set.unit = unit;
	async->args.fabric_pcp_dest_mode_config_set.flags = flags;
	async->args.fabric_pcp_dest_mode_config_set.modid = modid;
	async->args.fabric_pcp_dest_mode_config_set.pcp_config = pcp_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_port_create_async(
	int unit,
	bcm_gport_t parent_port,
	int offset,
	uint32 flags,
	bcm_gport_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PORT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_port_create.unit = unit;
	async->args.fabric_port_create.parent_port = parent_port;
	async->args.fabric_port_create.offset = offset;
	async->args.fabric_port_create.flags = flags;
	async->args.fabric_port_create.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_port_destroy_async(
	int unit,
	bcm_gport_t parent_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PORT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_port_destroy.unit = unit;
	async->args.fabric_port_destroy.parent_port = parent_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_port_failover_get_async(
	int unit,
	bcm_gport_t port,
	bcm_failover_t * failover_id,
	bcm_gport_t * failover_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PORT_FAILOVER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_port_failover_get.unit = unit;
	async->args.fabric_port_failover_get.port = port;
	async->args.fabric_port_failover_get.failover_id = failover_id;
	async->args.fabric_port_failover_get.failover_port = failover_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_port_failover_set_async(
	int unit,
	bcm_gport_t port,
	bcm_failover_t failover_id,
	bcm_gport_t failover_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PORT_FAILOVER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_port_failover_set.unit = unit;
	async->args.fabric_port_failover_set.port = port;
	async->args.fabric_port_failover_set.failover_id = failover_id;
	async->args.fabric_port_failover_set.failover_port = failover_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_port_get_async(
	int unit,
	bcm_gport_t child_port,
	uint32 flags,
	bcm_gport_t * parent_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_port_get.unit = unit;
	async->args.fabric_port_get.child_port = child_port;
	async->args.fabric_port_get.flags = flags;
	async->args.fabric_port_get.parent_port = parent_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_action_create_async(
	int unit,
	bcm_fabric_predicate_action_info_t * predicate_action,
	bcm_fabric_predicate_action_t * predicate_action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_ACTION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_action_create.unit = unit;
	async->args.fabric_predicate_action_create.predicate_action = predicate_action;
	async->args.fabric_predicate_action_create.predicate_action_id = predicate_action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_action_destroy_async(
	int unit,
	bcm_fabric_predicate_action_t predicate_action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_ACTION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_action_destroy.unit = unit;
	async->args.fabric_predicate_action_destroy.predicate_action_id = predicate_action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_action_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_ACTION_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_action_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_action_get_async(
	int unit,
	bcm_fabric_predicate_action_t predicate_action_id,
	bcm_fabric_predicate_action_info_t * predicate_action_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_action_get.unit = unit;
	async->args.fabric_predicate_action_get.predicate_action_id = predicate_action_id;
	async->args.fabric_predicate_action_get.predicate_action_info = predicate_action_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_action_traverse_async(
	int unit,
	bcm_fabric_predicate_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_action_traverse.unit = unit;
	async->args.fabric_predicate_action_traverse.cb = cb;
	async->args.fabric_predicate_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_create_async(
	int unit,
	bcm_fabric_predicate_info_t * pred_info,
	bcm_fabric_predicate_t * pred_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_create.unit = unit;
	async->args.fabric_predicate_create.pred_info = pred_info;
	async->args.fabric_predicate_create.pred_id = pred_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_destroy_async(
	int unit,
	bcm_fabric_predicate_t pred_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_destroy.unit = unit;
	async->args.fabric_predicate_destroy.pred_id = pred_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_get_async(
	int unit,
	bcm_fabric_predicate_t pred_id,
	bcm_fabric_predicate_info_t * pred_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_get.unit = unit;
	async->args.fabric_predicate_get.pred_id = pred_id;
	async->args.fabric_predicate_get.pred_info = pred_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_predicate_traverse_async(
	int unit,
	bcm_fabric_predicate_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PREDICATE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_predicate_traverse.unit = unit;
	async->args.fabric_predicate_traverse.cb = cb;
	async->args.fabric_predicate_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_priority_get_async(
	int unit,
	uint32 flags,
	bcm_cos_t ingress_pri,
	bcm_color_t color,
	int * fabric_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_priority_get.unit = unit;
	async->args.fabric_priority_get.flags = flags;
	async->args.fabric_priority_get.ingress_pri = ingress_pri;
	async->args.fabric_priority_get.color = color;
	async->args.fabric_priority_get.fabric_priority = fabric_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_priority_set_async(
	int unit,
	uint32 flags,
	bcm_cos_t ingress_pri,
	bcm_color_t color,
	int fabric_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_priority_set.unit = unit;
	async->args.fabric_priority_set.flags = flags;
	async->args.fabric_priority_set.ingress_pri = ingress_pri;
	async->args.fabric_priority_set.color = color;
	async->args.fabric_priority_set.fabric_priority = fabric_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_create_async(
	int unit,
	uint32 flags,
	int base,
	int count,
	bcm_fabric_qsel_t * qsel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_create.unit = unit;
	async->args.fabric_qsel_create.flags = flags;
	async->args.fabric_qsel_create.base = base;
	async->args.fabric_qsel_create.count = count;
	async->args.fabric_qsel_create.qsel_id = qsel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_destroy_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_destroy.unit = unit;
	async->args.fabric_qsel_destroy.qsel_id = qsel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_entry_get_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	int offset,
	bcm_gport_t * queue,
	bcm_fabric_qsel_offset_t * qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_entry_get.unit = unit;
	async->args.fabric_qsel_entry_get.qsel_id = qsel_id;
	async->args.fabric_qsel_entry_get.offset = offset;
	async->args.fabric_qsel_entry_get.queue = queue;
	async->args.fabric_qsel_entry_get.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_entry_multi_get_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	int offset,
	int count,
	bcm_gport_t * queue,
	bcm_fabric_qsel_offset_t * qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_ENTRY_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_entry_multi_get.unit = unit;
	async->args.fabric_qsel_entry_multi_get.qsel_id = qsel_id;
	async->args.fabric_qsel_entry_multi_get.offset = offset;
	async->args.fabric_qsel_entry_multi_get.count = count;
	async->args.fabric_qsel_entry_multi_get.queue = queue;
	async->args.fabric_qsel_entry_multi_get.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_entry_multi_set_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	int offset,
	int count,
	bcm_gport_t * queue,
	bcm_fabric_qsel_offset_t * qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_ENTRY_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_entry_multi_set.unit = unit;
	async->args.fabric_qsel_entry_multi_set.qsel_id = qsel_id;
	async->args.fabric_qsel_entry_multi_set.offset = offset;
	async->args.fabric_qsel_entry_multi_set.count = count;
	async->args.fabric_qsel_entry_multi_set.queue = queue;
	async->args.fabric_qsel_entry_multi_set.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_entry_set_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	int offset,
	bcm_gport_t queue,
	bcm_fabric_qsel_offset_t qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_ENTRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_entry_set.unit = unit;
	async->args.fabric_qsel_entry_set.qsel_id = qsel_id;
	async->args.fabric_qsel_entry_set.offset = offset;
	async->args.fabric_qsel_entry_set.queue = queue;
	async->args.fabric_qsel_entry_set.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_entry_traverse_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	bcm_fabric_qsel_entry_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_ENTRY_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_entry_traverse.unit = unit;
	async->args.fabric_qsel_entry_traverse.qsel_id = qsel_id;
	async->args.fabric_qsel_entry_traverse.cb = cb;
	async->args.fabric_qsel_entry_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_get_async(
	int unit,
	bcm_fabric_qsel_t qsel_id,
	uint32 * flags,
	int * base,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_get.unit = unit;
	async->args.fabric_qsel_get.qsel_id = qsel_id;
	async->args.fabric_qsel_get.flags = flags;
	async->args.fabric_qsel_get.base = base;
	async->args.fabric_qsel_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_create_async(
	int unit,
	uint32 flags,
	bcm_fabric_qsel_offset_t * qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_create.unit = unit;
	async->args.fabric_qsel_offset_create.flags = flags;
	async->args.fabric_qsel_offset_create.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_destroy_async(
	int unit,
	bcm_fabric_qsel_offset_t qsel_offset_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_destroy.unit = unit;
	async->args.fabric_qsel_offset_destroy.qsel_offset_id = qsel_offset_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_entry_get_async(
	int unit,
	bcm_fabric_qsel_offset_t qsel_offset_id,
	bcm_cos_t int_pri,
	int * offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_entry_get.unit = unit;
	async->args.fabric_qsel_offset_entry_get.qsel_offset_id = qsel_offset_id;
	async->args.fabric_qsel_offset_entry_get.int_pri = int_pri;
	async->args.fabric_qsel_offset_entry_get.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_entry_set_async(
	int unit,
	bcm_fabric_qsel_offset_t qsel_offset_id,
	bcm_cos_t int_pri,
	int offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_ENTRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_entry_set.unit = unit;
	async->args.fabric_qsel_offset_entry_set.qsel_offset_id = qsel_offset_id;
	async->args.fabric_qsel_offset_entry_set.int_pri = int_pri;
	async->args.fabric_qsel_offset_entry_set.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_entry_traverse_async(
	int unit,
	bcm_fabric_qsel_offset_t qsel_offset_id,
	bcm_fabric_qsel_offset_entry_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_ENTRY_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_entry_traverse.unit = unit;
	async->args.fabric_qsel_offset_entry_traverse.qsel_offset_id = qsel_offset_id;
	async->args.fabric_qsel_offset_entry_traverse.cb = cb;
	async->args.fabric_qsel_offset_entry_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_offset_traverse_async(
	int unit,
	bcm_fabric_qsel_offset_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_OFFSET_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_offset_traverse.unit = unit;
	async->args.fabric_qsel_offset_traverse.cb = cb;
	async->args.fabric_qsel_offset_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_qsel_traverse_async(
	int unit,
	bcm_fabric_qsel_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_QSEL_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_qsel_traverse.unit = unit;
	async->args.fabric_qsel_traverse.cb = cb;
	async->args.fabric_qsel_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_rci_config_get_async(
	int unit,
	bcm_fabric_rci_config_t * rci_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_RCI_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_rci_config_get.unit = unit;
	async->args.fabric_rci_config_get.rci_config = rci_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_rci_config_set_async(
	int unit,
	bcm_fabric_rci_config_t rci_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_RCI_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_rci_config_set.unit = unit;
	async->args.fabric_rci_config_set.rci_config = rci_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_reachability_status_get_async(
	int unit,
	int moduleid,
	int links_max,
	uint32 * links_array,
	int * links_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_REACHABILITY_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_reachability_status_get.unit = unit;
	async->args.fabric_reachability_status_get.moduleid = moduleid;
	async->args.fabric_reachability_status_get.links_max = links_max;
	async->args.fabric_reachability_status_get.links_array = links_array;
	async->args.fabric_reachability_status_get.links_count = links_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_route_rx_async(
	int unit,
	uint32 flags,
	uint32 data_out_max_size,
	uint32 * data_out,
	uint32 * data_out_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ROUTE_RX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_route_rx.unit = unit;
	async->args.fabric_route_rx.flags = flags;
	async->args.fabric_route_rx.data_out_max_size = data_out_max_size;
	async->args.fabric_route_rx.data_out = data_out;
	async->args.fabric_route_rx.data_out_size = data_out_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_route_tx_async(
	int unit,
	uint32 flags,
	bcm_fabric_route_t * route,
	uint32 data_in_size,
	uint32 * data_in,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_ROUTE_TX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_route_tx.unit = unit;
	async->args.fabric_route_tx.flags = flags;
	async->args.fabric_route_tx.route = route;
	async->args.fabric_route_tx.data_in_size = data_in_size;
	async->args.fabric_route_tx.data_in = data_in;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_static_replication_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 destid_count,
	bcm_module_t * destid_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_STATIC_REPLICATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_static_replication_set.unit = unit;
	async->args.fabric_static_replication_set.port = port;
	async->args.fabric_static_replication_set.flags = flags;
	async->args.fabric_static_replication_set.destid_count = destid_count;
	async->args.fabric_static_replication_set.destid_array = destid_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_direct_routing_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_fabric_tdm_direct_routing_t * routing_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_DIRECT_ROUTING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_direct_routing_get.unit = unit;
	async->args.fabric_tdm_direct_routing_get.gport = gport;
	async->args.fabric_tdm_direct_routing_get.routing_info = routing_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_direct_routing_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_fabric_tdm_direct_routing_t * routing_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_DIRECT_ROUTING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_direct_routing_set.unit = unit;
	async->args.fabric_tdm_direct_routing_set.gport = gport;
	async->args.fabric_tdm_direct_routing_set.routing_info = routing_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_editing_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_fabric_tdm_editing_t * editing,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_EDITING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_editing_get.unit = unit;
	async->args.fabric_tdm_editing_get.gport = gport;
	async->args.fabric_tdm_editing_get.editing = editing;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_editing_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_fabric_tdm_editing_t * editing,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_EDITING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_editing_set.unit = unit;
	async->args.fabric_tdm_editing_set.gport = gport;
	async->args.fabric_tdm_editing_set.editing = editing;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_enable_get_async(
	int unit,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_enable_get.unit = unit;
	async->args.fabric_tdm_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fabric_tdm_enable_set_async(
	int unit,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FABRIC_TDM_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fabric_tdm_enable_set.unit = unit;
	async->args.fabric_tdm_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_failover_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_create_async(
	int unit,
	uint32 flags,
	bcm_failover_t * failover_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_create.unit = unit;
	async->args.failover_create.flags = flags;
	async->args.failover_create.failover_id = failover_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_destroy_async(
	int unit,
	bcm_failover_t failover_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_destroy.unit = unit;
	async->args.failover_destroy.failover_id = failover_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_get_async(
	int unit,
	bcm_failover_t failover_id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_get.unit = unit;
	async->args.failover_get.failover_id = failover_id;
	async->args.failover_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_multi_level_attach_async(
	int unit,
	bcm_failover_multi_level_t multi_level_failover,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_MULTI_LEVEL_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_multi_level_attach.unit = unit;
	async->args.failover_multi_level_attach.multi_level_failover = multi_level_failover;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_failover_ring_config_get_async(
	int unit,
	bcm_failover_ring_t * failover_ring,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_RING_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_ring_config_get.unit = unit;
	async->args.failover_ring_config_get.failover_ring = failover_ring;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_ring_config_set_async(
	int unit,
	bcm_failover_ring_t * failover_ring,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_RING_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_ring_config_set.unit = unit;
	async->args.failover_ring_config_set.failover_ring = failover_ring;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_failover_set_async(
	int unit,
	bcm_failover_t failover_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_set.unit = unit;
	async->args.failover_set.failover_id = failover_id;
	async->args.failover_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_status_get_async(
	int unit,
	bcm_failover_element_t * failover,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_status_get.unit = unit;
	async->args.failover_status_get.failover = failover;
	async->args.failover_status_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_failover_status_set_async(
	int unit,
	bcm_failover_element_t * failover,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FAILOVER_STATUS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_status_set.unit = unit;
	async->args.failover_status_set.failover = failover;
	async->args.failover_status_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */
#ifdef	INCLUDE_FCMAP

void
bcm_fcmap_diag_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_diag_code_t * diag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_DIAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_diag_get.unit = unit;
	async->args.fcmap_diag_get.port = port;
	async->args.fcmap_diag_get.diag = diag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_event_enable_get_async(
	int unit,
	bcm_fcmap_event_t t,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_EVENT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_event_enable_get.unit = unit;
	async->args.fcmap_event_enable_get.t = t;
	async->args.fcmap_event_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_event_enable_set_async(
	int unit,
	bcm_fcmap_event_t t,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_EVENT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_event_enable_set.unit = unit;
	async->args.fcmap_event_enable_set.t = t;
	async->args.fcmap_event_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_event_register_async(
	int unit,
	bcm_fcmap_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_event_register.unit = unit;
	async->args.fcmap_event_register.cb = cb;
	async->args.fcmap_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_event_unregister_async(
	int unit,
	bcm_fcmap_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_event_unregister.unit = unit;
	async->args.fcmap_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_linkfault_trigger_rc_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_lf_tr_t * trigger,
	bcm_fcmap_lf_rc_t * rc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_LINKFAULT_TRIGGER_RC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_linkfault_trigger_rc_get.unit = unit;
	async->args.fcmap_linkfault_trigger_rc_get.port = port;
	async->args.fcmap_linkfault_trigger_rc_get.trigger = trigger;
	async->args.fcmap_linkfault_trigger_rc_get.rc = rc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_ability_advert_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_ability_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_ABILITY_ADVERT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_ability_advert_get.unit = unit;
	async->args.fcmap_port_ability_advert_get.port = port;
	async->args.fcmap_port_ability_advert_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_ability_advert_set_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_ability_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_ABILITY_ADVERT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_ability_advert_set.unit = unit;
	async->args.fcmap_port_ability_advert_set.port = port;
	async->args.fcmap_port_ability_advert_set.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_config_get.unit = unit;
	async->args.fcmap_port_config_get.port = port;
	async->args.fcmap_port_config_get.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_config_selective_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_CONFIG_SELECTIVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_config_selective_get.unit = unit;
	async->args.fcmap_port_config_selective_get.port = port;
	async->args.fcmap_port_config_selective_get.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_config_selective_set_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_CONFIG_SELECTIVE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_config_selective_set.unit = unit;
	async->args.fcmap_port_config_selective_set.port = port;
	async->args.fcmap_port_config_selective_set.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_config_set.unit = unit;
	async->args.fcmap_port_config_set.port = port;
	async->args.fcmap_port_config_set.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_enable_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_enable.unit = unit;
	async->args.fcmap_port_enable.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_link_reset_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_LINK_RESET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_link_reset.unit = unit;
	async->args.fcmap_port_link_reset.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_shutdown_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_SHUTDOWN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_shutdown.unit = unit;
	async->args.fcmap_port_shutdown.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_speed_set_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_port_speed_t speed,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_SPEED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_speed_set.unit = unit;
	async->args.fcmap_port_speed_set.port = port;
	async->args.fcmap_port_speed_set.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_port_traverse_async(
	int unit,
	bcm_fcmap_port_traverse_cb callbk,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_port_traverse.unit = unit;
	async->args.fcmap_port_traverse.callbk = callbk;
	async->args.fcmap_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_stat_clear_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_stat_clear.unit = unit;
	async->args.fcmap_stat_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_stat_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_stat_get.unit = unit;
	async->args.fcmap_stat_get.port = port;
	async->args.fcmap_stat_get.stat = stat;
	async->args.fcmap_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_stat_get32_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_stat_get32.unit = unit;
	async->args.fcmap_stat_get32.port = port;
	async->args.fcmap_stat_get32.stat = stat;
	async->args.fcmap_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_vlan_map_add_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_vlan_vsan_map_t * vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_VLAN_MAP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_vlan_map_add.unit = unit;
	async->args.fcmap_vlan_map_add.port = port;
	async->args.fcmap_vlan_map_add.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_vlan_map_delete_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_vlan_vsan_map_t * vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_VLAN_MAP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_vlan_map_delete.unit = unit;
	async->args.fcmap_vlan_map_delete.port = port;
	async->args.fcmap_vlan_map_delete.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcmap_vlan_map_get_async(
	int unit,
	bcm_port_t port,
	bcm_fcmap_vlan_vsan_map_t * vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCMAP_VLAN_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcmap_vlan_map_get.unit = unit;
	async->args.fcmap_vlan_map_get.port = port;
	async->args.fcmap_vlan_map_get.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_FCMAP */

void
bcm_fcoe_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_control_vsan_get_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan_id,
	bcm_fcoe_vsan_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_CONTROL_VSAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_control_vsan_get.unit = unit;
	async->args.fcoe_control_vsan_get.vsan_id = vsan_id;
	async->args.fcoe_control_vsan_get.type = type;
	async->args.fcoe_control_vsan_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_control_vsan_set_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan_id,
	bcm_fcoe_vsan_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_CONTROL_VSAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_control_vsan_set.unit = unit;
	async->args.fcoe_control_vsan_set.vsan_id = vsan_id;
	async->args.fcoe_control_vsan_set.type = type;
	async->args.fcoe_control_vsan_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_enable_set_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_enable_set.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_fc_header_type_get_async(
	int unit,
	uint32 flags,
	uint8 r_ctl,
	bcm_fcoe_fc_header_type_t * hdr_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_FC_HEADER_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_fc_header_type_get.unit = unit;
	async->args.fcoe_fc_header_type_get.flags = flags;
	async->args.fcoe_fc_header_type_get.r_ctl = r_ctl;
	async->args.fcoe_fc_header_type_get.hdr_type = hdr_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_fc_header_type_set_async(
	int unit,
	uint32 flags,
	uint8 r_ctl,
	bcm_fcoe_fc_header_type_t hdr_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_FC_HEADER_TYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_fc_header_type_set.unit = unit;
	async->args.fcoe_fc_header_type_set.flags = flags;
	async->args.fcoe_fc_header_type_set.r_ctl = r_ctl;
	async->args.fcoe_fc_header_type_set.hdr_type = hdr_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_intf_config_get_async(
	int unit,
	uint32 flags,
	bcm_if_t intf,
	bcm_fcoe_intf_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_INTF_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_intf_config_get.unit = unit;
	async->args.fcoe_intf_config_get.flags = flags;
	async->args.fcoe_intf_config_get.intf = intf;
	async->args.fcoe_intf_config_get.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_intf_config_set_async(
	int unit,
	uint32 flags,
	bcm_if_t intf,
	bcm_fcoe_intf_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_INTF_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_intf_config_set.unit = unit;
	async->args.fcoe_intf_config_set.flags = flags;
	async->args.fcoe_intf_config_set.intf = intf;
	async->args.fcoe_intf_config_set.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_add_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_add.unit = unit;
	async->args.fcoe_route_add.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_delete_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_delete.unit = unit;
	async->args.fcoe_route_delete.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_delete_by_interface_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_DELETE_BY_INTERFACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_delete_by_interface.unit = unit;
	async->args.fcoe_route_delete_by_interface.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_delete_by_prefix_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_DELETE_BY_PREFIX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_delete_by_prefix.unit = unit;
	async->args.fcoe_route_delete_by_prefix.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_find_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_find.unit = unit;
	async->args.fcoe_route_find.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_attach_async(
	int unit,
	bcm_fcoe_route_t * route,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_attach.unit = unit;
	async->args.fcoe_route_stat_attach.route = route;
	async->args.fcoe_route_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_counter_get_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_fcoe_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_counter_get.unit = unit;
	async->args.fcoe_route_stat_counter_get.route = route;
	async->args.fcoe_route_stat_counter_get.stat = stat;
	async->args.fcoe_route_stat_counter_get.num_entries = num_entries;
	async->args.fcoe_route_stat_counter_get.counter_indexes = counter_indexes;
	async->args.fcoe_route_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_counter_set_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_fcoe_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_counter_set.unit = unit;
	async->args.fcoe_route_stat_counter_set.route = route;
	async->args.fcoe_route_stat_counter_set.stat = stat;
	async->args.fcoe_route_stat_counter_set.num_entries = num_entries;
	async->args.fcoe_route_stat_counter_set.counter_indexes = counter_indexes;
	async->args.fcoe_route_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_counter_sync_get_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_fcoe_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_counter_sync_get.unit = unit;
	async->args.fcoe_route_stat_counter_sync_get.route = route;
	async->args.fcoe_route_stat_counter_sync_get.stat = stat;
	async->args.fcoe_route_stat_counter_sync_get.num_entries = num_entries;
	async->args.fcoe_route_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.fcoe_route_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_detach_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_detach.unit = unit;
	async->args.fcoe_route_stat_detach.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_stat_id_get_async(
	int unit,
	bcm_fcoe_route_t * route,
	bcm_fcoe_route_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_stat_id_get.unit = unit;
	async->args.fcoe_route_stat_id_get.route = route;
	async->args.fcoe_route_stat_id_get.stat = stat;
	async->args.fcoe_route_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_route_traverse_async(
	int unit,
	uint32 flags,
	bcm_fcoe_route_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ROUTE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_route_traverse.unit = unit;
	async->args.fcoe_route_traverse.flags = flags;
	async->args.fcoe_route_traverse.trav_fn = trav_fn;
	async->args.fcoe_route_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_create_async(
	int unit,
	uint32 options,
	bcm_fcoe_vsan_t * vsan,
	bcm_fcoe_vsan_id_t * vsan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_create.unit = unit;
	async->args.fcoe_vsan_create.options = options;
	async->args.fcoe_vsan_create.vsan = vsan;
	async->args.fcoe_vsan_create.vsan_id = vsan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_destroy_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_destroy.unit = unit;
	async->args.fcoe_vsan_destroy.vsan_id = vsan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_get_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan_id,
	bcm_fcoe_vsan_t * vsan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_get.unit = unit;
	async->args.fcoe_vsan_get.vsan_id = vsan_id;
	async->args.fcoe_vsan_get.vsan = vsan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_set_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan_id,
	bcm_fcoe_vsan_t * vsan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_set.unit = unit;
	async->args.fcoe_vsan_set.vsan_id = vsan_id;
	async->args.fcoe_vsan_set.vsan = vsan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_attach_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_attach.unit = unit;
	async->args.fcoe_vsan_stat_attach.vsan = vsan;
	async->args.fcoe_vsan_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_counter_get_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	bcm_fcoe_vsan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_counter_get.unit = unit;
	async->args.fcoe_vsan_stat_counter_get.vsan = vsan;
	async->args.fcoe_vsan_stat_counter_get.stat = stat;
	async->args.fcoe_vsan_stat_counter_get.num_entries = num_entries;
	async->args.fcoe_vsan_stat_counter_get.counter_indexes = counter_indexes;
	async->args.fcoe_vsan_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_counter_set_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	bcm_fcoe_vsan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_counter_set.unit = unit;
	async->args.fcoe_vsan_stat_counter_set.vsan = vsan;
	async->args.fcoe_vsan_stat_counter_set.stat = stat;
	async->args.fcoe_vsan_stat_counter_set.num_entries = num_entries;
	async->args.fcoe_vsan_stat_counter_set.counter_indexes = counter_indexes;
	async->args.fcoe_vsan_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_counter_sync_get_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	bcm_fcoe_vsan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_counter_sync_get.unit = unit;
	async->args.fcoe_vsan_stat_counter_sync_get.vsan = vsan;
	async->args.fcoe_vsan_stat_counter_sync_get.stat = stat;
	async->args.fcoe_vsan_stat_counter_sync_get.num_entries = num_entries;
	async->args.fcoe_vsan_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.fcoe_vsan_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_detach_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_detach.unit = unit;
	async->args.fcoe_vsan_stat_detach.vsan = vsan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_stat_id_get_async(
	int unit,
	bcm_fcoe_vsan_id_t vsan,
	bcm_fcoe_vsan_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_stat_id_get.unit = unit;
	async->args.fcoe_vsan_stat_id_get.vsan = vsan;
	async->args.fcoe_vsan_stat_id_get.stat = stat;
	async->args.fcoe_vsan_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_translate_action_add_async(
	int unit,
	bcm_fcoe_vsan_translate_key_config_t * key,
	bcm_fcoe_vsan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_TRANSLATE_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_translate_action_add.unit = unit;
	async->args.fcoe_vsan_translate_action_add.key = key;
	async->args.fcoe_vsan_translate_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_translate_action_delete_async(
	int unit,
	bcm_fcoe_vsan_translate_key_config_t * key,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_TRANSLATE_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_translate_action_delete.unit = unit;
	async->args.fcoe_vsan_translate_action_delete.key = key;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_vsan_traverse_async(
	int unit,
	uint32 flags,
	bcm_fcoe_vsan_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_VSAN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_vsan_traverse.unit = unit;
	async->args.fcoe_vsan_traverse.flags = flags;
	async->args.fcoe_vsan_traverse.trav_fn = trav_fn;
	async->args.fcoe_vsan_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_add_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_add.unit = unit;
	async->args.fcoe_zone_add.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_delete_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_delete.unit = unit;
	async->args.fcoe_zone_delete.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_delete_by_did_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_DELETE_BY_DID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_delete_by_did.unit = unit;
	async->args.fcoe_zone_delete_by_did.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_delete_by_sid_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_DELETE_BY_SID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_delete_by_sid.unit = unit;
	async->args.fcoe_zone_delete_by_sid.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_delete_by_vsan_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_DELETE_BY_VSAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_delete_by_vsan.unit = unit;
	async->args.fcoe_zone_delete_by_vsan.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_get_async(
	int unit,
	bcm_fcoe_zone_entry_t * zone,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_get.unit = unit;
	async->args.fcoe_zone_get.zone = zone;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_fcoe_zone_traverse_async(
	int unit,
	uint32 flags,
	bcm_fcoe_zone_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FCOE_ZONE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.fcoe_zone_traverse.unit = unit;
	async->args.fcoe_zone_traverse.flags = flags;
	async->args.fcoe_zone_traverse.trav_fn = trav_fn;
	async->args.fcoe_zone_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_add.unit = unit;
	async->args.field_action_add.entry = entry;
	async->args.field_action_add.action = action;
	async->args.field_action_add.param0 = param0;
	async->args.field_action_add.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_class_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_class_info_t * class_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_CLASS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_class_add.unit = unit;
	async->args.field_action_class_add.entry = entry;
	async->args.field_action_class_add.class_info = class_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_class_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_class_info_t * class_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_class_get.unit = unit;
	async->args.field_action_class_get.entry = entry;
	async->args.field_action_class_get.class_info = class_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_config_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	int core_config_arr_len,
	bcm_field_action_core_config_t * core_config_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_config_add.unit = unit;
	async->args.field_action_config_add.entry = entry;
	async->args.field_action_config_add.action = action;
	async->args.field_action_config_add.core_config_arr_len = core_config_arr_len;
	async->args.field_action_config_add.core_config_arr = core_config_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_copytocpu_config_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_CopyToCpu_config_t * CopyToCpu_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_COPYTOCPU_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_copytocpu_config_get.unit = unit;
	async->args.field_action_copytocpu_config_get.entry = entry;
	async->args.field_action_copytocpu_config_get.CopyToCpu_config = CopyToCpu_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_copytocpu_config_set_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_CopyToCpu_config_t CopyToCpu_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_COPYTOCPU_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_copytocpu_config_set.unit = unit;
	async->args.field_action_copytocpu_config_set.entry = entry;
	async->args.field_action_copytocpu_config_set.CopyToCpu_config = CopyToCpu_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_delete_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_delete.unit = unit;
	async->args.field_action_delete.entry = entry;
	async->args.field_action_delete.action = action;
	async->args.field_action_delete.param0 = param0;
	async->args.field_action_delete.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 * param0,
	uint32 * param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_get.unit = unit;
	async->args.field_action_get.entry = entry;
	async->args.field_action_get.action = action;
	async->args.field_action_get.param0 = param0;
	async->args.field_action_get.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_mac_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_MAC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_mac_add.unit = unit;
	async->args.field_action_mac_add.entry = entry;
	async->args.field_action_mac_add.action = action;
	async->args.field_action_mac_add.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_mac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_mac_get.unit = unit;
	async->args.field_action_mac_get.entry = entry;
	async->args.field_action_mac_get.action = action;
	async->args.field_action_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_ports_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_PORTS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_ports_add.unit = unit;
	async->args.field_action_ports_add.entry = entry;
	async->args.field_action_ports_add.action = action;
	async->args.field_action_ports_add.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_ports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_ports_get.unit = unit;
	async->args.field_action_ports_get.entry = entry;
	async->args.field_action_ports_get.action = action;
	async->args.field_action_ports_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_redirect_config_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_redirect_config_t * redirect_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_REDIRECT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_redirect_config_get.unit = unit;
	async->args.field_action_redirect_config_get.entry = entry;
	async->args.field_action_redirect_config_get.redirect_config = redirect_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_redirect_config_set_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_redirect_config_t redirect_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_REDIRECT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_redirect_config_set.unit = unit;
	async->args.field_action_redirect_config_set.entry = entry;
	async->args.field_action_redirect_config_set.redirect_config = redirect_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_remove_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_remove.unit = unit;
	async->args.field_action_remove.entry = entry;
	async->args.field_action_remove.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_remove_all_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_REMOVE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_remove_all.unit = unit;
	async->args.field_action_remove_all.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_width_get_async(
	int unit,
	uint32 flags,
	int internal_action,
	uint32 * width_p,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_WIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_width_get.unit = unit;
	async->args.field_action_width_get.flags = flags;
	async->args.field_action_width_get.internal_action = internal_action;
	async->args.field_action_width_get.width_p = width_p;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_action_width_set_async(
	int unit,
	uint32 flags,
	int internal_action,
	uint32 width,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ACTION_WIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_width_set.unit = unit;
	async->args.field_action_width_set.flags = flags;
	async->args.field_action_width_set.internal_action = internal_action;
	async->args.field_action_width_set.width = width;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_class_map_get_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_field_qualify_t qual,
	uint32 num_entries,
	uint32 * orig_values_array,
	uint32 * map_values_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_CLASS_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_class_map_get.unit = unit;
	async->args.field_class_map_get.stage = stage;
	async->args.field_class_map_get.qual = qual;
	async->args.field_class_map_get.num_entries = num_entries;
	async->args.field_class_map_get.orig_values_array = orig_values_array;
	async->args.field_class_map_get.map_values_array = map_values_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_class_map_set_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_field_qualify_t qual,
	uint32 num_entries,
	uint32 * orig_values_array,
	uint32 * map_values_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_CLASS_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_class_map_set.unit = unit;
	async->args.field_class_map_set.stage = stage;
	async->args.field_class_map_set.qual = qual;
	async->args.field_class_map_set.num_entries = num_entries;
	async->args.field_class_map_set.orig_values_array = orig_values_array;
	async->args.field_class_map_set.map_values_array = map_values_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_class_size_get_async(
	int unit,
	bcm_field_qualify_t qual,
	uint16 * class_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_CLASS_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_class_size_get.unit = unit;
	async->args.field_class_size_get.qual = qual;
	async->args.field_class_size_get.class_size = class_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_control_get_async(
	int unit,
	bcm_field_control_t control,
	uint32 * state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_control_get.unit = unit;
	async->args.field_control_get.control = control;
	async->args.field_control_get.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_control_set_async(
	int unit,
	bcm_field_control_t control,
	uint32 state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_control_set.unit = unit;
	async->args.field_control_set.control = control;
	async->args.field_control_set.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_create_async(
	int unit,
	bcm_field_data_qualifier_t * data_qualifier,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_create.unit = unit;
	async->args.field_data_qualifier_create.data_qualifier = data_qualifier;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_destroy_async(
	int unit,
	int qual_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_destroy.unit = unit;
	async->args.field_data_qualifier_destroy.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_ethertype_add_async(
	int unit,
	int qual_id,
	bcm_field_data_ethertype_t * etype,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ethertype_add.unit = unit;
	async->args.field_data_qualifier_ethertype_add.qual_id = qual_id;
	async->args.field_data_qualifier_ethertype_add.etype = etype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_ethertype_delete_async(
	int unit,
	int qual_id,
	bcm_field_data_ethertype_t * etype,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ethertype_delete.unit = unit;
	async->args.field_data_qualifier_ethertype_delete.qual_id = qual_id;
	async->args.field_data_qualifier_ethertype_delete.etype = etype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_get_async(
	int unit,
	int qual_id,
	bcm_field_data_qualifier_t * qual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_get.unit = unit;
	async->args.field_data_qualifier_get.qual_id = qual_id;
	async->args.field_data_qualifier_get.qual = qual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_ip_protocol_add_async(
	int unit,
	int qual_id,
	bcm_field_data_ip_protocol_t * ip_protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ip_protocol_add.unit = unit;
	async->args.field_data_qualifier_ip_protocol_add.qual_id = qual_id;
	async->args.field_data_qualifier_ip_protocol_add.ip_protocol = ip_protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_ip_protocol_delete_async(
	int unit,
	int qual_id,
	bcm_field_data_ip_protocol_t * ip_protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ip_protocol_delete.unit = unit;
	async->args.field_data_qualifier_ip_protocol_delete.qual_id = qual_id;
	async->args.field_data_qualifier_ip_protocol_delete.ip_protocol = ip_protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_multi_get_async(
	int unit,
	int qual_size,
	int * qual_array,
	int * qual_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_multi_get.unit = unit;
	async->args.field_data_qualifier_multi_get.qual_size = qual_size;
	async->args.field_data_qualifier_multi_get.qual_array = qual_array;
	async->args.field_data_qualifier_multi_get.qual_count = qual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_packet_format_add_async(
	int unit,
	int qual_id,
	bcm_field_data_packet_format_t * packet_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_packet_format_add.unit = unit;
	async->args.field_data_qualifier_packet_format_add.qual_id = qual_id;
	async->args.field_data_qualifier_packet_format_add.packet_format = packet_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_data_qualifier_packet_format_delete_async(
	int unit,
	int qual_id,
	bcm_field_data_packet_format_t * packet_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_packet_format_delete.unit = unit;
	async->args.field_data_qualifier_packet_format_delete.qual_id = qual_id;
	async->args.field_data_qualifier_packet_format_delete.packet_format = packet_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_direct_extraction_action_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_extraction_action_t action,
	int count,
	bcm_field_extraction_field_t * extractions,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DIRECT_EXTRACTION_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_direct_extraction_action_add.unit = unit;
	async->args.field_direct_extraction_action_add.entry = entry;
	async->args.field_direct_extraction_action_add.action = action;
	async->args.field_direct_extraction_action_add.count = count;
	async->args.field_direct_extraction_action_add.extractions = extractions;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_direct_extraction_action_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_extraction_action_t * action,
	int max_count,
	bcm_field_extraction_field_t * extractions,
	int * actual_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_DIRECT_EXTRACTION_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_direct_extraction_action_get.unit = unit;
	async->args.field_direct_extraction_action_get.entry = entry;
	async->args.field_direct_extraction_action_get.action = action;
	async->args.field_direct_extraction_action_get.max_count = max_count;
	async->args.field_direct_extraction_action_get.extractions = extractions;
	async->args.field_direct_extraction_action_get.actual_count = actual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_copy_async(
	int unit,
	bcm_field_entry_t src_entry,
	bcm_field_entry_t * dst_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_COPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_copy.unit = unit;
	async->args.field_entry_copy.src_entry = src_entry;
	async->args.field_entry_copy.dst_entry = dst_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_copy_id_async(
	int unit,
	bcm_field_entry_t src_entry,
	bcm_field_entry_t dst_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_COPY_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_copy_id.unit = unit;
	async->args.field_entry_copy_id.src_entry = src_entry;
	async->args.field_entry_copy_id.dst_entry = dst_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_create_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_entry_t * entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_create.unit = unit;
	async->args.field_entry_create.group = group;
	async->args.field_entry_create.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_create_id_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_create_id.unit = unit;
	async->args.field_entry_create_id.group = group;
	async->args.field_entry_create_id.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_destroy_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_destroy.unit = unit;
	async->args.field_entry_destroy.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_field_entry_dump_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_dump.unit = unit;
	async->args.field_entry_dump.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_field_entry_enable_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * enable_flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_enable_get.unit = unit;
	async->args.field_entry_enable_get.entry = entry;
	async->args.field_entry_enable_get.enable_flag = enable_flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_enable_set_async(
	int unit,
	bcm_field_entry_t entry,
	int enable_flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_enable_set.unit = unit;
	async->args.field_entry_enable_set.entry = entry;
	async->args.field_entry_enable_set.enable_flag = enable_flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_install_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_INSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_install.unit = unit;
	async->args.field_entry_install.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_multi_get_async(
	int unit,
	bcm_field_group_t group,
	int entry_size,
	bcm_field_entry_t * entry_array,
	int * entry_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_multi_get.unit = unit;
	async->args.field_entry_multi_get.group = group;
	async->args.field_entry_multi_get.entry_size = entry_size;
	async->args.field_entry_multi_get.entry_array = entry_array;
	async->args.field_entry_multi_get.entry_count = entry_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_operation_async(
	int unit,
	bcm_field_entry_oper_t * entry_oper,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_OPERATION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_operation.unit = unit;
	async->args.field_entry_operation.entry_oper = entry_oper;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_policer_attach_async(
	int unit,
	bcm_field_entry_t entry_id,
	int level,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_attach.unit = unit;
	async->args.field_entry_policer_attach.entry_id = entry_id;
	async->args.field_entry_policer_attach.level = level;
	async->args.field_entry_policer_attach.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_policer_detach_async(
	int unit,
	bcm_field_entry_t entry_id,
	int level,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_detach.unit = unit;
	async->args.field_entry_policer_detach.entry_id = entry_id;
	async->args.field_entry_policer_detach.level = level;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_policer_detach_all_async(
	int unit,
	bcm_field_entry_t entry_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_detach_all.unit = unit;
	async->args.field_entry_policer_detach_all.entry_id = entry_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_policer_get_async(
	int unit,
	bcm_field_entry_t entry_id,
	int level,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_get.unit = unit;
	async->args.field_entry_policer_get.entry_id = entry_id;
	async->args.field_entry_policer_get.level = level;
	async->args.field_entry_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_prio_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_PRIO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_prio_get.unit = unit;
	async->args.field_entry_prio_get.entry = entry;
	async->args.field_entry_prio_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_prio_set_async(
	int unit,
	bcm_field_entry_t entry,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_PRIO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_prio_set.unit = unit;
	async->args.field_entry_prio_set.entry = entry;
	async->args.field_entry_prio_set.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_reinstall_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_REINSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_reinstall.unit = unit;
	async->args.field_entry_reinstall.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_remove_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_remove.unit = unit;
	async->args.field_entry_remove.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_stat_attach_async(
	int unit,
	bcm_field_entry_t entry,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_attach.unit = unit;
	async->args.field_entry_stat_attach.entry = entry;
	async->args.field_entry_stat_attach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_stat_detach_async(
	int unit,
	bcm_field_entry_t entry,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_detach.unit = unit;
	async->args.field_entry_stat_detach.entry = entry;
	async->args.field_entry_stat_detach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_stat_extended_attach_async(
	int unit,
	bcm_field_entry_t entry,
	int stat_id,
	bcm_field_stat_action_t stat_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_EXTENDED_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_extended_attach.unit = unit;
	async->args.field_entry_stat_extended_attach.entry = entry;
	async->args.field_entry_stat_extended_attach.stat_id = stat_id;
	async->args.field_entry_stat_extended_attach.stat_action = stat_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_stat_extended_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * stat_id,
	bcm_field_stat_action_t * stat_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_EXTENDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_extended_get.unit = unit;
	async->args.field_entry_stat_extended_get.entry = entry;
	async->args.field_entry_stat_extended_get.stat_id = stat_id;
	async->args.field_entry_stat_extended_get.stat_action = stat_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_entry_stat_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_get.unit = unit;
	async->args.field_entry_stat_get.entry = entry;
	async->args.field_entry_stat_get.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_action_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_aset_t * aset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_action_get.unit = unit;
	async->args.field_group_action_get.group = group;
	async->args.field_group_action_get.aset = aset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_action_set_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_aset_t aset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_ACTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_action_set.unit = unit;
	async->args.field_group_action_set.group = group;
	async->args.field_group_action_set.aset = aset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_compress_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_COMPRESS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_compress.unit = unit;
	async->args.field_group_compress.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_config_create_async(
	int unit,
	bcm_field_group_config_t * group_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CONFIG_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_config_create.unit = unit;
	async->args.field_group_config_create.group_config = group_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_config_validate_async(
	int unit,
	bcm_field_group_config_t * group_config,
	bcm_field_group_mode_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CONFIG_VALIDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_config_validate.unit = unit;
	async->args.field_group_config_validate.group_config = group_config;
	async->args.field_group_config_validate.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_create_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create.unit = unit;
	async->args.field_group_create.qset = qset;
	async->args.field_group_create.pri = pri;
	async->args.field_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_create_id_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_id.unit = unit;
	async->args.field_group_create_id.qset = qset;
	async->args.field_group_create_id.pri = pri;
	async->args.field_group_create_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_create_mode_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_mode.unit = unit;
	async->args.field_group_create_mode.qset = qset;
	async->args.field_group_create_mode.pri = pri;
	async->args.field_group_create_mode.mode = mode;
	async->args.field_group_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_create_mode_id_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_mode_id.unit = unit;
	async->args.field_group_create_mode_id.qset = qset;
	async->args.field_group_create_mode_id.pri = pri;
	async->args.field_group_create_mode_id.mode = mode;
	async->args.field_group_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_default_entry_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_entry_t * entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_DEFAULT_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_default_entry_get.unit = unit;
	async->args.field_group_default_entry_get.group = group;
	async->args.field_group_default_entry_get.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_default_entry_set_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_entry_t entry,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_DEFAULT_ENTRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_default_entry_set.unit = unit;
	async->args.field_group_default_entry_set.group = group;
	async->args.field_group_default_entry_set.entry = entry;
	async->args.field_group_default_entry_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_destroy_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_destroy.unit = unit;
	async->args.field_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_field_group_dump_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_dump.unit = unit;
	async->args.field_group_dump.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_field_group_enable_get_async(
	int unit,
	bcm_field_group_t group,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_enable_get.unit = unit;
	async->args.field_group_enable_get.group = group;
	async->args.field_group_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_enable_set_async(
	int unit,
	bcm_field_group_t group,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_enable_set.unit = unit;
	async->args.field_group_enable_set.group = group;
	async->args.field_group_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_expansion_enable_get_async(
	int unit,
	bcm_field_group_t group,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_EXPANSION_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_expansion_enable_get.unit = unit;
	async->args.field_group_expansion_enable_get.group = group;
	async->args.field_group_expansion_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_expansion_enable_set_async(
	int unit,
	bcm_field_group_t group,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_EXPANSION_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_expansion_enable_set.unit = unit;
	async->args.field_group_expansion_enable_set.group = group;
	async->args.field_group_expansion_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_flush_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_FLUSH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_flush.unit = unit;
	async->args.field_group_flush.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_qset_t * qset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_get.unit = unit;
	async->args.field_group_get.group = group;
	async->args.field_group_get.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_install_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_INSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_install.unit = unit;
	async->args.field_group_install.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_mode_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_group_mode_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_mode_get.unit = unit;
	async->args.field_group_mode_get.group = group;
	async->args.field_group_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_oper_mode_get_async(
	int unit,
	bcm_field_qualify_t stage,
	bcm_field_group_oper_mode_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_OPER_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_oper_mode_get.unit = unit;
	async->args.field_group_oper_mode_get.stage = stage;
	async->args.field_group_oper_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_oper_mode_set_async(
	int unit,
	bcm_field_qualify_t stage,
	bcm_field_group_oper_mode_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_OPER_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_oper_mode_set.unit = unit;
	async->args.field_group_oper_mode_set.stage = stage;
	async->args.field_group_oper_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_port_create_mode_async(
	int unit,
	bcm_port_t port,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_port_create_mode.unit = unit;
	async->args.field_group_port_create_mode.port = port;
	async->args.field_group_port_create_mode.qset = qset;
	async->args.field_group_port_create_mode.pri = pri;
	async->args.field_group_port_create_mode.mode = mode;
	async->args.field_group_port_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_port_create_mode_id_async(
	int unit,
	bcm_port_t port,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_port_create_mode_id.unit = unit;
	async->args.field_group_port_create_mode_id.port = port;
	async->args.field_group_port_create_mode_id.qset = qset;
	async->args.field_group_port_create_mode_id.pri = pri;
	async->args.field_group_port_create_mode_id.mode = mode;
	async->args.field_group_port_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_ports_add_async(
	int unit,
	bcm_field_group_t group,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_add.unit = unit;
	async->args.field_group_ports_add.group = group;
	async->args.field_group_ports_add.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_ports_create_mode_async(
	int unit,
	bcm_pbmp_t pbmp,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_create_mode.unit = unit;
	async->args.field_group_ports_create_mode.pbmp = pbmp;
	async->args.field_group_ports_create_mode.qset = qset;
	async->args.field_group_ports_create_mode.pri = pri;
	async->args.field_group_ports_create_mode.mode = mode;
	async->args.field_group_ports_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_ports_create_mode_id_async(
	int unit,
	bcm_pbmp_t pbmp,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_create_mode_id.unit = unit;
	async->args.field_group_ports_create_mode_id.pbmp = pbmp;
	async->args.field_group_ports_create_mode_id.qset = qset;
	async->args.field_group_ports_create_mode_id.pri = pri;
	async->args.field_group_ports_create_mode_id.mode = mode;
	async->args.field_group_ports_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_ports_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_get.unit = unit;
	async->args.field_group_ports_get.group = group;
	async->args.field_group_ports_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_ports_remove_async(
	int unit,
	bcm_field_group_t group,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_remove.unit = unit;
	async->args.field_group_ports_remove.group = group;
	async->args.field_group_ports_remove.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_presel_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_presel_set_t * presel,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PRESEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_presel_get.unit = unit;
	async->args.field_group_presel_get.group = group;
	async->args.field_group_presel_get.presel = presel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_presel_set_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_presel_set_t * presel,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PRESEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_presel_set.unit = unit;
	async->args.field_group_presel_set.group = group;
	async->args.field_group_presel_set.presel = presel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_priority_get_async(
	int unit,
	bcm_field_group_t group,
	int * priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_priority_get.unit = unit;
	async->args.field_group_priority_get.group = group;
	async->args.field_group_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_priority_set_async(
	int unit,
	bcm_field_group_t group,
	int priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_priority_set.unit = unit;
	async->args.field_group_priority_set.group = group;
	async->args.field_group_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_remove_async(
	int unit,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_remove.unit = unit;
	async->args.field_group_remove.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_set_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_qset_t qset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_set.unit = unit;
	async->args.field_group_set.group = group;
	async->args.field_group_set.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_status_get_async(
	int unit,
	bcm_field_group_t group,
	bcm_field_group_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_status_get.unit = unit;
	async->args.field_group_status_get.group = group;
	async->args.field_group_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_traverse_async(
	int unit,
	bcm_field_group_traverse_cb callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_traverse.unit = unit;
	async->args.field_group_traverse.callback = callback;
	async->args.field_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_wlan_create_mode_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_wlan_create_mode.unit = unit;
	async->args.field_group_wlan_create_mode.qset = qset;
	async->args.field_group_wlan_create_mode.pri = pri;
	async->args.field_group_wlan_create_mode.mode = mode;
	async->args.field_group_wlan_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_group_wlan_create_mode_id_async(
	int unit,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_wlan_create_mode_id.unit = unit;
	async->args.field_group_wlan_create_mode_id.qset = qset;
	async->args.field_group_wlan_create_mode_id.pri = pri;
	async->args.field_group_wlan_create_mode_id.mode = mode;
	async->args.field_group_wlan_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_add_async(
	int unit,
	bcm_field_hintid_t hint_id,
	bcm_field_hint_t * hint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_add.unit = unit;
	async->args.field_hints_add.hint_id = hint_id;
	async->args.field_hints_add.hint = hint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_create_async(
	int unit,
	bcm_field_hintid_t * hint_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_create.unit = unit;
	async->args.field_hints_create.hint_id = hint_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_delete_async(
	int unit,
	bcm_field_hintid_t hint_id,
	bcm_field_hint_t * hint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_delete.unit = unit;
	async->args.field_hints_delete.hint_id = hint_id;
	async->args.field_hints_delete.hint = hint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_delete_all_async(
	int unit,
	bcm_field_hintid_t hint_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_delete_all.unit = unit;
	async->args.field_hints_delete_all.hint_id = hint_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_destroy_async(
	int unit,
	bcm_field_hintid_t hint_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_destroy.unit = unit;
	async->args.field_hints_destroy.hint_id = hint_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_hints_get_async(
	int unit,
	bcm_field_hintid_t hint_id,
	bcm_field_hint_t * hint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_HINTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_hints_get.unit = unit;
	async->args.field_hints_get.hint_id = hint_id;
	async->args.field_hints_get.hint = hint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_internal_to_bcm_action_map_async(
	int unit,
	uint32 flags,
	int internal_action,
	uint32 bcm_action_size,
	bcm_field_internal_to_bcm_map_t * bcm_action_stage,
	uint32 * bcm_action_size_actual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_INTERNAL_TO_BCM_ACTION_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_internal_to_bcm_action_map.unit = unit;
	async->args.field_internal_to_bcm_action_map.flags = flags;
	async->args.field_internal_to_bcm_action_map.internal_action = internal_action;
	async->args.field_internal_to_bcm_action_map.bcm_action_size = bcm_action_size;
	async->args.field_internal_to_bcm_action_map.bcm_action_stage = bcm_action_stage;
	async->args.field_internal_to_bcm_action_map.bcm_action_size_actual = bcm_action_size_actual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_oam_stat_action_add_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_stat_action_t * oam_stat_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_OAM_STAT_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_oam_stat_action_add.unit = unit;
	async->args.field_oam_stat_action_add.entry = entry;
	async->args.field_oam_stat_action_add.oam_stat_action = oam_stat_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_oam_stat_action_delete_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_stat_action_t * oam_stat_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_OAM_STAT_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_oam_stat_action_delete.unit = unit;
	async->args.field_oam_stat_action_delete.entry = entry;
	async->args.field_oam_stat_action_delete.oam_stat_action = oam_stat_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_oam_stat_action_delete_all_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_OAM_STAT_ACTION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_oam_stat_action_delete_all.unit = unit;
	async->args.field_oam_stat_action_delete_all.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_oam_stat_action_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_stat_action_t * oam_stat_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_OAM_STAT_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_oam_stat_action_get.unit = unit;
	async->args.field_oam_stat_action_get.entry = entry;
	async->args.field_oam_stat_action_get.oam_stat_action = oam_stat_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_oam_stat_action_get_all_async(
	int unit,
	bcm_field_entry_t entry,
	int oam_stat_max,
	bcm_field_oam_stat_action_t * oam_stat_action,
	int * oam_stat_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_OAM_STAT_ACTION_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_oam_stat_action_get_all.unit = unit;
	async->args.field_oam_stat_action_get_all.entry = entry;
	async->args.field_oam_stat_action_get_all.oam_stat_max = oam_stat_max;
	async->args.field_oam_stat_action_get_all.oam_stat_action = oam_stat_action;
	async->args.field_oam_stat_action_get_all.oam_stat_count = oam_stat_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_config_get_async(
	int unit,
	bcm_field_presel_t presel_id,
	bcm_field_presel_config_t * presel_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_config_get.unit = unit;
	async->args.field_presel_config_get.presel_id = presel_id;
	async->args.field_presel_config_get.presel_config = presel_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_config_set_async(
	int unit,
	bcm_field_presel_t presel_id,
	bcm_field_presel_config_t * presel_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_config_set.unit = unit;
	async->args.field_presel_config_set.presel_id = presel_id;
	async->args.field_presel_config_set.presel_config = presel_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_create_async(
	int unit,
	bcm_field_presel_t * presel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_create.unit = unit;
	async->args.field_presel_create.presel_id = presel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_create_id_async(
	int unit,
	bcm_field_presel_t presel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_create_id.unit = unit;
	async->args.field_presel_create_id.presel_id = presel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_create_stage_id_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_field_presel_t presel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_CREATE_STAGE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_create_stage_id.unit = unit;
	async->args.field_presel_create_stage_id.stage = stage;
	async->args.field_presel_create_stage_id.presel_id = presel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_presel_destroy_async(
	int unit,
	bcm_field_presel_t presel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_PRESEL_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_presel_destroy.unit = unit;
	async->args.field_presel_destroy.presel_id = presel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_data_qualifier_add_async(
	int unit,
	bcm_field_qset_t * qset,
	int qual_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_data_qualifier_add.unit = unit;
	async->args.field_qset_data_qualifier_add.qset = qset;
	async->args.field_qset_data_qualifier_add.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_data_qualifier_delete_async(
	int unit,
	bcm_field_qset_t * qset,
	int qual_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_data_qualifier_delete.unit = unit;
	async->args.field_qset_data_qualifier_delete.qset = qset;
	async->args.field_qset_data_qualifier_delete.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_data_qualifier_get_async(
	int unit,
	bcm_field_qset_t qset,
	int qual_max,
	int * qual_arr,
	int * qual_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_data_qualifier_get.unit = unit;
	async->args.field_qset_data_qualifier_get.qset = qset;
	async->args.field_qset_data_qualifier_get.qual_max = qual_max;
	async->args.field_qset_data_qualifier_get.qual_arr = qual_arr;
	async->args.field_qset_data_qualifier_get.qual_count = qual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_id_multi_delete_async(
	int unit,
	bcm_field_qualify_t qualifier,
	int num_objects,
	int * object_list,
	bcm_field_qset_t * qset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_ID_MULTI_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_id_multi_delete.unit = unit;
	async->args.field_qset_id_multi_delete.qualifier = qualifier;
	async->args.field_qset_id_multi_delete.num_objects = num_objects;
	async->args.field_qset_id_multi_delete.object_list = object_list;
	async->args.field_qset_id_multi_delete.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_id_multi_get_async(
	int unit,
	bcm_field_qset_t qset,
	bcm_field_qualify_t qualifier,
	int max_objects,
	int * object_list,
	int * count_objects,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_ID_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_id_multi_get.unit = unit;
	async->args.field_qset_id_multi_get.qset = qset;
	async->args.field_qset_id_multi_get.qualifier = qualifier;
	async->args.field_qset_id_multi_get.max_objects = max_objects;
	async->args.field_qset_id_multi_get.object_list = object_list;
	async->args.field_qset_id_multi_get.count_objects = count_objects;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qset_id_multi_set_async(
	int unit,
	bcm_field_qualify_t qualifier,
	int num_objects,
	int * object_list,
	bcm_field_qset_t * qset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QSET_ID_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_id_multi_set.unit = unit;
	async->args.field_qset_id_multi_set.qualifier = qualifier;
	async->args.field_qset_id_multi_set.num_objects = num_objects;
	async->args.field_qset_id_multi_set.object_list = object_list;
	async->args.field_qset_id_multi_set.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualifier_delete_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_qualify_t qual_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFIER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualifier_delete.unit = unit;
	async->args.field_qualifier_delete.entry = entry;
	async->args.field_qualifier_delete.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_AppType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_AppType_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_APPTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_AppType.unit = unit;
	async->args.field_qualify_AppType.entry = entry;
	async->args.field_qualify_AppType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_AppType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_AppType_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_APPTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_AppType_get.unit = unit;
	async->args.field_qualify_AppType_get.entry = entry;
	async->args.field_qualify_AppType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpOpcode_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_ArpOpcode_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPOPCODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpOpcode.unit = unit;
	async->args.field_qualify_ArpOpcode.entry = entry;
	async->args.field_qualify_ArpOpcode.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpOpcode_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_ArpOpcode_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPOPCODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpOpcode_get.unit = unit;
	async->args.field_qualify_ArpOpcode_get.entry = entry;
	async->args.field_qualify_ArpOpcode_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpSenderIp4_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPSENDERIP4;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpSenderIp4.unit = unit;
	async->args.field_qualify_ArpSenderIp4.entry = entry;
	async->args.field_qualify_ArpSenderIp4.data = data;
	async->args.field_qualify_ArpSenderIp4.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpSenderIp4_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPSENDERIP4_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpSenderIp4_get.unit = unit;
	async->args.field_qualify_ArpSenderIp4_get.entry = entry;
	async->args.field_qualify_ArpSenderIp4_get.data = data;
	async->args.field_qualify_ArpSenderIp4_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpTargetIp4_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPTARGETIP4;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpTargetIp4.unit = unit;
	async->args.field_qualify_ArpTargetIp4.entry = entry;
	async->args.field_qualify_ArpTargetIp4.data = data;
	async->args.field_qualify_ArpTargetIp4.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ArpTargetIp4_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ARPTARGETIP4_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ArpTargetIp4_get.unit = unit;
	async->args.field_qualify_ArpTargetIp4_get.entry = entry;
	async->args.field_qualify_ArpTargetIp4_get.data = data;
	async->args.field_qualify_ArpTargetIp4_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BfdYourDiscriminator_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BFDYOURDISCRIMINATOR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BfdYourDiscriminator.unit = unit;
	async->args.field_qualify_BfdYourDiscriminator.entry = entry;
	async->args.field_qualify_BfdYourDiscriminator.data = data;
	async->args.field_qualify_BfdYourDiscriminator.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BfdYourDiscriminator_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BFDYOURDISCRIMINATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BfdYourDiscriminator_get.unit = unit;
	async->args.field_qualify_BfdYourDiscriminator_get.entry = entry;
	async->args.field_qualify_BfdYourDiscriminator_get.data = data;
	async->args.field_qualify_BfdYourDiscriminator_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BigIcmpCheck_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 flag,
	uint32 size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BIGICMPCHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BigIcmpCheck.unit = unit;
	async->args.field_qualify_BigIcmpCheck.entry = entry;
	async->args.field_qualify_BigIcmpCheck.flag = flag;
	async->args.field_qualify_BigIcmpCheck.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BigIcmpCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * flag,
	uint32 * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BIGICMPCHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BigIcmpCheck_get.unit = unit;
	async->args.field_qualify_BigIcmpCheck_get.entry = entry;
	async->args.field_qualify_BigIcmpCheck_get.flag = flag;
	async->args.field_qualify_BigIcmpCheck_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassFilter_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSFILTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassFilter.unit = unit;
	async->args.field_qualify_BypassFilter.entry = entry;
	async->args.field_qualify_BypassFilter.data = data;
	async->args.field_qualify_BypassFilter.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassFilter32_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSFILTER32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassFilter32.unit = unit;
	async->args.field_qualify_BypassFilter32.entry = entry;
	async->args.field_qualify_BypassFilter32.data = data;
	async->args.field_qualify_BypassFilter32.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassFilter32_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSFILTER32_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassFilter32_get.unit = unit;
	async->args.field_qualify_BypassFilter32_get.entry = entry;
	async->args.field_qualify_BypassFilter32_get.data = data;
	async->args.field_qualify_BypassFilter32_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassFilter_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSFILTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassFilter_get.unit = unit;
	async->args.field_qualify_BypassFilter_get.entry = entry;
	async->args.field_qualify_BypassFilter_get.data = data;
	async->args.field_qualify_BypassFilter_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassSrcMacFilter_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSSRCMACFILTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassSrcMacFilter.unit = unit;
	async->args.field_qualify_BypassSrcMacFilter.entry = entry;
	async->args.field_qualify_BypassSrcMacFilter.data = data;
	async->args.field_qualify_BypassSrcMacFilter.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_BypassSrcMacFilter_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_BYPASSSRCMACFILTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_BypassSrcMacFilter_get.unit = unit;
	async->args.field_qualify_BypassSrcMacFilter_get.entry = entry;
	async->args.field_qualify_BypassSrcMacFilter_get.data = data;
	async->args.field_qualify_BypassSrcMacFilter_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapHdrRid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPHDRRID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapHdrRid.unit = unit;
	async->args.field_qualify_CapwapHdrRid.entry = entry;
	async->args.field_qualify_CapwapHdrRid.data = data;
	async->args.field_qualify_CapwapHdrRid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapHdrRid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPHDRRID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapHdrRid_get.unit = unit;
	async->args.field_qualify_CapwapHdrRid_get.entry = entry;
	async->args.field_qualify_CapwapHdrRid_get.data = data;
	async->args.field_qualify_CapwapHdrRid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapHdrType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPHDRTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapHdrType.unit = unit;
	async->args.field_qualify_CapwapHdrType.entry = entry;
	async->args.field_qualify_CapwapHdrType.data = data;
	async->args.field_qualify_CapwapHdrType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapHdrType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPHDRTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapHdrType_get.unit = unit;
	async->args.field_qualify_CapwapHdrType_get.entry = entry;
	async->args.field_qualify_CapwapHdrType_get.data = data;
	async->args.field_qualify_CapwapHdrType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDip_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDip.unit = unit;
	async->args.field_qualify_CapwapPayloadDip.entry = entry;
	async->args.field_qualify_CapwapPayloadDip.data = data;
	async->args.field_qualify_CapwapPayloadDip.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDip6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDip6.unit = unit;
	async->args.field_qualify_CapwapPayloadDip6.entry = entry;
	async->args.field_qualify_CapwapPayloadDip6.data = (uint8 *)data;
	async->args.field_qualify_CapwapPayloadDip6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDip6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDip6_get.unit = unit;
	async->args.field_qualify_CapwapPayloadDip6_get.entry = entry;
	async->args.field_qualify_CapwapPayloadDip6_get.data = data;
	async->args.field_qualify_CapwapPayloadDip6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDip_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDip_get.unit = unit;
	async->args.field_qualify_CapwapPayloadDip_get.entry = entry;
	async->args.field_qualify_CapwapPayloadDip_get.data = data;
	async->args.field_qualify_CapwapPayloadDip_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDstMac.unit = unit;
	async->args.field_qualify_CapwapPayloadDstMac.entry = entry;
	async->args.field_qualify_CapwapPayloadDstMac.data = (uint8 *)data;
	async->args.field_qualify_CapwapPayloadDstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadDstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADDSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadDstMac_get.unit = unit;
	async->args.field_qualify_CapwapPayloadDstMac_get.entry = entry;
	async->args.field_qualify_CapwapPayloadDstMac_get.data = data;
	async->args.field_qualify_CapwapPayloadDstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadEtherType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADETHERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadEtherType.unit = unit;
	async->args.field_qualify_CapwapPayloadEtherType.entry = entry;
	async->args.field_qualify_CapwapPayloadEtherType.data = data;
	async->args.field_qualify_CapwapPayloadEtherType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadEtherType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadEtherType_get.unit = unit;
	async->args.field_qualify_CapwapPayloadEtherType_get.entry = entry;
	async->args.field_qualify_CapwapPayloadEtherType_get.data = data;
	async->args.field_qualify_CapwapPayloadEtherType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlan.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlan.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlan.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi_get.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi_get.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi_get.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanId.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanId.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanId.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanId_get.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanId_get.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanId_get.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanPri.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanPri.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanPri.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlanPri_get.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlanPri_get.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlanPri_get.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadInnerVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADINNERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadInnerVlan_get.unit = unit;
	async->args.field_qualify_CapwapPayloadInnerVlan_get.entry = entry;
	async->args.field_qualify_CapwapPayloadInnerVlan_get.data = data;
	async->args.field_qualify_CapwapPayloadInnerVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadIpProtocol_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADIPPROTOCOL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadIpProtocol.unit = unit;
	async->args.field_qualify_CapwapPayloadIpProtocol.entry = entry;
	async->args.field_qualify_CapwapPayloadIpProtocol.data = data;
	async->args.field_qualify_CapwapPayloadIpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadIpProtocol_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADIPPROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadIpProtocol_get.unit = unit;
	async->args.field_qualify_CapwapPayloadIpProtocol_get.entry = entry;
	async->args.field_qualify_CapwapPayloadIpProtocol_get.data = data;
	async->args.field_qualify_CapwapPayloadIpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL3HdrParseable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL3HDRPARSEABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL3HdrParseable.unit = unit;
	async->args.field_qualify_CapwapPayloadL3HdrParseable.entry = entry;
	async->args.field_qualify_CapwapPayloadL3HdrParseable.data = data;
	async->args.field_qualify_CapwapPayloadL3HdrParseable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL3HdrParseable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL3HDRPARSEABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL3HdrParseable_get.unit = unit;
	async->args.field_qualify_CapwapPayloadL3HdrParseable_get.entry = entry;
	async->args.field_qualify_CapwapPayloadL3HdrParseable_get.data = data;
	async->args.field_qualify_CapwapPayloadL3HdrParseable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4DstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4DSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4DstPort.unit = unit;
	async->args.field_qualify_CapwapPayloadL4DstPort.entry = entry;
	async->args.field_qualify_CapwapPayloadL4DstPort.data = data;
	async->args.field_qualify_CapwapPayloadL4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4DstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4DSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4DstPort_get.unit = unit;
	async->args.field_qualify_CapwapPayloadL4DstPort_get.entry = entry;
	async->args.field_qualify_CapwapPayloadL4DstPort_get.data = data;
	async->args.field_qualify_CapwapPayloadL4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4HdrParseable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4HDRPARSEABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4HdrParseable.unit = unit;
	async->args.field_qualify_CapwapPayloadL4HdrParseable.entry = entry;
	async->args.field_qualify_CapwapPayloadL4HdrParseable.data = data;
	async->args.field_qualify_CapwapPayloadL4HdrParseable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4HdrParseable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4HDRPARSEABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4HdrParseable_get.unit = unit;
	async->args.field_qualify_CapwapPayloadL4HdrParseable_get.entry = entry;
	async->args.field_qualify_CapwapPayloadL4HdrParseable_get.data = data;
	async->args.field_qualify_CapwapPayloadL4HdrParseable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4SrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4SRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4SrcPort.unit = unit;
	async->args.field_qualify_CapwapPayloadL4SrcPort.entry = entry;
	async->args.field_qualify_CapwapPayloadL4SrcPort.data = data;
	async->args.field_qualify_CapwapPayloadL4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadL4SrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADL4SRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadL4SrcPort_get.unit = unit;
	async->args.field_qualify_CapwapPayloadL4SrcPort_get.entry = entry;
	async->args.field_qualify_CapwapPayloadL4SrcPort_get.data = data;
	async->args.field_qualify_CapwapPayloadL4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlan.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlan.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlan.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi_get.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi_get.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi_get.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanId.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanId.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanId.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanId_get.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanId_get.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanId_get.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanPri.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanPri.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanPri.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlanPri_get.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlanPri_get.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlanPri_get.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadOuterVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADOUTERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadOuterVlan_get.unit = unit;
	async->args.field_qualify_CapwapPayloadOuterVlan_get.entry = entry;
	async->args.field_qualify_CapwapPayloadOuterVlan_get.data = data;
	async->args.field_qualify_CapwapPayloadOuterVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSOF_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSOF;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSOF.unit = unit;
	async->args.field_qualify_CapwapPayloadSOF.entry = entry;
	async->args.field_qualify_CapwapPayloadSOF.data = data;
	async->args.field_qualify_CapwapPayloadSOF.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSOF_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSOF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSOF_get.unit = unit;
	async->args.field_qualify_CapwapPayloadSOF_get.entry = entry;
	async->args.field_qualify_CapwapPayloadSOF_get.data = data;
	async->args.field_qualify_CapwapPayloadSOF_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSip_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSip.unit = unit;
	async->args.field_qualify_CapwapPayloadSip.entry = entry;
	async->args.field_qualify_CapwapPayloadSip.data = data;
	async->args.field_qualify_CapwapPayloadSip.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSip6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSip6.unit = unit;
	async->args.field_qualify_CapwapPayloadSip6.entry = entry;
	async->args.field_qualify_CapwapPayloadSip6.data = (uint8 *)data;
	async->args.field_qualify_CapwapPayloadSip6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSip6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSip6_get.unit = unit;
	async->args.field_qualify_CapwapPayloadSip6_get.entry = entry;
	async->args.field_qualify_CapwapPayloadSip6_get.data = data;
	async->args.field_qualify_CapwapPayloadSip6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSip_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSip_get.unit = unit;
	async->args.field_qualify_CapwapPayloadSip_get.entry = entry;
	async->args.field_qualify_CapwapPayloadSip_get.data = data;
	async->args.field_qualify_CapwapPayloadSip_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSrcMac.unit = unit;
	async->args.field_qualify_CapwapPayloadSrcMac.entry = entry;
	async->args.field_qualify_CapwapPayloadSrcMac.data = (uint8 *)data;
	async->args.field_qualify_CapwapPayloadSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadSrcMac_get.unit = unit;
	async->args.field_qualify_CapwapPayloadSrcMac_get.entry = entry;
	async->args.field_qualify_CapwapPayloadSrcMac_get.data = data;
	async->args.field_qualify_CapwapPayloadSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadTos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADTOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadTos.unit = unit;
	async->args.field_qualify_CapwapPayloadTos.entry = entry;
	async->args.field_qualify_CapwapPayloadTos.data = data;
	async->args.field_qualify_CapwapPayloadTos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadTos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADTOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadTos_get.unit = unit;
	async->args.field_qualify_CapwapPayloadTos_get.entry = entry;
	async->args.field_qualify_CapwapPayloadTos_get.data = data;
	async->args.field_qualify_CapwapPayloadTos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadVlanFormat_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADVLANFORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadVlanFormat.unit = unit;
	async->args.field_qualify_CapwapPayloadVlanFormat.entry = entry;
	async->args.field_qualify_CapwapPayloadVlanFormat.data = data;
	async->args.field_qualify_CapwapPayloadVlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CapwapPayloadVlanFormat_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CAPWAPPAYLOADVLANFORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CapwapPayloadVlanFormat_get.unit = unit;
	async->args.field_qualify_CapwapPayloadVlanFormat_get.entry = entry;
	async->args.field_qualify_CapwapPayloadVlanFormat_get.data = data;
	async->args.field_qualify_CapwapPayloadVlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CascadedKeyValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CASCADEDKEYVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CascadedKeyValue.unit = unit;
	async->args.field_qualify_CascadedKeyValue.entry = entry;
	async->args.field_qualify_CascadedKeyValue.data = data;
	async->args.field_qualify_CascadedKeyValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CascadedKeyValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CASCADEDKEYVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CascadedKeyValue_get.unit = unit;
	async->args.field_qualify_CascadedKeyValue_get.entry = entry;
	async->args.field_qualify_CascadedKeyValue_get.data = data;
	async->args.field_qualify_CascadedKeyValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ClassId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CLASSID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ClassId.unit = unit;
	async->args.field_qualify_ClassId.entry = entry;
	async->args.field_qualify_ClassId.data = data;
	async->args.field_qualify_ClassId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ClassId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CLASSID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ClassId_get.unit = unit;
	async->args.field_qualify_ClassId_get.entry = entry;
	async->args.field_qualify_ClassId_get.data = data;
	async->args.field_qualify_ClassId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CnTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CNTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CnTag.unit = unit;
	async->args.field_qualify_CnTag.entry = entry;
	async->args.field_qualify_CnTag.data = data;
	async->args.field_qualify_CnTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CnTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CNTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CnTag_get.unit = unit;
	async->args.field_qualify_CnTag_get.entry = entry;
	async->args.field_qualify_CnTag_get.data = data;
	async->args.field_qualify_CnTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Color_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_COLOR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Color.unit = unit;
	async->args.field_qualify_Color.entry = entry;
	async->args.field_qualify_Color.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Color_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_COLOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Color_get.unit = unit;
	async->args.field_qualify_Color_get.entry = entry;
	async->args.field_qualify_Color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CpuQueue_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CPUQUEUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CpuQueue.unit = unit;
	async->args.field_qualify_CpuQueue.entry = entry;
	async->args.field_qualify_CpuQueue.data = data;
	async->args.field_qualify_CpuQueue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CpuQueue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CPUQUEUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CpuQueue_get.unit = unit;
	async->args.field_qualify_CpuQueue_get.entry = entry;
	async->args.field_qualify_CpuQueue_get.data = data;
	async->args.field_qualify_CpuQueue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CpuVisibilityPacket_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CPUVISIBILITYPACKET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CpuVisibilityPacket.unit = unit;
	async->args.field_qualify_CpuVisibilityPacket.entry = entry;
	async->args.field_qualify_CpuVisibilityPacket.data = data;
	async->args.field_qualify_CpuVisibilityPacket.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CpuVisibilityPacket_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CPUVISIBILITYPACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CpuVisibilityPacket_get.unit = unit;
	async->args.field_qualify_CpuVisibilityPacket_get.entry = entry;
	async->args.field_qualify_CpuVisibilityPacket_get.data = data;
	async->args.field_qualify_CpuVisibilityPacket_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CustomHeaderData_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CUSTOMHEADERDATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CustomHeaderData.unit = unit;
	async->args.field_qualify_CustomHeaderData.entry = entry;
	async->args.field_qualify_CustomHeaderData.data = data;
	async->args.field_qualify_CustomHeaderData.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CustomHeaderData_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CUSTOMHEADERDATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CustomHeaderData_get.unit = unit;
	async->args.field_qualify_CustomHeaderData_get.entry = entry;
	async->args.field_qualify_CustomHeaderData_get.data = data;
	async->args.field_qualify_CustomHeaderData_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CustomHeaderPkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CUSTOMHEADERPKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CustomHeaderPkt.unit = unit;
	async->args.field_qualify_CustomHeaderPkt.entry = entry;
	async->args.field_qualify_CustomHeaderPkt.data = data;
	async->args.field_qualify_CustomHeaderPkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_CustomHeaderPkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CUSTOMHEADERPKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CustomHeaderPkt_get.unit = unit;
	async->args.field_qualify_CustomHeaderPkt_get.entry = entry;
	async->args.field_qualify_CustomHeaderPkt_get.data = data;
	async->args.field_qualify_CustomHeaderPkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DSCP_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSCP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DSCP.unit = unit;
	async->args.field_qualify_DSCP.entry = entry;
	async->args.field_qualify_DSCP.data = data;
	async->args.field_qualify_DSCP.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DSCP_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSCP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DSCP_get.unit = unit;
	async->args.field_qualify_DSCP_get.entry = entry;
	async->args.field_qualify_DSCP_get.data = data;
	async->args.field_qualify_DSCP_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Decap_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_decap_t decap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DECAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Decap.unit = unit;
	async->args.field_qualify_Decap.entry = entry;
	async->args.field_qualify_Decap.decap = decap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DestVirtualPortValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DESTVIRTUALPORTVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DestVirtualPortValid.unit = unit;
	async->args.field_qualify_DestVirtualPortValid.entry = entry;
	async->args.field_qualify_DestVirtualPortValid.data = data;
	async->args.field_qualify_DestVirtualPortValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DestVirtualPortValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DESTVIRTUALPORTVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DestVirtualPortValid_get.unit = unit;
	async->args.field_qualify_DestVirtualPortValid_get.entry = entry;
	async->args.field_qualify_DestVirtualPortValid_get.data = data;
	async->args.field_qualify_DestVirtualPortValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DevicePortBitmap_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DEVICEPORTBITMAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DevicePortBitmap.unit = unit;
	async->args.field_qualify_DevicePortBitmap.entry = entry;
	async->args.field_qualify_DevicePortBitmap.data = data;
	async->args.field_qualify_DevicePortBitmap.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DevicePortBitmap_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DEVICEPORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DevicePortBitmap_get.unit = unit;
	async->args.field_qualify_DevicePortBitmap_get.entry = entry;
	async->args.field_qualify_DevicePortBitmap_get.data = data;
	async->args.field_qualify_DevicePortBitmap_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Dhcp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DHCP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Dhcp.unit = unit;
	async->args.field_qualify_Dhcp.entry = entry;
	async->args.field_qualify_Dhcp.data = data;
	async->args.field_qualify_Dhcp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Dhcp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DHCP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Dhcp_get.unit = unit;
	async->args.field_qualify_Dhcp_get.entry = entry;
	async->args.field_qualify_Dhcp_get.data = data;
	async->args.field_qualify_Dhcp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DosAttack_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DosAttack.unit = unit;
	async->args.field_qualify_DosAttack.entry = entry;
	async->args.field_qualify_DosAttack.data = data;
	async->args.field_qualify_DosAttack.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DosAttack_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DosAttack_get.unit = unit;
	async->args.field_qualify_DosAttack_get.entry = entry;
	async->args.field_qualify_DosAttack_get.data = data;
	async->args.field_qualify_DosAttack_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DownMepSatTerminated_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOWNMEPSATTERMINATED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DownMepSatTerminated.unit = unit;
	async->args.field_qualify_DownMepSatTerminated.entry = entry;
	async->args.field_qualify_DownMepSatTerminated.data = data;
	async->args.field_qualify_DownMepSatTerminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DownMepSatTerminated_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOWNMEPSATTERMINATED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DownMepSatTerminated_get.unit = unit;
	async->args.field_qualify_DownMepSatTerminated_get.entry = entry;
	async->args.field_qualify_DownMepSatTerminated_get.data = data;
	async->args.field_qualify_DownMepSatTerminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Drop_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DROP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Drop.unit = unit;
	async->args.field_qualify_Drop.entry = entry;
	async->args.field_qualify_Drop.data = data;
	async->args.field_qualify_Drop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Drop_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DROP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Drop_get.unit = unit;
	async->args.field_qualify_Drop_get.entry = entry;
	async->args.field_qualify_Drop_get.data = data;
	async->args.field_qualify_Drop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassField_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassField.unit = unit;
	async->args.field_qualify_DstClassField.entry = entry;
	async->args.field_qualify_DstClassField.data = data;
	async->args.field_qualify_DstClassField.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassField_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassField_get.unit = unit;
	async->args.field_qualify_DstClassField_get.entry = entry;
	async->args.field_qualify_DstClassField_get.data = data;
	async->args.field_qualify_DstClassField_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassL2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL2.unit = unit;
	async->args.field_qualify_DstClassL2.entry = entry;
	async->args.field_qualify_DstClassL2.data = data;
	async->args.field_qualify_DstClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassL2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL2_get.unit = unit;
	async->args.field_qualify_DstClassL2_get.entry = entry;
	async->args.field_qualify_DstClassL2_get.data = data;
	async->args.field_qualify_DstClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassL3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL3.unit = unit;
	async->args.field_qualify_DstClassL3.entry = entry;
	async->args.field_qualify_DstClassL3.data = data;
	async->args.field_qualify_DstClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstClassL3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL3_get.unit = unit;
	async->args.field_qualify_DstClassL3_get.entry = entry;
	async->args.field_qualify_DstClassL3_get.data = data;
	async->args.field_qualify_DstClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstGport.unit = unit;
	async->args.field_qualify_DstGport.entry = entry;
	async->args.field_qualify_DstGport.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstGport_get.unit = unit;
	async->args.field_qualify_DstGport_get.entry = entry;
	async->args.field_qualify_DstGport_get.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstGports.unit = unit;
	async->args.field_qualify_DstGports.entry = entry;
	async->args.field_qualify_DstGports.port_id = port_id;
	async->args.field_qualify_DstGports.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstGports_get.unit = unit;
	async->args.field_qualify_DstGports_get.entry = entry;
	async->args.field_qualify_DstGports_get.port_id = port_id;
	async->args.field_qualify_DstGports_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstHiGig_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstHiGig.unit = unit;
	async->args.field_qualify_DstHiGig.entry = entry;
	async->args.field_qualify_DstHiGig.data = data;
	async->args.field_qualify_DstHiGig.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstHiGig_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstHiGig_get.unit = unit;
	async->args.field_qualify_DstHiGig_get.entry = entry;
	async->args.field_qualify_DstHiGig_get.data = data;
	async->args.field_qualify_DstHiGig_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp.unit = unit;
	async->args.field_qualify_DstIp.entry = entry;
	async->args.field_qualify_DstIp.data = data;
	async->args.field_qualify_DstIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6.unit = unit;
	async->args.field_qualify_DstIp6.entry = entry;
	async->args.field_qualify_DstIp6.data = (uint8 *)data;
	async->args.field_qualify_DstIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6Class_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Class.unit = unit;
	async->args.field_qualify_DstIp6Class.entry = entry;
	async->args.field_qualify_DstIp6Class.data = data;
	async->args.field_qualify_DstIp6Class.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassLower.unit = unit;
	async->args.field_qualify_DstIp6ClassLower.entry = entry;
	async->args.field_qualify_DstIp6ClassLower.data = data;
	async->args.field_qualify_DstIp6ClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassLower_get.unit = unit;
	async->args.field_qualify_DstIp6ClassLower_get.entry = entry;
	async->args.field_qualify_DstIp6ClassLower_get.data = data;
	async->args.field_qualify_DstIp6ClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassMsbNibble.unit = unit;
	async->args.field_qualify_DstIp6ClassMsbNibble.entry = entry;
	async->args.field_qualify_DstIp6ClassMsbNibble.data = data;
	async->args.field_qualify_DstIp6ClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassMsbNibble_get.unit = unit;
	async->args.field_qualify_DstIp6ClassMsbNibble_get.entry = entry;
	async->args.field_qualify_DstIp6ClassMsbNibble_get.data = data;
	async->args.field_qualify_DstIp6ClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassUpper.unit = unit;
	async->args.field_qualify_DstIp6ClassUpper.entry = entry;
	async->args.field_qualify_DstIp6ClassUpper.data = data;
	async->args.field_qualify_DstIp6ClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6ClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6ClassUpper_get.unit = unit;
	async->args.field_qualify_DstIp6ClassUpper_get.entry = entry;
	async->args.field_qualify_DstIp6ClassUpper_get.data = data;
	async->args.field_qualify_DstIp6ClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6Class_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Class_get.unit = unit;
	async->args.field_qualify_DstIp6Class_get.entry = entry;
	async->args.field_qualify_DstIp6Class_get.data = data;
	async->args.field_qualify_DstIp6Class_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6High_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6High.unit = unit;
	async->args.field_qualify_DstIp6High.entry = entry;
	async->args.field_qualify_DstIp6High.data = (uint8 *)data;
	async->args.field_qualify_DstIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6High_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6High_get.unit = unit;
	async->args.field_qualify_DstIp6High_get.entry = entry;
	async->args.field_qualify_DstIp6High_get.data = data;
	async->args.field_qualify_DstIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6Low_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6LOW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Low.unit = unit;
	async->args.field_qualify_DstIp6Low.entry = entry;
	async->args.field_qualify_DstIp6Low.data = (uint8 *)data;
	async->args.field_qualify_DstIp6Low.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6Low_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6LOW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Low_get.unit = unit;
	async->args.field_qualify_DstIp6Low_get.entry = entry;
	async->args.field_qualify_DstIp6Low_get.data = data;
	async->args.field_qualify_DstIp6Low_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6_get.unit = unit;
	async->args.field_qualify_DstIp6_get.entry = entry;
	async->args.field_qualify_DstIp6_get.data = data;
	async->args.field_qualify_DstIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClass.unit = unit;
	async->args.field_qualify_DstIpClass.entry = entry;
	async->args.field_qualify_DstIpClass.data = data;
	async->args.field_qualify_DstIpClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassLower.unit = unit;
	async->args.field_qualify_DstIpClassLower.entry = entry;
	async->args.field_qualify_DstIpClassLower.data = data;
	async->args.field_qualify_DstIpClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassLower_get.unit = unit;
	async->args.field_qualify_DstIpClassLower_get.entry = entry;
	async->args.field_qualify_DstIpClassLower_get.data = data;
	async->args.field_qualify_DstIpClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassMsbNibble.unit = unit;
	async->args.field_qualify_DstIpClassMsbNibble.entry = entry;
	async->args.field_qualify_DstIpClassMsbNibble.data = data;
	async->args.field_qualify_DstIpClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassMsbNibble_get.unit = unit;
	async->args.field_qualify_DstIpClassMsbNibble_get.entry = entry;
	async->args.field_qualify_DstIpClassMsbNibble_get.data = data;
	async->args.field_qualify_DstIpClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassUpper.unit = unit;
	async->args.field_qualify_DstIpClassUpper.entry = entry;
	async->args.field_qualify_DstIpClassUpper.data = data;
	async->args.field_qualify_DstIpClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClassUpper_get.unit = unit;
	async->args.field_qualify_DstIpClassUpper_get.entry = entry;
	async->args.field_qualify_DstIpClassUpper_get.data = data;
	async->args.field_qualify_DstIpClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpClass_get.unit = unit;
	async->args.field_qualify_DstIpClass_get.entry = entry;
	async->args.field_qualify_DstIpClass_get.data = data;
	async->args.field_qualify_DstIpClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpLocal_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPLOCAL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpLocal.unit = unit;
	async->args.field_qualify_DstIpLocal.entry = entry;
	async->args.field_qualify_DstIpLocal.data = data;
	async->args.field_qualify_DstIpLocal.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIpLocal_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIPLOCAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIpLocal_get.unit = unit;
	async->args.field_qualify_DstIpLocal_get.entry = entry;
	async->args.field_qualify_DstIpLocal_get.data = data;
	async->args.field_qualify_DstIpLocal_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstIp_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp_get.unit = unit;
	async->args.field_qualify_DstIp_get.entry = entry;
	async->args.field_qualify_DstIp_get.data = data;
	async->args.field_qualify_DstIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL2MulticastGroup_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t group,
	bcm_multicast_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL2MULTICASTGROUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL2MulticastGroup.unit = unit;
	async->args.field_qualify_DstL2MulticastGroup.entry = entry;
	async->args.field_qualify_DstL2MulticastGroup.group = group;
	async->args.field_qualify_DstL2MulticastGroup.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL2MulticastGroup_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t * group,
	bcm_multicast_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL2MULTICASTGROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL2MulticastGroup_get.unit = unit;
	async->args.field_qualify_DstL2MulticastGroup_get.entry = entry;
	async->args.field_qualify_DstL2MulticastGroup_get.group = group;
	async->args.field_qualify_DstL2MulticastGroup_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3Egress_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t if_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3Egress.unit = unit;
	async->args.field_qualify_DstL3Egress.entry = entry;
	async->args.field_qualify_DstL3Egress.if_id = if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3EgressNextHops_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESSNEXTHOPS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3EgressNextHops.unit = unit;
	async->args.field_qualify_DstL3EgressNextHops.entry = entry;
	async->args.field_qualify_DstL3EgressNextHops.data = data;
	async->args.field_qualify_DstL3EgressNextHops.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3EgressNextHops_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESSNEXTHOPS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3EgressNextHops_get.unit = unit;
	async->args.field_qualify_DstL3EgressNextHops_get.entry = entry;
	async->args.field_qualify_DstL3EgressNextHops_get.data = data;
	async->args.field_qualify_DstL3EgressNextHops_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3Egress_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t * if_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3Egress_get.unit = unit;
	async->args.field_qualify_DstL3Egress_get.entry = entry;
	async->args.field_qualify_DstL3Egress_get.if_id = if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3MulticastGroup_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t group,
	bcm_multicast_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3MULTICASTGROUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3MulticastGroup.unit = unit;
	async->args.field_qualify_DstL3MulticastGroup.entry = entry;
	async->args.field_qualify_DstL3MulticastGroup.group = group;
	async->args.field_qualify_DstL3MulticastGroup.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstL3MulticastGroup_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t * group,
	bcm_multicast_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3MULTICASTGROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3MulticastGroup_get.unit = unit;
	async->args.field_qualify_DstL3MulticastGroup_get.entry = entry;
	async->args.field_qualify_DstL3MulticastGroup_get.group = group;
	async->args.field_qualify_DstL3MulticastGroup_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMac.unit = unit;
	async->args.field_qualify_DstMac.entry = entry;
	async->args.field_qualify_DstMac.data = (uint8 *)data;
	async->args.field_qualify_DstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMac_get.unit = unit;
	async->args.field_qualify_DstMac_get.entry = entry;
	async->args.field_qualify_DstMac_get.data = data;
	async->args.field_qualify_DstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMimGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGport.unit = unit;
	async->args.field_qualify_DstMimGport.entry = entry;
	async->args.field_qualify_DstMimGport.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMimGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGport_get.unit = unit;
	async->args.field_qualify_DstMimGport_get.entry = entry;
	async->args.field_qualify_DstMimGport_get.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMimGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcm_gport_t mim_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGports.unit = unit;
	async->args.field_qualify_DstMimGports.entry = entry;
	async->args.field_qualify_DstMimGports.mim_port_id = mim_port_id;
	async->args.field_qualify_DstMimGports.mim_port_mask = mim_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMimGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcm_gport_t * mim_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGports_get.unit = unit;
	async->args.field_qualify_DstMimGports_get.entry = entry;
	async->args.field_qualify_DstMimGports_get.mim_port_id = mim_port_id;
	async->args.field_qualify_DstMimGports_get.mim_port_mask = mim_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMplsGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGport.unit = unit;
	async->args.field_qualify_DstMplsGport.entry = entry;
	async->args.field_qualify_DstMplsGport.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMplsGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGport_get.unit = unit;
	async->args.field_qualify_DstMplsGport_get.entry = entry;
	async->args.field_qualify_DstMplsGport_get.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMplsGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcm_gport_t mpls_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGports.unit = unit;
	async->args.field_qualify_DstMplsGports.entry = entry;
	async->args.field_qualify_DstMplsGports.mpls_port_id = mpls_port_id;
	async->args.field_qualify_DstMplsGports.mpls_port_mask = mpls_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMplsGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcm_gport_t * mpls_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGports_get.unit = unit;
	async->args.field_qualify_DstMplsGports_get.entry = entry;
	async->args.field_qualify_DstMplsGports_get.mpls_port_id = mpls_port_id;
	async->args.field_qualify_DstMplsGports_get.mpls_port_mask = mpls_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMulticastGroup_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroup.unit = unit;
	async->args.field_qualify_DstMulticastGroup.entry = entry;
	async->args.field_qualify_DstMulticastGroup.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMulticastGroup_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroup_get.unit = unit;
	async->args.field_qualify_DstMulticastGroup_get.entry = entry;
	async->args.field_qualify_DstMulticastGroup_get.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMulticastGroups_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t group,
	bcm_multicast_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUPS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroups.unit = unit;
	async->args.field_qualify_DstMulticastGroups.entry = entry;
	async->args.field_qualify_DstMulticastGroups.group = group;
	async->args.field_qualify_DstMulticastGroups.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMulticastGroups_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t * group,
	bcm_multicast_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUPS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroups_get.unit = unit;
	async->args.field_qualify_DstMulticastGroups_get.entry = entry;
	async->args.field_qualify_DstMulticastGroups_get.group = group;
	async->args.field_qualify_DstMulticastGroups_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipath_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipath.unit = unit;
	async->args.field_qualify_DstMultipath.entry = entry;
	async->args.field_qualify_DstMultipath.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipathOverlay_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t data,
	bcm_if_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATHOVERLAY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipathOverlay.unit = unit;
	async->args.field_qualify_DstMultipathOverlay.entry = entry;
	async->args.field_qualify_DstMultipathOverlay.data = data;
	async->args.field_qualify_DstMultipathOverlay.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipathOverlay_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t * data,
	bcm_if_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATHOVERLAY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipathOverlay_get.unit = unit;
	async->args.field_qualify_DstMultipathOverlay_get.entry = entry;
	async->args.field_qualify_DstMultipathOverlay_get.data = data;
	async->args.field_qualify_DstMultipathOverlay_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipathUnderlay_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t data,
	bcm_if_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATHUNDERLAY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipathUnderlay.unit = unit;
	async->args.field_qualify_DstMultipathUnderlay.entry = entry;
	async->args.field_qualify_DstMultipathUnderlay.data = data;
	async->args.field_qualify_DstMultipathUnderlay.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipathUnderlay_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t * data,
	bcm_if_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATHUNDERLAY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipathUnderlay_get.unit = unit;
	async->args.field_qualify_DstMultipathUnderlay_get.entry = entry;
	async->args.field_qualify_DstMultipathUnderlay_get.data = data;
	async->args.field_qualify_DstMultipathUnderlay_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstMultipath_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_if_t * mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipath_get.unit = unit;
	async->args.field_qualify_DstMultipath_get.entry = entry;
	async->args.field_qualify_DstMultipath_get.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstNivGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t niv_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTNIVGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstNivGport.unit = unit;
	async->args.field_qualify_DstNivGport.entry = entry;
	async->args.field_qualify_DstNivGport.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstNivGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * niv_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTNIVGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstNivGport_get.unit = unit;
	async->args.field_qualify_DstNivGport_get.entry = entry;
	async->args.field_qualify_DstNivGport_get.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstNivGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t niv_port_id,
	bcm_gport_t niv_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTNIVGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstNivGports.unit = unit;
	async->args.field_qualify_DstNivGports.entry = entry;
	async->args.field_qualify_DstNivGports.niv_port_id = niv_port_id;
	async->args.field_qualify_DstNivGports.niv_port_mask = niv_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstNivGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * niv_port_id,
	bcm_gport_t * niv_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTNIVGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstNivGports_get.unit = unit;
	async->args.field_qualify_DstNivGports_get.entry = entry;
	async->args.field_qualify_DstNivGports_get.niv_port_id = niv_port_id;
	async->args.field_qualify_DstNivGports_get.niv_port_mask = niv_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_module_t data_modid,
	bcm_module_t mask_modid,
	bcm_port_t data_port,
	bcm_port_t mask_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPort.unit = unit;
	async->args.field_qualify_DstPort.entry = entry;
	async->args.field_qualify_DstPort.data_modid = data_modid;
	async->args.field_qualify_DstPort.mask_modid = mask_modid;
	async->args.field_qualify_DstPort.data_port = data_port;
	async->args.field_qualify_DstPort.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRLanId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRLanId.unit = unit;
	async->args.field_qualify_DstPortSRLanId.entry = entry;
	async->args.field_qualify_DstPortSRLanId.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRLanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRLanId_get.unit = unit;
	async->args.field_qualify_DstPortSRLanId_get.entry = entry;
	async->args.field_qualify_DstPortSRLanId_get.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRMode_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_port_mode_t type,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRMODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRMode.unit = unit;
	async->args.field_qualify_DstPortSRMode.entry = entry;
	async->args.field_qualify_DstPortSRMode.type = type;
	async->args.field_qualify_DstPortSRMode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRMode_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_port_mode_t * type,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRMODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRMode_get.unit = unit;
	async->args.field_qualify_DstPortSRMode_get.entry = entry;
	async->args.field_qualify_DstPortSRMode_get.type = type;
	async->args.field_qualify_DstPortSRMode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRNetId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 net_id,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRNETID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRNetId.unit = unit;
	async->args.field_qualify_DstPortSRNetId.entry = entry;
	async->args.field_qualify_DstPortSRNetId.net_id = net_id;
	async->args.field_qualify_DstPortSRNetId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRNetId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * net_id,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRNETID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRNetId_get.unit = unit;
	async->args.field_qualify_DstPortSRNetId_get.entry = entry;
	async->args.field_qualify_DstPortSRNetId_get.net_id = net_id;
	async->args.field_qualify_DstPortSRNetId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRRoleInterlink_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRROLEINTERLINK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRRoleInterlink.unit = unit;
	async->args.field_qualify_DstPortSRRoleInterlink.entry = entry;
	async->args.field_qualify_DstPortSRRoleInterlink.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRRoleInterlink_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRROLEINTERLINK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRRoleInterlink_get.unit = unit;
	async->args.field_qualify_DstPortSRRoleInterlink_get.entry = entry;
	async->args.field_qualify_DstPortSRRoleInterlink_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_port_sr_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRType.unit = unit;
	async->args.field_qualify_DstPortSRType.entry = entry;
	async->args.field_qualify_DstPortSRType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPortSRType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_port_sr_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTSRTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPortSRType_get.unit = unit;
	async->args.field_qualify_DstPortSRType_get.entry = entry;
	async->args.field_qualify_DstPortSRType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_module_t * data_modid,
	bcm_module_t * mask_modid,
	bcm_port_t * data_port,
	bcm_port_t * mask_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPort_get.unit = unit;
	async->args.field_qualify_DstPort_get.entry = entry;
	async->args.field_qualify_DstPort_get.data_modid = data_modid;
	async->args.field_qualify_DstPort_get.mask_modid = mask_modid;
	async->args.field_qualify_DstPort_get.data_port = data_port;
	async->args.field_qualify_DstPort_get.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstRpfGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTRPFGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstRpfGport.unit = unit;
	async->args.field_qualify_DstRpfGport.entry = entry;
	async->args.field_qualify_DstRpfGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstRpfGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTRPFGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstRpfGport_get.unit = unit;
	async->args.field_qualify_DstRpfGport_get.entry = entry;
	async->args.field_qualify_DstRpfGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstSysPortExt_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTSYSPORTEXT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstSysPortExt.unit = unit;
	async->args.field_qualify_DstSysPortExt.entry = entry;
	async->args.field_qualify_DstSysPortExt.data = data;
	async->args.field_qualify_DstSysPortExt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstSysPortExt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTSYSPORTEXT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstSysPortExt_get.unit = unit;
	async->args.field_qualify_DstSysPortExt_get.entry = entry;
	async->args.field_qualify_DstSysPortExt_get.data = data;
	async->args.field_qualify_DstSysPortExt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstTrunk_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t data,
	bcm_trunk_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstTrunk.unit = unit;
	async->args.field_qualify_DstTrunk.entry = entry;
	async->args.field_qualify_DstTrunk.data = data;
	async->args.field_qualify_DstTrunk.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstTrunk_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t * data,
	bcm_trunk_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstTrunk_get.unit = unit;
	async->args.field_qualify_DstTrunk_get.entry = entry;
	async->args.field_qualify_DstTrunk_get.data = data;
	async->args.field_qualify_DstTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVlanGport.unit = unit;
	async->args.field_qualify_DstVlanGport.entry = entry;
	async->args.field_qualify_DstVlanGport.vlan_port_id = vlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVlanGport_get.unit = unit;
	async->args.field_qualify_DstVlanGport_get.entry = entry;
	async->args.field_qualify_DstVlanGport_get.vlan_port_id = vlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vlan_port_id,
	bcm_gport_t vlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVlanGports.unit = unit;
	async->args.field_qualify_DstVlanGports.entry = entry;
	async->args.field_qualify_DstVlanGports.vlan_port_id = vlan_port_id;
	async->args.field_qualify_DstVlanGports.vlan_port_mask = vlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vlan_port_id,
	bcm_gport_t * vlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVlanGports_get.unit = unit;
	async->args.field_qualify_DstVlanGports_get.entry = entry;
	async->args.field_qualify_DstVlanGports_get.vlan_port_id = vlan_port_id;
	async->args.field_qualify_DstVlanGports_get.vlan_port_mask = vlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVxlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vxlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVXLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVxlanGport.unit = unit;
	async->args.field_qualify_DstVxlanGport.entry = entry;
	async->args.field_qualify_DstVxlanGport.vxlan_port_id = vxlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVxlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vxlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVXLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVxlanGport_get.unit = unit;
	async->args.field_qualify_DstVxlanGport_get.entry = entry;
	async->args.field_qualify_DstVxlanGport_get.vxlan_port_id = vxlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVxlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vxlan_port_id,
	bcm_gport_t vxlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVXLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVxlanGports.unit = unit;
	async->args.field_qualify_DstVxlanGports.entry = entry;
	async->args.field_qualify_DstVxlanGports.vxlan_port_id = vxlan_port_id;
	async->args.field_qualify_DstVxlanGports.vxlan_port_mask = vxlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstVxlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vxlan_port_id,
	bcm_gport_t * vxlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTVXLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstVxlanGports_get.unit = unit;
	async->args.field_qualify_DstVxlanGports_get.entry = entry;
	async->args.field_qualify_DstVxlanGports_get.vxlan_port_id = vxlan_port_id;
	async->args.field_qualify_DstVxlanGports_get.vxlan_port_mask = vxlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstWlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGport.unit = unit;
	async->args.field_qualify_DstWlanGport.entry = entry;
	async->args.field_qualify_DstWlanGport.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstWlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGport_get.unit = unit;
	async->args.field_qualify_DstWlanGport_get.entry = entry;
	async->args.field_qualify_DstWlanGport_get.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstWlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcm_gport_t wlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGports.unit = unit;
	async->args.field_qualify_DstWlanGports.entry = entry;
	async->args.field_qualify_DstWlanGports.wlan_port_id = wlan_port_id;
	async->args.field_qualify_DstWlanGports.wlan_port_mask = wlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_DstWlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcm_gport_t * wlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGports_get.unit = unit;
	async->args.field_qualify_DstWlanGports_get.entry = entry;
	async->args.field_qualify_DstWlanGports_get.wlan_port_id = wlan_port_id;
	async->args.field_qualify_DstWlanGports_get.wlan_port_mask = wlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ECid_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ECID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ECid.unit = unit;
	async->args.field_qualify_ECid.entry = entry;
	async->args.field_qualify_ECid.data = data;
	async->args.field_qualify_ECid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ECid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ECID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ECid_get.unit = unit;
	async->args.field_qualify_ECid_get.entry = entry;
	async->args.field_qualify_ECid_get.data = data;
	async->args.field_qualify_ECid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ETag_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ETag.unit = unit;
	async->args.field_qualify_ETag.entry = entry;
	async->args.field_qualify_ETag.data = data;
	async->args.field_qualify_ETag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ETag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ETag_get.unit = unit;
	async->args.field_qualify_ETag_get.entry = entry;
	async->args.field_qualify_ETag_get.data = data;
	async->args.field_qualify_ETag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EcnValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ECNVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EcnValue.unit = unit;
	async->args.field_qualify_EcnValue.entry = entry;
	async->args.field_qualify_EcnValue.data = data;
	async->args.field_qualify_EcnValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EcnValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ECNVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EcnValue_get.unit = unit;
	async->args.field_qualify_EcnValue_get.entry = entry;
	async->args.field_qualify_EcnValue_get.data = data;
	async->args.field_qualify_EcnValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClass.unit = unit;
	async->args.field_qualify_EgressClass.entry = entry;
	async->args.field_qualify_EgressClass.data = data;
	async->args.field_qualify_EgressClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassL2Gre_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSL2GRE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassL2Gre.unit = unit;
	async->args.field_qualify_EgressClassL2Gre.entry = entry;
	async->args.field_qualify_EgressClassL2Gre.data = data;
	async->args.field_qualify_EgressClassL2Gre.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassL2Gre_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSL2GRE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassL2Gre_get.unit = unit;
	async->args.field_qualify_EgressClassL2Gre_get.entry = entry;
	async->args.field_qualify_EgressClassL2Gre_get.data = data;
	async->args.field_qualify_EgressClassL2Gre_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassL3Interface_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSL3INTERFACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassL3Interface.unit = unit;
	async->args.field_qualify_EgressClassL3Interface.entry = entry;
	async->args.field_qualify_EgressClassL3Interface.data = data;
	async->args.field_qualify_EgressClassL3Interface.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassL3Interface_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSL3INTERFACE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassL3Interface_get.unit = unit;
	async->args.field_qualify_EgressClassL3Interface_get.entry = entry;
	async->args.field_qualify_EgressClassL3Interface_get.data = data;
	async->args.field_qualify_EgressClassL3Interface_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassTrill_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSTRILL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassTrill.unit = unit;
	async->args.field_qualify_EgressClassTrill.entry = entry;
	async->args.field_qualify_EgressClassTrill.data = data;
	async->args.field_qualify_EgressClassTrill.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassTrill_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSTRILL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassTrill_get.unit = unit;
	async->args.field_qualify_EgressClassTrill_get.entry = entry;
	async->args.field_qualify_EgressClassTrill_get.data = data;
	async->args.field_qualify_EgressClassTrill_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassVxlan_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSVXLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassVxlan.unit = unit;
	async->args.field_qualify_EgressClassVxlan.entry = entry;
	async->args.field_qualify_EgressClassVxlan.data = data;
	async->args.field_qualify_EgressClassVxlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassVxlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSVXLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassVxlan_get.unit = unit;
	async->args.field_qualify_EgressClassVxlan_get.entry = entry;
	async->args.field_qualify_EgressClassVxlan_get.data = data;
	async->args.field_qualify_EgressClassVxlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassWlan_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSWLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassWlan.unit = unit;
	async->args.field_qualify_EgressClassWlan.entry = entry;
	async->args.field_qualify_EgressClassWlan.data = data;
	async->args.field_qualify_EgressClassWlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClassWlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASSWLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClassWlan_get.unit = unit;
	async->args.field_qualify_EgressClassWlan_get.entry = entry;
	async->args.field_qualify_EgressClassWlan_get.data = data;
	async->args.field_qualify_EgressClassWlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EgressClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EGRESSCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EgressClass_get.unit = unit;
	async->args.field_qualify_EgressClass_get.entry = entry;
	async->args.field_qualify_EgressClass_get.data = data;
	async->args.field_qualify_EgressClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EqualL4Port_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EQUALL4PORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EqualL4Port.unit = unit;
	async->args.field_qualify_EqualL4Port.entry = entry;
	async->args.field_qualify_EqualL4Port.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EqualL4Port_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EQUALL4PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EqualL4Port_get.unit = unit;
	async->args.field_qualify_EqualL4Port_get.entry = entry;
	async->args.field_qualify_EqualL4Port_get.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EtherType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherType.unit = unit;
	async->args.field_qualify_EtherType.entry = entry;
	async->args.field_qualify_EtherType.data = data;
	async->args.field_qualify_EtherType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EtherTypeClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPECLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherTypeClass.unit = unit;
	async->args.field_qualify_EtherTypeClass.entry = entry;
	async->args.field_qualify_EtherTypeClass.data = data;
	async->args.field_qualify_EtherTypeClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EtherTypeClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPECLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherTypeClass_get.unit = unit;
	async->args.field_qualify_EtherTypeClass_get.entry = entry;
	async->args.field_qualify_EtherTypeClass_get.data = data;
	async->args.field_qualify_EtherTypeClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EtherType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherType_get.unit = unit;
	async->args.field_qualify_EtherType_get.entry = entry;
	async->args.field_qualify_EtherType_get.data = data;
	async->args.field_qualify_EtherType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVlanTranslateKeyFirst_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVLANTRANSLATEKEYFIRST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst.unit = unit;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst.entry = entry;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst.data = data;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVlanTranslateKeyFirst_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVLANTRANSLATEKEYFIRST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst_get.unit = unit;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst_get.entry = entry;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst_get.data = data;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeyFirst_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVlanTranslateKeySecond_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVLANTRANSLATEKEYSECOND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond.unit = unit;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond.entry = entry;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond.data = data;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVlanTranslateKeySecond_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVLANTRANSLATEKEYSECOND_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond_get.unit = unit;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond_get.entry = entry;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond_get.data = data;
	async->args.field_qualify_EthernetOamClassVlanTranslateKeySecond_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVpn_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVPN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVpn.unit = unit;
	async->args.field_qualify_EthernetOamClassVpn.entry = entry;
	async->args.field_qualify_EthernetOamClassVpn.data = data;
	async->args.field_qualify_EthernetOamClassVpn.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamClassVpn_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMCLASSVPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamClassVpn_get.unit = unit;
	async->args.field_qualify_EthernetOamClassVpn_get.entry = entry;
	async->args.field_qualify_EthernetOamClassVpn_get.data = data;
	async->args.field_qualify_EthernetOamClassVpn_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamDstClassL2_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMDSTCLASSL2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamDstClassL2.unit = unit;
	async->args.field_qualify_EthernetOamDstClassL2.entry = entry;
	async->args.field_qualify_EthernetOamDstClassL2.data = data;
	async->args.field_qualify_EthernetOamDstClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamDstClassL2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMDSTCLASSL2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamDstClassL2_get.unit = unit;
	async->args.field_qualify_EthernetOamDstClassL2_get.entry = entry;
	async->args.field_qualify_EthernetOamDstClassL2_get.data = data;
	async->args.field_qualify_EthernetOamDstClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamHeaderBits0_31_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMHEADERBITS0_31;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamHeaderBits0_31.unit = unit;
	async->args.field_qualify_EthernetOamHeaderBits0_31.entry = entry;
	async->args.field_qualify_EthernetOamHeaderBits0_31.data = data;
	async->args.field_qualify_EthernetOamHeaderBits0_31.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamHeaderBits0_31_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMHEADERBITS0_31_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamHeaderBits0_31_get.unit = unit;
	async->args.field_qualify_EthernetOamHeaderBits0_31_get.entry = entry;
	async->args.field_qualify_EthernetOamHeaderBits0_31_get.data = data;
	async->args.field_qualify_EthernetOamHeaderBits0_31_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamHeaderBits32_63_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMHEADERBITS32_63;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamHeaderBits32_63.unit = unit;
	async->args.field_qualify_EthernetOamHeaderBits32_63.entry = entry;
	async->args.field_qualify_EthernetOamHeaderBits32_63.data = data;
	async->args.field_qualify_EthernetOamHeaderBits32_63.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamHeaderBits32_63_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMHEADERBITS32_63_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamHeaderBits32_63_get.unit = unit;
	async->args.field_qualify_EthernetOamHeaderBits32_63_get.entry = entry;
	async->args.field_qualify_EthernetOamHeaderBits32_63_get.data = data;
	async->args.field_qualify_EthernetOamHeaderBits32_63_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassMim_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSMIM;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassMim.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassMim.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassMim.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassMim.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassMim_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSMIM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassMim_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassMim_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassMim_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassMim_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassMpls_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSMPLS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassMpls.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassMpls.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassMpls.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassMpls.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassMpls_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSMPLS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassMpls_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassMpls_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassMpls_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassMpls_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassNiv_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSNIV;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassNiv.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassNiv.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassNiv.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassNiv.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassNiv_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSNIV_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassNiv_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassNiv_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassNiv_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassNiv_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassPort.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassPort.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassPort.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassPort_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassPort_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassPort_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassVlan_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassVlan.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassVlan.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassVlan.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassVlan_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassVlan_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassVlan_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassVxlan_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSVXLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamInterfaceClassVxlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMINTERFACECLASSVXLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan_get.unit = unit;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan_get.entry = entry;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan_get.data = data;
	async->args.field_qualify_EthernetOamInterfaceClassVxlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamTxPktUPMEP_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMTXPKTUPMEP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamTxPktUPMEP.unit = unit;
	async->args.field_qualify_EthernetOamTxPktUPMEP.entry = entry;
	async->args.field_qualify_EthernetOamTxPktUPMEP.data = data;
	async->args.field_qualify_EthernetOamTxPktUPMEP.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_EthernetOamTxPktUPMEP_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERNETOAMTXPKTUPMEP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EthernetOamTxPktUPMEP_get.unit = unit;
	async->args.field_qualify_EthernetOamTxPktUPMEP_get.entry = entry;
	async->args.field_qualify_EthernetOamTxPktUPMEP_get.data = data;
	async->args.field_qualify_EthernetOamTxPktUPMEP_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchActionClassId_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHACTIONCLASSID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchActionClassId.unit = unit;
	async->args.field_qualify_ExactMatchActionClassId.entry = entry;
	async->args.field_qualify_ExactMatchActionClassId.group_pri = group_pri;
	async->args.field_qualify_ExactMatchActionClassId.data = data;
	async->args.field_qualify_ExactMatchActionClassId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchActionClassId_get_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHACTIONCLASSID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchActionClassId_get.unit = unit;
	async->args.field_qualify_ExactMatchActionClassId_get.entry = entry;
	async->args.field_qualify_ExactMatchActionClassId_get.group_pri = group_pri;
	async->args.field_qualify_ExactMatchActionClassId_get.data = data;
	async->args.field_qualify_ExactMatchActionClassId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchGroupClassId_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	bcm_field_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHGROUPCLASSID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchGroupClassId.unit = unit;
	async->args.field_qualify_ExactMatchGroupClassId.entry = entry;
	async->args.field_qualify_ExactMatchGroupClassId.group_pri = group_pri;
	async->args.field_qualify_ExactMatchGroupClassId.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchGroupClassId_get_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	bcm_field_group_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHGROUPCLASSID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchGroupClassId_get.unit = unit;
	async->args.field_qualify_ExactMatchGroupClassId_get.entry = entry;
	async->args.field_qualify_ExactMatchGroupClassId_get.group_pri = group_pri;
	async->args.field_qualify_ExactMatchGroupClassId_get.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchHitStatus_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHHITSTATUS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchHitStatus.unit = unit;
	async->args.field_qualify_ExactMatchHitStatus.entry = entry;
	async->args.field_qualify_ExactMatchHitStatus.group_pri = group_pri;
	async->args.field_qualify_ExactMatchHitStatus.data = data;
	async->args.field_qualify_ExactMatchHitStatus.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExactMatchHitStatus_get_async(
	int unit,
	bcm_field_entry_t entry,
	int group_pri,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXACTMATCHHITSTATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExactMatchHitStatus_get.unit = unit;
	async->args.field_qualify_ExactMatchHitStatus_get.entry = entry;
	async->args.field_qualify_ExactMatchHitStatus_get.group_pri = group_pri;
	async->args.field_qualify_ExactMatchHitStatus_get.data = data;
	async->args.field_qualify_ExactMatchHitStatus_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeader2Type_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADER2TYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeader2Type.unit = unit;
	async->args.field_qualify_ExtensionHeader2Type.entry = entry;
	async->args.field_qualify_ExtensionHeader2Type.data = data;
	async->args.field_qualify_ExtensionHeader2Type.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeader2Type_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADER2TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeader2Type_get.unit = unit;
	async->args.field_qualify_ExtensionHeader2Type_get.entry = entry;
	async->args.field_qualify_ExtensionHeader2Type_get.data = data;
	async->args.field_qualify_ExtensionHeader2Type_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeaderSubCode_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderSubCode.unit = unit;
	async->args.field_qualify_ExtensionHeaderSubCode.entry = entry;
	async->args.field_qualify_ExtensionHeaderSubCode.data = data;
	async->args.field_qualify_ExtensionHeaderSubCode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeaderSubCode_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderSubCode_get.unit = unit;
	async->args.field_qualify_ExtensionHeaderSubCode_get.entry = entry;
	async->args.field_qualify_ExtensionHeaderSubCode_get.data = data;
	async->args.field_qualify_ExtensionHeaderSubCode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeaderType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderType.unit = unit;
	async->args.field_qualify_ExtensionHeaderType.entry = entry;
	async->args.field_qualify_ExtensionHeaderType.data = data;
	async->args.field_qualify_ExtensionHeaderType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExtensionHeaderType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderType_get.unit = unit;
	async->args.field_qualify_ExtensionHeaderType_get.entry = entry;
	async->args.field_qualify_ExtensionHeaderType_get.data = data;
	async->args.field_qualify_ExtensionHeaderType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit0_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT0;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit0.unit = unit;
	async->args.field_qualify_ExternalHit0.entry = entry;
	async->args.field_qualify_ExternalHit0.data = data;
	async->args.field_qualify_ExternalHit0.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit0_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT0_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit0_get.unit = unit;
	async->args.field_qualify_ExternalHit0_get.entry = entry;
	async->args.field_qualify_ExternalHit0_get.data = data;
	async->args.field_qualify_ExternalHit0_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit1_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT1;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit1.unit = unit;
	async->args.field_qualify_ExternalHit1.entry = entry;
	async->args.field_qualify_ExternalHit1.data = data;
	async->args.field_qualify_ExternalHit1.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit1_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit1_get.unit = unit;
	async->args.field_qualify_ExternalHit1_get.entry = entry;
	async->args.field_qualify_ExternalHit1_get.data = data;
	async->args.field_qualify_ExternalHit1_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit2_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit2.unit = unit;
	async->args.field_qualify_ExternalHit2.entry = entry;
	async->args.field_qualify_ExternalHit2.data = data;
	async->args.field_qualify_ExternalHit2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit2_get.unit = unit;
	async->args.field_qualify_ExternalHit2_get.entry = entry;
	async->args.field_qualify_ExternalHit2_get.data = data;
	async->args.field_qualify_ExternalHit2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit3_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit3.unit = unit;
	async->args.field_qualify_ExternalHit3.entry = entry;
	async->args.field_qualify_ExternalHit3.data = data;
	async->args.field_qualify_ExternalHit3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit3_get.unit = unit;
	async->args.field_qualify_ExternalHit3_get.entry = entry;
	async->args.field_qualify_ExternalHit3_get.data = data;
	async->args.field_qualify_ExternalHit3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit4_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT4;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit4.unit = unit;
	async->args.field_qualify_ExternalHit4.entry = entry;
	async->args.field_qualify_ExternalHit4.data = data;
	async->args.field_qualify_ExternalHit4.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit4_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT4_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit4_get.unit = unit;
	async->args.field_qualify_ExternalHit4_get.entry = entry;
	async->args.field_qualify_ExternalHit4_get.data = data;
	async->args.field_qualify_ExternalHit4_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit5_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT5;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit5.unit = unit;
	async->args.field_qualify_ExternalHit5.entry = entry;
	async->args.field_qualify_ExternalHit5.data = data;
	async->args.field_qualify_ExternalHit5.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit5_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT5_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit5_get.unit = unit;
	async->args.field_qualify_ExternalHit5_get.entry = entry;
	async->args.field_qualify_ExternalHit5_get.data = data;
	async->args.field_qualify_ExternalHit5_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit6_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit6.unit = unit;
	async->args.field_qualify_ExternalHit6.entry = entry;
	async->args.field_qualify_ExternalHit6.data = data;
	async->args.field_qualify_ExternalHit6.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit6_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit6_get.unit = unit;
	async->args.field_qualify_ExternalHit6_get.entry = entry;
	async->args.field_qualify_ExternalHit6_get.data = data;
	async->args.field_qualify_ExternalHit6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit7_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT7;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit7.unit = unit;
	async->args.field_qualify_ExternalHit7.entry = entry;
	async->args.field_qualify_ExternalHit7.data = data;
	async->args.field_qualify_ExternalHit7.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalHit7_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALHIT7_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalHit7_get.unit = unit;
	async->args.field_qualify_ExternalHit7_get.entry = entry;
	async->args.field_qualify_ExternalHit7_get.data = data;
	async->args.field_qualify_ExternalHit7_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue0_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE0;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue0.unit = unit;
	async->args.field_qualify_ExternalValue0.entry = entry;
	async->args.field_qualify_ExternalValue0.data = data;
	async->args.field_qualify_ExternalValue0.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue0_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE0_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue0_get.unit = unit;
	async->args.field_qualify_ExternalValue0_get.entry = entry;
	async->args.field_qualify_ExternalValue0_get.data = data;
	async->args.field_qualify_ExternalValue0_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue1_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE1;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue1.unit = unit;
	async->args.field_qualify_ExternalValue1.entry = entry;
	async->args.field_qualify_ExternalValue1.data = data;
	async->args.field_qualify_ExternalValue1.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue1_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue1_get.unit = unit;
	async->args.field_qualify_ExternalValue1_get.entry = entry;
	async->args.field_qualify_ExternalValue1_get.data = data;
	async->args.field_qualify_ExternalValue1_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue2_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue2.unit = unit;
	async->args.field_qualify_ExternalValue2.entry = entry;
	async->args.field_qualify_ExternalValue2.data = data;
	async->args.field_qualify_ExternalValue2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue2_get.unit = unit;
	async->args.field_qualify_ExternalValue2_get.entry = entry;
	async->args.field_qualify_ExternalValue2_get.data = data;
	async->args.field_qualify_ExternalValue2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue3_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue3.unit = unit;
	async->args.field_qualify_ExternalValue3.entry = entry;
	async->args.field_qualify_ExternalValue3.data = data;
	async->args.field_qualify_ExternalValue3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue3_get.unit = unit;
	async->args.field_qualify_ExternalValue3_get.entry = entry;
	async->args.field_qualify_ExternalValue3_get.data = data;
	async->args.field_qualify_ExternalValue3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue4_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE4;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue4.unit = unit;
	async->args.field_qualify_ExternalValue4.entry = entry;
	async->args.field_qualify_ExternalValue4.data = data;
	async->args.field_qualify_ExternalValue4.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue4_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE4_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue4_get.unit = unit;
	async->args.field_qualify_ExternalValue4_get.entry = entry;
	async->args.field_qualify_ExternalValue4_get.data = data;
	async->args.field_qualify_ExternalValue4_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue5_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE5;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue5.unit = unit;
	async->args.field_qualify_ExternalValue5.entry = entry;
	async->args.field_qualify_ExternalValue5.data = data;
	async->args.field_qualify_ExternalValue5.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue5_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE5_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue5_get.unit = unit;
	async->args.field_qualify_ExternalValue5_get.entry = entry;
	async->args.field_qualify_ExternalValue5_get.data = data;
	async->args.field_qualify_ExternalValue5_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue6_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue6.unit = unit;
	async->args.field_qualify_ExternalValue6.entry = entry;
	async->args.field_qualify_ExternalValue6.data = data;
	async->args.field_qualify_ExternalValue6.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue6_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue6_get.unit = unit;
	async->args.field_qualify_ExternalValue6_get.entry = entry;
	async->args.field_qualify_ExternalValue6_get.data = data;
	async->args.field_qualify_ExternalValue6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue7_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE7;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue7.unit = unit;
	async->args.field_qualify_ExternalValue7.entry = entry;
	async->args.field_qualify_ExternalValue7.data = data;
	async->args.field_qualify_ExternalValue7.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ExternalValue7_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTERNALVALUE7_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExternalValue7_get.unit = unit;
	async->args.field_qualify_ExternalValue7_get.entry = entry;
	async->args.field_qualify_ExternalValue7_get.data = data;
	async->args.field_qualify_ExternalValue7_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FabricQueueTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FABRICQUEUETAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FabricQueueTag.unit = unit;
	async->args.field_qualify_FabricQueueTag.entry = entry;
	async->args.field_qualify_FabricQueueTag.data = data;
	async->args.field_qualify_FabricQueueTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FabricQueueTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FABRICQUEUETAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FabricQueueTag_get.unit = unit;
	async->args.field_qualify_FabricQueueTag_get.entry = entry;
	async->args.field_qualify_FabricQueueTag_get.data = data;
	async->args.field_qualify_FabricQueueTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeOxID_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEOXID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeOxID.unit = unit;
	async->args.field_qualify_FcoeOxID.entry = entry;
	async->args.field_qualify_FcoeOxID.data = data;
	async->args.field_qualify_FcoeOxID.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeOxIDClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEOXIDCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeOxIDClass.unit = unit;
	async->args.field_qualify_FcoeOxIDClass.entry = entry;
	async->args.field_qualify_FcoeOxIDClass.data = data;
	async->args.field_qualify_FcoeOxIDClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeOxIDClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEOXIDCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeOxIDClass_get.unit = unit;
	async->args.field_qualify_FcoeOxIDClass_get.entry = entry;
	async->args.field_qualify_FcoeOxIDClass_get.data = data;
	async->args.field_qualify_FcoeOxIDClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeOxID_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEOXID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeOxID_get.unit = unit;
	async->args.field_qualify_FcoeOxID_get.entry = entry;
	async->args.field_qualify_FcoeOxID_get.data = data;
	async->args.field_qualify_FcoeOxID_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeRxID_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOERXID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeRxID.unit = unit;
	async->args.field_qualify_FcoeRxID.entry = entry;
	async->args.field_qualify_FcoeRxID.data = data;
	async->args.field_qualify_FcoeRxID.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeRxIDClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOERXIDCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeRxIDClass.unit = unit;
	async->args.field_qualify_FcoeRxIDClass.entry = entry;
	async->args.field_qualify_FcoeRxIDClass.data = data;
	async->args.field_qualify_FcoeRxIDClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeRxIDClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOERXIDCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeRxIDClass_get.unit = unit;
	async->args.field_qualify_FcoeRxIDClass_get.entry = entry;
	async->args.field_qualify_FcoeRxIDClass_get.data = data;
	async->args.field_qualify_FcoeRxIDClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeRxID_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOERXID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeRxID_get.unit = unit;
	async->args.field_qualify_FcoeRxID_get.entry = entry;
	async->args.field_qualify_FcoeRxID_get.data = data;
	async->args.field_qualify_FcoeRxID_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeSOF_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOESOF;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeSOF.unit = unit;
	async->args.field_qualify_FcoeSOF.entry = entry;
	async->args.field_qualify_FcoeSOF.data = data;
	async->args.field_qualify_FcoeSOF.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeSOF_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOESOF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeSOF_get.unit = unit;
	async->args.field_qualify_FcoeSOF_get.entry = entry;
	async->args.field_qualify_FcoeSOF_get.data = data;
	async->args.field_qualify_FcoeSOF_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeVersionIsZero_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEVERSIONISZERO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeVersionIsZero.unit = unit;
	async->args.field_qualify_FcoeVersionIsZero.entry = entry;
	async->args.field_qualify_FcoeVersionIsZero.data = data;
	async->args.field_qualify_FcoeVersionIsZero.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FcoeVersionIsZero_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FCOEVERSIONISZERO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FcoeVersionIsZero_get.unit = unit;
	async->args.field_qualify_FcoeVersionIsZero_get.entry = entry;
	async->args.field_qualify_FcoeVersionIsZero_get.data = data;
	async->args.field_qualify_FcoeVersionIsZero_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Fhei_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FHEI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Fhei.unit = unit;
	async->args.field_qualify_Fhei.entry = entry;
	async->args.field_qualify_Fhei.data = data;
	async->args.field_qualify_Fhei.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FheiSize_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FHEISIZE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FheiSize.unit = unit;
	async->args.field_qualify_FheiSize.entry = entry;
	async->args.field_qualify_FheiSize.data = data;
	async->args.field_qualify_FheiSize.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FheiSize_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FHEISIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FheiSize_get.unit = unit;
	async->args.field_qualify_FheiSize_get.entry = entry;
	async->args.field_qualify_FheiSize_get.data = data;
	async->args.field_qualify_FheiSize_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Fhei_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FHEI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Fhei_get.unit = unit;
	async->args.field_qualify_Fhei_get.entry = entry;
	async->args.field_qualify_Fhei_get.data = data;
	async->args.field_qualify_Fhei_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanCSCtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANCSCTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanCSCtl.unit = unit;
	async->args.field_qualify_FibreChanCSCtl.entry = entry;
	async->args.field_qualify_FibreChanCSCtl.data = data;
	async->args.field_qualify_FibreChanCSCtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanCSCtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANCSCTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanCSCtl_get.unit = unit;
	async->args.field_qualify_FibreChanCSCtl_get.entry = entry;
	async->args.field_qualify_FibreChanCSCtl_get.data = data;
	async->args.field_qualify_FibreChanCSCtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDFCtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDFCTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDFCtl.unit = unit;
	async->args.field_qualify_FibreChanDFCtl.entry = entry;
	async->args.field_qualify_FibreChanDFCtl.data = data;
	async->args.field_qualify_FibreChanDFCtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDFCtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDFCTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDFCtl_get.unit = unit;
	async->args.field_qualify_FibreChanDFCtl_get.entry = entry;
	async->args.field_qualify_FibreChanDFCtl_get.data = data;
	async->args.field_qualify_FibreChanDFCtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstId.unit = unit;
	async->args.field_qualify_FibreChanDstId.entry = entry;
	async->args.field_qualify_FibreChanDstId.data = data;
	async->args.field_qualify_FibreChanDstId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClass.unit = unit;
	async->args.field_qualify_FibreChanDstIdClass.entry = entry;
	async->args.field_qualify_FibreChanDstIdClass.data = data;
	async->args.field_qualify_FibreChanDstIdClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassLower.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassLower.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassLower.data = data;
	async->args.field_qualify_FibreChanDstIdClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassLower_get.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassLower_get.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassLower_get.data = data;
	async->args.field_qualify_FibreChanDstIdClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble.data = data;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble_get.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble_get.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble_get.data = data;
	async->args.field_qualify_FibreChanDstIdClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassUpper.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassUpper.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassUpper.data = data;
	async->args.field_qualify_FibreChanDstIdClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClassUpper_get.unit = unit;
	async->args.field_qualify_FibreChanDstIdClassUpper_get.entry = entry;
	async->args.field_qualify_FibreChanDstIdClassUpper_get.data = data;
	async->args.field_qualify_FibreChanDstIdClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstIdClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTIDCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstIdClass_get.unit = unit;
	async->args.field_qualify_FibreChanDstIdClass_get.entry = entry;
	async->args.field_qualify_FibreChanDstIdClass_get.data = data;
	async->args.field_qualify_FibreChanDstIdClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanDstId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANDSTID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanDstId_get.unit = unit;
	async->args.field_qualify_FibreChanDstId_get.entry = entry;
	async->args.field_qualify_FibreChanDstId_get.data = data;
	async->args.field_qualify_FibreChanDstId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanFCtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANFCTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanFCtl.unit = unit;
	async->args.field_qualify_FibreChanFCtl.entry = entry;
	async->args.field_qualify_FibreChanFCtl.data = data;
	async->args.field_qualify_FibreChanFCtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanFCtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANFCTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanFCtl_get.unit = unit;
	async->args.field_qualify_FibreChanFCtl_get.entry = entry;
	async->args.field_qualify_FibreChanFCtl_get.data = data;
	async->args.field_qualify_FibreChanFCtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanInner_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t fibre_chan_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANINNER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanInner.unit = unit;
	async->args.field_qualify_FibreChanInner.entry = entry;
	async->args.field_qualify_FibreChanInner.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanInner_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t * fibre_chan_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANINNER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanInner_get.unit = unit;
	async->args.field_qualify_FibreChanInner_get.entry = entry;
	async->args.field_qualify_FibreChanInner_get.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanOuter_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t fibre_chan_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANOUTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanOuter.unit = unit;
	async->args.field_qualify_FibreChanOuter.entry = entry;
	async->args.field_qualify_FibreChanOuter.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanOuter_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t * fibre_chan_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANOUTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanOuter_get.unit = unit;
	async->args.field_qualify_FibreChanOuter_get.entry = entry;
	async->args.field_qualify_FibreChanOuter_get.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanRCtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANRCTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanRCtl.unit = unit;
	async->args.field_qualify_FibreChanRCtl.entry = entry;
	async->args.field_qualify_FibreChanRCtl.data = data;
	async->args.field_qualify_FibreChanRCtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanRCtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANRCTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanRCtl_get.unit = unit;
	async->args.field_qualify_FibreChanRCtl_get.entry = entry;
	async->args.field_qualify_FibreChanRCtl_get.data = data;
	async->args.field_qualify_FibreChanRCtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcBindCheck_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCBINDCHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcBindCheck.unit = unit;
	async->args.field_qualify_FibreChanSrcBindCheck.entry = entry;
	async->args.field_qualify_FibreChanSrcBindCheck.data = data;
	async->args.field_qualify_FibreChanSrcBindCheck.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcBindCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCBINDCHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcBindCheck_get.unit = unit;
	async->args.field_qualify_FibreChanSrcBindCheck_get.entry = entry;
	async->args.field_qualify_FibreChanSrcBindCheck_get.data = data;
	async->args.field_qualify_FibreChanSrcBindCheck_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcFpmaCheck_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCFPMACHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcFpmaCheck.unit = unit;
	async->args.field_qualify_FibreChanSrcFpmaCheck.entry = entry;
	async->args.field_qualify_FibreChanSrcFpmaCheck.data = data;
	async->args.field_qualify_FibreChanSrcFpmaCheck.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcFpmaCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCFPMACHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcFpmaCheck_get.unit = unit;
	async->args.field_qualify_FibreChanSrcFpmaCheck_get.entry = entry;
	async->args.field_qualify_FibreChanSrcFpmaCheck_get.data = data;
	async->args.field_qualify_FibreChanSrcFpmaCheck_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcId.unit = unit;
	async->args.field_qualify_FibreChanSrcId.entry = entry;
	async->args.field_qualify_FibreChanSrcId.data = data;
	async->args.field_qualify_FibreChanSrcId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClass.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClass.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClass.data = data;
	async->args.field_qualify_FibreChanSrcIdClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassLower.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassLower.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassLower.data = data;
	async->args.field_qualify_FibreChanSrcIdClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassLower_get.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassLower_get.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassLower_get.data = data;
	async->args.field_qualify_FibreChanSrcIdClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble.data = data;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble_get.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble_get.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble_get.data = data;
	async->args.field_qualify_FibreChanSrcIdClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassUpper.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassUpper.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassUpper.data = data;
	async->args.field_qualify_FibreChanSrcIdClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClassUpper_get.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClassUpper_get.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClassUpper_get.data = data;
	async->args.field_qualify_FibreChanSrcIdClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcIdClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCIDCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcIdClass_get.unit = unit;
	async->args.field_qualify_FibreChanSrcIdClass_get.entry = entry;
	async->args.field_qualify_FibreChanSrcIdClass_get.data = data;
	async->args.field_qualify_FibreChanSrcIdClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanSrcId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANSRCID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanSrcId_get.unit = unit;
	async->args.field_qualify_FibreChanSrcId_get.entry = entry;
	async->args.field_qualify_FibreChanSrcId_get.data = data;
	async->args.field_qualify_FibreChanSrcId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanType.unit = unit;
	async->args.field_qualify_FibreChanType.entry = entry;
	async->args.field_qualify_FibreChanType.data = data;
	async->args.field_qualify_FibreChanType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanType_get.unit = unit;
	async->args.field_qualify_FibreChanType_get.entry = entry;
	async->args.field_qualify_FibreChanType_get.data = data;
	async->args.field_qualify_FibreChanType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTFabricId_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTFABRICID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTFabricId.unit = unit;
	async->args.field_qualify_FibreChanVFTFabricId.entry = entry;
	async->args.field_qualify_FibreChanVFTFabricId.data = data;
	async->args.field_qualify_FibreChanVFTFabricId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTFabricId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTFABRICID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTFabricId_get.unit = unit;
	async->args.field_qualify_FibreChanVFTFabricId_get.entry = entry;
	async->args.field_qualify_FibreChanVFTFabricId_get.data = data;
	async->args.field_qualify_FibreChanVFTFabricId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTHopCount_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTHOPCOUNT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTHopCount.unit = unit;
	async->args.field_qualify_FibreChanVFTHopCount.entry = entry;
	async->args.field_qualify_FibreChanVFTHopCount.data = data;
	async->args.field_qualify_FibreChanVFTHopCount.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTHopCount_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTHOPCOUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTHopCount_get.unit = unit;
	async->args.field_qualify_FibreChanVFTHopCount_get.entry = entry;
	async->args.field_qualify_FibreChanVFTHopCount_get.data = data;
	async->args.field_qualify_FibreChanVFTHopCount_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTPri.unit = unit;
	async->args.field_qualify_FibreChanVFTPri.entry = entry;
	async->args.field_qualify_FibreChanVFTPri.data = data;
	async->args.field_qualify_FibreChanVFTPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTPri_get.unit = unit;
	async->args.field_qualify_FibreChanVFTPri_get.entry = entry;
	async->args.field_qualify_FibreChanVFTPri_get.data = data;
	async->args.field_qualify_FibreChanVFTPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTValid.unit = unit;
	async->args.field_qualify_FibreChanVFTValid.entry = entry;
	async->args.field_qualify_FibreChanVFTValid.data = data;
	async->args.field_qualify_FibreChanVFTValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTValid_get.unit = unit;
	async->args.field_qualify_FibreChanVFTValid_get.entry = entry;
	async->args.field_qualify_FibreChanVFTValid_get.data = data;
	async->args.field_qualify_FibreChanVFTValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVersion_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVERSION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVersion.unit = unit;
	async->args.field_qualify_FibreChanVFTVersion.entry = entry;
	async->args.field_qualify_FibreChanVFTVersion.data = data;
	async->args.field_qualify_FibreChanVFTVersion.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVersion_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVERSION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVersion_get.unit = unit;
	async->args.field_qualify_FibreChanVFTVersion_get.entry = entry;
	async->args.field_qualify_FibreChanVFTVersion_get.data = data;
	async->args.field_qualify_FibreChanVFTVersion_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVsanId_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVSANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVsanId.unit = unit;
	async->args.field_qualify_FibreChanVFTVsanId.entry = entry;
	async->args.field_qualify_FibreChanVFTVsanId.data = data;
	async->args.field_qualify_FibreChanVFTVsanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVsanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVSANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVsanId_get.unit = unit;
	async->args.field_qualify_FibreChanVFTVsanId_get.entry = entry;
	async->args.field_qualify_FibreChanVFTVsanId_get.data = data;
	async->args.field_qualify_FibreChanVFTVsanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVsanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVSANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVsanPri.unit = unit;
	async->args.field_qualify_FibreChanVFTVsanPri.entry = entry;
	async->args.field_qualify_FibreChanVFTVsanPri.data = data;
	async->args.field_qualify_FibreChanVFTVsanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanVFTVsanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANVFTVSANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanVFTVsanPri_get.unit = unit;
	async->args.field_qualify_FibreChanVFTVsanPri_get.entry = entry;
	async->args.field_qualify_FibreChanVFTVsanPri_get.data = data;
	async->args.field_qualify_FibreChanVFTVsanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanZoneCheck_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANZONECHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanZoneCheck.unit = unit;
	async->args.field_qualify_FibreChanZoneCheck.entry = entry;
	async->args.field_qualify_FibreChanZoneCheck.data = data;
	async->args.field_qualify_FibreChanZoneCheck.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FibreChanZoneCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANZONECHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanZoneCheck_get.unit = unit;
	async->args.field_qualify_FibreChanZoneCheck_get.entry = entry;
	async->args.field_qualify_FibreChanZoneCheck_get.data = data;
	async->args.field_qualify_FibreChanZoneCheck_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FlowId_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FLOWID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FlowId.unit = unit;
	async->args.field_qualify_FlowId.entry = entry;
	async->args.field_qualify_FlowId.data = data;
	async->args.field_qualify_FlowId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_FlowId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FLOWID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FlowId_get.unit = unit;
	async->args.field_qualify_FlowId_get.entry = entry;
	async->args.field_qualify_FlowId_get.data = data;
	async->args.field_qualify_FlowId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardCopy_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDCOPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardCopy.unit = unit;
	async->args.field_qualify_ForwardCopy.entry = entry;
	async->args.field_qualify_ForwardCopy.data = data;
	async->args.field_qualify_ForwardCopy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardCopy_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDCOPY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardCopy_get.unit = unit;
	async->args.field_qualify_ForwardCopy_get.entry = entry;
	async->args.field_qualify_ForwardCopy_get.data = data;
	async->args.field_qualify_ForwardCopy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrDstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRDSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrDstMac.unit = unit;
	async->args.field_qualify_ForwardHdrDstMac.entry = entry;
	async->args.field_qualify_ForwardHdrDstMac.data = (uint8 *)data;
	async->args.field_qualify_ForwardHdrDstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrDstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRDSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrDstMac_get.unit = unit;
	async->args.field_qualify_ForwardHdrDstMac_get.entry = entry;
	async->args.field_qualify_ForwardHdrDstMac_get.data = data;
	async->args.field_qualify_ForwardHdrDstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrSrcMac.unit = unit;
	async->args.field_qualify_ForwardHdrSrcMac.entry = entry;
	async->args.field_qualify_ForwardHdrSrcMac.data = (uint8 *)data;
	async->args.field_qualify_ForwardHdrSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrSrcMac_get.unit = unit;
	async->args.field_qualify_ForwardHdrSrcMac_get.entry = entry;
	async->args.field_qualify_ForwardHdrSrcMac_get.data = data;
	async->args.field_qualify_ForwardHdrSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrVlanId.unit = unit;
	async->args.field_qualify_ForwardHdrVlanId.entry = entry;
	async->args.field_qualify_ForwardHdrVlanId.data = data;
	async->args.field_qualify_ForwardHdrVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardHdrVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDHDRVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardHdrVlanId_get.unit = unit;
	async->args.field_qualify_ForwardHdrVlanId_get.entry = entry;
	async->args.field_qualify_ForwardHdrVlanId_get.data = data;
	async->args.field_qualify_ForwardHdrVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingHeaderOffset_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_data_offset_base_t base_header,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGHEADEROFFSET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingHeaderOffset.unit = unit;
	async->args.field_qualify_ForwardingHeaderOffset.entry = entry;
	async->args.field_qualify_ForwardingHeaderOffset.base_header = base_header;
	async->args.field_qualify_ForwardingHeaderOffset.data = data;
	async->args.field_qualify_ForwardingHeaderOffset.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingHeaderOffset_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_data_offset_base_t * base_header,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGHEADEROFFSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingHeaderOffset_get.unit = unit;
	async->args.field_qualify_ForwardingHeaderOffset_get.entry = entry;
	async->args.field_qualify_ForwardingHeaderOffset_get.base_header = base_header;
	async->args.field_qualify_ForwardingHeaderOffset_get.data = data;
	async->args.field_qualify_ForwardingHeaderOffset_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_ForwardingType_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingType.unit = unit;
	async->args.field_qualify_ForwardingType.entry = entry;
	async->args.field_qualify_ForwardingType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_ForwardingType_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingType_get.unit = unit;
	async->args.field_qualify_ForwardingType_get.entry = entry;
	async->args.field_qualify_ForwardingType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanId.unit = unit;
	async->args.field_qualify_ForwardingVlanId.entry = entry;
	async->args.field_qualify_ForwardingVlanId.data = data;
	async->args.field_qualify_ForwardingVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanId_get.unit = unit;
	async->args.field_qualify_ForwardingVlanId_get.entry = entry;
	async->args.field_qualify_ForwardingVlanId_get.data = data;
	async->args.field_qualify_ForwardingVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingVlanValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanValid.unit = unit;
	async->args.field_qualify_ForwardingVlanValid.entry = entry;
	async->args.field_qualify_ForwardingVlanValid.data = data;
	async->args.field_qualify_ForwardingVlanValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ForwardingVlanValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanValid_get.unit = unit;
	async->args.field_qualify_ForwardingVlanValid_get.entry = entry;
	async->args.field_qualify_ForwardingVlanValid_get.data = data;
	async->args.field_qualify_ForwardingVlanValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GeneratedTtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GENERATEDTTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GeneratedTtl.unit = unit;
	async->args.field_qualify_GeneratedTtl.entry = entry;
	async->args.field_qualify_GeneratedTtl.data = data;
	async->args.field_qualify_GeneratedTtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GeneratedTtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GENERATEDTTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GeneratedTtl_get.unit = unit;
	async->args.field_qualify_GeneratedTtl_get.entry = entry;
	async->args.field_qualify_GeneratedTtl_get.data = data;
	async->args.field_qualify_GeneratedTtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GenericAssociatedChannelLabelValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GENERICASSOCIATEDCHANNELLABELVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GenericAssociatedChannelLabelValid.unit = unit;
	async->args.field_qualify_GenericAssociatedChannelLabelValid.entry = entry;
	async->args.field_qualify_GenericAssociatedChannelLabelValid.data = data;
	async->args.field_qualify_GenericAssociatedChannelLabelValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GenericAssociatedChannelLabelValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GENERICASSOCIATEDCHANNELLABELVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GenericAssociatedChannelLabelValid_get.unit = unit;
	async->args.field_qualify_GenericAssociatedChannelLabelValid_get.entry = entry;
	async->args.field_qualify_GenericAssociatedChannelLabelValid_get.data = data;
	async->args.field_qualify_GenericAssociatedChannelLabelValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GroupClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GROUPCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GroupClass.unit = unit;
	async->args.field_qualify_GroupClass.entry = entry;
	async->args.field_qualify_GroupClass.data = data;
	async->args.field_qualify_GroupClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_GroupClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_GROUPCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_GroupClass_get.unit = unit;
	async->args.field_qualify_GroupClass_get.entry = entry;
	async->args.field_qualify_GroupClass_get.data = data;
	async->args.field_qualify_GroupClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HeaderFormat_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_header_format_t header_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HEADERFORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HeaderFormat.unit = unit;
	async->args.field_qualify_HeaderFormat.entry = entry;
	async->args.field_qualify_HeaderFormat.header_format = header_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HeaderFormatSet_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_header_format_set_t header_format_set,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HEADERFORMATSET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HeaderFormatSet.unit = unit;
	async->args.field_qualify_HeaderFormatSet.entry = entry;
	async->args.field_qualify_HeaderFormatSet.header_format_set = header_format_set;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HeaderFormatSet_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_header_format_set_t * header_format_set,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HEADERFORMATSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HeaderFormatSet_get.unit = unit;
	async->args.field_qualify_HeaderFormatSet_get.entry = entry;
	async->args.field_qualify_HeaderFormatSet_get.header_format_set = header_format_set;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HeaderFormat_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_header_format_t * header_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HEADERFORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HeaderFormat_get.unit = unit;
	async->args.field_qualify_HeaderFormat_get.entry = entry;
	async->args.field_qualify_HeaderFormat_get.header_format = header_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGig_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGig.unit = unit;
	async->args.field_qualify_HiGig.entry = entry;
	async->args.field_qualify_HiGig.data = data;
	async->args.field_qualify_HiGig.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigColor_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGCOLOR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigColor.unit = unit;
	async->args.field_qualify_HiGigColor.entry = entry;
	async->args.field_qualify_HiGigColor.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigColor_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGCOLOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigColor_get.unit = unit;
	async->args.field_qualify_HiGigColor_get.entry = entry;
	async->args.field_qualify_HiGigColor_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDoNotFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDONOTFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDoNotFlags.unit = unit;
	async->args.field_qualify_HiGigDoNotFlags.entry = entry;
	async->args.field_qualify_HiGigDoNotFlags.data = data;
	async->args.field_qualify_HiGigDoNotFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDoNotFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDONOTFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDoNotFlags_get.unit = unit;
	async->args.field_qualify_HiGigDoNotFlags_get.entry = entry;
	async->args.field_qualify_HiGigDoNotFlags_get.data = data;
	async->args.field_qualify_HiGigDoNotFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstGport.unit = unit;
	async->args.field_qualify_HiGigDstGport.entry = entry;
	async->args.field_qualify_HiGigDstGport.port_id = port_id;
	async->args.field_qualify_HiGigDstGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstGport_get.unit = unit;
	async->args.field_qualify_HiGigDstGport_get.entry = entry;
	async->args.field_qualify_HiGigDstGport_get.port_id = port_id;
	async->args.field_qualify_HiGigDstGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstModPortGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMODPORTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstModPortGport.unit = unit;
	async->args.field_qualify_HiGigDstModPortGport.entry = entry;
	async->args.field_qualify_HiGigDstModPortGport.port_id = port_id;
	async->args.field_qualify_HiGigDstModPortGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstModPortGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMODPORTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstModPortGport_get.unit = unit;
	async->args.field_qualify_HiGigDstModPortGport_get.entry = entry;
	async->args.field_qualify_HiGigDstModPortGport_get.port_id = port_id;
	async->args.field_qualify_HiGigDstModPortGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstModuleGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMODULEGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstModuleGport.unit = unit;
	async->args.field_qualify_HiGigDstModuleGport.entry = entry;
	async->args.field_qualify_HiGigDstModuleGport.port_id = port_id;
	async->args.field_qualify_HiGigDstModuleGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstModuleGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMODULEGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstModuleGport_get.unit = unit;
	async->args.field_qualify_HiGigDstModuleGport_get.entry = entry;
	async->args.field_qualify_HiGigDstModuleGport_get.port_id = port_id;
	async->args.field_qualify_HiGigDstModuleGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstMulticast_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMULTICAST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstMulticast.unit = unit;
	async->args.field_qualify_HiGigDstMulticast.entry = entry;
	async->args.field_qualify_HiGigDstMulticast.data = data;
	async->args.field_qualify_HiGigDstMulticast.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstMulticastGroupId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t group,
	bcm_multicast_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMULTICASTGROUPID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstMulticastGroupId.unit = unit;
	async->args.field_qualify_HiGigDstMulticastGroupId.entry = entry;
	async->args.field_qualify_HiGigDstMulticastGroupId.group = group;
	async->args.field_qualify_HiGigDstMulticastGroupId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstMulticastGroupId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_multicast_t * group,
	bcm_multicast_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMULTICASTGROUPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstMulticastGroupId_get.unit = unit;
	async->args.field_qualify_HiGigDstMulticastGroupId_get.entry = entry;
	async->args.field_qualify_HiGigDstMulticastGroupId_get.group = group;
	async->args.field_qualify_HiGigDstMulticastGroupId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstMulticast_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTMULTICAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstMulticast_get.unit = unit;
	async->args.field_qualify_HiGigDstMulticast_get.entry = entry;
	async->args.field_qualify_HiGigDstMulticast_get.data = data;
	async->args.field_qualify_HiGigDstMulticast_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstPortGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTPORTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstPortGport.unit = unit;
	async->args.field_qualify_HiGigDstPortGport.entry = entry;
	async->args.field_qualify_HiGigDstPortGport.port_id = port_id;
	async->args.field_qualify_HiGigDstPortGport.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstPortGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTPORTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstPortGport_get.unit = unit;
	async->args.field_qualify_HiGigDstPortGport_get.entry = entry;
	async->args.field_qualify_HiGigDstPortGport_get.port_id = port_id;
	async->args.field_qualify_HiGigDstPortGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstTrunk_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstTrunk.unit = unit;
	async->args.field_qualify_HiGigDstTrunk.entry = entry;
	async->args.field_qualify_HiGigDstTrunk.data = data;
	async->args.field_qualify_HiGigDstTrunk.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstTrunkId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t data,
	bcm_trunk_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTRUNKID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstTrunkId.unit = unit;
	async->args.field_qualify_HiGigDstTrunkId.entry = entry;
	async->args.field_qualify_HiGigDstTrunkId.data = data;
	async->args.field_qualify_HiGigDstTrunkId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstTrunkId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t * data,
	bcm_trunk_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTRUNKID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstTrunkId_get.unit = unit;
	async->args.field_qualify_HiGigDstTrunkId_get.entry = entry;
	async->args.field_qualify_HiGigDstTrunkId_get.data = data;
	async->args.field_qualify_HiGigDstTrunkId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstTrunk_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstTrunk_get.unit = unit;
	async->args.field_qualify_HiGigDstTrunk_get.entry = entry;
	async->args.field_qualify_HiGigDstTrunk_get.data = data;
	async->args.field_qualify_HiGigDstTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstType.unit = unit;
	async->args.field_qualify_HiGigDstType.entry = entry;
	async->args.field_qualify_HiGigDstType.data = data;
	async->args.field_qualify_HiGigDstType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigDstType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGDSTTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigDstType_get.unit = unit;
	async->args.field_qualify_HiGigDstType_get.entry = entry;
	async->args.field_qualify_HiGigDstType_get.data = data;
	async->args.field_qualify_HiGigDstType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigEgressMcast_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGEGRESSMCAST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigEgressMcast.unit = unit;
	async->args.field_qualify_HiGigEgressMcast.entry = entry;
	async->args.field_qualify_HiGigEgressMcast.data = data;
	async->args.field_qualify_HiGigEgressMcast.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigEgressMcast_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGEGRESSMCAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigEgressMcast_get.unit = unit;
	async->args.field_qualify_HiGigEgressMcast_get.entry = entry;
	async->args.field_qualify_HiGigEgressMcast_get.data = data;
	async->args.field_qualify_HiGigEgressMcast_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigExtendedHeaderPresent_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGEXTENDEDHEADERPRESENT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigExtendedHeaderPresent.unit = unit;
	async->args.field_qualify_HiGigExtendedHeaderPresent.entry = entry;
	async->args.field_qualify_HiGigExtendedHeaderPresent.data = data;
	async->args.field_qualify_HiGigExtendedHeaderPresent.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigExtendedHeaderPresent_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGEXTENDEDHEADERPRESENT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigExtendedHeaderPresent_get.unit = unit;
	async->args.field_qualify_HiGigExtendedHeaderPresent_get.entry = entry;
	async->args.field_qualify_HiGigExtendedHeaderPresent_get.data = data;
	async->args.field_qualify_HiGigExtendedHeaderPresent_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigForwardingType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_HiGigForwardingType_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGFORWARDINGTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigForwardingType.unit = unit;
	async->args.field_qualify_HiGigForwardingType.entry = entry;
	async->args.field_qualify_HiGigForwardingType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigForwardingType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_HiGigForwardingType_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGFORWARDINGTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigForwardingType_get.unit = unit;
	async->args.field_qualify_HiGigForwardingType_get.entry = entry;
	async->args.field_qualify_HiGigForwardingType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressClassificationTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSCLASSIFICATIONTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressClassificationTag.unit = unit;
	async->args.field_qualify_HiGigIngressClassificationTag.entry = entry;
	async->args.field_qualify_HiGigIngressClassificationTag.data = data;
	async->args.field_qualify_HiGigIngressClassificationTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressClassificationTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSCLASSIFICATIONTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressClassificationTag_get.unit = unit;
	async->args.field_qualify_HiGigIngressClassificationTag_get.entry = entry;
	async->args.field_qualify_HiGigIngressClassificationTag_get.data = data;
	async->args.field_qualify_HiGigIngressClassificationTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressL3SwitchPkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSL3SWITCHPKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressL3SwitchPkt.unit = unit;
	async->args.field_qualify_HiGigIngressL3SwitchPkt.entry = entry;
	async->args.field_qualify_HiGigIngressL3SwitchPkt.data = data;
	async->args.field_qualify_HiGigIngressL3SwitchPkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressL3SwitchPkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSL3SWITCHPKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressL3SwitchPkt_get.unit = unit;
	async->args.field_qualify_HiGigIngressL3SwitchPkt_get.entry = entry;
	async->args.field_qualify_HiGigIngressL3SwitchPkt_get.data = data;
	async->args.field_qualify_HiGigIngressL3SwitchPkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressTagged_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSTAGGED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressTagged.unit = unit;
	async->args.field_qualify_HiGigIngressTagged.entry = entry;
	async->args.field_qualify_HiGigIngressTagged.data = data;
	async->args.field_qualify_HiGigIngressTagged.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIngressTagged_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINGRESSTAGGED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIngressTagged_get.unit = unit;
	async->args.field_qualify_HiGigIngressTagged_get.entry = entry;
	async->args.field_qualify_HiGigIngressTagged_get.data = data;
	async->args.field_qualify_HiGigIngressTagged_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIntCongestionNotification_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINTCONGESTIONNOTIFICATION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIntCongestionNotification.unit = unit;
	async->args.field_qualify_HiGigIntCongestionNotification.entry = entry;
	async->args.field_qualify_HiGigIntCongestionNotification.data = data;
	async->args.field_qualify_HiGigIntCongestionNotification.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigIntCongestionNotification_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGINTCONGESTIONNOTIFICATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigIntCongestionNotification_get.unit = unit;
	async->args.field_qualify_HiGigIntCongestionNotification_get.entry = entry;
	async->args.field_qualify_HiGigIntCongestionNotification_get.data = data;
	async->args.field_qualify_HiGigIntCongestionNotification_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLabel_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLABEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLabel.unit = unit;
	async->args.field_qualify_HiGigLabel.entry = entry;
	async->args.field_qualify_HiGigLabel.data = data;
	async->args.field_qualify_HiGigLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLabelType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLABELTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLabelType.unit = unit;
	async->args.field_qualify_HiGigLabelType.entry = entry;
	async->args.field_qualify_HiGigLabelType.data = data;
	async->args.field_qualify_HiGigLabelType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLabelType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLABELTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLabelType_get.unit = unit;
	async->args.field_qualify_HiGigLabelType_get.entry = entry;
	async->args.field_qualify_HiGigLabelType_get.data = data;
	async->args.field_qualify_HiGigLabelType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLabel_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLABEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLabel_get.unit = unit;
	async->args.field_qualify_HiGigLabel_get.entry = entry;
	async->args.field_qualify_HiGigLabel_get.data = data;
	async->args.field_qualify_HiGigLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLoadBalanceID_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLOADBALANCEID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLoadBalanceID.unit = unit;
	async->args.field_qualify_HiGigLoadBalanceID.entry = entry;
	async->args.field_qualify_HiGigLoadBalanceID.data = data;
	async->args.field_qualify_HiGigLoadBalanceID.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigLoadBalanceID_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGLOADBALANCEID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigLoadBalanceID_get.unit = unit;
	async->args.field_qualify_HiGigLoadBalanceID_get.entry = entry;
	async->args.field_qualify_HiGigLoadBalanceID_get.data = data;
	async->args.field_qualify_HiGigLoadBalanceID_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMirrorOrSwitchPkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMIRRORORSWITCHPKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt.unit = unit;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt.entry = entry;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt.data = data;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMirrorOrSwitchPkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMIRRORORSWITCHPKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt_get.unit = unit;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt_get.entry = entry;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt_get.data = data;
	async->args.field_qualify_HiGigMirrorOrSwitchPkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMirrorToVp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMIRRORTOVP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMirrorToVp.unit = unit;
	async->args.field_qualify_HiGigMirrorToVp.entry = entry;
	async->args.field_qualify_HiGigMirrorToVp.data = data;
	async->args.field_qualify_HiGigMirrorToVp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMirrorToVp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMIRRORTOVP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMirrorToVp_get.unit = unit;
	async->args.field_qualify_HiGigMirrorToVp_get.entry = entry;
	async->args.field_qualify_HiGigMirrorToVp_get.data = data;
	async->args.field_qualify_HiGigMirrorToVp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMplsPkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMPLSPKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMplsPkt.unit = unit;
	async->args.field_qualify_HiGigMplsPkt.entry = entry;
	async->args.field_qualify_HiGigMplsPkt.data = data;
	async->args.field_qualify_HiGigMplsPkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMplsPkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMPLSPKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMplsPkt_get.unit = unit;
	async->args.field_qualify_HiGigMplsPkt_get.entry = entry;
	async->args.field_qualify_HiGigMplsPkt_get.data = data;
	async->args.field_qualify_HiGigMplsPkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMulticastIndex_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMULTICASTINDEX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMulticastIndex.unit = unit;
	async->args.field_qualify_HiGigMulticastIndex.entry = entry;
	async->args.field_qualify_HiGigMulticastIndex.data = data;
	async->args.field_qualify_HiGigMulticastIndex.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigMulticastIndex_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGMULTICASTINDEX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigMulticastIndex_get.unit = unit;
	async->args.field_qualify_HiGigMulticastIndex_get.entry = entry;
	async->args.field_qualify_HiGigMulticastIndex_get.data = data;
	async->args.field_qualify_HiGigMulticastIndex_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineClassificationTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINECLASSIFICATIONTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag.data = data;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineClassificationTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINECLASSIFICATIONTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag_get.data = data;
	async->args.field_qualify_HiGigOffloadEngineClassificationTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineDeferredFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEDEFERREDFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags.data = data;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineDeferredFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEDEFERREDFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags_get.data = data;
	async->args.field_qualify_HiGigOffloadEngineDeferredFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineDscpNew_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEDSCPNEW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineDscpNew.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineDscpNew.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineDscpNew.data = data;
	async->args.field_qualify_HiGigOffloadEngineDscpNew.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineDscpNew_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEDSCPNEW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineDscpNew_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineDscpNew_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineDscpNew_get.data = data;
	async->args.field_qualify_HiGigOffloadEngineDscpNew_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePktPriNew_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPKTPRINEW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew.data = data;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePktPriNew_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPKTPRINEW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew_get.data = data;
	async->args.field_qualify_HiGigOffloadEnginePktPriNew_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePreserveDot1p_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPRESERVEDOT1P;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p.data = data;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePreserveDot1p_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPRESERVEDOT1P_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p_get.data = data;
	async->args.field_qualify_HiGigOffloadEnginePreserveDot1p_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePreserveDscp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPRESERVEDSCP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp.data = data;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEnginePreserveDscp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEPRESERVEDSCP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp_get.data = data;
	async->args.field_qualify_HiGigOffloadEnginePreserveDscp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineSrcType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINESRCTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineSrcType.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineSrcType.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineSrcType.data = data;
	async->args.field_qualify_HiGigOffloadEngineSrcType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineSrcType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINESRCTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineSrcType_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineSrcType_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineSrcType_get.data = data;
	async->args.field_qualify_HiGigOffloadEngineSrcType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineVxltStatus_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEVXLTSTATUS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus.data = data;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigOffloadEngineVxltStatus_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGOFFLOADENGINEVXLTSTATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus_get.unit = unit;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus_get.entry = entry;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus_get.data = data;
	async->args.field_qualify_HiGigOffloadEngineVxltStatus_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigPortFilteringMode_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPORTFILTERINGMODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigPortFilteringMode.unit = unit;
	async->args.field_qualify_HiGigPortFilteringMode.entry = entry;
	async->args.field_qualify_HiGigPortFilteringMode.data = data;
	async->args.field_qualify_HiGigPortFilteringMode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigPortFilteringMode_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPORTFILTERINGMODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigPortFilteringMode_get.unit = unit;
	async->args.field_qualify_HiGigPortFilteringMode_get.entry = entry;
	async->args.field_qualify_HiGigPortFilteringMode_get.data = data;
	async->args.field_qualify_HiGigPortFilteringMode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigPreserveFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPRESERVEFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigPreserveFlags.unit = unit;
	async->args.field_qualify_HiGigPreserveFlags.entry = entry;
	async->args.field_qualify_HiGigPreserveFlags.data = data;
	async->args.field_qualify_HiGigPreserveFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigPreserveFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPRESERVEFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigPreserveFlags_get.unit = unit;
	async->args.field_qualify_HiGigPreserveFlags_get.entry = entry;
	async->args.field_qualify_HiGigPreserveFlags_get.data = data;
	async->args.field_qualify_HiGigPreserveFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigProtectionSwitchingStatus_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPROTECTIONSWITCHINGSTATUS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigProtectionSwitchingStatus.unit = unit;
	async->args.field_qualify_HiGigProtectionSwitchingStatus.entry = entry;
	async->args.field_qualify_HiGigProtectionSwitchingStatus.data = data;
	async->args.field_qualify_HiGigProtectionSwitchingStatus.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigProtectionSwitchingStatus_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPROTECTIONSWITCHINGSTATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigProtectionSwitchingStatus_get.unit = unit;
	async->args.field_qualify_HiGigProtectionSwitchingStatus_get.entry = entry;
	async->args.field_qualify_HiGigProtectionSwitchingStatus_get.data = data;
	async->args.field_qualify_HiGigProtectionSwitchingStatus_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigProxy_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPROXY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigProxy.unit = unit;
	async->args.field_qualify_HiGigProxy.entry = entry;
	async->args.field_qualify_HiGigProxy.data = data;
	async->args.field_qualify_HiGigProxy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigProxy_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGPROXY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigProxy_get.unit = unit;
	async->args.field_qualify_HiGigProxy_get.entry = entry;
	async->args.field_qualify_HiGigProxy_get.data = data;
	async->args.field_qualify_HiGigProxy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigReplicationId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGREPLICATIONID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigReplicationId.unit = unit;
	async->args.field_qualify_HiGigReplicationId.entry = entry;
	async->args.field_qualify_HiGigReplicationId.data = data;
	async->args.field_qualify_HiGigReplicationId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigReplicationId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGREPLICATIONID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigReplicationId_get.unit = unit;
	async->args.field_qualify_HiGigReplicationId_get.entry = entry;
	async->args.field_qualify_HiGigReplicationId_get.data = data;
	async->args.field_qualify_HiGigReplicationId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcGport.unit = unit;
	async->args.field_qualify_HiGigSrcGport.entry = entry;
	async->args.field_qualify_HiGigSrcGport.port_id = port_id;
	async->args.field_qualify_HiGigSrcGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcGport_get.unit = unit;
	async->args.field_qualify_HiGigSrcGport_get.entry = entry;
	async->args.field_qualify_HiGigSrcGport_get.port_id = port_id;
	async->args.field_qualify_HiGigSrcGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcModPortGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCMODPORTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcModPortGport.unit = unit;
	async->args.field_qualify_HiGigSrcModPortGport.entry = entry;
	async->args.field_qualify_HiGigSrcModPortGport.port_id = port_id;
	async->args.field_qualify_HiGigSrcModPortGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcModPortGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCMODPORTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcModPortGport_get.unit = unit;
	async->args.field_qualify_HiGigSrcModPortGport_get.entry = entry;
	async->args.field_qualify_HiGigSrcModPortGport_get.port_id = port_id;
	async->args.field_qualify_HiGigSrcModPortGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcModuleGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCMODULEGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcModuleGport.unit = unit;
	async->args.field_qualify_HiGigSrcModuleGport.entry = entry;
	async->args.field_qualify_HiGigSrcModuleGport.port_id = port_id;
	async->args.field_qualify_HiGigSrcModuleGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcModuleGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCMODULEGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcModuleGport_get.unit = unit;
	async->args.field_qualify_HiGigSrcModuleGport_get.entry = entry;
	async->args.field_qualify_HiGigSrcModuleGport_get.port_id = port_id;
	async->args.field_qualify_HiGigSrcModuleGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcPortGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCPORTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcPortGport.unit = unit;
	async->args.field_qualify_HiGigSrcPortGport.entry = entry;
	async->args.field_qualify_HiGigSrcPortGport.port_id = port_id;
	async->args.field_qualify_HiGigSrcPortGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcPortGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCPORTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcPortGport_get.unit = unit;
	async->args.field_qualify_HiGigSrcPortGport_get.entry = entry;
	async->args.field_qualify_HiGigSrcPortGport_get.port_id = port_id;
	async->args.field_qualify_HiGigSrcPortGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcTrunk_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCTRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcTrunk.unit = unit;
	async->args.field_qualify_HiGigSrcTrunk.entry = entry;
	async->args.field_qualify_HiGigSrcTrunk.data = data;
	async->args.field_qualify_HiGigSrcTrunk.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcTrunk_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCTRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcTrunk_get.unit = unit;
	async->args.field_qualify_HiGigSrcTrunk_get.entry = entry;
	async->args.field_qualify_HiGigSrcTrunk_get.data = data;
	async->args.field_qualify_HiGigSrcTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcType_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcType.unit = unit;
	async->args.field_qualify_HiGigSrcType.entry = entry;
	async->args.field_qualify_HiGigSrcType.data = data;
	async->args.field_qualify_HiGigSrcType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigSrcType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGSRCTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigSrcType_get.unit = unit;
	async->args.field_qualify_HiGigSrcType_get.entry = entry;
	async->args.field_qualify_HiGigSrcType_get.data = data;
	async->args.field_qualify_HiGigSrcType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigTrafficClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGTRAFFICCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigTrafficClass.unit = unit;
	async->args.field_qualify_HiGigTrafficClass.entry = entry;
	async->args.field_qualify_HiGigTrafficClass.data = data;
	async->args.field_qualify_HiGigTrafficClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigTrafficClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGTRAFFICCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigTrafficClass_get.unit = unit;
	async->args.field_qualify_HiGigTrafficClass_get.entry = entry;
	async->args.field_qualify_HiGigTrafficClass_get.data = data;
	async->args.field_qualify_HiGigTrafficClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVlan_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVlan.unit = unit;
	async->args.field_qualify_HiGigVlan.entry = entry;
	async->args.field_qualify_HiGigVlan.data = data;
	async->args.field_qualify_HiGigVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVlan_get.unit = unit;
	async->args.field_qualify_HiGigVlan_get.entry = entry;
	async->args.field_qualify_HiGigVlan_get.data = data;
	async->args.field_qualify_HiGigVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVni_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVNI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVni.unit = unit;
	async->args.field_qualify_HiGigVni.entry = entry;
	async->args.field_qualify_HiGigVni.data = data;
	async->args.field_qualify_HiGigVni.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVni_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVNI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVni_get.unit = unit;
	async->args.field_qualify_HiGigVni_get.entry = entry;
	async->args.field_qualify_HiGigVni_get.data = data;
	async->args.field_qualify_HiGigVni_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpLagFailoverPacket_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPLAGFAILOVERPACKET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpLagFailoverPacket.unit = unit;
	async->args.field_qualify_HiGigVpLagFailoverPacket.entry = entry;
	async->args.field_qualify_HiGigVpLagFailoverPacket.data = data;
	async->args.field_qualify_HiGigVpLagFailoverPacket.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpLagFailoverPacket_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPLAGFAILOVERPACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpLagFailoverPacket_get.unit = unit;
	async->args.field_qualify_HiGigVpLagFailoverPacket_get.entry = entry;
	async->args.field_qualify_HiGigVpLagFailoverPacket_get.data = data;
	async->args.field_qualify_HiGigVpLagFailoverPacket_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpPreserveFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPPRESERVEFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpPreserveFlags.unit = unit;
	async->args.field_qualify_HiGigVpPreserveFlags.entry = entry;
	async->args.field_qualify_HiGigVpPreserveFlags.data = data;
	async->args.field_qualify_HiGigVpPreserveFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpPreserveFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPPRESERVEFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpPreserveFlags_get.unit = unit;
	async->args.field_qualify_HiGigVpPreserveFlags_get.entry = entry;
	async->args.field_qualify_HiGigVpPreserveFlags_get.data = data;
	async->args.field_qualify_HiGigVpPreserveFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpReplicationId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPREPLICATIONID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpReplicationId.unit = unit;
	async->args.field_qualify_HiGigVpReplicationId.entry = entry;
	async->args.field_qualify_HiGigVpReplicationId.data = data;
	async->args.field_qualify_HiGigVpReplicationId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGigVpReplicationId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIGVPREPLICATIONID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGigVpReplicationId_get.unit = unit;
	async->args.field_qualify_HiGigVpReplicationId_get.entry = entry;
	async->args.field_qualify_HiGigVpReplicationId_get.data = data;
	async->args.field_qualify_HiGigVpReplicationId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_HiGig_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGig_get.unit = unit;
	async->args.field_qualify_HiGig_get.entry = entry;
	async->args.field_qualify_HiGig_get.data = data;
	async->args.field_qualify_HiGig_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ISid_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ISID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ISid.unit = unit;
	async->args.field_qualify_ISid.entry = entry;
	async->args.field_qualify_ISid.data = data;
	async->args.field_qualify_ISid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ISid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ISID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ISid_get.unit = unit;
	async->args.field_qualify_ISid_get.entry = entry;
	async->args.field_qualify_ISid_get.data = data;
	async->args.field_qualify_ISid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ITag_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ITAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ITag.unit = unit;
	async->args.field_qualify_ITag.entry = entry;
	async->args.field_qualify_ITag.data = data;
	async->args.field_qualify_ITag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ITag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ITAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ITag_get.unit = unit;
	async->args.field_qualify_ITag_get.entry = entry;
	async->args.field_qualify_ITag_get.data = data;
	async->args.field_qualify_ITag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IcmpError_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPERROR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IcmpError.unit = unit;
	async->args.field_qualify_IcmpError.entry = entry;
	async->args.field_qualify_IcmpError.data = data;
	async->args.field_qualify_IcmpError.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IcmpError_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPERROR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IcmpError_get.unit = unit;
	async->args.field_qualify_IcmpError_get.entry = entry;
	async->args.field_qualify_IcmpError_get.data = data;
	async->args.field_qualify_IcmpError_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IcmpTypeCode_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPTYPECODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IcmpTypeCode.unit = unit;
	async->args.field_qualify_IcmpTypeCode.entry = entry;
	async->args.field_qualify_IcmpTypeCode.data = data;
	async->args.field_qualify_IcmpTypeCode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IcmpTypeCode_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPTYPECODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IcmpTypeCode_get.unit = unit;
	async->args.field_qualify_IcmpTypeCode_get.entry = entry;
	async->args.field_qualify_IcmpTypeCode_get.data = data;
	async->args.field_qualify_IcmpTypeCode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IgmpTypeMaxRespTime_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IGMPTYPEMAXRESPTIME;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IgmpTypeMaxRespTime.unit = unit;
	async->args.field_qualify_IgmpTypeMaxRespTime.entry = entry;
	async->args.field_qualify_IgmpTypeMaxRespTime.data = data;
	async->args.field_qualify_IgmpTypeMaxRespTime.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IgmpTypeMaxRespTime_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IGMPTYPEMAXRESPTIME_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IgmpTypeMaxRespTime_get.unit = unit;
	async->args.field_qualify_IgmpTypeMaxRespTime_get.entry = entry;
	async->args.field_qualify_IgmpTypeMaxRespTime_get.data = data;
	async->args.field_qualify_IgmpTypeMaxRespTime_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_port_t data,
	bcm_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPort.unit = unit;
	async->args.field_qualify_InPort.entry = entry;
	async->args.field_qualify_InPort.data = data;
	async->args.field_qualify_InPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_port_t * data,
	bcm_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPort_get.unit = unit;
	async->args.field_qualify_InPort_get.entry = entry;
	async->args.field_qualify_InPort_get.data = data;
	async->args.field_qualify_InPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InPorts_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPorts.unit = unit;
	async->args.field_qualify_InPorts.entry = entry;
	async->args.field_qualify_InPorts.data = data;
	async->args.field_qualify_InPorts.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InPorts_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPorts_get.unit = unit;
	async->args.field_qualify_InPorts_get.entry = entry;
	async->args.field_qualify_InPorts_get.data = data;
	async->args.field_qualify_InPorts_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPort.unit = unit;
	async->args.field_qualify_InVPort.entry = entry;
	async->args.field_qualify_InVPort.data = data;
	async->args.field_qualify_InVPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPort32_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORT32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPort32.unit = unit;
	async->args.field_qualify_InVPort32.entry = entry;
	async->args.field_qualify_InVPort32.data = data;
	async->args.field_qualify_InVPort32.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPort32_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORT32_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPort32_get.unit = unit;
	async->args.field_qualify_InVPort32_get.entry = entry;
	async->args.field_qualify_InVPort32_get.data = data;
	async->args.field_qualify_InVPort32_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPortWide_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORTWIDE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPortWide.unit = unit;
	async->args.field_qualify_InVPortWide.entry = entry;
	async->args.field_qualify_InVPortWide.data = data;
	async->args.field_qualify_InVPortWide.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPortWide_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORTWIDE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPortWide_get.unit = unit;
	async->args.field_qualify_InVPortWide_get.entry = entry;
	async->args.field_qualify_InVPortWide_get.data = data;
	async->args.field_qualify_InVPortWide_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InVPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INVPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InVPort_get.unit = unit;
	async->args.field_qualify_InVPort_get.entry = entry;
	async->args.field_qualify_InVPort_get.data = data;
	async->args.field_qualify_InVPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IncomingIpIfClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INCOMINGIPIFCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IncomingIpIfClass.unit = unit;
	async->args.field_qualify_IncomingIpIfClass.entry = entry;
	async->args.field_qualify_IncomingIpIfClass.data = data;
	async->args.field_qualify_IncomingIpIfClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IncomingIpIfClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INCOMINGIPIFCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IncomingIpIfClass_get.unit = unit;
	async->args.field_qualify_IncomingIpIfClass_get.entry = entry;
	async->args.field_qualify_IncomingIpIfClass_get.data = data;
	async->args.field_qualify_IncomingIpIfClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressClassField_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSCLASSFIELD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressClassField.unit = unit;
	async->args.field_qualify_IngressClassField.entry = entry;
	async->args.field_qualify_IngressClassField.data = data;
	async->args.field_qualify_IngressClassField.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressClassField_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSCLASSFIELD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressClassField_get.unit = unit;
	async->args.field_qualify_IngressClassField_get.entry = entry;
	async->args.field_qualify_IngressClassField_get.data = data;
	async->args.field_qualify_IngressClassField_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropEthernetOamControl_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPETHERNETOAMCONTROL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropEthernetOamControl.unit = unit;
	async->args.field_qualify_IngressDropEthernetOamControl.entry = entry;
	async->args.field_qualify_IngressDropEthernetOamControl.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropEthernetOamControl_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t * mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPETHERNETOAMCONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropEthernetOamControl_get.unit = unit;
	async->args.field_qualify_IngressDropEthernetOamControl_get.entry = entry;
	async->args.field_qualify_IngressDropEthernetOamControl_get.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropEthernetOamData_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPETHERNETOAMDATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropEthernetOamData.unit = unit;
	async->args.field_qualify_IngressDropEthernetOamData.entry = entry;
	async->args.field_qualify_IngressDropEthernetOamData.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropEthernetOamData_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t * mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPETHERNETOAMDATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropEthernetOamData_get.unit = unit;
	async->args.field_qualify_IngressDropEthernetOamData_get.entry = entry;
	async->args.field_qualify_IngressDropEthernetOamData_get.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropMplsOamControl_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPMPLSOAMCONTROL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropMplsOamControl.unit = unit;
	async->args.field_qualify_IngressDropMplsOamControl.entry = entry;
	async->args.field_qualify_IngressDropMplsOamControl.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropMplsOamControl_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t * mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPMPLSOAMCONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropMplsOamControl_get.unit = unit;
	async->args.field_qualify_IngressDropMplsOamControl_get.entry = entry;
	async->args.field_qualify_IngressDropMplsOamControl_get.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropMplsOamData_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPMPLSOAMDATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropMplsOamData.unit = unit;
	async->args.field_qualify_IngressDropMplsOamData.entry = entry;
	async->args.field_qualify_IngressDropMplsOamData.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressDropMplsOamData_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_drop_mep_type_t * mep_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSDROPMPLSOAMDATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressDropMplsOamData_get.unit = unit;
	async->args.field_qualify_IngressDropMplsOamData_get.entry = entry;
	async->args.field_qualify_IngressDropMplsOamData_get.mep_type = mep_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressECid_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSECID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressECid.unit = unit;
	async->args.field_qualify_IngressECid.entry = entry;
	async->args.field_qualify_IngressECid.data = data;
	async->args.field_qualify_IngressECid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressECid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSECID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressECid_get.unit = unit;
	async->args.field_qualify_IngressECid_get.entry = entry;
	async->args.field_qualify_IngressECid_get.data = data;
	async->args.field_qualify_IngressECid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressInterfaceClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSINTERFACECLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressInterfaceClassPort.unit = unit;
	async->args.field_qualify_IngressInterfaceClassPort.entry = entry;
	async->args.field_qualify_IngressInterfaceClassPort.data = data;
	async->args.field_qualify_IngressInterfaceClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressInterfaceClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSINTERFACECLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressInterfaceClassPort_get.unit = unit;
	async->args.field_qualify_IngressInterfaceClassPort_get.entry = entry;
	async->args.field_qualify_IngressInterfaceClassPort_get.data = data;
	async->args.field_qualify_IngressInterfaceClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressInterfaceClassVPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSINTERFACECLASSVPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressInterfaceClassVPort.unit = unit;
	async->args.field_qualify_IngressInterfaceClassVPort.entry = entry;
	async->args.field_qualify_IngressInterfaceClassVPort.data = data;
	async->args.field_qualify_IngressInterfaceClassVPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressInterfaceClassVPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSINTERFACECLASSVPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressInterfaceClassVPort_get.unit = unit;
	async->args.field_qualify_IngressInterfaceClassVPort_get.entry = entry;
	async->args.field_qualify_IngressInterfaceClassVPort_get.data = data;
	async->args.field_qualify_IngressInterfaceClassVPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressStpState_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressStpState.unit = unit;
	async->args.field_qualify_IngressStpState.entry = entry;
	async->args.field_qualify_IngressStpState.data = data;
	async->args.field_qualify_IngressStpState.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressStpState_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressStpState_get.unit = unit;
	async->args.field_qualify_IngressStpState_get.entry = entry;
	async->args.field_qualify_IngressStpState_get.data = data;
	async->args.field_qualify_IngressStpState_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressVPortBridgeDisable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSVPORTBRIDGEDISABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressVPortBridgeDisable.unit = unit;
	async->args.field_qualify_IngressVPortBridgeDisable.entry = entry;
	async->args.field_qualify_IngressVPortBridgeDisable.data = data;
	async->args.field_qualify_IngressVPortBridgeDisable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IngressVPortBridgeDisable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSVPORTBRIDGEDISABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressVPortBridgeDisable_get.unit = unit;
	async->args.field_qualify_IngressVPortBridgeDisable_get.entry = entry;
	async->args.field_qualify_IngressVPortBridgeDisable_get.data = data;
	async->args.field_qualify_IngressVPortBridgeDisable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDSCP_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDSCP.unit = unit;
	async->args.field_qualify_InnerDSCP.entry = entry;
	async->args.field_qualify_InnerDSCP.data = data;
	async->args.field_qualify_InnerDSCP.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDSCP_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDSCP_get.unit = unit;
	async->args.field_qualify_InnerDSCP_get.entry = entry;
	async->args.field_qualify_InnerDSCP_get.data = data;
	async->args.field_qualify_InnerDSCP_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp.unit = unit;
	async->args.field_qualify_InnerDstIp.entry = entry;
	async->args.field_qualify_InnerDstIp.data = data;
	async->args.field_qualify_InnerDstIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6.unit = unit;
	async->args.field_qualify_InnerDstIp6.entry = entry;
	async->args.field_qualify_InnerDstIp6.data = (uint8 *)data;
	async->args.field_qualify_InnerDstIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp6High_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6High.unit = unit;
	async->args.field_qualify_InnerDstIp6High.entry = entry;
	async->args.field_qualify_InnerDstIp6High.data = (uint8 *)data;
	async->args.field_qualify_InnerDstIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp6High_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6High_get.unit = unit;
	async->args.field_qualify_InnerDstIp6High_get.entry = entry;
	async->args.field_qualify_InnerDstIp6High_get.data = data;
	async->args.field_qualify_InnerDstIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6_get.unit = unit;
	async->args.field_qualify_InnerDstIp6_get.entry = entry;
	async->args.field_qualify_InnerDstIp6_get.data = data;
	async->args.field_qualify_InnerDstIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstIp_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp_get.unit = unit;
	async->args.field_qualify_InnerDstIp_get.entry = entry;
	async->args.field_qualify_InnerDstIp_get.data = data;
	async->args.field_qualify_InnerDstIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstMac.unit = unit;
	async->args.field_qualify_InnerDstMac.entry = entry;
	async->args.field_qualify_InnerDstMac.data = (uint8 *)data;
	async->args.field_qualify_InnerDstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerDstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstMac_get.unit = unit;
	async->args.field_qualify_InnerDstMac_get.entry = entry;
	async->args.field_qualify_InnerDstMac_get.data = data;
	async->args.field_qualify_InnerDstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerEtherType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERETHERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerEtherType.unit = unit;
	async->args.field_qualify_InnerEtherType.entry = entry;
	async->args.field_qualify_InnerEtherType.data = data;
	async->args.field_qualify_InnerEtherType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerEtherType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerEtherType_get.unit = unit;
	async->args.field_qualify_InnerEtherType_get.entry = entry;
	async->args.field_qualify_InnerEtherType_get.data = data;
	async->args.field_qualify_InnerEtherType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6FlowLabel_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6FlowLabel.unit = unit;
	async->args.field_qualify_InnerIp6FlowLabel.entry = entry;
	async->args.field_qualify_InnerIp6FlowLabel.data = data;
	async->args.field_qualify_InnerIp6FlowLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6FlowLabel_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6FlowLabel_get.unit = unit;
	async->args.field_qualify_InnerIp6FlowLabel_get.entry = entry;
	async->args.field_qualify_InnerIp6FlowLabel_get.data = data;
	async->args.field_qualify_InnerIp6FlowLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6HopLimit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6HOPLIMIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6HopLimit.unit = unit;
	async->args.field_qualify_InnerIp6HopLimit.entry = entry;
	async->args.field_qualify_InnerIp6HopLimit.data = data;
	async->args.field_qualify_InnerIp6HopLimit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6HopLimit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6HOPLIMIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6HopLimit_get.unit = unit;
	async->args.field_qualify_InnerIp6HopLimit_get.entry = entry;
	async->args.field_qualify_InnerIp6HopLimit_get.data = data;
	async->args.field_qualify_InnerIp6HopLimit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6NextHeader_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6NEXTHEADER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6NextHeader.unit = unit;
	async->args.field_qualify_InnerIp6NextHeader.entry = entry;
	async->args.field_qualify_InnerIp6NextHeader.data = data;
	async->args.field_qualify_InnerIp6NextHeader.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIp6NextHeader_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6NEXTHEADER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6NextHeader_get.unit = unit;
	async->args.field_qualify_InnerIp6NextHeader_get.entry = entry;
	async->args.field_qualify_InnerIp6NextHeader_get.data = data;
	async->args.field_qualify_InnerIp6NextHeader_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpFrag_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t frag_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpFrag.unit = unit;
	async->args.field_qualify_InnerIpFrag.entry = entry;
	async->args.field_qualify_InnerIpFrag.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpFrag_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t * frag_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpFrag_get.unit = unit;
	async->args.field_qualify_InnerIpFrag_get.entry = entry;
	async->args.field_qualify_InnerIpFrag_get.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpProtocol_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocol.unit = unit;
	async->args.field_qualify_InnerIpProtocol.entry = entry;
	async->args.field_qualify_InnerIpProtocol.data = data;
	async->args.field_qualify_InnerIpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpProtocolCommon_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocolCommon.unit = unit;
	async->args.field_qualify_InnerIpProtocolCommon.entry = entry;
	async->args.field_qualify_InnerIpProtocolCommon.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpProtocolCommon_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t * protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocolCommon_get.unit = unit;
	async->args.field_qualify_InnerIpProtocolCommon_get.entry = entry;
	async->args.field_qualify_InnerIpProtocolCommon_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpProtocol_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocol_get.unit = unit;
	async->args.field_qualify_InnerIpProtocol_get.entry = entry;
	async->args.field_qualify_InnerIpProtocol_get.data = data;
	async->args.field_qualify_InnerIpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpType_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpType.unit = unit;
	async->args.field_qualify_InnerIpType.entry = entry;
	async->args.field_qualify_InnerIpType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerIpType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpType_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpType_get.unit = unit;
	async->args.field_qualify_InnerIpType_get.entry = entry;
	async->args.field_qualify_InnerIpType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerL4DstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4DstPort.unit = unit;
	async->args.field_qualify_InnerL4DstPort.entry = entry;
	async->args.field_qualify_InnerL4DstPort.data = data;
	async->args.field_qualify_InnerL4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerL4DstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4DstPort_get.unit = unit;
	async->args.field_qualify_InnerL4DstPort_get.entry = entry;
	async->args.field_qualify_InnerL4DstPort_get.data = data;
	async->args.field_qualify_InnerL4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerL4SrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4SrcPort.unit = unit;
	async->args.field_qualify_InnerL4SrcPort.entry = entry;
	async->args.field_qualify_InnerL4SrcPort.data = data;
	async->args.field_qualify_InnerL4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerL4SrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4SrcPort_get.unit = unit;
	async->args.field_qualify_InnerL4SrcPort_get.entry = entry;
	async->args.field_qualify_InnerL4SrcPort_get.data = data;
	async->args.field_qualify_InnerL4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp.unit = unit;
	async->args.field_qualify_InnerSrcIp.entry = entry;
	async->args.field_qualify_InnerSrcIp.data = data;
	async->args.field_qualify_InnerSrcIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6.unit = unit;
	async->args.field_qualify_InnerSrcIp6.entry = entry;
	async->args.field_qualify_InnerSrcIp6.data = (uint8 *)data;
	async->args.field_qualify_InnerSrcIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp6High_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6High.unit = unit;
	async->args.field_qualify_InnerSrcIp6High.entry = entry;
	async->args.field_qualify_InnerSrcIp6High.data = (uint8 *)data;
	async->args.field_qualify_InnerSrcIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp6High_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6High_get.unit = unit;
	async->args.field_qualify_InnerSrcIp6High_get.entry = entry;
	async->args.field_qualify_InnerSrcIp6High_get.data = data;
	async->args.field_qualify_InnerSrcIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6_get.unit = unit;
	async->args.field_qualify_InnerSrcIp6_get.entry = entry;
	async->args.field_qualify_InnerSrcIp6_get.data = data;
	async->args.field_qualify_InnerSrcIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcIp_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp_get.unit = unit;
	async->args.field_qualify_InnerSrcIp_get.entry = entry;
	async->args.field_qualify_InnerSrcIp_get.data = data;
	async->args.field_qualify_InnerSrcIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcMac.unit = unit;
	async->args.field_qualify_InnerSrcMac.entry = entry;
	async->args.field_qualify_InnerSrcMac.data = (uint8 *)data;
	async->args.field_qualify_InnerSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcMac_get.unit = unit;
	async->args.field_qualify_InnerSrcMac_get.entry = entry;
	async->args.field_qualify_InnerSrcMac_get.data = data;
	async->args.field_qualify_InnerSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTos.unit = unit;
	async->args.field_qualify_InnerTos.entry = entry;
	async->args.field_qualify_InnerTos.data = data;
	async->args.field_qualify_InnerTos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTos_get.unit = unit;
	async->args.field_qualify_InnerTos_get.entry = entry;
	async->args.field_qualify_InnerTos_get.data = data;
	async->args.field_qualify_InnerTos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTpid_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTpid.unit = unit;
	async->args.field_qualify_InnerTpid.entry = entry;
	async->args.field_qualify_InnerTpid.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTpid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTpid_get.unit = unit;
	async->args.field_qualify_InnerTpid_get.entry = entry;
	async->args.field_qualify_InnerTpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTtl.unit = unit;
	async->args.field_qualify_InnerTtl.entry = entry;
	async->args.field_qualify_InnerTtl.data = data;
	async->args.field_qualify_InnerTtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerTtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTtl_get.unit = unit;
	async->args.field_qualify_InnerTtl_get.entry = entry;
	async->args.field_qualify_InnerTtl_get.data = data;
	async->args.field_qualify_InnerTtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlan.unit = unit;
	async->args.field_qualify_InnerVlan.entry = entry;
	async->args.field_qualify_InnerVlan.data = data;
	async->args.field_qualify_InnerVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanActionRange_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANACTIONRANGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanActionRange.unit = unit;
	async->args.field_qualify_InnerVlanActionRange.entry = entry;
	async->args.field_qualify_InnerVlanActionRange.data = data;
	async->args.field_qualify_InnerVlanActionRange.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanActionRange_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANACTIONRANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanActionRange_get.unit = unit;
	async->args.field_qualify_InnerVlanActionRange_get.entry = entry;
	async->args.field_qualify_InnerVlanActionRange_get.data = data;
	async->args.field_qualify_InnerVlanActionRange_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanCfi.unit = unit;
	async->args.field_qualify_InnerVlanCfi.entry = entry;
	async->args.field_qualify_InnerVlanCfi.data = data;
	async->args.field_qualify_InnerVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanCfi_get.unit = unit;
	async->args.field_qualify_InnerVlanCfi_get.entry = entry;
	async->args.field_qualify_InnerVlanCfi_get.data = data;
	async->args.field_qualify_InnerVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanId.unit = unit;
	async->args.field_qualify_InnerVlanId.entry = entry;
	async->args.field_qualify_InnerVlanId.data = data;
	async->args.field_qualify_InnerVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanId_get.unit = unit;
	async->args.field_qualify_InnerVlanId_get.entry = entry;
	async->args.field_qualify_InnerVlanId_get.data = data;
	async->args.field_qualify_InnerVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanPri.unit = unit;
	async->args.field_qualify_InnerVlanPri.entry = entry;
	async->args.field_qualify_InnerVlanPri.data = data;
	async->args.field_qualify_InnerVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanPri_get.unit = unit;
	async->args.field_qualify_InnerVlanPri_get.entry = entry;
	async->args.field_qualify_InnerVlanPri_get.data = data;
	async->args.field_qualify_InnerVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InnerVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlan_get.unit = unit;
	async->args.field_qualify_InnerVlan_get.entry = entry;
	async->args.field_qualify_InnerVlan_get.data = data;
	async->args.field_qualify_InnerVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IntCongestionNotification_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTCONGESTIONNOTIFICATION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntCongestionNotification.unit = unit;
	async->args.field_qualify_IntCongestionNotification.entry = entry;
	async->args.field_qualify_IntCongestionNotification.data = data;
	async->args.field_qualify_IntCongestionNotification.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IntCongestionNotification_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTCONGESTIONNOTIFICATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntCongestionNotification_get.unit = unit;
	async->args.field_qualify_IntCongestionNotification_get.entry = entry;
	async->args.field_qualify_IntCongestionNotification_get.data = data;
	async->args.field_qualify_IntCongestionNotification_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IntPriority_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntPriority.unit = unit;
	async->args.field_qualify_IntPriority.entry = entry;
	async->args.field_qualify_IntPriority.data = data;
	async->args.field_qualify_IntPriority.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IntPriority_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntPriority_get.unit = unit;
	async->args.field_qualify_IntPriority_get.entry = entry;
	async->args.field_qualify_IntPriority_get.data = data;
	async->args.field_qualify_IntPriority_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassL2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL2.unit = unit;
	async->args.field_qualify_InterfaceClassL2.entry = entry;
	async->args.field_qualify_InterfaceClassL2.data = data;
	async->args.field_qualify_InterfaceClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassL2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL2_get.unit = unit;
	async->args.field_qualify_InterfaceClassL2_get.entry = entry;
	async->args.field_qualify_InterfaceClassL2_get.data = data;
	async->args.field_qualify_InterfaceClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassL3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL3.unit = unit;
	async->args.field_qualify_InterfaceClassL3.entry = entry;
	async->args.field_qualify_InterfaceClassL3.data = data;
	async->args.field_qualify_InterfaceClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassL3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL3_get.unit = unit;
	async->args.field_qualify_InterfaceClassL3_get.entry = entry;
	async->args.field_qualify_InterfaceClassL3_get.data = data;
	async->args.field_qualify_InterfaceClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassPort.unit = unit;
	async->args.field_qualify_InterfaceClassPort.entry = entry;
	async->args.field_qualify_InterfaceClassPort.data = data;
	async->args.field_qualify_InterfaceClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassPort_get.unit = unit;
	async->args.field_qualify_InterfaceClassPort_get.entry = entry;
	async->args.field_qualify_InterfaceClassPort_get.data = data;
	async->args.field_qualify_InterfaceClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassProcessingPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPROCESSINGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassProcessingPort.unit = unit;
	async->args.field_qualify_InterfaceClassProcessingPort.entry = entry;
	async->args.field_qualify_InterfaceClassProcessingPort.data = data;
	async->args.field_qualify_InterfaceClassProcessingPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassProcessingPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPROCESSINGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassProcessingPort_get.unit = unit;
	async->args.field_qualify_InterfaceClassProcessingPort_get.entry = entry;
	async->args.field_qualify_InterfaceClassProcessingPort_get.data = data;
	async->args.field_qualify_InterfaceClassProcessingPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassVPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSVPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassVPort.unit = unit;
	async->args.field_qualify_InterfaceClassVPort.entry = entry;
	async->args.field_qualify_InterfaceClassVPort.data = data;
	async->args.field_qualify_InterfaceClassVPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceClassVPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSVPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassVPort_get.unit = unit;
	async->args.field_qualify_InterfaceClassVPort_get.entry = entry;
	async->args.field_qualify_InterfaceClassVPort_get.data = data;
	async->args.field_qualify_InterfaceClassVPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceInPorts_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACEINPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceInPorts.unit = unit;
	async->args.field_qualify_InterfaceInPorts.entry = entry;
	async->args.field_qualify_InterfaceInPorts.data = data;
	async->args.field_qualify_InterfaceInPorts.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceInPorts_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACEINPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceInPorts_get.unit = unit;
	async->args.field_qualify_InterfaceInPorts_get.entry = entry;
	async->args.field_qualify_InterfaceInPorts_get.data = data;
	async->args.field_qualify_InterfaceInPorts_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceIngressKeySelectClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACEINGRESSKEYSELECTCLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort.unit = unit;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort.entry = entry;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort.data = data;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceIngressKeySelectClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACEINGRESSKEYSELECTCLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort_get.unit = unit;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort_get.entry = entry;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort_get.data = data;
	async->args.field_qualify_InterfaceIngressKeySelectClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceLookupClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACELOOKUPCLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceLookupClassPort.unit = unit;
	async->args.field_qualify_InterfaceLookupClassPort.entry = entry;
	async->args.field_qualify_InterfaceLookupClassPort.data = data;
	async->args.field_qualify_InterfaceLookupClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_InterfaceLookupClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACELOOKUPCLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceLookupClassPort_get.unit = unit;
	async->args.field_qualify_InterfaceLookupClassPort_get.entry = entry;
	async->args.field_qualify_InterfaceLookupClassPort_get.data = data;
	async->args.field_qualify_InterfaceLookupClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6FlowLabel_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6FlowLabel.unit = unit;
	async->args.field_qualify_Ip6FlowLabel.entry = entry;
	async->args.field_qualify_Ip6FlowLabel.data = data;
	async->args.field_qualify_Ip6FlowLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6FlowLabel_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6FlowLabel_get.unit = unit;
	async->args.field_qualify_Ip6FlowLabel_get.entry = entry;
	async->args.field_qualify_Ip6FlowLabel_get.data = data;
	async->args.field_qualify_Ip6FlowLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6HopLimit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6HopLimit.unit = unit;
	async->args.field_qualify_Ip6HopLimit.entry = entry;
	async->args.field_qualify_Ip6HopLimit.data = data;
	async->args.field_qualify_Ip6HopLimit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6HopLimit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6HopLimit_get.unit = unit;
	async->args.field_qualify_Ip6HopLimit_get.entry = entry;
	async->args.field_qualify_Ip6HopLimit_get.data = data;
	async->args.field_qualify_Ip6HopLimit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6NextHeader_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6NextHeader.unit = unit;
	async->args.field_qualify_Ip6NextHeader.entry = entry;
	async->args.field_qualify_Ip6NextHeader.data = data;
	async->args.field_qualify_Ip6NextHeader.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6NextHeader_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6NextHeader_get.unit = unit;
	async->args.field_qualify_Ip6NextHeader_get.entry = entry;
	async->args.field_qualify_Ip6NextHeader_get.data = data;
	async->args.field_qualify_Ip6NextHeader_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6TrafficClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6TrafficClass.unit = unit;
	async->args.field_qualify_Ip6TrafficClass.entry = entry;
	async->args.field_qualify_Ip6TrafficClass.data = data;
	async->args.field_qualify_Ip6TrafficClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ip6TrafficClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6TrafficClass_get.unit = unit;
	async->args.field_qualify_Ip6TrafficClass_get.entry = entry;
	async->args.field_qualify_Ip6TrafficClass_get.data = data;
	async->args.field_qualify_Ip6TrafficClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpAddrsNormalized_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPADDRSNORMALIZED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpAddrsNormalized.unit = unit;
	async->args.field_qualify_IpAddrsNormalized.entry = entry;
	async->args.field_qualify_IpAddrsNormalized.data = data;
	async->args.field_qualify_IpAddrsNormalized.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpAddrsNormalized_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPADDRSNORMALIZED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpAddrsNormalized_get.unit = unit;
	async->args.field_qualify_IpAddrsNormalized_get.entry = entry;
	async->args.field_qualify_IpAddrsNormalized_get.data = data;
	async->args.field_qualify_IpAddrsNormalized_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpAuth_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPAUTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpAuth.unit = unit;
	async->args.field_qualify_IpAuth.entry = entry;
	async->args.field_qualify_IpAuth.data = data;
	async->args.field_qualify_IpAuth.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpAuth_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPAUTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpAuth_get.unit = unit;
	async->args.field_qualify_IpAuth_get.entry = entry;
	async->args.field_qualify_IpAuth_get.data = data;
	async->args.field_qualify_IpAuth_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFlags.unit = unit;
	async->args.field_qualify_IpFlags.entry = entry;
	async->args.field_qualify_IpFlags.data = data;
	async->args.field_qualify_IpFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFlags_get.unit = unit;
	async->args.field_qualify_IpFlags_get.entry = entry;
	async->args.field_qualify_IpFlags_get.data = data;
	async->args.field_qualify_IpFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFrag_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t frag_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFrag.unit = unit;
	async->args.field_qualify_IpFrag.entry = entry;
	async->args.field_qualify_IpFrag.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFragNonOrFirst_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAGNONORFIRST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFragNonOrFirst.unit = unit;
	async->args.field_qualify_IpFragNonOrFirst.entry = entry;
	async->args.field_qualify_IpFragNonOrFirst.data = data;
	async->args.field_qualify_IpFragNonOrFirst.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFragNonOrFirst_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAGNONORFIRST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFragNonOrFirst_get.unit = unit;
	async->args.field_qualify_IpFragNonOrFirst_get.entry = entry;
	async->args.field_qualify_IpFragNonOrFirst_get.data = data;
	async->args.field_qualify_IpFragNonOrFirst_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpFrag_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t * frag_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFrag_get.unit = unit;
	async->args.field_qualify_IpFrag_get.entry = entry;
	async->args.field_qualify_IpFrag_get.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpInfo_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpInfo.unit = unit;
	async->args.field_qualify_IpInfo.entry = entry;
	async->args.field_qualify_IpInfo.data = data;
	async->args.field_qualify_IpInfo.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpInfo_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpInfo_get.unit = unit;
	async->args.field_qualify_IpInfo_get.entry = entry;
	async->args.field_qualify_IpInfo_get.data = data;
	async->args.field_qualify_IpInfo_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpMulticastCompatible_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMULTICASTCOMPATIBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpMulticastCompatible.unit = unit;
	async->args.field_qualify_IpMulticastCompatible.entry = entry;
	async->args.field_qualify_IpMulticastCompatible.data = data;
	async->args.field_qualify_IpMulticastCompatible.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpMulticastCompatible_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMULTICASTCOMPATIBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpMulticastCompatible_get.unit = unit;
	async->args.field_qualify_IpMulticastCompatible_get.entry = entry;
	async->args.field_qualify_IpMulticastCompatible_get.data = data;
	async->args.field_qualify_IpMulticastCompatible_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocol_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocol.unit = unit;
	async->args.field_qualify_IpProtocol.entry = entry;
	async->args.field_qualify_IpProtocol.data = data;
	async->args.field_qualify_IpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocolClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolClass.unit = unit;
	async->args.field_qualify_IpProtocolClass.entry = entry;
	async->args.field_qualify_IpProtocolClass.data = data;
	async->args.field_qualify_IpProtocolClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocolClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolClass_get.unit = unit;
	async->args.field_qualify_IpProtocolClass_get.entry = entry;
	async->args.field_qualify_IpProtocolClass_get.data = data;
	async->args.field_qualify_IpProtocolClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocolCommon_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolCommon.unit = unit;
	async->args.field_qualify_IpProtocolCommon.entry = entry;
	async->args.field_qualify_IpProtocolCommon.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocolCommon_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t * protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolCommon_get.unit = unit;
	async->args.field_qualify_IpProtocolCommon_get.entry = entry;
	async->args.field_qualify_IpProtocolCommon_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpProtocol_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocol_get.unit = unit;
	async->args.field_qualify_IpProtocol_get.entry = entry;
	async->args.field_qualify_IpProtocol_get.data = data;
	async->args.field_qualify_IpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpTunnelHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTUNNELHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpTunnelHit.unit = unit;
	async->args.field_qualify_IpTunnelHit.entry = entry;
	async->args.field_qualify_IpTunnelHit.data = data;
	async->args.field_qualify_IpTunnelHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpTunnelHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTUNNELHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpTunnelHit_get.unit = unit;
	async->args.field_qualify_IpTunnelHit_get.entry = entry;
	async->args.field_qualify_IpTunnelHit_get.data = data;
	async->args.field_qualify_IpTunnelHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpTunnelValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTUNNELVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpTunnelValue.unit = unit;
	async->args.field_qualify_IpTunnelValue.entry = entry;
	async->args.field_qualify_IpTunnelValue.data = data;
	async->args.field_qualify_IpTunnelValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpTunnelValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTUNNELVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpTunnelValue_get.unit = unit;
	async->args.field_qualify_IpTunnelValue_get.entry = entry;
	async->args.field_qualify_IpTunnelValue_get.data = data;
	async->args.field_qualify_IpTunnelValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpType_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpType.unit = unit;
	async->args.field_qualify_IpType.entry = entry;
	async->args.field_qualify_IpType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_IpType_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpType_get.unit = unit;
	async->args.field_qualify_IpType_get.entry = entry;
	async->args.field_qualify_IpType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcHit.unit = unit;
	async->args.field_qualify_IpmcHit.entry = entry;
	async->args.field_qualify_IpmcHit.data = data;
	async->args.field_qualify_IpmcHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcHit_get.unit = unit;
	async->args.field_qualify_IpmcHit_get.entry = entry;
	async->args.field_qualify_IpmcHit_get.data = data;
	async->args.field_qualify_IpmcHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcStarGroupHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupHit.unit = unit;
	async->args.field_qualify_IpmcStarGroupHit.entry = entry;
	async->args.field_qualify_IpmcStarGroupHit.data = data;
	async->args.field_qualify_IpmcStarGroupHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcStarGroupHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupHit_get.unit = unit;
	async->args.field_qualify_IpmcStarGroupHit_get.entry = entry;
	async->args.field_qualify_IpmcStarGroupHit_get.data = data;
	async->args.field_qualify_IpmcStarGroupHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcStarGroupValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupValue.unit = unit;
	async->args.field_qualify_IpmcStarGroupValue.entry = entry;
	async->args.field_qualify_IpmcStarGroupValue.data = data;
	async->args.field_qualify_IpmcStarGroupValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcStarGroupValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupValue_get.unit = unit;
	async->args.field_qualify_IpmcStarGroupValue_get.entry = entry;
	async->args.field_qualify_IpmcStarGroupValue_get.data = data;
	async->args.field_qualify_IpmcStarGroupValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcValue.unit = unit;
	async->args.field_qualify_IpmcValue.entry = entry;
	async->args.field_qualify_IpmcValue.data = data;
	async->args.field_qualify_IpmcValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IpmcValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcValue_get.unit = unit;
	async->args.field_qualify_IpmcValue_get.entry = entry;
	async->args.field_qualify_IpmcValue_get.data = data;
	async->args.field_qualify_IpmcValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IsEqualValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ISEQUALVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IsEqualValue.unit = unit;
	async->args.field_qualify_IsEqualValue.entry = entry;
	async->args.field_qualify_IsEqualValue.data = data;
	async->args.field_qualify_IsEqualValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_IsEqualValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ISEQUALVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IsEqualValue_get.unit = unit;
	async->args.field_qualify_IsEqualValue_get.entry = entry;
	async->args.field_qualify_IsEqualValue_get.data = data;
	async->args.field_qualify_IsEqualValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2CacheHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2CacheHit.unit = unit;
	async->args.field_qualify_L2CacheHit.entry = entry;
	async->args.field_qualify_L2CacheHit.data = data;
	async->args.field_qualify_L2CacheHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2CacheHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2CacheHit_get.unit = unit;
	async->args.field_qualify_L2CacheHit_get.entry = entry;
	async->args.field_qualify_L2CacheHit_get.data = data;
	async->args.field_qualify_L2CacheHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestHit.unit = unit;
	async->args.field_qualify_L2DestHit.entry = entry;
	async->args.field_qualify_L2DestHit.data = data;
	async->args.field_qualify_L2DestHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestHit_get.unit = unit;
	async->args.field_qualify_L2DestHit_get.entry = entry;
	async->args.field_qualify_L2DestHit_get.data = data;
	async->args.field_qualify_L2DestHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestSRNodeType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_node_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTSRNODETYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestSRNodeType.unit = unit;
	async->args.field_qualify_L2DestSRNodeType.entry = entry;
	async->args.field_qualify_L2DestSRNodeType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestSRNodeType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_node_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTSRNODETYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestSRNodeType_get.unit = unit;
	async->args.field_qualify_L2DestSRNodeType_get.entry = entry;
	async->args.field_qualify_L2DestSRNodeType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestValue.unit = unit;
	async->args.field_qualify_L2DestValue.entry = entry;
	async->args.field_qualify_L2DestValue.data = data;
	async->args.field_qualify_L2DestValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DestValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestValue_get.unit = unit;
	async->args.field_qualify_L2DestValue_get.entry = entry;
	async->args.field_qualify_L2DestValue_get.data = data;
	async->args.field_qualify_L2DestValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DstMulticastHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DSTMULTICASTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DstMulticastHit.unit = unit;
	async->args.field_qualify_L2DstMulticastHit.entry = entry;
	async->args.field_qualify_L2DstMulticastHit.data = data;
	async->args.field_qualify_L2DstMulticastHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2DstMulticastHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DSTMULTICASTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DstMulticastHit_get.unit = unit;
	async->args.field_qualify_L2DstMulticastHit_get.entry = entry;
	async->args.field_qualify_L2DstMulticastHit_get.data = data;
	async->args.field_qualify_L2DstMulticastHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2Format_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_L2Format_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Format.unit = unit;
	async->args.field_qualify_L2Format.entry = entry;
	async->args.field_qualify_L2Format.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2Format_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_L2Format_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Format_get.unit = unit;
	async->args.field_qualify_L2Format_get.entry = entry;
	async->args.field_qualify_L2Format_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreFlowId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREFLOWID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreFlowId.unit = unit;
	async->args.field_qualify_L2GreFlowId.entry = entry;
	async->args.field_qualify_L2GreFlowId.data = data;
	async->args.field_qualify_L2GreFlowId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreFlowId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREFLOWID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreFlowId_get.unit = unit;
	async->args.field_qualify_L2GreFlowId_get.entry = entry;
	async->args.field_qualify_L2GreFlowId_get.data = data;
	async->args.field_qualify_L2GreFlowId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreProtocolType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREPROTOCOLTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreProtocolType.unit = unit;
	async->args.field_qualify_L2GreProtocolType.entry = entry;
	async->args.field_qualify_L2GreProtocolType.data = data;
	async->args.field_qualify_L2GreProtocolType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreProtocolType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREPROTOCOLTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreProtocolType_get.unit = unit;
	async->args.field_qualify_L2GreProtocolType_get.entry = entry;
	async->args.field_qualify_L2GreProtocolType_get.data = data;
	async->args.field_qualify_L2GreProtocolType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreSrcIpHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GRESRCIPHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreSrcIpHit.unit = unit;
	async->args.field_qualify_L2GreSrcIpHit.entry = entry;
	async->args.field_qualify_L2GreSrcIpHit.data = data;
	async->args.field_qualify_L2GreSrcIpHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreSrcIpHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GRESRCIPHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreSrcIpHit_get.unit = unit;
	async->args.field_qualify_L2GreSrcIpHit_get.entry = entry;
	async->args.field_qualify_L2GreSrcIpHit_get.data = data;
	async->args.field_qualify_L2GreSrcIpHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreVfiHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREVFIHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreVfiHit.unit = unit;
	async->args.field_qualify_L2GreVfiHit.entry = entry;
	async->args.field_qualify_L2GreVfiHit.data = data;
	async->args.field_qualify_L2GreVfiHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreVfiHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREVFIHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreVfiHit_get.unit = unit;
	async->args.field_qualify_L2GreVfiHit_get.entry = entry;
	async->args.field_qualify_L2GreVfiHit_get.data = data;
	async->args.field_qualify_L2GreVfiHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreVsid_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREVSID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreVsid.unit = unit;
	async->args.field_qualify_L2GreVsid.entry = entry;
	async->args.field_qualify_L2GreVsid.data = data;
	async->args.field_qualify_L2GreVsid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2GreVsid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2GREVSID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2GreVsid_get.unit = unit;
	async->args.field_qualify_L2GreVsid_get.entry = entry;
	async->args.field_qualify_L2GreVsid_get.data = data;
	async->args.field_qualify_L2GreVsid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2Learn_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2LEARN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Learn.unit = unit;
	async->args.field_qualify_L2Learn.entry = entry;
	async->args.field_qualify_L2Learn.data = data;
	async->args.field_qualify_L2Learn.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2Learn_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2LEARN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Learn_get.unit = unit;
	async->args.field_qualify_L2Learn_get.entry = entry;
	async->args.field_qualify_L2Learn_get.data = data;
	async->args.field_qualify_L2Learn_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2PayLoad_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 length,
	const uint8 * data,
	const uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOAD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayLoad.unit = unit;
	async->args.field_qualify_L2PayLoad.entry = entry;
	async->args.field_qualify_L2PayLoad.length = length;
	async->args.field_qualify_L2PayLoad.data = (uint8 *)data;
	async->args.field_qualify_L2PayLoad.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2PayLoad_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 length,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOAD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayLoad_get.unit = unit;
	async->args.field_qualify_L2PayLoad_get.entry = entry;
	async->args.field_qualify_L2PayLoad_get.length = length;
	async->args.field_qualify_L2PayLoad_get.data = data;
	async->args.field_qualify_L2PayLoad_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2PayloadFirstEightBytes_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data1,
	uint32 data2,
	uint32 mask1,
	uint32 mask2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOADFIRSTEIGHTBYTES;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayloadFirstEightBytes.unit = unit;
	async->args.field_qualify_L2PayloadFirstEightBytes.entry = entry;
	async->args.field_qualify_L2PayloadFirstEightBytes.data1 = data1;
	async->args.field_qualify_L2PayloadFirstEightBytes.data2 = data2;
	async->args.field_qualify_L2PayloadFirstEightBytes.mask1 = mask1;
	async->args.field_qualify_L2PayloadFirstEightBytes.mask2 = mask2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2PayloadFirstEightBytes_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data1,
	uint32 * data2,
	uint32 * mask1,
	uint32 * mask2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOADFIRSTEIGHTBYTES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.unit = unit;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.entry = entry;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.data1 = data1;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.data2 = data2;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.mask1 = mask1;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.mask2 = mask2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcHit.unit = unit;
	async->args.field_qualify_L2SrcHit.entry = entry;
	async->args.field_qualify_L2SrcHit.data = data;
	async->args.field_qualify_L2SrcHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcHit_get.unit = unit;
	async->args.field_qualify_L2SrcHit_get.entry = entry;
	async->args.field_qualify_L2SrcHit_get.data = data;
	async->args.field_qualify_L2SrcHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcMulticastHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCMULTICASTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcMulticastHit.unit = unit;
	async->args.field_qualify_L2SrcMulticastHit.entry = entry;
	async->args.field_qualify_L2SrcMulticastHit.data = data;
	async->args.field_qualify_L2SrcMulticastHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcMulticastHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCMULTICASTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcMulticastHit_get.unit = unit;
	async->args.field_qualify_L2SrcMulticastHit_get.entry = entry;
	async->args.field_qualify_L2SrcMulticastHit_get.data = data;
	async->args.field_qualify_L2SrcMulticastHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcStatic_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcStatic.unit = unit;
	async->args.field_qualify_L2SrcStatic.entry = entry;
	async->args.field_qualify_L2SrcStatic.data = data;
	async->args.field_qualify_L2SrcStatic.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcStatic_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcStatic_get.unit = unit;
	async->args.field_qualify_L2SrcStatic_get.entry = entry;
	async->args.field_qualify_L2SrcStatic_get.data = data;
	async->args.field_qualify_L2SrcStatic_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcValue.unit = unit;
	async->args.field_qualify_L2SrcValue.entry = entry;
	async->args.field_qualify_L2SrcValue.data = data;
	async->args.field_qualify_L2SrcValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2SrcValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcValue_get.unit = unit;
	async->args.field_qualify_L2SrcValue_get.entry = entry;
	async->args.field_qualify_L2SrcValue_get.data = data;
	async->args.field_qualify_L2SrcValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2StationMove_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2StationMove.unit = unit;
	async->args.field_qualify_L2StationMove.entry = entry;
	async->args.field_qualify_L2StationMove.data = data;
	async->args.field_qualify_L2StationMove.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L2StationMove_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2StationMove_get.unit = unit;
	async->args.field_qualify_L2StationMove_get.entry = entry;
	async->args.field_qualify_L2StationMove_get.data = data;
	async->args.field_qualify_L2StationMove_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestHostHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestHostHit.unit = unit;
	async->args.field_qualify_L3DestHostHit.entry = entry;
	async->args.field_qualify_L3DestHostHit.data = data;
	async->args.field_qualify_L3DestHostHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestHostHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestHostHit_get.unit = unit;
	async->args.field_qualify_L3DestHostHit_get.entry = entry;
	async->args.field_qualify_L3DestHostHit_get.data = data;
	async->args.field_qualify_L3DestHostHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestRouteHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteHit.unit = unit;
	async->args.field_qualify_L3DestRouteHit.entry = entry;
	async->args.field_qualify_L3DestRouteHit.data = data;
	async->args.field_qualify_L3DestRouteHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestRouteHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteHit_get.unit = unit;
	async->args.field_qualify_L3DestRouteHit_get.entry = entry;
	async->args.field_qualify_L3DestRouteHit_get.data = data;
	async->args.field_qualify_L3DestRouteHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestRouteValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteValue.unit = unit;
	async->args.field_qualify_L3DestRouteValue.entry = entry;
	async->args.field_qualify_L3DestRouteValue.data = data;
	async->args.field_qualify_L3DestRouteValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3DestRouteValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteValue_get.unit = unit;
	async->args.field_qualify_L3DestRouteValue_get.entry = entry;
	async->args.field_qualify_L3DestRouteValue_get.data = data;
	async->args.field_qualify_L3DestRouteValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3Ingress_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 intf_id,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3INGRESS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Ingress.unit = unit;
	async->args.field_qualify_L3Ingress.entry = entry;
	async->args.field_qualify_L3Ingress.intf_id = intf_id;
	async->args.field_qualify_L3Ingress.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3Ingress_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3INGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Ingress_get.unit = unit;
	async->args.field_qualify_L3Ingress_get.entry = entry;
	async->args.field_qualify_L3Ingress_get.data = data;
	async->args.field_qualify_L3Ingress_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3Routable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Routable.unit = unit;
	async->args.field_qualify_L3Routable.entry = entry;
	async->args.field_qualify_L3Routable.data = data;
	async->args.field_qualify_L3Routable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3Routable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Routable_get.unit = unit;
	async->args.field_qualify_L3Routable_get.entry = entry;
	async->args.field_qualify_L3Routable_get.data = data;
	async->args.field_qualify_L3Routable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcBind_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCBIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcBind.unit = unit;
	async->args.field_qualify_L3SrcBind.entry = entry;
	async->args.field_qualify_L3SrcBind.data = data;
	async->args.field_qualify_L3SrcBind.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcBind_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCBIND_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcBind_get.unit = unit;
	async->args.field_qualify_L3SrcBind_get.entry = entry;
	async->args.field_qualify_L3SrcBind_get.data = data;
	async->args.field_qualify_L3SrcBind_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcHostHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcHostHit.unit = unit;
	async->args.field_qualify_L3SrcHostHit.entry = entry;
	async->args.field_qualify_L3SrcHostHit.data = data;
	async->args.field_qualify_L3SrcHostHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcHostHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcHostHit_get.unit = unit;
	async->args.field_qualify_L3SrcHostHit_get.entry = entry;
	async->args.field_qualify_L3SrcHostHit_get.data = data;
	async->args.field_qualify_L3SrcHostHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcRouteHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCROUTEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcRouteHit.unit = unit;
	async->args.field_qualify_L3SrcRouteHit.entry = entry;
	async->args.field_qualify_L3SrcRouteHit.data = data;
	async->args.field_qualify_L3SrcRouteHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcRouteHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCROUTEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcRouteHit_get.unit = unit;
	async->args.field_qualify_L3SrcRouteHit_get.entry = entry;
	async->args.field_qualify_L3SrcRouteHit_get.data = data;
	async->args.field_qualify_L3SrcRouteHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcRouteValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCROUTEVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcRouteValue.unit = unit;
	async->args.field_qualify_L3SrcRouteValue.entry = entry;
	async->args.field_qualify_L3SrcRouteValue.data = data;
	async->args.field_qualify_L3SrcRouteValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L3SrcRouteValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCROUTEVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcRouteValue_get.unit = unit;
	async->args.field_qualify_L3SrcRouteValue_get.entry = entry;
	async->args.field_qualify_L3SrcRouteValue_get.data = data;
	async->args.field_qualify_L3SrcRouteValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4DstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPort.unit = unit;
	async->args.field_qualify_L4DstPort.entry = entry;
	async->args.field_qualify_L4DstPort.data = data;
	async->args.field_qualify_L4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4DstPortClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORTCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPortClass.unit = unit;
	async->args.field_qualify_L4DstPortClass.entry = entry;
	async->args.field_qualify_L4DstPortClass.data = data;
	async->args.field_qualify_L4DstPortClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4DstPortClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORTCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPortClass_get.unit = unit;
	async->args.field_qualify_L4DstPortClass_get.entry = entry;
	async->args.field_qualify_L4DstPortClass_get.data = data;
	async->args.field_qualify_L4DstPortClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4DstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPort_get.unit = unit;
	async->args.field_qualify_L4DstPort_get.entry = entry;
	async->args.field_qualify_L4DstPort_get.data = data;
	async->args.field_qualify_L4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4PortRangeCheck_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_range_t range,
	int invert,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTRANGECHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4PortRangeCheck.unit = unit;
	async->args.field_qualify_L4PortRangeCheck.entry = entry;
	async->args.field_qualify_L4PortRangeCheck.range = range;
	async->args.field_qualify_L4PortRangeCheck.invert = invert;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4PortRangeCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	int max_count,
	bcm_field_range_t * range,
	int * invert,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTRANGECHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4PortRangeCheck_get.unit = unit;
	async->args.field_qualify_L4PortRangeCheck_get.entry = entry;
	async->args.field_qualify_L4PortRangeCheck_get.max_count = max_count;
	async->args.field_qualify_L4PortRangeCheck_get.range = range;
	async->args.field_qualify_L4PortRangeCheck_get.invert = invert;
	async->args.field_qualify_L4PortRangeCheck_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4Ports_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4Ports.unit = unit;
	async->args.field_qualify_L4Ports.entry = entry;
	async->args.field_qualify_L4Ports.data = data;
	async->args.field_qualify_L4Ports.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4Ports_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4Ports_get.unit = unit;
	async->args.field_qualify_L4Ports_get.entry = entry;
	async->args.field_qualify_L4Ports_get.data = data;
	async->args.field_qualify_L4Ports_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4SrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPort.unit = unit;
	async->args.field_qualify_L4SrcPort.entry = entry;
	async->args.field_qualify_L4SrcPort.data = data;
	async->args.field_qualify_L4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4SrcPortClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORTCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPortClass.unit = unit;
	async->args.field_qualify_L4SrcPortClass.entry = entry;
	async->args.field_qualify_L4SrcPortClass.data = data;
	async->args.field_qualify_L4SrcPortClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4SrcPortClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORTCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPortClass_get.unit = unit;
	async->args.field_qualify_L4SrcPortClass_get.entry = entry;
	async->args.field_qualify_L4SrcPortClass_get.data = data;
	async->args.field_qualify_L4SrcPortClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_L4SrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPort_get.unit = unit;
	async->args.field_qualify_L4SrcPort_get.entry = entry;
	async->args.field_qualify_L4SrcPort_get.data = data;
	async->args.field_qualify_L4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnExtension_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNEXTENSION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnExtension.unit = unit;
	async->args.field_qualify_LearnExtension.entry = entry;
	async->args.field_qualify_LearnExtension.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnExtension_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNEXTENSION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnExtension_get.unit = unit;
	async->args.field_qualify_LearnExtension_get.entry = entry;
	async->args.field_qualify_LearnExtension_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnInVPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNINVPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnInVPort.unit = unit;
	async->args.field_qualify_LearnInVPort.entry = entry;
	async->args.field_qualify_LearnInVPort.data = data;
	async->args.field_qualify_LearnInVPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnInVPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNINVPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnInVPort_get.unit = unit;
	async->args.field_qualify_LearnInVPort_get.entry = entry;
	async->args.field_qualify_LearnInVPort_get.data = data;
	async->args.field_qualify_LearnInVPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnSrcMac.unit = unit;
	async->args.field_qualify_LearnSrcMac.entry = entry;
	async->args.field_qualify_LearnSrcMac.data = (uint8 *)data;
	async->args.field_qualify_LearnSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnSrcMac_get.unit = unit;
	async->args.field_qualify_LearnSrcMac_get.entry = entry;
	async->args.field_qualify_LearnSrcMac_get.data = data;
	async->args.field_qualify_LearnSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnSrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNSRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnSrcPort.unit = unit;
	async->args.field_qualify_LearnSrcPort.entry = entry;
	async->args.field_qualify_LearnSrcPort.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnSrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNSRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnSrcPort_get.unit = unit;
	async->args.field_qualify_LearnSrcPort_get.entry = entry;
	async->args.field_qualify_LearnSrcPort_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnVlan.unit = unit;
	async->args.field_qualify_LearnVlan.entry = entry;
	async->args.field_qualify_LearnVlan.data = data;
	async->args.field_qualify_LearnVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LearnVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LEARNVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LearnVlan_get.unit = unit;
	async->args.field_qualify_LearnVlan_get.entry = entry;
	async->args.field_qualify_LearnVlan_get.data = data;
	async->args.field_qualify_LearnVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Llc_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_llc_header_t data,
	bcm_field_llc_header_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Llc.unit = unit;
	async->args.field_qualify_Llc.entry = entry;
	async->args.field_qualify_Llc.data = data;
	async->args.field_qualify_Llc.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Llc_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_llc_header_t * data,
	bcm_field_llc_header_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Llc_get.unit = unit;
	async->args.field_qualify_Llc_get.entry = entry;
	async->args.field_qualify_Llc_get.data = data;
	async->args.field_qualify_Llc_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LlidValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLIDVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LlidValue.unit = unit;
	async->args.field_qualify_LlidValue.entry = entry;
	async->args.field_qualify_LlidValue.data = data;
	async->args.field_qualify_LlidValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LlidValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLIDVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LlidValue_get.unit = unit;
	async->args.field_qualify_LlidValue_get.entry = entry;
	async->args.field_qualify_LlidValue_get.data = data;
	async->args.field_qualify_LlidValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackColor_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKCOLOR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackColor.unit = unit;
	async->args.field_qualify_LoopBackColor.entry = entry;
	async->args.field_qualify_LoopBackColor.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackColor_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKCOLOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackColor_get.unit = unit;
	async->args.field_qualify_LoopBackColor_get.entry = entry;
	async->args.field_qualify_LoopBackColor_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackCpuMasqueradePktProfile_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKCPUMASQUERADEPKTPROFILE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile.unit = unit;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile.entry = entry;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile.data = data;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackCpuMasqueradePktProfile_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKCPUMASQUERADEPKTPROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile_get.unit = unit;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile_get.entry = entry;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile_get.data = data;
	async->args.field_qualify_LoopBackCpuMasqueradePktProfile_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackPacketProcessingPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKPACKETPROCESSINGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackPacketProcessingPort.unit = unit;
	async->args.field_qualify_LoopBackPacketProcessingPort.entry = entry;
	async->args.field_qualify_LoopBackPacketProcessingPort.port_id = port_id;
	async->args.field_qualify_LoopBackPacketProcessingPort.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackPacketProcessingPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKPACKETPROCESSINGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackPacketProcessingPort_get.unit = unit;
	async->args.field_qualify_LoopBackPacketProcessingPort_get.entry = entry;
	async->args.field_qualify_LoopBackPacketProcessingPort_get.port_id = port_id;
	async->args.field_qualify_LoopBackPacketProcessingPort_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackQueue_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKQUEUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackQueue.unit = unit;
	async->args.field_qualify_LoopBackQueue.entry = entry;
	async->args.field_qualify_LoopBackQueue.data = data;
	async->args.field_qualify_LoopBackQueue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackQueue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKQUEUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackQueue_get.unit = unit;
	async->args.field_qualify_LoopBackQueue_get.entry = entry;
	async->args.field_qualify_LoopBackQueue_get.data = data;
	async->args.field_qualify_LoopBackQueue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackSrcGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKSRCGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackSrcGport.unit = unit;
	async->args.field_qualify_LoopBackSrcGport.entry = entry;
	async->args.field_qualify_LoopBackSrcGport.port_id = port_id;
	async->args.field_qualify_LoopBackSrcGport.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackSrcGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKSRCGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackSrcGport_get.unit = unit;
	async->args.field_qualify_LoopBackSrcGport_get.entry = entry;
	async->args.field_qualify_LoopBackSrcGport_get.port_id = port_id;
	async->args.field_qualify_LoopBackSrcGport_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackTrafficClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTRAFFICCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackTrafficClass.unit = unit;
	async->args.field_qualify_LoopBackTrafficClass.entry = entry;
	async->args.field_qualify_LoopBackTrafficClass.data = data;
	async->args.field_qualify_LoopBackTrafficClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopBackTrafficClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTRAFFICCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopBackTrafficClass_get.unit = unit;
	async->args.field_qualify_LoopBackTrafficClass_get.entry = entry;
	async->args.field_qualify_LoopBackTrafficClass_get.data = data;
	async->args.field_qualify_LoopBackTrafficClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Loopback_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Loopback.unit = unit;
	async->args.field_qualify_Loopback.entry = entry;
	async->args.field_qualify_Loopback.data = data;
	async->args.field_qualify_Loopback.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopbackType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_LoopbackType_t loopback_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopbackType.unit = unit;
	async->args.field_qualify_LoopbackType.entry = entry;
	async->args.field_qualify_LoopbackType.loopback_type = loopback_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_LoopbackType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_LoopbackType_t * loopback_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopbackType_get.unit = unit;
	async->args.field_qualify_LoopbackType_get.entry = entry;
	async->args.field_qualify_LoopbackType_get.loopback_type = loopback_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Loopback_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Loopback_get.unit = unit;
	async->args.field_qualify_Loopback_get.entry = entry;
	async->args.field_qualify_Loopback_get.data = data;
	async->args.field_qualify_Loopback_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MHOpcode_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MHOpcode.unit = unit;
	async->args.field_qualify_MHOpcode.entry = entry;
	async->args.field_qualify_MHOpcode.data = data;
	async->args.field_qualify_MHOpcode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MHOpcode_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MHOpcode_get.unit = unit;
	async->args.field_qualify_MHOpcode_get.entry = entry;
	async->args.field_qualify_MHOpcode_get.data = data;
	async->args.field_qualify_MHOpcode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MacAddrsNormalized_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MACADDRSNORMALIZED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MacAddrsNormalized.unit = unit;
	async->args.field_qualify_MacAddrsNormalized.entry = entry;
	async->args.field_qualify_MacAddrsNormalized.data = data;
	async->args.field_qualify_MacAddrsNormalized.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MacAddrsNormalized_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MACADDRSNORMALIZED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MacAddrsNormalized_get.unit = unit;
	async->args.field_qualify_MacAddrsNormalized_get.entry = entry;
	async->args.field_qualify_MacAddrsNormalized_get.data = data;
	async->args.field_qualify_MacAddrsNormalized_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimSrcGportHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMSRCGPORTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimSrcGportHit.unit = unit;
	async->args.field_qualify_MimSrcGportHit.entry = entry;
	async->args.field_qualify_MimSrcGportHit.data = data;
	async->args.field_qualify_MimSrcGportHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimSrcGportHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMSRCGPORTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimSrcGportHit_get.unit = unit;
	async->args.field_qualify_MimSrcGportHit_get.entry = entry;
	async->args.field_qualify_MimSrcGportHit_get.data = data;
	async->args.field_qualify_MimSrcGportHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVfiHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVFIHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVfiHit.unit = unit;
	async->args.field_qualify_MimVfiHit.entry = entry;
	async->args.field_qualify_MimVfiHit.data = data;
	async->args.field_qualify_MimVfiHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVfiHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVFIHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVfiHit_get.unit = unit;
	async->args.field_qualify_MimVfiHit_get.entry = entry;
	async->args.field_qualify_MimVfiHit_get.data = data;
	async->args.field_qualify_MimVfiHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVlanCfi.unit = unit;
	async->args.field_qualify_MimVlanCfi.entry = entry;
	async->args.field_qualify_MimVlanCfi.data = data;
	async->args.field_qualify_MimVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVlanCfi_get.unit = unit;
	async->args.field_qualify_MimVlanCfi_get.entry = entry;
	async->args.field_qualify_MimVlanCfi_get.data = data;
	async->args.field_qualify_MimVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVlanPri.unit = unit;
	async->args.field_qualify_MimVlanPri.entry = entry;
	async->args.field_qualify_MimVlanPri.data = data;
	async->args.field_qualify_MimVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimVlanPri_get.unit = unit;
	async->args.field_qualify_MimVlanPri_get.entry = entry;
	async->args.field_qualify_MimVlanPri_get.data = data;
	async->args.field_qualify_MimVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlDstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLDSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlDstMac.unit = unit;
	async->args.field_qualify_MimlDstMac.entry = entry;
	async->args.field_qualify_MimlDstMac.data = (uint8 *)data;
	async->args.field_qualify_MimlDstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlDstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLDSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlDstMac_get.unit = unit;
	async->args.field_qualify_MimlDstMac_get.entry = entry;
	async->args.field_qualify_MimlDstMac_get.data = data;
	async->args.field_qualify_MimlDstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlInnerTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLINNERTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlInnerTag.unit = unit;
	async->args.field_qualify_MimlInnerTag.entry = entry;
	async->args.field_qualify_MimlInnerTag.data = data;
	async->args.field_qualify_MimlInnerTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlInnerTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLINNERTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlInnerTag_get.unit = unit;
	async->args.field_qualify_MimlInnerTag_get.entry = entry;
	async->args.field_qualify_MimlInnerTag_get.data = data;
	async->args.field_qualify_MimlInnerTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlPkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLPKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlPkt.unit = unit;
	async->args.field_qualify_MimlPkt.entry = entry;
	async->args.field_qualify_MimlPkt.data = data;
	async->args.field_qualify_MimlPkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlPkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLPKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlPkt_get.unit = unit;
	async->args.field_qualify_MimlPkt_get.entry = entry;
	async->args.field_qualify_MimlPkt_get.data = data;
	async->args.field_qualify_MimlPkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlSrcMac.unit = unit;
	async->args.field_qualify_MimlSrcMac.entry = entry;
	async->args.field_qualify_MimlSrcMac.data = (uint8 *)data;
	async->args.field_qualify_MimlSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlSrcMac_get.unit = unit;
	async->args.field_qualify_MimlSrcMac_get.entry = entry;
	async->args.field_qualify_MimlSrcMac_get.data = data;
	async->args.field_qualify_MimlSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlan.unit = unit;
	async->args.field_qualify_MimlVlan.entry = entry;
	async->args.field_qualify_MimlVlan.data = data;
	async->args.field_qualify_MimlVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanCfi.unit = unit;
	async->args.field_qualify_MimlVlanCfi.entry = entry;
	async->args.field_qualify_MimlVlanCfi.data = data;
	async->args.field_qualify_MimlVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanCfi_get.unit = unit;
	async->args.field_qualify_MimlVlanCfi_get.entry = entry;
	async->args.field_qualify_MimlVlanCfi_get.data = data;
	async->args.field_qualify_MimlVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanId.unit = unit;
	async->args.field_qualify_MimlVlanId.entry = entry;
	async->args.field_qualify_MimlVlanId.data = data;
	async->args.field_qualify_MimlVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanId_get.unit = unit;
	async->args.field_qualify_MimlVlanId_get.entry = entry;
	async->args.field_qualify_MimlVlanId_get.data = data;
	async->args.field_qualify_MimlVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanPri.unit = unit;
	async->args.field_qualify_MimlVlanPri.entry = entry;
	async->args.field_qualify_MimlVlanPri.data = data;
	async->args.field_qualify_MimlVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlanPri_get.unit = unit;
	async->args.field_qualify_MimlVlanPri_get.entry = entry;
	async->args.field_qualify_MimlVlanPri_get.data = data;
	async->args.field_qualify_MimlVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MimlVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIMLVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MimlVlan_get.unit = unit;
	async->args.field_qualify_MimlVlan_get.entry = entry;
	async->args.field_qualify_MimlVlan_get.data = data;
	async->args.field_qualify_MimlVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MirrorCopy_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorCopy.unit = unit;
	async->args.field_qualify_MirrorCopy.entry = entry;
	async->args.field_qualify_MirrorCopy.data = data;
	async->args.field_qualify_MirrorCopy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MirrorCopy_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorCopy_get.unit = unit;
	async->args.field_qualify_MirrorCopy_get.entry = entry;
	async->args.field_qualify_MirrorCopy_get.data = data;
	async->args.field_qualify_MirrorCopy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MirrorEgressDisabled_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRROREGRESSDISABLED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorEgressDisabled.unit = unit;
	async->args.field_qualify_MirrorEgressDisabled.entry = entry;
	async->args.field_qualify_MirrorEgressDisabled.data = data;
	async->args.field_qualify_MirrorEgressDisabled.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MirrorEgressDisabled_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRROREGRESSDISABLED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorEgressDisabled_get.unit = unit;
	async->args.field_qualify_MirrorEgressDisabled_get.entry = entry;
	async->args.field_qualify_MirrorEgressDisabled_get.data = data;
	async->args.field_qualify_MirrorEgressDisabled_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MixedSrcClassId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t pbmp,
	bcm_field_src_class_t data,
	bcm_field_src_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIXEDSRCCLASSID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MixedSrcClassId.unit = unit;
	async->args.field_qualify_MixedSrcClassId.entry = entry;
	async->args.field_qualify_MixedSrcClassId.pbmp = pbmp;
	async->args.field_qualify_MixedSrcClassId.data = data;
	async->args.field_qualify_MixedSrcClassId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MixedSrcClassId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t pbmp,
	bcm_field_src_class_t * data,
	bcm_field_src_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIXEDSRCCLASSID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MixedSrcClassId_get.unit = unit;
	async->args.field_qualify_MixedSrcClassId_get.entry = entry;
	async->args.field_qualify_MixedSrcClassId_get.pbmp = pbmp;
	async->args.field_qualify_MixedSrcClassId_get.data = data;
	async->args.field_qualify_MixedSrcClassId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsBos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSBOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsBos.unit = unit;
	async->args.field_qualify_MplsBos.entry = entry;
	async->args.field_qualify_MplsBos.data = data;
	async->args.field_qualify_MplsBos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsBos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSBOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsBos_get.unit = unit;
	async->args.field_qualify_MplsBos_get.entry = entry;
	async->args.field_qualify_MplsBos_get.data = data;
	async->args.field_qualify_MplsBos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsControlWord_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSCONTROLWORD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsControlWord.unit = unit;
	async->args.field_qualify_MplsControlWord.entry = entry;
	async->args.field_qualify_MplsControlWord.data = data;
	async->args.field_qualify_MplsControlWord.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsControlWordValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSCONTROLWORDVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsControlWordValid.unit = unit;
	async->args.field_qualify_MplsControlWordValid.entry = entry;
	async->args.field_qualify_MplsControlWordValid.data = data;
	async->args.field_qualify_MplsControlWordValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsControlWordValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSCONTROLWORDVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsControlWordValid_get.unit = unit;
	async->args.field_qualify_MplsControlWordValid_get.entry = entry;
	async->args.field_qualify_MplsControlWordValid_get.data = data;
	async->args.field_qualify_MplsControlWordValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsControlWord_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSCONTROLWORD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsControlWord_get.unit = unit;
	async->args.field_qualify_MplsControlWord_get.entry = entry;
	async->args.field_qualify_MplsControlWord_get.data = data;
	async->args.field_qualify_MplsControlWord_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabel_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabel.unit = unit;
	async->args.field_qualify_MplsForwardingLabel.entry = entry;
	async->args.field_qualify_MplsForwardingLabel.data = data;
	async->args.field_qualify_MplsForwardingLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelAction_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELACTION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelAction.unit = unit;
	async->args.field_qualify_MplsForwardingLabelAction.entry = entry;
	async->args.field_qualify_MplsForwardingLabelAction.data = data;
	async->args.field_qualify_MplsForwardingLabelAction.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelAction32_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELACTION32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelAction32.unit = unit;
	async->args.field_qualify_MplsForwardingLabelAction32.entry = entry;
	async->args.field_qualify_MplsForwardingLabelAction32.data = data;
	async->args.field_qualify_MplsForwardingLabelAction32.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelAction32_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELACTION32_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelAction32_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelAction32_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelAction32_get.data = data;
	async->args.field_qualify_MplsForwardingLabelAction32_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelAction_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelAction_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelAction_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelAction_get.data = data;
	async->args.field_qualify_MplsForwardingLabelAction_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelBos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELBOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelBos.unit = unit;
	async->args.field_qualify_MplsForwardingLabelBos.entry = entry;
	async->args.field_qualify_MplsForwardingLabelBos.data = data;
	async->args.field_qualify_MplsForwardingLabelBos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelBos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELBOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelBos_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelBos_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelBos_get.data = data;
	async->args.field_qualify_MplsForwardingLabelBos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelExp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELEXP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelExp.unit = unit;
	async->args.field_qualify_MplsForwardingLabelExp.entry = entry;
	async->args.field_qualify_MplsForwardingLabelExp.data = data;
	async->args.field_qualify_MplsForwardingLabelExp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelExp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELEXP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelExp_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelExp_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelExp_get.data = data;
	async->args.field_qualify_MplsForwardingLabelExp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelId.unit = unit;
	async->args.field_qualify_MplsForwardingLabelId.entry = entry;
	async->args.field_qualify_MplsForwardingLabelId.data = data;
	async->args.field_qualify_MplsForwardingLabelId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelId_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelId_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelId_get.data = data;
	async->args.field_qualify_MplsForwardingLabelId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelPayload_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELPAYLOAD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelPayload.unit = unit;
	async->args.field_qualify_MplsForwardingLabelPayload.entry = entry;
	async->args.field_qualify_MplsForwardingLabelPayload.data = data;
	async->args.field_qualify_MplsForwardingLabelPayload.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelPayload_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELPAYLOAD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelPayload_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelPayload_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelPayload_get.data = data;
	async->args.field_qualify_MplsForwardingLabelPayload_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelTtl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELTTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelTtl.unit = unit;
	async->args.field_qualify_MplsForwardingLabelTtl.entry = entry;
	async->args.field_qualify_MplsForwardingLabelTtl.data = data;
	async->args.field_qualify_MplsForwardingLabelTtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabelTtl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABELTTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabelTtl_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabelTtl_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabelTtl_get.data = data;
	async->args.field_qualify_MplsForwardingLabelTtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsForwardingLabel_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSFORWARDINGLABEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsForwardingLabel_get.unit = unit;
	async->args.field_qualify_MplsForwardingLabel_get.entry = entry;
	async->args.field_qualify_MplsForwardingLabel_get.data = data;
	async->args.field_qualify_MplsForwardingLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1.unit = unit;
	async->args.field_qualify_MplsLabel1.entry = entry;
	async->args.field_qualify_MplsLabel1.data = data;
	async->args.field_qualify_MplsLabel1.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Bos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1BOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Bos.unit = unit;
	async->args.field_qualify_MplsLabel1Bos.entry = entry;
	async->args.field_qualify_MplsLabel1Bos.data = data;
	async->args.field_qualify_MplsLabel1Bos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Bos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1BOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Bos_get.unit = unit;
	async->args.field_qualify_MplsLabel1Bos_get.entry = entry;
	async->args.field_qualify_MplsLabel1Bos_get.data = data;
	async->args.field_qualify_MplsLabel1Bos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Exp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1EXP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Exp.unit = unit;
	async->args.field_qualify_MplsLabel1Exp.entry = entry;
	async->args.field_qualify_MplsLabel1Exp.data = data;
	async->args.field_qualify_MplsLabel1Exp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Exp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1EXP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Exp_get.unit = unit;
	async->args.field_qualify_MplsLabel1Exp_get.entry = entry;
	async->args.field_qualify_MplsLabel1Exp_get.data = data;
	async->args.field_qualify_MplsLabel1Exp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Hit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1HIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Hit.unit = unit;
	async->args.field_qualify_MplsLabel1Hit.entry = entry;
	async->args.field_qualify_MplsLabel1Hit.data = data;
	async->args.field_qualify_MplsLabel1Hit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Hit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1HIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Hit_get.unit = unit;
	async->args.field_qualify_MplsLabel1Hit_get.entry = entry;
	async->args.field_qualify_MplsLabel1Hit_get.data = data;
	async->args.field_qualify_MplsLabel1Hit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Id_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Id.unit = unit;
	async->args.field_qualify_MplsLabel1Id.entry = entry;
	async->args.field_qualify_MplsLabel1Id.data = data;
	async->args.field_qualify_MplsLabel1Id.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Id_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Id_get.unit = unit;
	async->args.field_qualify_MplsLabel1Id_get.entry = entry;
	async->args.field_qualify_MplsLabel1Id_get.data = data;
	async->args.field_qualify_MplsLabel1Id_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Ttl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1TTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Ttl.unit = unit;
	async->args.field_qualify_MplsLabel1Ttl.entry = entry;
	async->args.field_qualify_MplsLabel1Ttl.data = data;
	async->args.field_qualify_MplsLabel1Ttl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1Ttl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1TTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1Ttl_get.unit = unit;
	async->args.field_qualify_MplsLabel1Ttl_get.entry = entry;
	async->args.field_qualify_MplsLabel1Ttl_get.data = data;
	async->args.field_qualify_MplsLabel1Ttl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel1_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel1_get.unit = unit;
	async->args.field_qualify_MplsLabel1_get.entry = entry;
	async->args.field_qualify_MplsLabel1_get.data = data;
	async->args.field_qualify_MplsLabel1_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2.unit = unit;
	async->args.field_qualify_MplsLabel2.entry = entry;
	async->args.field_qualify_MplsLabel2.data = data;
	async->args.field_qualify_MplsLabel2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Bos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2BOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Bos.unit = unit;
	async->args.field_qualify_MplsLabel2Bos.entry = entry;
	async->args.field_qualify_MplsLabel2Bos.data = data;
	async->args.field_qualify_MplsLabel2Bos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Bos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2BOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Bos_get.unit = unit;
	async->args.field_qualify_MplsLabel2Bos_get.entry = entry;
	async->args.field_qualify_MplsLabel2Bos_get.data = data;
	async->args.field_qualify_MplsLabel2Bos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Exp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2EXP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Exp.unit = unit;
	async->args.field_qualify_MplsLabel2Exp.entry = entry;
	async->args.field_qualify_MplsLabel2Exp.data = data;
	async->args.field_qualify_MplsLabel2Exp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Exp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2EXP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Exp_get.unit = unit;
	async->args.field_qualify_MplsLabel2Exp_get.entry = entry;
	async->args.field_qualify_MplsLabel2Exp_get.data = data;
	async->args.field_qualify_MplsLabel2Exp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Hit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2HIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Hit.unit = unit;
	async->args.field_qualify_MplsLabel2Hit.entry = entry;
	async->args.field_qualify_MplsLabel2Hit.data = data;
	async->args.field_qualify_MplsLabel2Hit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Hit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2HIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Hit_get.unit = unit;
	async->args.field_qualify_MplsLabel2Hit_get.entry = entry;
	async->args.field_qualify_MplsLabel2Hit_get.data = data;
	async->args.field_qualify_MplsLabel2Hit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Id_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Id.unit = unit;
	async->args.field_qualify_MplsLabel2Id.entry = entry;
	async->args.field_qualify_MplsLabel2Id.data = data;
	async->args.field_qualify_MplsLabel2Id.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Id_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Id_get.unit = unit;
	async->args.field_qualify_MplsLabel2Id_get.entry = entry;
	async->args.field_qualify_MplsLabel2Id_get.data = data;
	async->args.field_qualify_MplsLabel2Id_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Ttl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2TTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Ttl.unit = unit;
	async->args.field_qualify_MplsLabel2Ttl.entry = entry;
	async->args.field_qualify_MplsLabel2Ttl.data = data;
	async->args.field_qualify_MplsLabel2Ttl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2Ttl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2TTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2Ttl_get.unit = unit;
	async->args.field_qualify_MplsLabel2Ttl_get.entry = entry;
	async->args.field_qualify_MplsLabel2Ttl_get.data = data;
	async->args.field_qualify_MplsLabel2Ttl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel2_get.unit = unit;
	async->args.field_qualify_MplsLabel2_get.entry = entry;
	async->args.field_qualify_MplsLabel2_get.data = data;
	async->args.field_qualify_MplsLabel2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3.unit = unit;
	async->args.field_qualify_MplsLabel3.entry = entry;
	async->args.field_qualify_MplsLabel3.data = data;
	async->args.field_qualify_MplsLabel3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Bos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3BOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Bos.unit = unit;
	async->args.field_qualify_MplsLabel3Bos.entry = entry;
	async->args.field_qualify_MplsLabel3Bos.data = data;
	async->args.field_qualify_MplsLabel3Bos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Bos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3BOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Bos_get.unit = unit;
	async->args.field_qualify_MplsLabel3Bos_get.entry = entry;
	async->args.field_qualify_MplsLabel3Bos_get.data = data;
	async->args.field_qualify_MplsLabel3Bos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Exp_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3EXP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Exp.unit = unit;
	async->args.field_qualify_MplsLabel3Exp.entry = entry;
	async->args.field_qualify_MplsLabel3Exp.data = data;
	async->args.field_qualify_MplsLabel3Exp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Exp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3EXP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Exp_get.unit = unit;
	async->args.field_qualify_MplsLabel3Exp_get.entry = entry;
	async->args.field_qualify_MplsLabel3Exp_get.data = data;
	async->args.field_qualify_MplsLabel3Exp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Id_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Id.unit = unit;
	async->args.field_qualify_MplsLabel3Id.entry = entry;
	async->args.field_qualify_MplsLabel3Id.data = data;
	async->args.field_qualify_MplsLabel3Id.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Id_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Id_get.unit = unit;
	async->args.field_qualify_MplsLabel3Id_get.entry = entry;
	async->args.field_qualify_MplsLabel3Id_get.data = data;
	async->args.field_qualify_MplsLabel3Id_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Ttl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3TTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Ttl.unit = unit;
	async->args.field_qualify_MplsLabel3Ttl.entry = entry;
	async->args.field_qualify_MplsLabel3Ttl.data = data;
	async->args.field_qualify_MplsLabel3Ttl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3Ttl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3TTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3Ttl_get.unit = unit;
	async->args.field_qualify_MplsLabel3Ttl_get.entry = entry;
	async->args.field_qualify_MplsLabel3Ttl_get.data = data;
	async->args.field_qualify_MplsLabel3Ttl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsLabel3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSLABEL3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsLabel3_get.unit = unit;
	async->args.field_qualify_MplsLabel3_get.entry = entry;
	async->args.field_qualify_MplsLabel3_get.data = data;
	async->args.field_qualify_MplsLabel3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamACH_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamACH.unit = unit;
	async->args.field_qualify_MplsOamACH.entry = entry;
	async->args.field_qualify_MplsOamACH.data = data;
	async->args.field_qualify_MplsOamACH.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamACH_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamACH_get.unit = unit;
	async->args.field_qualify_MplsOamACH_get.entry = entry;
	async->args.field_qualify_MplsOamACH_get.data = data;
	async->args.field_qualify_MplsOamACH_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamClassMplsSwitchLabel_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMCLASSMPLSSWITCHLABEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel.unit = unit;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel.entry = entry;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel.data = data;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamClassMplsSwitchLabel_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMCLASSMPLSSWITCHLABEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel_get.unit = unit;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel_get.entry = entry;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel_get.data = data;
	async->args.field_qualify_MplsOamClassMplsSwitchLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamControlPktType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_MplsOam_Control_pktType_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMCONTROLPKTTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamControlPktType.unit = unit;
	async->args.field_qualify_MplsOamControlPktType.entry = entry;
	async->args.field_qualify_MplsOamControlPktType.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamControlPktType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_MplsOam_Control_pktType_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMCONTROLPKTTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamControlPktType_get.unit = unit;
	async->args.field_qualify_MplsOamControlPktType_get.entry = entry;
	async->args.field_qualify_MplsOamControlPktType_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamGALExposed_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMGALEXPOSED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamGALExposed.unit = unit;
	async->args.field_qualify_MplsOamGALExposed.entry = entry;
	async->args.field_qualify_MplsOamGALExposed.data = data;
	async->args.field_qualify_MplsOamGALExposed.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamGALExposed_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMGALEXPOSED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamGALExposed_get.unit = unit;
	async->args.field_qualify_MplsOamGALExposed_get.entry = entry;
	async->args.field_qualify_MplsOamGALExposed_get.data = data;
	async->args.field_qualify_MplsOamGALExposed_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamGALLabelOnly_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMGALLABELONLY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamGALLabelOnly.unit = unit;
	async->args.field_qualify_MplsOamGALLabelOnly.entry = entry;
	async->args.field_qualify_MplsOamGALLabelOnly.data = data;
	async->args.field_qualify_MplsOamGALLabelOnly.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamGALLabelOnly_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMGALLABELONLY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamGALLabelOnly_get.unit = unit;
	async->args.field_qualify_MplsOamGALLabelOnly_get.entry = entry;
	async->args.field_qualify_MplsOamGALLabelOnly_get.data = data;
	async->args.field_qualify_MplsOamGALLabelOnly_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamHeaderBits0_31_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMHEADERBITS0_31;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamHeaderBits0_31.unit = unit;
	async->args.field_qualify_MplsOamHeaderBits0_31.entry = entry;
	async->args.field_qualify_MplsOamHeaderBits0_31.data = data;
	async->args.field_qualify_MplsOamHeaderBits0_31.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamHeaderBits0_31_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMHEADERBITS0_31_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamHeaderBits0_31_get.unit = unit;
	async->args.field_qualify_MplsOamHeaderBits0_31_get.entry = entry;
	async->args.field_qualify_MplsOamHeaderBits0_31_get.data = data;
	async->args.field_qualify_MplsOamHeaderBits0_31_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamHeaderBits32_63_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMHEADERBITS32_63;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamHeaderBits32_63.unit = unit;
	async->args.field_qualify_MplsOamHeaderBits32_63.entry = entry;
	async->args.field_qualify_MplsOamHeaderBits32_63.data = data;
	async->args.field_qualify_MplsOamHeaderBits32_63.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamHeaderBits32_63_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMHEADERBITS32_63_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamHeaderBits32_63_get.unit = unit;
	async->args.field_qualify_MplsOamHeaderBits32_63_get.entry = entry;
	async->args.field_qualify_MplsOamHeaderBits32_63_get.data = data;
	async->args.field_qualify_MplsOamHeaderBits32_63_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamUpperLabelDataDrop_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMUPPERLABELDATADROP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamUpperLabelDataDrop.unit = unit;
	async->args.field_qualify_MplsOamUpperLabelDataDrop.entry = entry;
	async->args.field_qualify_MplsOamUpperLabelDataDrop.data = data;
	async->args.field_qualify_MplsOamUpperLabelDataDrop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOamUpperLabelDataDrop_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOAMUPPERLABELDATADROP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOamUpperLabelDataDrop_get.unit = unit;
	async->args.field_qualify_MplsOamUpperLabelDataDrop_get.entry = entry;
	async->args.field_qualify_MplsOamUpperLabelDataDrop_get.data = data;
	async->args.field_qualify_MplsOamUpperLabelDataDrop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOuterLabelPop_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOUTERLABELPOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOuterLabelPop.unit = unit;
	async->args.field_qualify_MplsOuterLabelPop.entry = entry;
	async->args.field_qualify_MplsOuterLabelPop.data = data;
	async->args.field_qualify_MplsOuterLabelPop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsOuterLabelPop_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSOUTERLABELPOP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsOuterLabelPop_get.unit = unit;
	async->args.field_qualify_MplsOuterLabelPop_get.entry = entry;
	async->args.field_qualify_MplsOuterLabelPop_get.data = data;
	async->args.field_qualify_MplsOuterLabelPop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsStationHitTunnelUnterminated_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSSTATIONHITTUNNELUNTERMINATED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsStationHitTunnelUnterminated.unit = unit;
	async->args.field_qualify_MplsStationHitTunnelUnterminated.entry = entry;
	async->args.field_qualify_MplsStationHitTunnelUnterminated.data = data;
	async->args.field_qualify_MplsStationHitTunnelUnterminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsStationHitTunnelUnterminated_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSSTATIONHITTUNNELUNTERMINATED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsStationHitTunnelUnterminated_get.unit = unit;
	async->args.field_qualify_MplsStationHitTunnelUnterminated_get.entry = entry;
	async->args.field_qualify_MplsStationHitTunnelUnterminated_get.data = data;
	async->args.field_qualify_MplsStationHitTunnelUnterminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminated_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminated.unit = unit;
	async->args.field_qualify_MplsTerminated.entry = entry;
	async->args.field_qualify_MplsTerminated.data = data;
	async->args.field_qualify_MplsTerminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminatedHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATEDHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminatedHit.unit = unit;
	async->args.field_qualify_MplsTerminatedHit.entry = entry;
	async->args.field_qualify_MplsTerminatedHit.data = data;
	async->args.field_qualify_MplsTerminatedHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminatedHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATEDHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminatedHit_get.unit = unit;
	async->args.field_qualify_MplsTerminatedHit_get.entry = entry;
	async->args.field_qualify_MplsTerminatedHit_get.data = data;
	async->args.field_qualify_MplsTerminatedHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminatedValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATEDVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminatedValue.unit = unit;
	async->args.field_qualify_MplsTerminatedValue.entry = entry;
	async->args.field_qualify_MplsTerminatedValue.data = data;
	async->args.field_qualify_MplsTerminatedValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminatedValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATEDVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminatedValue_get.unit = unit;
	async->args.field_qualify_MplsTerminatedValue_get.entry = entry;
	async->args.field_qualify_MplsTerminatedValue_get.data = data;
	async->args.field_qualify_MplsTerminatedValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MplsTerminated_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminated_get.unit = unit;
	async->args.field_qualify_MplsTerminated_get.entry = entry;
	async->args.field_qualify_MplsTerminated_get.data = data;
	async->args.field_qualify_MplsTerminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MyStation2Hit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATION2HIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStation2Hit.unit = unit;
	async->args.field_qualify_MyStation2Hit.entry = entry;
	async->args.field_qualify_MyStation2Hit.data = data;
	async->args.field_qualify_MyStation2Hit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MyStation2Hit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATION2HIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStation2Hit_get.unit = unit;
	async->args.field_qualify_MyStation2Hit_get.entry = entry;
	async->args.field_qualify_MyStation2Hit_get.data = data;
	async->args.field_qualify_MyStation2Hit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MyStationHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATIONHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStationHit.unit = unit;
	async->args.field_qualify_MyStationHit.entry = entry;
	async->args.field_qualify_MyStationHit.data = data;
	async->args.field_qualify_MyStationHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_MyStationHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATIONHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStationHit_get.unit = unit;
	async->args.field_qualify_MyStationHit_get.entry = entry;
	async->args.field_qualify_MyStationHit_get.data = data;
	async->args.field_qualify_MyStationHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatDstRealmId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATDSTREALMID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatDstRealmId.unit = unit;
	async->args.field_qualify_NatDstRealmId.entry = entry;
	async->args.field_qualify_NatDstRealmId.data = data;
	async->args.field_qualify_NatDstRealmId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatDstRealmId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATDSTREALMID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatDstRealmId_get.unit = unit;
	async->args.field_qualify_NatDstRealmId_get.entry = entry;
	async->args.field_qualify_NatDstRealmId_get.data = data;
	async->args.field_qualify_NatDstRealmId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatNeeded_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATNEEDED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatNeeded.unit = unit;
	async->args.field_qualify_NatNeeded.entry = entry;
	async->args.field_qualify_NatNeeded.data = data;
	async->args.field_qualify_NatNeeded.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatNeeded_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATNEEDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatNeeded_get.unit = unit;
	async->args.field_qualify_NatNeeded_get.entry = entry;
	async->args.field_qualify_NatNeeded_get.data = data;
	async->args.field_qualify_NatNeeded_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatSrcRealmId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATSRCREALMID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatSrcRealmId.unit = unit;
	async->args.field_qualify_NatSrcRealmId.entry = entry;
	async->args.field_qualify_NatSrcRealmId.data = data;
	async->args.field_qualify_NatSrcRealmId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NatSrcRealmId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATSRCREALMID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NatSrcRealmId_get.unit = unit;
	async->args.field_qualify_NatSrcRealmId_get.entry = entry;
	async->args.field_qualify_NatSrcRealmId_get.data = data;
	async->args.field_qualify_NatSrcRealmId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NativeVSwitch_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATIVEVSWITCH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NativeVSwitch.unit = unit;
	async->args.field_qualify_NativeVSwitch.entry = entry;
	async->args.field_qualify_NativeVSwitch.data = data;
	async->args.field_qualify_NativeVSwitch.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NativeVSwitchValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATIVEVSWITCHVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NativeVSwitchValid.unit = unit;
	async->args.field_qualify_NativeVSwitchValid.entry = entry;
	async->args.field_qualify_NativeVSwitchValid.data = data;
	async->args.field_qualify_NativeVSwitchValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NativeVSwitchValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATIVEVSWITCHVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NativeVSwitchValid_get.unit = unit;
	async->args.field_qualify_NativeVSwitchValid_get.entry = entry;
	async->args.field_qualify_NativeVSwitchValid_get.data = data;
	async->args.field_qualify_NativeVSwitchValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_NativeVSwitch_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_NATIVEVSWITCH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_NativeVSwitch_get.unit = unit;
	async->args.field_qualify_NativeVSwitch_get.entry = entry;
	async->args.field_qualify_NativeVSwitch_get.data = data;
	async->args.field_qualify_NativeVSwitch_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamDownMEPLoopbackPacket_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMDOWNMEPLOOPBACKPACKET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamDownMEPLoopbackPacket.unit = unit;
	async->args.field_qualify_OamDownMEPLoopbackPacket.entry = entry;
	async->args.field_qualify_OamDownMEPLoopbackPacket.data = data;
	async->args.field_qualify_OamDownMEPLoopbackPacket.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamDownMEPLoopbackPacket_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMDOWNMEPLOOPBACKPACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamDownMEPLoopbackPacket_get.unit = unit;
	async->args.field_qualify_OamDownMEPLoopbackPacket_get.entry = entry;
	async->args.field_qualify_OamDownMEPLoopbackPacket_get.data = data;
	async->args.field_qualify_OamDownMEPLoopbackPacket_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClass2Vxlt_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASS2VXLT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClass2Vxlt.unit = unit;
	async->args.field_qualify_OamEgressClass2Vxlt.entry = entry;
	async->args.field_qualify_OamEgressClass2Vxlt.data = data;
	async->args.field_qualify_OamEgressClass2Vxlt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClass2Vxlt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASS2VXLT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClass2Vxlt_get.unit = unit;
	async->args.field_qualify_OamEgressClass2Vxlt_get.entry = entry;
	async->args.field_qualify_OamEgressClass2Vxlt_get.data = data;
	async->args.field_qualify_OamEgressClass2Vxlt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassPort.unit = unit;
	async->args.field_qualify_OamEgressClassPort.entry = entry;
	async->args.field_qualify_OamEgressClassPort.data = data;
	async->args.field_qualify_OamEgressClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassPort_get.unit = unit;
	async->args.field_qualify_OamEgressClassPort_get.entry = entry;
	async->args.field_qualify_OamEgressClassPort_get.data = data;
	async->args.field_qualify_OamEgressClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassSrcMac.unit = unit;
	async->args.field_qualify_OamEgressClassSrcMac.entry = entry;
	async->args.field_qualify_OamEgressClassSrcMac.data = data;
	async->args.field_qualify_OamEgressClassSrcMac.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassSrcMac_get.unit = unit;
	async->args.field_qualify_OamEgressClassSrcMac_get.entry = entry;
	async->args.field_qualify_OamEgressClassSrcMac_get.data = data;
	async->args.field_qualify_OamEgressClassSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassVxlt_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSVXLT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassVxlt.unit = unit;
	async->args.field_qualify_OamEgressClassVxlt.entry = entry;
	async->args.field_qualify_OamEgressClassVxlt.data = data;
	async->args.field_qualify_OamEgressClassVxlt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressClassVxlt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSCLASSVXLT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressClassVxlt_get.unit = unit;
	async->args.field_qualify_OamEgressClassVxlt_get.entry = entry;
	async->args.field_qualify_OamEgressClassVxlt_get.data = data;
	async->args.field_qualify_OamEgressClassVxlt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressEtherType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSETHERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressEtherType.unit = unit;
	async->args.field_qualify_OamEgressEtherType.entry = entry;
	async->args.field_qualify_OamEgressEtherType.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressEtherType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressEtherType_get.unit = unit;
	async->args.field_qualify_OamEgressEtherType_get.entry = entry;
	async->args.field_qualify_OamEgressEtherType_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressMulticastMacHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSMULTICASTMACHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressMulticastMacHit.unit = unit;
	async->args.field_qualify_OamEgressMulticastMacHit.entry = entry;
	async->args.field_qualify_OamEgressMulticastMacHit.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressMulticastMacHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSMULTICASTMACHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressMulticastMacHit_get.unit = unit;
	async->args.field_qualify_OamEgressMulticastMacHit_get.entry = entry;
	async->args.field_qualify_OamEgressMulticastMacHit_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressPortUnicastDstMacHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSPORTUNICASTDSTMACHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit.unit = unit;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit.entry = entry;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit.data = data;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressPortUnicastDstMacHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSPORTUNICASTDSTMACHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit_get.unit = unit;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit_get.entry = entry;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit_get.data = data;
	async->args.field_qualify_OamEgressPortUnicastDstMacHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressVxltFirstHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSVXLTFIRSTHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressVxltFirstHit.unit = unit;
	async->args.field_qualify_OamEgressVxltFirstHit.entry = entry;
	async->args.field_qualify_OamEgressVxltFirstHit.data = data;
	async->args.field_qualify_OamEgressVxltFirstHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressVxltFirstHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSVXLTFIRSTHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressVxltFirstHit_get.unit = unit;
	async->args.field_qualify_OamEgressVxltFirstHit_get.entry = entry;
	async->args.field_qualify_OamEgressVxltFirstHit_get.data = data;
	async->args.field_qualify_OamEgressVxltFirstHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressVxltSecondHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSVXLTSECONDHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressVxltSecondHit.unit = unit;
	async->args.field_qualify_OamEgressVxltSecondHit.entry = entry;
	async->args.field_qualify_OamEgressVxltSecondHit.data = data;
	async->args.field_qualify_OamEgressVxltSecondHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamEgressVxltSecondHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMEGRESSVXLTSECONDHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamEgressVxltSecondHit_get.unit = unit;
	async->args.field_qualify_OamEgressVxltSecondHit_get.entry = entry;
	async->args.field_qualify_OamEgressVxltSecondHit_get.data = data;
	async->args.field_qualify_OamEgressVxltSecondHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderBits0_31_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADERBITS0_31;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderBits0_31.unit = unit;
	async->args.field_qualify_OamHeaderBits0_31.entry = entry;
	async->args.field_qualify_OamHeaderBits0_31.data = data;
	async->args.field_qualify_OamHeaderBits0_31.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderBits0_31_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADERBITS0_31_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderBits0_31_get.unit = unit;
	async->args.field_qualify_OamHeaderBits0_31_get.entry = entry;
	async->args.field_qualify_OamHeaderBits0_31_get.data = data;
	async->args.field_qualify_OamHeaderBits0_31_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderBits32_63_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADERBITS32_63;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderBits32_63.unit = unit;
	async->args.field_qualify_OamHeaderBits32_63.entry = entry;
	async->args.field_qualify_OamHeaderBits32_63.data = data;
	async->args.field_qualify_OamHeaderBits32_63.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderBits32_63_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADERBITS32_63_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderBits32_63_get.unit = unit;
	async->args.field_qualify_OamHeaderBits32_63_get.entry = entry;
	async->args.field_qualify_OamHeaderBits32_63_get.data = data;
	async->args.field_qualify_OamHeaderBits32_63_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderOffset_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADEROFFSET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderOffset.unit = unit;
	async->args.field_qualify_OamHeaderOffset.entry = entry;
	async->args.field_qualify_OamHeaderOffset.data = data;
	async->args.field_qualify_OamHeaderOffset.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamHeaderOffset_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMHEADEROFFSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamHeaderOffset_get.unit = unit;
	async->args.field_qualify_OamHeaderOffset_get.entry = entry;
	async->args.field_qualify_OamHeaderOffset_get.data = data;
	async->args.field_qualify_OamHeaderOffset_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamInLifId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMINLIFID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamInLifId.unit = unit;
	async->args.field_qualify_OamInLifId.entry = entry;
	async->args.field_qualify_OamInLifId.data = data;
	async->args.field_qualify_OamInLifId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamInLifIdValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMINLIFIDVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamInLifIdValid.unit = unit;
	async->args.field_qualify_OamInLifIdValid.entry = entry;
	async->args.field_qualify_OamInLifIdValid.data = data;
	async->args.field_qualify_OamInLifIdValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamInLifIdValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMINLIFIDVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamInLifIdValid_get.unit = unit;
	async->args.field_qualify_OamInLifIdValid_get.entry = entry;
	async->args.field_qualify_OamInLifIdValid_get.data = data;
	async->args.field_qualify_OamInLifIdValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamInLifId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMINLIFID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamInLifId_get.unit = unit;
	async->args.field_qualify_OamInLifId_get.entry = entry;
	async->args.field_qualify_OamInLifId_get.data = data;
	async->args.field_qualify_OamInLifId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMdl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMDL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMdl.unit = unit;
	async->args.field_qualify_OamMdl.entry = entry;
	async->args.field_qualify_OamMdl.data = data;
	async->args.field_qualify_OamMdl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMdl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMDL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMdl_get.unit = unit;
	async->args.field_qualify_OamMdl_get.entry = entry;
	async->args.field_qualify_OamMdl_get.data = data;
	async->args.field_qualify_OamMdl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMepId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMEPID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMepId.unit = unit;
	async->args.field_qualify_OamMepId.entry = entry;
	async->args.field_qualify_OamMepId.data = data;
	async->args.field_qualify_OamMepId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMepId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMEPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMepId_get.unit = unit;
	async->args.field_qualify_OamMepId_get.entry = entry;
	async->args.field_qualify_OamMepId_get.data = data;
	async->args.field_qualify_OamMepId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMeterDisable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMETERDISABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMeterDisable.unit = unit;
	async->args.field_qualify_OamMeterDisable.entry = entry;
	async->args.field_qualify_OamMeterDisable.data = data;
	async->args.field_qualify_OamMeterDisable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamMeterDisable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMMETERDISABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamMeterDisable_get.unit = unit;
	async->args.field_qualify_OamMeterDisable_get.entry = entry;
	async->args.field_qualify_OamMeterDisable_get.data = data;
	async->args.field_qualify_OamMeterDisable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamStampOffset_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMSTAMPOFFSET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamStampOffset.unit = unit;
	async->args.field_qualify_OamStampOffset.entry = entry;
	async->args.field_qualify_OamStampOffset.data = data;
	async->args.field_qualify_OamStampOffset.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamStampOffset_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMSTAMPOFFSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamStampOffset_get.unit = unit;
	async->args.field_qualify_OamStampOffset_get.entry = entry;
	async->args.field_qualify_OamStampOffset_get.data = data;
	async->args.field_qualify_OamStampOffset_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamSubtype_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMSUBTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamSubtype.unit = unit;
	async->args.field_qualify_OamSubtype.entry = entry;
	async->args.field_qualify_OamSubtype.data = data;
	async->args.field_qualify_OamSubtype.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamSubtype_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMSUBTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamSubtype_get.unit = unit;
	async->args.field_qualify_OamSubtype_get.entry = entry;
	async->args.field_qualify_OamSubtype_get.data = data;
	async->args.field_qualify_OamSubtype_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamTsSystemHeader_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMTSSYSTEMHEADER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamTsSystemHeader.unit = unit;
	async->args.field_qualify_OamTsSystemHeader.entry = entry;
	async->args.field_qualify_OamTsSystemHeader.data = data;
	async->args.field_qualify_OamTsSystemHeader.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamTsSystemHeader_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMTSSYSTEMHEADER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamTsSystemHeader_get.unit = unit;
	async->args.field_qualify_OamTsSystemHeader_get.entry = entry;
	async->args.field_qualify_OamTsSystemHeader_get.data = data;
	async->args.field_qualify_OamTsSystemHeader_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_type_t oam_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamType.unit = unit;
	async->args.field_qualify_OamType.entry = entry;
	async->args.field_qualify_OamType.oam_type = oam_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_oam_type_t * oam_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamType_get.unit = unit;
	async->args.field_qualify_OamType_get.entry = entry;
	async->args.field_qualify_OamType_get.oam_type = oam_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamUpMep_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMUPMEP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamUpMep.unit = unit;
	async->args.field_qualify_OamUpMep.entry = entry;
	async->args.field_qualify_OamUpMep.data = data;
	async->args.field_qualify_OamUpMep.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OamUpMep_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OAMUPMEP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OamUpMep_get.unit = unit;
	async->args.field_qualify_OamUpMep_get.entry = entry;
	async->args.field_qualify_OamUpMep_get.data = data;
	async->args.field_qualify_OamUpMep_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_port_t data,
	bcm_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPort.unit = unit;
	async->args.field_qualify_OutPort.entry = entry;
	async->args.field_qualify_OutPort.data = data;
	async->args.field_qualify_OutPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_port_t * data,
	bcm_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPort_get.unit = unit;
	async->args.field_qualify_OutPort_get.entry = entry;
	async->args.field_qualify_OutPort_get.data = data;
	async->args.field_qualify_OutPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutPorts_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPorts.unit = unit;
	async->args.field_qualify_OutPorts.entry = entry;
	async->args.field_qualify_OutPorts.data = data;
	async->args.field_qualify_OutPorts.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutPorts_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPorts_get.unit = unit;
	async->args.field_qualify_OutPorts_get.entry = entry;
	async->args.field_qualify_OutPorts_get.data = data;
	async->args.field_qualify_OutPorts_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutVPort_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTVPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutVPort.unit = unit;
	async->args.field_qualify_OutVPort.entry = entry;
	async->args.field_qualify_OutVPort.data = data;
	async->args.field_qualify_OutVPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutVPort32_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTVPORT32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutVPort32.unit = unit;
	async->args.field_qualify_OutVPort32.entry = entry;
	async->args.field_qualify_OutVPort32.data = data;
	async->args.field_qualify_OutVPort32.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutVPort32_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTVPORT32_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutVPort32_get.unit = unit;
	async->args.field_qualify_OutVPort32_get.entry = entry;
	async->args.field_qualify_OutVPort32_get.data = data;
	async->args.field_qualify_OutVPort32_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OutVPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTVPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutVPort_get.unit = unit;
	async->args.field_qualify_OutVPort_get.entry = entry;
	async->args.field_qualify_OutVPort_get.data = data;
	async->args.field_qualify_OutVPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterTpid_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterTpid.unit = unit;
	async->args.field_qualify_OuterTpid.entry = entry;
	async->args.field_qualify_OuterTpid.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterTpid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterTpid_get.unit = unit;
	async->args.field_qualify_OuterTpid_get.entry = entry;
	async->args.field_qualify_OuterTpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlan.unit = unit;
	async->args.field_qualify_OuterVlan.entry = entry;
	async->args.field_qualify_OuterVlan.data = data;
	async->args.field_qualify_OuterVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanActionRange_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANACTIONRANGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanActionRange.unit = unit;
	async->args.field_qualify_OuterVlanActionRange.entry = entry;
	async->args.field_qualify_OuterVlanActionRange.data = data;
	async->args.field_qualify_OuterVlanActionRange.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanActionRange_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANACTIONRANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanActionRange_get.unit = unit;
	async->args.field_qualify_OuterVlanActionRange_get.entry = entry;
	async->args.field_qualify_OuterVlanActionRange_get.data = data;
	async->args.field_qualify_OuterVlanActionRange_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanCfi.unit = unit;
	async->args.field_qualify_OuterVlanCfi.entry = entry;
	async->args.field_qualify_OuterVlanCfi.data = data;
	async->args.field_qualify_OuterVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanCfi_get.unit = unit;
	async->args.field_qualify_OuterVlanCfi_get.entry = entry;
	async->args.field_qualify_OuterVlanCfi_get.data = data;
	async->args.field_qualify_OuterVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanId.unit = unit;
	async->args.field_qualify_OuterVlanId.entry = entry;
	async->args.field_qualify_OuterVlanId.data = data;
	async->args.field_qualify_OuterVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanId_get.unit = unit;
	async->args.field_qualify_OuterVlanId_get.entry = entry;
	async->args.field_qualify_OuterVlanId_get.data = data;
	async->args.field_qualify_OuterVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPri.unit = unit;
	async->args.field_qualify_OuterVlanPri.entry = entry;
	async->args.field_qualify_OuterVlanPri.data = data;
	async->args.field_qualify_OuterVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanPriCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRICFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPriCfi.unit = unit;
	async->args.field_qualify_OuterVlanPriCfi.entry = entry;
	async->args.field_qualify_OuterVlanPriCfi.data = data;
	async->args.field_qualify_OuterVlanPriCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanPriCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRICFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPriCfi_get.unit = unit;
	async->args.field_qualify_OuterVlanPriCfi_get.entry = entry;
	async->args.field_qualify_OuterVlanPriCfi_get.data = data;
	async->args.field_qualify_OuterVlanPriCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPri_get.unit = unit;
	async->args.field_qualify_OuterVlanPri_get.entry = entry;
	async->args.field_qualify_OuterVlanPri_get.data = data;
	async->args.field_qualify_OuterVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_OuterVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlan_get.unit = unit;
	async->args.field_qualify_OuterVlan_get.entry = entry;
	async->args.field_qualify_OuterVlan_get.data = data;
	async->args.field_qualify_OuterVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketLength_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETLENGTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketLength.unit = unit;
	async->args.field_qualify_PacketLength.entry = entry;
	async->args.field_qualify_PacketLength.data = data;
	async->args.field_qualify_PacketLength.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketLengthRangeCheck_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_range_t range,
	int invert,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETLENGTHRANGECHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketLengthRangeCheck.unit = unit;
	async->args.field_qualify_PacketLengthRangeCheck.entry = entry;
	async->args.field_qualify_PacketLengthRangeCheck.range = range;
	async->args.field_qualify_PacketLengthRangeCheck.invert = invert;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketLengthRangeCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	int max_count,
	bcm_field_range_t * range,
	int * invert,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETLENGTHRANGECHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketLengthRangeCheck_get.unit = unit;
	async->args.field_qualify_PacketLengthRangeCheck_get.entry = entry;
	async->args.field_qualify_PacketLengthRangeCheck_get.max_count = max_count;
	async->args.field_qualify_PacketLengthRangeCheck_get.range = range;
	async->args.field_qualify_PacketLengthRangeCheck_get.invert = invert;
	async->args.field_qualify_PacketLengthRangeCheck_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketLength_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETLENGTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketLength_get.unit = unit;
	async->args.field_qualify_PacketLength_get.entry = entry;
	async->args.field_qualify_PacketLength_get.data = data;
	async->args.field_qualify_PacketLength_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketRes_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketRes.unit = unit;
	async->args.field_qualify_PacketRes.entry = entry;
	async->args.field_qualify_PacketRes.data = data;
	async->args.field_qualify_PacketRes.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketRes_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketRes_get.unit = unit;
	async->args.field_qualify_PacketRes_get.entry = entry;
	async->args.field_qualify_PacketRes_get.data = data;
	async->args.field_qualify_PacketRes_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketSize_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETSIZE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketSize.unit = unit;
	async->args.field_qualify_PacketSize.entry = entry;
	async->args.field_qualify_PacketSize.data = data;
	async->args.field_qualify_PacketSize.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketSize_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETSIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketSize_get.unit = unit;
	async->args.field_qualify_PacketSize_get.entry = entry;
	async->args.field_qualify_PacketSize_get.data = data;
	async->args.field_qualify_PacketSize_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketTerminatedBytes_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETTERMINATEDBYTES;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketTerminatedBytes.unit = unit;
	async->args.field_qualify_PacketTerminatedBytes.entry = entry;
	async->args.field_qualify_PacketTerminatedBytes.data = data;
	async->args.field_qualify_PacketTerminatedBytes.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PacketTerminatedBytes_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETTERMINATEDBYTES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketTerminatedBytes_get.unit = unit;
	async->args.field_qualify_PacketTerminatedBytes_get.entry = entry;
	async->args.field_qualify_PacketTerminatedBytes_get.data = data;
	async->args.field_qualify_PacketTerminatedBytes_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PktIsVisible_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PKTISVISIBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PktIsVisible.unit = unit;
	async->args.field_qualify_PktIsVisible.entry = entry;
	async->args.field_qualify_PktIsVisible.data = data;
	async->args.field_qualify_PktIsVisible.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PktIsVisible_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PKTISVISIBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PktIsVisible_get.unit = unit;
	async->args.field_qualify_PktIsVisible_get.entry = entry;
	async->args.field_qualify_PktIsVisible_get.data = data;
	async->args.field_qualify_PktIsVisible_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PolicerIntPrio_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_POLICERINTPRIO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PolicerIntPrio.unit = unit;
	async->args.field_qualify_PolicerIntPrio.entry = entry;
	async->args.field_qualify_PolicerIntPrio.data = data;
	async->args.field_qualify_PolicerIntPrio.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PolicerIntPrio_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_POLICERINTPRIO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PolicerIntPrio_get.unit = unit;
	async->args.field_qualify_PolicerIntPrio_get.entry = entry;
	async->args.field_qualify_PolicerIntPrio_get.data = data;
	async->args.field_qualify_PolicerIntPrio_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PortOrientation_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PORTORIENTATION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PortOrientation.unit = unit;
	async->args.field_qualify_PortOrientation.entry = entry;
	async->args.field_qualify_PortOrientation.data = data;
	async->args.field_qualify_PortOrientation.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PortOrientation_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PORTORIENTATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PortOrientation_get.unit = unit;
	async->args.field_qualify_PortOrientation_get.entry = entry;
	async->args.field_qualify_PortOrientation_get.data = data;
	async->args.field_qualify_PortOrientation_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PreemptablePacket_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PREEMPTABLEPACKET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PreemptablePacket.unit = unit;
	async->args.field_qualify_PreemptablePacket.entry = entry;
	async->args.field_qualify_PreemptablePacket.data = data;
	async->args.field_qualify_PreemptablePacket.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PreemptablePacket_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PREEMPTABLEPACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PreemptablePacket_get.unit = unit;
	async->args.field_qualify_PreemptablePacket_get.entry = entry;
	async->args.field_qualify_PreemptablePacket_get.data = data;
	async->args.field_qualify_PreemptablePacket_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PreselId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PRESELID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PreselId.unit = unit;
	async->args.field_qualify_PreselId.entry = entry;
	async->args.field_qualify_PreselId.data = data;
	async->args.field_qualify_PreselId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_PreselId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PRESELID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PreselId_get.unit = unit;
	async->args.field_qualify_PreselId_get.entry = entry;
	async->args.field_qualify_PreselId_get.data = data;
	async->args.field_qualify_PreselId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ptch_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PTCH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ptch.unit = unit;
	async->args.field_qualify_Ptch.entry = entry;
	async->args.field_qualify_Ptch.data = data;
	async->args.field_qualify_Ptch.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ptch_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_PTCH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ptch_get.unit = unit;
	async->args.field_qualify_Ptch_get.entry = entry;
	async->args.field_qualify_Ptch_get.data = data;
	async->args.field_qualify_Ptch_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RangeCheck_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_range_t range,
	int invert,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RangeCheck.unit = unit;
	async->args.field_qualify_RangeCheck.entry = entry;
	async->args.field_qualify_RangeCheck.range = range;
	async->args.field_qualify_RangeCheck.invert = invert;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RangeCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	int max_count,
	bcm_field_range_t * range,
	int * invert,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RangeCheck_get.unit = unit;
	async->args.field_qualify_RangeCheck_get.entry = entry;
	async->args.field_qualify_RangeCheck_get.max_count = max_count;
	async->args.field_qualify_RangeCheck_get.range = range;
	async->args.field_qualify_RangeCheck_get.invert = invert;
	async->args.field_qualify_RangeCheck_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RecoverableDrop_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RECOVERABLEDROP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RecoverableDrop.unit = unit;
	async->args.field_qualify_RecoverableDrop.entry = entry;
	async->args.field_qualify_RecoverableDrop.data = data;
	async->args.field_qualify_RecoverableDrop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RecoverableDrop_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RECOVERABLEDROP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RecoverableDrop_get.unit = unit;
	async->args.field_qualify_RecoverableDrop_get.entry = entry;
	async->args.field_qualify_RecoverableDrop_get.data = data;
	async->args.field_qualify_RecoverableDrop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RepCopy_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPCOPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RepCopy.unit = unit;
	async->args.field_qualify_RepCopy.entry = entry;
	async->args.field_qualify_RepCopy.data = data;
	async->args.field_qualify_RepCopy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RepCopy_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPCOPY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RepCopy_get.unit = unit;
	async->args.field_qualify_RepCopy_get.entry = entry;
	async->args.field_qualify_RepCopy_get.data = data;
	async->args.field_qualify_RepCopy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ReplicantAny_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPLICANTANY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ReplicantAny.unit = unit;
	async->args.field_qualify_ReplicantAny.entry = entry;
	async->args.field_qualify_ReplicantAny.data = data;
	async->args.field_qualify_ReplicantAny.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ReplicantAny_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPLICANTANY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ReplicantAny_get.unit = unit;
	async->args.field_qualify_ReplicantAny_get.entry = entry;
	async->args.field_qualify_ReplicantAny_get.data = data;
	async->args.field_qualify_ReplicantAny_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ReplicantFirst_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPLICANTFIRST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ReplicantFirst.unit = unit;
	async->args.field_qualify_ReplicantFirst.entry = entry;
	async->args.field_qualify_ReplicantFirst.data = data;
	async->args.field_qualify_ReplicantFirst.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_ReplicantFirst_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_REPLICANTFIRST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ReplicantFirst_get.unit = unit;
	async->args.field_qualify_ReplicantFirst_get.entry = entry;
	async->args.field_qualify_ReplicantFirst_get.data = data;
	async->args.field_qualify_ReplicantFirst_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthDstQueuePair_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHDSTQUEUEPAIR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthDstQueuePair.unit = unit;
	async->args.field_qualify_RoceBthDstQueuePair.entry = entry;
	async->args.field_qualify_RoceBthDstQueuePair.data = data;
	async->args.field_qualify_RoceBthDstQueuePair.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthDstQueuePair_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHDSTQUEUEPAIR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthDstQueuePair_get.unit = unit;
	async->args.field_qualify_RoceBthDstQueuePair_get.entry = entry;
	async->args.field_qualify_RoceBthDstQueuePair_get.data = data;
	async->args.field_qualify_RoceBthDstQueuePair_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthFlags.unit = unit;
	async->args.field_qualify_RoceBthFlags.entry = entry;
	async->args.field_qualify_RoceBthFlags.data = data;
	async->args.field_qualify_RoceBthFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthFlags_get.unit = unit;
	async->args.field_qualify_RoceBthFlags_get.entry = entry;
	async->args.field_qualify_RoceBthFlags_get.data = data;
	async->args.field_qualify_RoceBthFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthOpcode_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHOPCODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthOpcode.unit = unit;
	async->args.field_qualify_RoceBthOpcode.entry = entry;
	async->args.field_qualify_RoceBthOpcode.data = data;
	async->args.field_qualify_RoceBthOpcode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthOpcode_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHOPCODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthOpcode_get.unit = unit;
	async->args.field_qualify_RoceBthOpcode_get.entry = entry;
	async->args.field_qualify_RoceBthOpcode_get.data = data;
	async->args.field_qualify_RoceBthOpcode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthPartitionKey_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHPARTITIONKEY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthPartitionKey.unit = unit;
	async->args.field_qualify_RoceBthPartitionKey.entry = entry;
	async->args.field_qualify_RoceBthPartitionKey.data = data;
	async->args.field_qualify_RoceBthPartitionKey.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceBthPartitionKey_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEBTHPARTITIONKEY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceBthPartitionKey_get.unit = unit;
	async->args.field_qualify_RoceBthPartitionKey_get.entry = entry;
	async->args.field_qualify_RoceBthPartitionKey_get.data = data;
	async->args.field_qualify_RoceBthPartitionKey_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceVer1Pkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEVER1PKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceVer1Pkt.unit = unit;
	async->args.field_qualify_RoceVer1Pkt.entry = entry;
	async->args.field_qualify_RoceVer1Pkt.data = data;
	async->args.field_qualify_RoceVer1Pkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceVer1Pkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEVER1PKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceVer1Pkt_get.unit = unit;
	async->args.field_qualify_RoceVer1Pkt_get.entry = entry;
	async->args.field_qualify_RoceVer1Pkt_get.data = data;
	async->args.field_qualify_RoceVer1Pkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceVer2Pkt_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEVER2PKT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceVer2Pkt.unit = unit;
	async->args.field_qualify_RoceVer2Pkt.entry = entry;
	async->args.field_qualify_RoceVer2Pkt.data = data;
	async->args.field_qualify_RoceVer2Pkt.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RoceVer2Pkt_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROCEVER2PKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RoceVer2Pkt_get.unit = unit;
	async->args.field_qualify_RoceVer2Pkt_get.entry = entry;
	async->args.field_qualify_RoceVer2Pkt_get.data = data;
	async->args.field_qualify_RoceVer2Pkt_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RouterAlertLabelValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROUTERALERTLABELVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RouterAlertLabelValid.unit = unit;
	async->args.field_qualify_RouterAlertLabelValid.entry = entry;
	async->args.field_qualify_RouterAlertLabelValid.data = data;
	async->args.field_qualify_RouterAlertLabelValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RouterAlertLabelValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_ROUTERALERTLABELVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RouterAlertLabelValid_get.unit = unit;
	async->args.field_qualify_RouterAlertLabelValid_get.entry = entry;
	async->args.field_qualify_RouterAlertLabelValid_get.data = data;
	async->args.field_qualify_RouterAlertLabelValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7AHashLower_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7AHASHLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7AHashLower.unit = unit;
	async->args.field_qualify_Rtag7AHashLower.entry = entry;
	async->args.field_qualify_Rtag7AHashLower.data = data;
	async->args.field_qualify_Rtag7AHashLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7AHashLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7AHASHLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7AHashLower_get.unit = unit;
	async->args.field_qualify_Rtag7AHashLower_get.entry = entry;
	async->args.field_qualify_Rtag7AHashLower_get.data = data;
	async->args.field_qualify_Rtag7AHashLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7AHashUpper_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7AHASHUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7AHashUpper.unit = unit;
	async->args.field_qualify_Rtag7AHashUpper.entry = entry;
	async->args.field_qualify_Rtag7AHashUpper.data = data;
	async->args.field_qualify_Rtag7AHashUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7AHashUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7AHASHUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7AHashUpper_get.unit = unit;
	async->args.field_qualify_Rtag7AHashUpper_get.entry = entry;
	async->args.field_qualify_Rtag7AHashUpper_get.data = data;
	async->args.field_qualify_Rtag7AHashUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7BHashLower_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7BHASHLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7BHashLower.unit = unit;
	async->args.field_qualify_Rtag7BHashLower.entry = entry;
	async->args.field_qualify_Rtag7BHashLower.data = data;
	async->args.field_qualify_Rtag7BHashLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7BHashLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7BHASHLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7BHashLower_get.unit = unit;
	async->args.field_qualify_Rtag7BHashLower_get.entry = entry;
	async->args.field_qualify_Rtag7BHashLower_get.data = data;
	async->args.field_qualify_Rtag7BHashLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7BHashUpper_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7BHASHUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7BHashUpper.unit = unit;
	async->args.field_qualify_Rtag7BHashUpper.entry = entry;
	async->args.field_qualify_Rtag7BHashUpper.data = data;
	async->args.field_qualify_Rtag7BHashUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Rtag7BHashUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RTAG7BHASHUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Rtag7BHashUpper_get.unit = unit;
	async->args.field_qualify_Rtag7BHashUpper_get.entry = entry;
	async->args.field_qualify_Rtag7BHashUpper_get.data = data;
	async->args.field_qualify_Rtag7BHashUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCode_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_rx_trap_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCode.unit = unit;
	async->args.field_qualify_RxTrapCode.entry = entry;
	async->args.field_qualify_RxTrapCode.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCode32_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODE32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCode32.unit = unit;
	async->args.field_qualify_RxTrapCode32.entry = entry;
	async->args.field_qualify_RxTrapCode32.data = data;
	async->args.field_qualify_RxTrapCode32.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCode32_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODE32_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCode32_get.unit = unit;
	async->args.field_qualify_RxTrapCode32_get.entry = entry;
	async->args.field_qualify_RxTrapCode32_get.data = data;
	async->args.field_qualify_RxTrapCode32_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCodeForSnoop_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODEFORSNOOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCodeForSnoop.unit = unit;
	async->args.field_qualify_RxTrapCodeForSnoop.entry = entry;
	async->args.field_qualify_RxTrapCodeForSnoop.data = data;
	async->args.field_qualify_RxTrapCodeForSnoop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCodeForSnoop_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODEFORSNOOP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCodeForSnoop_get.unit = unit;
	async->args.field_qualify_RxTrapCodeForSnoop_get.entry = entry;
	async->args.field_qualify_RxTrapCodeForSnoop_get.data = data;
	async->args.field_qualify_RxTrapCodeForSnoop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapCode_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_rx_trap_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPCODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapCode_get.unit = unit;
	async->args.field_qualify_RxTrapCode_get.entry = entry;
	async->args.field_qualify_RxTrapCode_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapData_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPDATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapData.unit = unit;
	async->args.field_qualify_RxTrapData.entry = entry;
	async->args.field_qualify_RxTrapData.data = data;
	async->args.field_qualify_RxTrapData.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapData_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPDATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapData_get.unit = unit;
	async->args.field_qualify_RxTrapData_get.entry = entry;
	async->args.field_qualify_RxTrapData_get.data = data;
	async->args.field_qualify_RxTrapData_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapStrength_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPSTRENGTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapStrength.unit = unit;
	async->args.field_qualify_RxTrapStrength.entry = entry;
	async->args.field_qualify_RxTrapStrength.data = data;
	async->args.field_qualify_RxTrapStrength.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_RxTrapStrength_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_RXTRAPSTRENGTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RxTrapStrength_get.unit = unit;
	async->args.field_qualify_RxTrapStrength_get.entry = entry;
	async->args.field_qualify_RxTrapStrength_get.data = data;
	async->args.field_qualify_RxTrapStrength_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRDuplicate_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRDUPLICATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRDuplicate.unit = unit;
	async->args.field_qualify_SRDuplicate.entry = entry;
	async->args.field_qualify_SRDuplicate.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRDuplicate_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRDUPLICATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRDuplicate_get.unit = unit;
	async->args.field_qualify_SRDuplicate_get.entry = entry;
	async->args.field_qualify_SRDuplicate_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRError_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRERROR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRError.unit = unit;
	async->args.field_qualify_SRError.entry = entry;
	async->args.field_qualify_SRError.data = data;
	async->args.field_qualify_SRError.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRError_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRERROR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRError_get.unit = unit;
	async->args.field_qualify_SRError_get.entry = entry;
	async->args.field_qualify_SRError_get.data = data;
	async->args.field_qualify_SRError_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRFlowId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRFLOWID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRFlowId.unit = unit;
	async->args.field_qualify_SRFlowId.entry = entry;
	async->args.field_qualify_SRFlowId.data = data;
	async->args.field_qualify_SRFlowId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRFlowId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRFLOWID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRFlowId_get.unit = unit;
	async->args.field_qualify_SRFlowId_get.entry = entry;
	async->args.field_qualify_SRFlowId_get.data = data;
	async->args.field_qualify_SRFlowId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRLanId_async(
	int unit,
	bcm_field_entry_t entry,
	int lan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRLanId.unit = unit;
	async->args.field_qualify_SRLanId.entry = entry;
	async->args.field_qualify_SRLanId.lan_id = lan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRLanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * lan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRLanId_get.unit = unit;
	async->args.field_qualify_SRLanId_get.entry = entry;
	async->args.field_qualify_SRLanId_get.lan_id = lan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRNetId_async(
	int unit,
	bcm_field_entry_t entry,
	int net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRNETID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRNetId.unit = unit;
	async->args.field_qualify_SRNetId.entry = entry;
	async->args.field_qualify_SRNetId.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRNetIdMatched_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRNETIDMATCHED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRNetIdMatched.unit = unit;
	async->args.field_qualify_SRNetIdMatched.entry = entry;
	async->args.field_qualify_SRNetIdMatched.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRNetIdMatched_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRNETIDMATCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRNetIdMatched_get.unit = unit;
	async->args.field_qualify_SRNetIdMatched_get.entry = entry;
	async->args.field_qualify_SRNetIdMatched_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRNetId_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRNETID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRNetId_get.unit = unit;
	async->args.field_qualify_SRNetId_get.entry = entry;
	async->args.field_qualify_SRNetId_get.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRSrcNodeIsSan_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRSRCNODEISSAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRSrcNodeIsSan.unit = unit;
	async->args.field_qualify_SRSrcNodeIsSan.entry = entry;
	async->args.field_qualify_SRSrcNodeIsSan.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRSrcNodeIsSan_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRSRCNODEISSAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRSrcNodeIsSan_get.unit = unit;
	async->args.field_qualify_SRSrcNodeIsSan_get.entry = entry;
	async->args.field_qualify_SRSrcNodeIsSan_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRSupervisionType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_supervision_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRSUPERVISIONTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRSupervisionType.unit = unit;
	async->args.field_qualify_SRSupervisionType.entry = entry;
	async->args.field_qualify_SRSupervisionType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRSupervisionType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_supervision_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRSUPERVISIONTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRSupervisionType_get.unit = unit;
	async->args.field_qualify_SRSupervisionType_get.entry = entry;
	async->args.field_qualify_SRSupervisionType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRTagType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_tag_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRTAGTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRTagType.unit = unit;
	async->args.field_qualify_SRTagType.entry = entry;
	async->args.field_qualify_SRTagType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SRTagType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_tag_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRTAGTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SRTagType_get.unit = unit;
	async->args.field_qualify_SRTagType_get.entry = entry;
	async->args.field_qualify_SRTagType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Snap_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_snap_header_t data,
	bcm_field_snap_header_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Snap.unit = unit;
	async->args.field_qualify_Snap.entry = entry;
	async->args.field_qualify_Snap.data = data;
	async->args.field_qualify_Snap.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Snap_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_snap_header_t * data,
	bcm_field_snap_header_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Snap_get.unit = unit;
	async->args.field_qualify_Snap_get.entry = entry;
	async->args.field_qualify_Snap_get.data = data;
	async->args.field_qualify_Snap_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SnoopCopy_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNOOPCOPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SnoopCopy.unit = unit;
	async->args.field_qualify_SnoopCopy.entry = entry;
	async->args.field_qualify_SnoopCopy.data = data;
	async->args.field_qualify_SnoopCopy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SnoopCopy_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNOOPCOPY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SnoopCopy_get.unit = unit;
	async->args.field_qualify_SnoopCopy_get.entry = entry;
	async->args.field_qualify_SnoopCopy_get.data = data;
	async->args.field_qualify_SnoopCopy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SourceGportBitmap_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SOURCEGPORTBITMAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SourceGportBitmap.unit = unit;
	async->args.field_qualify_SourceGportBitmap.entry = entry;
	async->args.field_qualify_SourceGportBitmap.data = data;
	async->args.field_qualify_SourceGportBitmap.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SourceGportBitmap_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SOURCEGPORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SourceGportBitmap_get.unit = unit;
	async->args.field_qualify_SourceGportBitmap_get.entry = entry;
	async->args.field_qualify_SourceGportBitmap_get.data = data;
	async->args.field_qualify_SourceGportBitmap_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassField_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassField.unit = unit;
	async->args.field_qualify_SrcClassField.entry = entry;
	async->args.field_qualify_SrcClassField.data = data;
	async->args.field_qualify_SrcClassField.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassField_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassField_get.unit = unit;
	async->args.field_qualify_SrcClassField_get.entry = entry;
	async->args.field_qualify_SrcClassField_get.data = data;
	async->args.field_qualify_SrcClassField_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassL2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL2.unit = unit;
	async->args.field_qualify_SrcClassL2.entry = entry;
	async->args.field_qualify_SrcClassL2.data = data;
	async->args.field_qualify_SrcClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassL2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL2_get.unit = unit;
	async->args.field_qualify_SrcClassL2_get.entry = entry;
	async->args.field_qualify_SrcClassL2_get.data = data;
	async->args.field_qualify_SrcClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassL3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL3.unit = unit;
	async->args.field_qualify_SrcClassL3.entry = entry;
	async->args.field_qualify_SrcClassL3.data = data;
	async->args.field_qualify_SrcClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcClassL3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL3_get.unit = unit;
	async->args.field_qualify_SrcClassL3_get.entry = entry;
	async->args.field_qualify_SrcClassL3_get.data = data;
	async->args.field_qualify_SrcClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcGport.unit = unit;
	async->args.field_qualify_SrcGport.entry = entry;
	async->args.field_qualify_SrcGport.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcGport_get.unit = unit;
	async->args.field_qualify_SrcGport_get.entry = entry;
	async->args.field_qualify_SrcGport_get.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcGports.unit = unit;
	async->args.field_qualify_SrcGports.entry = entry;
	async->args.field_qualify_SrcGports.port_id = port_id;
	async->args.field_qualify_SrcGports.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcGports_get.unit = unit;
	async->args.field_qualify_SrcGports_get.entry = entry;
	async->args.field_qualify_SrcGports_get.port_id = port_id;
	async->args.field_qualify_SrcGports_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp.unit = unit;
	async->args.field_qualify_SrcIp.entry = entry;
	async->args.field_qualify_SrcIp.data = data;
	async->args.field_qualify_SrcIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6.unit = unit;
	async->args.field_qualify_SrcIp6.entry = entry;
	async->args.field_qualify_SrcIp6.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6Class_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Class.unit = unit;
	async->args.field_qualify_SrcIp6Class.entry = entry;
	async->args.field_qualify_SrcIp6Class.data = data;
	async->args.field_qualify_SrcIp6Class.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassLower.unit = unit;
	async->args.field_qualify_SrcIp6ClassLower.entry = entry;
	async->args.field_qualify_SrcIp6ClassLower.data = data;
	async->args.field_qualify_SrcIp6ClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassLower_get.unit = unit;
	async->args.field_qualify_SrcIp6ClassLower_get.entry = entry;
	async->args.field_qualify_SrcIp6ClassLower_get.data = data;
	async->args.field_qualify_SrcIp6ClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassMsbNibble.unit = unit;
	async->args.field_qualify_SrcIp6ClassMsbNibble.entry = entry;
	async->args.field_qualify_SrcIp6ClassMsbNibble.data = data;
	async->args.field_qualify_SrcIp6ClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassMsbNibble_get.unit = unit;
	async->args.field_qualify_SrcIp6ClassMsbNibble_get.entry = entry;
	async->args.field_qualify_SrcIp6ClassMsbNibble_get.data = data;
	async->args.field_qualify_SrcIp6ClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassUpper.unit = unit;
	async->args.field_qualify_SrcIp6ClassUpper.entry = entry;
	async->args.field_qualify_SrcIp6ClassUpper.data = data;
	async->args.field_qualify_SrcIp6ClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6ClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6ClassUpper_get.unit = unit;
	async->args.field_qualify_SrcIp6ClassUpper_get.entry = entry;
	async->args.field_qualify_SrcIp6ClassUpper_get.data = data;
	async->args.field_qualify_SrcIp6ClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6Class_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Class_get.unit = unit;
	async->args.field_qualify_SrcIp6Class_get.entry = entry;
	async->args.field_qualify_SrcIp6Class_get.data = data;
	async->args.field_qualify_SrcIp6Class_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6High_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6High.unit = unit;
	async->args.field_qualify_SrcIp6High.entry = entry;
	async->args.field_qualify_SrcIp6High.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6High_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6High_get.unit = unit;
	async->args.field_qualify_SrcIp6High_get.entry = entry;
	async->args.field_qualify_SrcIp6High_get.data = data;
	async->args.field_qualify_SrcIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6Low_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6LOW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Low.unit = unit;
	async->args.field_qualify_SrcIp6Low.entry = entry;
	async->args.field_qualify_SrcIp6Low.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6Low.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6Low_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6LOW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Low_get.unit = unit;
	async->args.field_qualify_SrcIp6Low_get.entry = entry;
	async->args.field_qualify_SrcIp6Low_get.data = data;
	async->args.field_qualify_SrcIp6Low_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6_get.unit = unit;
	async->args.field_qualify_SrcIp6_get.entry = entry;
	async->args.field_qualify_SrcIp6_get.data = data;
	async->args.field_qualify_SrcIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClass_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClass.unit = unit;
	async->args.field_qualify_SrcIpClass.entry = entry;
	async->args.field_qualify_SrcIpClass.data = data;
	async->args.field_qualify_SrcIpClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassLower_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSLOWER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassLower.unit = unit;
	async->args.field_qualify_SrcIpClassLower.entry = entry;
	async->args.field_qualify_SrcIpClassLower.data = data;
	async->args.field_qualify_SrcIpClassLower.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassLower_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSLOWER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassLower_get.unit = unit;
	async->args.field_qualify_SrcIpClassLower_get.entry = entry;
	async->args.field_qualify_SrcIpClassLower_get.data = data;
	async->args.field_qualify_SrcIpClassLower_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassMsbNibble_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSMSBNIBBLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassMsbNibble.unit = unit;
	async->args.field_qualify_SrcIpClassMsbNibble.entry = entry;
	async->args.field_qualify_SrcIpClassMsbNibble.data = data;
	async->args.field_qualify_SrcIpClassMsbNibble.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassMsbNibble_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSMSBNIBBLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassMsbNibble_get.unit = unit;
	async->args.field_qualify_SrcIpClassMsbNibble_get.entry = entry;
	async->args.field_qualify_SrcIpClassMsbNibble_get.data = data;
	async->args.field_qualify_SrcIpClassMsbNibble_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassUpper_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSUPPER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassUpper.unit = unit;
	async->args.field_qualify_SrcIpClassUpper.entry = entry;
	async->args.field_qualify_SrcIpClassUpper.data = data;
	async->args.field_qualify_SrcIpClassUpper.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClassUpper_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASSUPPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClassUpper_get.unit = unit;
	async->args.field_qualify_SrcIpClassUpper_get.entry = entry;
	async->args.field_qualify_SrcIpClassUpper_get.data = data;
	async->args.field_qualify_SrcIpClassUpper_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpClass_get.unit = unit;
	async->args.field_qualify_SrcIpClass_get.entry = entry;
	async->args.field_qualify_SrcIpClass_get.data = data;
	async->args.field_qualify_SrcIpClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpEqualDstIp_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPEQUALDSTIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpEqualDstIp.unit = unit;
	async->args.field_qualify_SrcIpEqualDstIp.entry = entry;
	async->args.field_qualify_SrcIpEqualDstIp.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIpEqualDstIp_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPEQUALDSTIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIpEqualDstIp_get.unit = unit;
	async->args.field_qualify_SrcIpEqualDstIp_get.entry = entry;
	async->args.field_qualify_SrcIpEqualDstIp_get.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcIp_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp_get.unit = unit;
	async->args.field_qualify_SrcIp_get.entry = entry;
	async->args.field_qualify_SrcIp_get.data = data;
	async->args.field_qualify_SrcIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMac.unit = unit;
	async->args.field_qualify_SrcMac.entry = entry;
	async->args.field_qualify_SrcMac.data = (uint8 *)data;
	async->args.field_qualify_SrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMac_get.unit = unit;
	async->args.field_qualify_SrcMac_get.entry = entry;
	async->args.field_qualify_SrcMac_get.data = data;
	async->args.field_qualify_SrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMimGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGport.unit = unit;
	async->args.field_qualify_SrcMimGport.entry = entry;
	async->args.field_qualify_SrcMimGport.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMimGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGport_get.unit = unit;
	async->args.field_qualify_SrcMimGport_get.entry = entry;
	async->args.field_qualify_SrcMimGport_get.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMimGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcm_gport_t mim_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGports.unit = unit;
	async->args.field_qualify_SrcMimGports.entry = entry;
	async->args.field_qualify_SrcMimGports.mim_port_id = mim_port_id;
	async->args.field_qualify_SrcMimGports.mim_port_mask = mim_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMimGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcm_gport_t * mim_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGports_get.unit = unit;
	async->args.field_qualify_SrcMimGports_get.entry = entry;
	async->args.field_qualify_SrcMimGports_get.mim_port_id = mim_port_id;
	async->args.field_qualify_SrcMimGports_get.mim_port_mask = mim_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModPortGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGport.unit = unit;
	async->args.field_qualify_SrcModPortGport.entry = entry;
	async->args.field_qualify_SrcModPortGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModPortGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGport_get.unit = unit;
	async->args.field_qualify_SrcModPortGport_get.entry = entry;
	async->args.field_qualify_SrcModPortGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModPortGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_gport_t port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGports.unit = unit;
	async->args.field_qualify_SrcModPortGports.entry = entry;
	async->args.field_qualify_SrcModPortGports.port_id = port_id;
	async->args.field_qualify_SrcModPortGports.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModPortGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_gport_t * port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGports_get.unit = unit;
	async->args.field_qualify_SrcModPortGports_get.entry = entry;
	async->args.field_qualify_SrcModPortGports_get.port_id = port_id;
	async->args.field_qualify_SrcModPortGports_get.port_mask = port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModuleGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODULEGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModuleGport.unit = unit;
	async->args.field_qualify_SrcModuleGport.entry = entry;
	async->args.field_qualify_SrcModuleGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcModuleGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODULEGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModuleGport_get.unit = unit;
	async->args.field_qualify_SrcModuleGport_get.entry = entry;
	async->args.field_qualify_SrcModuleGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMplsGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGport.unit = unit;
	async->args.field_qualify_SrcMplsGport.entry = entry;
	async->args.field_qualify_SrcMplsGport.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMplsGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGport_get.unit = unit;
	async->args.field_qualify_SrcMplsGport_get.entry = entry;
	async->args.field_qualify_SrcMplsGport_get.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMplsGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcm_gport_t mpls_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGports.unit = unit;
	async->args.field_qualify_SrcMplsGports.entry = entry;
	async->args.field_qualify_SrcMplsGports.mpls_port_id = mpls_port_id;
	async->args.field_qualify_SrcMplsGports.mpls_port_mask = mpls_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcMplsGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcm_gport_t * mpls_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGports_get.unit = unit;
	async->args.field_qualify_SrcMplsGports_get.entry = entry;
	async->args.field_qualify_SrcMplsGports_get.mpls_port_id = mpls_port_id;
	async->args.field_qualify_SrcMplsGports_get.mpls_port_mask = mpls_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcNivGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t niv_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCNIVGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcNivGport.unit = unit;
	async->args.field_qualify_SrcNivGport.entry = entry;
	async->args.field_qualify_SrcNivGport.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcNivGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * niv_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCNIVGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcNivGport_get.unit = unit;
	async->args.field_qualify_SrcNivGport_get.entry = entry;
	async->args.field_qualify_SrcNivGport_get.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcNivGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t niv_port_id,
	bcm_gport_t niv_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCNIVGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcNivGports.unit = unit;
	async->args.field_qualify_SrcNivGports.entry = entry;
	async->args.field_qualify_SrcNivGports.niv_port_id = niv_port_id;
	async->args.field_qualify_SrcNivGports.niv_port_mask = niv_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcNivGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * niv_port_id,
	bcm_gport_t * niv_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCNIVGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcNivGports_get.unit = unit;
	async->args.field_qualify_SrcNivGports_get.entry = entry;
	async->args.field_qualify_SrcNivGports_get.niv_port_id = niv_port_id;
	async->args.field_qualify_SrcNivGports_get.niv_port_mask = niv_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_module_t data_modid,
	bcm_module_t mask_modid,
	bcm_port_t data_port,
	bcm_port_t mask_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPort.unit = unit;
	async->args.field_qualify_SrcPort.entry = entry;
	async->args.field_qualify_SrcPort.data_modid = data_modid;
	async->args.field_qualify_SrcPort.mask_modid = mask_modid;
	async->args.field_qualify_SrcPort.data_port = data_port;
	async->args.field_qualify_SrcPort.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRLanId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRLanId.unit = unit;
	async->args.field_qualify_SrcPortSRLanId.entry = entry;
	async->args.field_qualify_SrcPortSRLanId.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRLanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * net_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRLanId_get.unit = unit;
	async->args.field_qualify_SrcPortSRLanId_get.entry = entry;
	async->args.field_qualify_SrcPortSRLanId_get.net_id = net_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRMode_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_port_mode_t type,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRMODE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRMode.unit = unit;
	async->args.field_qualify_SrcPortSRMode.entry = entry;
	async->args.field_qualify_SrcPortSRMode.type = type;
	async->args.field_qualify_SrcPortSRMode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRMode_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_sr_port_mode_t * type,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRMODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRMode_get.unit = unit;
	async->args.field_qualify_SrcPortSRMode_get.entry = entry;
	async->args.field_qualify_SrcPortSRMode_get.type = type;
	async->args.field_qualify_SrcPortSRMode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRNetId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 net_id,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRNETID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRNetId.unit = unit;
	async->args.field_qualify_SrcPortSRNetId.entry = entry;
	async->args.field_qualify_SrcPortSRNetId.net_id = net_id;
	async->args.field_qualify_SrcPortSRNetId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRNetId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * net_id,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRNETID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRNetId_get.unit = unit;
	async->args.field_qualify_SrcPortSRNetId_get.entry = entry;
	async->args.field_qualify_SrcPortSRNetId_get.net_id = net_id;
	async->args.field_qualify_SrcPortSRNetId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRRoleInterlink_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRROLEINTERLINK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRRoleInterlink.unit = unit;
	async->args.field_qualify_SrcPortSRRoleInterlink.entry = entry;
	async->args.field_qualify_SrcPortSRRoleInterlink.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRRoleInterlink_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRROLEINTERLINK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRRoleInterlink_get.unit = unit;
	async->args.field_qualify_SrcPortSRRoleInterlink_get.entry = entry;
	async->args.field_qualify_SrcPortSRRoleInterlink_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_port_sr_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRType.unit = unit;
	async->args.field_qualify_SrcPortSRType.entry = entry;
	async->args.field_qualify_SrcPortSRType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPortSRType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_port_sr_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTSRTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPortSRType_get.unit = unit;
	async->args.field_qualify_SrcPortSRType_get.entry = entry;
	async->args.field_qualify_SrcPortSRType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_module_t * data_modid,
	bcm_module_t * mask_modid,
	bcm_port_t * data_port,
	bcm_port_t * mask_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPort_get.unit = unit;
	async->args.field_qualify_SrcPort_get.entry = entry;
	async->args.field_qualify_SrcPort_get.data_modid = data_modid;
	async->args.field_qualify_SrcPort_get.mask_modid = mask_modid;
	async->args.field_qualify_SrcPort_get.data_port = data_port;
	async->args.field_qualify_SrcPort_get.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcTrunk_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t data,
	bcm_trunk_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunk.unit = unit;
	async->args.field_qualify_SrcTrunk.entry = entry;
	async->args.field_qualify_SrcTrunk.data = data;
	async->args.field_qualify_SrcTrunk.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcTrunkMemberGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNKMEMBERGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunkMemberGport.unit = unit;
	async->args.field_qualify_SrcTrunkMemberGport.entry = entry;
	async->args.field_qualify_SrcTrunkMemberGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcTrunkMemberGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNKMEMBERGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunkMemberGport_get.unit = unit;
	async->args.field_qualify_SrcTrunkMemberGport_get.entry = entry;
	async->args.field_qualify_SrcTrunkMemberGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcTrunk_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_trunk_t * data,
	bcm_trunk_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunk_get.unit = unit;
	async->args.field_qualify_SrcTrunk_get.entry = entry;
	async->args.field_qualify_SrcTrunk_get.data = data;
	async->args.field_qualify_SrcTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVirtualPortValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVIRTUALPORTVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVirtualPortValid.unit = unit;
	async->args.field_qualify_SrcVirtualPortValid.entry = entry;
	async->args.field_qualify_SrcVirtualPortValid.data = data;
	async->args.field_qualify_SrcVirtualPortValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVirtualPortValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVIRTUALPORTVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVirtualPortValid_get.unit = unit;
	async->args.field_qualify_SrcVirtualPortValid_get.entry = entry;
	async->args.field_qualify_SrcVirtualPortValid_get.data = data;
	async->args.field_qualify_SrcVirtualPortValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVlanGport.unit = unit;
	async->args.field_qualify_SrcVlanGport.entry = entry;
	async->args.field_qualify_SrcVlanGport.vlan_port_id = vlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVlanGport_get.unit = unit;
	async->args.field_qualify_SrcVlanGport_get.entry = entry;
	async->args.field_qualify_SrcVlanGport_get.vlan_port_id = vlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vlan_port_id,
	bcm_gport_t vlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVlanGports.unit = unit;
	async->args.field_qualify_SrcVlanGports.entry = entry;
	async->args.field_qualify_SrcVlanGports.vlan_port_id = vlan_port_id;
	async->args.field_qualify_SrcVlanGports.vlan_port_mask = vlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vlan_port_id,
	bcm_gport_t * vlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVlanGports_get.unit = unit;
	async->args.field_qualify_SrcVlanGports_get.entry = entry;
	async->args.field_qualify_SrcVlanGports_get.vlan_port_id = vlan_port_id;
	async->args.field_qualify_SrcVlanGports_get.vlan_port_mask = vlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVxlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vxlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVXLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVxlanGport.unit = unit;
	async->args.field_qualify_SrcVxlanGport.entry = entry;
	async->args.field_qualify_SrcVxlanGport.vxlan_port_id = vxlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVxlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vxlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVXLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVxlanGport_get.unit = unit;
	async->args.field_qualify_SrcVxlanGport_get.entry = entry;
	async->args.field_qualify_SrcVxlanGport_get.vxlan_port_id = vxlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVxlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t vxlan_port_id,
	bcm_gport_t vxlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVXLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVxlanGports.unit = unit;
	async->args.field_qualify_SrcVxlanGports.entry = entry;
	async->args.field_qualify_SrcVxlanGports.vxlan_port_id = vxlan_port_id;
	async->args.field_qualify_SrcVxlanGports.vxlan_port_mask = vxlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcVxlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * vxlan_port_id,
	bcm_gport_t * vxlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCVXLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVxlanGports_get.unit = unit;
	async->args.field_qualify_SrcVxlanGports_get.entry = entry;
	async->args.field_qualify_SrcVxlanGports_get.vxlan_port_id = vxlan_port_id;
	async->args.field_qualify_SrcVxlanGports_get.vxlan_port_mask = vxlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcWlanGport_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGport.unit = unit;
	async->args.field_qualify_SrcWlanGport.entry = entry;
	async->args.field_qualify_SrcWlanGport.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcWlanGport_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGport_get.unit = unit;
	async->args.field_qualify_SrcWlanGport_get.entry = entry;
	async->args.field_qualify_SrcWlanGport_get.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcWlanGports_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcm_gport_t wlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORTS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGports.unit = unit;
	async->args.field_qualify_SrcWlanGports.entry = entry;
	async->args.field_qualify_SrcWlanGports.wlan_port_id = wlan_port_id;
	async->args.field_qualify_SrcWlanGports.wlan_port_mask = wlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SrcWlanGports_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcm_gport_t * wlan_port_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGports_get.unit = unit;
	async->args.field_qualify_SrcWlanGports_get.entry = entry;
	async->args.field_qualify_SrcWlanGports_get.wlan_port_id = wlan_port_id;
	async->args.field_qualify_SrcWlanGports_get.wlan_port_mask = wlan_port_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StackingRoute_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STACKINGROUTE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StackingRoute.unit = unit;
	async->args.field_qualify_StackingRoute.entry = entry;
	async->args.field_qualify_StackingRoute.data = data;
	async->args.field_qualify_StackingRoute.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StackingRoute_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STACKINGROUTE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StackingRoute_get.unit = unit;
	async->args.field_qualify_StackingRoute_get.entry = entry;
	async->args.field_qualify_StackingRoute_get.data = data;
	async->args.field_qualify_StackingRoute_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Stage_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_stage_t data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Stage.unit = unit;
	async->args.field_qualify_Stage.entry = entry;
	async->args.field_qualify_Stage.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Stage_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_stage_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Stage_get.unit = unit;
	async->args.field_qualify_Stage_get.entry = entry;
	async->args.field_qualify_Stage_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredDirectValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDDIRECTVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredDirectValue.unit = unit;
	async->args.field_qualify_StaggeredDirectValue.entry = entry;
	async->args.field_qualify_StaggeredDirectValue.data = data;
	async->args.field_qualify_StaggeredDirectValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredDirectValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDDIRECTVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredDirectValue_get.unit = unit;
	async->args.field_qualify_StaggeredDirectValue_get.entry = entry;
	async->args.field_qualify_StaggeredDirectValue_get.data = data;
	async->args.field_qualify_StaggeredDirectValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile0_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE0;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile0.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile0.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile0.data = data;
	async->args.field_qualify_StaggeredPreselProfile0.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile0_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE0_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile0_get.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile0_get.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile0_get.data = data;
	async->args.field_qualify_StaggeredPreselProfile0_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile1_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE1;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile1.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile1.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile1.data = data;
	async->args.field_qualify_StaggeredPreselProfile1.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile1_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile1_get.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile1_get.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile1_get.data = data;
	async->args.field_qualify_StaggeredPreselProfile1_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile2.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile2.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile2.data = data;
	async->args.field_qualify_StaggeredPreselProfile2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile2_get.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile2_get.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile2_get.data = data;
	async->args.field_qualify_StaggeredPreselProfile2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile3.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile3.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile3.data = data;
	async->args.field_qualify_StaggeredPreselProfile3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfile3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILE3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfile3_get.unit = unit;
	async->args.field_qualify_StaggeredPreselProfile3_get.entry = entry;
	async->args.field_qualify_StaggeredPreselProfile3_get.data = data;
	async->args.field_qualify_StaggeredPreselProfile3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfileDirect_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILEDIRECT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfileDirect.unit = unit;
	async->args.field_qualify_StaggeredPreselProfileDirect.entry = entry;
	async->args.field_qualify_StaggeredPreselProfileDirect.data = data;
	async->args.field_qualify_StaggeredPreselProfileDirect.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredPreselProfileDirect_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDPRESELPROFILEDIRECT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredPreselProfileDirect_get.unit = unit;
	async->args.field_qualify_StaggeredPreselProfileDirect_get.entry = entry;
	async->args.field_qualify_StaggeredPreselProfileDirect_get.data = data;
	async->args.field_qualify_StaggeredPreselProfileDirect_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue0_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE0;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue0.unit = unit;
	async->args.field_qualify_StaggeredValue0.entry = entry;
	async->args.field_qualify_StaggeredValue0.data = data;
	async->args.field_qualify_StaggeredValue0.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue0_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE0_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue0_get.unit = unit;
	async->args.field_qualify_StaggeredValue0_get.entry = entry;
	async->args.field_qualify_StaggeredValue0_get.data = data;
	async->args.field_qualify_StaggeredValue0_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue1_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE1;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue1.unit = unit;
	async->args.field_qualify_StaggeredValue1.entry = entry;
	async->args.field_qualify_StaggeredValue1.data = data;
	async->args.field_qualify_StaggeredValue1.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue1_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue1_get.unit = unit;
	async->args.field_qualify_StaggeredValue1_get.entry = entry;
	async->args.field_qualify_StaggeredValue1_get.data = data;
	async->args.field_qualify_StaggeredValue1_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue2_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE2;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue2.unit = unit;
	async->args.field_qualify_StaggeredValue2.entry = entry;
	async->args.field_qualify_StaggeredValue2.data = data;
	async->args.field_qualify_StaggeredValue2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue2_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue2_get.unit = unit;
	async->args.field_qualify_StaggeredValue2_get.entry = entry;
	async->args.field_qualify_StaggeredValue2_get.data = data;
	async->args.field_qualify_StaggeredValue2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue3_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE3;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue3.unit = unit;
	async->args.field_qualify_StaggeredValue3.entry = entry;
	async->args.field_qualify_StaggeredValue3.data = data;
	async->args.field_qualify_StaggeredValue3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StaggeredValue3_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGGEREDVALUE3_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StaggeredValue3_get.unit = unit;
	async->args.field_qualify_StaggeredValue3_get.entry = entry;
	async->args.field_qualify_StaggeredValue3_get.data = data;
	async->args.field_qualify_StaggeredValue3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StpState_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STPSTATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StpState.unit = unit;
	async->args.field_qualify_StpState.entry = entry;
	async->args.field_qualify_StpState.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_StpState_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_STPSTATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_StpState_get.unit = unit;
	async->args.field_qualify_StpState_get.entry = entry;
	async->args.field_qualify_StpState_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SubportPktTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SUBPORTPKTTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SubportPktTag.unit = unit;
	async->args.field_qualify_SubportPktTag.entry = entry;
	async->args.field_qualify_SubportPktTag.data = data;
	async->args.field_qualify_SubportPktTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SubportPktTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SUBPORTPKTTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SubportPktTag_get.unit = unit;
	async->args.field_qualify_SubportPktTag_get.entry = entry;
	async->args.field_qualify_SubportPktTag_get.data = data;
	async->args.field_qualify_SubportPktTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SystemPortBitmap_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t data,
	bcm_pbmp_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SYSTEMPORTBITMAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SystemPortBitmap.unit = unit;
	async->args.field_qualify_SystemPortBitmap.entry = entry;
	async->args.field_qualify_SystemPortBitmap.data = data;
	async->args.field_qualify_SystemPortBitmap.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_SystemPortBitmap_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_SYSTEMPORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SystemPortBitmap_get.unit = unit;
	async->args.field_qualify_SystemPortBitmap_get.entry = entry;
	async->args.field_qualify_SystemPortBitmap_get.data = data;
	async->args.field_qualify_SystemPortBitmap_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpClassOne_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCLASSONE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpClassOne.unit = unit;
	async->args.field_qualify_TcpClassOne.entry = entry;
	async->args.field_qualify_TcpClassOne.data = data;
	async->args.field_qualify_TcpClassOne.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpClassOne_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCLASSONE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpClassOne_get.unit = unit;
	async->args.field_qualify_TcpClassOne_get.entry = entry;
	async->args.field_qualify_TcpClassOne_get.data = data;
	async->args.field_qualify_TcpClassOne_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpClassZero_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCLASSZERO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpClassZero.unit = unit;
	async->args.field_qualify_TcpClassZero.entry = entry;
	async->args.field_qualify_TcpClassZero.data = data;
	async->args.field_qualify_TcpClassZero.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpClassZero_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCLASSZERO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpClassZero_get.unit = unit;
	async->args.field_qualify_TcpClassZero_get.entry = entry;
	async->args.field_qualify_TcpClassZero_get.data = data;
	async->args.field_qualify_TcpClassZero_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpControl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpControl.unit = unit;
	async->args.field_qualify_TcpControl.entry = entry;
	async->args.field_qualify_TcpControl.data = data;
	async->args.field_qualify_TcpControl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpControl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpControl_get.unit = unit;
	async->args.field_qualify_TcpControl_get.entry = entry;
	async->args.field_qualify_TcpControl_get.data = data;
	async->args.field_qualify_TcpControl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpHeaderSize_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpHeaderSize.unit = unit;
	async->args.field_qualify_TcpHeaderSize.entry = entry;
	async->args.field_qualify_TcpHeaderSize.data = data;
	async->args.field_qualify_TcpHeaderSize.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpHeaderSize_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpHeaderSize_get.unit = unit;
	async->args.field_qualify_TcpHeaderSize_get.entry = entry;
	async->args.field_qualify_TcpHeaderSize_get.data = data;
	async->args.field_qualify_TcpHeaderSize_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpSequenceZero_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpSequenceZero.unit = unit;
	async->args.field_qualify_TcpSequenceZero.entry = entry;
	async->args.field_qualify_TcpSequenceZero.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TcpSequenceZero_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * flag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpSequenceZero_get.unit = unit;
	async->args.field_qualify_TcpSequenceZero_get.entry = entry;
	async->args.field_qualify_TcpSequenceZero_get.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Tos_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Tos.unit = unit;
	async->args.field_qualify_Tos.entry = entry;
	async->args.field_qualify_Tos.data = data;
	async->args.field_qualify_Tos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosClassOne_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSCLASSONE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosClassOne.unit = unit;
	async->args.field_qualify_TosClassOne.entry = entry;
	async->args.field_qualify_TosClassOne.data = data;
	async->args.field_qualify_TosClassOne.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosClassOne_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSCLASSONE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosClassOne_get.unit = unit;
	async->args.field_qualify_TosClassOne_get.entry = entry;
	async->args.field_qualify_TosClassOne_get.data = data;
	async->args.field_qualify_TosClassOne_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosClassZero_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSCLASSZERO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosClassZero.unit = unit;
	async->args.field_qualify_TosClassZero.entry = entry;
	async->args.field_qualify_TosClassZero.data = data;
	async->args.field_qualify_TosClassZero.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosClassZero_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSCLASSZERO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosClassZero_get.unit = unit;
	async->args.field_qualify_TosClassZero_get.entry = entry;
	async->args.field_qualify_TosClassZero_get.data = data;
	async->args.field_qualify_TosClassZero_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosLower4Bits_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSLOWER4BITS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosLower4Bits.unit = unit;
	async->args.field_qualify_TosLower4Bits.entry = entry;
	async->args.field_qualify_TosLower4Bits.data = data;
	async->args.field_qualify_TosLower4Bits.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TosLower4Bits_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOSLOWER4BITS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TosLower4Bits_get.unit = unit;
	async->args.field_qualify_TosLower4Bits_get.entry = entry;
	async->args.field_qualify_TosLower4Bits_get.data = data;
	async->args.field_qualify_TosLower4Bits_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Tos_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Tos_get.unit = unit;
	async->args.field_qualify_Tos_get.entry = entry;
	async->args.field_qualify_Tos_get.data = data;
	async->args.field_qualify_Tos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlan.unit = unit;
	async->args.field_qualify_TranslatedInnerVlan.entry = entry;
	async->args.field_qualify_TranslatedInnerVlan.data = data;
	async->args.field_qualify_TranslatedInnerVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanCfi.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanCfi.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanCfi.data = data;
	async->args.field_qualify_TranslatedInnerVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanCfi_get.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanCfi_get.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanCfi_get.data = data;
	async->args.field_qualify_TranslatedInnerVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanId.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanId.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanId.data = data;
	async->args.field_qualify_TranslatedInnerVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanId_get.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanId_get.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanId_get.data = data;
	async->args.field_qualify_TranslatedInnerVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanPri.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanPri.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanPri.data = data;
	async->args.field_qualify_TranslatedInnerVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlanPri_get.unit = unit;
	async->args.field_qualify_TranslatedInnerVlanPri_get.entry = entry;
	async->args.field_qualify_TranslatedInnerVlanPri_get.data = data;
	async->args.field_qualify_TranslatedInnerVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedInnerVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDINNERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedInnerVlan_get.unit = unit;
	async->args.field_qualify_TranslatedInnerVlan_get.entry = entry;
	async->args.field_qualify_TranslatedInnerVlan_get.data = data;
	async->args.field_qualify_TranslatedInnerVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlan.unit = unit;
	async->args.field_qualify_TranslatedOuterVlan.entry = entry;
	async->args.field_qualify_TranslatedOuterVlan.data = data;
	async->args.field_qualify_TranslatedOuterVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanCfi.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanCfi.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanCfi.data = data;
	async->args.field_qualify_TranslatedOuterVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanCfi_get.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanCfi_get.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanCfi_get.data = data;
	async->args.field_qualify_TranslatedOuterVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanId.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanId.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanId.data = data;
	async->args.field_qualify_TranslatedOuterVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanId_get.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanId_get.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanId_get.data = data;
	async->args.field_qualify_TranslatedOuterVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanPri.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanPri.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanPri.data = data;
	async->args.field_qualify_TranslatedOuterVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlanPri_get.unit = unit;
	async->args.field_qualify_TranslatedOuterVlanPri_get.entry = entry;
	async->args.field_qualify_TranslatedOuterVlanPri_get.data = data;
	async->args.field_qualify_TranslatedOuterVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedOuterVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDOUTERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedOuterVlan_get.unit = unit;
	async->args.field_qualify_TranslatedOuterVlan_get.entry = entry;
	async->args.field_qualify_TranslatedOuterVlan_get.data = data;
	async->args.field_qualify_TranslatedOuterVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedVlanFormat_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedVlanFormat.unit = unit;
	async->args.field_qualify_TranslatedVlanFormat.entry = entry;
	async->args.field_qualify_TranslatedVlanFormat.data = data;
	async->args.field_qualify_TranslatedVlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TranslatedVlanFormat_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedVlanFormat_get.unit = unit;
	async->args.field_qualify_TranslatedVlanFormat_get.entry = entry;
	async->args.field_qualify_TranslatedVlanFormat_get.data = data;
	async->args.field_qualify_TranslatedVlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillEgressRbridge_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLEGRESSRBRIDGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillEgressRbridge.unit = unit;
	async->args.field_qualify_TrillEgressRbridge.entry = entry;
	async->args.field_qualify_TrillEgressRbridge.data = data;
	async->args.field_qualify_TrillEgressRbridge.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillEgressRbridgeHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLEGRESSRBRIDGEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillEgressRbridgeHit.unit = unit;
	async->args.field_qualify_TrillEgressRbridgeHit.entry = entry;
	async->args.field_qualify_TrillEgressRbridgeHit.data = data;
	async->args.field_qualify_TrillEgressRbridgeHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillEgressRbridgeHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLEGRESSRBRIDGEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillEgressRbridgeHit_get.unit = unit;
	async->args.field_qualify_TrillEgressRbridgeHit_get.entry = entry;
	async->args.field_qualify_TrillEgressRbridgeHit_get.data = data;
	async->args.field_qualify_TrillEgressRbridgeHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillEgressRbridge_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLEGRESSRBRIDGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillEgressRbridge_get.unit = unit;
	async->args.field_qualify_TrillEgressRbridge_get.entry = entry;
	async->args.field_qualify_TrillEgressRbridge_get.data = data;
	async->args.field_qualify_TrillEgressRbridge_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillHopCount_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLHOPCOUNT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillHopCount.unit = unit;
	async->args.field_qualify_TrillHopCount.entry = entry;
	async->args.field_qualify_TrillHopCount.data = data;
	async->args.field_qualify_TrillHopCount.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillHopCount_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLHOPCOUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillHopCount_get.unit = unit;
	async->args.field_qualify_TrillHopCount_get.entry = entry;
	async->args.field_qualify_TrillHopCount_get.data = data;
	async->args.field_qualify_TrillHopCount_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIVersion_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLIVERSION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIVersion.unit = unit;
	async->args.field_qualify_TrillIVersion.entry = entry;
	async->args.field_qualify_TrillIVersion.data = data;
	async->args.field_qualify_TrillIVersion.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIVersion_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLIVERSION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIVersion_get.unit = unit;
	async->args.field_qualify_TrillIVersion_get.entry = entry;
	async->args.field_qualify_TrillIVersion_get.data = data;
	async->args.field_qualify_TrillIVersion_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIngressRbridge_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLINGRESSRBRIDGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIngressRbridge.unit = unit;
	async->args.field_qualify_TrillIngressRbridge.entry = entry;
	async->args.field_qualify_TrillIngressRbridge.data = data;
	async->args.field_qualify_TrillIngressRbridge.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIngressRbridgeHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLINGRESSRBRIDGEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIngressRbridgeHit.unit = unit;
	async->args.field_qualify_TrillIngressRbridgeHit.entry = entry;
	async->args.field_qualify_TrillIngressRbridgeHit.data = data;
	async->args.field_qualify_TrillIngressRbridgeHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIngressRbridgeHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLINGRESSRBRIDGEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIngressRbridgeHit_get.unit = unit;
	async->args.field_qualify_TrillIngressRbridgeHit_get.entry = entry;
	async->args.field_qualify_TrillIngressRbridgeHit_get.data = data;
	async->args.field_qualify_TrillIngressRbridgeHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillIngressRbridge_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLINGRESSRBRIDGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillIngressRbridge_get.unit = unit;
	async->args.field_qualify_TrillIngressRbridge_get.entry = entry;
	async->args.field_qualify_TrillIngressRbridge_get.data = data;
	async->args.field_qualify_TrillIngressRbridge_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillMultiDestination_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLMULTIDESTINATION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillMultiDestination.unit = unit;
	async->args.field_qualify_TrillMultiDestination.entry = entry;
	async->args.field_qualify_TrillMultiDestination.data = data;
	async->args.field_qualify_TrillMultiDestination.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillMultiDestination_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLMULTIDESTINATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillMultiDestination_get.unit = unit;
	async->args.field_qualify_TrillMultiDestination_get.entry = entry;
	async->args.field_qualify_TrillMultiDestination_get.data = data;
	async->args.field_qualify_TrillMultiDestination_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillOpLength_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLOPLENGTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillOpLength.unit = unit;
	async->args.field_qualify_TrillOpLength.entry = entry;
	async->args.field_qualify_TrillOpLength.data = data;
	async->args.field_qualify_TrillOpLength.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillOpLength_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLOPLENGTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillOpLength_get.unit = unit;
	async->args.field_qualify_TrillOpLength_get.entry = entry;
	async->args.field_qualify_TrillOpLength_get.data = data;
	async->args.field_qualify_TrillOpLength_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillPayload_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLPAYLOAD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillPayload.unit = unit;
	async->args.field_qualify_TrillPayload.entry = entry;
	async->args.field_qualify_TrillPayload.data = data;
	async->args.field_qualify_TrillPayload.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrillPayload_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRILLPAYLOAD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrillPayload_get.unit = unit;
	async->args.field_qualify_TrillPayload_get.entry = entry;
	async->args.field_qualify_TrillPayload_get.data = data;
	async->args.field_qualify_TrillPayload_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrunkHashResult_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRUNKHASHRESULT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrunkHashResult.unit = unit;
	async->args.field_qualify_TrunkHashResult.entry = entry;
	async->args.field_qualify_TrunkHashResult.data = data;
	async->args.field_qualify_TrunkHashResult.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrunkHashResult_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRUNKHASHRESULT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrunkHashResult_get.unit = unit;
	async->args.field_qualify_TrunkHashResult_get.entry = entry;
	async->args.field_qualify_TrunkHashResult_get.data = data;
	async->args.field_qualify_TrunkHashResult_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrunkMemberSourceModuleId_async(
	int unit,
	bcm_field_entry_t entry,
	int data,
	int mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRUNKMEMBERSOURCEMODULEID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrunkMemberSourceModuleId.unit = unit;
	async->args.field_qualify_TrunkMemberSourceModuleId.entry = entry;
	async->args.field_qualify_TrunkMemberSourceModuleId.data = data;
	async->args.field_qualify_TrunkMemberSourceModuleId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TrunkMemberSourceModuleId_get_async(
	int unit,
	bcm_field_entry_t entry,
	int * data,
	int * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRUNKMEMBERSOURCEMODULEID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TrunkMemberSourceModuleId_get.unit = unit;
	async->args.field_qualify_TrunkMemberSourceModuleId_get.entry = entry;
	async->args.field_qualify_TrunkMemberSourceModuleId_get.data = data;
	async->args.field_qualify_TrunkMemberSourceModuleId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TsnFlowId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TSNFLOWID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TsnFlowId.unit = unit;
	async->args.field_qualify_TsnFlowId.entry = entry;
	async->args.field_qualify_TsnFlowId.data = data;
	async->args.field_qualify_TsnFlowId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TsnFlowId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TSNFLOWID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TsnFlowId_get.unit = unit;
	async->args.field_qualify_TsnFlowId_get.entry = entry;
	async->args.field_qualify_TsnFlowId_get.data = data;
	async->args.field_qualify_TsnFlowId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ttl_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ttl.unit = unit;
	async->args.field_qualify_Ttl.entry = entry;
	async->args.field_qualify_Ttl.data = data;
	async->args.field_qualify_Ttl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TtlClassOne_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTLCLASSONE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TtlClassOne.unit = unit;
	async->args.field_qualify_TtlClassOne.entry = entry;
	async->args.field_qualify_TtlClassOne.data = data;
	async->args.field_qualify_TtlClassOne.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TtlClassOne_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTLCLASSONE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TtlClassOne_get.unit = unit;
	async->args.field_qualify_TtlClassOne_get.entry = entry;
	async->args.field_qualify_TtlClassOne_get.data = data;
	async->args.field_qualify_TtlClassOne_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TtlClassZero_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t data,
	bcm_class_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTLCLASSZERO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TtlClassZero.unit = unit;
	async->args.field_qualify_TtlClassZero.entry = entry;
	async->args.field_qualify_TtlClassZero.data = data;
	async->args.field_qualify_TtlClassZero.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TtlClassZero_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_class_t * data,
	bcm_class_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTLCLASSZERO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TtlClassZero_get.unit = unit;
	async->args.field_qualify_TtlClassZero_get.entry = entry;
	async->args.field_qualify_TtlClassZero_get.data = data;
	async->args.field_qualify_TtlClassZero_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Ttl_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ttl_get.unit = unit;
	async->args.field_qualify_Ttl_get.entry = entry;
	async->args.field_qualify_Ttl_get.data = data;
	async->args.field_qualify_Ttl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelId.unit = unit;
	async->args.field_qualify_TunnelId.entry = entry;
	async->args.field_qualify_TunnelId.data = data;
	async->args.field_qualify_TunnelId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelId_get.unit = unit;
	async->args.field_qualify_TunnelId_get.entry = entry;
	async->args.field_qualify_TunnelId_get.data = data;
	async->args.field_qualify_TunnelId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDip_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDip.unit = unit;
	async->args.field_qualify_TunnelPayloadDip.entry = entry;
	async->args.field_qualify_TunnelPayloadDip.data = data;
	async->args.field_qualify_TunnelPayloadDip.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDip6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDip6.unit = unit;
	async->args.field_qualify_TunnelPayloadDip6.entry = entry;
	async->args.field_qualify_TunnelPayloadDip6.data = (uint8 *)data;
	async->args.field_qualify_TunnelPayloadDip6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDip6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDip6_get.unit = unit;
	async->args.field_qualify_TunnelPayloadDip6_get.entry = entry;
	async->args.field_qualify_TunnelPayloadDip6_get.data = data;
	async->args.field_qualify_TunnelPayloadDip6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDip_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDip_get.unit = unit;
	async->args.field_qualify_TunnelPayloadDip_get.entry = entry;
	async->args.field_qualify_TunnelPayloadDip_get.data = data;
	async->args.field_qualify_TunnelPayloadDip_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDstMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDSTMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDstMac.unit = unit;
	async->args.field_qualify_TunnelPayloadDstMac.entry = entry;
	async->args.field_qualify_TunnelPayloadDstMac.data = (uint8 *)data;
	async->args.field_qualify_TunnelPayloadDstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadDstMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADDSTMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadDstMac_get.unit = unit;
	async->args.field_qualify_TunnelPayloadDstMac_get.entry = entry;
	async->args.field_qualify_TunnelPayloadDstMac_get.data = data;
	async->args.field_qualify_TunnelPayloadDstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadEtherType_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADETHERTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadEtherType.unit = unit;
	async->args.field_qualify_TunnelPayloadEtherType.entry = entry;
	async->args.field_qualify_TunnelPayloadEtherType.data = data;
	async->args.field_qualify_TunnelPayloadEtherType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadEtherType_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadEtherType_get.unit = unit;
	async->args.field_qualify_TunnelPayloadEtherType_get.entry = entry;
	async->args.field_qualify_TunnelPayloadEtherType_get.data = data;
	async->args.field_qualify_TunnelPayloadEtherType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadIpProtocol_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADIPPROTOCOL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadIpProtocol.unit = unit;
	async->args.field_qualify_TunnelPayloadIpProtocol.entry = entry;
	async->args.field_qualify_TunnelPayloadIpProtocol.data = data;
	async->args.field_qualify_TunnelPayloadIpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadIpProtocol_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADIPPROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadIpProtocol_get.unit = unit;
	async->args.field_qualify_TunnelPayloadIpProtocol_get.entry = entry;
	async->args.field_qualify_TunnelPayloadIpProtocol_get.data = data;
	async->args.field_qualify_TunnelPayloadIpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadL4DstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADL4DSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadL4DstPort.unit = unit;
	async->args.field_qualify_TunnelPayloadL4DstPort.entry = entry;
	async->args.field_qualify_TunnelPayloadL4DstPort.data = data;
	async->args.field_qualify_TunnelPayloadL4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadL4DstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADL4DSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadL4DstPort_get.unit = unit;
	async->args.field_qualify_TunnelPayloadL4DstPort_get.entry = entry;
	async->args.field_qualify_TunnelPayloadL4DstPort_get.data = data;
	async->args.field_qualify_TunnelPayloadL4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadL4SrcPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADL4SRCPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadL4SrcPort.unit = unit;
	async->args.field_qualify_TunnelPayloadL4SrcPort.entry = entry;
	async->args.field_qualify_TunnelPayloadL4SrcPort.data = data;
	async->args.field_qualify_TunnelPayloadL4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadL4SrcPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADL4SRCPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadL4SrcPort_get.unit = unit;
	async->args.field_qualify_TunnelPayloadL4SrcPort_get.entry = entry;
	async->args.field_qualify_TunnelPayloadL4SrcPort_get.data = data;
	async->args.field_qualify_TunnelPayloadL4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlan_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlan.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlan.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlan.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanCfi_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANCFI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanCfi_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANCFI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi_get.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi_get.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi_get.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanId_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanId.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanId.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanId.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanId_get.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanId_get.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanId_get.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanPri_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANPRI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanPri.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanPri.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanPri.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlanPri_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLANPRI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlanPri_get.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlanPri_get.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlanPri_get.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadOuterVlan_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADOUTERVLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadOuterVlan_get.unit = unit;
	async->args.field_qualify_TunnelPayloadOuterVlan_get.entry = entry;
	async->args.field_qualify_TunnelPayloadOuterVlan_get.data = data;
	async->args.field_qualify_TunnelPayloadOuterVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSip_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSIP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSip.unit = unit;
	async->args.field_qualify_TunnelPayloadSip.entry = entry;
	async->args.field_qualify_TunnelPayloadSip.data = data;
	async->args.field_qualify_TunnelPayloadSip.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSip6_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSIP6;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSip6.unit = unit;
	async->args.field_qualify_TunnelPayloadSip6.entry = entry;
	async->args.field_qualify_TunnelPayloadSip6.data = (uint8 *)data;
	async->args.field_qualify_TunnelPayloadSip6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSip6_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSIP6_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSip6_get.unit = unit;
	async->args.field_qualify_TunnelPayloadSip6_get.entry = entry;
	async->args.field_qualify_TunnelPayloadSip6_get.data = data;
	async->args.field_qualify_TunnelPayloadSip6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSip_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSIP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSip_get.unit = unit;
	async->args.field_qualify_TunnelPayloadSip_get.entry = entry;
	async->args.field_qualify_TunnelPayloadSip_get.data = data;
	async->args.field_qualify_TunnelPayloadSip_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSrcMac_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSRCMAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSrcMac.unit = unit;
	async->args.field_qualify_TunnelPayloadSrcMac.entry = entry;
	async->args.field_qualify_TunnelPayloadSrcMac.data = (uint8 *)data;
	async->args.field_qualify_TunnelPayloadSrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelPayloadSrcMac_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELPAYLOADSRCMAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelPayloadSrcMac_get.unit = unit;
	async->args.field_qualify_TunnelPayloadSrcMac_get.entry = entry;
	async->args.field_qualify_TunnelPayloadSrcMac_get.data = data;
	async->args.field_qualify_TunnelPayloadSrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminated_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminated.unit = unit;
	async->args.field_qualify_TunnelTerminated.entry = entry;
	async->args.field_qualify_TunnelTerminated.data = data;
	async->args.field_qualify_TunnelTerminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminatedHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATEDHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminatedHit.unit = unit;
	async->args.field_qualify_TunnelTerminatedHit.entry = entry;
	async->args.field_qualify_TunnelTerminatedHit.data = data;
	async->args.field_qualify_TunnelTerminatedHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminatedHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATEDHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminatedHit_get.unit = unit;
	async->args.field_qualify_TunnelTerminatedHit_get.entry = entry;
	async->args.field_qualify_TunnelTerminatedHit_get.data = data;
	async->args.field_qualify_TunnelTerminatedHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminatedValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATEDVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminatedValue.unit = unit;
	async->args.field_qualify_TunnelTerminatedValue.entry = entry;
	async->args.field_qualify_TunnelTerminatedValue.data = data;
	async->args.field_qualify_TunnelTerminatedValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminatedValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATEDVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminatedValue_get.unit = unit;
	async->args.field_qualify_TunnelTerminatedValue_get.entry = entry;
	async->args.field_qualify_TunnelTerminatedValue_get.data = data;
	async->args.field_qualify_TunnelTerminatedValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelTerminated_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminated_get.unit = unit;
	async->args.field_qualify_TunnelTerminated_get.entry = entry;
	async->args.field_qualify_TunnelTerminated_get.data = data;
	async->args.field_qualify_TunnelTerminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelType_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_TunnelType_t tunnel_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelType.unit = unit;
	async->args.field_qualify_TunnelType.entry = entry;
	async->args.field_qualify_TunnelType.tunnel_type = tunnel_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_TunnelType_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_TunnelType_t * tunnel_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelType_get.unit = unit;
	async->args.field_qualify_TunnelType_get.entry = entry;
	async->args.field_qualify_TunnelType_get.tunnel_type = tunnel_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_UdfClass_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_UDFCLASS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_UdfClass.unit = unit;
	async->args.field_qualify_UdfClass.entry = entry;
	async->args.field_qualify_UdfClass.data = data;
	async->args.field_qualify_UdfClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_UdfClass_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_UDFCLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_UdfClass_get.unit = unit;
	async->args.field_qualify_UdfClass_get.entry = entry;
	async->args.field_qualify_UdfClass_get.data = data;
	async->args.field_qualify_UdfClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VPortRangeCheck_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_field_range_t range,
	int invert,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPORTRANGECHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VPortRangeCheck.unit = unit;
	async->args.field_qualify_VPortRangeCheck.entry = entry;
	async->args.field_qualify_VPortRangeCheck.range = range;
	async->args.field_qualify_VPortRangeCheck.invert = invert;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VPortRangeCheck_get_async(
	int unit,
	bcm_field_entry_t entry,
	int max_count,
	bcm_field_range_t * range,
	int * invert,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPORTRANGECHECK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VPortRangeCheck_get.unit = unit;
	async->args.field_qualify_VPortRangeCheck_get.entry = entry;
	async->args.field_qualify_VPortRangeCheck_get.max_count = max_count;
	async->args.field_qualify_VPortRangeCheck_get.range = range;
	async->args.field_qualify_VPortRangeCheck_get.invert = invert;
	async->args.field_qualify_VPortRangeCheck_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanAction_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANACTION;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanAction.unit = unit;
	async->args.field_qualify_VlanAction.entry = entry;
	async->args.field_qualify_VlanAction.data = data;
	async->args.field_qualify_VlanAction.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanAction_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanAction_get.unit = unit;
	async->args.field_qualify_VlanAction_get.entry = entry;
	async->args.field_qualify_VlanAction_get.data = data;
	async->args.field_qualify_VlanAction_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanFormat_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanFormat.unit = unit;
	async->args.field_qualify_VlanFormat.entry = entry;
	async->args.field_qualify_VlanFormat.data = data;
	async->args.field_qualify_VlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanFormat_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanFormat_get.unit = unit;
	async->args.field_qualify_VlanFormat_get.entry = entry;
	async->args.field_qualify_VlanFormat_get.data = data;
	async->args.field_qualify_VlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanSREnable_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANSRENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanSREnable.unit = unit;
	async->args.field_qualify_VlanSREnable.entry = entry;
	async->args.field_qualify_VlanSREnable.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanSREnable_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANSRENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanSREnable_get.unit = unit;
	async->args.field_qualify_VlanSREnable_get.entry = entry;
	async->args.field_qualify_VlanSREnable_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanSRLanId_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 lan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANSRLANID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanSRLanId.unit = unit;
	async->args.field_qualify_VlanSRLanId.entry = entry;
	async->args.field_qualify_VlanSRLanId.lan_id = lan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanSRLanId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * lan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANSRLANID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanSRLanId_get.unit = unit;
	async->args.field_qualify_VlanSRLanId_get.entry = entry;
	async->args.field_qualify_VlanSRLanId_get.lan_id = lan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanTranslationHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationHit.unit = unit;
	async->args.field_qualify_VlanTranslationHit.entry = entry;
	async->args.field_qualify_VlanTranslationHit.data = data;
	async->args.field_qualify_VlanTranslationHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanTranslationHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationHit_get.unit = unit;
	async->args.field_qualify_VlanTranslationHit_get.entry = entry;
	async->args.field_qualify_VlanTranslationHit_get.data = data;
	async->args.field_qualify_VlanTranslationHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanTranslationValue_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 data,
	uint64 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONVALUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationValue.unit = unit;
	async->args.field_qualify_VlanTranslationValue.entry = entry;
	async->args.field_qualify_VlanTranslationValue.data = data;
	async->args.field_qualify_VlanTranslationValue.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VlanTranslationValue_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint64 * data,
	uint64 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONVALUE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationValue_get.unit = unit;
	async->args.field_qualify_VlanTranslationValue_get.entry = entry;
	async->args.field_qualify_VlanTranslationValue_get.data = data;
	async->args.field_qualify_VlanTranslationValue_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VnTag_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VNTAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VnTag.unit = unit;
	async->args.field_qualify_VnTag.entry = entry;
	async->args.field_qualify_VnTag.data = data;
	async->args.field_qualify_VnTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VnTag_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VNTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VnTag_get.unit = unit;
	async->args.field_qualify_VnTag_get.entry = entry;
	async->args.field_qualify_VnTag_get.data = data;
	async->args.field_qualify_VnTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Vpn_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vpn_t data,
	bcm_vpn_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vpn.unit = unit;
	async->args.field_qualify_Vpn.entry = entry;
	async->args.field_qualify_Vpn.data = data;
	async->args.field_qualify_Vpn.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VpnUnknownDstMacDstPort_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPNUNKNOWNDSTMACDSTPORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VpnUnknownDstMacDstPort.unit = unit;
	async->args.field_qualify_VpnUnknownDstMacDstPort.entry = entry;
	async->args.field_qualify_VpnUnknownDstMacDstPort.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VpnUnknownDstMacDstPort_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_gport_t * port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPNUNKNOWNDSTMACDSTPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VpnUnknownDstMacDstPort_get.unit = unit;
	async->args.field_qualify_VpnUnknownDstMacDstPort_get.entry = entry;
	async->args.field_qualify_VpnUnknownDstMacDstPort_get.port_id = port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Vpn_get_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_vpn_t * data,
	bcm_vpn_t * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vpn_get.unit = unit;
	async->args.field_qualify_Vpn_get.entry = entry;
	async->args.field_qualify_Vpn_get.data = data;
	async->args.field_qualify_Vpn_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Vrf_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VRF;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vrf.unit = unit;
	async->args.field_qualify_Vrf.entry = entry;
	async->args.field_qualify_Vrf.data = data;
	async->args.field_qualify_Vrf.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_Vrf_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VRF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vrf_get.unit = unit;
	async->args.field_qualify_Vrf_get.entry = entry;
	async->args.field_qualify_Vrf_get.data = data;
	async->args.field_qualify_Vrf_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanClassValid_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANCLASSVALID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanClassValid.unit = unit;
	async->args.field_qualify_VxlanClassValid.entry = entry;
	async->args.field_qualify_VxlanClassValid.data = data;
	async->args.field_qualify_VxlanClassValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanClassValid_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANCLASSVALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanClassValid_get.unit = unit;
	async->args.field_qualify_VxlanClassValid_get.entry = entry;
	async->args.field_qualify_VxlanClassValid_get.data = data;
	async->args.field_qualify_VxlanClassValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanFlags_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANFLAGS;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanFlags.unit = unit;
	async->args.field_qualify_VxlanFlags.entry = entry;
	async->args.field_qualify_VxlanFlags.data = data;
	async->args.field_qualify_VxlanFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanFlags_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANFLAGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanFlags_get.unit = unit;
	async->args.field_qualify_VxlanFlags_get.entry = entry;
	async->args.field_qualify_VxlanFlags_get.data = data;
	async->args.field_qualify_VxlanFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanHeaderBits56_63_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANHEADERBITS56_63;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanHeaderBits56_63.unit = unit;
	async->args.field_qualify_VxlanHeaderBits56_63.entry = entry;
	async->args.field_qualify_VxlanHeaderBits56_63.data = data;
	async->args.field_qualify_VxlanHeaderBits56_63.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanHeaderBits56_63_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANHEADERBITS56_63_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanHeaderBits56_63_get.unit = unit;
	async->args.field_qualify_VxlanHeaderBits56_63_get.entry = entry;
	async->args.field_qualify_VxlanHeaderBits56_63_get.data = data;
	async->args.field_qualify_VxlanHeaderBits56_63_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanHeaderBits8_31_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANHEADERBITS8_31;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanHeaderBits8_31.unit = unit;
	async->args.field_qualify_VxlanHeaderBits8_31.entry = entry;
	async->args.field_qualify_VxlanHeaderBits8_31.data = data;
	async->args.field_qualify_VxlanHeaderBits8_31.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanHeaderBits8_31_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANHEADERBITS8_31_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanHeaderBits8_31_get.unit = unit;
	async->args.field_qualify_VxlanHeaderBits8_31_get.entry = entry;
	async->args.field_qualify_VxlanHeaderBits8_31_get.data = data;
	async->args.field_qualify_VxlanHeaderBits8_31_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanNetworkId_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANNETWORKID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanNetworkId.unit = unit;
	async->args.field_qualify_VxlanNetworkId.entry = entry;
	async->args.field_qualify_VxlanNetworkId.data = data;
	async->args.field_qualify_VxlanNetworkId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanNetworkId_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANNETWORKID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanNetworkId_get.unit = unit;
	async->args.field_qualify_VxlanNetworkId_get.entry = entry;
	async->args.field_qualify_VxlanNetworkId_get.data = data;
	async->args.field_qualify_VxlanNetworkId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanPacket_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANPACKET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanPacket.unit = unit;
	async->args.field_qualify_VxlanPacket.entry = entry;
	async->args.field_qualify_VxlanPacket.data = data;
	async->args.field_qualify_VxlanPacket.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanPacket_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANPACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanPacket_get.unit = unit;
	async->args.field_qualify_VxlanPacket_get.entry = entry;
	async->args.field_qualify_VxlanPacket_get.data = data;
	async->args.field_qualify_VxlanPacket_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanPayloadVlanFormat_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANPAYLOADVLANFORMAT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanPayloadVlanFormat.unit = unit;
	async->args.field_qualify_VxlanPayloadVlanFormat.entry = entry;
	async->args.field_qualify_VxlanPayloadVlanFormat.data = data;
	async->args.field_qualify_VxlanPayloadVlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanPayloadVlanFormat_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANPAYLOADVLANFORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanPayloadVlanFormat_get.unit = unit;
	async->args.field_qualify_VxlanPayloadVlanFormat_get.entry = entry;
	async->args.field_qualify_VxlanPayloadVlanFormat_get.data = data;
	async->args.field_qualify_VxlanPayloadVlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanVnidVlanTranslateHit_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANVNIDVLANTRANSLATEHIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanVnidVlanTranslateHit.unit = unit;
	async->args.field_qualify_VxlanVnidVlanTranslateHit.entry = entry;
	async->args.field_qualify_VxlanVnidVlanTranslateHit.data = data;
	async->args.field_qualify_VxlanVnidVlanTranslateHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_VxlanVnidVlanTranslateHit_get_async(
	int unit,
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_VXLANVNIDVLANTRANSLATEHIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VxlanVnidVlanTranslateHit_get.unit = unit;
	async->args.field_qualify_VxlanVnidVlanTranslateHit_get.entry = entry;
	async->args.field_qualify_VxlanVnidVlanTranslateHit_get.data = data;
	async->args.field_qualify_VxlanVnidVlanTranslateHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_clear_async(
	int unit,
	bcm_field_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_clear.unit = unit;
	async->args.field_qualify_clear.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_data_async(
	int unit,
	bcm_field_entry_t eid,
	int qual_id,
	uint8 * data,
	uint8 * mask,
	uint16 length,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_data.unit = unit;
	async->args.field_qualify_data.eid = eid;
	async->args.field_qualify_data.qual_id = qual_id;
	async->args.field_qualify_data.data = data;
	async->args.field_qualify_data.mask = mask;
	async->args.field_qualify_data.length = length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_data_get_async(
	int unit,
	bcm_field_entry_t eid,
	int qual_id,
	uint16 length_max,
	uint8 * data,
	uint8 * mask,
	uint16 * length,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_DATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_data_get.unit = unit;
	async->args.field_qualify_data_get.eid = eid;
	async->args.field_qualify_data_get.qual_id = qual_id;
	async->args.field_qualify_data_get.length_max = length_max;
	async->args.field_qualify_data_get.data = data;
	async->args.field_qualify_data_get.mask = mask;
	async->args.field_qualify_data_get.length = length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_udf_async(
	int unit,
	bcm_field_entry_t eid,
	bcm_udf_id_t udf_id,
	int length,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_UDF;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_udf.unit = unit;
	async->args.field_qualify_udf.eid = eid;
	async->args.field_qualify_udf.udf_id = udf_id;
	async->args.field_qualify_udf.length = length;
	async->args.field_qualify_udf.data = data;
	async->args.field_qualify_udf.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_qualify_udf_get_async(
	int unit,
	bcm_field_entry_t eid,
	bcm_udf_id_t udf_id,
	int max_length,
	uint8 * data,
	uint8 * mask,
	int * actual_length,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_QUALIFY_UDF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_udf_get.unit = unit;
	async->args.field_qualify_udf_get.eid = eid;
	async->args.field_qualify_udf_get.udf_id = udf_id;
	async->args.field_qualify_udf_get.max_length = max_length;
	async->args.field_qualify_udf_get.data = data;
	async->args.field_qualify_udf_get.mask = mask;
	async->args.field_qualify_udf_get.actual_length = actual_length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_create_async(
	int unit,
	bcm_field_range_t * range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_create.unit = unit;
	async->args.field_range_create.range = range;
	async->args.field_range_create.flags = flags;
	async->args.field_range_create.min = min;
	async->args.field_range_create.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_create_id_async(
	int unit,
	bcm_field_range_t range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_create_id.unit = unit;
	async->args.field_range_create_id.range = range;
	async->args.field_range_create_id.flags = flags;
	async->args.field_range_create_id.min = min;
	async->args.field_range_create_id.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_destroy_async(
	int unit,
	bcm_field_range_t range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_destroy.unit = unit;
	async->args.field_range_destroy.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_get_async(
	int unit,
	bcm_field_range_t range,
	uint32 * flags,
	bcm_l4_port_t * min,
	bcm_l4_port_t * max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_get.unit = unit;
	async->args.field_range_get.range = range;
	async->args.field_range_get.flags = flags;
	async->args.field_range_get.min = min;
	async->args.field_range_get.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_group_create_async(
	int unit,
	bcm_field_range_t * range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_if_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_group_create.unit = unit;
	async->args.field_range_group_create.range = range;
	async->args.field_range_group_create.flags = flags;
	async->args.field_range_group_create.min = min;
	async->args.field_range_group_create.max = max;
	async->args.field_range_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_group_create_id_async(
	int unit,
	bcm_field_range_t range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_if_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_group_create_id.unit = unit;
	async->args.field_range_group_create_id.range = range;
	async->args.field_range_group_create_id.flags = flags;
	async->args.field_range_group_create_id.min = min;
	async->args.field_range_group_create_id.max = max;
	async->args.field_range_group_create_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_multi_create_async(
	int unit,
	bcm_field_range_t * range_id,
	uint32 create_flags,
	int count,
	uint32 * range_flags,
	uint32 * min_value,
	uint32 * max_value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_MULTI_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_multi_create.unit = unit;
	async->args.field_range_multi_create.range_id = range_id;
	async->args.field_range_multi_create.create_flags = create_flags;
	async->args.field_range_multi_create.count = count;
	async->args.field_range_multi_create.range_flags = range_flags;
	async->args.field_range_multi_create.min_value = min_value;
	async->args.field_range_multi_create.max_value = max_value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_range_multi_get_async(
	int unit,
	bcm_field_range_t range_id,
	int max_count,
	uint32 * range_flags,
	uint32 * minimum_value,
	uint32 * maxamum_value,
	int * actual_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RANGE_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_multi_get.unit = unit;
	async->args.field_range_multi_get.range_id = range_id;
	async->args.field_range_multi_get.max_count = max_count;
	async->args.field_range_multi_get.range_flags = range_flags;
	async->args.field_range_multi_get.minimum_value = minimum_value;
	async->args.field_range_multi_get.maxamum_value = maxamum_value;
	async->args.field_range_multi_get.actual_count = actual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_resync_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_RESYNC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_resync.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_sat_macsa_add_async(
	int unit,
	bcm_mac_t mac,
	uint32 class_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SAT_MACSA_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_sat_macsa_add.unit = unit;
	async->args.field_sat_macsa_add.mac = (uint8 *)mac;
	async->args.field_sat_macsa_add.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_sat_macsa_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SAT_MACSA_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_sat_macsa_delete.unit = unit;
	async->args.field_sat_macsa_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_sat_macsa_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SAT_MACSA_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_sat_macsa_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_sat_macsa_get_async(
	int unit,
	bcm_mac_t mac,
	uint32 * class_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SAT_MACSA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_sat_macsa_get.unit = unit;
	async->args.field_sat_macsa_get.mac = (uint8 *)mac;
	async->args.field_sat_macsa_get.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_field_show_async(
	int unit,
	const char * pfx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SHOW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_show.unit = unit;
	async->args.field_show.pfx = (char *)pfx;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_field_source_class_mode_get_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_pbmp_t pbmp,
	bcm_field_src_class_mode_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SOURCE_CLASS_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_source_class_mode_get.unit = unit;
	async->args.field_source_class_mode_get.stage = stage;
	async->args.field_source_class_mode_get.pbmp = pbmp;
	async->args.field_source_class_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_source_class_mode_set_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_pbmp_t pbmp,
	bcm_field_src_class_mode_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_SOURCE_CLASS_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_source_class_mode_set.unit = unit;
	async->args.field_source_class_mode_set.stage = stage;
	async->args.field_source_class_mode_set.pbmp = pbmp;
	async->args.field_source_class_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stage_info_get_async(
	int unit,
	bcm_field_stage_t stage,
	bcm_field_stage_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAGE_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stage_info_get.unit = unit;
	async->args.field_stage_info_get.stage = stage;
	async->args.field_stage_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_all_set_async(
	int unit,
	int stat_id,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_ALL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_all_set.unit = unit;
	async->args.field_stat_all_set.stat_id = stat_id;
	async->args.field_stat_all_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_all_set32_async(
	int unit,
	int stat_id,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_ALL_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_all_set32.unit = unit;
	async->args.field_stat_all_set32.stat_id = stat_id;
	async->args.field_stat_all_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_attach_async(
	int unit,
	bcm_field_group_t group,
	uint32 stat_counter_id,
	uint32 * stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_attach.unit = unit;
	async->args.field_stat_attach.group = group;
	async->args.field_stat_attach.stat_counter_id = stat_counter_id;
	async->args.field_stat_attach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_config_get_async(
	int unit,
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_config_get.unit = unit;
	async->args.field_stat_config_get.stat_id = stat_id;
	async->args.field_stat_config_get.nstat = nstat;
	async->args.field_stat_config_get.stat_arr = stat_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_counter_get_async(
	int unit,
	uint32 stat_id,
	bcm_field_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_counter_get.unit = unit;
	async->args.field_stat_counter_get.stat_id = stat_id;
	async->args.field_stat_counter_get.stat = stat;
	async->args.field_stat_counter_get.num_entries = num_entries;
	async->args.field_stat_counter_get.counter_indexes = counter_indexes;
	async->args.field_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_counter_set_async(
	int unit,
	uint32 stat_id,
	bcm_field_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_counter_set.unit = unit;
	async->args.field_stat_counter_set.stat_id = stat_id;
	async->args.field_stat_counter_set.stat = stat;
	async->args.field_stat_counter_set.num_entries = num_entries;
	async->args.field_stat_counter_set.counter_indexes = counter_indexes;
	async->args.field_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_counter_sync_get_async(
	int unit,
	uint32 stat_id,
	bcm_field_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_counter_sync_get.unit = unit;
	async->args.field_stat_counter_sync_get.stat_id = stat_id;
	async->args.field_stat_counter_sync_get.stat = stat;
	async->args.field_stat_counter_sync_get.num_entries = num_entries;
	async->args.field_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.field_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_create_async(
	int unit,
	bcm_field_group_t group,
	int nstat,
	bcm_field_stat_t * stat_arr,
	int * stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_create.unit = unit;
	async->args.field_stat_create.group = group;
	async->args.field_stat_create.nstat = nstat;
	async->args.field_stat_create.stat_arr = stat_arr;
	async->args.field_stat_create.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_create_id_async(
	int unit,
	bcm_field_group_t group,
	int nstat,
	bcm_field_stat_t * stat_arr,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_create_id.unit = unit;
	async->args.field_stat_create_id.group = group;
	async->args.field_stat_create_id.nstat = nstat;
	async->args.field_stat_create_id.stat_arr = stat_arr;
	async->args.field_stat_create_id.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_destroy_async(
	int unit,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_destroy.unit = unit;
	async->args.field_stat_destroy.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_detach_async(
	int unit,
	uint32 stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_detach.unit = unit;
	async->args.field_stat_detach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_get_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_get.unit = unit;
	async->args.field_stat_get.stat_id = stat_id;
	async->args.field_stat_get.stat = stat;
	async->args.field_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_get32_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_get32.unit = unit;
	async->args.field_stat_get32.stat_id = stat_id;
	async->args.field_stat_get32.stat = stat;
	async->args.field_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_id_get_async(
	int unit,
	bcm_field_group_t group,
	uint32 stat_id,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_id_get.unit = unit;
	async->args.field_stat_id_get.group = group;
	async->args.field_stat_id_get.stat_id = stat_id;
	async->args.field_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_multi_get_async(
	int unit,
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_multi_get.unit = unit;
	async->args.field_stat_multi_get.stat_id = stat_id;
	async->args.field_stat_multi_get.nstat = nstat;
	async->args.field_stat_multi_get.stat_arr = stat_arr;
	async->args.field_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_multi_get32_async(
	int unit,
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_multi_get32.unit = unit;
	async->args.field_stat_multi_get32.stat_id = stat_id;
	async->args.field_stat_multi_get32.nstat = nstat;
	async->args.field_stat_multi_get32.stat_arr = stat_arr;
	async->args.field_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_set_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_set.unit = unit;
	async->args.field_stat_set.stat_id = stat_id;
	async->args.field_stat_set.stat = stat;
	async->args.field_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_set32_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_set32.unit = unit;
	async->args.field_stat_set32.stat_id = stat_id;
	async->args.field_stat_set32.stat = stat;
	async->args.field_stat_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_size_async(
	int unit,
	int stat_id,
	int * stat_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_SIZE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_size.unit = unit;
	async->args.field_stat_size.stat_id = stat_id;
	async->args.field_stat_size.stat_size = stat_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_sync_get_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_sync_get.unit = unit;
	async->args.field_stat_sync_get.stat_id = stat_id;
	async->args.field_stat_sync_get.stat = stat;
	async->args.field_stat_sync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_field_stat_sync_get32_async(
	int unit,
	int stat_id,
	bcm_field_stat_t stat,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIELD_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_sync_get32.unit = unit;
	async->args.field_stat_sync_get32.stat_id = stat_id;
	async->args.field_stat_sync_get32.stat = stat;
	async->args.field_stat_sync_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_find_async(
	char * type,
	char * subtype,
	int remunit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.find.type = type;
	async->args.find.subtype = subtype;
	async->args.find.remunit = remunit;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_I2C

void
bcm_i2c_ioctl_async(
	int unit,
	int fd,
	int opcode,
	void * data,
	int len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_I2C_IOCTL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.i2c_ioctl.unit = unit;
	async->args.i2c_ioctl.fd = fd;
	async->args.i2c_ioctl.opcode = opcode;
	async->args.i2c_ioctl.data = data;
	async->args.i2c_ioctl.len = len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_i2c_open_async(
	int unit,
	char * devname,
	uint32 flags,
	int speed,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_I2C_OPEN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.i2c_open.unit = unit;
	async->args.i2c_open.devname = devname;
	async->args.i2c_open.flags = flags;
	async->args.i2c_open.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_i2c_read_async(
	int unit,
	int fd,
	uint32 addr,
	uint8 * data,
	uint32 * nbytes,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_I2C_READ;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.i2c_read.unit = unit;
	async->args.i2c_read.fd = fd;
	async->args.i2c_read.addr = addr;
	async->args.i2c_read.data = data;
	async->args.i2c_read.nbytes = nbytes;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_i2c_write_async(
	int unit,
	int fd,
	uint32 addr,
	uint8 * data,
	uint32 nbytes,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_I2C_WRITE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.i2c_write.unit = unit;
	async->args.i2c_write.fd = fd;
	async->args.i2c_write.addr = addr;
	async->args.i2c_write.data = data;
	async->args.i2c_write.nbytes = nbytes;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_I2C */

void
bcm_info_get_async(
	int unit,
	bcm_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.info_get.unit = unit;
	async->args.info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_init_check_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_INIT_CHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.init_check.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_init_selective_async(
	int unit,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_INIT_SELECTIVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.init_selective.unit = unit;
	async->args.init_selective.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ip6_mask_create_async(
	bcm_ip6_t ip6,
	int len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IP6_MASK_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ip6_mask_create.ip6 = (uint8 *)ip6;
	async->args.ip6_mask_create.len = len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ip6_mask_length_async(
	bcm_ip6_t mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IP6_MASK_LENGTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ip6_mask_length.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

/* bcm_ip_mask_create has a non int return type */
void
bcm_ip_mask_length_async(
	bcm_ip_t ip,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IP_MASK_LENGTH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ip_mask_length.ip = ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_config_get_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_port_t port,
	bcm_ipfix_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_config_get.unit = unit;
	async->args.ipfix_config_get.stage = stage;
	async->args.ipfix_config_get.port = port;
	async->args.ipfix_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_config_set_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_port_t port,
	bcm_ipfix_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_config_set.unit = unit;
	async->args.ipfix_config_set.stage = stage;
	async->args.ipfix_config_set.port = port;
	async->args.ipfix_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_config_get_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_ipfix_mirror_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_config_get.unit = unit;
	async->args.ipfix_mirror_config_get.stage = stage;
	async->args.ipfix_mirror_config_get.port = port;
	async->args.ipfix_mirror_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_config_set_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_ipfix_mirror_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_config_set.unit = unit;
	async->args.ipfix_mirror_config_set.stage = stage;
	async->args.ipfix_mirror_config_set.port = port;
	async->args.ipfix_mirror_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_port_dest_add_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_add.unit = unit;
	async->args.ipfix_mirror_port_dest_add.stage = stage;
	async->args.ipfix_mirror_port_dest_add.port = port;
	async->args.ipfix_mirror_port_dest_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_port_dest_delete_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_delete.unit = unit;
	async->args.ipfix_mirror_port_dest_delete.stage = stage;
	async->args.ipfix_mirror_port_dest_delete.port = port;
	async->args.ipfix_mirror_port_dest_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_port_dest_delete_all_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_delete_all.unit = unit;
	async->args.ipfix_mirror_port_dest_delete_all.stage = stage;
	async->args.ipfix_mirror_port_dest_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_mirror_port_dest_get_async(
	int unit,
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest_id,
	int * mirror_dest_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_get.unit = unit;
	async->args.ipfix_mirror_port_dest_get.stage = stage;
	async->args.ipfix_mirror_port_dest_get.port = port;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_size = mirror_dest_size;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_id = mirror_dest_id;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_create_async(
	int unit,
	bcm_ipfix_rate_t * rate_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_create.unit = unit;
	async->args.ipfix_rate_create.rate_info = rate_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_destroy_async(
	int unit,
	bcm_ipfix_rate_id_t rate_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_destroy.unit = unit;
	async->args.ipfix_rate_destroy.rate_id = rate_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_get_async(
	int unit,
	bcm_ipfix_rate_t * rate_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_get.unit = unit;
	async->args.ipfix_rate_get.rate_info = rate_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_mirror_add_async(
	int unit,
	bcm_ipfix_rate_id_t rate_id,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_add.unit = unit;
	async->args.ipfix_rate_mirror_add.rate_id = rate_id;
	async->args.ipfix_rate_mirror_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_mirror_delete_async(
	int unit,
	bcm_ipfix_rate_id_t rate_id,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_delete.unit = unit;
	async->args.ipfix_rate_mirror_delete.rate_id = rate_id;
	async->args.ipfix_rate_mirror_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_mirror_delete_all_async(
	int unit,
	bcm_ipfix_rate_id_t rate_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_delete_all.unit = unit;
	async->args.ipfix_rate_mirror_delete_all.rate_id = rate_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_mirror_get_async(
	int unit,
	bcm_ipfix_rate_id_t rate_id,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest_id,
	int * mirror_dest_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_get.unit = unit;
	async->args.ipfix_rate_mirror_get.rate_id = rate_id;
	async->args.ipfix_rate_mirror_get.mirror_dest_size = mirror_dest_size;
	async->args.ipfix_rate_mirror_get.mirror_dest_id = mirror_dest_id;
	async->args.ipfix_rate_mirror_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_rate_traverse_async(
	int unit,
	bcm_ipfix_rate_traverse_cb cb,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_RATE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_traverse.unit = unit;
	async->args.ipfix_rate_traverse.cb = cb;
	async->args.ipfix_rate_traverse.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_register_async(
	int unit,
	bcm_ipfix_callback_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_register.unit = unit;
	async->args.ipfix_register.callback = callback;
	async->args.ipfix_register.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipfix_unregister_async(
	int unit,
	bcm_ipfix_callback_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPFIX_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_unregister.unit = unit;
	async->args.ipfix_unregister.callback = callback;
	async->args.ipfix_unregister.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_ipmc_add_async(
	int unit,
	bcm_ipmc_addr_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_add.unit = unit;
	async->args.ipmc_add.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_age_async(
	int unit,
	uint32 flags,
	bcm_ipmc_traverse_cb age_cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_AGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_age.unit = unit;
	async->args.ipmc_age.flags = flags;
	async->args.ipmc_age.age_cb = age_cb;
	async->args.ipmc_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_bitmap_del_async(
	int unit,
	int ipmc_idx,
	bcm_port_t port,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_BITMAP_DEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_bitmap_del.unit = unit;
	async->args.ipmc_bitmap_del.ipmc_idx = ipmc_idx;
	async->args.ipmc_bitmap_del.port = port;
	async->args.ipmc_bitmap_del.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_bitmap_get_async(
	int unit,
	int ipmc_idx,
	bcm_port_t port,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_BITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_bitmap_get.unit = unit;
	async->args.ipmc_bitmap_get.ipmc_idx = ipmc_idx;
	async->args.ipmc_bitmap_get.port = port;
	async->args.ipmc_bitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_bitmap_max_get_async(
	int unit,
	int * max_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_BITMAP_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_bitmap_max_get.unit = unit;
	async->args.ipmc_bitmap_max_get.max_index = max_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_bitmap_set_async(
	int unit,
	int ipmc_idx,
	bcm_port_t port,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_BITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_bitmap_set.unit = unit;
	async->args.ipmc_bitmap_set.ipmc_idx = ipmc_idx;
	async->args.ipmc_bitmap_set.port = port;
	async->args.ipmc_bitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_counters_get_async(
	int unit,
	bcm_port_t port,
	bcm_ipmc_counters_t * counters,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_COUNTERS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_counters_get.unit = unit;
	async->args.ipmc_counters_get.port = port;
	async->args.ipmc_counters_get.counters = counters;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_egress_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_mac_t mac,
	int * untag,
	bcm_vlan_t * vid,
	int * ttl_threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_egress_port_get.unit = unit;
	async->args.ipmc_egress_port_get.port = port;
	async->args.ipmc_egress_port_get.mac = (uint8 *)mac;
	async->args.ipmc_egress_port_get.untag = untag;
	async->args.ipmc_egress_port_get.vid = vid;
	async->args.ipmc_egress_port_get.ttl_threshold = ttl_threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_egress_port_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_egress_port_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_egress_port_set_async(
	int unit,
	bcm_port_t port,
	const bcm_mac_t mac,
	int untag,
	bcm_vlan_t vid,
	int ttl_threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_egress_port_set.unit = unit;
	async->args.ipmc_egress_port_set.port = port;
	async->args.ipmc_egress_port_set.mac = (uint8 *)mac;
	async->args.ipmc_egress_port_set.untag = untag;
	async->args.ipmc_egress_port_set.vid = vid;
	async->args.ipmc_egress_port_set.ttl_threshold = ttl_threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_enable_async(
	int unit,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_enable.unit = unit;
	async->args.ipmc_enable.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_find_async(
	int unit,
	bcm_ipmc_addr_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_find.unit = unit;
	async->args.ipmc_find.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_range_add_async(
	int unit,
	int * range_id,
	bcm_ipmc_range_t * range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RANGE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_range_add.unit = unit;
	async->args.ipmc_range_add.range_id = range_id;
	async->args.ipmc_range_add.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_range_delete_async(
	int unit,
	int range_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RANGE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_range_delete.unit = unit;
	async->args.ipmc_range_delete.range_id = range_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_range_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RANGE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_range_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_range_get_async(
	int unit,
	int range_id,
	bcm_ipmc_range_t * range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_range_get.unit = unit;
	async->args.ipmc_range_get.range_id = range_id;
	async->args.ipmc_range_get.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_range_size_get_async(
	int unit,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RANGE_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_range_size_get.unit = unit;
	async->args.ipmc_range_size_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_remove_async(
	int unit,
	bcm_ipmc_addr_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_remove.unit = unit;
	async->args.ipmc_remove.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_remove_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_REMOVE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_remove_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_add_async(
	int unit,
	int rp_id,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_add.unit = unit;
	async->args.ipmc_rp_add.rp_id = rp_id;
	async->args.ipmc_rp_add.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_create_async(
	int unit,
	uint32 flags,
	int * rp_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_create.unit = unit;
	async->args.ipmc_rp_create.flags = flags;
	async->args.ipmc_rp_create.rp_id = rp_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_delete_async(
	int unit,
	int rp_id,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_delete.unit = unit;
	async->args.ipmc_rp_delete.rp_id = rp_id;
	async->args.ipmc_rp_delete.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_delete_all_async(
	int unit,
	int rp_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_delete_all.unit = unit;
	async->args.ipmc_rp_delete_all.rp_id = rp_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_destroy_async(
	int unit,
	int rp_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_destroy.unit = unit;
	async->args.ipmc_rp_destroy.rp_id = rp_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_get_async(
	int unit,
	int rp_id,
	int intf_max,
	bcm_if_t * intf_array,
	int * intf_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_get.unit = unit;
	async->args.ipmc_rp_get.rp_id = rp_id;
	async->args.ipmc_rp_get.intf_max = intf_max;
	async->args.ipmc_rp_get.intf_array = intf_array;
	async->args.ipmc_rp_get.intf_count = intf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_rp_set_async(
	int unit,
	int rp_id,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_RP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_rp_set.unit = unit;
	async->args.ipmc_rp_set.rp_id = rp_id;
	async->args.ipmc_rp_set.intf_count = intf_count;
	async->args.ipmc_rp_set.intf_array = intf_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_attach_async(
	int unit,
	bcm_ipmc_addr_t * info,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_attach.unit = unit;
	async->args.ipmc_stat_attach.info = info;
	async->args.ipmc_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_counter_get_async(
	int unit,
	bcm_ipmc_addr_t * info,
	bcm_ipmc_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_counter_get.unit = unit;
	async->args.ipmc_stat_counter_get.info = info;
	async->args.ipmc_stat_counter_get.stat = stat;
	async->args.ipmc_stat_counter_get.num_entries = num_entries;
	async->args.ipmc_stat_counter_get.counter_indexes = counter_indexes;
	async->args.ipmc_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_counter_set_async(
	int unit,
	bcm_ipmc_addr_t * info,
	bcm_ipmc_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_counter_set.unit = unit;
	async->args.ipmc_stat_counter_set.info = info;
	async->args.ipmc_stat_counter_set.stat = stat;
	async->args.ipmc_stat_counter_set.num_entries = num_entries;
	async->args.ipmc_stat_counter_set.counter_indexes = counter_indexes;
	async->args.ipmc_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_counter_sync_get_async(
	int unit,
	bcm_ipmc_addr_t * info,
	bcm_ipmc_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_counter_sync_get.unit = unit;
	async->args.ipmc_stat_counter_sync_get.info = info;
	async->args.ipmc_stat_counter_sync_get.stat = stat;
	async->args.ipmc_stat_counter_sync_get.num_entries = num_entries;
	async->args.ipmc_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.ipmc_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_detach_async(
	int unit,
	bcm_ipmc_addr_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_detach.unit = unit;
	async->args.ipmc_stat_detach.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_id_get_async(
	int unit,
	bcm_ipmc_addr_t * info,
	bcm_ipmc_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_id_get.unit = unit;
	async->args.ipmc_stat_id_get.info = info;
	async->args.ipmc_stat_id_get.stat = stat;
	async->args.ipmc_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_multi_get_async(
	int unit,
	bcm_ipmc_addr_t * info,
	int nstat,
	bcm_ipmc_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_multi_get.unit = unit;
	async->args.ipmc_stat_multi_get.info = info;
	async->args.ipmc_stat_multi_get.nstat = nstat;
	async->args.ipmc_stat_multi_get.stat_arr = stat_arr;
	async->args.ipmc_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_multi_get32_async(
	int unit,
	bcm_ipmc_addr_t * info,
	int nstat,
	bcm_ipmc_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_multi_get32.unit = unit;
	async->args.ipmc_stat_multi_get32.info = info;
	async->args.ipmc_stat_multi_get32.nstat = nstat;
	async->args.ipmc_stat_multi_get32.stat_arr = stat_arr;
	async->args.ipmc_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_multi_set_async(
	int unit,
	bcm_ipmc_addr_t * info,
	int nstat,
	bcm_ipmc_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_multi_set.unit = unit;
	async->args.ipmc_stat_multi_set.info = info;
	async->args.ipmc_stat_multi_set.nstat = nstat;
	async->args.ipmc_stat_multi_set.stat_arr = stat_arr;
	async->args.ipmc_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_stat_multi_set32_async(
	int unit,
	bcm_ipmc_addr_t * info,
	int nstat,
	bcm_ipmc_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_stat_multi_set32.unit = unit;
	async->args.ipmc_stat_multi_set32.info = info;
	async->args.ipmc_stat_multi_set32.nstat = nstat;
	async->args.ipmc_stat_multi_set32.stat_arr = stat_arr;
	async->args.ipmc_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipmc_traverse_async(
	int unit,
	uint32 flags,
	bcm_ipmc_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPMC_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_traverse.unit = unit;
	async->args.ipmc_traverse.flags = flags;
	async->args.ipmc_traverse.cb = cb;
	async->args.ipmc_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_ipsec_config_set_async(
	int unit,
	bcm_ipsec_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_config_set.unit = unit;
	async->args.ipsec_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_sa_create_async(
	int unit,
	uint32 flags,
	uint32 * sa_id,
	bcm_ipsec_sa_info_t * sa,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_SA_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_sa_create.unit = unit;
	async->args.ipsec_sa_create.flags = flags;
	async->args.ipsec_sa_create.sa_id = sa_id;
	async->args.ipsec_sa_create.sa = sa;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_sa_delete_async(
	int unit,
	uint32 flags,
	uint32 sa_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_SA_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_sa_delete.unit = unit;
	async->args.ipsec_sa_delete.flags = flags;
	async->args.ipsec_sa_delete.sa_id = sa_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_sa_key_update_async(
	int unit,
	uint32 flags,
	uint32 sa_id,
	bcm_ipsec_sa_keys_t * sa_keys,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_SA_KEY_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_sa_key_update.unit = unit;
	async->args.ipsec_sa_key_update.flags = flags;
	async->args.ipsec_sa_key_update.sa_id = sa_id;
	async->args.ipsec_sa_key_update.sa_keys = sa_keys;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_sa_to_tunnel_map_get_async(
	int unit,
	uint32 sa_id,
	uint32 * tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_SA_TO_TUNNEL_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_sa_to_tunnel_map_get.unit = unit;
	async->args.ipsec_sa_to_tunnel_map_get.sa_id = sa_id;
	async->args.ipsec_sa_to_tunnel_map_get.tunnel_id = tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_sa_to_tunnel_map_set_async(
	int unit,
	uint32 tunnel_id,
	uint32 sa_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_SA_TO_TUNNEL_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_sa_to_tunnel_map_set.unit = unit;
	async->args.ipsec_sa_to_tunnel_map_set.tunnel_id = tunnel_id;
	async->args.ipsec_sa_to_tunnel_map_set.sa_id = sa_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_tunnel_create_async(
	int unit,
	uint32 flags,
	uint32 * tunnel_id,
	bcm_ipsec_tunnel_info_t * tunnel_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_TUNNEL_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_tunnel_create.unit = unit;
	async->args.ipsec_tunnel_create.flags = flags;
	async->args.ipsec_tunnel_create.tunnel_id = tunnel_id;
	async->args.ipsec_tunnel_create.tunnel_info = tunnel_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ipsec_tunnel_delete_async(
	int unit,
	uint32 flags,
	uint32 tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_IPSEC_TUNNEL_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipsec_tunnel_delete.unit = unit;
	async->args.ipsec_tunnel_delete.flags = flags;
	async->args.ipsec_tunnel_delete.tunnel_id = tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_filter_create_async(
	int unit,
	bcm_knet_filter_t * filter,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_FILTER_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_filter_create.unit = unit;
	async->args.knet_filter_create.filter = filter;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_filter_destroy_async(
	int unit,
	int filter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_FILTER_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_filter_destroy.unit = unit;
	async->args.knet_filter_destroy.filter_id = filter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_filter_get_async(
	int unit,
	int filter_id,
	bcm_knet_filter_t * filter,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_FILTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_filter_get.unit = unit;
	async->args.knet_filter_get.filter_id = filter_id;
	async->args.knet_filter_get.filter = filter;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_filter_traverse_async(
	int unit,
	bcm_knet_filter_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_FILTER_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_filter_traverse.unit = unit;
	async->args.knet_filter_traverse.trav_fn = trav_fn;
	async->args.knet_filter_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_netif_create_async(
	int unit,
	bcm_knet_netif_t * netif,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_NETIF_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_netif_create.unit = unit;
	async->args.knet_netif_create.netif = netif;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_netif_destroy_async(
	int unit,
	int netif_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_NETIF_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_netif_destroy.unit = unit;
	async->args.knet_netif_destroy.netif_id = netif_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_netif_get_async(
	int unit,
	int netif_id,
	bcm_knet_netif_t * netif,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_NETIF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_netif_get.unit = unit;
	async->args.knet_netif_get.netif_id = netif_id;
	async->args.knet_netif_get.netif = netif;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_knet_netif_traverse_async(
	int unit,
	bcm_knet_netif_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_KNET_NETIF_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.knet_netif_traverse.unit = unit;
	async->args.knet_netif_traverse.trav_fn = trav_fn;
	async->args.knet_netif_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_add_async(
	int unit,
	bcm_l2_addr_t * l2addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_add.unit = unit;
	async->args.l2_addr_add.l2addr = l2addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete.unit = unit;
	async->args.l2_addr_delete.mac = (uint8 *)mac;
	async->args.l2_addr_delete.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_mac_async(
	int unit,
	bcm_mac_t mac,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_mac.unit = unit;
	async->args.l2_addr_delete_by_mac.mac = (uint8 *)mac;
	async->args.l2_addr_delete_by_mac.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_mac_port_async(
	int unit,
	bcm_mac_t mac,
	bcm_module_t mod,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC_PORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_mac_port.unit = unit;
	async->args.l2_addr_delete_by_mac_port.mac = (uint8 *)mac;
	async->args.l2_addr_delete_by_mac_port.mod = mod;
	async->args.l2_addr_delete_by_mac_port.port = port;
	async->args.l2_addr_delete_by_mac_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_port_async(
	int unit,
	bcm_module_t mod,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_PORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_port.unit = unit;
	async->args.l2_addr_delete_by_port.mod = mod;
	async->args.l2_addr_delete_by_port.port = port;
	async->args.l2_addr_delete_by_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_trunk_async(
	int unit,
	bcm_trunk_t tid,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_TRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_trunk.unit = unit;
	async->args.l2_addr_delete_by_trunk.tid = tid;
	async->args.l2_addr_delete_by_trunk.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_vlan_async(
	int unit,
	bcm_vlan_t vid,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan.unit = unit;
	async->args.l2_addr_delete_by_vlan.vid = vid;
	async->args.l2_addr_delete_by_vlan.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_vlan_gport_multi_async(
	int unit,
	uint32 flags,
	int num_pairs,
	bcm_vlan_t * vlan,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_GPORT_MULTI;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan_gport_multi.unit = unit;
	async->args.l2_addr_delete_by_vlan_gport_multi.flags = flags;
	async->args.l2_addr_delete_by_vlan_gport_multi.num_pairs = num_pairs;
	async->args.l2_addr_delete_by_vlan_gport_multi.vlan = vlan;
	async->args.l2_addr_delete_by_vlan_gport_multi.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_vlan_port_async(
	int unit,
	bcm_vlan_t vid,
	bcm_module_t mod,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_PORT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan_port.unit = unit;
	async->args.l2_addr_delete_by_vlan_port.vid = vid;
	async->args.l2_addr_delete_by_vlan_port.mod = mod;
	async->args.l2_addr_delete_by_vlan_port.port = port;
	async->args.l2_addr_delete_by_vlan_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_delete_by_vlan_trunk_async(
	int unit,
	bcm_vlan_t vid,
	bcm_trunk_t tid,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_TRUNK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan_trunk.unit = unit;
	async->args.l2_addr_delete_by_vlan_trunk.vid = vid;
	async->args.l2_addr_delete_by_vlan_trunk.tid = tid;
	async->args.l2_addr_delete_by_vlan_trunk.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_freeze_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_FREEZE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_freeze.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_get_async(
	int unit,
	bcm_mac_t mac_addr,
	bcm_vlan_t vid,
	bcm_l2_addr_t * l2addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_get.unit = unit;
	async->args.l2_addr_get.mac_addr = (uint8 *)mac_addr;
	async->args.l2_addr_get.vid = vid;
	async->args.l2_addr_get.l2addr = l2addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_msg_distribute_get_async(
	int unit,
	bcm_l2_addr_distribute_t * distribution,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_MSG_DISTRIBUTE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_msg_distribute_get.unit = unit;
	async->args.l2_addr_msg_distribute_get.distribution = distribution;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_msg_distribute_set_async(
	int unit,
	bcm_l2_addr_distribute_t * distribution,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_MSG_DISTRIBUTE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_msg_distribute_set.unit = unit;
	async->args.l2_addr_msg_distribute_set.distribution = distribution;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_multi_add_async(
	int unit,
	bcm_l2_addr_t * l2addr,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_MULTI_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_multi_add.unit = unit;
	async->args.l2_addr_multi_add.l2addr = l2addr;
	async->args.l2_addr_multi_add.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_multi_delete_async(
	int unit,
	bcm_l2_addr_t * l2addr,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_MULTI_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_multi_delete.unit = unit;
	async->args.l2_addr_multi_delete.l2addr = l2addr;
	async->args.l2_addr_multi_delete.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_register_async(
	int unit,
	bcm_l2_addr_callback_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_register.unit = unit;
	async->args.l2_addr_register.callback = callback;
	async->args.l2_addr_register.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_thaw_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_THAW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_thaw.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_addr_unregister_async(
	int unit,
	bcm_l2_addr_callback_t callback,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_ADDR_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_unregister.unit = unit;
	async->args.l2_addr_unregister.callback = callback;
	async->args.l2_addr_unregister.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_age_timer_get_async(
	int unit,
	int * age_seconds,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AGE_TIMER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_age_timer_get.unit = unit;
	async->args.l2_age_timer_get.age_seconds = age_seconds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_age_timer_set_async(
	int unit,
	int age_seconds,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AGE_TIMER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_age_timer_set.unit = unit;
	async->args.l2_age_timer_set.age_seconds = age_seconds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_auth_add_async(
	int unit,
	bcm_l2_auth_addr_t * addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AUTH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_auth_add.unit = unit;
	async->args.l2_auth_add.addr = addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_auth_delete_async(
	int unit,
	bcm_l2_auth_addr_t * addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AUTH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_auth_delete.unit = unit;
	async->args.l2_auth_delete.addr = addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_auth_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AUTH_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_auth_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_auth_get_async(
	int unit,
	bcm_l2_auth_addr_t * addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AUTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_auth_get.unit = unit;
	async->args.l2_auth_get.addr = addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_auth_traverse_async(
	int unit,
	bcm_l2_auth_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_AUTH_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_auth_traverse.unit = unit;
	async->args.l2_auth_traverse.trav_fn = trav_fn;
	async->args.l2_auth_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_delete_async(
	int unit,
	int index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_delete.unit = unit;
	async->args.l2_cache_delete.index = index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_get_async(
	int unit,
	int index,
	bcm_l2_cache_addr_t * addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_get.unit = unit;
	async->args.l2_cache_get.index = index;
	async->args.l2_cache_get.addr = addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_profile_get_async(
	int unit,
	int trap_type,
	uint32 profile_idx,
	uint32 flags,
	bcm_l2cp_profile_info_t * l2cp_profile_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_profile_get.unit = unit;
	async->args.l2_cache_profile_get.trap_type = trap_type;
	async->args.l2_cache_profile_get.profile_idx = profile_idx;
	async->args.l2_cache_profile_get.flags = flags;
	async->args.l2_cache_profile_get.l2cp_profile_info = l2cp_profile_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_profile_set_async(
	int unit,
	int trap_type,
	uint32 profile_idx,
	uint32 flags,
	bcm_l2cp_profile_info_t * l2cp_profile_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_profile_set.unit = unit;
	async->args.l2_cache_profile_set.trap_type = trap_type;
	async->args.l2_cache_profile_set.profile_idx = profile_idx;
	async->args.l2_cache_profile_set.flags = flags;
	async->args.l2_cache_profile_set.l2cp_profile_info = l2cp_profile_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_set_async(
	int unit,
	int index,
	bcm_l2_cache_addr_t * addr,
	int * index_used,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_set.unit = unit;
	async->args.l2_cache_set.index = index;
	async->args.l2_cache_set.addr = addr;
	async->args.l2_cache_set.index_used = index_used;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_size_get_async(
	int unit,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_size_get.unit = unit;
	async->args.l2_cache_size_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_vpn_to_profile_map_get_async(
	int unit,
	uint32 vsi,
	uint32 * profile_idx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_VPN_TO_PROFILE_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_vpn_to_profile_map_get.unit = unit;
	async->args.l2_cache_vpn_to_profile_map_get.vsi = vsi;
	async->args.l2_cache_vpn_to_profile_map_get.profile_idx = profile_idx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_cache_vpn_to_profile_map_set_async(
	int unit,
	uint32 vsi,
	uint32 profile_idx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CACHE_VPN_TO_PROFILE_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_vpn_to_profile_map_set.unit = unit;
	async->args.l2_cache_vpn_to_profile_map_set.vsi = vsi;
	async->args.l2_cache_vpn_to_profile_map_set.profile_idx = profile_idx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_clear_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_clear.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_conflict_get_async(
	int unit,
	bcm_l2_addr_t * addr,
	bcm_l2_addr_t * cf_array,
	int cf_max,
	int * cf_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_CONFLICT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_conflict_get.unit = unit;
	async->args.l2_conflict_get.addr = addr;
	async->args.l2_conflict_get.cf_array = cf_array;
	async->args.l2_conflict_get.cf_max = cf_max;
	async->args.l2_conflict_get.cf_count = cf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_egress_create_async(
	int unit,
	bcm_l2_egress_t * egr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_EGRESS_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_egress_create.unit = unit;
	async->args.l2_egress_create.egr = egr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_egress_destroy_async(
	int unit,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_EGRESS_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_egress_destroy.unit = unit;
	async->args.l2_egress_destroy.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_egress_find_async(
	int unit,
	bcm_l2_egress_t * egr,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_EGRESS_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_egress_find.unit = unit;
	async->args.l2_egress_find.egr = egr;
	async->args.l2_egress_find.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_egress_get_async(
	int unit,
	bcm_if_t encap_id,
	bcm_l2_egress_t * egr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_egress_get.unit = unit;
	async->args.l2_egress_get.encap_id = encap_id;
	async->args.l2_egress_get.egr = egr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_egress_traverse_async(
	int unit,
	bcm_l2_egress_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_EGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_egress_traverse.unit = unit;
	async->args.l2_egress_traverse.trav_fn = trav_fn;
	async->args.l2_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_gport_forward_info_get_async(
	int unit,
	int gport_id,
	bcm_l2_gport_forward_info_t * forward_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_GPORT_FORWARD_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_gport_forward_info_get.unit = unit;
	async->args.l2_gport_forward_info_get.gport_id = gport_id;
	async->args.l2_gport_forward_info_get.forward_info = forward_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_key_dump_async(
	int unit,
	char * pfx,
	bcm_l2_addr_t * entry,
	char * sfx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_KEY_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_key_dump.unit = unit;
	async->args.l2_key_dump.pfx = pfx;
	async->args.l2_key_dump.entry = entry;
	async->args.l2_key_dump.sfx = sfx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_class_get_async(
	int unit,
	int lclass,
	int * lclass_prio,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_class_get.unit = unit;
	async->args.l2_learn_class_get.lclass = lclass;
	async->args.l2_learn_class_get.lclass_prio = lclass_prio;
	async->args.l2_learn_class_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_class_set_async(
	int unit,
	int lclass,
	int lclass_prio,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_CLASS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_class_set.unit = unit;
	async->args.l2_learn_class_set.lclass = lclass;
	async->args.l2_learn_class_set.lclass_prio = lclass_prio;
	async->args.l2_learn_class_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_limit_disable_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_DISABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_disable.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_limit_enable_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_enable.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_limit_get_async(
	int unit,
	bcm_l2_learn_limit_t * limit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_get.unit = unit;
	async->args.l2_learn_limit_get.limit = limit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_limit_set_async(
	int unit,
	bcm_l2_learn_limit_t * limit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_set.unit = unit;
	async->args.l2_learn_limit_set.limit = limit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_msgs_config_get_async(
	int unit,
	bcm_l2_learn_msgs_config_t * learn_msg_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_MSGS_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_msgs_config_get.unit = unit;
	async->args.l2_learn_msgs_config_get.learn_msg_config = learn_msg_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_msgs_config_set_async(
	int unit,
	bcm_l2_learn_msgs_config_t * learn_msg_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_MSGS_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_msgs_config_set.unit = unit;
	async->args.l2_learn_msgs_config_set.learn_msg_config = learn_msg_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_port_class_get_async(
	int unit,
	bcm_gport_t port,
	int * lclass,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_port_class_get.unit = unit;
	async->args.l2_learn_port_class_get.port = port;
	async->args.l2_learn_port_class_get.lclass = lclass;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_port_class_set_async(
	int unit,
	bcm_gport_t port,
	int lclass,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_port_class_set.unit = unit;
	async->args.l2_learn_port_class_set.port = port;
	async->args.l2_learn_port_class_set.lclass = lclass;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_stat_get_async(
	int unit,
	bcm_l2_learn_stat_t * learn_stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_stat_get.unit = unit;
	async->args.l2_learn_stat_get.learn_stat = learn_stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_learn_stat_set_async(
	int unit,
	bcm_l2_learn_stat_t * learn_stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_LEARN_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_stat_set.unit = unit;
	async->args.l2_learn_stat_set.learn_stat = learn_stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_mac_port_create_async(
	int unit,
	bcm_l2_mac_port_t * mac_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MAC_PORT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_mac_port_create.unit = unit;
	async->args.l2_mac_port_create.mac_port = mac_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_mac_port_destroy_async(
	int unit,
	bcm_gport_t mac_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MAC_PORT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_mac_port_destroy.unit = unit;
	async->args.l2_mac_port_destroy.mac_port_id = mac_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_mac_port_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MAC_PORT_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_mac_port_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_mac_port_get_async(
	int unit,
	bcm_l2_mac_port_t * mac_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MAC_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_mac_port_get.unit = unit;
	async->args.l2_mac_port_get.mac_port = mac_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_mac_port_traverse_async(
	int unit,
	bcm_l2_mac_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MAC_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_mac_port_traverse.unit = unit;
	async->args.l2_mac_port_traverse.cb = cb;
	async->args.l2_mac_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_match_masked_traverse_async(
	int unit,
	uint32 flags,
	bcm_l2_addr_t * match_addr,
	bcm_l2_addr_t * mask_addr,
	bcm_l2_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MATCH_MASKED_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_match_masked_traverse.unit = unit;
	async->args.l2_match_masked_traverse.flags = flags;
	async->args.l2_match_masked_traverse.match_addr = match_addr;
	async->args.l2_match_masked_traverse.mask_addr = mask_addr;
	async->args.l2_match_masked_traverse.trav_fn = trav_fn;
	async->args.l2_match_masked_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_matched_traverse_async(
	int unit,
	uint32 flags,
	bcm_l2_addr_t * match_addr,
	bcm_l2_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_MATCHED_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_matched_traverse.unit = unit;
	async->args.l2_matched_traverse.flags = flags;
	async->args.l2_matched_traverse.match_addr = match_addr;
	async->args.l2_matched_traverse.trav_fn = trav_fn;
	async->args.l2_matched_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_port_native_async(
	int unit,
	int modid,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_PORT_NATIVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_port_native.unit = unit;
	async->args.l2_port_native.modid = modid;
	async->args.l2_port_native.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_replace_async(
	int unit,
	uint32 flags,
	bcm_l2_addr_t * match_addr,
	bcm_module_t new_module,
	bcm_port_t new_port,
	bcm_trunk_t new_trunk,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_REPLACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_replace.unit = unit;
	async->args.l2_replace.flags = flags;
	async->args.l2_replace.match_addr = match_addr;
	async->args.l2_replace.new_module = new_module;
	async->args.l2_replace.new_port = new_port;
	async->args.l2_replace.new_trunk = new_trunk;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_replace_match_async(
	int unit,
	uint32 flags,
	bcm_l2_addr_t * match_addr,
	bcm_l2_addr_t * mask_addr,
	bcm_l2_addr_t * replace_addr,
	bcm_l2_addr_t * replace_mask_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_REPLACE_MATCH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_replace_match.unit = unit;
	async->args.l2_replace_match.flags = flags;
	async->args.l2_replace_match.match_addr = match_addr;
	async->args.l2_replace_match.mask_addr = mask_addr;
	async->args.l2_replace_match.replace_addr = replace_addr;
	async->args.l2_replace_match.replace_mask_addr = replace_mask_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_ring_replace_async(
	int unit,
	bcm_l2_ring_t * l2_ring,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_RING_REPLACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_ring_replace.unit = unit;
	async->args.l2_ring_replace.l2_ring = l2_ring;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_stat_enable_set_async(
	int unit,
	bcm_l2_addr_t * l2_addr,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_stat_enable_set.unit = unit;
	async->args.l2_stat_enable_set.l2_addr = l2_addr;
	async->args.l2_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_stat_get_async(
	int unit,
	bcm_l2_addr_t * l2_addr,
	bcm_l2_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_stat_get.unit = unit;
	async->args.l2_stat_get.l2_addr = l2_addr;
	async->args.l2_stat_get.stat = stat;
	async->args.l2_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_stat_get32_async(
	int unit,
	bcm_l2_addr_t * l2_addr,
	bcm_l2_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_stat_get32.unit = unit;
	async->args.l2_stat_get32.l2_addr = l2_addr;
	async->args.l2_stat_get32.stat = stat;
	async->args.l2_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_stat_set_async(
	int unit,
	bcm_l2_addr_t * l2_addr,
	bcm_l2_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_stat_set.unit = unit;
	async->args.l2_stat_set.l2_addr = l2_addr;
	async->args.l2_stat_set.stat = stat;
	async->args.l2_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_stat_set32_async(
	int unit,
	bcm_l2_addr_t * l2_addr,
	bcm_l2_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_stat_set32.unit = unit;
	async->args.l2_stat_set32.l2_addr = l2_addr;
	async->args.l2_stat_set32.stat = stat;
	async->args.l2_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_add_async(
	int unit,
	int * station_id,
	bcm_l2_station_t * station,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_add.unit = unit;
	async->args.l2_station_add.station_id = station_id;
	async->args.l2_station_add.station = station;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_delete_async(
	int unit,
	int station_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_delete.unit = unit;
	async->args.l2_station_delete.station_id = station_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_get_async(
	int unit,
	int station_id,
	bcm_l2_station_t * station,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_get.unit = unit;
	async->args.l2_station_get.station_id = station_id;
	async->args.l2_station_get.station = station;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_size_get_async(
	int unit,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_size_get.unit = unit;
	async->args.l2_station_size_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_station_traverse_async(
	int unit,
	bcm_l2_station_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_STATION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_station_traverse.unit = unit;
	async->args.l2_station_traverse.trav_fn = trav_fn;
	async->args.l2_station_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_traverse_async(
	int unit,
	bcm_l2_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_traverse.unit = unit;
	async->args.l2_traverse.trav_fn = trav_fn;
	async->args.l2_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_tunnel_add_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_TUNNEL_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_tunnel_add.unit = unit;
	async->args.l2_tunnel_add.mac = (uint8 *)mac;
	async->args.l2_tunnel_add.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_tunnel_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_TUNNEL_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_tunnel_delete.unit = unit;
	async->args.l2_tunnel_delete.mac = (uint8 *)mac;
	async->args.l2_tunnel_delete.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2_tunnel_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2_TUNNEL_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_tunnel_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_l2gre_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_port_add_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_l2gre_port_t * l2gre_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_port_add.unit = unit;
	async->args.l2gre_port_add.l2vpn = l2vpn;
	async->args.l2gre_port_add.l2gre_port = l2gre_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_port_delete_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_gport_t l2gre_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_port_delete.unit = unit;
	async->args.l2gre_port_delete.l2vpn = l2vpn;
	async->args.l2gre_port_delete.l2gre_port_id = l2gre_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_port_delete_all_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_port_delete_all.unit = unit;
	async->args.l2gre_port_delete_all.l2vpn = l2vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_port_get_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_l2gre_port_t * l2gre_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_port_get.unit = unit;
	async->args.l2gre_port_get.l2vpn = l2vpn;
	async->args.l2gre_port_get.l2gre_port = l2gre_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_port_get_all_async(
	int unit,
	bcm_vpn_t l2vpn,
	int port_max,
	bcm_l2gre_port_t * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_PORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_port_get_all.unit = unit;
	async->args.l2gre_port_get_all.l2vpn = l2vpn;
	async->args.l2gre_port_get_all.port_max = port_max;
	async->args.l2gre_port_get_all.port_array = port_array;
	async->args.l2gre_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_attach_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_attach.unit = unit;
	async->args.l2gre_stat_attach.port = port;
	async->args.l2gre_stat_attach.vpn = vpn;
	async->args.l2gre_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_counter_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_l2gre_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_counter_get.unit = unit;
	async->args.l2gre_stat_counter_get.port = port;
	async->args.l2gre_stat_counter_get.vpn = vpn;
	async->args.l2gre_stat_counter_get.stat = stat;
	async->args.l2gre_stat_counter_get.num_entries = num_entries;
	async->args.l2gre_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l2gre_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_counter_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_l2gre_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_counter_set.unit = unit;
	async->args.l2gre_stat_counter_set.port = port;
	async->args.l2gre_stat_counter_set.vpn = vpn;
	async->args.l2gre_stat_counter_set.stat = stat;
	async->args.l2gre_stat_counter_set.num_entries = num_entries;
	async->args.l2gre_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l2gre_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_counter_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_l2gre_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_counter_sync_get.unit = unit;
	async->args.l2gre_stat_counter_sync_get.port = port;
	async->args.l2gre_stat_counter_sync_get.vpn = vpn;
	async->args.l2gre_stat_counter_sync_get.stat = stat;
	async->args.l2gre_stat_counter_sync_get.num_entries = num_entries;
	async->args.l2gre_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l2gre_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_detach_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_detach.unit = unit;
	async->args.l2gre_stat_detach.port = port;
	async->args.l2gre_stat_detach.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_id_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_l2gre_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_id_get.unit = unit;
	async->args.l2gre_stat_id_get.port = port;
	async->args.l2gre_stat_id_get.vpn = vpn;
	async->args.l2gre_stat_id_get.stat = stat;
	async->args.l2gre_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_multi_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_l2gre_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_multi_get.unit = unit;
	async->args.l2gre_stat_multi_get.port = port;
	async->args.l2gre_stat_multi_get.vpn = vpn;
	async->args.l2gre_stat_multi_get.nstat = nstat;
	async->args.l2gre_stat_multi_get.stat_arr = stat_arr;
	async->args.l2gre_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_multi_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_l2gre_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_multi_get32.unit = unit;
	async->args.l2gre_stat_multi_get32.port = port;
	async->args.l2gre_stat_multi_get32.vpn = vpn;
	async->args.l2gre_stat_multi_get32.nstat = nstat;
	async->args.l2gre_stat_multi_get32.stat_arr = stat_arr;
	async->args.l2gre_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_multi_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_l2gre_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_multi_set.unit = unit;
	async->args.l2gre_stat_multi_set.port = port;
	async->args.l2gre_stat_multi_set.vpn = vpn;
	async->args.l2gre_stat_multi_set.nstat = nstat;
	async->args.l2gre_stat_multi_set.stat_arr = stat_arr;
	async->args.l2gre_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_stat_multi_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_l2gre_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_stat_multi_set32.unit = unit;
	async->args.l2gre_stat_multi_set32.port = port;
	async->args.l2gre_stat_multi_set32.vpn = vpn;
	async->args.l2gre_stat_multi_set32.nstat = nstat;
	async->args.l2gre_stat_multi_set32.stat_arr = stat_arr;
	async->args.l2gre_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_initiator_create_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_INITIATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_initiator_create.unit = unit;
	async->args.l2gre_tunnel_initiator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_initiator_destroy_async(
	int unit,
	bcm_gport_t l2gre_tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_INITIATOR_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_initiator_destroy.unit = unit;
	async->args.l2gre_tunnel_initiator_destroy.l2gre_tunnel_id = l2gre_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_initiator_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_INITIATOR_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_initiator_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_initiator_get_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_INITIATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_initiator_get.unit = unit;
	async->args.l2gre_tunnel_initiator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_initiator_traverse_async(
	int unit,
	bcm_tunnel_initiator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_INITIATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_initiator_traverse.unit = unit;
	async->args.l2gre_tunnel_initiator_traverse.cb = cb;
	async->args.l2gre_tunnel_initiator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_create_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_create.unit = unit;
	async->args.l2gre_tunnel_terminator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_destroy_async(
	int unit,
	bcm_gport_t l2gre_tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_destroy.unit = unit;
	async->args.l2gre_tunnel_terminator_destroy.l2gre_tunnel_id = l2gre_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_get_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_get.unit = unit;
	async->args.l2gre_tunnel_terminator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_traverse_async(
	int unit,
	bcm_tunnel_terminator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_traverse.unit = unit;
	async->args.l2gre_tunnel_terminator_traverse.cb = cb;
	async->args.l2gre_tunnel_terminator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_tunnel_terminator_update_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_TUNNEL_TERMINATOR_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_tunnel_terminator_update.unit = unit;
	async->args.l2gre_tunnel_terminator_update.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_vpn_create_async(
	int unit,
	bcm_l2gre_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_VPN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_vpn_create.unit = unit;
	async->args.l2gre_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_vpn_destroy_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_VPN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_vpn_destroy.unit = unit;
	async->args.l2gre_vpn_destroy.l2vpn = l2vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_vpn_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_VPN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_vpn_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_vpn_get_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_l2gre_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_vpn_get.unit = unit;
	async->args.l2gre_vpn_get.l2vpn = l2vpn;
	async->args.l2gre_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l2gre_vpn_traverse_async(
	int unit,
	bcm_l2gre_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L2GRE_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2gre_vpn_traverse.unit = unit;
	async->args.l2gre_vpn_traverse.cb = cb;
	async->args.l2gre_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_agm_attach_async(
	int unit,
	bcm_if_t l3_ecmp_id,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_AGM_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_agm_attach.unit = unit;
	async->args.l3_ecmp_agm_attach.l3_ecmp_id = l3_ecmp_id;
	async->args.l3_ecmp_agm_attach.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_agm_attach_get_async(
	int unit,
	bcm_if_t l3_ecmp_id,
	bcm_switch_agm_id_t * agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_AGM_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_agm_attach_get.unit = unit;
	async->args.l3_ecmp_agm_attach_get.l3_ecmp_id = l3_ecmp_id;
	async->args.l3_ecmp_agm_attach_get.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_agm_detach_async(
	int unit,
	bcm_if_t l3_ecmp_id,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_AGM_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_agm_detach.unit = unit;
	async->args.l3_ecmp_agm_detach.l3_ecmp_id = l3_ecmp_id;
	async->args.l3_ecmp_agm_detach.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_create_async(
	int unit,
	uint32 options,
	bcm_l3_egress_ecmp_t * ecmp_info,
	int ecmp_member_count,
	bcm_l3_ecmp_member_t * ecmp_member_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_create.unit = unit;
	async->args.l3_ecmp_create.options = options;
	async->args.l3_ecmp_create.ecmp_info = ecmp_info;
	async->args.l3_ecmp_create.ecmp_member_count = ecmp_member_count;
	async->args.l3_ecmp_create.ecmp_member_array = ecmp_member_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_destroy_async(
	int unit,
	bcm_if_t ecmp_group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_destroy.unit = unit;
	async->args.l3_ecmp_destroy.ecmp_group_id = ecmp_group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_find_async(
	int unit,
	int ecmp_member_count,
	bcm_l3_ecmp_member_t * ecmp_member_array,
	bcm_l3_egress_ecmp_t * ecmp_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_find.unit = unit;
	async->args.l3_ecmp_find.ecmp_member_count = ecmp_member_count;
	async->args.l3_ecmp_find.ecmp_member_array = ecmp_member_array;
	async->args.l3_ecmp_find.ecmp_info = ecmp_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_get_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp_info,
	int ecmp_member_size,
	bcm_l3_ecmp_member_t * ecmp_member_array,
	int * ecmp_member_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_get.unit = unit;
	async->args.l3_ecmp_get.ecmp_info = ecmp_info;
	async->args.l3_ecmp_get.ecmp_member_size = ecmp_member_size;
	async->args.l3_ecmp_get.ecmp_member_array = ecmp_member_array;
	async->args.l3_ecmp_get.ecmp_member_count = ecmp_member_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_member_add_async(
	int unit,
	bcm_if_t ecmp_group_id,
	bcm_l3_ecmp_member_t * ecmp_member,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_MEMBER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_member_add.unit = unit;
	async->args.l3_ecmp_member_add.ecmp_group_id = ecmp_group_id;
	async->args.l3_ecmp_member_add.ecmp_member = ecmp_member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_member_delete_async(
	int unit,
	bcm_if_t ecmp_group_id,
	bcm_l3_ecmp_member_t * ecmp_member,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_MEMBER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_member_delete.unit = unit;
	async->args.l3_ecmp_member_delete.ecmp_group_id = ecmp_group_id;
	async->args.l3_ecmp_member_delete.ecmp_member = ecmp_member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_member_delete_all_async(
	int unit,
	bcm_if_t ecmp_group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_MEMBER_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_member_delete_all.unit = unit;
	async->args.l3_ecmp_member_delete_all.ecmp_group_id = ecmp_group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ecmp_traverse_async(
	int unit,
	bcm_l3_ecmp_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ECMP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ecmp_traverse.unit = unit;
	async->args.l3_ecmp_traverse.trav_fn = trav_fn;
	async->args.l3_ecmp_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_create_async(
	int unit,
	uint32 flags,
	bcm_l3_egress_t * egr,
	bcm_if_t * if_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_create.unit = unit;
	async->args.l3_egress_create.flags = flags;
	async->args.l3_egress_create.egr = egr;
	async->args.l3_egress_create.if_id = if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_destroy_async(
	int unit,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_destroy.unit = unit;
	async->args.l3_egress_destroy.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_add_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_add.unit = unit;
	async->args.l3_egress_ecmp_add.ecmp = ecmp;
	async->args.l3_egress_ecmp_add.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_create_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_create.unit = unit;
	async->args.l3_egress_ecmp_create.ecmp = ecmp;
	async->args.l3_egress_ecmp_create.intf_count = intf_count;
	async->args.l3_egress_ecmp_create.intf_array = intf_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_delete_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_delete.unit = unit;
	async->args.l3_egress_ecmp_delete.ecmp = ecmp;
	async->args.l3_egress_ecmp_delete.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_destroy_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_destroy.unit = unit;
	async->args.l3_egress_ecmp_destroy.ecmp = ecmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_ethertype_get_async(
	int unit,
	uint32 * flags,
	int ethertype_max,
	int * ethertype_array,
	int * ethertype_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_ETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_ethertype_get.unit = unit;
	async->args.l3_egress_ecmp_ethertype_get.flags = flags;
	async->args.l3_egress_ecmp_ethertype_get.ethertype_max = ethertype_max;
	async->args.l3_egress_ecmp_ethertype_get.ethertype_array = ethertype_array;
	async->args.l3_egress_ecmp_ethertype_get.ethertype_count = ethertype_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_ethertype_set_async(
	int unit,
	uint32 flags,
	int ethertype_count,
	int * ethertype_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_ETHERTYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_ethertype_set.unit = unit;
	async->args.l3_egress_ecmp_ethertype_set.flags = flags;
	async->args.l3_egress_ecmp_ethertype_set.ethertype_count = ethertype_count;
	async->args.l3_egress_ecmp_ethertype_set.ethertype_array = ethertype_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_find_async(
	int unit,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_l3_egress_ecmp_t * ecmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_find.unit = unit;
	async->args.l3_egress_ecmp_find.intf_count = intf_count;
	async->args.l3_egress_ecmp_find.intf_array = intf_array;
	async->args.l3_egress_ecmp_find.ecmp = ecmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_get_async(
	int unit,
	bcm_l3_egress_ecmp_t * ecmp,
	int intf_size,
	bcm_if_t * intf_array,
	int * intf_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_get.unit = unit;
	async->args.l3_egress_ecmp_get.ecmp = ecmp;
	async->args.l3_egress_ecmp_get.intf_size = intf_size;
	async->args.l3_egress_ecmp_get.intf_array = intf_array;
	async->args.l3_egress_ecmp_get.intf_count = intf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_member_status_get_async(
	int unit,
	bcm_if_t intf,
	int * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_MEMBER_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_member_status_get.unit = unit;
	async->args.l3_egress_ecmp_member_status_get.intf = intf;
	async->args.l3_egress_ecmp_member_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_member_status_set_async(
	int unit,
	bcm_if_t intf,
	int status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_MEMBER_STATUS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_member_status_set.unit = unit;
	async->args.l3_egress_ecmp_member_status_set.intf = intf;
	async->args.l3_egress_ecmp_member_status_set.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_resilient_replace_async(
	int unit,
	uint32 flags,
	bcm_l3_egress_ecmp_resilient_entry_t * match_entry,
	int * num_entries,
	bcm_l3_egress_ecmp_resilient_entry_t * replace_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_RESILIENT_REPLACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_resilient_replace.unit = unit;
	async->args.l3_egress_ecmp_resilient_replace.flags = flags;
	async->args.l3_egress_ecmp_resilient_replace.match_entry = match_entry;
	async->args.l3_egress_ecmp_resilient_replace.num_entries = num_entries;
	async->args.l3_egress_ecmp_resilient_replace.replace_entry = replace_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_resilient_traverse_async(
	int unit,
	uint32 flags,
	bcm_l3_egress_ecmp_resilient_entry_t * match_entry,
	bcm_l3_egress_ecmp_resilient_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_RESILIENT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_resilient_traverse.unit = unit;
	async->args.l3_egress_ecmp_resilient_traverse.flags = flags;
	async->args.l3_egress_ecmp_resilient_traverse.match_entry = match_entry;
	async->args.l3_egress_ecmp_resilient_traverse.trav_fn = trav_fn;
	async->args.l3_egress_ecmp_resilient_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_ecmp_traverse_async(
	int unit,
	bcm_l3_egress_ecmp_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_ECMP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_ecmp_traverse.unit = unit;
	async->args.l3_egress_ecmp_traverse.trav_fn = trav_fn;
	async->args.l3_egress_ecmp_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_find_async(
	int unit,
	bcm_l3_egress_t * egr,
	bcm_if_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_find.unit = unit;
	async->args.l3_egress_find.egr = egr;
	async->args.l3_egress_find.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_get_async(
	int unit,
	bcm_if_t intf,
	bcm_l3_egress_t * egr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_get.unit = unit;
	async->args.l3_egress_get.intf = intf;
	async->args.l3_egress_get.egr = egr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multi_alloc_async(
	int unit,
	bcm_l3_egress_multi_info_t egress_multi_info,
	bcm_if_t * base_egress_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTI_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multi_alloc.unit = unit;
	async->args.l3_egress_multi_alloc.egress_multi_info = egress_multi_info;
	async->args.l3_egress_multi_alloc.base_egress_id = base_egress_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multi_free_async(
	int unit,
	bcm_if_t base_egress_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTI_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multi_free.unit = unit;
	async->args.l3_egress_multi_free.base_egress_id = base_egress_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_add_async(
	int unit,
	bcm_if_t mpintf,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_add.unit = unit;
	async->args.l3_egress_multipath_add.mpintf = mpintf;
	async->args.l3_egress_multipath_add.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_create_async(
	int unit,
	uint32 flags,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_create.unit = unit;
	async->args.l3_egress_multipath_create.flags = flags;
	async->args.l3_egress_multipath_create.intf_count = intf_count;
	async->args.l3_egress_multipath_create.intf_array = intf_array;
	async->args.l3_egress_multipath_create.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_delete_async(
	int unit,
	bcm_if_t mpintf,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_delete.unit = unit;
	async->args.l3_egress_multipath_delete.mpintf = mpintf;
	async->args.l3_egress_multipath_delete.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_destroy_async(
	int unit,
	bcm_if_t mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_destroy.unit = unit;
	async->args.l3_egress_multipath_destroy.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_find_async(
	int unit,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_find.unit = unit;
	async->args.l3_egress_multipath_find.intf_count = intf_count;
	async->args.l3_egress_multipath_find.intf_array = intf_array;
	async->args.l3_egress_multipath_find.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_get_async(
	int unit,
	bcm_if_t mpintf,
	int intf_size,
	bcm_if_t * intf_array,
	int * intf_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_get.unit = unit;
	async->args.l3_egress_multipath_get.mpintf = mpintf;
	async->args.l3_egress_multipath_get.intf_size = intf_size;
	async->args.l3_egress_multipath_get.intf_array = intf_array;
	async->args.l3_egress_multipath_get.intf_count = intf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_max_create_async(
	int unit,
	uint32 flags,
	int max_paths,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_MAX_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_max_create.unit = unit;
	async->args.l3_egress_multipath_max_create.flags = flags;
	async->args.l3_egress_multipath_max_create.max_paths = max_paths;
	async->args.l3_egress_multipath_max_create.intf_count = intf_count;
	async->args.l3_egress_multipath_max_create.intf_array = intf_array;
	async->args.l3_egress_multipath_max_create.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_multipath_traverse_async(
	int unit,
	bcm_l3_egress_multipath_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_traverse.unit = unit;
	async->args.l3_egress_multipath_traverse.trav_fn = trav_fn;
	async->args.l3_egress_multipath_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_attach_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_attach.unit = unit;
	async->args.l3_egress_stat_attach.intf_id = intf_id;
	async->args.l3_egress_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_counter_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_counter_get.unit = unit;
	async->args.l3_egress_stat_counter_get.intf_id = intf_id;
	async->args.l3_egress_stat_counter_get.stat = stat;
	async->args.l3_egress_stat_counter_get.num_entries = num_entries;
	async->args.l3_egress_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_egress_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_counter_set_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_counter_set.unit = unit;
	async->args.l3_egress_stat_counter_set.intf_id = intf_id;
	async->args.l3_egress_stat_counter_set.stat = stat;
	async->args.l3_egress_stat_counter_set.num_entries = num_entries;
	async->args.l3_egress_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_egress_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_counter_sync_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_counter_sync_get.unit = unit;
	async->args.l3_egress_stat_counter_sync_get.intf_id = intf_id;
	async->args.l3_egress_stat_counter_sync_get.stat = stat;
	async->args.l3_egress_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_egress_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_egress_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_detach_async(
	int unit,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_detach.unit = unit;
	async->args.l3_egress_stat_detach.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_enable_set_async(
	int unit,
	bcm_l3_egress_t * egr,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_enable_set.unit = unit;
	async->args.l3_egress_stat_enable_set.egr = egr;
	async->args.l3_egress_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_get_async(
	int unit,
	bcm_l3_egress_t * egr,
	bcm_l3_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_get.unit = unit;
	async->args.l3_egress_stat_get.egr = egr;
	async->args.l3_egress_stat_get.stat = stat;
	async->args.l3_egress_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_get32_async(
	int unit,
	bcm_l3_egress_t * egr,
	bcm_l3_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_get32.unit = unit;
	async->args.l3_egress_stat_get32.egr = egr;
	async->args.l3_egress_stat_get32.stat = stat;
	async->args.l3_egress_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_id_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_id_get.unit = unit;
	async->args.l3_egress_stat_id_get.intf_id = intf_id;
	async->args.l3_egress_stat_id_get.stat = stat;
	async->args.l3_egress_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_set_async(
	int unit,
	bcm_l3_egress_t * egr,
	bcm_l3_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_set.unit = unit;
	async->args.l3_egress_stat_set.egr = egr;
	async->args.l3_egress_stat_set.stat = stat;
	async->args.l3_egress_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_stat_set32_async(
	int unit,
	bcm_l3_egress_t * egr,
	bcm_l3_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_stat_set32.unit = unit;
	async->args.l3_egress_stat_set32.egr = egr;
	async->args.l3_egress_stat_set32.stat = stat;
	async->args.l3_egress_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_egress_traverse_async(
	int unit,
	bcm_l3_egress_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_EGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_traverse.unit = unit;
	async->args.l3_egress_traverse.trav_fn = trav_fn;
	async->args.l3_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_enable_set_async(
	int unit,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_enable_set.unit = unit;
	async->args.l3_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_add_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_add.unit = unit;
	async->args.l3_host_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_age_async(
	int unit,
	uint32 flags,
	bcm_l3_host_traverse_cb age_cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_AGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_age.unit = unit;
	async->args.l3_host_age.flags = flags;
	async->args.l3_host_age.age_cb = age_cb;
	async->args.l3_host_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_conflict_get_async(
	int unit,
	bcm_l3_key_t * ipkey,
	bcm_l3_key_t * cf_array,
	int cf_max,
	int * cf_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_CONFLICT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_conflict_get.unit = unit;
	async->args.l3_host_conflict_get.ipkey = ipkey;
	async->args.l3_host_conflict_get.cf_array = cf_array;
	async->args.l3_host_conflict_get.cf_max = cf_max;
	async->args.l3_host_conflict_get.cf_count = cf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_delete_async(
	int unit,
	bcm_l3_host_t * ip_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete.unit = unit;
	async->args.l3_host_delete.ip_addr = ip_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_delete_all_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_all.unit = unit;
	async->args.l3_host_delete_all.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_delete_by_interface_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_DELETE_BY_INTERFACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_by_interface.unit = unit;
	async->args.l3_host_delete_by_interface.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_delete_by_network_async(
	int unit,
	bcm_l3_route_t * ip_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_DELETE_BY_NETWORK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_by_network.unit = unit;
	async->args.l3_host_delete_by_network.ip_addr = ip_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_find_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_find.unit = unit;
	async->args.l3_host_find.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_invalidate_entry_async(
	int unit,
	bcm_ip_t info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_INVALIDATE_ENTRY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_invalidate_entry.unit = unit;
	async->args.l3_host_invalidate_entry.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_attach_async(
	int unit,
	bcm_l3_host_t * info,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_attach.unit = unit;
	async->args.l3_host_stat_attach.info = info;
	async->args.l3_host_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_counter_get_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_counter_get.unit = unit;
	async->args.l3_host_stat_counter_get.info = info;
	async->args.l3_host_stat_counter_get.stat = stat;
	async->args.l3_host_stat_counter_get.num_entries = num_entries;
	async->args.l3_host_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_host_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_counter_set_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_counter_set.unit = unit;
	async->args.l3_host_stat_counter_set.info = info;
	async->args.l3_host_stat_counter_set.stat = stat;
	async->args.l3_host_stat_counter_set.num_entries = num_entries;
	async->args.l3_host_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_host_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_counter_sync_get_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_counter_sync_get.unit = unit;
	async->args.l3_host_stat_counter_sync_get.info = info;
	async->args.l3_host_stat_counter_sync_get.stat = stat;
	async->args.l3_host_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_host_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_host_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_detach_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_detach.unit = unit;
	async->args.l3_host_stat_detach.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_enable_set_async(
	int unit,
	bcm_l3_host_t * host,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_enable_set.unit = unit;
	async->args.l3_host_stat_enable_set.host = host;
	async->args.l3_host_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_get_async(
	int unit,
	bcm_l3_host_t * host,
	bcm_l3_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_get.unit = unit;
	async->args.l3_host_stat_get.host = host;
	async->args.l3_host_stat_get.stat = stat;
	async->args.l3_host_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_get32_async(
	int unit,
	bcm_l3_host_t * host,
	bcm_l3_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_get32.unit = unit;
	async->args.l3_host_stat_get32.host = host;
	async->args.l3_host_stat_get32.stat = stat;
	async->args.l3_host_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_id_get_async(
	int unit,
	bcm_l3_host_t * info,
	bcm_l3_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_id_get.unit = unit;
	async->args.l3_host_stat_id_get.info = info;
	async->args.l3_host_stat_id_get.stat = stat;
	async->args.l3_host_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_set_async(
	int unit,
	bcm_l3_host_t * host,
	bcm_l3_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_set.unit = unit;
	async->args.l3_host_stat_set.host = host;
	async->args.l3_host_stat_set.stat = stat;
	async->args.l3_host_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_stat_set32_async(
	int unit,
	bcm_l3_host_t * host,
	bcm_l3_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_stat_set32.unit = unit;
	async->args.l3_host_stat_set32.host = host;
	async->args.l3_host_stat_set32.stat = stat;
	async->args.l3_host_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_traverse_async(
	int unit,
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_host_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_traverse.unit = unit;
	async->args.l3_host_traverse.flags = flags;
	async->args.l3_host_traverse.start = start;
	async->args.l3_host_traverse.end = end;
	async->args.l3_host_traverse.cb = cb;
	async->args.l3_host_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_host_validate_entry_async(
	int unit,
	bcm_ip_t info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_HOST_VALIDATE_ENTRY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_validate_entry.unit = unit;
	async->args.l3_host_validate_entry.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_info_async(
	int unit,
	bcm_l3_info_t * l3info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INFO;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_info.unit = unit;
	async->args.l3_info.l3info = l3info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_create_async(
	int unit,
	bcm_l3_ingress_t * ing_intf,
	bcm_if_t * intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_create.unit = unit;
	async->args.l3_ingress_create.ing_intf = ing_intf;
	async->args.l3_ingress_create.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_destroy_async(
	int unit,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_destroy.unit = unit;
	async->args.l3_ingress_destroy.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_find_async(
	int unit,
	bcm_l3_ingress_t * ing_intf,
	bcm_if_t * intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_find.unit = unit;
	async->args.l3_ingress_find.ing_intf = ing_intf;
	async->args.l3_ingress_find.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_get_async(
	int unit,
	bcm_if_t intf,
	bcm_l3_ingress_t * ing_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_get.unit = unit;
	async->args.l3_ingress_get.intf = intf;
	async->args.l3_ingress_get.ing_intf = ing_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_attach_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_attach.unit = unit;
	async->args.l3_ingress_stat_attach.intf_id = intf_id;
	async->args.l3_ingress_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_counter_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_counter_get.unit = unit;
	async->args.l3_ingress_stat_counter_get.intf_id = intf_id;
	async->args.l3_ingress_stat_counter_get.stat = stat;
	async->args.l3_ingress_stat_counter_get.num_entries = num_entries;
	async->args.l3_ingress_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_ingress_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_counter_set_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_counter_set.unit = unit;
	async->args.l3_ingress_stat_counter_set.intf_id = intf_id;
	async->args.l3_ingress_stat_counter_set.stat = stat;
	async->args.l3_ingress_stat_counter_set.num_entries = num_entries;
	async->args.l3_ingress_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_ingress_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_counter_sync_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_counter_sync_get.unit = unit;
	async->args.l3_ingress_stat_counter_sync_get.intf_id = intf_id;
	async->args.l3_ingress_stat_counter_sync_get.stat = stat;
	async->args.l3_ingress_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_ingress_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_ingress_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_detach_async(
	int unit,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_detach.unit = unit;
	async->args.l3_ingress_stat_detach.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_stat_id_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_l3_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_stat_id_get.unit = unit;
	async->args.l3_ingress_stat_id_get.intf_id = intf_id;
	async->args.l3_ingress_stat_id_get.stat = stat;
	async->args.l3_ingress_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ingress_traverse_async(
	int unit,
	bcm_l3_ingress_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_traverse.unit = unit;
	async->args.l3_ingress_traverse.trav_fn = trav_fn;
	async->args.l3_ingress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_create_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_create.unit = unit;
	async->args.l3_intf_create.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_delete_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_delete.unit = unit;
	async->args.l3_intf_delete.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_find_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_find.unit = unit;
	async->args.l3_intf_find.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_find_vlan_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_FIND_VLAN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_find_vlan.unit = unit;
	async->args.l3_intf_find_vlan.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_intf_get_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_INTF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_get.unit = unit;
	async->args.l3_intf_get.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip4_options_action_get_async(
	int unit,
	int ip4_options_profile_id,
	int ip4_option,
	bcm_l3_ip4_options_action_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP4_OPTIONS_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip4_options_action_get.unit = unit;
	async->args.l3_ip4_options_action_get.ip4_options_profile_id = ip4_options_profile_id;
	async->args.l3_ip4_options_action_get.ip4_option = ip4_option;
	async->args.l3_ip4_options_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip4_options_action_set_async(
	int unit,
	int ip4_options_profile_id,
	int ip4_option,
	bcm_l3_ip4_options_action_t action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP4_OPTIONS_ACTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip4_options_action_set.unit = unit;
	async->args.l3_ip4_options_action_set.ip4_options_profile_id = ip4_options_profile_id;
	async->args.l3_ip4_options_action_set.ip4_option = ip4_option;
	async->args.l3_ip4_options_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip4_options_profile_create_async(
	int unit,
	uint32 flags,
	bcm_l3_ip4_options_action_t default_action,
	int * ip4_options_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP4_OPTIONS_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip4_options_profile_create.unit = unit;
	async->args.l3_ip4_options_profile_create.flags = flags;
	async->args.l3_ip4_options_profile_create.default_action = default_action;
	async->args.l3_ip4_options_profile_create.ip4_options_profile_id = ip4_options_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip4_options_profile_destroy_async(
	int unit,
	int ip4_options_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP4_OPTIONS_PROFILE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip4_options_profile_destroy.unit = unit;
	async->args.l3_ip4_options_profile_destroy.ip4_options_profile_id = ip4_options_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip6_prefix_map_add_async(
	int unit,
	bcm_ip6_t ip6_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_add.unit = unit;
	async->args.l3_ip6_prefix_map_add.ip6_addr = (uint8 *)ip6_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip6_prefix_map_delete_async(
	int unit,
	bcm_ip6_t ip6_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_delete.unit = unit;
	async->args.l3_ip6_prefix_map_delete.ip6_addr = (uint8 *)ip6_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip6_prefix_map_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_ip6_prefix_map_get_async(
	int unit,
	int map_size,
	bcm_ip6_t * ip6_array,
	int * ip6_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_get.unit = unit;
	async->args.l3_ip6_prefix_map_get.map_size = map_size;
	async->args.l3_ip6_prefix_map_get.ip6_array = ip6_array;
	async->args.l3_ip6_prefix_map_get.ip6_count = ip6_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_add_async(
	int unit,
	bcm_l3_nat_egress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_add.unit = unit;
	async->args.l3_nat_egress_add.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_delete_async(
	int unit,
	bcm_l3_nat_id_t nat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_delete.unit = unit;
	async->args.l3_nat_egress_delete.nat_id = nat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_get_async(
	int unit,
	bcm_l3_nat_egress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_get.unit = unit;
	async->args.l3_nat_egress_get.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_attach_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_attach.unit = unit;
	async->args.l3_nat_egress_stat_attach.info = info;
	async->args.l3_nat_egress_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_counter_get_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	bcm_l3_nat_egress_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_counter_get.unit = unit;
	async->args.l3_nat_egress_stat_counter_get.info = info;
	async->args.l3_nat_egress_stat_counter_get.stat = stat;
	async->args.l3_nat_egress_stat_counter_get.num_entries = num_entries;
	async->args.l3_nat_egress_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_nat_egress_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_counter_set_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	bcm_l3_nat_egress_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_counter_set.unit = unit;
	async->args.l3_nat_egress_stat_counter_set.info = info;
	async->args.l3_nat_egress_stat_counter_set.stat = stat;
	async->args.l3_nat_egress_stat_counter_set.num_entries = num_entries;
	async->args.l3_nat_egress_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_nat_egress_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_counter_sync_get_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	bcm_l3_nat_egress_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_counter_sync_get.unit = unit;
	async->args.l3_nat_egress_stat_counter_sync_get.info = info;
	async->args.l3_nat_egress_stat_counter_sync_get.stat = stat;
	async->args.l3_nat_egress_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_nat_egress_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_nat_egress_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_detach_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_detach.unit = unit;
	async->args.l3_nat_egress_stat_detach.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_id_get_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	bcm_l3_nat_egress_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_id_get.unit = unit;
	async->args.l3_nat_egress_stat_id_get.info = info;
	async->args.l3_nat_egress_stat_id_get.stat = stat;
	async->args.l3_nat_egress_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_multi_get_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	int nstat,
	bcm_l3_nat_egress_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_multi_get.unit = unit;
	async->args.l3_nat_egress_stat_multi_get.info = info;
	async->args.l3_nat_egress_stat_multi_get.nstat = nstat;
	async->args.l3_nat_egress_stat_multi_get.stat_arr = stat_arr;
	async->args.l3_nat_egress_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_multi_get32_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	int nstat,
	bcm_l3_nat_egress_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_multi_get32.unit = unit;
	async->args.l3_nat_egress_stat_multi_get32.info = info;
	async->args.l3_nat_egress_stat_multi_get32.nstat = nstat;
	async->args.l3_nat_egress_stat_multi_get32.stat_arr = stat_arr;
	async->args.l3_nat_egress_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_multi_set_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	int nstat,
	bcm_l3_nat_egress_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_multi_set.unit = unit;
	async->args.l3_nat_egress_stat_multi_set.info = info;
	async->args.l3_nat_egress_stat_multi_set.nstat = nstat;
	async->args.l3_nat_egress_stat_multi_set.stat_arr = stat_arr;
	async->args.l3_nat_egress_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_stat_multi_set32_async(
	int unit,
	bcm_l3_nat_egress_t * info,
	int nstat,
	bcm_l3_nat_egress_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_stat_multi_set32.unit = unit;
	async->args.l3_nat_egress_stat_multi_set32.info = info;
	async->args.l3_nat_egress_stat_multi_set32.nstat = nstat;
	async->args.l3_nat_egress_stat_multi_set32.stat_arr = stat_arr;
	async->args.l3_nat_egress_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_egress_traverse_async(
	int unit,
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_nat_egress_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_EGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_egress_traverse.unit = unit;
	async->args.l3_nat_egress_traverse.flags = flags;
	async->args.l3_nat_egress_traverse.start = start;
	async->args.l3_nat_egress_traverse.end = end;
	async->args.l3_nat_egress_traverse.cb = cb;
	async->args.l3_nat_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_add_async(
	int unit,
	bcm_l3_nat_ingress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_add.unit = unit;
	async->args.l3_nat_ingress_add.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_age_async(
	int unit,
	uint32 flags,
	bcm_l3_nat_ingress_traverse_cb age_cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_AGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_age.unit = unit;
	async->args.l3_nat_ingress_age.flags = flags;
	async->args.l3_nat_ingress_age.age_cb = age_cb;
	async->args.l3_nat_ingress_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_delete_async(
	int unit,
	bcm_l3_nat_ingress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_delete.unit = unit;
	async->args.l3_nat_ingress_delete.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_delete_all_async(
	int unit,
	bcm_l3_nat_ingress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_delete_all.unit = unit;
	async->args.l3_nat_ingress_delete_all.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_find_async(
	int unit,
	bcm_l3_nat_ingress_t * nat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_find.unit = unit;
	async->args.l3_nat_ingress_find.nat_info = nat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_nat_ingress_traverse_async(
	int unit,
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_nat_ingress_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_NAT_INGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_nat_ingress_traverse.unit = unit;
	async->args.l3_nat_ingress_traverse.flags = flags;
	async->args.l3_nat_ingress_traverse.start = start;
	async->args.l3_nat_ingress_traverse.end = end;
	async->args.l3_nat_ingress_traverse.cb = cb;
	async->args.l3_nat_ingress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_add_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_add.unit = unit;
	async->args.l3_route_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_age_async(
	int unit,
	uint32 flags,
	bcm_l3_route_traverse_cb age_out,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_AGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_age.unit = unit;
	async->args.l3_route_age.flags = flags;
	async->args.l3_route_age.age_out = age_out;
	async->args.l3_route_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_delete_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete.unit = unit;
	async->args.l3_route_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_delete_all_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete_all.unit = unit;
	async->args.l3_route_delete_all.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_delete_by_interface_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_DELETE_BY_INTERFACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete_by_interface.unit = unit;
	async->args.l3_route_delete_by_interface.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_find_async(
	int unit,
	bcm_l3_host_t * host,
	bcm_l3_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_find.unit = unit;
	async->args.l3_route_find.host = host;
	async->args.l3_route_find.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_get_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_get.unit = unit;
	async->args.l3_route_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_max_ecmp_get_async(
	int unit,
	int * max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_max_ecmp_get.unit = unit;
	async->args.l3_route_max_ecmp_get.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_max_ecmp_set_async(
	int unit,
	int max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_max_ecmp_set.unit = unit;
	async->args.l3_route_max_ecmp_set.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_multipath_get_async(
	int unit,
	bcm_l3_route_t * the_route,
	bcm_l3_route_t * path_array,
	int max_path,
	int * path_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_MULTIPATH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_multipath_get.unit = unit;
	async->args.l3_route_multipath_get.the_route = the_route;
	async->args.l3_route_multipath_get.path_array = path_array;
	async->args.l3_route_multipath_get.max_path = max_path;
	async->args.l3_route_multipath_get.path_count = path_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_attach_async(
	int unit,
	bcm_l3_route_t * info,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_attach.unit = unit;
	async->args.l3_route_stat_attach.info = info;
	async->args.l3_route_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_counter_get_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_l3_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_counter_get.unit = unit;
	async->args.l3_route_stat_counter_get.info = info;
	async->args.l3_route_stat_counter_get.stat = stat;
	async->args.l3_route_stat_counter_get.num_entries = num_entries;
	async->args.l3_route_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_route_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_counter_set_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_l3_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_counter_set.unit = unit;
	async->args.l3_route_stat_counter_set.info = info;
	async->args.l3_route_stat_counter_set.stat = stat;
	async->args.l3_route_stat_counter_set.num_entries = num_entries;
	async->args.l3_route_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_route_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_counter_sync_get_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_l3_route_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_counter_sync_get.unit = unit;
	async->args.l3_route_stat_counter_sync_get.info = info;
	async->args.l3_route_stat_counter_sync_get.stat = stat;
	async->args.l3_route_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_route_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_route_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_detach_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_detach.unit = unit;
	async->args.l3_route_stat_detach.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_enable_set_async(
	int unit,
	bcm_l3_route_t * route,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_enable_set.unit = unit;
	async->args.l3_route_stat_enable_set.route = route;
	async->args.l3_route_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_get_async(
	int unit,
	bcm_l3_route_t * route,
	bcm_l3_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_get.unit = unit;
	async->args.l3_route_stat_get.route = route;
	async->args.l3_route_stat_get.stat = stat;
	async->args.l3_route_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_get32_async(
	int unit,
	bcm_l3_route_t * route,
	bcm_l3_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_get32.unit = unit;
	async->args.l3_route_stat_get32.route = route;
	async->args.l3_route_stat_get32.stat = stat;
	async->args.l3_route_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_id_get_async(
	int unit,
	bcm_l3_route_t * info,
	bcm_l3_route_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_id_get.unit = unit;
	async->args.l3_route_stat_id_get.info = info;
	async->args.l3_route_stat_id_get.stat = stat;
	async->args.l3_route_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_multi_get_async(
	int unit,
	bcm_l3_route_t * info,
	int nstat,
	bcm_l3_route_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_multi_get.unit = unit;
	async->args.l3_route_stat_multi_get.info = info;
	async->args.l3_route_stat_multi_get.nstat = nstat;
	async->args.l3_route_stat_multi_get.stat_arr = stat_arr;
	async->args.l3_route_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_multi_get32_async(
	int unit,
	bcm_l3_route_t * info,
	int nstat,
	bcm_l3_route_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_multi_get32.unit = unit;
	async->args.l3_route_stat_multi_get32.info = info;
	async->args.l3_route_stat_multi_get32.nstat = nstat;
	async->args.l3_route_stat_multi_get32.stat_arr = stat_arr;
	async->args.l3_route_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_multi_set_async(
	int unit,
	bcm_l3_route_t * info,
	int nstat,
	bcm_l3_route_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_multi_set.unit = unit;
	async->args.l3_route_stat_multi_set.info = info;
	async->args.l3_route_stat_multi_set.nstat = nstat;
	async->args.l3_route_stat_multi_set.stat_arr = stat_arr;
	async->args.l3_route_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_multi_set32_async(
	int unit,
	bcm_l3_route_t * info,
	int nstat,
	bcm_l3_route_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_multi_set32.unit = unit;
	async->args.l3_route_stat_multi_set32.info = info;
	async->args.l3_route_stat_multi_set32.nstat = nstat;
	async->args.l3_route_stat_multi_set32.stat_arr = stat_arr;
	async->args.l3_route_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_set_async(
	int unit,
	bcm_l3_route_t * route,
	bcm_l3_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_set.unit = unit;
	async->args.l3_route_stat_set.route = route;
	async->args.l3_route_stat_set.stat = stat;
	async->args.l3_route_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_stat_set32_async(
	int unit,
	bcm_l3_route_t * route,
	bcm_l3_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_stat_set32.unit = unit;
	async->args.l3_route_stat_set32.route = route;
	async->args.l3_route_stat_set32.stat = stat;
	async->args.l3_route_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_route_traverse_async(
	int unit,
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_route_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_ROUTE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_traverse.unit = unit;
	async->args.l3_route_traverse.flags = flags;
	async->args.l3_route_traverse.start = start;
	async->args.l3_route_traverse.end = end;
	async->args.l3_route_traverse.trav_fn = trav_fn;
	async->args.l3_route_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_add_async(
	int unit,
	bcm_l3_source_bind_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_add.unit = unit;
	async->args.l3_source_bind_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_delete_async(
	int unit,
	bcm_l3_source_bind_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_delete.unit = unit;
	async->args.l3_source_bind_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_enable_get.unit = unit;
	async->args.l3_source_bind_enable_get.port = port;
	async->args.l3_source_bind_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_enable_set.unit = unit;
	async->args.l3_source_bind_enable_set.port = port;
	async->args.l3_source_bind_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_get_async(
	int unit,
	bcm_l3_source_bind_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_get.unit = unit;
	async->args.l3_source_bind_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_source_bind_traverse_async(
	int unit,
	bcm_l3_source_bind_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SOURCE_BIND_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_traverse.unit = unit;
	async->args.l3_source_bind_traverse.cb = cb;
	async->args.l3_source_bind_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_subnet_route_find_async(
	int unit,
	bcm_l3_route_t * input,
	bcm_l3_route_t * route,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_SUBNET_ROUTE_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_subnet_route_find.unit = unit;
	async->args.l3_subnet_route_find.input = input;
	async->args.l3_subnet_route_find.route = route;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_attach_async(
	int unit,
	bcm_vrf_t vrf,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_attach.unit = unit;
	async->args.l3_vrf_stat_attach.vrf = vrf;
	async->args.l3_vrf_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_counter_get_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_counter_get.unit = unit;
	async->args.l3_vrf_stat_counter_get.vrf = vrf;
	async->args.l3_vrf_stat_counter_get.stat = stat;
	async->args.l3_vrf_stat_counter_get.num_entries = num_entries;
	async->args.l3_vrf_stat_counter_get.counter_indexes = counter_indexes;
	async->args.l3_vrf_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_counter_set_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_counter_set.unit = unit;
	async->args.l3_vrf_stat_counter_set.vrf = vrf;
	async->args.l3_vrf_stat_counter_set.stat = stat;
	async->args.l3_vrf_stat_counter_set.num_entries = num_entries;
	async->args.l3_vrf_stat_counter_set.counter_indexes = counter_indexes;
	async->args.l3_vrf_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_counter_sync_get_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_counter_sync_get.unit = unit;
	async->args.l3_vrf_stat_counter_sync_get.vrf = vrf;
	async->args.l3_vrf_stat_counter_sync_get.stat = stat;
	async->args.l3_vrf_stat_counter_sync_get.num_entries = num_entries;
	async->args.l3_vrf_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.l3_vrf_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_detach_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_detach.unit = unit;
	async->args.l3_vrf_stat_detach.vrf = vrf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_enable_set_async(
	int unit,
	bcm_vrf_t vrf,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_enable_set.unit = unit;
	async->args.l3_vrf_stat_enable_set.vrf = vrf;
	async->args.l3_vrf_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_get_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_get.unit = unit;
	async->args.l3_vrf_stat_get.vrf = vrf;
	async->args.l3_vrf_stat_get.stat = stat;
	async->args.l3_vrf_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_get32_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_get32.unit = unit;
	async->args.l3_vrf_stat_get32.vrf = vrf;
	async->args.l3_vrf_stat_get32.stat = stat;
	async->args.l3_vrf_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_id_get_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_id_get.unit = unit;
	async->args.l3_vrf_stat_id_get.vrf = vrf;
	async->args.l3_vrf_stat_id_get.stat = stat;
	async->args.l3_vrf_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_multi_get_async(
	int unit,
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_get.unit = unit;
	async->args.l3_vrf_stat_multi_get.vrf = vrf;
	async->args.l3_vrf_stat_multi_get.nstat = nstat;
	async->args.l3_vrf_stat_multi_get.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_multi_get32_async(
	int unit,
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_get32.unit = unit;
	async->args.l3_vrf_stat_multi_get32.vrf = vrf;
	async->args.l3_vrf_stat_multi_get32.nstat = nstat;
	async->args.l3_vrf_stat_multi_get32.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_multi_set_async(
	int unit,
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_set.unit = unit;
	async->args.l3_vrf_stat_multi_set.vrf = vrf;
	async->args.l3_vrf_stat_multi_set.nstat = nstat;
	async->args.l3_vrf_stat_multi_set.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_multi_set32_async(
	int unit,
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_set32.unit = unit;
	async->args.l3_vrf_stat_multi_set32.vrf = vrf;
	async->args.l3_vrf_stat_multi_set32.nstat = nstat;
	async->args.l3_vrf_stat_multi_set32.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_set_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_set.unit = unit;
	async->args.l3_vrf_stat_set.vrf = vrf;
	async->args.l3_vrf_stat_set.stat = stat;
	async->args.l3_vrf_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_set32_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_set32.unit = unit;
	async->args.l3_vrf_stat_set32.vrf = vrf;
	async->args.l3_vrf_stat_set32.stat = stat;
	async->args.l3_vrf_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_sync_get_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_sync_get.unit = unit;
	async->args.l3_vrf_stat_sync_get.vrf = vrf;
	async->args.l3_vrf_stat_sync_get.stat = stat;
	async->args.l3_vrf_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrf_stat_sync_get32_async(
	int unit,
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRF_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_sync_get32.unit = unit;
	async->args.l3_vrf_stat_sync_get32.vrf = vrf;
	async->args.l3_vrf_stat_sync_get32.stat = stat;
	async->args.l3_vrf_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_add_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 vrid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_add.unit = unit;
	async->args.l3_vrrp_add.vlan = vlan;
	async->args.l3_vrrp_add.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_config_add_async(
	int unit,
	uint32 flags,
	bcm_vlan_t vlan,
	uint32 vrid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_config_add.unit = unit;
	async->args.l3_vrrp_config_add.flags = flags;
	async->args.l3_vrrp_config_add.vlan = vlan;
	async->args.l3_vrrp_config_add.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_config_delete_async(
	int unit,
	uint32 flags,
	bcm_vlan_t vlan,
	uint32 vrid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_config_delete.unit = unit;
	async->args.l3_vrrp_config_delete.flags = flags;
	async->args.l3_vrrp_config_delete.vlan = vlan;
	async->args.l3_vrrp_config_delete.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_config_delete_all_async(
	int unit,
	uint32 flags,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_CONFIG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_config_delete_all.unit = unit;
	async->args.l3_vrrp_config_delete_all.flags = flags;
	async->args.l3_vrrp_config_delete_all.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_config_get_async(
	int unit,
	uint32 flags,
	bcm_vlan_t vlan,
	uint32 alloc_size,
	uint32 * vrid_array,
	uint32 * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_config_get.unit = unit;
	async->args.l3_vrrp_config_get.flags = flags;
	async->args.l3_vrrp_config_get.vlan = vlan;
	async->args.l3_vrrp_config_get.alloc_size = alloc_size;
	async->args.l3_vrrp_config_get.vrid_array = vrid_array;
	async->args.l3_vrrp_config_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_delete_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 vrid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_delete.unit = unit;
	async->args.l3_vrrp_delete.vlan = vlan;
	async->args.l3_vrrp_delete.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_delete_all_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_delete_all.unit = unit;
	async->args.l3_vrrp_delete_all.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_l3_vrrp_get_async(
	int unit,
	bcm_vlan_t vlan,
	int alloc_size,
	int * vrid_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_L3_VRRP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_get.unit = unit;
	async->args.l3_vrrp_get.vlan = vlan;
	async->args.l3_vrrp_get.alloc_size = alloc_size;
	async->args.l3_vrrp_get.vrid_array = vrid_array;
	async->args.l3_vrrp_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_lb_control_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_control_t lb_control,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_control_get.unit = unit;
	async->args.lb_control_get.lbg_id = lbg_id;
	async->args.lb_control_get.direction = direction;
	async->args.lb_control_get.flags = flags;
	async->args.lb_control_get.lb_control = lb_control;
	async->args.lb_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_control_set_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_control_t lb_control,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_control_set.unit = unit;
	async->args.lb_control_set.lbg_id = lbg_id;
	async->args.lb_control_set.direction = direction;
	async->args.lb_control_set.flags = flags;
	async->args.lb_control_set.lb_control = lb_control;
	async->args.lb_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_enable_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	uint32 flags,
	uint32 * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_enable_get.unit = unit;
	async->args.lb_enable_get.lbg_id = lbg_id;
	async->args.lb_enable_get.flags = flags;
	async->args.lb_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_enable_set_async(
	int unit,
	bcm_lbg_t lbg_id,
	uint32 flags,
	uint32 enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_enable_set.unit = unit;
	async->args.lb_enable_set.lbg_id = lbg_id;
	async->args.lb_enable_set.flags = flags;
	async->args.lb_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_flush_configure_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	uint32 flags,
	bcm_lb_flush_type_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_FLUSH_CONFIGURE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_flush_configure_get.unit = unit;
	async->args.lb_flush_configure_get.lbg_id = lbg_id;
	async->args.lb_flush_configure_get.flags = flags;
	async->args.lb_flush_configure_get.type = type;
	async->args.lb_flush_configure_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_flush_configure_set_async(
	int unit,
	bcm_lbg_t lbg_id,
	uint32 flags,
	bcm_lb_flush_type_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_FLUSH_CONFIGURE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_flush_configure_set.unit = unit;
	async->args.lb_flush_configure_set.lbg_id = lbg_id;
	async->args.lb_flush_configure_set.flags = flags;
	async->args.lb_flush_configure_set.type = type;
	async->args.lb_flush_configure_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_control_get_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_modem_control_t modem_control,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_control_get.unit = unit;
	async->args.lb_modem_control_get.modem_id = modem_id;
	async->args.lb_modem_control_get.direction = direction;
	async->args.lb_modem_control_get.flags = flags;
	async->args.lb_modem_control_get.modem_control = modem_control;
	async->args.lb_modem_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_control_set_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_modem_control_t modem_control,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_control_set.unit = unit;
	async->args.lb_modem_control_set.modem_id = modem_id;
	async->args.lb_modem_control_set.direction = direction;
	async->args.lb_modem_control_set.flags = flags;
	async->args.lb_modem_control_set.modem_control = modem_control;
	async->args.lb_modem_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_packet_config_get_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_lb_modem_packet_config_t * packet_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_PACKET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_packet_config_get.unit = unit;
	async->args.lb_modem_packet_config_get.modem_id = modem_id;
	async->args.lb_modem_packet_config_get.flags = flags;
	async->args.lb_modem_packet_config_get.packet_config = packet_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_packet_config_set_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_lb_modem_packet_config_t * packet_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_PACKET_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_packet_config_set.unit = unit;
	async->args.lb_modem_packet_config_set.modem_id = modem_id;
	async->args.lb_modem_packet_config_set.flags = flags;
	async->args.lb_modem_packet_config_set.packet_config = packet_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_shaper_get_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_lb_modem_shaper_config_t * shaper,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_SHAPER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_shaper_get.unit = unit;
	async->args.lb_modem_shaper_get.modem_id = modem_id;
	async->args.lb_modem_shaper_get.flags = flags;
	async->args.lb_modem_shaper_get.shaper = shaper;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_shaper_set_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_lb_modem_shaper_config_t * shaper,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_SHAPER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_shaper_set.unit = unit;
	async->args.lb_modem_shaper_set.modem_id = modem_id;
	async->args.lb_modem_shaper_set.flags = flags;
	async->args.lb_modem_shaper_set.shaper = shaper;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_stat_get_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_modem_stat_val_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_stat_get.unit = unit;
	async->args.lb_modem_stat_get.modem_id = modem_id;
	async->args.lb_modem_stat_get.direction = direction;
	async->args.lb_modem_stat_get.flags = flags;
	async->args.lb_modem_stat_get.type = type;
	async->args.lb_modem_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_status_get_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_modem_status_type_t status_type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_status_get.unit = unit;
	async->args.lb_modem_status_get.modem_id = modem_id;
	async->args.lb_modem_status_get.direction = direction;
	async->args.lb_modem_status_get.flags = flags;
	async->args.lb_modem_status_get.status_type = status_type;
	async->args.lb_modem_status_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_to_lbg_map_get_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lbg_t * lbg_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_TO_LBG_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_to_lbg_map_get.unit = unit;
	async->args.lb_modem_to_lbg_map_get.modem_id = modem_id;
	async->args.lb_modem_to_lbg_map_get.direction = direction;
	async->args.lb_modem_to_lbg_map_get.flags = flags;
	async->args.lb_modem_to_lbg_map_get.lbg_id = lbg_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_to_lbg_map_set_async(
	int unit,
	bcm_modem_t modem_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lbg_t lbg_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_TO_LBG_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_to_lbg_map_set.unit = unit;
	async->args.lb_modem_to_lbg_map_set.modem_id = modem_id;
	async->args.lb_modem_to_lbg_map_set.direction = direction;
	async->args.lb_modem_to_lbg_map_set.flags = flags;
	async->args.lb_modem_to_lbg_map_set.lbg_id = lbg_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_to_port_map_get_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_gport_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_TO_PORT_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_to_port_map_get.unit = unit;
	async->args.lb_modem_to_port_map_get.modem_id = modem_id;
	async->args.lb_modem_to_port_map_get.flags = flags;
	async->args.lb_modem_to_port_map_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_modem_to_port_map_set_async(
	int unit,
	bcm_modem_t modem_id,
	uint32 flags,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_MODEM_TO_PORT_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_modem_to_port_map_set.unit = unit;
	async->args.lb_modem_to_port_map_set.modem_id = modem_id;
	async->args.lb_modem_to_port_map_set.flags = flags;
	async->args.lb_modem_to_port_map_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_packet_config_get_async(
	int unit,
	uint32 flags,
	bcm_lb_packet_config_t * packet_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_PACKET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_packet_config_get.unit = unit;
	async->args.lb_packet_config_get.flags = flags;
	async->args.lb_packet_config_get.packet_config = packet_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_packet_config_set_async(
	int unit,
	uint32 flags,
	bcm_lb_packet_config_t * packet_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_PACKET_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_packet_config_set.unit = unit;
	async->args.lb_packet_config_set.flags = flags;
	async->args.lb_packet_config_set.packet_config = packet_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_rx_modem_map_get_async(
	int unit,
	bcm_lb_rx_modem_map_index_t * map_index,
	uint32 flags,
	bcm_lb_rx_modem_map_config_t * map_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_RX_MODEM_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_rx_modem_map_get.unit = unit;
	async->args.lb_rx_modem_map_get.map_index = map_index;
	async->args.lb_rx_modem_map_get.flags = flags;
	async->args.lb_rx_modem_map_get.map_config = map_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_rx_modem_map_set_async(
	int unit,
	bcm_lb_rx_modem_map_index_t * map_index,
	uint32 flags,
	bcm_lb_rx_modem_map_config_t * map_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_RX_MODEM_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_rx_modem_map_set.unit = unit;
	async->args.lb_rx_modem_map_set.map_index = map_index;
	async->args.lb_rx_modem_map_set.flags = flags;
	async->args.lb_rx_modem_map_set.map_config = map_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_sequence_number_width_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	int * number_width,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_SEQUENCE_NUMBER_WIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_sequence_number_width_get.unit = unit;
	async->args.lb_sequence_number_width_get.lbg_id = lbg_id;
	async->args.lb_sequence_number_width_get.direction = direction;
	async->args.lb_sequence_number_width_get.flags = flags;
	async->args.lb_sequence_number_width_get.number_width = number_width;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_sequence_number_width_set_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	int number_width,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_SEQUENCE_NUMBER_WIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_sequence_number_width_set.unit = unit;
	async->args.lb_sequence_number_width_set.lbg_id = lbg_id;
	async->args.lb_sequence_number_width_set.direction = direction;
	async->args.lb_sequence_number_width_set.flags = flags;
	async->args.lb_sequence_number_width_set.number_width = number_width;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_stat_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_stat_val_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_stat_get.unit = unit;
	async->args.lb_stat_get.lbg_id = lbg_id;
	async->args.lb_stat_get.direction = direction;
	async->args.lb_stat_get.flags = flags;
	async->args.lb_stat_get.type = type;
	async->args.lb_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_status_get_async(
	int unit,
	bcm_lbg_t lbg_id,
	bcm_lb_direction_type_t direction,
	uint32 flags,
	bcm_lb_status_type_t status_type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_status_get.unit = unit;
	async->args.lb_status_get.lbg_id = lbg_id;
	async->args.lb_status_get.direction = direction;
	async->args.lb_status_get.flags = flags;
	async->args.lb_status_get.status_type = status_type;
	async->args.lb_status_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_tc_dp_to_priority_config_get_async(
	int unit,
	uint32 flags,
	bcm_lb_tc_dp_t * tc_dp,
	bcm_lb_pkt_pri_t * pkt_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_TC_DP_TO_PRIORITY_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_tc_dp_to_priority_config_get.unit = unit;
	async->args.lb_tc_dp_to_priority_config_get.flags = flags;
	async->args.lb_tc_dp_to_priority_config_get.tc_dp = tc_dp;
	async->args.lb_tc_dp_to_priority_config_get.pkt_pri = pkt_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_tc_dp_to_priority_config_set_async(
	int unit,
	uint32 flags,
	bcm_lb_tc_dp_t * tc_dp,
	bcm_lb_pkt_pri_t * pkt_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_TC_DP_TO_PRIORITY_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_tc_dp_to_priority_config_set.unit = unit;
	async->args.lb_tc_dp_to_priority_config_set.flags = flags;
	async->args.lb_tc_dp_to_priority_config_set.tc_dp = tc_dp;
	async->args.lb_tc_dp_to_priority_config_set.pkt_pri = pkt_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_tx_sched_get_async(
	int unit,
	uint32 flags,
	int max_lbg_count,
	bcm_lb_lbg_weight_t * lbg_weights,
	int * lbg_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_TX_SCHED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_tx_sched_get.unit = unit;
	async->args.lb_tx_sched_get.flags = flags;
	async->args.lb_tx_sched_get.max_lbg_count = max_lbg_count;
	async->args.lb_tx_sched_get.lbg_weights = lbg_weights;
	async->args.lb_tx_sched_get.lbg_count = lbg_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_lb_tx_sched_set_async(
	int unit,
	uint32 flags,
	int lbg_count,
	bcm_lb_lbg_weight_t * lbg_weights,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LB_TX_SCHED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.lb_tx_sched_set.unit = unit;
	async->args.lb_tx_sched_set.flags = flags;
	async->args.lb_tx_sched_set.lbg_count = lbg_count;
	async->args.lb_tx_sched_set.lbg_weights = lbg_weights;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_link_change_async(
	int unit,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINK_CHANGE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.link_change.unit = unit;
	async->args.link_change.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_link_wait_async(
	int unit,
	bcm_pbmp_t * pbm,
	int us,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINK_WAIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.link_wait.unit = unit;
	async->args.link_wait.pbm = pbm;
	async->args.link_wait.us = us;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_linkscan_dump_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_dump.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_linkscan_enable_get_async(
	int unit,
	int * us,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_get.unit = unit;
	async->args.linkscan_enable_get.us = us;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_enable_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_port_get.unit = unit;
	async->args.linkscan_enable_port_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_enable_set_async(
	int unit,
	int us,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_set.unit = unit;
	async->args.linkscan_enable_set.us = us;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_mode_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_mode_get.unit = unit;
	async->args.linkscan_mode_get.port = port;
	async->args.linkscan_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_mode_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_mode_set.unit = unit;
	async->args.linkscan_mode_set.port = port;
	async->args.linkscan_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_mode_set_pbm_async(
	int unit,
	bcm_pbmp_t pbm,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_MODE_SET_PBM;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_mode_set_pbm.unit = unit;
	async->args.linkscan_mode_set_pbm.pbm = pbm;
	async->args.linkscan_mode_set_pbm.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_port_register_async(
	int unit,
	bcm_port_t port,
	bcm_linkscan_port_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_PORT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_port_register.unit = unit;
	async->args.linkscan_port_register.port = port;
	async->args.linkscan_port_register.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_port_unregister_async(
	int unit,
	bcm_port_t port,
	bcm_linkscan_port_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_PORT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_port_unregister.unit = unit;
	async->args.linkscan_port_unregister.port = port;
	async->args.linkscan_port_unregister.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_register_async(
	int unit,
	bcm_linkscan_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_register.unit = unit;
	async->args.linkscan_register.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_trigger_event_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_linkscan_trigger_event_t trigger_event,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_TRIGGER_EVENT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_trigger_event_get.unit = unit;
	async->args.linkscan_trigger_event_get.port = port;
	async->args.linkscan_trigger_event_get.flags = flags;
	async->args.linkscan_trigger_event_get.trigger_event = trigger_event;
	async->args.linkscan_trigger_event_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_trigger_event_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_linkscan_trigger_event_t trigger_event,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_TRIGGER_EVENT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_trigger_event_set.unit = unit;
	async->args.linkscan_trigger_event_set.port = port;
	async->args.linkscan_trigger_event_set.flags = flags;
	async->args.linkscan_trigger_event_set.trigger_event = trigger_event;
	async->args.linkscan_trigger_event_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_unregister_async(
	int unit,
	bcm_linkscan_handler_t f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_unregister.unit = unit;
	async->args.linkscan_unregister.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_linkscan_update_async(
	int unit,
	bcm_pbmp_t pbm,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_LINKSCAN_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_update.unit = unit;
	async->args.linkscan_update.pbm = pbm;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_MACSEC

void
bcm_macsec_event_enable_get_async(
	int unit,
	bcm_macsec_event_t t,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_EVENT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_event_enable_get.unit = unit;
	async->args.macsec_event_enable_get.t = t;
	async->args.macsec_event_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_event_enable_set_async(
	int unit,
	bcm_macsec_event_t t,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_EVENT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_event_enable_set.unit = unit;
	async->args.macsec_event_enable_set.t = t;
	async->args.macsec_event_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_event_register_async(
	int unit,
	bcm_macsec_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_event_register.unit = unit;
	async->args.macsec_event_register.cb = cb;
	async->args.macsec_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_event_unregister_async(
	int unit,
	bcm_macsec_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_event_unregister.unit = unit;
	async->args.macsec_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_flow_create_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_macsec_flow_match_t * flow,
	bcm_macsec_flow_action_t * action,
	int * flowId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_FLOW_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_flow_create.unit = unit;
	async->args.macsec_flow_create.port = port;
	async->args.macsec_flow_create.flags = flags;
	async->args.macsec_flow_create.flow = flow;
	async->args.macsec_flow_create.action = action;
	async->args.macsec_flow_create.flowId = flowId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_flow_destroy_async(
	int unit,
	bcm_port_t port,
	int flowId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_FLOW_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_flow_destroy.unit = unit;
	async->args.macsec_flow_destroy.port = port;
	async->args.macsec_flow_destroy.flowId = flowId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_flow_get_async(
	int unit,
	bcm_port_t port,
	int flowId,
	bcm_macsec_flow_match_t * flow,
	bcm_macsec_flow_action_t * a,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_FLOW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_flow_get.unit = unit;
	async->args.macsec_flow_get.port = port;
	async->args.macsec_flow_get.flowId = flowId;
	async->args.macsec_flow_get.flow = flow;
	async->args.macsec_flow_get.a = a;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_flow_traverse_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_flow_traverse_cb callbk,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_FLOW_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_flow_traverse.unit = unit;
	async->args.macsec_flow_traverse.port = port;
	async->args.macsec_flow_traverse.callbk = callbk;
	async->args.macsec_flow_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_port_capability_get_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_port_capability_t * cap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_PORT_CAPABILITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_port_capability_get.unit = unit;
	async->args.macsec_port_capability_get.port = port;
	async->args.macsec_port_capability_get.cap = cap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_port_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_PORT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_port_config_get.unit = unit;
	async->args.macsec_port_config_get.port = port;
	async->args.macsec_port_config_get.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_port_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_port_config_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_PORT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_port_config_set.unit = unit;
	async->args.macsec_port_config_set.port = port;
	async->args.macsec_port_config_set.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_port_traverse_async(
	int unit,
	bcm_macsec_port_traverse_cb callbk,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_port_traverse.unit = unit;
	async->args.macsec_port_traverse.callbk = callbk;
	async->args.macsec_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_assoc_create_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int chanId,
	bcm_macsec_secure_assoc_t * assoc,
	int * assocId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_assoc_create.unit = unit;
	async->args.macsec_secure_assoc_create.port = port;
	async->args.macsec_secure_assoc_create.flags = flags;
	async->args.macsec_secure_assoc_create.chanId = chanId;
	async->args.macsec_secure_assoc_create.assoc = assoc;
	async->args.macsec_secure_assoc_create.assocId = assocId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_assoc_destroy_async(
	int unit,
	bcm_port_t port,
	int assocId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_assoc_destroy.unit = unit;
	async->args.macsec_secure_assoc_destroy.port = port;
	async->args.macsec_secure_assoc_destroy.assocId = assocId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_assoc_get_async(
	int unit,
	bcm_port_t port,
	int assocId,
	bcm_macsec_secure_assoc_t * assoc,
	int * chanId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_assoc_get.unit = unit;
	async->args.macsec_secure_assoc_get.port = port;
	async->args.macsec_secure_assoc_get.assocId = assocId;
	async->args.macsec_secure_assoc_get.assoc = assoc;
	async->args.macsec_secure_assoc_get.chanId = chanId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_assoc_traverse_async(
	int unit,
	bcm_port_t port,
	int chanId,
	bcm_macsec_secure_assoc_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_assoc_traverse.unit = unit;
	async->args.macsec_secure_assoc_traverse.port = port;
	async->args.macsec_secure_assoc_traverse.chanId = chanId;
	async->args.macsec_secure_assoc_traverse.cb = cb;
	async->args.macsec_secure_assoc_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_chan_create_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_macsec_secure_chan_t * chan,
	int * chanId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_chan_create.unit = unit;
	async->args.macsec_secure_chan_create.port = port;
	async->args.macsec_secure_chan_create.flags = flags;
	async->args.macsec_secure_chan_create.chan = chan;
	async->args.macsec_secure_chan_create.chanId = chanId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_chan_destroy_async(
	int unit,
	bcm_port_t port,
	int chanId,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_chan_destroy.unit = unit;
	async->args.macsec_secure_chan_destroy.port = port;
	async->args.macsec_secure_chan_destroy.chanId = chanId;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_chan_get_async(
	int unit,
	bcm_port_t port,
	int chanId,
	bcm_macsec_secure_chan_t * chan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_chan_get.unit = unit;
	async->args.macsec_secure_chan_get.port = port;
	async->args.macsec_secure_chan_get.chanId = chanId;
	async->args.macsec_secure_chan_get.chan = chan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_secure_chan_traverse_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_chan_traverse_cb calback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_secure_chan_traverse.unit = unit;
	async->args.macsec_secure_chan_traverse.port = port;
	async->args.macsec_secure_chan_traverse.calback = calback;
	async->args.macsec_secure_chan_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_stat_clear_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_stat_clear.unit = unit;
	async->args.macsec_stat_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_stat_get_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_stat_t stat,
	int chanId,
	int assocId,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_stat_get.unit = unit;
	async->args.macsec_stat_get.port = port;
	async->args.macsec_stat_get.stat = stat;
	async->args.macsec_stat_get.chanId = chanId;
	async->args.macsec_stat_get.assocId = assocId;
	async->args.macsec_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_stat_get32_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_stat_t stat,
	int chanId,
	int assocId,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_stat_get32.unit = unit;
	async->args.macsec_stat_get32.port = port;
	async->args.macsec_stat_get32.stat = stat;
	async->args.macsec_stat_get32.chanId = chanId;
	async->args.macsec_stat_get32.assocId = assocId;
	async->args.macsec_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_stat_set_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_stat_t stat,
	int chanId,
	int assocId,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_stat_set.unit = unit;
	async->args.macsec_stat_set.port = port;
	async->args.macsec_stat_set.stat = stat;
	async->args.macsec_stat_set.chanId = chanId;
	async->args.macsec_stat_set.assocId = assocId;
	async->args.macsec_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_macsec_stat_set32_async(
	int unit,
	bcm_port_t port,
	bcm_macsec_stat_t stat,
	int chanId,
	int assocId,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MACSEC_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.macsec_stat_set32.unit = unit;
	async->args.macsec_stat_set32.port = port;
	async->args.macsec_stat_set32.stat = stat;
	async->args.macsec_stat_set32.chanId = chanId;
	async->args.macsec_stat_set32.assocId = assocId;
	async->args.macsec_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_MACSEC */

void
bcm_mcast_addr_add_async(
	int unit,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_ADDR_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_add.unit = unit;
	async->args.mcast_addr_add.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_addr_add_w_l2mcindex_async(
	int unit,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_ADDR_ADD_W_L2MCINDEX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_add_w_l2mcindex.unit = unit;
	async->args.mcast_addr_add_w_l2mcindex.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_addr_remove_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_ADDR_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_remove.unit = unit;
	async->args.mcast_addr_remove.mac = (uint8 *)mac;
	async->args.mcast_addr_remove.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_addr_remove_w_l2mcindex_async(
	int unit,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_ADDR_REMOVE_W_L2MCINDEX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_remove_w_l2mcindex.unit = unit;
	async->args.mcast_addr_remove_w_l2mcindex.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_bitmap_del_async(
	int unit,
	int mc_idx,
	bcm_port_t in_port,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_BITMAP_DEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_bitmap_del.unit = unit;
	async->args.mcast_bitmap_del.mc_idx = mc_idx;
	async->args.mcast_bitmap_del.in_port = in_port;
	async->args.mcast_bitmap_del.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_bitmap_get_async(
	int unit,
	int mc_idx,
	bcm_port_t in_port,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_BITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_bitmap_get.unit = unit;
	async->args.mcast_bitmap_get.mc_idx = mc_idx;
	async->args.mcast_bitmap_get.in_port = in_port;
	async->args.mcast_bitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_bitmap_max_get_async(
	int unit,
	int * max_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_BITMAP_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_bitmap_max_get.unit = unit;
	async->args.mcast_bitmap_max_get.max_index = max_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_bitmap_set_async(
	int unit,
	int mc_idx,
	bcm_port_t in_port,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_BITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_bitmap_set.unit = unit;
	async->args.mcast_bitmap_set.mc_idx = mc_idx;
	async->args.mcast_bitmap_set.in_port = in_port;
	async->args.mcast_bitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_join_async(
	int unit,
	bcm_mac_t mcMacAddr,
	bcm_vlan_t vlanId,
	int srcPort,
	bcm_mcast_addr_t * mcaddr,
	bcm_pbmp_t * allRouterBmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_JOIN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_join.unit = unit;
	async->args.mcast_join.mcMacAddr = (uint8 *)mcMacAddr;
	async->args.mcast_join.vlanId = vlanId;
	async->args.mcast_join.srcPort = srcPort;
	async->args.mcast_join.mcaddr = mcaddr;
	async->args.mcast_join.allRouterBmp = allRouterBmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_leave_async(
	int unit,
	bcm_mac_t mcMacAddr,
	bcm_vlan_t vlanId,
	int srcPort,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_LEAVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_leave.unit = unit;
	async->args.mcast_leave.mcMacAddr = (uint8 *)mcMacAddr;
	async->args.mcast_leave.vlanId = vlanId;
	async->args.mcast_leave.srcPort = srcPort;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_port_add_async(
	int unit,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_add.unit = unit;
	async->args.mcast_port_add.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_port_get_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_get.unit = unit;
	async->args.mcast_port_get.mac = (uint8 *)mac;
	async->args.mcast_port_get.vid = vid;
	async->args.mcast_port_get.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mcast_port_remove_async(
	int unit,
	bcm_mcast_addr_t * mcaddr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MCAST_PORT_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_remove.unit = unit;
	async->args.mcast_port_remove.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_mim_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_attach_async(
	int unit,
	int lookup_id,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_attach.unit = unit;
	async->args.mim_lookup_id_stat_attach.lookup_id = lookup_id;
	async->args.mim_lookup_id_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_counter_get_async(
	int unit,
	int lookup_id,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_counter_get.unit = unit;
	async->args.mim_lookup_id_stat_counter_get.lookup_id = lookup_id;
	async->args.mim_lookup_id_stat_counter_get.stat = stat;
	async->args.mim_lookup_id_stat_counter_get.num_entries = num_entries;
	async->args.mim_lookup_id_stat_counter_get.counter_indexes = counter_indexes;
	async->args.mim_lookup_id_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_counter_set_async(
	int unit,
	int lookup_id,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_counter_set.unit = unit;
	async->args.mim_lookup_id_stat_counter_set.lookup_id = lookup_id;
	async->args.mim_lookup_id_stat_counter_set.stat = stat;
	async->args.mim_lookup_id_stat_counter_set.num_entries = num_entries;
	async->args.mim_lookup_id_stat_counter_set.counter_indexes = counter_indexes;
	async->args.mim_lookup_id_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_counter_sync_get_async(
	int unit,
	int lookup_id,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_counter_sync_get.unit = unit;
	async->args.mim_lookup_id_stat_counter_sync_get.lookup_id = lookup_id;
	async->args.mim_lookup_id_stat_counter_sync_get.stat = stat;
	async->args.mim_lookup_id_stat_counter_sync_get.num_entries = num_entries;
	async->args.mim_lookup_id_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.mim_lookup_id_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_detach_async(
	int unit,
	int lookup_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_detach.unit = unit;
	async->args.mim_lookup_id_stat_detach.lookup_id = lookup_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_lookup_id_stat_id_get_async(
	int unit,
	int lookup_id,
	bcm_mim_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_LOOKUP_ID_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_lookup_id_stat_id_get.unit = unit;
	async->args.mim_lookup_id_stat_id_get.lookup_id = lookup_id;
	async->args.mim_lookup_id_stat_id_get.stat = stat;
	async->args.mim_lookup_id_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_port_add_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_port_t * mim_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_add.unit = unit;
	async->args.mim_port_add.vpn = vpn;
	async->args.mim_port_add.mim_port = mim_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_port_delete_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_gport_t mim_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_delete.unit = unit;
	async->args.mim_port_delete.vpn = vpn;
	async->args.mim_port_delete.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_port_delete_all_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_delete_all.unit = unit;
	async->args.mim_port_delete_all.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_port_get_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_port_t * mim_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_get.unit = unit;
	async->args.mim_port_get.vpn = vpn;
	async->args.mim_port_get.mim_port = mim_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_port_get_all_async(
	int unit,
	bcm_mim_vpn_t vpn,
	int port_max,
	bcm_mim_port_t * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_PORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_get_all.unit = unit;
	async->args.mim_port_get_all.vpn = vpn;
	async->args.mim_port_get_all.port_max = port_max;
	async->args.mim_port_get_all.port_array = port_array;
	async->args.mim_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_create_async(
	int unit,
	bcm_mim_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_create.unit = unit;
	async->args.mim_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_destroy_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_destroy.unit = unit;
	async->args.mim_vpn_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_get_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_get.unit = unit;
	async->args.mim_vpn_get.vpn = vpn;
	async->args.mim_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_attach_async(
	int unit,
	bcm_mim_vpn_t vpn,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_attach.unit = unit;
	async->args.mim_vpn_stat_attach.vpn = vpn;
	async->args.mim_vpn_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_counter_get_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_counter_get.unit = unit;
	async->args.mim_vpn_stat_counter_get.vpn = vpn;
	async->args.mim_vpn_stat_counter_get.stat = stat;
	async->args.mim_vpn_stat_counter_get.num_entries = num_entries;
	async->args.mim_vpn_stat_counter_get.counter_indexes = counter_indexes;
	async->args.mim_vpn_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_counter_set_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_counter_set.unit = unit;
	async->args.mim_vpn_stat_counter_set.vpn = vpn;
	async->args.mim_vpn_stat_counter_set.stat = stat;
	async->args.mim_vpn_stat_counter_set.num_entries = num_entries;
	async->args.mim_vpn_stat_counter_set.counter_indexes = counter_indexes;
	async->args.mim_vpn_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_counter_sync_get_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_counter_sync_get.unit = unit;
	async->args.mim_vpn_stat_counter_sync_get.vpn = vpn;
	async->args.mim_vpn_stat_counter_sync_get.stat = stat;
	async->args.mim_vpn_stat_counter_sync_get.num_entries = num_entries;
	async->args.mim_vpn_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.mim_vpn_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_detach_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_detach.unit = unit;
	async->args.mim_vpn_stat_detach.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_stat_id_get_async(
	int unit,
	bcm_mim_vpn_t vpn,
	bcm_mim_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_stat_id_get.unit = unit;
	async->args.mim_vpn_stat_id_get.vpn = vpn;
	async->args.mim_vpn_stat_id_get.stat = stat;
	async->args.mim_vpn_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mim_vpn_traverse_async(
	int unit,
	bcm_mim_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIM_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_traverse.unit = unit;
	async->args.mim_vpn_traverse.cb = cb;
	async->args.mim_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_mirror_destination_create_async(
	int unit,
	bcm_mirror_destination_t * mirror_dest,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_DESTINATION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_create.unit = unit;
	async->args.mirror_destination_create.mirror_dest = mirror_dest;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_destination_destroy_async(
	int unit,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_DESTINATION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_destroy.unit = unit;
	async->args.mirror_destination_destroy.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_destination_get_async(
	int unit,
	bcm_gport_t mirror_dest_id,
	bcm_mirror_destination_t * mirror_dest,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_DESTINATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_get.unit = unit;
	async->args.mirror_destination_get.mirror_dest_id = mirror_dest_id;
	async->args.mirror_destination_get.mirror_dest = mirror_dest;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_destination_traverse_async(
	int unit,
	bcm_mirror_destination_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_DESTINATION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_traverse.unit = unit;
	async->args.mirror_destination_traverse.cb = cb;
	async->args.mirror_destination_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_egress_get_async(
	int unit,
	bcm_port_t port,
	int * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_egress_get.unit = unit;
	async->args.mirror_egress_get.port = port;
	async->args.mirror_egress_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_egress_set_async(
	int unit,
	bcm_port_t port,
	int val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_egress_set.unit = unit;
	async->args.mirror_egress_set.port = port;
	async->args.mirror_egress_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_ingress_get_async(
	int unit,
	bcm_port_t port,
	int * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_INGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_ingress_get.unit = unit;
	async->args.mirror_ingress_get.port = port;
	async->args.mirror_ingress_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_ingress_set_async(
	int unit,
	bcm_port_t port,
	int val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_INGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_ingress_set.unit = unit;
	async->args.mirror_ingress_set.port = port;
	async->args.mirror_ingress_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_mode_get_async(
	int unit,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_mode_get.unit = unit;
	async->args.mirror_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_mode_set_async(
	int unit,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_mode_set.unit = unit;
	async->args.mirror_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_dest_add_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_add.unit = unit;
	async->args.mirror_port_dest_add.port = port;
	async->args.mirror_port_dest_add.flags = flags;
	async->args.mirror_port_dest_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_dest_delete_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_gport_t mirror_dest_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_delete.unit = unit;
	async->args.mirror_port_dest_delete.port = port;
	async->args.mirror_port_dest_delete.flags = flags;
	async->args.mirror_port_dest_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_dest_delete_all_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_delete_all.unit = unit;
	async->args.mirror_port_dest_delete_all.port = port;
	async->args.mirror_port_dest_delete_all.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_dest_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest,
	int * mirror_dest_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_get.unit = unit;
	async->args.mirror_port_dest_get.port = port;
	async->args.mirror_port_dest_get.flags = flags;
	async->args.mirror_port_dest_get.mirror_dest_size = mirror_dest_size;
	async->args.mirror_port_dest_get.mirror_dest = mirror_dest;
	async->args.mirror_port_dest_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_destination_add_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_gport_t mirror_dest,
	bcm_mirror_options_t options,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DESTINATION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_destination_add.unit = unit;
	async->args.mirror_port_destination_add.port = port;
	async->args.mirror_port_destination_add.flags = flags;
	async->args.mirror_port_destination_add.mirror_dest = mirror_dest;
	async->args.mirror_port_destination_add.options = options;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_destination_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest,
	int * mirror_dest_count,
	bcm_mirror_options_t * options,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_DESTINATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_destination_get.unit = unit;
	async->args.mirror_port_destination_get.port = port;
	async->args.mirror_port_destination_get.flags = flags;
	async->args.mirror_port_destination_get.mirror_dest_size = mirror_dest_size;
	async->args.mirror_port_destination_get.mirror_dest = mirror_dest;
	async->args.mirror_port_destination_get.mirror_dest_count = mirror_dest_count;
	async->args.mirror_port_destination_get.options = options;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_module_t * dest_mod,
	bcm_port_t * dest_port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_get.unit = unit;
	async->args.mirror_port_get.port = port;
	async->args.mirror_port_get.dest_mod = dest_mod;
	async->args.mirror_port_get.dest_port = dest_port;
	async->args.mirror_port_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_info_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_mirror_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_info_get.unit = unit;
	async->args.mirror_port_info_get.port = port;
	async->args.mirror_port_info_get.flags = flags;
	async->args.mirror_port_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_info_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_mirror_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_INFO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_info_set.unit = unit;
	async->args.mirror_port_info_set.port = port;
	async->args.mirror_port_info_set.flags = flags;
	async->args.mirror_port_info_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_set_async(
	int unit,
	bcm_port_t port,
	bcm_module_t dest_mod,
	bcm_port_t dest_port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_set.unit = unit;
	async->args.mirror_port_set.port = port;
	async->args.mirror_port_set.dest_mod = dest_mod;
	async->args.mirror_port_set.dest_port = dest_port;
	async->args.mirror_port_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_dest_add_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	bcm_gport_t destid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DEST_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_dest_add.unit = unit;
	async->args.mirror_port_vlan_dest_add.port = port;
	async->args.mirror_port_vlan_dest_add.vlan = vlan;
	async->args.mirror_port_vlan_dest_add.flags = flags;
	async->args.mirror_port_vlan_dest_add.destid = destid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_dest_delete_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	bcm_gport_t destid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DEST_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_dest_delete.unit = unit;
	async->args.mirror_port_vlan_dest_delete.port = port;
	async->args.mirror_port_vlan_dest_delete.vlan = vlan;
	async->args.mirror_port_vlan_dest_delete.flags = flags;
	async->args.mirror_port_vlan_dest_delete.destid = destid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_dest_delete_all_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DEST_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_dest_delete_all.unit = unit;
	async->args.mirror_port_vlan_dest_delete_all.port = port;
	async->args.mirror_port_vlan_dest_delete_all.vlan = vlan;
	async->args.mirror_port_vlan_dest_delete_all.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_dest_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	uint32 mirror_dest_size,
	bcm_gport_t * destid,
	uint32 * destcount,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_dest_get.unit = unit;
	async->args.mirror_port_vlan_dest_get.port = port;
	async->args.mirror_port_vlan_dest_get.vlan = vlan;
	async->args.mirror_port_vlan_dest_get.flags = flags;
	async->args.mirror_port_vlan_dest_get.mirror_dest_size = mirror_dest_size;
	async->args.mirror_port_vlan_dest_get.destid = destid;
	async->args.mirror_port_vlan_dest_get.destcount = destcount;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_destination_add_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	bcm_gport_t destid,
	bcm_mirror_options_t options,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DESTINATION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_destination_add.unit = unit;
	async->args.mirror_port_vlan_destination_add.port = port;
	async->args.mirror_port_vlan_destination_add.vlan = vlan;
	async->args.mirror_port_vlan_destination_add.flags = flags;
	async->args.mirror_port_vlan_destination_add.destid = destid;
	async->args.mirror_port_vlan_destination_add.options = options;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_destination_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	uint32 flags,
	uint32 mirror_dest_size,
	bcm_gport_t * destid,
	uint32 * destcount,
	bcm_mirror_options_t * options,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_DESTINATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_destination_get.unit = unit;
	async->args.mirror_port_vlan_destination_get.port = port;
	async->args.mirror_port_vlan_destination_get.vlan = vlan;
	async->args.mirror_port_vlan_destination_get.flags = flags;
	async->args.mirror_port_vlan_destination_get.mirror_dest_size = mirror_dest_size;
	async->args.mirror_port_vlan_destination_get.destid = destid;
	async->args.mirror_port_vlan_destination_get.destcount = destcount;
	async->args.mirror_port_vlan_destination_get.options = options;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	bcm_gport_t * dest_port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_get.unit = unit;
	async->args.mirror_port_vlan_get.port = port;
	async->args.mirror_port_vlan_get.vlan = vlan;
	async->args.mirror_port_vlan_get.dest_port = dest_port;
	async->args.mirror_port_vlan_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_port_vlan_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	bcm_gport_t destport,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_PORT_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_vlan_set.unit = unit;
	async->args.mirror_port_vlan_set.port = port;
	async->args.mirror_port_vlan_set.vlan = vlan;
	async->args.mirror_port_vlan_set.destport = destport;
	async->args.mirror_port_vlan_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_to_get_async(
	int unit,
	bcm_port_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_TO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_get.unit = unit;
	async->args.mirror_to_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_to_pbmp_get_async(
	int unit,
	bcm_port_t port,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_TO_PBMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_pbmp_get.unit = unit;
	async->args.mirror_to_pbmp_get.port = port;
	async->args.mirror_to_pbmp_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_to_pbmp_set_async(
	int unit,
	bcm_port_t port,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_TO_PBMP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_pbmp_set.unit = unit;
	async->args.mirror_to_pbmp_set.port = port;
	async->args.mirror_to_pbmp_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_to_set_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_TO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_set.unit = unit;
	async->args.mirror_to_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_vlan_get_async(
	int unit,
	bcm_port_t port,
	uint16 * tpid,
	uint16 * vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_vlan_get.unit = unit;
	async->args.mirror_vlan_get.port = port;
	async->args.mirror_vlan_get.tpid = tpid;
	async->args.mirror_vlan_get.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mirror_vlan_set_async(
	int unit,
	bcm_port_t port,
	uint16 tpid,
	uint16 vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MIRROR_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_vlan_set.unit = unit;
	async->args.mirror_vlan_set.port = port;
	async->args.mirror_vlan_set.tpid = tpid;
	async->args.mirror_vlan_set.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

/* bcm_module_name has a non int return type */
#ifdef	INCLUDE_L3

void
bcm_mpls_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_entropy_identifier_add_async(
	int unit,
	uint32 options,
	bcm_mpls_entropy_identifier_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_ENTROPY_IDENTIFIER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_entropy_identifier_add.unit = unit;
	async->args.mpls_entropy_identifier_add.options = options;
	async->args.mpls_entropy_identifier_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_entropy_identifier_delete_async(
	int unit,
	bcm_mpls_entropy_identifier_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_ENTROPY_IDENTIFIER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_entropy_identifier_delete.unit = unit;
	async->args.mpls_entropy_identifier_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_entropy_identifier_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_ENTROPY_IDENTIFIER_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_entropy_identifier_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_entropy_identifier_get_async(
	int unit,
	bcm_mpls_entropy_identifier_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_ENTROPY_IDENTIFIER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_entropy_identifier_get.unit = unit;
	async->args.mpls_entropy_identifier_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_entropy_identifier_traverse_async(
	int unit,
	bcm_mpls_entropy_identifier_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_ENTROPY_IDENTIFIER_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_entropy_identifier_traverse.unit = unit;
	async->args.mpls_entropy_identifier_traverse.cb = cb;
	async->args.mpls_entropy_identifier_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_exp_map_create_async(
	int unit,
	uint32 flags,
	int * exp_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_EXP_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_create.unit = unit;
	async->args.mpls_exp_map_create.flags = flags;
	async->args.mpls_exp_map_create.exp_map_id = exp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_exp_map_destroy_async(
	int unit,
	int exp_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_EXP_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_destroy.unit = unit;
	async->args.mpls_exp_map_destroy.exp_map_id = exp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_exp_map_get_async(
	int unit,
	int exp_map_id,
	bcm_mpls_exp_map_t * exp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_EXP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_get.unit = unit;
	async->args.mpls_exp_map_get.exp_map_id = exp_map_id;
	async->args.mpls_exp_map_get.exp_map = exp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_exp_map_set_async(
	int unit,
	int exp_map_id,
	bcm_mpls_exp_map_t * exp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_EXP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_set.unit = unit;
	async->args.mpls_exp_map_set.exp_map_id = exp_map_id;
	async->args.mpls_exp_map_set.exp_map = exp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_attach_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_attach.unit = unit;
	async->args.mpls_label_stat_attach.label = label;
	async->args.mpls_label_stat_attach.port = port;
	async->args.mpls_label_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_clear_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_clear.unit = unit;
	async->args.mpls_label_stat_clear.label = label;
	async->args.mpls_label_stat_clear.port = port;
	async->args.mpls_label_stat_clear.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_counter_get_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_counter_get.unit = unit;
	async->args.mpls_label_stat_counter_get.label = label;
	async->args.mpls_label_stat_counter_get.port = port;
	async->args.mpls_label_stat_counter_get.stat = stat;
	async->args.mpls_label_stat_counter_get.num_entries = num_entries;
	async->args.mpls_label_stat_counter_get.counter_indexes = counter_indexes;
	async->args.mpls_label_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_counter_set_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_counter_set.unit = unit;
	async->args.mpls_label_stat_counter_set.label = label;
	async->args.mpls_label_stat_counter_set.port = port;
	async->args.mpls_label_stat_counter_set.stat = stat;
	async->args.mpls_label_stat_counter_set.num_entries = num_entries;
	async->args.mpls_label_stat_counter_set.counter_indexes = counter_indexes;
	async->args.mpls_label_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_counter_sync_get_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_counter_sync_get.unit = unit;
	async->args.mpls_label_stat_counter_sync_get.label = label;
	async->args.mpls_label_stat_counter_sync_get.port = port;
	async->args.mpls_label_stat_counter_sync_get.stat = stat;
	async->args.mpls_label_stat_counter_sync_get.num_entries = num_entries;
	async->args.mpls_label_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.mpls_label_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_detach_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_detach.unit = unit;
	async->args.mpls_label_stat_detach.label = label;
	async->args.mpls_label_stat_detach.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_enable_set_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_enable_set.unit = unit;
	async->args.mpls_label_stat_enable_set.label = label;
	async->args.mpls_label_stat_enable_set.port = port;
	async->args.mpls_label_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_get_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_get.unit = unit;
	async->args.mpls_label_stat_get.label = label;
	async->args.mpls_label_stat_get.port = port;
	async->args.mpls_label_stat_get.stat = stat;
	async->args.mpls_label_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_get32_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_get32.unit = unit;
	async->args.mpls_label_stat_get32.label = label;
	async->args.mpls_label_stat_get32.port = port;
	async->args.mpls_label_stat_get32.stat = stat;
	async->args.mpls_label_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_id_get_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_id_get.unit = unit;
	async->args.mpls_label_stat_id_get.label = label;
	async->args.mpls_label_stat_id_get.port = port;
	async->args.mpls_label_stat_id_get.stat = stat;
	async->args.mpls_label_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_sync_get_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_sync_get.unit = unit;
	async->args.mpls_label_stat_sync_get.label = label;
	async->args.mpls_label_stat_sync_get.port = port;
	async->args.mpls_label_stat_sync_get.stat = stat;
	async->args.mpls_label_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_label_stat_sync_get32_async(
	int unit,
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_sync_get32.unit = unit;
	async->args.mpls_label_stat_sync_get32.label = label;
	async->args.mpls_label_stat_sync_get32.port = port;
	async->args.mpls_label_stat_sync_get32.stat = stat;
	async->args.mpls_label_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_add_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_mpls_port_t * mpls_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_add.unit = unit;
	async->args.mpls_port_add.vpn = vpn;
	async->args.mpls_port_add.mpls_port = mpls_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_delete_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t mpls_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_delete.unit = unit;
	async->args.mpls_port_delete.vpn = vpn;
	async->args.mpls_port_delete.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_delete_all_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_delete_all.unit = unit;
	async->args.mpls_port_delete_all.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_mpls_port_t * mpls_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_get.unit = unit;
	async->args.mpls_port_get.vpn = vpn;
	async->args.mpls_port_get.mpls_port = mpls_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_get_all_async(
	int unit,
	bcm_vpn_t vpn,
	int port_max,
	bcm_mpls_port_t * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_get_all.unit = unit;
	async->args.mpls_port_get_all.vpn = vpn;
	async->args.mpls_port_get_all.port_max = port_max;
	async->args.mpls_port_get_all.port_array = port_array;
	async->args.mpls_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_attach_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_attach.unit = unit;
	async->args.mpls_port_stat_attach.vpn = vpn;
	async->args.mpls_port_stat_attach.port = port;
	async->args.mpls_port_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_counter_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_counter_get.unit = unit;
	async->args.mpls_port_stat_counter_get.vpn = vpn;
	async->args.mpls_port_stat_counter_get.port = port;
	async->args.mpls_port_stat_counter_get.stat = stat;
	async->args.mpls_port_stat_counter_get.num_entries = num_entries;
	async->args.mpls_port_stat_counter_get.counter_indexes = counter_indexes;
	async->args.mpls_port_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_counter_set_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_counter_set.unit = unit;
	async->args.mpls_port_stat_counter_set.vpn = vpn;
	async->args.mpls_port_stat_counter_set.port = port;
	async->args.mpls_port_stat_counter_set.stat = stat;
	async->args.mpls_port_stat_counter_set.num_entries = num_entries;
	async->args.mpls_port_stat_counter_set.counter_indexes = counter_indexes;
	async->args.mpls_port_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_counter_sync_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_counter_sync_get.unit = unit;
	async->args.mpls_port_stat_counter_sync_get.vpn = vpn;
	async->args.mpls_port_stat_counter_sync_get.port = port;
	async->args.mpls_port_stat_counter_sync_get.stat = stat;
	async->args.mpls_port_stat_counter_sync_get.num_entries = num_entries;
	async->args.mpls_port_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.mpls_port_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_detach_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_detach.unit = unit;
	async->args.mpls_port_stat_detach.vpn = vpn;
	async->args.mpls_port_stat_detach.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_enable_set_async(
	int unit,
	bcm_gport_t mpls_port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_enable_set.unit = unit;
	async->args.mpls_port_stat_enable_set.mpls_port = mpls_port;
	async->args.mpls_port_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_get_async(
	int unit,
	bcm_gport_t mpls_port,
	bcm_cos_t cos,
	bcm_mpls_port_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_get.unit = unit;
	async->args.mpls_port_stat_get.mpls_port = mpls_port;
	async->args.mpls_port_stat_get.cos = cos;
	async->args.mpls_port_stat_get.stat = stat;
	async->args.mpls_port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_get32_async(
	int unit,
	bcm_gport_t mpls_port,
	bcm_cos_t cos,
	bcm_mpls_port_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_get32.unit = unit;
	async->args.mpls_port_stat_get32.mpls_port = mpls_port;
	async->args.mpls_port_stat_get32.cos = cos;
	async->args.mpls_port_stat_get32.stat = stat;
	async->args.mpls_port_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_id_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_id_get.unit = unit;
	async->args.mpls_port_stat_id_get.vpn = vpn;
	async->args.mpls_port_stat_id_get.port = port;
	async->args.mpls_port_stat_id_get.stat = stat;
	async->args.mpls_port_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_set_async(
	int unit,
	bcm_gport_t mpls_port,
	bcm_cos_t cos,
	bcm_mpls_port_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_set.unit = unit;
	async->args.mpls_port_stat_set.mpls_port = mpls_port;
	async->args.mpls_port_stat_set.cos = cos;
	async->args.mpls_port_stat_set.stat = stat;
	async->args.mpls_port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_port_stat_set32_async(
	int unit,
	bcm_gport_t mpls_port,
	bcm_cos_t cos,
	bcm_mpls_port_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_PORT_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_stat_set32.unit = unit;
	async->args.mpls_port_stat_set32.mpls_port = mpls_port;
	async->args.mpls_port_stat_set32.cos = cos;
	async->args.mpls_port_stat_set32.stat = stat;
	async->args.mpls_port_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_range_action_add_async(
	int unit,
	bcm_mpls_label_t label_low,
	bcm_mpls_label_t label_high,
	bcm_mpls_range_action_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_RANGE_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_range_action_add.unit = unit;
	async->args.mpls_range_action_add.label_low = label_low;
	async->args.mpls_range_action_add.label_high = label_high;
	async->args.mpls_range_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_range_action_get_async(
	int unit,
	bcm_mpls_label_t label_low,
	bcm_mpls_label_t label_high,
	bcm_mpls_range_action_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_RANGE_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_range_action_get.unit = unit;
	async->args.mpls_range_action_get.label_low = label_low;
	async->args.mpls_range_action_get.label_high = label_high;
	async->args.mpls_range_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_range_action_remove_async(
	int unit,
	bcm_mpls_label_t label_low,
	bcm_mpls_label_t label_high,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_RANGE_ACTION_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_range_action_remove.unit = unit;
	async->args.mpls_range_action_remove.label_low = label_low;
	async->args.mpls_range_action_remove.label_high = label_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_initiator_clear_async(
	int unit,
	bcm_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_clear.unit = unit;
	async->args.mpls_tunnel_initiator_clear.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_initiator_clear_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_clear_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_initiator_create_async(
	int unit,
	bcm_if_t intf,
	int num_labels,
	bcm_mpls_egress_label_t * label_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_create.unit = unit;
	async->args.mpls_tunnel_initiator_create.intf = intf;
	async->args.mpls_tunnel_initiator_create.num_labels = num_labels;
	async->args.mpls_tunnel_initiator_create.label_array = label_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_initiator_get_async(
	int unit,
	bcm_if_t intf,
	int label_max,
	bcm_mpls_egress_label_t * label_array,
	int * label_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_get.unit = unit;
	async->args.mpls_tunnel_initiator_get.intf = intf;
	async->args.mpls_tunnel_initiator_get.label_max = label_max;
	async->args.mpls_tunnel_initiator_get.label_array = label_array;
	async->args.mpls_tunnel_initiator_get.label_count = label_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_initiator_set_async(
	int unit,
	bcm_if_t intf,
	int num_labels,
	bcm_mpls_egress_label_t * label_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_set.unit = unit;
	async->args.mpls_tunnel_initiator_set.intf = intf;
	async->args.mpls_tunnel_initiator_set.num_labels = num_labels;
	async->args.mpls_tunnel_initiator_set.label_array = label_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_label_counter_id_detach_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_LABEL_COUNTER_ID_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_label_counter_id_detach.unit = unit;
	async->args.mpls_tunnel_label_counter_id_detach.intf_id = intf_id;
	async->args.mpls_tunnel_label_counter_id_detach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_label_counter_id_num_get_async(
	int unit,
	bcm_if_t intf_id,
	int * num_counters,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_LABEL_COUNTER_ID_NUM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_label_counter_id_num_get.unit = unit;
	async->args.mpls_tunnel_label_counter_id_num_get.intf_id = intf_id;
	async->args.mpls_tunnel_label_counter_id_num_get.num_counters = num_counters;
	async->args.mpls_tunnel_label_counter_id_num_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_label_counter_id_stat_get_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_mpls_stat_info_t * stat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_LABEL_COUNTER_ID_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_label_counter_id_stat_get.unit = unit;
	async->args.mpls_tunnel_label_counter_id_stat_get.intf_id = intf_id;
	async->args.mpls_tunnel_label_counter_id_stat_get.stat_counter_id = stat_counter_id;
	async->args.mpls_tunnel_label_counter_id_stat_get.stat_info = stat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_label_counter_id_stat_set_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_mpls_stat_info_t * stat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_LABEL_COUNTER_ID_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_label_counter_id_stat_set.unit = unit;
	async->args.mpls_tunnel_label_counter_id_stat_set.intf_id = intf_id;
	async->args.mpls_tunnel_label_counter_id_stat_set.stat_counter_id = stat_counter_id;
	async->args.mpls_tunnel_label_counter_id_stat_set.stat_info = stat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_label_counter_id_stat_sync_get_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_mpls_stat_info_t * stat_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_LABEL_COUNTER_ID_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_label_counter_id_stat_sync_get.unit = unit;
	async->args.mpls_tunnel_label_counter_id_stat_sync_get.intf_id = intf_id;
	async->args.mpls_tunnel_label_counter_id_stat_sync_get.stat_counter_id = stat_counter_id;
	async->args.mpls_tunnel_label_counter_id_stat_sync_get.stat_info = stat_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_attach_async(
	int unit,
	bcm_if_t intf_id,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_attach.unit = unit;
	async->args.mpls_tunnel_stat_attach.intf_id = intf_id;
	async->args.mpls_tunnel_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_counter_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_counter_get.unit = unit;
	async->args.mpls_tunnel_stat_counter_get.intf_id = intf_id;
	async->args.mpls_tunnel_stat_counter_get.stat = stat;
	async->args.mpls_tunnel_stat_counter_get.num_entries = num_entries;
	async->args.mpls_tunnel_stat_counter_get.counter_indexes = counter_indexes;
	async->args.mpls_tunnel_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_counter_set_async(
	int unit,
	bcm_if_t intf_id,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_counter_set.unit = unit;
	async->args.mpls_tunnel_stat_counter_set.intf_id = intf_id;
	async->args.mpls_tunnel_stat_counter_set.stat = stat;
	async->args.mpls_tunnel_stat_counter_set.num_entries = num_entries;
	async->args.mpls_tunnel_stat_counter_set.counter_indexes = counter_indexes;
	async->args.mpls_tunnel_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_counter_sync_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_mpls_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_counter_sync_get.unit = unit;
	async->args.mpls_tunnel_stat_counter_sync_get.intf_id = intf_id;
	async->args.mpls_tunnel_stat_counter_sync_get.stat = stat;
	async->args.mpls_tunnel_stat_counter_sync_get.num_entries = num_entries;
	async->args.mpls_tunnel_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.mpls_tunnel_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_detach_async(
	int unit,
	bcm_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_detach.unit = unit;
	async->args.mpls_tunnel_stat_detach.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_stat_id_get_async(
	int unit,
	bcm_if_t intf_id,
	bcm_mpls_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_stat_id_get.unit = unit;
	async->args.mpls_tunnel_stat_id_get.intf_id = intf_id;
	async->args.mpls_tunnel_stat_id_get.stat = stat;
	async->args.mpls_tunnel_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_add_async(
	int unit,
	bcm_mpls_tunnel_switch_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_add.unit = unit;
	async->args.mpls_tunnel_switch_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_create_async(
	int unit,
	bcm_mpls_tunnel_switch_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_create.unit = unit;
	async->args.mpls_tunnel_switch_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_delete_async(
	int unit,
	bcm_mpls_tunnel_switch_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_delete.unit = unit;
	async->args.mpls_tunnel_switch_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_get_async(
	int unit,
	bcm_mpls_tunnel_switch_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_get.unit = unit;
	async->args.mpls_tunnel_switch_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_tunnel_switch_traverse_async(
	int unit,
	bcm_mpls_tunnel_switch_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_traverse.unit = unit;
	async->args.mpls_tunnel_switch_traverse.cb = cb;
	async->args.mpls_tunnel_switch_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_vpn_id_create_async(
	int unit,
	bcm_mpls_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_VPN_ID_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_create.unit = unit;
	async->args.mpls_vpn_id_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_vpn_id_destroy_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_destroy.unit = unit;
	async->args.mpls_vpn_id_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_vpn_id_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_vpn_id_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_mpls_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_VPN_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_get.unit = unit;
	async->args.mpls_vpn_id_get.vpn = vpn;
	async->args.mpls_vpn_id_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_mpls_vpn_traverse_async(
	int unit,
	bcm_mpls_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MPLS_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_traverse.unit = unit;
	async->args.mpls_vpn_traverse.cb = cb;
	async->args.mpls_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_multicast_add_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	int nof_replications,
	bcm_multicast_replication_t * rep_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_add.unit = unit;
	async->args.multicast_add.group = group;
	async->args.multicast_add.flags = flags;
	async->args.multicast_add.nof_replications = nof_replications;
	async->args.multicast_add.rep_array = rep_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_control_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_multicast_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_control_get.unit = unit;
	async->args.multicast_control_get.group = group;
	async->args.multicast_control_get.type = type;
	async->args.multicast_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_control_set_async(
	int unit,
	bcm_multicast_t group,
	bcm_multicast_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_control_set.unit = unit;
	async->args.multicast_control_set.group = group;
	async->args.multicast_control_set.type = type;
	async->args.multicast_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_create_async(
	int unit,
	uint32 flags,
	bcm_multicast_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_create.unit = unit;
	async->args.multicast_create.flags = flags;
	async->args.multicast_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_delete_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	int nof_replications,
	bcm_multicast_replication_t * rep_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_delete.unit = unit;
	async->args.multicast_delete.group = group;
	async->args.multicast_delete.flags = flags;
	async->args.multicast_delete.nof_replications = nof_replications;
	async->args.multicast_delete.rep_array = rep_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_destroy_async(
	int unit,
	bcm_multicast_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_destroy.unit = unit;
	async->args.multicast_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_add_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_add.unit = unit;
	async->args.multicast_egress_add.group = group;
	async->args.multicast_egress_add.port = port;
	async->args.multicast_egress_add.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_delete_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_delete.unit = unit;
	async->args.multicast_egress_delete.group = group;
	async->args.multicast_egress_delete.port = port;
	async->args.multicast_egress_delete.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_delete_all_async(
	int unit,
	bcm_multicast_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_delete_all.unit = unit;
	async->args.multicast_egress_delete_all.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_get_async(
	int unit,
	bcm_multicast_t group,
	int port_max,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_get.unit = unit;
	async->args.multicast_egress_get.group = group;
	async->args.multicast_egress_get.port_max = port_max;
	async->args.multicast_egress_get.port_array = port_array;
	async->args.multicast_egress_get.encap_id_array = encap_id_array;
	async->args.multicast_egress_get.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_object_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_if_t intf,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_OBJECT_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_object_encap_get.unit = unit;
	async->args.multicast_egress_object_encap_get.group = group;
	async->args.multicast_egress_object_encap_get.intf = intf;
	async->args.multicast_egress_object_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_set_async(
	int unit,
	bcm_multicast_t group,
	int port_count,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_set.unit = unit;
	async->args.multicast_egress_set.group = group;
	async->args.multicast_egress_set.port_count = port_count;
	async->args.multicast_egress_set.port_array = port_array;
	async->args.multicast_egress_set.encap_id_array = encap_id_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_add_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_gport_t subscriber_queue,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_add.unit = unit;
	async->args.multicast_egress_subscriber_add.group = group;
	async->args.multicast_egress_subscriber_add.port = port;
	async->args.multicast_egress_subscriber_add.encap_id = encap_id;
	async->args.multicast_egress_subscriber_add.subscriber_queue = subscriber_queue;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_delete_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_gport_t subscriber_queue,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_delete.unit = unit;
	async->args.multicast_egress_subscriber_delete.group = group;
	async->args.multicast_egress_subscriber_delete.port = port;
	async->args.multicast_egress_subscriber_delete.encap_id = encap_id;
	async->args.multicast_egress_subscriber_delete.subscriber_queue = subscriber_queue;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_get_async(
	int unit,
	bcm_multicast_t group,
	int port_max,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	bcm_gport_t * subscriber_queue_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_get.unit = unit;
	async->args.multicast_egress_subscriber_get.group = group;
	async->args.multicast_egress_subscriber_get.port_max = port_max;
	async->args.multicast_egress_subscriber_get.port_array = port_array;
	async->args.multicast_egress_subscriber_get.encap_id_array = encap_id_array;
	async->args.multicast_egress_subscriber_get.subscriber_queue_array = subscriber_queue_array;
	async->args.multicast_egress_subscriber_get.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_qos_map_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t subscriber_queue,
	int * qos_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_QOS_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_qos_map_get.unit = unit;
	async->args.multicast_egress_subscriber_qos_map_get.group = group;
	async->args.multicast_egress_subscriber_qos_map_get.port = port;
	async->args.multicast_egress_subscriber_qos_map_get.subscriber_queue = subscriber_queue;
	async->args.multicast_egress_subscriber_qos_map_get.qos_map_id = qos_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_qos_map_set_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t subscriber_queue,
	int qos_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_QOS_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_qos_map_set.unit = unit;
	async->args.multicast_egress_subscriber_qos_map_set.group = group;
	async->args.multicast_egress_subscriber_qos_map_set.port = port;
	async->args.multicast_egress_subscriber_qos_map_set.subscriber_queue = subscriber_queue;
	async->args.multicast_egress_subscriber_qos_map_set.qos_map_id = qos_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_egress_subscriber_set_async(
	int unit,
	bcm_multicast_t group,
	int port_count,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	bcm_gport_t * subscriber_queue_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SUBSCRIBER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_subscriber_set.unit = unit;
	async->args.multicast_egress_subscriber_set.group = group;
	async->args.multicast_egress_subscriber_set.port_count = port_count;
	async->args.multicast_egress_subscriber_set.port_array = port_array;
	async->args.multicast_egress_subscriber_set.encap_id_array = encap_id_array;
	async->args.multicast_egress_subscriber_set.subscriber_queue_array = subscriber_queue_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_extender_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t extender_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_EXTENDER_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_extender_encap_get.unit = unit;
	async->args.multicast_extender_encap_get.group = group;
	async->args.multicast_extender_encap_get.port = port;
	async->args.multicast_extender_encap_get.extender_port_id = extender_port_id;
	async->args.multicast_extender_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_fabric_distribution_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_fabric_distribution_t * ds_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_FABRIC_DISTRIBUTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_fabric_distribution_get.unit = unit;
	async->args.multicast_fabric_distribution_get.group = group;
	async->args.multicast_fabric_distribution_get.ds_id = ds_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_fabric_distribution_set_async(
	int unit,
	bcm_multicast_t group,
	bcm_fabric_distribution_t ds_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_FABRIC_DISTRIBUTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_fabric_distribution_set.unit = unit;
	async->args.multicast_fabric_distribution_set.group = group;
	async->args.multicast_fabric_distribution_set.ds_id = ds_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_get_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	int replication_max,
	bcm_multicast_replication_t * out_rep_array,
	int * rep_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_get.unit = unit;
	async->args.multicast_get.group = group;
	async->args.multicast_get.flags = flags;
	async->args.multicast_get.replication_max = replication_max;
	async->args.multicast_get.out_rep_array = out_rep_array;
	async->args.multicast_get.rep_count = rep_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_group_free_range_get_async(
	int unit,
	uint32 type_flag,
	bcm_multicast_t * group_min,
	bcm_multicast_t * group_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_GROUP_FREE_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_group_free_range_get.unit = unit;
	async->args.multicast_group_free_range_get.type_flag = type_flag;
	async->args.multicast_group_free_range_get.group_min = group_min;
	async->args.multicast_group_free_range_get.group_max = group_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_group_get_async(
	int unit,
	bcm_multicast_t group,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_group_get.unit = unit;
	async->args.multicast_group_get.group = group;
	async->args.multicast_group_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_group_is_free_async(
	int unit,
	bcm_multicast_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_GROUP_IS_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_group_is_free.unit = unit;
	async->args.multicast_group_is_free.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_group_traverse_async(
	int unit,
	bcm_multicast_group_traverse_cb_t trav_fn,
	uint32 flags,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_group_traverse.unit = unit;
	async->args.multicast_group_traverse.trav_fn = trav_fn;
	async->args.multicast_group_traverse.flags = flags;
	async->args.multicast_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_ingress_add_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_ingress_add.unit = unit;
	async->args.multicast_ingress_add.group = group;
	async->args.multicast_ingress_add.port = port;
	async->args.multicast_ingress_add.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_ingress_delete_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_ingress_delete.unit = unit;
	async->args.multicast_ingress_delete.group = group;
	async->args.multicast_ingress_delete.port = port;
	async->args.multicast_ingress_delete.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_ingress_delete_all_async(
	int unit,
	bcm_multicast_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_ingress_delete_all.unit = unit;
	async->args.multicast_ingress_delete_all.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_ingress_get_async(
	int unit,
	bcm_multicast_t group,
	int port_max,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_ingress_get.unit = unit;
	async->args.multicast_ingress_get.group = group;
	async->args.multicast_ingress_get.port_max = port_max;
	async->args.multicast_ingress_get.port_array = port_array;
	async->args.multicast_ingress_get.encap_id_array = encap_id_array;
	async->args.multicast_ingress_get.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_ingress_set_async(
	int unit,
	bcm_multicast_t group,
	int port_count,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_ingress_set.unit = unit;
	async->args.multicast_ingress_set.group = group;
	async->args.multicast_ingress_set.port_count = port_count;
	async->args.multicast_ingress_set.port_array = port_array;
	async->args.multicast_ingress_set.encap_id_array = encap_id_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_l2_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_vlan_t vlan,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_L2_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_l2_encap_get.unit = unit;
	async->args.multicast_l2_encap_get.group = group;
	async->args.multicast_l2_encap_get.port = port;
	async->args.multicast_l2_encap_get.vlan = vlan;
	async->args.multicast_l2_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_l2gre_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t l2gre_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_L2GRE_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_l2gre_encap_get.unit = unit;
	async->args.multicast_l2gre_encap_get.group = group;
	async->args.multicast_l2gre_encap_get.port = port;
	async->args.multicast_l2gre_encap_get.l2gre_port_id = l2gre_port_id;
	async->args.multicast_l2gre_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_l3_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t intf,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_L3_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_l3_encap_get.unit = unit;
	async->args.multicast_l3_encap_get.group = group;
	async->args.multicast_l3_encap_get.port = port;
	async->args.multicast_l3_encap_get.intf = intf;
	async->args.multicast_l3_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_mac_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t mac_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_MAC_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_mac_encap_get.unit = unit;
	async->args.multicast_mac_encap_get.group = group;
	async->args.multicast_mac_encap_get.port = port;
	async->args.multicast_mac_encap_get.mac_port_id = mac_port_id;
	async->args.multicast_mac_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_mim_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t mim_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_MIM_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_mim_encap_get.unit = unit;
	async->args.multicast_mim_encap_get.group = group;
	async->args.multicast_mim_encap_get.port = port;
	async->args.multicast_mim_encap_get.mim_port_id = mim_port_id;
	async->args.multicast_mim_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_multi_alloc_async(
	int unit,
	bcm_multicast_multi_info_t mc_multi_info,
	bcm_multicast_t * base_mc_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_MULTI_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_multi_alloc.unit = unit;
	async->args.multicast_multi_alloc.mc_multi_info = mc_multi_info;
	async->args.multicast_multi_alloc.base_mc_group = base_mc_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_multi_free_async(
	int unit,
	bcm_multicast_t base_mc_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_MULTI_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_multi_free.unit = unit;
	async->args.multicast_multi_free.base_mc_group = base_mc_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_niv_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t niv_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_NIV_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_niv_encap_get.unit = unit;
	async->args.multicast_niv_encap_get.group = group;
	async->args.multicast_niv_encap_get.port = port;
	async->args.multicast_niv_encap_get.niv_port_id = niv_port_id;
	async->args.multicast_niv_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_repl_get_async(
	int unit,
	int index,
	bcm_port_t port,
	bcm_vlan_vector_t vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_REPL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_repl_get.unit = unit;
	async->args.multicast_repl_get.index = index;
	async->args.multicast_repl_get.port = port;
	async->args.multicast_repl_get.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_repl_set_async(
	int unit,
	int mc_index,
	bcm_port_t port,
	bcm_vlan_vector_t vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_REPL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_repl_set.unit = unit;
	async->args.multicast_repl_set.mc_index = mc_index;
	async->args.multicast_repl_set.port = port;
	async->args.multicast_repl_set.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_set_async(
	int unit,
	bcm_multicast_t group,
	uint32 flags,
	int nof_replications,
	bcm_multicast_replication_t * rep_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_set.unit = unit;
	async->args.multicast_set.group = group;
	async->args.multicast_set.flags = flags;
	async->args.multicast_set.nof_replications = nof_replications;
	async->args.multicast_set.rep_array = rep_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_subport_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t subport,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_SUBPORT_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_subport_encap_get.unit = unit;
	async->args.multicast_subport_encap_get.group = group;
	async->args.multicast_subport_encap_get.port = port;
	async->args.multicast_subport_encap_get.subport = subport;
	async->args.multicast_subport_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_trill_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t intf,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_TRILL_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_trill_encap_get.unit = unit;
	async->args.multicast_trill_encap_get.group = group;
	async->args.multicast_trill_encap_get.port = port;
	async->args.multicast_trill_encap_get.intf = intf;
	async->args.multicast_trill_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_vlan_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t vlan_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_VLAN_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_vlan_encap_get.unit = unit;
	async->args.multicast_vlan_encap_get.group = group;
	async->args.multicast_vlan_encap_get.port = port;
	async->args.multicast_vlan_encap_get.vlan_port_id = vlan_port_id;
	async->args.multicast_vlan_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_vpls_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t mpls_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_VPLS_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_vpls_encap_get.unit = unit;
	async->args.multicast_vpls_encap_get.group = group;
	async->args.multicast_vpls_encap_get.port = port;
	async->args.multicast_vpls_encap_get.mpls_port_id = mpls_port_id;
	async->args.multicast_vpls_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_vxlan_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t vxlan_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_VXLAN_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_vxlan_encap_get.unit = unit;
	async->args.multicast_vxlan_encap_get.group = group;
	async->args.multicast_vxlan_encap_get.port = port;
	async->args.multicast_vxlan_encap_get.vxlan_port_id = vxlan_port_id;
	async->args.multicast_vxlan_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_multicast_wlan_encap_get_async(
	int unit,
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t wlan_port_id,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_MULTICAST_WLAN_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_wlan_encap_get.unit = unit;
	async->args.multicast_wlan_encap_get.group = group;
	async->args.multicast_wlan_encap_get.port = port;
	async->args.multicast_wlan_encap_get.wlan_port_id = wlan_port_id;
	async->args.multicast_wlan_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_niv_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_egress_add_async(
	int unit,
	bcm_gport_t niv_port,
	bcm_niv_egress_t * niv_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_EGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_egress_add.unit = unit;
	async->args.niv_egress_add.niv_port = niv_port;
	async->args.niv_egress_add.niv_egress = niv_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_egress_delete_async(
	int unit,
	bcm_gport_t niv_port,
	bcm_niv_egress_t * niv_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_EGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_egress_delete.unit = unit;
	async->args.niv_egress_delete.niv_port = niv_port;
	async->args.niv_egress_delete.niv_egress = niv_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_egress_delete_all_async(
	int unit,
	bcm_gport_t niv_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_EGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_egress_delete_all.unit = unit;
	async->args.niv_egress_delete_all.niv_port = niv_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_egress_get_async(
	int unit,
	bcm_gport_t niv_port,
	int array_size,
	bcm_niv_egress_t * niv_egress_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_egress_get.unit = unit;
	async->args.niv_egress_get.niv_port = niv_port;
	async->args.niv_egress_get.array_size = array_size;
	async->args.niv_egress_get.niv_egress_array = niv_egress_array;
	async->args.niv_egress_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_egress_set_async(
	int unit,
	bcm_gport_t niv_port,
	int array_size,
	bcm_niv_egress_t * niv_egress_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_egress_set.unit = unit;
	async->args.niv_egress_set.niv_port = niv_port;
	async->args.niv_egress_set.array_size = array_size;
	async->args.niv_egress_set.niv_egress_array = niv_egress_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_forward_add_async(
	int unit,
	bcm_niv_forward_t * iv_fwd_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_FORWARD_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_add.unit = unit;
	async->args.niv_forward_add.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_forward_delete_async(
	int unit,
	bcm_niv_forward_t * iv_fwd_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_FORWARD_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_delete.unit = unit;
	async->args.niv_forward_delete.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_forward_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_FORWARD_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_forward_get_async(
	int unit,
	bcm_niv_forward_t * iv_fwd_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_FORWARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_get.unit = unit;
	async->args.niv_forward_get.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_forward_traverse_async(
	int unit,
	bcm_niv_forward_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_FORWARD_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_traverse.unit = unit;
	async->args.niv_forward_traverse.cb = cb;
	async->args.niv_forward_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_port_add_async(
	int unit,
	bcm_niv_port_t * niv_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_add.unit = unit;
	async->args.niv_port_add.niv_port = niv_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_port_delete_async(
	int unit,
	bcm_gport_t niv_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_delete.unit = unit;
	async->args.niv_port_delete.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_port_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_port_get_async(
	int unit,
	bcm_niv_port_t * niv_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_get.unit = unit;
	async->args.niv_port_get.niv_port = niv_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_niv_port_traverse_async(
	int unit,
	bcm_niv_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_NIV_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_traverse.unit = unit;
	async->args.niv_port_traverse.cb = cb;
	async->args.niv_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_oam_ais_add_async(
	int unit,
	bcm_oam_ais_t * ais_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_AIS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_ais_add.unit = unit;
	async->args.oam_ais_add.ais_ptr = ais_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_ais_delete_async(
	int unit,
	bcm_oam_ais_t * ais_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_AIS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_ais_delete.unit = unit;
	async->args.oam_ais_delete.ais_ptr = ais_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_ais_get_async(
	int unit,
	bcm_oam_ais_t * ais_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_AIS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_ais_get.unit = unit;
	async->args.oam_ais_get.ais_ptr = ais_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_control_get_async(
	int unit,
	bcm_oam_control_type_t type,
	uint64 * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_control_get.unit = unit;
	async->args.oam_control_get.type = type;
	async->args.oam_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_control_set_async(
	int unit,
	bcm_oam_control_type_t type,
	uint64 arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_control_set.unit = unit;
	async->args.oam_control_set.type = type;
	async->args.oam_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_csf_add_async(
	int unit,
	bcm_oam_csf_t * csf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_CSF_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_csf_add.unit = unit;
	async->args.oam_csf_add.csf_ptr = csf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_csf_delete_async(
	int unit,
	bcm_oam_csf_t * csf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_CSF_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_csf_delete.unit = unit;
	async->args.oam_csf_delete.csf_ptr = csf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_csf_get_async(
	int unit,
	bcm_oam_csf_t * csf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_CSF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_csf_get.unit = unit;
	async->args.oam_csf_get.csf_ptr = csf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_delay_add_async(
	int unit,
	bcm_oam_delay_t * delay_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_DELAY_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_delay_add.unit = unit;
	async->args.oam_delay_add.delay_ptr = delay_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_delay_delete_async(
	int unit,
	bcm_oam_delay_t * delay_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_DELAY_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_delay_delete.unit = unit;
	async->args.oam_delay_delete.delay_ptr = delay_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_delay_get_async(
	int unit,
	bcm_oam_delay_t * delay_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_DELAY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_delay_get.unit = unit;
	async->args.oam_delay_get.delay_ptr = delay_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_action_set_async(
	int unit,
	bcm_oam_endpoint_t id,
	bcm_oam_endpoint_action_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_ACTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_action_set.unit = unit;
	async->args.oam_endpoint_action_set.id = id;
	async->args.oam_endpoint_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_create_async(
	int unit,
	bcm_oam_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_create.unit = unit;
	async->args.oam_endpoint_create.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_destroy_async(
	int unit,
	bcm_oam_endpoint_t endpoint,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_destroy.unit = unit;
	async->args.oam_endpoint_destroy.endpoint = endpoint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_destroy_all_async(
	int unit,
	bcm_oam_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_destroy_all.unit = unit;
	async->args.oam_endpoint_destroy_all.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_egress_intf_egress_attach_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	bcm_if_t egress_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_EGRESS_INTF_EGRESS_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_egress_intf_egress_attach.unit = unit;
	async->args.oam_endpoint_egress_intf_egress_attach.endpoint_id = endpoint_id;
	async->args.oam_endpoint_egress_intf_egress_attach.egress_intf = egress_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_egress_intf_egress_attach_get_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	int max_count,
	bcm_if_t * egress_intf,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_EGRESS_INTF_EGRESS_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_egress_intf_egress_attach_get.unit = unit;
	async->args.oam_endpoint_egress_intf_egress_attach_get.endpoint_id = endpoint_id;
	async->args.oam_endpoint_egress_intf_egress_attach_get.max_count = max_count;
	async->args.oam_endpoint_egress_intf_egress_attach_get.egress_intf = egress_intf;
	async->args.oam_endpoint_egress_intf_egress_attach_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_egress_intf_egress_detach_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	bcm_if_t egress_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_EGRESS_INTF_EGRESS_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_egress_intf_egress_detach.unit = unit;
	async->args.oam_endpoint_egress_intf_egress_detach.endpoint_id = endpoint_id;
	async->args.oam_endpoint_egress_intf_egress_detach.egress_intf = egress_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_faults_multi_get_async(
	int unit,
	uint32 flags,
	bcm_oam_protocol_type_t endpoint_protocol,
	uint32 max_endpoints,
	bcm_oam_endpoint_fault_t * faults,
	uint32 * endpoint_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_FAULTS_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_faults_multi_get.unit = unit;
	async->args.oam_endpoint_faults_multi_get.flags = flags;
	async->args.oam_endpoint_faults_multi_get.endpoint_protocol = endpoint_protocol;
	async->args.oam_endpoint_faults_multi_get.max_endpoints = max_endpoints;
	async->args.oam_endpoint_faults_multi_get.faults = faults;
	async->args.oam_endpoint_faults_multi_get.endpoint_count = endpoint_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_get_async(
	int unit,
	bcm_oam_endpoint_t endpoint,
	bcm_oam_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_get.unit = unit;
	async->args.oam_endpoint_get.endpoint = endpoint;
	async->args.oam_endpoint_get.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_gport_egress_attach_async(
	int unit,
	bcm_oam_endpoint_t endpoint,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_GPORT_EGRESS_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_gport_egress_attach.unit = unit;
	async->args.oam_endpoint_gport_egress_attach.endpoint = endpoint;
	async->args.oam_endpoint_gport_egress_attach.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_gport_egress_attach_get_async(
	int unit,
	bcm_oam_endpoint_t endpoint,
	int max_count,
	bcm_gport_t * gport,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_GPORT_EGRESS_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_gport_egress_attach_get.unit = unit;
	async->args.oam_endpoint_gport_egress_attach_get.endpoint = endpoint;
	async->args.oam_endpoint_gport_egress_attach_get.max_count = max_count;
	async->args.oam_endpoint_gport_egress_attach_get.gport = gport;
	async->args.oam_endpoint_gport_egress_attach_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_gport_egress_detach_async(
	int unit,
	bcm_oam_endpoint_t endpoint,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_GPORT_EGRESS_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_gport_egress_detach.unit = unit;
	async->args.oam_endpoint_gport_egress_detach.endpoint = endpoint;
	async->args.oam_endpoint_gport_egress_detach.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_endpoint_traverse_async(
	int unit,
	bcm_oam_group_t group,
	bcm_oam_endpoint_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_ENDPOINT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_traverse.unit = unit;
	async->args.oam_endpoint_traverse.group = group;
	async->args.oam_endpoint_traverse.cb = cb;
	async->args.oam_endpoint_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_event_register_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_event_register.unit = unit;
	async->args.oam_event_register.event_types = event_types;
	async->args.oam_event_register.cb = cb;
	async->args.oam_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_event_unregister_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_event_unregister.unit = unit;
	async->args.oam_event_unregister.event_types = event_types;
	async->args.oam_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_group_create_async(
	int unit,
	bcm_oam_group_info_t * group_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_create.unit = unit;
	async->args.oam_group_create.group_info = group_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_group_destroy_async(
	int unit,
	bcm_oam_group_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_destroy.unit = unit;
	async->args.oam_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_group_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_GROUP_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_group_get_async(
	int unit,
	bcm_oam_group_t group,
	bcm_oam_group_info_t * group_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_get.unit = unit;
	async->args.oam_group_get.group = group;
	async->args.oam_group_get.group_info = group_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_group_traverse_async(
	int unit,
	bcm_oam_group_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_traverse.unit = unit;
	async->args.oam_group_traverse.cb = cb;
	async->args.oam_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_lookup_enable_get_async(
	int unit,
	bcm_oam_lookup_type_t type,
	bcm_oam_conditions_t * condition,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOKUP_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_lookup_enable_get.unit = unit;
	async->args.oam_lookup_enable_get.type = type;
	async->args.oam_lookup_enable_get.condition = condition;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_lookup_enable_multi_set_async(
	int unit,
	bcm_oam_lookup_types_t types,
	bcm_oam_conditions_t conditions,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOKUP_ENABLE_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_lookup_enable_multi_set.unit = unit;
	async->args.oam_lookup_enable_multi_set.types = types;
	async->args.oam_lookup_enable_multi_set.conditions = conditions;
	async->args.oam_lookup_enable_multi_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_lookup_enable_set_async(
	int unit,
	bcm_oam_lookup_type_t type,
	bcm_oam_condition_t condition,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOKUP_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_lookup_enable_set.unit = unit;
	async->args.oam_lookup_enable_set.type = type;
	async->args.oam_lookup_enable_set.condition = condition;
	async->args.oam_lookup_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loopback_add_async(
	int unit,
	bcm_oam_loopback_t * loopback_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOPBACK_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loopback_add.unit = unit;
	async->args.oam_loopback_add.loopback_ptr = loopback_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loopback_delete_async(
	int unit,
	bcm_oam_loopback_t * loopback_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOPBACK_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loopback_delete.unit = unit;
	async->args.oam_loopback_delete.loopback_ptr = loopback_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loopback_get_async(
	int unit,
	bcm_oam_loopback_t * loopback_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOOPBACK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loopback_get.unit = unit;
	async->args.oam_loopback_get.loopback_ptr = loopback_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loss_add_async(
	int unit,
	bcm_oam_loss_t * loss_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOSS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loss_add.unit = unit;
	async->args.oam_loss_add.loss_ptr = loss_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loss_delete_async(
	int unit,
	bcm_oam_loss_t * loss_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOSS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loss_delete.unit = unit;
	async->args.oam_loss_delete.loss_ptr = loss_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_loss_get_async(
	int unit,
	bcm_oam_loss_t * loss_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_LOSS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_loss_get.unit = unit;
	async->args.oam_loss_get.loss_ptr = loss_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_mpls_tp_channel_type_rx_get_async(
	int unit,
	bcm_oam_mpls_tp_channel_type_t channel_type,
	int num_values,
	int * list_of_values,
	int * value_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_MPLS_TP_CHANNEL_TYPE_RX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_mpls_tp_channel_type_rx_get.unit = unit;
	async->args.oam_mpls_tp_channel_type_rx_get.channel_type = channel_type;
	async->args.oam_mpls_tp_channel_type_rx_get.num_values = num_values;
	async->args.oam_mpls_tp_channel_type_rx_get.list_of_values = list_of_values;
	async->args.oam_mpls_tp_channel_type_rx_get.value_count = value_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_mpls_tp_channel_type_rx_set_async(
	int unit,
	bcm_oam_mpls_tp_channel_type_t channel_type,
	int num_values,
	int * list_of_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_MPLS_TP_CHANNEL_TYPE_RX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_mpls_tp_channel_type_rx_set.unit = unit;
	async->args.oam_mpls_tp_channel_type_rx_set.channel_type = channel_type;
	async->args.oam_mpls_tp_channel_type_rx_set.num_values = num_values;
	async->args.oam_mpls_tp_channel_type_rx_set.list_of_values = list_of_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_mpls_tp_channel_type_tx_get_async(
	int unit,
	bcm_oam_mpls_tp_channel_type_t channel_type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_MPLS_TP_CHANNEL_TYPE_TX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_mpls_tp_channel_type_tx_get.unit = unit;
	async->args.oam_mpls_tp_channel_type_tx_get.channel_type = channel_type;
	async->args.oam_mpls_tp_channel_type_tx_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_mpls_tp_channel_type_tx_set_async(
	int unit,
	bcm_oam_mpls_tp_channel_type_t channel_type,
	int value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_MPLS_TP_CHANNEL_TYPE_TX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_mpls_tp_channel_type_tx_set.unit = unit;
	async->args.oam_mpls_tp_channel_type_tx_set.channel_type = channel_type;
	async->args.oam_mpls_tp_channel_type_tx_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcode_group_get_async(
	int unit,
	bcm_oam_protocol_type_t protocol,
	bcm_oam_opcode_t opcode,
	uint8 * opcode_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODE_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcode_group_get.unit = unit;
	async->args.oam_opcode_group_get.protocol = protocol;
	async->args.oam_opcode_group_get.opcode = opcode;
	async->args.oam_opcode_group_get.opcode_group = opcode_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcode_group_set_async(
	int unit,
	bcm_oam_protocol_type_t protocol,
	bcm_oam_opcodes_t opcodes,
	uint8 opcode_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODE_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcode_group_set.unit = unit;
	async->args.oam_opcode_group_set.protocol = protocol;
	async->args.oam_opcode_group_set.opcodes = opcodes;
	async->args.oam_opcode_group_set.opcode_group = opcode_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcode_map_get_async(
	int unit,
	int opcode,
	int * profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODE_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcode_map_get.unit = unit;
	async->args.oam_opcode_map_get.opcode = opcode;
	async->args.oam_opcode_map_get.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcode_map_set_async(
	int unit,
	int opcode,
	int profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODE_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcode_map_set.unit = unit;
	async->args.oam_opcode_map_set.opcode = opcode;
	async->args.oam_opcode_map_set.profile = profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcodes_count_profile_create_async(
	int unit,
	uint8 * lm_count_profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODES_COUNT_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcodes_count_profile_create.unit = unit;
	async->args.oam_opcodes_count_profile_create.lm_count_profile = lm_count_profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcodes_count_profile_delete_async(
	int unit,
	uint8 lm_count_profile,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODES_COUNT_PROFILE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcodes_count_profile_delete.unit = unit;
	async->args.oam_opcodes_count_profile_delete.lm_count_profile = lm_count_profile;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcodes_count_profile_get_async(
	int unit,
	uint8 lm_count_profile,
	uint8 count_enable,
	bcm_oam_opcodes_t * opcodes_bitmap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODES_COUNT_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcodes_count_profile_get.unit = unit;
	async->args.oam_opcodes_count_profile_get.lm_count_profile = lm_count_profile;
	async->args.oam_opcodes_count_profile_get.count_enable = count_enable;
	async->args.oam_opcodes_count_profile_get.opcodes_bitmap = opcodes_bitmap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_opcodes_count_profile_set_async(
	int unit,
	uint8 lm_count_profile,
	uint8 count_enable,
	bcm_oam_opcodes_t * opcodes_bitmap,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_OPCODES_COUNT_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_opcodes_count_profile_set.unit = unit;
	async->args.oam_opcodes_count_profile_set.lm_count_profile = lm_count_profile;
	async->args.oam_opcodes_count_profile_set.count_enable = count_enable;
	async->args.oam_opcodes_count_profile_set.opcodes_bitmap = opcodes_bitmap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_performance_event_register_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_performance_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PERFORMANCE_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_performance_event_register.unit = unit;
	async->args.oam_performance_event_register.event_types = event_types;
	async->args.oam_performance_event_register.cb = cb;
	async->args.oam_performance_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_performance_event_unregister_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_performance_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PERFORMANCE_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_performance_event_unregister.unit = unit;
	async->args.oam_performance_event_unregister.event_types = event_types;
	async->args.oam_performance_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_event_register_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_pm_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_event_register.unit = unit;
	async->args.oam_pm_event_register.event_types = event_types;
	async->args.oam_pm_event_register.cb = cb;
	async->args.oam_pm_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_event_unregister_async(
	int unit,
	bcm_oam_event_types_t event_types,
	bcm_oam_pm_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_event_unregister.unit = unit;
	async->args.oam_pm_event_unregister.event_types = event_types;
	async->args.oam_pm_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_attach_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	int profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_attach.unit = unit;
	async->args.oam_pm_profile_attach.endpoint_id = endpoint_id;
	async->args.oam_pm_profile_attach.profile_id = profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_attach_get_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	int * profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_attach_get.unit = unit;
	async->args.oam_pm_profile_attach_get.endpoint_id = endpoint_id;
	async->args.oam_pm_profile_attach_get.profile_id = profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_create_async(
	int unit,
	bcm_oam_pm_profile_info_t * profile_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_create.unit = unit;
	async->args.oam_pm_profile_create.profile_info = profile_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_delete_async(
	int unit,
	bcm_oam_pm_profile_t profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_delete.unit = unit;
	async->args.oam_pm_profile_delete.profile_id = profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_detach_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	int profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_detach.unit = unit;
	async->args.oam_pm_profile_detach.endpoint_id = endpoint_id;
	async->args.oam_pm_profile_detach.profile_id = profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_get_async(
	int unit,
	bcm_oam_pm_profile_info_t * profile_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_get.unit = unit;
	async->args.oam_pm_profile_get.profile_info = profile_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_profile_traverse_async(
	int unit,
	bcm_oam_pm_profile_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_PROFILE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_profile_traverse.unit = unit;
	async->args.oam_pm_profile_traverse.cb = cb;
	async->args.oam_pm_profile_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_raw_data_read_done_async(
	int unit,
	bcm_oam_event_types_t event_types,
	uint32 read_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_RAW_DATA_READ_DONE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_raw_data_read_done.unit = unit;
	async->args.oam_pm_raw_data_read_done.event_types = event_types;
	async->args.oam_pm_raw_data_read_done.read_index = read_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pm_stats_get_async(
	int unit,
	bcm_oam_endpoint_t endpoint_id,
	bcm_oam_pm_stats_t * stats_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PM_STATS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pm_stats_get.unit = unit;
	async->args.oam_pm_stats_get.endpoint_id = endpoint_id;
	async->args.oam_pm_stats_get.stats_ptr = stats_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_protection_packet_header_get_async(
	int unit,
	bcm_pkt_blk_t * packet_header,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PROTECTION_PACKET_HEADER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_protection_packet_header_get.unit = unit;
	async->args.oam_protection_packet_header_get.packet_header = packet_header;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_protection_packet_header_set_async(
	int unit,
	bcm_pkt_blk_t * packet_header,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PROTECTION_PACKET_HEADER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_protection_packet_header_set.unit = unit;
	async->args.oam_protection_packet_header_set.packet_header = packet_header;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_psc_add_async(
	int unit,
	bcm_oam_psc_t * psc_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PSC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_psc_add.unit = unit;
	async->args.oam_psc_add.psc_ptr = psc_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_psc_delete_async(
	int unit,
	bcm_oam_psc_t * psc_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PSC_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_psc_delete.unit = unit;
	async->args.oam_psc_delete.psc_ptr = psc_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_psc_get_async(
	int unit,
	bcm_oam_psc_t * psc_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PSC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_psc_get.unit = unit;
	async->args.oam_psc_get.psc_ptr = psc_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pw_status_add_async(
	int unit,
	bcm_oam_pw_status_t * pw_status_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PW_STATUS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pw_status_add.unit = unit;
	async->args.oam_pw_status_add.pw_status_ptr = pw_status_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pw_status_delete_async(
	int unit,
	bcm_oam_pw_status_t * pw_status_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PW_STATUS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pw_status_delete.unit = unit;
	async->args.oam_pw_status_delete.pw_status_ptr = pw_status_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_pw_status_get_async(
	int unit,
	bcm_oam_pw_status_t * pw_status_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_PW_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_pw_status_get.unit = unit;
	async->args.oam_pw_status_get.pw_status_ptr = pw_status_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_sd_sf_detection_add_async(
	int unit,
	bcm_oam_sd_sf_detection_t * sd_sf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_SD_SF_DETECTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_sd_sf_detection_add.unit = unit;
	async->args.oam_sd_sf_detection_add.sd_sf_ptr = sd_sf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_sd_sf_detection_delete_async(
	int unit,
	bcm_oam_sd_sf_detection_t * sd_sf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_SD_SF_DETECTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_sd_sf_detection_delete.unit = unit;
	async->args.oam_sd_sf_detection_delete.sd_sf_ptr = sd_sf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_sd_sf_detection_get_async(
	int unit,
	bcm_oam_sd_sf_detection_t * sd_sf_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_SD_SF_DETECTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_sd_sf_detection_get.unit = unit;
	async->args.oam_sd_sf_detection_get.sd_sf_ptr = sd_sf_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_trunk_ports_add_async(
	int unit,
	bcm_gport_t trunk_gport,
	int max_ports,
	bcm_gport_t * port_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TRUNK_PORTS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_trunk_ports_add.unit = unit;
	async->args.oam_trunk_ports_add.trunk_gport = trunk_gport;
	async->args.oam_trunk_ports_add.max_ports = max_ports;
	async->args.oam_trunk_ports_add.port_arr = port_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_trunk_ports_delete_async(
	int unit,
	bcm_gport_t trunk_gport,
	int max_ports,
	bcm_gport_t * port_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TRUNK_PORTS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_trunk_ports_delete.unit = unit;
	async->args.oam_trunk_ports_delete.trunk_gport = trunk_gport;
	async->args.oam_trunk_ports_delete.max_ports = max_ports;
	async->args.oam_trunk_ports_delete.port_arr = port_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_trunk_ports_get_async(
	int unit,
	bcm_gport_t trunk_gport,
	int max_ports,
	bcm_gport_t * port_arr,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TRUNK_PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_trunk_ports_get.unit = unit;
	async->args.oam_trunk_ports_get.trunk_gport = trunk_gport;
	async->args.oam_trunk_ports_get.max_ports = max_ports;
	async->args.oam_trunk_ports_get.port_arr = port_arr;
	async->args.oam_trunk_ports_get.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_rx_add_async(
	int unit,
	bcm_oam_tst_rx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_RX_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_rx_add.unit = unit;
	async->args.oam_tst_rx_add.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_rx_delete_async(
	int unit,
	bcm_oam_tst_rx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_RX_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_rx_delete.unit = unit;
	async->args.oam_tst_rx_delete.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_rx_get_async(
	int unit,
	bcm_oam_tst_rx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_RX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_rx_get.unit = unit;
	async->args.oam_tst_rx_get.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_tx_add_async(
	int unit,
	bcm_oam_tst_tx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_TX_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_tx_add.unit = unit;
	async->args.oam_tst_tx_add.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_tx_delete_async(
	int unit,
	bcm_oam_tst_tx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_TX_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_tx_delete.unit = unit;
	async->args.oam_tst_tx_delete.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_tst_tx_get_async(
	int unit,
	bcm_oam_tst_tx_t * tst_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_TST_TX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_tst_tx_get.unit = unit;
	async->args.oam_tst_tx_get.tst_ptr = tst_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_y_1711_alarm_add_async(
	int unit,
	bcm_oam_y_1711_alarm_t * alarm_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_Y_1711_ALARM_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_y_1711_alarm_add.unit = unit;
	async->args.oam_y_1711_alarm_add.alarm_ptr = alarm_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_y_1711_alarm_delete_async(
	int unit,
	bcm_oam_y_1711_alarm_t * alarm_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_Y_1711_ALARM_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_y_1711_alarm_delete.unit = unit;
	async->args.oam_y_1711_alarm_delete.alarm_ptr = alarm_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oam_y_1711_alarm_get_async(
	int unit,
	bcm_oam_y_1711_alarm_t * alarm_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OAM_Y_1711_ALARM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_y_1711_alarm_get.unit = unit;
	async->args.oam_y_1711_alarm_get.alarm_ptr = alarm_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_config_get_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_oob_fc_rx_config_t * config,
	int array_max,
	bcm_gport_t * gport_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_config_get.unit = unit;
	async->args.oob_fc_rx_config_get.intf_id = intf_id;
	async->args.oob_fc_rx_config_get.config = config;
	async->args.oob_fc_rx_config_get.array_max = array_max;
	async->args.oob_fc_rx_config_get.gport_array = gport_array;
	async->args.oob_fc_rx_config_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_config_set_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_oob_fc_rx_config_t * config,
	int array_count,
	bcm_gport_t * gport_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_config_set.unit = unit;
	async->args.oob_fc_rx_config_set.intf_id = intf_id;
	async->args.oob_fc_rx_config_set.config = config;
	async->args.oob_fc_rx_config_set.array_count = array_count;
	async->args.oob_fc_rx_config_set.gport_array = gport_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_port_offset_get_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_gport_t gport,
	uint32 * offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_PORT_OFFSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_port_offset_get.unit = unit;
	async->args.oob_fc_rx_port_offset_get.intf_id = intf_id;
	async->args.oob_fc_rx_port_offset_get.gport = gport;
	async->args.oob_fc_rx_port_offset_get.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_port_tc_mapping_get_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_gport_t gport,
	uint32 tc,
	uint32 * pri_bmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_PORT_TC_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_port_tc_mapping_get.unit = unit;
	async->args.oob_fc_rx_port_tc_mapping_get.intf_id = intf_id;
	async->args.oob_fc_rx_port_tc_mapping_get.gport = gport;
	async->args.oob_fc_rx_port_tc_mapping_get.tc = tc;
	async->args.oob_fc_rx_port_tc_mapping_get.pri_bmp = pri_bmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_port_tc_mapping_multi_get_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_gport_t gport,
	int array_max,
	uint32 * tc,
	uint32 * pri_bmp,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_PORT_TC_MAPPING_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.unit = unit;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.intf_id = intf_id;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.gport = gport;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.array_max = array_max;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.tc = tc;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.pri_bmp = pri_bmp;
	async->args.oob_fc_rx_port_tc_mapping_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_port_tc_mapping_multi_set_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_gport_t gport,
	int array_count,
	uint32 * tc,
	uint32 * pri_bmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_PORT_TC_MAPPING_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.unit = unit;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.intf_id = intf_id;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.gport = gport;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.array_count = array_count;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.tc = tc;
	async->args.oob_fc_rx_port_tc_mapping_multi_set.pri_bmp = pri_bmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_rx_port_tc_mapping_set_async(
	int unit,
	bcm_oob_fc_rx_intf_id_t intf_id,
	bcm_gport_t gport,
	uint32 tc,
	uint32 pri_bmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_RX_PORT_TC_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_rx_port_tc_mapping_set.unit = unit;
	async->args.oob_fc_rx_port_tc_mapping_set.intf_id = intf_id;
	async->args.oob_fc_rx_port_tc_mapping_set.gport = gport;
	async->args.oob_fc_rx_port_tc_mapping_set.tc = tc;
	async->args.oob_fc_rx_port_tc_mapping_set.pri_bmp = pri_bmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_tx_config_get_async(
	int unit,
	bcm_oob_fc_tx_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_TX_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_tx_config_get.unit = unit;
	async->args.oob_fc_tx_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_tx_config_set_async(
	int unit,
	bcm_oob_fc_tx_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_TX_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_tx_config_set.unit = unit;
	async->args.oob_fc_tx_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_fc_tx_info_get_async(
	int unit,
	bcm_oob_fc_tx_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_FC_TX_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_fc_tx_info_get.unit = unit;
	async->args.oob_fc_tx_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_config_get_async(
	int unit,
	bcm_oob_stats_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_config_get.unit = unit;
	async->args.oob_stats_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_config_set_async(
	int unit,
	bcm_oob_stats_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_config_set.unit = unit;
	async->args.oob_stats_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_pool_mapping_get_async(
	int unit,
	int offset,
	uint8 * dir,
	bcm_service_pool_id_t * pool,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_POOL_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_pool_mapping_get.unit = unit;
	async->args.oob_stats_pool_mapping_get.offset = offset;
	async->args.oob_stats_pool_mapping_get.dir = dir;
	async->args.oob_stats_pool_mapping_get.pool = pool;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_pool_mapping_multi_get_async(
	int unit,
	int array_max,
	int * offset_array,
	uint8 * dir_array,
	bcm_service_pool_id_t * pool_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_POOL_MAPPING_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_pool_mapping_multi_get.unit = unit;
	async->args.oob_stats_pool_mapping_multi_get.array_max = array_max;
	async->args.oob_stats_pool_mapping_multi_get.offset_array = offset_array;
	async->args.oob_stats_pool_mapping_multi_get.dir_array = dir_array;
	async->args.oob_stats_pool_mapping_multi_get.pool_array = pool_array;
	async->args.oob_stats_pool_mapping_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_pool_mapping_multi_set_async(
	int unit,
	int array_count,
	int * offset_array,
	uint8 * dir_array,
	bcm_service_pool_id_t * pool_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_POOL_MAPPING_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_pool_mapping_multi_set.unit = unit;
	async->args.oob_stats_pool_mapping_multi_set.array_count = array_count;
	async->args.oob_stats_pool_mapping_multi_set.offset_array = offset_array;
	async->args.oob_stats_pool_mapping_multi_set.dir_array = dir_array;
	async->args.oob_stats_pool_mapping_multi_set.pool_array = pool_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_pool_mapping_set_async(
	int unit,
	int offset,
	uint8 dir,
	bcm_service_pool_id_t pool,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_POOL_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_pool_mapping_set.unit = unit;
	async->args.oob_stats_pool_mapping_set.offset = offset;
	async->args.oob_stats_pool_mapping_set.dir = dir;
	async->args.oob_stats_pool_mapping_set.pool = pool;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_queue_mapping_get_async(
	int unit,
	int offset,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_QUEUE_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_queue_mapping_get.unit = unit;
	async->args.oob_stats_queue_mapping_get.offset = offset;
	async->args.oob_stats_queue_mapping_get.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_queue_mapping_multi_get_async(
	int unit,
	int array_max,
	int * offset_array,
	bcm_gport_t * gport_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_QUEUE_MAPPING_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_queue_mapping_multi_get.unit = unit;
	async->args.oob_stats_queue_mapping_multi_get.array_max = array_max;
	async->args.oob_stats_queue_mapping_multi_get.offset_array = offset_array;
	async->args.oob_stats_queue_mapping_multi_get.gport_array = gport_array;
	async->args.oob_stats_queue_mapping_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_queue_mapping_multi_set_async(
	int unit,
	int array_count,
	int * offset_array,
	bcm_gport_t * gport_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_QUEUE_MAPPING_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_queue_mapping_multi_set.unit = unit;
	async->args.oob_stats_queue_mapping_multi_set.array_count = array_count;
	async->args.oob_stats_queue_mapping_multi_set.offset_array = offset_array;
	async->args.oob_stats_queue_mapping_multi_set.gport_array = gport_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_oob_stats_queue_mapping_set_async(
	int unit,
	int offset,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_OOB_STATS_QUEUE_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oob_stats_queue_mapping_set.unit = unit;
	async->args.oob_stats_queue_mapping_set.offset = offset;
	async->args.oob_stats_queue_mapping_set.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_alloc_async(
	int unit,
	int size,
	uint32 flags,
	bcm_pkt_t ** pkt_buf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_alloc.unit = unit;
	async->args.pkt_alloc.size = size;
	async->args.pkt_alloc.flags = flags;
	async->args.pkt_alloc.pkt_buf = (bcm_pkt_t * *)pkt_buf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_blk_alloc_async(
	int unit,
	int count,
	int size,
	uint32 flags,
	bcm_pkt_t *** packet_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_BLK_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_blk_alloc.unit = unit;
	async->args.pkt_blk_alloc.count = count;
	async->args.pkt_blk_alloc.size = size;
	async->args.pkt_blk_alloc.flags = flags;
	async->args.pkt_blk_alloc.packet_array = (bcm_pkt_t ** *)packet_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_blk_free_async(
	int unit,
	bcm_pkt_t ** pkt,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_BLK_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_blk_free.unit = unit;
	async->args.pkt_blk_free.pkt = (bcm_pkt_t * *)pkt;
	async->args.pkt_blk_free.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_byte_index_async(
	bcm_pkt_t * pkt,
	int n,
	int * len,
	int * blk_idx,
	uint8 ** location,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_BYTE_INDEX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_byte_index.pkt = pkt;
	async->args.pkt_byte_index.n = n;
	async->args.pkt_byte_index.len = len;
	async->args.pkt_byte_index.blk_idx = blk_idx;
	async->args.pkt_byte_index.location = (uint8 * *)location;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_clear_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_pkt_blk_t * blks,
	int blk_count,
	uint32 flags,
	bcm_pkt_t ** pkt_buf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_clear.unit = unit;
	async->args.pkt_clear.pkt = pkt;
	async->args.pkt_clear.blks = blks;
	async->args.pkt_clear.blk_count = blk_count;
	async->args.pkt_clear.flags = flags;
	async->args.pkt_clear.pkt_buf = (bcm_pkt_t * *)pkt_buf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_flags_init_async(
	int unit,
	bcm_pkt_t * pkt,
	uint32 init_flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_FLAGS_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_flags_init.unit = unit;
	async->args.pkt_flags_init.pkt = pkt;
	async->args.pkt_flags_init.init_flags = init_flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_flags_len_setup_async(
	int unit,
	bcm_pkt_t * pkt,
	int alloc_bytes,
	int payload_len,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_FLAGS_LEN_SETUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_flags_len_setup.unit = unit;
	async->args.pkt_flags_len_setup.pkt = pkt;
	async->args.pkt_flags_len_setup.alloc_bytes = alloc_bytes;
	async->args.pkt_flags_len_setup.payload_len = payload_len;
	async->args.pkt_flags_len_setup.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_free_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_free.unit = unit;
	async->args.pkt_free.pkt = pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_memcpy_async(
	bcm_pkt_t * pkt,
	int dest_byte,
	uint8 * src,
	int len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_MEMCPY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_memcpy.pkt = pkt;
	async->args.pkt_memcpy.dest_byte = dest_byte;
	async->args.pkt_memcpy.src = src;
	async->args.pkt_memcpy.len = len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_rx_alloc_async(
	int unit,
	int len,
	bcm_pkt_t ** pkt_buf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_RX_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_rx_alloc.unit = unit;
	async->args.pkt_rx_alloc.len = len;
	async->args.pkt_rx_alloc.pkt_buf = (bcm_pkt_t * *)pkt_buf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pkt_rx_free_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PKT_RX_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pkt_rx_free.unit = unit;
	async->args.pkt_rx_free.pkt = pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_add_async(
	int unit,
	uint32 action_id,
	bcm_policer_action_t action,
	uint32 param0,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_add.unit = unit;
	async->args.policer_action_add.action_id = action_id;
	async->args.policer_action_add.action = action;
	async->args.policer_action_add.param0 = param0;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_attach_async(
	int unit,
	bcm_policer_t policer_id,
	uint32 action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_attach.unit = unit;
	async->args.policer_action_attach.policer_id = policer_id;
	async->args.policer_action_attach.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_attach_get_async(
	int unit,
	bcm_policer_t policer_id,
	uint32 * action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_attach_get.unit = unit;
	async->args.policer_action_attach_get.policer_id = policer_id;
	async->args.policer_action_attach_get.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_create_async(
	int unit,
	uint32 * action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_create.unit = unit;
	async->args.policer_action_create.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_destroy_async(
	int unit,
	uint32 action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_destroy.unit = unit;
	async->args.policer_action_destroy.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_detach_async(
	int unit,
	bcm_policer_t policer_id,
	uint32 action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_detach.unit = unit;
	async->args.policer_action_detach.policer_id = policer_id;
	async->args.policer_action_detach.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_action_get_async(
	int unit,
	uint32 action_id,
	bcm_policer_action_t action,
	uint32 * param0,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_action_get.unit = unit;
	async->args.policer_action_get.action_id = action_id;
	async->args.policer_action_get.action = action;
	async->args.policer_action_get.param0 = param0;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_aggregate_group_create_async(
	int unit,
	bcm_policer_aggregate_group_info_t * info,
	bcm_policer_t * policer_id,
	int * npolicers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_AGGREGATE_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_aggregate_group_create.unit = unit;
	async->args.policer_aggregate_group_create.info = info;
	async->args.policer_aggregate_group_create.policer_id = policer_id;
	async->args.policer_aggregate_group_create.npolicers = npolicers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_color_decision_get_async(
	int unit,
	bcm_policer_color_decision_t * policer_color_decision,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_COLOR_DECISION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_color_decision_get.unit = unit;
	async->args.policer_color_decision_get.policer_color_decision = policer_color_decision;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_color_decision_set_async(
	int unit,
	bcm_policer_color_decision_t * policer_color_decision,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_COLOR_DECISION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_color_decision_set.unit = unit;
	async->args.policer_color_decision_set.policer_color_decision = policer_color_decision;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_color_resolution_get_async(
	int unit,
	bcm_policer_color_resolution_t * policer_color_resolution,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_COLOR_RESOLUTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_color_resolution_get.unit = unit;
	async->args.policer_color_resolution_get.policer_color_resolution = policer_color_resolution;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_color_resolution_set_async(
	int unit,
	bcm_policer_color_resolution_t * policer_color_resolution,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_COLOR_RESOLUTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_color_resolution_set.unit = unit;
	async->args.policer_color_resolution_set.policer_color_resolution = policer_color_resolution;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_create_async(
	int unit,
	bcm_policer_config_t * pol_cfg,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_create.unit = unit;
	async->args.policer_create.pol_cfg = pol_cfg;
	async->args.policer_create.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_custom_group_create_async(
	int unit,
	uint32 flags,
	uint32 mode_id,
	bcm_policer_t macro_flow_policer_id,
	bcm_policer_t * policer_id,
	uint32 * npolicers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_CUSTOM_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_custom_group_create.unit = unit;
	async->args.policer_custom_group_create.flags = flags;
	async->args.policer_custom_group_create.mode_id = mode_id;
	async->args.policer_custom_group_create.macro_flow_policer_id = macro_flow_policer_id;
	async->args.policer_custom_group_create.policer_id = policer_id;
	async->args.policer_custom_group_create.npolicers = npolicers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_destroy_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_destroy.unit = unit;
	async->args.policer_destroy.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_envelop_create_async(
	int unit,
	uint32 flag,
	bcm_policer_t macro_flow_policer_id,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ENVELOP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_envelop_create.unit = unit;
	async->args.policer_envelop_create.flag = flag;
	async->args.policer_envelop_create.macro_flow_policer_id = macro_flow_policer_id;
	async->args.policer_envelop_create.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_envelop_group_create_async(
	int unit,
	uint32 flag,
	bcm_policer_group_mode_t mode,
	bcm_policer_t macro_flow_policer_id,
	bcm_policer_t * policer_id,
	int * npolicers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_ENVELOP_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_envelop_group_create.unit = unit;
	async->args.policer_envelop_group_create.flag = flag;
	async->args.policer_envelop_group_create.mode = mode;
	async->args.policer_envelop_group_create.macro_flow_policer_id = macro_flow_policer_id;
	async->args.policer_envelop_group_create.policer_id = policer_id;
	async->args.policer_envelop_group_create.npolicers = npolicers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_get_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_policer_config_t * pol_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_get.unit = unit;
	async->args.policer_get.policer_id = policer_id;
	async->args.policer_get.pol_cfg = pol_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_global_meter_config_get_async(
	int unit,
	bcm_policer_global_meter_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GLOBAL_METER_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_global_meter_config_get.unit = unit;
	async->args.policer_global_meter_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_global_meter_config_set_async(
	int unit,
	bcm_policer_global_meter_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GLOBAL_METER_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_global_meter_config_set.unit = unit;
	async->args.policer_global_meter_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_create_async(
	int unit,
	bcm_policer_group_mode_t mode,
	bcm_policer_t * policer_id,
	int * npolicers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_create.unit = unit;
	async->args.policer_group_create.mode = mode;
	async->args.policer_group_create.policer_id = policer_id;
	async->args.policer_group_create.npolicers = npolicers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_create_with_map_async(
	int unit,
	bcm_policer_group_mode_t mode,
	bcm_policer_map_t * offset_map,
	bcm_policer_t * policer_id,
	int * num_policers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_CREATE_WITH_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_create_with_map.unit = unit;
	async->args.policer_group_create_with_map.mode = mode;
	async->args.policer_group_create_with_map.offset_map = offset_map;
	async->args.policer_group_create_with_map.policer_id = policer_id;
	async->args.policer_group_create_with_map.num_policers = num_policers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_get_async(
	int unit,
	bcm_policer_t base_policer_id,
	int member_max,
	bcm_policer_t * member_array,
	int * member_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_get.unit = unit;
	async->args.policer_group_get.base_policer_id = base_policer_id;
	async->args.policer_group_get.member_max = member_max;
	async->args.policer_group_get.member_array = member_array;
	async->args.policer_group_get.member_count = member_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_mode_id_create_async(
	int unit,
	uint32 flags,
	bcm_policer_group_mode_type_t type,
	uint32 total_policers,
	uint32 num_selectors,
	bcm_policer_group_mode_attr_selector_t * attr_selectors,
	uint32 * mode_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_MODE_ID_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_mode_id_create.unit = unit;
	async->args.policer_group_mode_id_create.flags = flags;
	async->args.policer_group_mode_id_create.type = type;
	async->args.policer_group_mode_id_create.total_policers = total_policers;
	async->args.policer_group_mode_id_create.num_selectors = num_selectors;
	async->args.policer_group_mode_id_create.attr_selectors = attr_selectors;
	async->args.policer_group_mode_id_create.mode_id = mode_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_mode_id_destroy_async(
	int unit,
	uint32 mode_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_MODE_ID_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_mode_id_destroy.unit = unit;
	async->args.policer_group_mode_id_destroy.mode_id = mode_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_group_mode_id_get_async(
	int unit,
	uint32 mode_id,
	uint32 num_selectors,
	uint32 * flags,
	bcm_policer_group_mode_type_t * type,
	uint32 * total_policers,
	bcm_policer_group_mode_attr_selector_t * attr_selectors,
	uint32 * actual_num_selectors,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_GROUP_MODE_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_group_mode_id_get.unit = unit;
	async->args.policer_group_mode_id_get.mode_id = mode_id;
	async->args.policer_group_mode_id_get.num_selectors = num_selectors;
	async->args.policer_group_mode_id_get.flags = flags;
	async->args.policer_group_mode_id_get.type = type;
	async->args.policer_group_mode_id_get.total_policers = total_policers;
	async->args.policer_group_mode_id_get.attr_selectors = attr_selectors;
	async->args.policer_group_mode_id_get.actual_num_selectors = actual_num_selectors;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_packet_counter_get32_async(
	int unit,
	bcm_policer_t policer_id,
	uint32 * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_PACKET_COUNTER_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_packet_counter_get32.unit = unit;
	async->args.policer_packet_counter_get32.policer_id = policer_id;
	async->args.policer_packet_counter_get32.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_packet_reset_counter_get32_async(
	int unit,
	bcm_policer_t policer_id,
	uint32 * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_PACKET_RESET_COUNTER_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_packet_reset_counter_get32.unit = unit;
	async->args.policer_packet_reset_counter_get32.policer_id = policer_id;
	async->args.policer_packet_reset_counter_get32.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_set_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_policer_config_t * pol_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_set.unit = unit;
	async->args.policer_set.policer_id = policer_id;
	async->args.policer_set.pol_cfg = pol_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_enable_get_async(
	int unit,
	bcm_policer_t policer_id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_enable_get.unit = unit;
	async->args.policer_stat_enable_get.policer_id = policer_id;
	async->args.policer_stat_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_enable_set_async(
	int unit,
	bcm_policer_t policer_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_enable_set.unit = unit;
	async->args.policer_stat_enable_set.policer_id = policer_id;
	async->args.policer_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_get_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_cos_t int_pri,
	bcm_policer_stat_t stat,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_get.unit = unit;
	async->args.policer_stat_get.policer_id = policer_id;
	async->args.policer_stat_get.int_pri = int_pri;
	async->args.policer_stat_get.stat = stat;
	async->args.policer_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_get32_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_cos_t int_pri,
	bcm_policer_stat_t stat,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_get32.unit = unit;
	async->args.policer_stat_get32.policer_id = policer_id;
	async->args.policer_stat_get32.int_pri = int_pri;
	async->args.policer_stat_get32.stat = stat;
	async->args.policer_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_set_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_cos_t int_pri,
	bcm_policer_stat_t stat,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_set.unit = unit;
	async->args.policer_stat_set.policer_id = policer_id;
	async->args.policer_stat_set.int_pri = int_pri;
	async->args.policer_stat_set.stat = stat;
	async->args.policer_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_stat_set32_async(
	int unit,
	bcm_policer_t policer_id,
	bcm_cos_t int_pri,
	bcm_policer_stat_t stat,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_stat_set32.unit = unit;
	async->args.policer_stat_set32.policer_id = policer_id;
	async->args.policer_stat_set32.int_pri = int_pri;
	async->args.policer_stat_set32.stat = stat;
	async->args.policer_stat_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_policer_traverse_async(
	int unit,
	bcm_policer_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_POLICER_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_traverse.unit = unit;
	async->args.policer_traverse.cb = cb;
	async->args.policer_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ability_advert_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_ability_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ABILITY_ADVERT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_advert_get.unit = unit;
	async->args.port_ability_advert_get.port = port;
	async->args.port_ability_advert_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ability_advert_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_ability_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ABILITY_ADVERT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_advert_set.unit = unit;
	async->args.port_ability_advert_set.port = port;
	async->args.port_ability_advert_set.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ability_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_abil_t * local_ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ABILITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_get.unit = unit;
	async->args.port_ability_get.port = port;
	async->args.port_ability_get.local_ability_mask = local_ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ability_local_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_ability_t * local_ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ABILITY_LOCAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_local_get.unit = unit;
	async->args.port_ability_local_get.port = port;
	async->args.port_ability_local_get.local_ability_mask = local_ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ability_remote_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_ability_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ABILITY_REMOTE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_remote_get.unit = unit;
	async->args.port_ability_remote_get.port = port;
	async->args.port_ability_remote_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_add_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_port_interface_info_t * interface_info,
	bcm_port_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_add.unit = unit;
	async->args.port_add.port = port;
	async->args.port_add.flags = flags;
	async->args.port_add.interface_info = interface_info;
	async->args.port_add.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_advert_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_abil_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ADVERT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_get.unit = unit;
	async->args.port_advert_get.port = port;
	async->args.port_advert_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_advert_remote_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_abil_t * ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ADVERT_REMOTE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_remote_get.unit = unit;
	async->args.port_advert_remote_get.port = port;
	async->args.port_advert_remote_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_advert_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_abil_t ability_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ADVERT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_set.unit = unit;
	async->args.port_advert_set.port = port;
	async->args.port_advert_set.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_autoneg_get_async(
	int unit,
	bcm_port_t port,
	int * autoneg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_AUTONEG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_autoneg_get.unit = unit;
	async->args.port_autoneg_get.port = port;
	async->args.port_autoneg_get.autoneg = autoneg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_autoneg_set_async(
	int unit,
	bcm_port_t port,
	int autoneg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_AUTONEG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_autoneg_set.unit = unit;
	async->args.port_autoneg_set.port = port;
	async->args.port_autoneg_set.autoneg = autoneg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_bpdu_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_BPDU_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_bpdu_enable_get.unit = unit;
	async->args.port_bpdu_enable_get.port = port;
	async->args.port_bpdu_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_bpdu_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_BPDU_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_bpdu_enable_set.unit = unit;
	async->args.port_bpdu_enable_set.port = port;
	async->args.port_bpdu_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_cable_diag_async(
	int unit,
	bcm_port_t port,
	bcm_port_cable_diag_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CABLE_DIAG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cable_diag.unit = unit;
	async->args.port_cable_diag.port = port;
	async->args.port_cable_diag.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_cfi_color_get_async(
	int unit,
	bcm_port_t port,
	int cfi,
	bcm_color_t * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CFI_COLOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cfi_color_get.unit = unit;
	async->args.port_cfi_color_get.port = port;
	async->args.port_cfi_color_get.cfi = cfi;
	async->args.port_cfi_color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_cfi_color_set_async(
	int unit,
	bcm_port_t port,
	int cfi,
	bcm_color_t color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CFI_COLOR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cfi_color_set.unit = unit;
	async->args.port_cfi_color_set.port = port;
	async->args.port_cfi_color_set.cfi = cfi;
	async->args.port_cfi_color_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_class_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_class_t pclass,
	uint32 * class_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_class_get.unit = unit;
	async->args.port_class_get.port = port;
	async->args.port_class_get.pclass = pclass;
	async->args.port_class_get.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_class_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_class_t pclass,
	uint32 class_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CLASS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_class_set.unit = unit;
	async->args.port_class_set.port = port;
	async->args.port_class_set.pclass = pclass;
	async->args.port_class_set.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_clear_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_clear.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_config_get_async(
	int unit,
	bcm_port_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_config_get.unit = unit;
	async->args.port_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_config_phy_oam_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_config_phy_oam_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONFIG_PHY_OAM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_config_phy_oam_get.unit = unit;
	async->args.port_config_phy_oam_get.port = port;
	async->args.port_config_phy_oam_get.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_config_phy_oam_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_config_phy_oam_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONFIG_PHY_OAM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_config_phy_oam_set.unit = unit;
	async->args.port_config_phy_oam_set.port = port;
	async->args.port_config_phy_oam_set.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_congestion_config_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_congestion_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_config_get.unit = unit;
	async->args.port_congestion_config_get.port = port;
	async->args.port_congestion_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_congestion_config_set_async(
	int unit,
	bcm_gport_t port,
	bcm_port_congestion_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_config_set.unit = unit;
	async->args.port_congestion_config_set.port = port;
	async->args.port_congestion_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_congestion_get_async(
	int unit,
	bcm_gport_t congestion_port,
	bcm_gport_t port,
	uint32 flags,
	int * channel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONGESTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_get.unit = unit;
	async->args.port_congestion_get.congestion_port = congestion_port;
	async->args.port_congestion_get.port = port;
	async->args.port_congestion_get.flags = flags;
	async->args.port_congestion_get.channel_id = channel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_congestion_set_async(
	int unit,
	bcm_gport_t congestion_port,
	bcm_gport_t port,
	uint32 flags,
	int channel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONGESTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_set.unit = unit;
	async->args.port_congestion_set.congestion_port = congestion_port;
	async->args.port_congestion_set.port = port;
	async->args.port_congestion_set.flags = flags;
	async->args.port_congestion_set.channel_id = channel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_t type,
	int * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_get.unit = unit;
	async->args.port_control_get.port = port;
	async->args.port_control_get.type = type;
	async->args.port_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_phy_oam_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_phy_oam_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_PHY_OAM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_oam_get.unit = unit;
	async->args.port_control_phy_oam_get.port = port;
	async->args.port_control_phy_oam_get.type = type;
	async->args.port_control_phy_oam_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_phy_oam_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_phy_oam_t type,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_PHY_OAM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_oam_set.unit = unit;
	async->args.port_control_phy_oam_set.port = port;
	async->args.port_control_phy_oam_set.type = type;
	async->args.port_control_phy_oam_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_phy_timesync_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_phy_timesync_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_PHY_TIMESYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_timesync_get.unit = unit;
	async->args.port_control_phy_timesync_get.port = port;
	async->args.port_control_phy_timesync_get.type = type;
	async->args.port_control_phy_timesync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_phy_timesync_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_phy_timesync_t type,
	uint64 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_PHY_TIMESYNC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_timesync_set.unit = unit;
	async->args.port_control_phy_timesync_set.port = port;
	async->args.port_control_phy_timesync_set.type = type;
	async->args.port_control_phy_timesync_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_control_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_control_t type,
	int value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_set.unit = unit;
	async->args.port_control_set.port = port;
	async->args.port_control_set.type = type;
	async->args.port_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_detach_async(
	int unit,
	bcm_pbmp_t pbmp,
	bcm_pbmp_t * detached,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_detach.unit = unit;
	async->args.port_detach.pbmp = pbmp;
	async->args.port_detach.detached = detached;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_discard_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DISCARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_discard_get.unit = unit;
	async->args.port_discard_get.port = port;
	async->args.port_discard_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_discard_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DISCARD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_discard_set.unit = unit;
	async->args.port_discard_set.port = port;
	async->args.port_discard_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_map_get_async(
	int unit,
	bcm_port_t port,
	int srccp,
	int * mapcp,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_get.unit = unit;
	async->args.port_dscp_map_get.port = port;
	async->args.port_dscp_map_get.srccp = srccp;
	async->args.port_dscp_map_get.mapcp = mapcp;
	async->args.port_dscp_map_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_map_mode_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_mode_get.unit = unit;
	async->args.port_dscp_map_mode_get.port = port;
	async->args.port_dscp_map_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_map_mode_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_mode_set.unit = unit;
	async->args.port_dscp_map_mode_set.port = port;
	async->args.port_dscp_map_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_map_set_async(
	int unit,
	bcm_port_t port,
	int srccp,
	int mapcp,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_set.unit = unit;
	async->args.port_dscp_map_set.port = port;
	async->args.port_dscp_map_set.srccp = srccp;
	async->args.port_dscp_map_set.mapcp = mapcp;
	async->args.port_dscp_map_set.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_unmap_get_async(
	int unit,
	bcm_port_t port,
	int internal_pri,
	bcm_color_t color,
	int * pkt_dscp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_UNMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_unmap_get.unit = unit;
	async->args.port_dscp_unmap_get.port = port;
	async->args.port_dscp_unmap_get.internal_pri = internal_pri;
	async->args.port_dscp_unmap_get.color = color;
	async->args.port_dscp_unmap_get.pkt_dscp = pkt_dscp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dscp_unmap_set_async(
	int unit,
	bcm_port_t port,
	int internal_pri,
	bcm_color_t color,
	int pkt_dscp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DSCP_UNMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_unmap_set.unit = unit;
	async->args.port_dscp_unmap_set.port = port;
	async->args.port_dscp_unmap_set.internal_pri = internal_pri;
	async->args.port_dscp_unmap_set.color = color;
	async->args.port_dscp_unmap_set.pkt_dscp = pkt_dscp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dtag_mode_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DTAG_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dtag_mode_get.unit = unit;
	async->args.port_dtag_mode_get.port = port;
	async->args.port_dtag_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_dtag_mode_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DTAG_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dtag_mode_set.unit = unit;
	async->args.port_dtag_mode_set.port = port;
	async->args.port_dtag_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_duplex_get_async(
	int unit,
	bcm_port_t port,
	int * duplex,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DUPLEX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_duplex_get.unit = unit;
	async->args.port_duplex_get.port = port;
	async->args.port_duplex_get.duplex = duplex;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_duplex_set_async(
	int unit,
	bcm_port_t port,
	int duplex,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_DUPLEX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_duplex_set.unit = unit;
	async->args.port_duplex_set.port = port;
	async->args.port_duplex_set.duplex = duplex;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_module_enable_get_async(
	int unit,
	bcm_module_t remote_module,
	bcm_port_e2efc_mode_t mode,
	int * enable,
	bcm_port_e2efc_remote_module_config_t * e2efc_rmod_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_MODULE_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_module_enable_get.unit = unit;
	async->args.port_e2efc_remote_module_enable_get.remote_module = remote_module;
	async->args.port_e2efc_remote_module_enable_get.mode = mode;
	async->args.port_e2efc_remote_module_enable_get.enable = enable;
	async->args.port_e2efc_remote_module_enable_get.e2efc_rmod_cfg = e2efc_rmod_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_module_enable_set_async(
	int unit,
	bcm_module_t remote_module,
	bcm_port_e2efc_mode_t mode,
	int enable,
	bcm_port_e2efc_remote_module_config_t * e2efc_rmod_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_MODULE_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_module_enable_set.unit = unit;
	async->args.port_e2efc_remote_module_enable_set.remote_module = remote_module;
	async->args.port_e2efc_remote_module_enable_set.mode = mode;
	async->args.port_e2efc_remote_module_enable_set.enable = enable;
	async->args.port_e2efc_remote_module_enable_set.e2efc_rmod_cfg = e2efc_rmod_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_module_traverse_async(
	int unit,
	bcm_port_e2efc_remote_module_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_MODULE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_module_traverse.unit = unit;
	async->args.port_e2efc_remote_module_traverse.cb = cb;
	async->args.port_e2efc_remote_module_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_port_add_async(
	int unit,
	bcm_port_e2efc_remote_port_config_t * e2efc_rport_cfg,
	int * rport_handle_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_port_add.unit = unit;
	async->args.port_e2efc_remote_port_add.e2efc_rport_cfg = e2efc_rport_cfg;
	async->args.port_e2efc_remote_port_add.rport_handle_id = rport_handle_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_port_delete_async(
	int unit,
	int rport_handle_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_port_delete.unit = unit;
	async->args.port_e2efc_remote_port_delete.rport_handle_id = rport_handle_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_port_get_async(
	int unit,
	int rport_handle_id,
	bcm_port_e2efc_remote_port_config_t * e2efc_rport_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_port_get.unit = unit;
	async->args.port_e2efc_remote_port_get.rport_handle_id = rport_handle_id;
	async->args.port_e2efc_remote_port_get.e2efc_rport_cfg = e2efc_rport_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_port_set_async(
	int unit,
	int rport_handle_id,
	bcm_port_e2efc_remote_port_config_t * e2efc_rport_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_port_set.unit = unit;
	async->args.port_e2efc_remote_port_set.rport_handle_id = rport_handle_id;
	async->args.port_e2efc_remote_port_set.e2efc_rport_cfg = e2efc_rport_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_e2efc_remote_port_traverse_async(
	int unit,
	bcm_port_e2efc_remote_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_E2EFC_REMOTE_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_e2efc_remote_port_traverse.unit = unit;
	async->args.port_e2efc_remote_port_traverse.cb = cb;
	async->args.port_e2efc_remote_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_egress_get_async(
	int unit,
	bcm_port_t port,
	int modid,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_egress_get.unit = unit;
	async->args.port_egress_get.port = port;
	async->args.port_egress_get.modid = modid;
	async->args.port_egress_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_egress_policer_set_async(
	int unit,
	bcm_port_t port,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_EGRESS_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_egress_policer_set.unit = unit;
	async->args.port_egress_policer_set.port = port;
	async->args.port_egress_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_egress_set_async(
	int unit,
	bcm_port_t port,
	int modid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_egress_set.unit = unit;
	async->args.port_egress_set.port = port;
	async->args.port_egress_set.modid = modid;
	async->args.port_egress_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_enable_get.unit = unit;
	async->args.port_enable_get.port = port;
	async->args.port_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_enable_set.unit = unit;
	async->args.port_enable_set.port = port;
	async->args.port_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_encap_config_t * encap_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_config_get.unit = unit;
	async->args.port_encap_config_get.gport = gport;
	async->args.port_encap_config_get.encap_config = encap_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_config_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_encap_config_t * encap_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_config_set.unit = unit;
	async->args.port_encap_config_set.gport = gport;
	async->args.port_encap_config_set.encap_config = encap_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_get.unit = unit;
	async->args.port_encap_get.port = port;
	async->args.port_encap_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_local_get_async(
	int unit,
	bcm_gport_t gport,
	uint32 flags,
	int * encap_local_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_LOCAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_local_get.unit = unit;
	async->args.port_encap_local_get.gport = gport;
	async->args.port_encap_local_get.flags = flags;
	async->args.port_encap_local_get.encap_local_id = encap_local_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_map_get_async(
	int unit,
	uint32 flags,
	bcm_if_t encap_id,
	bcm_gport_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_map_get.unit = unit;
	async->args.port_encap_map_get.flags = flags;
	async->args.port_encap_map_get.encap_id = encap_id;
	async->args.port_encap_map_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_map_set_async(
	int unit,
	uint32 flags,
	bcm_if_t encap_id,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_map_set.unit = unit;
	async->args.port_encap_map_set.flags = flags;
	async->args.port_encap_map_set.encap_id = encap_id;
	async->args.port_encap_map_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_encap_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_ENCAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_set.unit = unit;
	async->args.port_encap_set.port = port;
	async->args.port_encap_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_extender_mapping_info_get_async(
	int unit,
	uint32 flags,
	bcm_port_extender_mapping_type_t type,
	bcm_port_extender_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_EXTENDER_MAPPING_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_extender_mapping_info_get.unit = unit;
	async->args.port_extender_mapping_info_get.flags = flags;
	async->args.port_extender_mapping_info_get.type = type;
	async->args.port_extender_mapping_info_get.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_extender_mapping_info_set_async(
	int unit,
	uint32 flags,
	bcm_port_extender_mapping_type_t type,
	bcm_port_extender_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_EXTENDER_MAPPING_INFO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_extender_mapping_info_set.unit = unit;
	async->args.port_extender_mapping_info_set.flags = flags;
	async->args.port_extender_mapping_info_set.type = type;
	async->args.port_extender_mapping_info_set.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_fault_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FAULT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_fault_get.unit = unit;
	async->args.port_fault_get.port = port;
	async->args.port_fault_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_flood_block_get_async(
	int unit,
	bcm_port_t ingress_port,
	bcm_port_t egress_port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FLOOD_BLOCK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_flood_block_get.unit = unit;
	async->args.port_flood_block_get.ingress_port = ingress_port;
	async->args.port_flood_block_get.egress_port = egress_port;
	async->args.port_flood_block_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_flood_block_set_async(
	int unit,
	bcm_port_t ingress_port,
	bcm_port_t egress_port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FLOOD_BLOCK_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_flood_block_set.unit = unit;
	async->args.port_flood_block_set.ingress_port = ingress_port;
	async->args.port_flood_block_set.egress_port = egress_port;
	async->args.port_flood_block_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_dest_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_dest_info_t * dest_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_DEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_dest_get.unit = unit;
	async->args.port_force_dest_get.gport = gport;
	async->args.port_force_dest_get.dest_info = dest_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_dest_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_dest_info_t * dest_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_DEST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_dest_set.unit = unit;
	async->args.port_force_dest_set.gport = gport;
	async->args.port_force_dest_set.dest_info = dest_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_forward_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_t * egr_port,
	int * enabled,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_forward_get.unit = unit;
	async->args.port_force_forward_get.port = port;
	async->args.port_force_forward_get.egr_port = egr_port;
	async->args.port_force_forward_get.enabled = enabled;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_forward_mode_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_t * egr_port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_forward_mode_get.unit = unit;
	async->args.port_force_forward_mode_get.port = port;
	async->args.port_force_forward_mode_get.egr_port = egr_port;
	async->args.port_force_forward_mode_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_forward_mode_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_t egr_port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_forward_mode_set.unit = unit;
	async->args.port_force_forward_mode_set.port = port;
	async->args.port_force_forward_mode_set.egr_port = egr_port;
	async->args.port_force_forward_mode_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_forward_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_t egr_port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_forward_set.unit = unit;
	async->args.port_force_forward_set.port = port;
	async->args.port_force_forward_set.egr_port = egr_port;
	async->args.port_force_forward_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_vlan_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t * vlan,
	int * pkt_prio,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_vlan_get.unit = unit;
	async->args.port_force_vlan_get.port = port;
	async->args.port_force_vlan_get.vlan = vlan;
	async->args.port_force_vlan_get.pkt_prio = pkt_prio;
	async->args.port_force_vlan_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_force_vlan_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	int pkt_prio,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FORCE_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_vlan_set.unit = unit;
	async->args.port_force_vlan_set.port = port;
	async->args.port_force_vlan_set.vlan = vlan;
	async->args.port_force_vlan_set.pkt_prio = pkt_prio;
	async->args.port_force_vlan_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_frame_max_get_async(
	int unit,
	bcm_port_t port,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FRAME_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_frame_max_get.unit = unit;
	async->args.port_frame_max_get.port = port;
	async->args.port_frame_max_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_frame_max_set_async(
	int unit,
	bcm_port_t port,
	int size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_FRAME_MAX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_frame_max_set.unit = unit;
	async->args.port_frame_max_set.port = port;
	async->args.port_frame_max_set.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_port_interface_info_t * interface_info,
	bcm_port_mapping_info_t * mapping_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_get.unit = unit;
	async->args.port_get.port = port;
	async->args.port_get.flags = flags;
	async->args.port_get.interface_info = interface_info;
	async->args.port_get.mapping_info = mapping_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_add_async(
	int unit,
	bcm_port_t local_port,
	bcm_gport_t modport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_add.unit = unit;
	async->args.port_gport_add.local_port = local_port;
	async->args.port_gport_add.modport = modport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_delete_async(
	int unit,
	bcm_port_t local_port,
	bcm_gport_t modport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_delete.unit = unit;
	async->args.port_gport_delete.local_port = local_port;
	async->args.port_gport_delete.modport = modport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_delete_all_async(
	int unit,
	bcm_port_t local_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_delete_all.unit = unit;
	async->args.port_gport_delete_all.local_port = local_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_free_range_get_async(
	int unit,
	uint32 gport_type,
	bcm_gport_t * gport_min,
	bcm_gport_t * gport_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_FREE_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_free_range_get.unit = unit;
	async->args.port_gport_free_range_get.gport_type = gport_type;
	async->args.port_gport_free_range_get.gport_min = gport_min;
	async->args.port_gport_free_range_get.gport_max = gport_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_get_async(
	int unit,
	bcm_port_t port,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_get.unit = unit;
	async->args.port_gport_get.port = port;
	async->args.port_gport_get.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_get_all_async(
	int unit,
	bcm_port_t local_port,
	int size,
	bcm_gport_t * gport_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_get_all.unit = unit;
	async->args.port_gport_get_all.local_port = local_port;
	async->args.port_gport_get_all.size = size;
	async->args.port_gport_get_all.gport_array = gport_array;
	async->args.port_gport_get_all.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_gport_is_free_async(
	int unit,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_GPORT_IS_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_is_free.unit = unit;
	async->args.port_gport_is_free.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ifg_get_async(
	int unit,
	bcm_port_t port,
	int speed,
	bcm_port_duplex_t duplex,
	int * bit_times,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IFG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifg_get.unit = unit;
	async->args.port_ifg_get.port = port;
	async->args.port_ifg_get.speed = speed;
	async->args.port_ifg_get.duplex = duplex;
	async->args.port_ifg_get.bit_times = bit_times;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ifg_set_async(
	int unit,
	bcm_port_t port,
	int speed,
	bcm_port_duplex_t duplex,
	int bit_times,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IFG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifg_set.unit = unit;
	async->args.port_ifg_set.port = port;
	async->args.port_ifg_set.speed = speed;
	async->args.port_ifg_set.duplex = duplex;
	async->args.port_ifg_set.bit_times = bit_times;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ifilter_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IFILTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifilter_get.unit = unit;
	async->args.port_ifilter_get.port = port;
	async->args.port_ifilter_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ifilter_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IFILTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifilter_set.unit = unit;
	async->args.port_ifilter_set.port = port;
	async->args.port_ifilter_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_info_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_get.unit = unit;
	async->args.port_info_get.port = port;
	async->args.port_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_info_restore_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INFO_RESTORE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_restore.unit = unit;
	async->args.port_info_restore.port = port;
	async->args.port_info_restore.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_info_save_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INFO_SAVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_save.unit = unit;
	async->args.port_info_save.port = port;
	async->args.port_info_save.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_info_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INFO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_set.unit = unit;
	async->args.port_info_set.port = port;
	async->args.port_info_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ingress_tdm_failover_get_async(
	int unit,
	int flag,
	bcm_pbmp_t * tdm_enable_pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INGRESS_TDM_FAILOVER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ingress_tdm_failover_get.unit = unit;
	async->args.port_ingress_tdm_failover_get.flag = flag;
	async->args.port_ingress_tdm_failover_get.tdm_enable_pbmp = tdm_enable_pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ingress_tdm_failover_set_async(
	int unit,
	int flag,
	bcm_pbmp_t tdm_enable_pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INGRESS_TDM_FAILOVER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ingress_tdm_failover_set.unit = unit;
	async->args.port_ingress_tdm_failover_set.flag = flag;
	async->args.port_ingress_tdm_failover_set.tdm_enable_pbmp = tdm_enable_pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_inner_tpid_get_async(
	int unit,
	bcm_port_t port,
	uint16 * tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INNER_TPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_inner_tpid_get.unit = unit;
	async->args.port_inner_tpid_get.port = port;
	async->args.port_inner_tpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_inner_tpid_set_async(
	int unit,
	bcm_port_t port,
	uint16 tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INNER_TPID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_inner_tpid_set.unit = unit;
	async->args.port_inner_tpid_set.port = port;
	async->args.port_inner_tpid_set.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_interface_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_interface_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INTERFACE_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_config_get.unit = unit;
	async->args.port_interface_config_get.port = port;
	async->args.port_interface_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_interface_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_interface_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INTERFACE_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_config_set.unit = unit;
	async->args.port_interface_config_set.port = port;
	async->args.port_interface_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_interface_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_if_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INTERFACE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_get.unit = unit;
	async->args.port_interface_get.port = port;
	async->args.port_interface_get.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_interface_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_if_t intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INTERFACE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_set.unit = unit;
	async->args.port_interface_set.port = port;
	async->args.port_interface_set.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_internal_get_async(
	int unit,
	uint32 flags,
	int internal_ports_max,
	bcm_gport_t * internal_gport,
	int * internal_ports_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_INTERNAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_internal_get.unit = unit;
	async->args.port_internal_get.flags = flags;
	async->args.port_internal_get.internal_ports_max = internal_ports_max;
	async->args.port_internal_get.internal_gport = internal_gport;
	async->args.port_internal_get.internal_ports_count = internal_ports_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ipmc_modify_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IPMC_MODIFY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ipmc_modify_get.unit = unit;
	async->args.port_ipmc_modify_get.port = port;
	async->args.port_ipmc_modify_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_ipmc_modify_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_IPMC_MODIFY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ipmc_modify_set.unit = unit;
	async->args.port_ipmc_modify_set.port = port;
	async->args.port_ipmc_modify_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_jam_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_JAM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_jam_get.unit = unit;
	async->args.port_jam_get.port = port;
	async->args.port_jam_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_jam_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_JAM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_jam_set.unit = unit;
	async->args.port_jam_set.port = port;
	async->args.port_jam_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_enable_get.unit = unit;
	async->args.port_l3_enable_get.port = port;
	async->args.port_l3_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_enable_set.unit = unit;
	async->args.port_l3_enable_set.port = port;
	async->args.port_l3_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_encapsulated_mtu_get_async(
	int unit,
	bcm_port_t port,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_ENCAPSULATED_MTU_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_encapsulated_mtu_get.unit = unit;
	async->args.port_l3_encapsulated_mtu_get.port = port;
	async->args.port_l3_encapsulated_mtu_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_encapsulated_mtu_set_async(
	int unit,
	bcm_port_t port,
	int size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_ENCAPSULATED_MTU_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_encapsulated_mtu_set.unit = unit;
	async->args.port_l3_encapsulated_mtu_set.port = port;
	async->args.port_l3_encapsulated_mtu_set.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_modify_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_MODIFY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_modify_get.unit = unit;
	async->args.port_l3_modify_get.port = port;
	async->args.port_l3_modify_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_modify_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_MODIFY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_modify_set.unit = unit;
	async->args.port_l3_modify_set.port = port;
	async->args.port_l3_modify_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_mtu_get_async(
	int unit,
	bcm_port_t port,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_MTU_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_mtu_get.unit = unit;
	async->args.port_l3_mtu_get.port = port;
	async->args.port_l3_mtu_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_l3_mtu_set_async(
	int unit,
	bcm_port_t port,
	int size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_L3_MTU_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_mtu_set.unit = unit;
	async->args.port_l3_mtu_set.port = port;
	async->args.port_l3_mtu_set.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_learn_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LEARN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_get.unit = unit;
	async->args.port_learn_get.port = port;
	async->args.port_learn_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_learn_modify_async(
	int unit,
	bcm_port_t port,
	uint32 add,
	uint32 remove,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LEARN_MODIFY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_modify.unit = unit;
	async->args.port_learn_modify.port = port;
	async->args.port_learn_modify.add = add;
	async->args.port_learn_modify.remove = remove;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_learn_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LEARN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_set.unit = unit;
	async->args.port_learn_set.port = port;
	async->args.port_learn_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_link_failed_clear_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LINK_FAILED_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_link_failed_clear.unit = unit;
	async->args.port_link_failed_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_link_state_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_port_link_state_t * state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LINK_STATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_link_state_get.unit = unit;
	async->args.port_link_state_get.port = port;
	async->args.port_link_state_get.flags = flags;
	async->args.port_link_state_get.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_link_status_get_async(
	int unit,
	bcm_port_t port,
	int * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LINK_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_link_status_get.unit = unit;
	async->args.port_link_status_get.port = port;
	async->args.port_link_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_linkscan_get_async(
	int unit,
	bcm_port_t port,
	int * linkscan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LINKSCAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_linkscan_get.unit = unit;
	async->args.port_linkscan_get.port = port;
	async->args.port_linkscan_get.linkscan = linkscan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_linkscan_set_async(
	int unit,
	bcm_port_t port,
	int linkscan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LINKSCAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_linkscan_set.unit = unit;
	async->args.port_linkscan_set.port = port;
	async->args.port_linkscan_set.linkscan = linkscan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_local_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_t * local_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LOCAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_local_get.unit = unit;
	async->args.port_local_get.gport = gport;
	async->args.port_local_get.local_port = local_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_loopback_get_async(
	int unit,
	bcm_port_t port,
	int * loopback,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LOOPBACK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_loopback_get.unit = unit;
	async->args.port_loopback_get.port = port;
	async->args.port_loopback_get.loopback = loopback;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_loopback_set_async(
	int unit,
	bcm_port_t port,
	int loopback,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_LOOPBACK_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_loopback_set.unit = unit;
	async->args.port_loopback_set.port = port;
	async->args.port_loopback_set.loopback = loopback;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_management_packet_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_management_packet_config_t * config_array,
	int max_config,
	int * config_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MANAGEMENT_PACKET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_management_packet_config_get.unit = unit;
	async->args.port_management_packet_config_get.port = port;
	async->args.port_management_packet_config_get.config_array = config_array;
	async->args.port_management_packet_config_get.max_config = max_config;
	async->args.port_management_packet_config_get.config_count = config_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_management_packet_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_management_packet_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MANAGEMENT_PACKET_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_management_packet_config_set.unit = unit;
	async->args.port_management_packet_config_set.port = port;
	async->args.port_management_packet_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_master_get_async(
	int unit,
	bcm_port_t port,
	int * ms,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MASTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_master_get.unit = unit;
	async->args.port_master_get.port = port;
	async->args.port_master_get.ms = ms;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_master_set_async(
	int unit,
	bcm_port_t port,
	int ms,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MASTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_master_set.unit = unit;
	async->args.port_master_set.port = port;
	async->args.port_master_set.ms = ms;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_add_async(
	int unit,
	bcm_gport_t port,
	bcm_port_match_info_t * match,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_add.unit = unit;
	async->args.port_match_add.port = port;
	async->args.port_match_add.match = match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_delete_async(
	int unit,
	bcm_gport_t port,
	bcm_port_match_info_t * match,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_delete.unit = unit;
	async->args.port_match_delete.port = port;
	async->args.port_match_delete.match = match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_delete_all_async(
	int unit,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_delete_all.unit = unit;
	async->args.port_match_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_multi_get_async(
	int unit,
	bcm_gport_t port,
	int size,
	bcm_port_match_info_t * match_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_multi_get.unit = unit;
	async->args.port_match_multi_get.port = port;
	async->args.port_match_multi_get.size = size;
	async->args.port_match_multi_get.match_array = match_array;
	async->args.port_match_multi_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_replace_async(
	int unit,
	bcm_gport_t port,
	bcm_port_match_info_t * old_match,
	bcm_port_match_info_t * new_match,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_REPLACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_replace.unit = unit;
	async->args.port_match_replace.port = port;
	async->args.port_match_replace.old_match = old_match;
	async->args.port_match_replace.new_match = new_match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_match_set_async(
	int unit,
	bcm_gport_t port,
	int size,
	bcm_port_match_info_t * match_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MATCH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_set.unit = unit;
	async->args.port_match_set.port = port;
	async->args.port_match_set.size = size;
	async->args.port_match_set.match_array = match_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_mdix_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_mdix_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MDIX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_get.unit = unit;
	async->args.port_mdix_get.port = port;
	async->args.port_mdix_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_mdix_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_mdix_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MDIX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_set.unit = unit;
	async->args.port_mdix_set.port = port;
	async->args.port_mdix_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_mdix_status_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_mdix_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MDIX_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_status_get.unit = unit;
	async->args.port_mdix_status_get.port = port;
	async->args.port_mdix_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_medium_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_medium_t medium,
	bcm_phy_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_config_get.unit = unit;
	async->args.port_medium_config_get.port = port;
	async->args.port_medium_config_get.medium = medium;
	async->args.port_medium_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_medium_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_medium_t medium,
	bcm_phy_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_config_set.unit = unit;
	async->args.port_medium_config_set.port = port;
	async->args.port_medium_config_set.medium = medium;
	async->args.port_medium_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_medium_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_medium_t * medium,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MEDIUM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_get.unit = unit;
	async->args.port_medium_get.port = port;
	async->args.port_medium_get.medium = medium;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_medium_status_register_async(
	int unit,
	bcm_port_t port,
	bcm_port_medium_status_cb_t callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MEDIUM_STATUS_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_status_register.unit = unit;
	async->args.port_medium_status_register.port = port;
	async->args.port_medium_status_register.callback = callback;
	async->args.port_medium_status_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_medium_status_unregister_async(
	int unit,
	bcm_port_t port,
	bcm_port_medium_status_cb_t callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MEDIUM_STATUS_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_status_unregister.unit = unit;
	async->args.port_medium_status_unregister.port = port;
	async->args.port_medium_status_unregister.callback = callback;
	async->args.port_medium_status_unregister.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_modid_egress_get_async(
	int unit,
	bcm_port_t port,
	bcm_module_t modid,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MODID_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_egress_get.unit = unit;
	async->args.port_modid_egress_get.port = port;
	async->args.port_modid_egress_get.modid = modid;
	async->args.port_modid_egress_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_modid_egress_set_async(
	int unit,
	bcm_port_t port,
	bcm_module_t modid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MODID_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_egress_set.unit = unit;
	async->args.port_modid_egress_set.port = port;
	async->args.port_modid_egress_set.modid = modid;
	async->args.port_modid_egress_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_modid_enable_get_async(
	int unit,
	bcm_port_t port,
	int modid,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MODID_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_enable_get.unit = unit;
	async->args.port_modid_enable_get.port = port;
	async->args.port_modid_enable_get.modid = modid;
	async->args.port_modid_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_modid_enable_set_async(
	int unit,
	bcm_port_t port,
	int modid,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_MODID_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_enable_set.unit = unit;
	async->args.port_modid_enable_set.port = port;
	async->args.port_modid_enable_set.modid = modid;
	async->args.port_modid_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_nif_priority_get_async(
	int unit,
	bcm_gport_t local_port,
	uint32 flags,
	bcm_port_nif_prio_t * priority,
	bcm_pbmp_t * affected_ports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_NIF_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_nif_priority_get.unit = unit;
	async->args.port_nif_priority_get.local_port = local_port;
	async->args.port_nif_priority_get.flags = flags;
	async->args.port_nif_priority_get.priority = priority;
	async->args.port_nif_priority_get.affected_ports = affected_ports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_nif_priority_set_async(
	int unit,
	bcm_gport_t local_port,
	uint32 flags,
	bcm_port_nif_prio_t * priority,
	bcm_pbmp_t * affected_ports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_NIF_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_nif_priority_set.unit = unit;
	async->args.port_nif_priority_set.local_port = local_port;
	async->args.port_nif_priority_set.flags = flags;
	async->args.port_nif_priority_set.priority = priority;
	async->args.port_nif_priority_set.affected_ports = affected_ports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_addr_get_async(
	int unit,
	bcm_port_t port,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_ADDR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_addr_get.unit = unit;
	async->args.port_pause_addr_get.port = port;
	async->args.port_pause_addr_get.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_addr_set_async(
	int unit,
	bcm_port_t port,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_ADDR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_addr_set.unit = unit;
	async->args.port_pause_addr_set.port = port;
	async->args.port_pause_addr_set.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_get_async(
	int unit,
	bcm_port_t port,
	int * pause_tx,
	int * pause_rx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_get.unit = unit;
	async->args.port_pause_get.port = port;
	async->args.port_pause_get.pause_tx = pause_tx;
	async->args.port_pause_get.pause_rx = pause_rx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_set_async(
	int unit,
	bcm_port_t port,
	int pause_tx,
	int pause_rx,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_set.unit = unit;
	async->args.port_pause_set.port = port;
	async->args.port_pause_set.pause_tx = pause_tx;
	async->args.port_pause_set.pause_rx = pause_rx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_sym_get_async(
	int unit,
	bcm_port_t port,
	int * pause,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_SYM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_sym_get.unit = unit;
	async->args.port_pause_sym_get.port = port;
	async->args.port_pause_sym_get.pause = pause;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pause_sym_set_async(
	int unit,
	bcm_port_t port,
	int pause,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PAUSE_SYM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_sym_set.unit = unit;
	async->args.port_pause_sym_set.port = port;
	async->args.port_pause_sym_set.pause = pause;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pfm_get_async(
	int unit,
	bcm_port_t port,
	int * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PFM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pfm_get.unit = unit;
	async->args.port_pfm_get.port = port;
	async->args.port_pfm_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pfm_set_async(
	int unit,
	bcm_port_t port,
	int mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PFM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pfm_set.unit = unit;
	async->args.port_pfm_set.port = port;
	async->args.port_pfm_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_control_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_control_t type,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_control_get.unit = unit;
	async->args.port_phy_control_get.port = port;
	async->args.port_phy_control_get.type = type;
	async->args.port_phy_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_control_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_control_t type,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_control_set.unit = unit;
	async->args.port_phy_control_set.port = port;
	async->args.port_phy_control_set.type = type;
	async->args.port_phy_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_drv_name_get_async(
	int unit,
	bcm_port_t port,
	char * name,
	int len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_DRV_NAME_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_drv_name_get.unit = unit;
	async->args.port_phy_drv_name_get.port = port;
	async->args.port_phy_drv_name_get.name = name;
	async->args.port_phy_drv_name_get.len = len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_firmware_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	int offset,
	uint8 * array,
	int length,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_FIRMWARE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_firmware_set.unit = unit;
	async->args.port_phy_firmware_set.port = port;
	async->args.port_phy_firmware_set.flags = flags;
	async->args.port_phy_firmware_set.offset = offset;
	async->args.port_phy_firmware_set.array = array;
	async->args.port_phy_firmware_set.length = length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 * phy_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_get.unit = unit;
	async->args.port_phy_get.port = port;
	async->args.port_phy_get.flags = flags;
	async->args.port_phy_get.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_get.phy_data = phy_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_modify_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 phy_data,
	uint32 phy_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_MODIFY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_modify.unit = unit;
	async->args.port_phy_modify.port = port;
	async->args.port_phy_modify.flags = flags;
	async->args.port_phy_modify.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_modify.phy_data = phy_data;
	async->args.port_phy_modify.phy_mask = phy_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_multi_get_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 dev_addr,
	uint32 offset,
	int max_size,
	uint8 * data,
	int * actual_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_multi_get.unit = unit;
	async->args.port_phy_multi_get.port = port;
	async->args.port_phy_multi_get.flags = flags;
	async->args.port_phy_multi_get.dev_addr = dev_addr;
	async->args.port_phy_multi_get.offset = offset;
	async->args.port_phy_multi_get.max_size = max_size;
	async->args.port_phy_multi_get.data = data;
	async->args.port_phy_multi_get.actual_size = actual_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_reset_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_RESET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_reset.unit = unit;
	async->args.port_phy_reset.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_reset_register_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_reset_cb_t callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_RESET_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_reset_register.unit = unit;
	async->args.port_phy_reset_register.port = port;
	async->args.port_phy_reset_register.callback = callback;
	async->args.port_phy_reset_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_reset_unregister_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_reset_cb_t callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_RESET_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_reset_unregister.unit = unit;
	async->args.port_phy_reset_unregister.port = port;
	async->args.port_phy_reset_unregister.callback = callback;
	async->args.port_phy_reset_unregister.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 phy_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_set.unit = unit;
	async->args.port_phy_set.port = port;
	async->args.port_phy_set.flags = flags;
	async->args.port_phy_set.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_set.phy_data = phy_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_timesync_config_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_timesync_config_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_TIMESYNC_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_config_get.unit = unit;
	async->args.port_phy_timesync_config_get.port = port;
	async->args.port_phy_timesync_config_get.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_timesync_config_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_timesync_config_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_TIMESYNC_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_config_set.unit = unit;
	async->args.port_phy_timesync_config_set.port = port;
	async->args.port_phy_timesync_config_set.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_phy_timesync_enhanced_capture_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_phy_timesync_enhanced_capture_t * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PHY_TIMESYNC_ENHANCED_CAPTURE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_enhanced_capture_get.unit = unit;
	async->args.port_phy_timesync_enhanced_capture_get.port = port;
	async->args.port_phy_timesync_enhanced_capture_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_policer_get_async(
	int unit,
	bcm_port_t port,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_policer_get.unit = unit;
	async->args.port_policer_get.port = port;
	async->args.port_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_policer_set_async(
	int unit,
	bcm_port_t port,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_policer_set.unit = unit;
	async->args.port_policer_set.port = port;
	async->args.port_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_info_get_async(
	int unit,
	bcm_port_t pon_port,
	bcm_port_pon_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_info_get.unit = unit;
	async->args.port_pon_info_get.pon_port = pon_port;
	async->args.port_pon_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_info_set_async(
	int unit,
	bcm_port_t pon_port,
	bcm_port_pon_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_INFO_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_info_set.unit = unit;
	async->args.port_pon_info_set.pon_port = pon_port;
	async->args.port_pon_info_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_tunnel_add_async(
	int unit,
	bcm_gport_t pon_port,
	uint32 flags,
	bcm_gport_t * tunnel_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_TUNNEL_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_tunnel_add.unit = unit;
	async->args.port_pon_tunnel_add.pon_port = pon_port;
	async->args.port_pon_tunnel_add.flags = flags;
	async->args.port_pon_tunnel_add.tunnel_port_id = tunnel_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_tunnel_map_get_async(
	int unit,
	bcm_gport_t pon_port,
	bcm_tunnel_id_t tunnel_id,
	bcm_gport_t * tunnel_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_TUNNEL_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_tunnel_map_get.unit = unit;
	async->args.port_pon_tunnel_map_get.pon_port = pon_port;
	async->args.port_pon_tunnel_map_get.tunnel_id = tunnel_id;
	async->args.port_pon_tunnel_map_get.tunnel_port_id = tunnel_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_tunnel_map_set_async(
	int unit,
	bcm_gport_t pon_port,
	bcm_tunnel_id_t tunnel_id,
	bcm_gport_t tunnel_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_TUNNEL_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_tunnel_map_set.unit = unit;
	async->args.port_pon_tunnel_map_set.pon_port = pon_port;
	async->args.port_pon_tunnel_map_set.tunnel_id = tunnel_id;
	async->args.port_pon_tunnel_map_set.tunnel_port_id = tunnel_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_pon_tunnel_remove_async(
	int unit,
	bcm_gport_t tunnel_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PON_TUNNEL_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pon_tunnel_remove.unit = unit;
	async->args.port_pon_tunnel_remove.tunnel_port_id = tunnel_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_preemption_control_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_preempt_control_t type,
	uint32 * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PREEMPTION_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_preemption_control_get.unit = unit;
	async->args.port_preemption_control_get.gport = gport;
	async->args.port_preemption_control_get.type = type;
	async->args.port_preemption_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_preemption_control_set_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_preempt_control_t type,
	uint32 arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PREEMPTION_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_preemption_control_set.unit = unit;
	async->args.port_preemption_control_set.gport = gport;
	async->args.port_preemption_control_set.type = type;
	async->args.port_preemption_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_preemption_status_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_preempt_status_t type,
	uint32 * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PREEMPTION_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_preemption_status_get.unit = unit;
	async->args.port_preemption_status_get.gport = gport;
	async->args.port_preemption_status_get.type = type;
	async->args.port_preemption_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_color_get_async(
	int unit,
	bcm_port_t port,
	int prio,
	bcm_color_t * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_COLOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_color_get.unit = unit;
	async->args.port_priority_color_get.port = port;
	async->args.port_priority_color_get.prio = prio;
	async->args.port_priority_color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_color_set_async(
	int unit,
	bcm_port_t port,
	int prio,
	bcm_color_t color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_COLOR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_color_set.unit = unit;
	async->args.port_priority_color_set.port = port;
	async->args.port_priority_color_set.prio = prio;
	async->args.port_priority_color_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_group_config_get_async(
	int unit,
	bcm_gport_t gport,
	int priority_group,
	bcm_port_priority_group_config_t * prigrp_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_GROUP_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_group_config_get.unit = unit;
	async->args.port_priority_group_config_get.gport = gport;
	async->args.port_priority_group_config_get.priority_group = priority_group;
	async->args.port_priority_group_config_get.prigrp_config = prigrp_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_group_config_set_async(
	int unit,
	bcm_gport_t gport,
	int priority_group,
	bcm_port_priority_group_config_t * prigrp_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_GROUP_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_group_config_set.unit = unit;
	async->args.port_priority_group_config_set.gport = gport;
	async->args.port_priority_group_config_set.priority_group = priority_group;
	async->args.port_priority_group_config_set.prigrp_config = prigrp_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_group_mapping_get_async(
	int unit,
	bcm_gport_t gport,
	int prio,
	int * priority_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_GROUP_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_group_mapping_get.unit = unit;
	async->args.port_priority_group_mapping_get.gport = gport;
	async->args.port_priority_group_mapping_get.prio = prio;
	async->args.port_priority_group_mapping_get.priority_group = priority_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_priority_group_mapping_set_async(
	int unit,
	bcm_gport_t gport,
	int prio,
	int priority_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PRIORITY_GROUP_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_group_mapping_set.unit = unit;
	async->args.port_priority_group_mapping_set.gport = gport;
	async->args.port_priority_group_mapping_set.prio = prio;
	async->args.port_priority_group_mapping_set.priority_group = priority_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_probe_async(
	int unit,
	bcm_pbmp_t pbmp,
	bcm_pbmp_t * okay_pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PROBE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_probe.unit = unit;
	async->args.port_probe.pbmp = pbmp;
	async->args.port_probe.okay_pbmp = okay_pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_protocol_vlan_add_async(
	int unit,
	bcm_port_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_add.unit = unit;
	async->args.port_protocol_vlan_add.port = port;
	async->args.port_protocol_vlan_add.frame = frame;
	async->args.port_protocol_vlan_add.ether = ether;
	async->args.port_protocol_vlan_add.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_protocol_vlan_delete_async(
	int unit,
	bcm_port_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_delete.unit = unit;
	async->args.port_protocol_vlan_delete.port = port;
	async->args.port_protocol_vlan_delete.frame = frame;
	async->args.port_protocol_vlan_delete.ether = ether;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_protocol_vlan_delete_all_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_delete_all.unit = unit;
	async->args.port_protocol_vlan_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_queued_count_get_async(
	int unit,
	bcm_port_t port,
	uint32 * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_QUEUED_COUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_queued_count_get.unit = unit;
	async->args.port_queued_count_get.port = port;
	async->args.port_queued_count_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_get_async(
	int unit,
	bcm_port_t port,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_get.unit = unit;
	async->args.port_rate_egress_get.port = port;
	async->args.port_rate_egress_get.kbits_sec = kbits_sec;
	async->args.port_rate_egress_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_pps_get_async(
	int unit,
	bcm_port_t port,
	uint32 * pps,
	uint32 * burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_PPS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_pps_get.unit = unit;
	async->args.port_rate_egress_pps_get.port = port;
	async->args.port_rate_egress_pps_get.pps = pps;
	async->args.port_rate_egress_pps_get.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_pps_set_async(
	int unit,
	bcm_port_t port,
	uint32 pps,
	uint32 burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_PPS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_pps_set.unit = unit;
	async->args.port_rate_egress_pps_set.port = port;
	async->args.port_rate_egress_pps_set.pps = pps;
	async->args.port_rate_egress_pps_set.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_set_async(
	int unit,
	bcm_port_t port,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_set.unit = unit;
	async->args.port_rate_egress_set.port = port;
	async->args.port_rate_egress_set.kbits_sec = kbits_sec;
	async->args.port_rate_egress_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_traffic_get_async(
	int unit,
	bcm_port_t port,
	uint32 * traffic_types,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_TRAFFIC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_traffic_get.unit = unit;
	async->args.port_rate_egress_traffic_get.port = port;
	async->args.port_rate_egress_traffic_get.traffic_types = traffic_types;
	async->args.port_rate_egress_traffic_get.kbits_sec = kbits_sec;
	async->args.port_rate_egress_traffic_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_egress_traffic_set_async(
	int unit,
	bcm_port_t port,
	uint32 traffic_types,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_TRAFFIC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_traffic_set.unit = unit;
	async->args.port_rate_egress_traffic_set.port = port;
	async->args.port_rate_egress_traffic_set.traffic_types = traffic_types;
	async->args.port_rate_egress_traffic_set.kbits_sec = kbits_sec;
	async->args.port_rate_egress_traffic_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_ingress_get_async(
	int unit,
	bcm_port_t port,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_INGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_ingress_get.unit = unit;
	async->args.port_rate_ingress_get.port = port;
	async->args.port_rate_ingress_get.kbits_sec = kbits_sec;
	async->args.port_rate_ingress_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_ingress_set_async(
	int unit,
	bcm_port_t port,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_INGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_ingress_set.unit = unit;
	async->args.port_rate_ingress_set.port = port;
	async->args.port_rate_ingress_set.kbits_sec = kbits_sec;
	async->args.port_rate_ingress_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_pause_get_async(
	int unit,
	bcm_port_t port,
	uint32 * kbits_pause,
	uint32 * kbits_resume,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_PAUSE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_pause_get.unit = unit;
	async->args.port_rate_pause_get.port = port;
	async->args.port_rate_pause_get.kbits_pause = kbits_pause;
	async->args.port_rate_pause_get.kbits_resume = kbits_resume;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_rate_pause_set_async(
	int unit,
	bcm_port_t port,
	uint32 kbits_pause,
	uint32 kbits_resume,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RATE_PAUSE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_pause_set.unit = unit;
	async->args.port_rate_pause_set.port = port;
	async->args.port_rate_pause_set.kbits_pause = kbits_pause;
	async->args.port_rate_pause_set.kbits_resume = kbits_resume;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_redirect_config_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_port_redirect_config_t * redirect_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_REDIRECT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_redirect_config_get.unit = unit;
	async->args.port_redirect_config_get.gport = gport;
	async->args.port_redirect_config_get.redirect_config = redirect_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_redirect_config_set_async(
	int unit,
	bcm_gport_t port,
	bcm_port_redirect_config_t * redirect_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_REDIRECT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_redirect_config_set.unit = unit;
	async->args.port_redirect_config_set.port = port;
	async->args.port_redirect_config_set.redirect_config = redirect_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_remove_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_remove.unit = unit;
	async->args.port_remove.port = port;
	async->args.port_remove.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_resource_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_resource_t * resource,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RESOURCE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_resource_get.unit = unit;
	async->args.port_resource_get.port = port;
	async->args.port_resource_get.resource = resource;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_resource_multi_set_async(
	int unit,
	int nport,
	bcm_port_resource_t * resource,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RESOURCE_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_resource_multi_set.unit = unit;
	async->args.port_resource_multi_set.nport = nport;
	async->args.port_resource_multi_set.resource = resource;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_resource_set_async(
	int unit,
	bcm_gport_t port,
	bcm_port_resource_t * resource,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RESOURCE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_resource_set.unit = unit;
	async->args.port_resource_set.port = port;
	async->args.port_resource_set.resource = resource;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_resource_traverse_async(
	int unit,
	bcm_port_resource_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_RESOURCE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_resource_traverse.unit = unit;
	async->args.port_resource_traverse.trav_fn = trav_fn;
	async->args.port_resource_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_sample_rate_get_async(
	int unit,
	bcm_port_t port,
	int * ingress_rate,
	int * egress_rate,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SAMPLE_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_sample_rate_get.unit = unit;
	async->args.port_sample_rate_get.port = port;
	async->args.port_sample_rate_get.ingress_rate = ingress_rate;
	async->args.port_sample_rate_get.egress_rate = egress_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_sample_rate_set_async(
	int unit,
	bcm_port_t port,
	int ingress_rate,
	int egress_rate,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SAMPLE_RATE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_sample_rate_set.unit = unit;
	async->args.port_sample_rate_set.port = port;
	async->args.port_sample_rate_set.ingress_rate = ingress_rate;
	async->args.port_sample_rate_set.egress_rate = egress_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_selective_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SELECTIVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_selective_get.unit = unit;
	async->args.port_selective_get.port = port;
	async->args.port_selective_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_selective_set_async(
	int unit,
	bcm_port_t port,
	bcm_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SELECTIVE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_selective_set.unit = unit;
	async->args.port_selective_set.port = port;
	async->args.port_selective_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_speed_get_async(
	int unit,
	bcm_port_t port,
	int * speed,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SPEED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_get.unit = unit;
	async->args.port_speed_get.port = port;
	async->args.port_speed_get.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_speed_max_async(
	int unit,
	bcm_port_t port,
	int * speed,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SPEED_MAX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_max.unit = unit;
	async->args.port_speed_max.port = port;
	async->args.port_speed_max.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_speed_set_async(
	int unit,
	bcm_port_t port,
	int speed,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SPEED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_set.unit = unit;
	async->args.port_speed_set.port = port;
	async->args.port_speed_set.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_attach_async(
	int unit,
	bcm_gport_t port,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_attach.unit = unit;
	async->args.port_stat_attach.port = port;
	async->args.port_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_counter_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_counter_get.unit = unit;
	async->args.port_stat_counter_get.port = port;
	async->args.port_stat_counter_get.stat = stat;
	async->args.port_stat_counter_get.num_entries = num_entries;
	async->args.port_stat_counter_get.counter_indexes = counter_indexes;
	async->args.port_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_counter_set_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_counter_set.unit = unit;
	async->args.port_stat_counter_set.port = port;
	async->args.port_stat_counter_set.stat = stat;
	async->args.port_stat_counter_set.num_entries = num_entries;
	async->args.port_stat_counter_set.counter_indexes = counter_indexes;
	async->args.port_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_counter_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_counter_sync_get.unit = unit;
	async->args.port_stat_counter_sync_get.port = port;
	async->args.port_stat_counter_sync_get.stat = stat;
	async->args.port_stat_counter_sync_get.num_entries = num_entries;
	async->args.port_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.port_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_detach_async(
	int unit,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_detach.unit = unit;
	async->args.port_stat_detach.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_detach_with_id_async(
	int unit,
	bcm_gport_t port,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_DETACH_WITH_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_detach_with_id.unit = unit;
	async->args.port_stat_detach_with_id.port = port;
	async->args.port_stat_detach_with_id.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_enable_set_async(
	int unit,
	bcm_gport_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_enable_set.unit = unit;
	async->args.port_stat_enable_set.port = port;
	async->args.port_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_get.unit = unit;
	async->args.port_stat_get.port = port;
	async->args.port_stat_get.stat = stat;
	async->args.port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_get32.unit = unit;
	async->args.port_stat_get32.port = port;
	async->args.port_stat_get32.stat = stat;
	async->args.port_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_id_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_id_get.unit = unit;
	async->args.port_stat_id_get.port = port;
	async->args.port_stat_id_get.stat = stat;
	async->args.port_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_multi_get_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_get.unit = unit;
	async->args.port_stat_multi_get.port = port;
	async->args.port_stat_multi_get.nstat = nstat;
	async->args.port_stat_multi_get.stat_arr = stat_arr;
	async->args.port_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_multi_get32_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_get32.unit = unit;
	async->args.port_stat_multi_get32.port = port;
	async->args.port_stat_multi_get32.nstat = nstat;
	async->args.port_stat_multi_get32.stat_arr = stat_arr;
	async->args.port_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_multi_set_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_set.unit = unit;
	async->args.port_stat_multi_set.port = port;
	async->args.port_stat_multi_set.nstat = nstat;
	async->args.port_stat_multi_set.stat_arr = stat_arr;
	async->args.port_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_multi_set32_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_set32.unit = unit;
	async->args.port_stat_multi_set32.port = port;
	async->args.port_stat_multi_set32.nstat = nstat;
	async->args.port_stat_multi_set32.stat_arr = stat_arr;
	async->args.port_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_set_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_set.unit = unit;
	async->args.port_stat_set.port = port;
	async->args.port_stat_set.stat = stat;
	async->args.port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_set32.unit = unit;
	async->args.port_stat_set32.port = port;
	async->args.port_stat_set32.stat = stat;
	async->args.port_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_sync_get.unit = unit;
	async->args.port_stat_sync_get.port = port;
	async->args.port_stat_sync_get.stat = stat;
	async->args.port_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stat_sync_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_sync_get32.unit = unit;
	async->args.port_stat_sync_get32.port = port;
	async->args.port_stat_sync_get32.stat = stat;
	async->args.port_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stp_get_async(
	int unit,
	bcm_port_t port,
	int * state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stp_get.unit = unit;
	async->args.port_stp_get.port = port;
	async->args.port_stp_get.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_stp_set_async(
	int unit,
	bcm_port_t port,
	int state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_STP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stp_set.unit = unit;
	async->args.port_stp_set.port = port;
	async->args.port_stp_set.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_subsidiary_ports_get_async(
	int unit,
	bcm_port_t port,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_SUBSIDIARY_PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_subsidiary_ports_get.unit = unit;
	async->args.port_subsidiary_ports_get.port = port;
	async->args.port_subsidiary_ports_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tgid_get_async(
	int unit,
	bcm_port_t port,
	int * tgid,
	int * psc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TGID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tgid_get.unit = unit;
	async->args.port_tgid_get.port = port;
	async->args.port_tgid_get.tgid = tgid;
	async->args.port_tgid_get.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tgid_set_async(
	int unit,
	bcm_port_t port,
	int tgid,
	int psc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TGID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tgid_set.unit = unit;
	async->args.port_tgid_set.port = port;
	async->args.port_tgid_set.tgid = tgid;
	async->args.port_tgid_set.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_timesync_config_get_async(
	int unit,
	bcm_port_t port,
	int array_size,
	bcm_port_timesync_config_t * config_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TIMESYNC_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_timesync_config_get.unit = unit;
	async->args.port_timesync_config_get.port = port;
	async->args.port_timesync_config_get.array_size = array_size;
	async->args.port_timesync_config_get.config_array = config_array;
	async->args.port_timesync_config_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_timesync_config_set_async(
	int unit,
	bcm_port_t port,
	int config_count,
	bcm_port_timesync_config_t * config_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TIMESYNC_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_timesync_config_set.unit = unit;
	async->args.port_timesync_config_set.port = port;
	async->args.port_timesync_config_set.config_count = config_count;
	async->args.port_timesync_config_set.config_array = config_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_add_async(
	int unit,
	bcm_port_t port,
	uint16 tpid,
	int color_select,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_add.unit = unit;
	async->args.port_tpid_add.port = port;
	async->args.port_tpid_add.tpid = tpid;
	async->args.port_tpid_add.color_select = color_select;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_class_get_async(
	int unit,
	bcm_port_tpid_class_t * tpid_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_class_get.unit = unit;
	async->args.port_tpid_class_get.tpid_class = tpid_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_class_set_async(
	int unit,
	bcm_port_tpid_class_t * tpid_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_CLASS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_class_set.unit = unit;
	async->args.port_tpid_class_set.tpid_class = tpid_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_delete_async(
	int unit,
	bcm_port_t port,
	uint16 tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_delete.unit = unit;
	async->args.port_tpid_delete.port = port;
	async->args.port_tpid_delete.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_delete_all_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_delete_all.unit = unit;
	async->args.port_tpid_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_get_async(
	int unit,
	bcm_port_t port,
	uint16 * tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_get.unit = unit;
	async->args.port_tpid_get.port = port;
	async->args.port_tpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_get_all_async(
	int unit,
	bcm_port_t port,
	int size,
	uint16 * tpid_array,
	int * color_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_get_all.unit = unit;
	async->args.port_tpid_get_all.port = port;
	async->args.port_tpid_get_all.size = size;
	async->args.port_tpid_get_all.tpid_array = tpid_array;
	async->args.port_tpid_get_all.color_array = color_array;
	async->args.port_tpid_get_all.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_tpid_set_async(
	int unit,
	bcm_port_t port,
	uint16 tpid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TPID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_set.unit = unit;
	async->args.port_tpid_set.port = port;
	async->args.port_tpid_set.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_trunk_index_get_async(
	int unit,
	bcm_port_t port,
	int * port_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TRUNK_INDEX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_trunk_index_get.unit = unit;
	async->args.port_trunk_index_get.port = port;
	async->args.port_trunk_index_get.port_index = port_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_trunk_index_set_async(
	int unit,
	bcm_port_t port,
	int port_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_TRUNK_INDEX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_trunk_index_set.unit = unit;
	async->args.port_trunk_index_set.port = port;
	async->args.port_trunk_index_set.port_index = port_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_untagged_priority_get_async(
	int unit,
	bcm_port_t port,
	int * priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_priority_get.unit = unit;
	async->args.port_untagged_priority_get.port = port;
	async->args.port_untagged_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_untagged_priority_set_async(
	int unit,
	bcm_port_t port,
	int priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_priority_set.unit = unit;
	async->args.port_untagged_priority_set.port = port;
	async->args.port_untagged_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_untagged_vlan_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t * vid_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_vlan_get.unit = unit;
	async->args.port_untagged_vlan_get.port = port;
	async->args.port_untagged_vlan_get.vid_ptr = vid_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_untagged_vlan_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_vlan_set.unit = unit;
	async->args.port_untagged_vlan_set.port = port;
	async->args.port_untagged_vlan_set.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_update_async(
	int unit,
	bcm_port_t port,
	int link,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_update.unit = unit;
	async->args.port_update.port = port;
	async->args.port_update.link = link;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_dscp_map_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	int dscp,
	int * internal_pri,
	bcm_color_t * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_DSCP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_dscp_map_get.unit = unit;
	async->args.port_vlan_dscp_map_get.port = port;
	async->args.port_vlan_dscp_map_get.vlan = vlan;
	async->args.port_vlan_dscp_map_get.dscp = dscp;
	async->args.port_vlan_dscp_map_get.internal_pri = internal_pri;
	async->args.port_vlan_dscp_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_dscp_map_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	int dscp,
	int internal_pri,
	bcm_color_t color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_DSCP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_dscp_map_set.unit = unit;
	async->args.port_vlan_dscp_map_set.port = port;
	async->args.port_vlan_dscp_map_set.vlan = vlan;
	async->args.port_vlan_dscp_map_set.dscp = dscp;
	async->args.port_vlan_dscp_map_set.internal_pri = internal_pri;
	async->args.port_vlan_dscp_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_inner_tag_get_async(
	int unit,
	bcm_port_t port,
	uint16 * inner_tag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_inner_tag_get.unit = unit;
	async->args.port_vlan_inner_tag_get.port = port;
	async->args.port_vlan_inner_tag_get.inner_tag = inner_tag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_inner_tag_set_async(
	int unit,
	bcm_port_t port,
	uint16 inner_tag,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_inner_tag_set.unit = unit;
	async->args.port_vlan_inner_tag_set.port = port;
	async->args.port_vlan_inner_tag_set.inner_tag = inner_tag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_member_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_MEMBER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_member_get.unit = unit;
	async->args.port_vlan_member_get.port = port;
	async->args.port_vlan_member_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_member_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_MEMBER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_member_set.unit = unit;
	async->args.port_vlan_member_set.port = port;
	async->args.port_vlan_member_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_pri_map_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	int pkt_pri,
	int cfi,
	int * internal_pri,
	bcm_color_t * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRI_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_pri_map_get.unit = unit;
	async->args.port_vlan_pri_map_get.port = port;
	async->args.port_vlan_pri_map_get.vlan = vlan;
	async->args.port_vlan_pri_map_get.pkt_pri = pkt_pri;
	async->args.port_vlan_pri_map_get.cfi = cfi;
	async->args.port_vlan_pri_map_get.internal_pri = internal_pri;
	async->args.port_vlan_pri_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_pri_map_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vlan,
	int pkt_pri,
	int cfi,
	int internal_pri,
	bcm_color_t color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRI_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_pri_map_set.unit = unit;
	async->args.port_vlan_pri_map_set.port = port;
	async->args.port_vlan_pri_map_set.vlan = vlan;
	async->args.port_vlan_pri_map_set.pkt_pri = pkt_pri;
	async->args.port_vlan_pri_map_set.cfi = cfi;
	async->args.port_vlan_pri_map_set.internal_pri = internal_pri;
	async->args.port_vlan_pri_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_map_get_async(
	int unit,
	bcm_port_t port,
	int pkt_pri,
	int cfi,
	int * internal_pri,
	bcm_color_t * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_map_get.unit = unit;
	async->args.port_vlan_priority_map_get.port = port;
	async->args.port_vlan_priority_map_get.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_map_get.cfi = cfi;
	async->args.port_vlan_priority_map_get.internal_pri = internal_pri;
	async->args.port_vlan_priority_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_map_set_async(
	int unit,
	bcm_port_t port,
	int pkt_pri,
	int cfi,
	int internal_pri,
	bcm_color_t color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_map_set.unit = unit;
	async->args.port_vlan_priority_map_set.port = port;
	async->args.port_vlan_priority_map_set.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_map_set.cfi = cfi;
	async->args.port_vlan_priority_map_set.internal_pri = internal_pri;
	async->args.port_vlan_priority_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_mapping_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vid,
	int pkt_pri,
	int cfi,
	bcm_priority_mapping_t * pri_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_mapping_get.unit = unit;
	async->args.port_vlan_priority_mapping_get.port = port;
	async->args.port_vlan_priority_mapping_get.vid = vid;
	async->args.port_vlan_priority_mapping_get.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_mapping_get.cfi = cfi;
	async->args.port_vlan_priority_mapping_get.pri_map = pri_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_mapping_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vid,
	int pkt_pri,
	int cfi,
	bcm_priority_mapping_t * pri_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_mapping_set.unit = unit;
	async->args.port_vlan_priority_mapping_set.port = port;
	async->args.port_vlan_priority_mapping_set.vid = vid;
	async->args.port_vlan_priority_mapping_set.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_mapping_set.cfi = cfi;
	async->args.port_vlan_priority_mapping_set.pri_map = pri_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_unmap_get_async(
	int unit,
	bcm_port_t port,
	int internal_pri,
	bcm_color_t color,
	int * pkt_pri,
	int * cfi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_unmap_get.unit = unit;
	async->args.port_vlan_priority_unmap_get.port = port;
	async->args.port_vlan_priority_unmap_get.internal_pri = internal_pri;
	async->args.port_vlan_priority_unmap_get.color = color;
	async->args.port_vlan_priority_unmap_get.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_unmap_get.cfi = cfi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_priority_unmap_set_async(
	int unit,
	bcm_port_t port,
	int internal_pri,
	bcm_color_t color,
	int pkt_pri,
	int cfi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_unmap_set.unit = unit;
	async->args.port_vlan_priority_unmap_set.port = port;
	async->args.port_vlan_priority_unmap_set.internal_pri = internal_pri;
	async->args.port_vlan_priority_unmap_set.color = color;
	async->args.port_vlan_priority_unmap_set.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_unmap_set.cfi = cfi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_vector_get_async(
	int unit,
	bcm_gport_t port_id,
	bcm_vlan_vector_t vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_VECTOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_vector_get.unit = unit;
	async->args.port_vlan_vector_get.port_id = port_id;
	async->args.port_vlan_vector_get.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_vlan_vector_set_async(
	int unit,
	bcm_gport_t port_id,
	bcm_vlan_vector_t vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_VLAN_VECTOR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_vector_set.unit = unit;
	async->args.port_vlan_vector_set.port_id = port_id;
	async->args.port_vlan_vector_set.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_wide_data_get_async(
	int unit,
	bcm_gport_t gport,
	uint32 flags,
	uint64 * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_WIDE_DATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_wide_data_get.unit = unit;
	async->args.port_wide_data_get.gport = gport;
	async->args.port_wide_data_get.flags = flags;
	async->args.port_wide_data_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_port_wide_data_set_async(
	int unit,
	bcm_gport_t gport,
	uint32 flags,
	uint64 data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PORT_WIDE_DATA_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_wide_data_set.unit = unit;
	async->args.port_wide_data_set.gport = gport;
	async->args.port_wide_data_set.flags = flags;
	async->args.port_wide_data_set.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_proxy_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_client_set_async(
	int unit,
	bcm_port_t client_port,
	bcm_proxy_proto_type_t proto_type,
	bcm_module_t server_modid,
	bcm_port_t server_port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_CLIENT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_client_set.unit = unit;
	async->args.proxy_client_set.client_port = client_port;
	async->args.proxy_client_set.proto_type = proto_type;
	async->args.proxy_client_set.server_modid = server_modid;
	async->args.proxy_client_set.server_port = server_port;
	async->args.proxy_client_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_egress_create_async(
	int unit,
	uint32 flags,
	bcm_proxy_egress_t * proxy_egress,
	bcm_if_t * proxy_if_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_EGRESS_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_egress_create.unit = unit;
	async->args.proxy_egress_create.flags = flags;
	async->args.proxy_egress_create.proxy_egress = proxy_egress;
	async->args.proxy_egress_create.proxy_if_id = proxy_if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_egress_destroy_async(
	int unit,
	bcm_if_t proxy_if_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_EGRESS_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_egress_destroy.unit = unit;
	async->args.proxy_egress_destroy.proxy_if_id = proxy_if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_egress_get_async(
	int unit,
	bcm_if_t proxy_if_id,
	bcm_proxy_egress_t * proxy_egress,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_egress_get.unit = unit;
	async->args.proxy_egress_get.proxy_if_id = proxy_if_id;
	async->args.proxy_egress_get.proxy_egress = proxy_egress;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_egress_traverse_async(
	int unit,
	bcm_proxy_egress_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_EGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_egress_traverse.unit = unit;
	async->args.proxy_egress_traverse.trav_fn = trav_fn;
	async->args.proxy_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_server_get_async(
	int unit,
	bcm_port_t server_port,
	bcm_proxy_mode_t mode,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_SERVER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_get.unit = unit;
	async->args.proxy_server_get.server_port = server_port;
	async->args.proxy_server_get.mode = mode;
	async->args.proxy_server_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_server_port_get_async(
	int unit,
	bcm_gport_t local_ingress_port,
	bcm_proxy_server_t * proxy_server,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_SERVER_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_port_get.unit = unit;
	async->args.proxy_server_port_get.local_ingress_port = local_ingress_port;
	async->args.proxy_server_port_get.proxy_server = proxy_server;
	async->args.proxy_server_port_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_server_port_set_async(
	int unit,
	bcm_gport_t local_ingress_port,
	bcm_proxy_server_t * proxy_server,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_SERVER_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_port_set.unit = unit;
	async->args.proxy_server_port_set.local_ingress_port = local_ingress_port;
	async->args.proxy_server_port_set.proxy_server = proxy_server;
	async->args.proxy_server_port_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_proxy_server_set_async(
	int unit,
	bcm_port_t server_port,
	bcm_proxy_mode_t mode,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PROXY_SERVER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_set.unit = unit;
	async->args.proxy_server_set.server_port = server_port;
	async->args.proxy_server_set.mode = mode;
	async->args.proxy_server_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */
#ifdef	INCLUDE_PSTATS

void
bcm_pstats_data_sync_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_DATA_SYNC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_data_sync.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_create_async(
	int unit,
	int options,
	int array_count,
	bcm_pstats_session_element_t * element_array,
	bcm_pstats_session_id_t * session_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_create.unit = unit;
	async->args.pstats_session_create.options = options;
	async->args.pstats_session_create.array_count = array_count;
	async->args.pstats_session_create.element_array = element_array;
	async->args.pstats_session_create.session_id = session_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_data_clear_async(
	int unit,
	bcm_pstats_session_id_t session_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_DATA_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_data_clear.unit = unit;
	async->args.pstats_session_data_clear.session_id = session_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_data_get_async(
	int unit,
	bcm_pstats_session_id_t session_id,
	bcm_pstats_timestamp_t * timestamp,
	int array_max,
	bcm_pstats_data_t * data_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_DATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_data_get.unit = unit;
	async->args.pstats_session_data_get.session_id = session_id;
	async->args.pstats_session_data_get.timestamp = timestamp;
	async->args.pstats_session_data_get.array_max = array_max;
	async->args.pstats_session_data_get.data_array = data_array;
	async->args.pstats_session_data_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_data_sync_get_async(
	int unit,
	bcm_pstats_session_id_t session_id,
	bcm_pstats_timestamp_t * timestamp,
	int array_max,
	bcm_pstats_data_t * data_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_DATA_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_data_sync_get.unit = unit;
	async->args.pstats_session_data_sync_get.session_id = session_id;
	async->args.pstats_session_data_sync_get.timestamp = timestamp;
	async->args.pstats_session_data_sync_get.array_max = array_max;
	async->args.pstats_session_data_sync_get.data_array = data_array;
	async->args.pstats_session_data_sync_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_destroy_async(
	int unit,
	bcm_pstats_session_id_t session_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_destroy.unit = unit;
	async->args.pstats_session_destroy.session_id = session_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_get_async(
	int unit,
	bcm_pstats_session_id_t session_id,
	int array_max,
	bcm_pstats_session_element_t * element_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_get.unit = unit;
	async->args.pstats_session_get.session_id = session_id;
	async->args.pstats_session_get.array_max = array_max;
	async->args.pstats_session_get.element_array = element_array;
	async->args.pstats_session_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_pstats_session_traverse_async(
	int unit,
	bcm_pstats_session_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PSTATS_SESSION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.pstats_session_traverse.unit = unit;
	async->args.pstats_session_traverse.cb = cb;
	async->args.pstats_session_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_PSTATS */
#ifdef	INCLUDE_PTP

void
bcm_ptp_acceptable_master_add_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int priority1_alt_value,
	bcm_ptp_clock_peer_address_t * master_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_add.unit = unit;
	async->args.ptp_acceptable_master_add.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_add.clock_num = clock_num;
	async->args.ptp_acceptable_master_add.port_num = port_num;
	async->args.ptp_acceptable_master_add.priority1_alt_value = priority1_alt_value;
	async->args.ptp_acceptable_master_add.master_info = master_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_enabled_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint8 * enabled,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_ENABLED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_enabled_get.unit = unit;
	async->args.ptp_acceptable_master_enabled_get.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_enabled_get.clock_num = clock_num;
	async->args.ptp_acceptable_master_enabled_get.port_num = port_num;
	async->args.ptp_acceptable_master_enabled_get.enabled = enabled;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_enabled_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint8 enabled,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_ENABLED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_enabled_set.unit = unit;
	async->args.ptp_acceptable_master_enabled_set.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_enabled_set.clock_num = clock_num;
	async->args.ptp_acceptable_master_enabled_set.port_num = port_num;
	async->args.ptp_acceptable_master_enabled_set.enabled = enabled;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_list_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int max_num_masters,
	int * num_masters,
	bcm_ptp_clock_peer_address_t * master_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_list.unit = unit;
	async->args.ptp_acceptable_master_list.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_list.clock_num = clock_num;
	async->args.ptp_acceptable_master_list.port_num = port_num;
	async->args.ptp_acceptable_master_list.max_num_masters = max_num_masters;
	async->args.ptp_acceptable_master_list.num_masters = num_masters;
	async->args.ptp_acceptable_master_list.master_addr = master_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_peer_address_t * master_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_remove.unit = unit;
	async->args.ptp_acceptable_master_remove.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_remove.clock_num = clock_num;
	async->args.ptp_acceptable_master_remove.port_num = port_num;
	async->args.ptp_acceptable_master_remove.master_info = master_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_table_clear_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_TABLE_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_table_clear.unit = unit;
	async->args.ptp_acceptable_master_table_clear.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_table_clear.clock_num = clock_num;
	async->args.ptp_acceptable_master_table_clear.port_num = port_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_acceptable_master_table_size_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int * max_table_entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_ACCEPTABLE_MASTER_TABLE_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_acceptable_master_table_size_get.unit = unit;
	async->args.ptp_acceptable_master_table_size_get.ptp_id = ptp_id;
	async->args.ptp_acceptable_master_table_size_get.clock_num = clock_num;
	async->args.ptp_acceptable_master_table_size_get.port_num = port_num;
	async->args.ptp_acceptable_master_table_size_get.max_table_entries = max_table_entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_cb_register_async(
	int unit,
	bcm_ptp_cb_types_t cb_types,
	bcm_ptp_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CB_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_cb_register.unit = unit;
	async->args.ptp_cb_register.cb_types = cb_types;
	async->args.ptp_cb_register.cb = cb;
	async->args.ptp_cb_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_cb_unregister_async(
	int unit,
	bcm_ptp_cb_types_t cb_types,
	bcm_ptp_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CB_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_cb_unregister.unit = unit;
	async->args.ptp_cb_unregister.cb_types = cb_types;
	async->args.ptp_cb_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_accuracy_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_accuracy_t * accuracy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_ACCURACY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_accuracy_get.unit = unit;
	async->args.ptp_clock_accuracy_get.ptp_id = ptp_id;
	async->args.ptp_clock_accuracy_get.clock_num = clock_num;
	async->args.ptp_clock_accuracy_get.accuracy = accuracy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_accuracy_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_accuracy_t * accuracy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_ACCURACY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_accuracy_set.unit = unit;
	async->args.ptp_clock_accuracy_set.ptp_id = ptp_id;
	async->args.ptp_clock_accuracy_set.clock_num = clock_num;
	async->args.ptp_clock_accuracy_set.accuracy = accuracy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_create_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	bcm_ptp_clock_info_t * clock_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_create.unit = unit;
	async->args.ptp_clock_create.ptp_id = ptp_id;
	async->args.ptp_clock_create.clock_info = clock_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_current_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_current_dataset_t * dataset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_CURRENT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_current_dataset_get.unit = unit;
	async->args.ptp_clock_current_dataset_get.ptp_id = ptp_id;
	async->args.ptp_clock_current_dataset_get.clock_num = clock_num;
	async->args.ptp_clock_current_dataset_get.dataset = dataset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_default_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_default_dataset_t * dataset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_DEFAULT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_default_dataset_get.unit = unit;
	async->args.ptp_clock_default_dataset_get.ptp_id = ptp_id;
	async->args.ptp_clock_default_dataset_get.clock_num = clock_num;
	async->args.ptp_clock_default_dataset_get.dataset = dataset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_domain_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 * domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_DOMAIN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_domain_get.unit = unit;
	async->args.ptp_clock_domain_get.ptp_id = ptp_id;
	async->args.ptp_clock_domain_get.clock_num = clock_num;
	async->args.ptp_clock_domain_get.domain = domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_domain_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_DOMAIN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_domain_set.unit = unit;
	async->args.ptp_clock_domain_set.ptp_id = ptp_id;
	async->args.ptp_clock_domain_set.clock_num = clock_num;
	async->args.ptp_clock_domain_set.domain = domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_info_t * clock_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_get.unit = unit;
	async->args.ptp_clock_get.ptp_id = ptp_id;
	async->args.ptp_clock_get.clock_num = clock_num;
	async->args.ptp_clock_get.clock_info = clock_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_local_priority_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 * local_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_LOCAL_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_local_priority_get.unit = unit;
	async->args.ptp_clock_local_priority_get.ptp_id = ptp_id;
	async->args.ptp_clock_local_priority_get.clock_num = clock_num;
	async->args.ptp_clock_local_priority_get.local_priority = local_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_local_priority_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 local_priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_LOCAL_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_local_priority_set.unit = unit;
	async->args.ptp_clock_local_priority_set.ptp_id = ptp_id;
	async->args.ptp_clock_local_priority_set.clock_num = clock_num;
	async->args.ptp_clock_local_priority_set.local_priority = local_priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_parent_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_parent_dataset_t * dataset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PARENT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_parent_dataset_get.unit = unit;
	async->args.ptp_clock_parent_dataset_get.ptp_id = ptp_id;
	async->args.ptp_clock_parent_dataset_get.clock_num = clock_num;
	async->args.ptp_clock_parent_dataset_get.dataset = dataset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_announce_receipt_timeout_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 * timeout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_ANNOUNCE_RECEIPT_TIMEOUT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_announce_receipt_timeout_get.unit = unit;
	async->args.ptp_clock_port_announce_receipt_timeout_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_announce_receipt_timeout_get.clock_num = clock_num;
	async->args.ptp_clock_port_announce_receipt_timeout_get.clock_port = clock_port;
	async->args.ptp_clock_port_announce_receipt_timeout_get.timeout = timeout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_announce_receipt_timeout_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 timeout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_ANNOUNCE_RECEIPT_TIMEOUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_announce_receipt_timeout_set.unit = unit;
	async->args.ptp_clock_port_announce_receipt_timeout_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_announce_receipt_timeout_set.clock_num = clock_num;
	async->args.ptp_clock_port_announce_receipt_timeout_set.clock_port = clock_port;
	async->args.ptp_clock_port_announce_receipt_timeout_set.timeout = timeout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_configure_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_clock_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_CONFIGURE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_configure.unit = unit;
	async->args.ptp_clock_port_configure.ptp_id = ptp_id;
	async->args.ptp_clock_port_configure.clock_num = clock_num;
	async->args.ptp_clock_port_configure.clock_port = clock_port;
	async->args.ptp_clock_port_configure.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_port_dataset_t * dataset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_dataset_get.unit = unit;
	async->args.ptp_clock_port_dataset_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_dataset_get.clock_num = clock_num;
	async->args.ptp_clock_port_dataset_get.clock_port = clock_port;
	async->args.ptp_clock_port_dataset_get.dataset = dataset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_delay_mechanism_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 * delay_mechanism,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_DELAY_MECHANISM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_delay_mechanism_get.unit = unit;
	async->args.ptp_clock_port_delay_mechanism_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_delay_mechanism_get.clock_num = clock_num;
	async->args.ptp_clock_port_delay_mechanism_get.clock_port = clock_port;
	async->args.ptp_clock_port_delay_mechanism_get.delay_mechanism = delay_mechanism;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_delay_mechanism_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 delay_mechanism,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_DELAY_MECHANISM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_delay_mechanism_set.unit = unit;
	async->args.ptp_clock_port_delay_mechanism_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_delay_mechanism_set.clock_num = clock_num;
	async->args.ptp_clock_port_delay_mechanism_set.clock_port = clock_port;
	async->args.ptp_clock_port_delay_mechanism_set.delay_mechanism = delay_mechanism;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_disable_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_DISABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_disable.unit = unit;
	async->args.ptp_clock_port_disable.ptp_id = ptp_id;
	async->args.ptp_clock_port_disable.clock_num = clock_num;
	async->args.ptp_clock_port_disable.clock_port = clock_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_enable_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_enable.unit = unit;
	async->args.ptp_clock_port_enable.ptp_id = ptp_id;
	async->args.ptp_clock_port_enable.clock_num = clock_num;
	async->args.ptp_clock_port_enable.clock_port = clock_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_identity_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_port_identity_t * identity,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_IDENTITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_identity_get.unit = unit;
	async->args.ptp_clock_port_identity_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_identity_get.clock_num = clock_num;
	async->args.ptp_clock_port_identity_get.clock_port = clock_port;
	async->args.ptp_clock_port_identity_get.identity = identity;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_info_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_clock_port_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_info_get.unit = unit;
	async->args.ptp_clock_port_info_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_info_get.clock_num = clock_num;
	async->args.ptp_clock_port_info_get.clock_port = clock_port;
	async->args.ptp_clock_port_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_latency_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 latency_in,
	uint32 latency_out,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LATENCY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_latency_set.unit = unit;
	async->args.ptp_clock_port_latency_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_latency_set.clock_num = clock_num;
	async->args.ptp_clock_port_latency_set.clock_port = clock_port;
	async->args.ptp_clock_port_latency_set.latency_in = latency_in;
	async->args.ptp_clock_port_latency_set.latency_out = latency_out;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_announce_interval_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int * interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_ANNOUNCE_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_announce_interval_get.unit = unit;
	async->args.ptp_clock_port_log_announce_interval_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_announce_interval_get.clock_num = clock_num;
	async->args.ptp_clock_port_log_announce_interval_get.clock_port = clock_port;
	async->args.ptp_clock_port_log_announce_interval_get.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_announce_interval_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_ANNOUNCE_INTERVAL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_announce_interval_set.unit = unit;
	async->args.ptp_clock_port_log_announce_interval_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_announce_interval_set.clock_num = clock_num;
	async->args.ptp_clock_port_log_announce_interval_set.clock_port = clock_port;
	async->args.ptp_clock_port_log_announce_interval_set.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_min_delay_req_interval_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int * interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_MIN_DELAY_REQ_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_min_delay_req_interval_get.unit = unit;
	async->args.ptp_clock_port_log_min_delay_req_interval_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_min_delay_req_interval_get.clock_num = clock_num;
	async->args.ptp_clock_port_log_min_delay_req_interval_get.clock_port = clock_port;
	async->args.ptp_clock_port_log_min_delay_req_interval_get.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_min_delay_req_interval_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_MIN_DELAY_REQ_INTERVAL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_min_delay_req_interval_set.unit = unit;
	async->args.ptp_clock_port_log_min_delay_req_interval_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_min_delay_req_interval_set.clock_num = clock_num;
	async->args.ptp_clock_port_log_min_delay_req_interval_set.clock_port = clock_port;
	async->args.ptp_clock_port_log_min_delay_req_interval_set.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_min_pdelay_req_interval_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int * interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_MIN_PDELAY_REQ_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_get.unit = unit;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_get.clock_num = clock_num;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_get.clock_port = clock_port;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_get.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_min_pdelay_req_interval_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_MIN_PDELAY_REQ_INTERVAL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_set.unit = unit;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_set.clock_num = clock_num;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_set.clock_port = clock_port;
	async->args.ptp_clock_port_log_min_pdelay_req_interval_set.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_sync_interval_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int * interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_SYNC_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_sync_interval_get.unit = unit;
	async->args.ptp_clock_port_log_sync_interval_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_sync_interval_get.clock_num = clock_num;
	async->args.ptp_clock_port_log_sync_interval_get.clock_port = clock_port;
	async->args.ptp_clock_port_log_sync_interval_get.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_log_sync_interval_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	int interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_LOG_SYNC_INTERVAL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_log_sync_interval_set.unit = unit;
	async->args.ptp_clock_port_log_sync_interval_set.ptp_id = ptp_id;
	async->args.ptp_clock_port_log_sync_interval_set.clock_num = clock_num;
	async->args.ptp_clock_port_log_sync_interval_set.clock_port = clock_port;
	async->args.ptp_clock_port_log_sync_interval_set.interval = interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_mac_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_mac_get.unit = unit;
	async->args.ptp_clock_port_mac_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_mac_get.clock_num = clock_num;
	async->args.ptp_clock_port_mac_get.clock_port = clock_port;
	async->args.ptp_clock_port_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_protocol_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_protocol_t * protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_PROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_protocol_get.unit = unit;
	async->args.ptp_clock_port_protocol_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_protocol_get.clock_num = clock_num;
	async->args.ptp_clock_port_protocol_get.clock_port = clock_port;
	async->args.ptp_clock_port_protocol_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_type_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	bcm_ptp_port_type_t * type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_type_get.unit = unit;
	async->args.ptp_clock_port_type_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_type_get.clock_num = clock_num;
	async->args.ptp_clock_port_type_get.clock_port = clock_port;
	async->args.ptp_clock_port_type_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_port_version_number_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 clock_port,
	uint32 * version,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PORT_VERSION_NUMBER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_port_version_number_get.unit = unit;
	async->args.ptp_clock_port_version_number_get.ptp_id = ptp_id;
	async->args.ptp_clock_port_version_number_get.clock_num = clock_num;
	async->args.ptp_clock_port_version_number_get.clock_port = clock_port;
	async->args.ptp_clock_port_version_number_get.version = version;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_priority1_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 * priority1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PRIORITY1_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_priority1_get.unit = unit;
	async->args.ptp_clock_priority1_get.ptp_id = ptp_id;
	async->args.ptp_clock_priority1_get.clock_num = clock_num;
	async->args.ptp_clock_priority1_get.priority1 = priority1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_priority1_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 priority1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PRIORITY1_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_priority1_set.unit = unit;
	async->args.ptp_clock_priority1_set.ptp_id = ptp_id;
	async->args.ptp_clock_priority1_set.clock_num = clock_num;
	async->args.ptp_clock_priority1_set.priority1 = priority1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_priority2_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 * priority2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PRIORITY2_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_priority2_get.unit = unit;
	async->args.ptp_clock_priority2_get.ptp_id = ptp_id;
	async->args.ptp_clock_priority2_get.clock_num = clock_num;
	async->args.ptp_clock_priority2_get.priority2 = priority2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_priority2_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 priority2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_PRIORITY2_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_priority2_set.unit = unit;
	async->args.ptp_clock_priority2_set.ptp_id = ptp_id;
	async->args.ptp_clock_priority2_set.clock_num = clock_num;
	async->args.ptp_clock_priority2_set.priority2 = priority2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_quality_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_quality_t * clock_quality,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_QUALITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_quality_get.unit = unit;
	async->args.ptp_clock_quality_get.ptp_id = ptp_id;
	async->args.ptp_clock_quality_get.clock_num = clock_num;
	async->args.ptp_clock_quality_get.clock_quality = clock_quality;
	async->args.ptp_clock_quality_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_quality_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_quality_t clock_quality,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_QUALITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_quality_set.unit = unit;
	async->args.ptp_clock_quality_set.ptp_id = ptp_id;
	async->args.ptp_clock_quality_set.clock_num = clock_num;
	async->args.ptp_clock_quality_set.clock_quality = clock_quality;
	async->args.ptp_clock_quality_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_slaveonly_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 * slaveonly,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_SLAVEONLY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_slaveonly_get.unit = unit;
	async->args.ptp_clock_slaveonly_get.ptp_id = ptp_id;
	async->args.ptp_clock_slaveonly_get.clock_num = clock_num;
	async->args.ptp_clock_slaveonly_get.slaveonly = slaveonly;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_slaveonly_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint32 slaveonly,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_SLAVEONLY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_slaveonly_set.unit = unit;
	async->args.ptp_clock_slaveonly_set.ptp_id = ptp_id;
	async->args.ptp_clock_slaveonly_set.clock_num = clock_num;
	async->args.ptp_clock_slaveonly_set.slaveonly = slaveonly;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_time_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_timestamp_t * time,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TIME_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_time_get.unit = unit;
	async->args.ptp_clock_time_get.ptp_id = ptp_id;
	async->args.ptp_clock_time_get.clock_num = clock_num;
	async->args.ptp_clock_time_get.time = time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_time_properties_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_time_properties_t * data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TIME_PROPERTIES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_time_properties_get.unit = unit;
	async->args.ptp_clock_time_properties_get.ptp_id = ptp_id;
	async->args.ptp_clock_time_properties_get.clock_num = clock_num;
	async->args.ptp_clock_time_properties_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_time_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_timestamp_t * time,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TIME_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_time_set.unit = unit;
	async->args.ptp_clock_time_set.ptp_id = ptp_id;
	async->args.ptp_clock_time_set.clock_num = clock_num;
	async->args.ptp_clock_time_set.time = time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_timescale_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_timescale_t * timescale,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TIMESCALE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_timescale_get.unit = unit;
	async->args.ptp_clock_timescale_get.ptp_id = ptp_id;
	async->args.ptp_clock_timescale_get.clock_num = clock_num;
	async->args.ptp_clock_timescale_get.timescale = timescale;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_timescale_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_timescale_t * timescale,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TIMESCALE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_timescale_set.unit = unit;
	async->args.ptp_clock_timescale_set.ptp_id = ptp_id;
	async->args.ptp_clock_timescale_set.clock_num = clock_num;
	async->args.ptp_clock_timescale_set.timescale = timescale;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_traceability_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_trace_t * trace,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TRACEABILITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_traceability_get.unit = unit;
	async->args.ptp_clock_traceability_get.ptp_id = ptp_id;
	async->args.ptp_clock_traceability_get.clock_num = clock_num;
	async->args.ptp_clock_traceability_get.trace = trace;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_traceability_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_trace_t * trace,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_TRACEABILITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_traceability_set.unit = unit;
	async->args.ptp_clock_traceability_set.ptp_id = ptp_id;
	async->args.ptp_clock_traceability_set.clock_num = clock_num;
	async->args.ptp_clock_traceability_set.trace = trace;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_user_description_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 * desc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_USER_DESCRIPTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_user_description_set.unit = unit;
	async->args.ptp_clock_user_description_set.ptp_id = ptp_id;
	async->args.ptp_clock_user_description_set.clock_num = clock_num;
	async->args.ptp_clock_user_description_set.desc = desc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_utc_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_utc_t * utc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_UTC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_utc_get.unit = unit;
	async->args.ptp_clock_utc_get.ptp_id = ptp_id;
	async->args.ptp_clock_utc_get.clock_num = clock_num;
	async->args.ptp_clock_utc_get.utc = utc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_clock_utc_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_utc_t * utc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CLOCK_UTC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_clock_utc_set.unit = unit;
	async->args.ptp_clock_utc_set.ptp_id = ptp_id;
	async->args.ptp_clock_utc_set.clock_num = clock_num;
	async->args.ptp_clock_utc_set.utc = utc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_alarm_callback_register_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_ctdev_alarm_cb alarm_cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ALARM_CALLBACK_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_alarm_callback_register.unit = unit;
	async->args.ptp_ctdev_alarm_callback_register.ptp_id = ptp_id;
	async->args.ptp_ctdev_alarm_callback_register.clock_num = clock_num;
	async->args.ptp_ctdev_alarm_callback_register.alarm_cb = alarm_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_alarm_callback_unregister_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ALARM_CALLBACK_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_alarm_callback_unregister.unit = unit;
	async->args.ptp_ctdev_alarm_callback_unregister.ptp_id = ptp_id;
	async->args.ptp_ctdev_alarm_callback_unregister.clock_num = clock_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_alpha_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint16 * alpha_numerator,
	uint16 * alpha_denominator,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ALPHA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_alpha_get.unit = unit;
	async->args.ptp_ctdev_alpha_get.ptp_id = ptp_id;
	async->args.ptp_ctdev_alpha_get.clock_num = clock_num;
	async->args.ptp_ctdev_alpha_get.alpha_numerator = alpha_numerator;
	async->args.ptp_ctdev_alpha_get.alpha_denominator = alpha_denominator;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_alpha_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint16 alpha_numerator,
	uint16 alpha_denominator,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ALPHA_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_alpha_set.unit = unit;
	async->args.ptp_ctdev_alpha_set.ptp_id = ptp_id;
	async->args.ptp_ctdev_alpha_set.clock_num = clock_num;
	async->args.ptp_ctdev_alpha_set.alpha_numerator = alpha_numerator;
	async->args.ptp_ctdev_alpha_set.alpha_denominator = alpha_denominator;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_enable_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * enable,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_enable_get.unit = unit;
	async->args.ptp_ctdev_enable_get.ptp_id = ptp_id;
	async->args.ptp_ctdev_enable_get.clock_num = clock_num;
	async->args.ptp_ctdev_enable_get.enable = enable;
	async->args.ptp_ctdev_enable_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_enable_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int enable,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_enable_set.unit = unit;
	async->args.ptp_ctdev_enable_set.ptp_id = ptp_id;
	async->args.ptp_ctdev_enable_set.clock_num = clock_num;
	async->args.ptp_ctdev_enable_set.enable = enable;
	async->args.ptp_ctdev_enable_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_verbose_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * verbose,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_VERBOSE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_verbose_get.unit = unit;
	async->args.ptp_ctdev_verbose_get.ptp_id = ptp_id;
	async->args.ptp_ctdev_verbose_get.clock_num = clock_num;
	async->args.ptp_ctdev_verbose_get.verbose = verbose;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_ctdev_verbose_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int verbose,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_CTDEV_VERBOSE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_ctdev_verbose_set.unit = unit;
	async->args.ptp_ctdev_verbose_set.ptp_id = ptp_id;
	async->args.ptp_ctdev_verbose_set.clock_num = clock_num;
	async->args.ptp_ctdev_verbose_set.verbose = verbose;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_foreign_master_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_foreign_master_dataset_t * data_set,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_FOREIGN_MASTER_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_foreign_master_dataset_get.unit = unit;
	async->args.ptp_foreign_master_dataset_get.ptp_id = ptp_id;
	async->args.ptp_foreign_master_dataset_get.clock_num = clock_num;
	async->args.ptp_foreign_master_dataset_get.port_num = port_num;
	async->args.ptp_foreign_master_dataset_get.data_set = data_set;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_g8275p1_traceability_info_clock_class_map_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_g8275p1_clock_traceability_info_t traceability_info,
	uint8 * clock_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_G8275P1_TRACEABILITY_INFO_CLOCK_CLASS_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_g8275p1_traceability_info_clock_class_map.unit = unit;
	async->args.ptp_g8275p1_traceability_info_clock_class_map.ptp_id = ptp_id;
	async->args.ptp_g8275p1_traceability_info_clock_class_map.clock_num = clock_num;
	async->args.ptp_g8275p1_traceability_info_clock_class_map.traceability_info = traceability_info;
	async->args.ptp_g8275p1_traceability_info_clock_class_map.clock_class = clock_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_input_channel_precedence_mode_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int channel_select_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_INPUT_CHANNEL_PRECEDENCE_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_input_channel_precedence_mode_set.unit = unit;
	async->args.ptp_input_channel_precedence_mode_set.ptp_id = ptp_id;
	async->args.ptp_input_channel_precedence_mode_set.clock_num = clock_num;
	async->args.ptp_input_channel_precedence_mode_set.channel_select_mode = channel_select_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_input_channel_switching_mode_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int channel_switching_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_INPUT_CHANNEL_SWITCHING_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_input_channel_switching_mode_set.unit = unit;
	async->args.ptp_input_channel_switching_mode_set.ptp_id = ptp_id;
	async->args.ptp_input_channel_switching_mode_set.clock_num = clock_num;
	async->args.ptp_input_channel_switching_mode_set.channel_switching_mode = channel_switching_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_input_channels_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * num_channels,
	bcm_ptp_channel_t * channels,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_INPUT_CHANNELS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_input_channels_get.unit = unit;
	async->args.ptp_input_channels_get.ptp_id = ptp_id;
	async->args.ptp_input_channels_get.clock_num = clock_num;
	async->args.ptp_input_channels_get.num_channels = num_channels;
	async->args.ptp_input_channels_get.channels = channels;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_input_channels_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int num_channels,
	bcm_ptp_channel_t * channels,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_INPUT_CHANNELS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_input_channels_set.unit = unit;
	async->args.ptp_input_channels_set.ptp_id = ptp_id;
	async->args.ptp_input_channels_set.clock_num = clock_num;
	async->args.ptp_input_channels_set.num_channels = num_channels;
	async->args.ptp_input_channels_set.channels = channels;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_enable_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * enable,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_enable_get.unit = unit;
	async->args.ptp_modular_enable_get.ptp_id = ptp_id;
	async->args.ptp_modular_enable_get.clock_num = clock_num;
	async->args.ptp_modular_enable_get.enable = enable;
	async->args.ptp_modular_enable_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_enable_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int enable,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_enable_set.unit = unit;
	async->args.ptp_modular_enable_set.ptp_id = ptp_id;
	async->args.ptp_modular_enable_set.clock_num = clock_num;
	async->args.ptp_modular_enable_set.enable = enable;
	async->args.ptp_modular_enable_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_phyts_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * phyts,
	int * framesync_pin,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_PHYTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_phyts_get.unit = unit;
	async->args.ptp_modular_phyts_get.ptp_id = ptp_id;
	async->args.ptp_modular_phyts_get.clock_num = clock_num;
	async->args.ptp_modular_phyts_get.phyts = phyts;
	async->args.ptp_modular_phyts_get.framesync_pin = framesync_pin;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_phyts_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int phyts,
	int framesync_pin,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_PHYTS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_phyts_set.unit = unit;
	async->args.ptp_modular_phyts_set.ptp_id = ptp_id;
	async->args.ptp_modular_phyts_set.clock_num = clock_num;
	async->args.ptp_modular_phyts_set.phyts = phyts;
	async->args.ptp_modular_phyts_set.framesync_pin = framesync_pin;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_portbitmap_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_PORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_portbitmap_get.unit = unit;
	async->args.ptp_modular_portbitmap_get.ptp_id = ptp_id;
	async->args.ptp_modular_portbitmap_get.clock_num = clock_num;
	async->args.ptp_modular_portbitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_portbitmap_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_PORTBITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_portbitmap_set.unit = unit;
	async->args.ptp_modular_portbitmap_set.ptp_id = ptp_id;
	async->args.ptp_modular_portbitmap_set.clock_num = clock_num;
	async->args.ptp_modular_portbitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_verbose_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * verbose,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_VERBOSE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_verbose_get.unit = unit;
	async->args.ptp_modular_verbose_get.ptp_id = ptp_id;
	async->args.ptp_modular_verbose_get.clock_num = clock_num;
	async->args.ptp_modular_verbose_get.verbose = verbose;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_modular_verbose_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int verbose,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_MODULAR_VERBOSE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_modular_verbose_set.unit = unit;
	async->args.ptp_modular_verbose_set.ptp_id = ptp_id;
	async->args.ptp_modular_verbose_set.clock_num = clock_num;
	async->args.ptp_modular_verbose_set.verbose = verbose;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_packet_counters_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_packet_counters_t * counters,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PACKET_COUNTERS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_packet_counters_get.unit = unit;
	async->args.ptp_packet_counters_get.ptp_id = ptp_id;
	async->args.ptp_packet_counters_get.clock_num = clock_num;
	async->args.ptp_packet_counters_get.counters = counters;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_peer_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int max_num_peers,
	bcm_ptp_peer_entry_t * peers,
	int * num_peers,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PEER_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_peer_dataset_get.unit = unit;
	async->args.ptp_peer_dataset_get.ptp_id = ptp_id;
	async->args.ptp_peer_dataset_get.clock_num = clock_num;
	async->args.ptp_peer_dataset_get.port_num = port_num;
	async->args.ptp_peer_dataset_get.max_num_peers = max_num_peers;
	async->args.ptp_peer_dataset_get.peers = peers;
	async->args.ptp_peer_dataset_get.num_peers = num_peers;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_phase_offset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_phase_offset_t * offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PHASE_OFFSET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_phase_offset_get.unit = unit;
	async->args.ptp_phase_offset_get.ptp_id = ptp_id;
	async->args.ptp_phase_offset_get.clock_num = clock_num;
	async->args.ptp_phase_offset_get.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_phase_offset_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	const bcm_ptp_phase_offset_t * offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PHASE_OFFSET_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_phase_offset_set.unit = unit;
	async->args.ptp_phase_offset_set.ptp_id = ptp_id;
	async->args.ptp_phase_offset_set.clock_num = clock_num;
	async->args.ptp_phase_offset_set.offset = (bcm_ptp_phase_offset_t *)offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_primary_domain_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * primary_domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PRIMARY_DOMAIN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_primary_domain_get.unit = unit;
	async->args.ptp_primary_domain_get.ptp_id = ptp_id;
	async->args.ptp_primary_domain_get.clock_num = clock_num;
	async->args.ptp_primary_domain_get.primary_domain = primary_domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_primary_domain_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int primary_domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_PRIMARY_DOMAIN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_primary_domain_set.unit = unit;
	async->args.ptp_primary_domain_set.ptp_id = ptp_id;
	async->args.ptp_primary_domain_set.clock_num = clock_num;
	async->args.ptp_primary_domain_set.primary_domain = primary_domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_servo_configuration_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_servo_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SERVO_CONFIGURATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_servo_configuration_get.unit = unit;
	async->args.ptp_servo_configuration_get.ptp_id = ptp_id;
	async->args.ptp_servo_configuration_get.clock_num = clock_num;
	async->args.ptp_servo_configuration_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_servo_configuration_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_servo_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SERVO_CONFIGURATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_servo_configuration_set.unit = unit;
	async->args.ptp_servo_configuration_set.ptp_id = ptp_id;
	async->args.ptp_servo_configuration_set.clock_num = clock_num;
	async->args.ptp_servo_configuration_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_servo_status_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_servo_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SERVO_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_servo_status_get.unit = unit;
	async->args.ptp_servo_status_get.ptp_id = ptp_id;
	async->args.ptp_servo_status_get.clock_num = clock_num;
	async->args.ptp_servo_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_servo_threshold_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_servo_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SERVO_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_servo_threshold_get.unit = unit;
	async->args.ptp_servo_threshold_get.ptp_id = ptp_id;
	async->args.ptp_servo_threshold_get.clock_num = clock_num;
	async->args.ptp_servo_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_servo_threshold_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_servo_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SERVO_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_servo_threshold_set.unit = unit;
	async->args.ptp_servo_threshold_set.ptp_id = ptp_id;
	async->args.ptp_servo_threshold_set.clock_num = clock_num;
	async->args.ptp_servo_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signal_output_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * signal_output_count,
	bcm_ptp_signal_output_t * signal_output_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNAL_OUTPUT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signal_output_get.unit = unit;
	async->args.ptp_signal_output_get.ptp_id = ptp_id;
	async->args.ptp_signal_output_get.clock_num = clock_num;
	async->args.ptp_signal_output_get.signal_output_count = signal_output_count;
	async->args.ptp_signal_output_get.signal_output_id = signal_output_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signal_output_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int signal_output_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNAL_OUTPUT_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signal_output_remove.unit = unit;
	async->args.ptp_signal_output_remove.ptp_id = ptp_id;
	async->args.ptp_signal_output_remove.clock_num = clock_num;
	async->args.ptp_signal_output_remove.signal_output_id = signal_output_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signal_output_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * signal_output_id,
	bcm_ptp_signal_output_t * output_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNAL_OUTPUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signal_output_set.unit = unit;
	async->args.ptp_signal_output_set.ptp_id = ptp_id;
	async->args.ptp_signal_output_set.clock_num = clock_num;
	async->args.ptp_signal_output_set.signal_output_id = signal_output_id;
	async->args.ptp_signal_output_set.output_info = output_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaled_unicast_master_add_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_unicast_master_t * master_info,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALED_UNICAST_MASTER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaled_unicast_master_add.unit = unit;
	async->args.ptp_signaled_unicast_master_add.ptp_id = ptp_id;
	async->args.ptp_signaled_unicast_master_add.clock_num = clock_num;
	async->args.ptp_signaled_unicast_master_add.port_num = port_num;
	async->args.ptp_signaled_unicast_master_add.master_info = master_info;
	async->args.ptp_signaled_unicast_master_add.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaled_unicast_master_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_peer_address_t * master_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALED_UNICAST_MASTER_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaled_unicast_master_remove.unit = unit;
	async->args.ptp_signaled_unicast_master_remove.ptp_id = ptp_id;
	async->args.ptp_signaled_unicast_master_remove.clock_num = clock_num;
	async->args.ptp_signaled_unicast_master_remove.port_num = port_num;
	async->args.ptp_signaled_unicast_master_remove.master_info = master_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaled_unicast_slave_list_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int max_num_slaves,
	int * num_slaves,
	bcm_ptp_clock_peer_t * slave_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALED_UNICAST_SLAVE_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaled_unicast_slave_list.unit = unit;
	async->args.ptp_signaled_unicast_slave_list.ptp_id = ptp_id;
	async->args.ptp_signaled_unicast_slave_list.clock_num = clock_num;
	async->args.ptp_signaled_unicast_slave_list.port_num = port_num;
	async->args.ptp_signaled_unicast_slave_list.max_num_slaves = max_num_slaves;
	async->args.ptp_signaled_unicast_slave_list.num_slaves = num_slaves;
	async->args.ptp_signaled_unicast_slave_list.slave_info = slave_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaled_unicast_slave_table_clear_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int callstack,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALED_UNICAST_SLAVE_TABLE_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaled_unicast_slave_table_clear.unit = unit;
	async->args.ptp_signaled_unicast_slave_table_clear.ptp_id = ptp_id;
	async->args.ptp_signaled_unicast_slave_table_clear.clock_num = clock_num;
	async->args.ptp_signaled_unicast_slave_table_clear.port_num = port_num;
	async->args.ptp_signaled_unicast_slave_table_clear.callstack = callstack;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaling_arbiter_register_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_signaling_arbiter_t arb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALING_ARBITER_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaling_arbiter_register.unit = unit;
	async->args.ptp_signaling_arbiter_register.ptp_id = ptp_id;
	async->args.ptp_signaling_arbiter_register.clock_num = clock_num;
	async->args.ptp_signaling_arbiter_register.arb = arb;
	async->args.ptp_signaling_arbiter_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_signaling_arbiter_unregister_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SIGNALING_ARBITER_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_signaling_arbiter_unregister.unit = unit;
	async->args.ptp_signaling_arbiter_unregister.ptp_id = ptp_id;
	async->args.ptp_signaling_arbiter_unregister.clock_num = clock_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_stack_create_async(
	int unit,
	bcm_ptp_stack_info_t * ptp_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STACK_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_stack_create.unit = unit;
	async->args.ptp_stack_create.ptp_info = ptp_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_stack_destroy_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STACK_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_stack_destroy.unit = unit;
	async->args.ptp_stack_destroy.ptp_id = ptp_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_stack_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	bcm_ptp_stack_info_t * ptp_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STACK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_stack_get.unit = unit;
	async->args.ptp_stack_get.ptp_id = ptp_id;
	async->args.ptp_stack_get.ptp_info = ptp_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_stack_get_all_async(
	int unit,
	int max_size,
	bcm_ptp_stack_info_t * ptp_info,
	int * no_of_stacks,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STACK_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_stack_get_all.unit = unit;
	async->args.ptp_stack_get_all.max_size = max_size;
	async->args.ptp_stack_get_all.ptp_info = ptp_info;
	async->args.ptp_stack_get_all.no_of_stacks = no_of_stacks;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_master_add_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_unicast_master_t * master_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_MASTER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_master_add.unit = unit;
	async->args.ptp_static_unicast_master_add.ptp_id = ptp_id;
	async->args.ptp_static_unicast_master_add.clock_num = clock_num;
	async->args.ptp_static_unicast_master_add.port_num = port_num;
	async->args.ptp_static_unicast_master_add.master_info = master_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_master_list_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int max_num_masters,
	int * num_masters,
	bcm_ptp_clock_peer_address_t * master_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_MASTER_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_master_list.unit = unit;
	async->args.ptp_static_unicast_master_list.ptp_id = ptp_id;
	async->args.ptp_static_unicast_master_list.clock_num = clock_num;
	async->args.ptp_static_unicast_master_list.port_num = port_num;
	async->args.ptp_static_unicast_master_list.max_num_masters = max_num_masters;
	async->args.ptp_static_unicast_master_list.num_masters = num_masters;
	async->args.ptp_static_unicast_master_list.master_addr = master_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_master_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_peer_address_t * master_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_MASTER_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_master_remove.unit = unit;
	async->args.ptp_static_unicast_master_remove.ptp_id = ptp_id;
	async->args.ptp_static_unicast_master_remove.clock_num = clock_num;
	async->args.ptp_static_unicast_master_remove.port_num = port_num;
	async->args.ptp_static_unicast_master_remove.master_info = master_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_master_table_clear_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_MASTER_TABLE_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_master_table_clear.unit = unit;
	async->args.ptp_static_unicast_master_table_clear.ptp_id = ptp_id;
	async->args.ptp_static_unicast_master_table_clear.clock_num = clock_num;
	async->args.ptp_static_unicast_master_table_clear.port_num = port_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_master_table_size_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int * max_table_entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_MASTER_TABLE_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_master_table_size_get.unit = unit;
	async->args.ptp_static_unicast_master_table_size_get.ptp_id = ptp_id;
	async->args.ptp_static_unicast_master_table_size_get.clock_num = clock_num;
	async->args.ptp_static_unicast_master_table_size_get.port_num = port_num;
	async->args.ptp_static_unicast_master_table_size_get.max_table_entries = max_table_entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_slave_add_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_peer_t * slave_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_SLAVE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_slave_add.unit = unit;
	async->args.ptp_static_unicast_slave_add.ptp_id = ptp_id;
	async->args.ptp_static_unicast_slave_add.clock_num = clock_num;
	async->args.ptp_static_unicast_slave_add.port_num = port_num;
	async->args.ptp_static_unicast_slave_add.slave_info = slave_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_slave_list_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	int max_num_slaves,
	int * num_slaves,
	bcm_ptp_clock_peer_t * slave_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_SLAVE_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_slave_list.unit = unit;
	async->args.ptp_static_unicast_slave_list.ptp_id = ptp_id;
	async->args.ptp_static_unicast_slave_list.clock_num = clock_num;
	async->args.ptp_static_unicast_slave_list.port_num = port_num;
	async->args.ptp_static_unicast_slave_list.max_num_slaves = max_num_slaves;
	async->args.ptp_static_unicast_slave_list.num_slaves = num_slaves;
	async->args.ptp_static_unicast_slave_list.slave_info = slave_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_slave_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_peer_t * slave_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_SLAVE_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_slave_remove.unit = unit;
	async->args.ptp_static_unicast_slave_remove.ptp_id = ptp_id;
	async->args.ptp_static_unicast_slave_remove.clock_num = clock_num;
	async->args.ptp_static_unicast_slave_remove.port_num = port_num;
	async->args.ptp_static_unicast_slave_remove.slave_info = slave_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_static_unicast_slave_table_clear_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_STATIC_UNICAST_SLAVE_TABLE_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_static_unicast_slave_table_clear.unit = unit;
	async->args.ptp_static_unicast_slave_table_clear.ptp_id = ptp_id;
	async->args.ptp_static_unicast_slave_table_clear.clock_num = clock_num;
	async->args.ptp_static_unicast_slave_table_clear.port_num = port_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_sync_phy_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_sync_phy_input_t sync_input,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_SYNC_PHY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_sync_phy.unit = unit;
	async->args.ptp_sync_phy.ptp_id = ptp_id;
	async->args.ptp_sync_phy.clock_num = clock_num;
	async->args.ptp_sync_phy.sync_input = sync_input;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_init_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_init.unit = unit;
	async->args.ptp_telecom_g8265_init.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_init.clock_num = clock_num;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_network_option_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_network_option_t * network_option,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_NETWORK_OPTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_network_option_get.unit = unit;
	async->args.ptp_telecom_g8265_network_option_get.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_network_option_get.clock_num = clock_num;
	async->args.ptp_telecom_g8265_network_option_get.network_option = network_option;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_network_option_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_network_option_t network_option,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_NETWORK_OPTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_network_option_set.unit = unit;
	async->args.ptp_telecom_g8265_network_option_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_network_option_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_network_option_set.network_option = network_option;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_add_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_add.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_add.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_add.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_add.port_num = port_num;
	async->args.ptp_telecom_g8265_packet_master_add.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_best_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_pktmaster_t * pktmaster,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_BEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_best_get.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_best_get.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_best_get.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_best_get.pktmaster = pktmaster;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_clock_port_address_t * address,
	bcm_ptp_telecom_g8265_pktmaster_t * pktmaster,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_get.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_get.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_get.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_get.address = address;
	async->args.ptp_telecom_g8265_packet_master_get.pktmaster = pktmaster;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_list_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int max_master_count,
	int * num_masters,
	int * best_master,
	bcm_ptp_telecom_g8265_pktmaster_t * pktmaster,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_list.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_list.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_list.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_list.max_master_count = max_master_count;
	async->args.ptp_telecom_g8265_packet_master_list.num_masters = num_masters;
	async->args.ptp_telecom_g8265_packet_master_list.best_master = best_master;
	async->args.ptp_telecom_g8265_packet_master_list.pktmaster = pktmaster;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_lockout_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 lockout,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_LOCKOUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_lockout_set.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_lockout_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_lockout_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_lockout_set.lockout = lockout;
	async->args.ptp_telecom_g8265_packet_master_lockout_set.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_non_reversion_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 nonres,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_NON_REVERSION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_non_reversion_set.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_non_reversion_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_non_reversion_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_non_reversion_set.nonres = nonres;
	async->args.ptp_telecom_g8265_packet_master_non_reversion_set.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_priority_override_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint8 override,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_PRIORITY_OVERRIDE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_priority_override.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_priority_override.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_priority_override.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_priority_override.override = override;
	async->args.ptp_telecom_g8265_packet_master_priority_override.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_priority_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint16 priority,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_priority_set.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_priority_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_priority_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_priority_set.priority = priority;
	async->args.ptp_telecom_g8265_packet_master_priority_set.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_remove.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_remove.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_remove.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_remove.port_num = port_num;
	async->args.ptp_telecom_g8265_packet_master_remove.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_packet_master_wait_duration_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint64 wait_sec,
	bcm_ptp_clock_port_address_t * address,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PACKET_MASTER_WAIT_DURATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_packet_master_wait_duration_set.unit = unit;
	async->args.ptp_telecom_g8265_packet_master_wait_duration_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_packet_master_wait_duration_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_packet_master_wait_duration_set.wait_sec = wait_sec;
	async->args.ptp_telecom_g8265_packet_master_wait_duration_set.address = address;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_pktstats_thresholds_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_pktstats_t * thresholds,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PKTSTATS_THRESHOLDS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_pktstats_thresholds_get.unit = unit;
	async->args.ptp_telecom_g8265_pktstats_thresholds_get.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_pktstats_thresholds_get.clock_num = clock_num;
	async->args.ptp_telecom_g8265_pktstats_thresholds_get.thresholds = thresholds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_pktstats_thresholds_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_pktstats_t thresholds,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_PKTSTATS_THRESHOLDS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_pktstats_thresholds_set.unit = unit;
	async->args.ptp_telecom_g8265_pktstats_thresholds_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_pktstats_thresholds_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_pktstats_thresholds_set.thresholds = thresholds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_quality_level_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_telecom_g8265_quality_level_t ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_QUALITY_LEVEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_quality_level_set.unit = unit;
	async->args.ptp_telecom_g8265_quality_level_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_quality_level_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_quality_level_set.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_receipt_timeout_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_message_type_t message_type,
	uint32 * receipt_timeout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_RECEIPT_TIMEOUT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_receipt_timeout_get.unit = unit;
	async->args.ptp_telecom_g8265_receipt_timeout_get.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_receipt_timeout_get.clock_num = clock_num;
	async->args.ptp_telecom_g8265_receipt_timeout_get.message_type = message_type;
	async->args.ptp_telecom_g8265_receipt_timeout_get.receipt_timeout = receipt_timeout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_receipt_timeout_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_message_type_t message_type,
	uint32 receipt_timeout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_RECEIPT_TIMEOUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_receipt_timeout_set.unit = unit;
	async->args.ptp_telecom_g8265_receipt_timeout_set.ptp_id = ptp_id;
	async->args.ptp_telecom_g8265_receipt_timeout_set.clock_num = clock_num;
	async->args.ptp_telecom_g8265_receipt_timeout_set.message_type = message_type;
	async->args.ptp_telecom_g8265_receipt_timeout_set.receipt_timeout = receipt_timeout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_telecom_g8265_shutdown_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TELECOM_G8265_SHUTDOWN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_telecom_g8265_shutdown.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_time_format_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	bcm_ptp_time_type_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TIME_FORMAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_time_format_set.unit = unit;
	async->args.ptp_time_format_set.ptp_id = ptp_id;
	async->args.ptp_time_format_set.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_timesource_input_status_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_timesource_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TIMESOURCE_INPUT_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_timesource_input_status_get.unit = unit;
	async->args.ptp_timesource_input_status_get.ptp_id = ptp_id;
	async->args.ptp_timesource_input_status_get.clock_num = clock_num;
	async->args.ptp_timesource_input_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_tod_input_sources_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * num_tod_sources,
	bcm_ptp_tod_input_t * tod_sources,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TOD_INPUT_SOURCES_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_tod_input_sources_get.unit = unit;
	async->args.ptp_tod_input_sources_get.ptp_id = ptp_id;
	async->args.ptp_tod_input_sources_get.clock_num = clock_num;
	async->args.ptp_tod_input_sources_get.num_tod_sources = num_tod_sources;
	async->args.ptp_tod_input_sources_get.tod_sources = tod_sources;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_tod_input_sources_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int num_tod_sources,
	bcm_ptp_tod_input_t * tod_sources,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TOD_INPUT_SOURCES_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_tod_input_sources_set.unit = unit;
	async->args.ptp_tod_input_sources_set.ptp_id = ptp_id;
	async->args.ptp_tod_input_sources_set.clock_num = clock_num;
	async->args.ptp_tod_input_sources_set.num_tod_sources = num_tod_sources;
	async->args.ptp_tod_input_sources_set.tod_sources = tod_sources;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_tod_output_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * tod_output_count,
	bcm_ptp_tod_output_t * tod_output,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TOD_OUTPUT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_tod_output_get.unit = unit;
	async->args.ptp_tod_output_get.ptp_id = ptp_id;
	async->args.ptp_tod_output_get.clock_num = clock_num;
	async->args.ptp_tod_output_get.tod_output_count = tod_output_count;
	async->args.ptp_tod_output_get.tod_output = tod_output;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_tod_output_remove_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int tod_output_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TOD_OUTPUT_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_tod_output_remove.unit = unit;
	async->args.ptp_tod_output_remove.ptp_id = ptp_id;
	async->args.ptp_tod_output_remove.clock_num = clock_num;
	async->args.ptp_tod_output_remove.tod_output_id = tod_output_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_tod_output_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int * tod_output_id,
	bcm_ptp_tod_output_t * output_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TOD_OUTPUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_tod_output_set.unit = unit;
	async->args.ptp_tod_output_set.ptp_id = ptp_id;
	async->args.ptp_tod_output_set.clock_num = clock_num;
	async->args.ptp_tod_output_set.tod_output_id = tod_output_id;
	async->args.ptp_tod_output_set.output_info = output_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_transparent_clock_default_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	bcm_ptp_transparent_clock_default_dataset_t * data_set,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TRANSPARENT_CLOCK_DEFAULT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_transparent_clock_default_dataset_get.unit = unit;
	async->args.ptp_transparent_clock_default_dataset_get.ptp_id = ptp_id;
	async->args.ptp_transparent_clock_default_dataset_get.clock_num = clock_num;
	async->args.ptp_transparent_clock_default_dataset_get.data_set = data_set;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_transparent_clock_port_dataset_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	uint16 clock_port,
	bcm_ptp_transparent_clock_port_dataset_t * data_set,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_TRANSPARENT_CLOCK_PORT_DATASET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_transparent_clock_port_dataset_get.unit = unit;
	async->args.ptp_transparent_clock_port_dataset_get.ptp_id = ptp_id;
	async->args.ptp_transparent_clock_port_dataset_get.clock_num = clock_num;
	async->args.ptp_transparent_clock_port_dataset_get.clock_port = clock_port;
	async->args.ptp_transparent_clock_port_dataset_get.data_set = data_set;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 * duration,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_get.unit = unit;
	async->args.ptp_unicast_request_duration_get.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_get.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_get.port_num = port_num;
	async->args.ptp_unicast_request_duration_get.duration = duration;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_max_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 * duration_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_max_get.unit = unit;
	async->args.ptp_unicast_request_duration_max_get.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_max_get.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_max_get.port_num = port_num;
	async->args.ptp_unicast_request_duration_max_get.duration_max = duration_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_max_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 duration_max,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_MAX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_max_set.unit = unit;
	async->args.ptp_unicast_request_duration_max_set.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_max_set.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_max_set.port_num = port_num;
	async->args.ptp_unicast_request_duration_max_set.duration_max = duration_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_min_get_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 * duration_min,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_MIN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_min_get.unit = unit;
	async->args.ptp_unicast_request_duration_min_get.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_min_get.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_min_get.port_num = port_num;
	async->args.ptp_unicast_request_duration_min_get.duration_min = duration_min;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_min_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 duration_min,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_MIN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_min_set.unit = unit;
	async->args.ptp_unicast_request_duration_min_set.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_min_set.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_min_set.port_num = port_num;
	async->args.ptp_unicast_request_duration_min_set.duration_min = duration_min;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_ptp_unicast_request_duration_set_async(
	int unit,
	bcm_ptp_stack_id_t ptp_id,
	int clock_num,
	int port_num,
	uint32 duration,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_PTP_UNICAST_REQUEST_DURATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ptp_unicast_request_duration_set.unit = unit;
	async->args.ptp_unicast_request_duration_set.ptp_id = ptp_id;
	async->args.ptp_unicast_request_duration_set.clock_num = clock_num;
	async->args.ptp_unicast_request_duration_set.port_num = port_num;
	async->args.ptp_unicast_request_duration_set.duration = duration;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_PTP */

void
bcm_qos_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_map_add_async(
	int unit,
	uint32 flags,
	bcm_qos_map_t * map,
	int map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MAP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_add.unit = unit;
	async->args.qos_map_add.flags = flags;
	async->args.qos_map_add.map = map;
	async->args.qos_map_add.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_map_create_async(
	int unit,
	uint32 flags,
	int * map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_create.unit = unit;
	async->args.qos_map_create.flags = flags;
	async->args.qos_map_create.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_map_delete_async(
	int unit,
	uint32 flags,
	bcm_qos_map_t * map,
	int map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MAP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_delete.unit = unit;
	async->args.qos_map_delete.flags = flags;
	async->args.qos_map_delete.map = map;
	async->args.qos_map_delete.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_map_destroy_async(
	int unit,
	int map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_destroy.unit = unit;
	async->args.qos_map_destroy.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_map_multi_get_async(
	int unit,
	uint32 flags,
	int map_id,
	int array_size,
	bcm_qos_map_t * array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MAP_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_multi_get.unit = unit;
	async->args.qos_map_multi_get.flags = flags;
	async->args.qos_map_multi_get.map_id = map_id;
	async->args.qos_map_multi_get.array_size = array_size;
	async->args.qos_map_multi_get.array = array;
	async->args.qos_map_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_multi_get_async(
	int unit,
	int array_size,
	int * map_ids_array,
	int * flags_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_multi_get.unit = unit;
	async->args.qos_multi_get.array_size = array_size;
	async->args.qos_multi_get.map_ids_array = map_ids_array;
	async->args.qos_multi_get.flags_array = flags_array;
	async->args.qos_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_port_map_get_async(
	int unit,
	bcm_gport_t port,
	int * ing_map,
	int * egr_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_PORT_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_map_get.unit = unit;
	async->args.qos_port_map_get.port = port;
	async->args.qos_port_map_get.ing_map = ing_map;
	async->args.qos_port_map_get.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_port_map_set_async(
	int unit,
	bcm_gport_t port,
	int ing_map,
	int egr_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_PORT_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_map_set.unit = unit;
	async->args.qos_port_map_set.port = port;
	async->args.qos_port_map_set.ing_map = ing_map;
	async->args.qos_port_map_set.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_port_map_type_get_async(
	int unit,
	bcm_gport_t port,
	uint32 flags,
	int * map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_PORT_MAP_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_map_type_get.unit = unit;
	async->args.qos_port_map_type_get.port = port;
	async->args.qos_port_map_type_get.flags = flags;
	async->args.qos_port_map_type_get.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_port_vlan_map_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vid,
	int * ing_map,
	int * egr_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_PORT_VLAN_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_vlan_map_get.unit = unit;
	async->args.qos_port_vlan_map_get.port = port;
	async->args.qos_port_vlan_map_get.vid = vid;
	async->args.qos_port_vlan_map_get.ing_map = ing_map;
	async->args.qos_port_vlan_map_get.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_qos_port_vlan_map_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_t vid,
	int ing_map,
	int egr_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_QOS_PORT_VLAN_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_vlan_map_set.unit = unit;
	async->args.qos_port_vlan_map_set.port = port;
	async->args.qos_port_vlan_map_set.vid = vid;
	async->args.qos_port_vlan_map_set.ing_map = ing_map;
	async->args.qos_port_vlan_map_set.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_create_async(
	int unit,
	int flags,
	bcm_range_config_t * range_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_create.unit = unit;
	async->args.range_create.flags = flags;
	async->args.range_create.range_cfg = range_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_destroy_async(
	int unit,
	bcm_range_t rid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_destroy.unit = unit;
	async->args.range_destroy.rid = rid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_get_async(
	int unit,
	bcm_range_config_t * range_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_get.unit = unit;
	async->args.range_get.range_cfg = range_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_oper_mode_get_async(
	int unit,
	bcm_range_oper_mode_t * oper_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_OPER_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_oper_mode_get.unit = unit;
	async->args.range_oper_mode_get.oper_mode = oper_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_oper_mode_set_async(
	int unit,
	bcm_range_oper_mode_t oper_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_OPER_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_oper_mode_set.unit = unit;
	async->args.range_oper_mode_set.oper_mode = oper_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_range_traverse_async(
	int unit,
	bcm_range_traverse_cb callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RANGE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.range_traverse.unit = unit;
	async->args.range_traverse.callback = callback;
	async->args.range_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_bandwidth_get_async(
	int unit,
	bcm_port_t port,
	int flags,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bandwidth_get.unit = unit;
	async->args.rate_bandwidth_get.port = port;
	async->args.rate_bandwidth_get.flags = flags;
	async->args.rate_bandwidth_get.kbits_sec = kbits_sec;
	async->args.rate_bandwidth_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_bandwidth_set_async(
	int unit,
	bcm_port_t port,
	int flags,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bandwidth_set.unit = unit;
	async->args.rate_bandwidth_set.port = port;
	async->args.rate_bandwidth_set.flags = flags;
	async->args.rate_bandwidth_set.kbits_sec = kbits_sec;
	async->args.rate_bandwidth_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_bcast_get_async(
	int unit,
	int * pps,
	int * flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_BCAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bcast_get.unit = unit;
	async->args.rate_bcast_get.pps = pps;
	async->args.rate_bcast_get.flags = flags;
	async->args.rate_bcast_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_bcast_set_async(
	int unit,
	int pps,
	int flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_BCAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bcast_set.unit = unit;
	async->args.rate_bcast_set.pps = pps;
	async->args.rate_bcast_set.flags = flags;
	async->args.rate_bcast_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_dlfbc_get_async(
	int unit,
	int * pps,
	int * flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_DLFBC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_dlfbc_get.unit = unit;
	async->args.rate_dlfbc_get.pps = pps;
	async->args.rate_dlfbc_get.flags = flags;
	async->args.rate_dlfbc_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_dlfbc_set_async(
	int unit,
	int pps,
	int flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_DLFBC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_dlfbc_set.unit = unit;
	async->args.rate_dlfbc_set.pps = pps;
	async->args.rate_dlfbc_set.flags = flags;
	async->args.rate_dlfbc_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_get_async(
	int unit,
	int * pps,
	int * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_get.unit = unit;
	async->args.rate_get.pps = pps;
	async->args.rate_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_mcast_get_async(
	int unit,
	int * pps,
	int * flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_MCAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_mcast_get.unit = unit;
	async->args.rate_mcast_get.pps = pps;
	async->args.rate_mcast_get.flags = flags;
	async->args.rate_mcast_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_mcast_set_async(
	int unit,
	int pps,
	int flags,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_MCAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_mcast_set.unit = unit;
	async->args.rate_mcast_set.pps = pps;
	async->args.rate_mcast_set.flags = flags;
	async->args.rate_mcast_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_packet_get_async(
	int unit,
	bcm_port_t port,
	bcm_rate_packet_t * pkt_rate,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_PACKET_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_packet_get.unit = unit;
	async->args.rate_packet_get.port = port;
	async->args.rate_packet_get.pkt_rate = pkt_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_packet_set_async(
	int unit,
	bcm_port_t port,
	bcm_rate_packet_t * pkt_rate,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_PACKET_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_packet_set.unit = unit;
	async->args.rate_packet_set.port = port;
	async->args.rate_packet_set.pkt_rate = pkt_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_set_async(
	int unit,
	int pps,
	int flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_set.unit = unit;
	async->args.rate_set.pps = pps;
	async->args.rate_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_type_get_async(
	int unit,
	bcm_rate_limit_t * rl,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_type_get.unit = unit;
	async->args.rate_type_get.rl = rl;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rate_type_set_async(
	int unit,
	bcm_rate_limit_t * rl,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RATE_TYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_type_set.unit = unit;
	async->args.rate_type_set.rl = rl;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_REGEX

void
bcm_regex_config_get_async(
	int unit,
	bcm_regex_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_config_get.unit = unit;
	async->args.regex_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_config_set_async(
	int unit,
	bcm_regex_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_config_set.unit = unit;
	async->args.regex_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_engine_create_async(
	int unit,
	bcm_regex_engine_config_t * config,
	bcm_regex_engine_t * engid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_ENGINE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_engine_create.unit = unit;
	async->args.regex_engine_create.config = config;
	async->args.regex_engine_create.engid = engid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_engine_destroy_async(
	int unit,
	bcm_regex_engine_t engid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_ENGINE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_engine_destroy.unit = unit;
	async->args.regex_engine_destroy.engid = engid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_engine_get_async(
	int unit,
	bcm_regex_engine_t engid,
	bcm_regex_engine_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_ENGINE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_engine_get.unit = unit;
	async->args.regex_engine_get.engid = engid;
	async->args.regex_engine_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_engine_info_get_async(
	int unit,
	int engine_id,
	bcm_regex_engine_info_t * regex_engine_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_ENGINE_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_engine_info_get.unit = unit;
	async->args.regex_engine_info_get.engine_id = engine_id;
	async->args.regex_engine_info_get.regex_engine_info = regex_engine_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_engine_traverse_async(
	int unit,
	bcm_regex_engine_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_ENGINE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_engine_traverse.unit = unit;
	async->args.regex_engine_traverse.cb = cb;
	async->args.regex_engine_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_exclude_add_async(
	int unit,
	uint8 protocol,
	uint16 l4_start,
	uint16 l4_end,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_EXCLUDE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_exclude_add.unit = unit;
	async->args.regex_exclude_add.protocol = protocol;
	async->args.regex_exclude_add.l4_start = l4_start;
	async->args.regex_exclude_add.l4_end = l4_end;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_exclude_delete_async(
	int unit,
	uint8 protocol,
	uint16 l4_start,
	uint16 l4_end,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_EXCLUDE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_exclude_delete.unit = unit;
	async->args.regex_exclude_delete.protocol = protocol;
	async->args.regex_exclude_delete.l4_start = l4_start;
	async->args.regex_exclude_delete.l4_end = l4_end;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_exclude_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_EXCLUDE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_exclude_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_exclude_get_async(
	int unit,
	int array_size,
	uint8 * protocol,
	uint16 * l4low,
	uint16 * l4high,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_EXCLUDE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_exclude_get.unit = unit;
	async->args.regex_exclude_get.array_size = array_size;
	async->args.regex_exclude_get.protocol = protocol;
	async->args.regex_exclude_get.l4low = l4low;
	async->args.regex_exclude_get.l4high = l4high;
	async->args.regex_exclude_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_get_match_id_async(
	int unit,
	int signature_id,
	int * match_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_GET_MATCH_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_get_match_id.unit = unit;
	async->args.regex_get_match_id.signature_id = signature_id;
	async->args.regex_get_match_id.match_id = match_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_get_sig_id_async(
	int unit,
	int match_id,
	int * signature_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_GET_SIG_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_get_sig_id.unit = unit;
	async->args.regex_get_sig_id.match_id = match_id;
	async->args.regex_get_sig_id.signature_id = signature_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_info_get_async(
	int unit,
	bcm_regex_info_t * regex_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_info_get.unit = unit;
	async->args.regex_info_get.regex_info = regex_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_match_check_async(
	int unit,
	bcm_regex_match_t * matches,
	int count,
	int * metric,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_MATCH_CHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_match_check.unit = unit;
	async->args.regex_match_check.matches = matches;
	async->args.regex_match_check.count = count;
	async->args.regex_match_check.metric = metric;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_match_set_async(
	int unit,
	bcm_regex_engine_t engid,
	bcm_regex_match_t * matches,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_MATCH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_match_set.unit = unit;
	async->args.regex_match_set.engid = engid;
	async->args.regex_match_set.matches = matches;
	async->args.regex_match_set.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_add_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_add.unit = unit;
	async->args.regex_policy_action_add.policy = policy;
	async->args.regex_policy_action_add.action = action;
	async->args.regex_policy_action_add.param0 = param0;
	async->args.regex_policy_action_add.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_delete_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_delete.unit = unit;
	async->args.regex_policy_action_delete.policy = policy;
	async->args.regex_policy_action_delete.action = action;
	async->args.regex_policy_action_delete.param0 = param0;
	async->args.regex_policy_action_delete.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_get_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	uint32 * param0,
	uint32 * param1,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_get.unit = unit;
	async->args.regex_policy_action_get.policy = policy;
	async->args.regex_policy_action_get.action = action;
	async->args.regex_policy_action_get.param0 = param0;
	async->args.regex_policy_action_get.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_mac_add_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_MAC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_mac_add.unit = unit;
	async->args.regex_policy_action_mac_add.policy = policy;
	async->args.regex_policy_action_mac_add.action = action;
	async->args.regex_policy_action_mac_add.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_mac_get_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_mac_get.unit = unit;
	async->args.regex_policy_action_mac_get.policy = policy;
	async->args.regex_policy_action_mac_get.action = action;
	async->args.regex_policy_action_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_ports_add_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_PORTS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_ports_add.unit = unit;
	async->args.regex_policy_action_ports_add.policy = policy;
	async->args.regex_policy_action_ports_add.action = action;
	async->args.regex_policy_action_ports_add.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_ports_get_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_PORTS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_ports_get.unit = unit;
	async->args.regex_policy_action_ports_get.policy = policy;
	async->args.regex_policy_action_ports_get.action = action;
	async->args.regex_policy_action_ports_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_remove_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_field_action_t action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_remove.unit = unit;
	async->args.regex_policy_action_remove.policy = policy;
	async->args.regex_policy_action_remove.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_action_remove_all_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_ACTION_REMOVE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_action_remove_all.unit = unit;
	async->args.regex_policy_action_remove_all.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_create_async(
	int unit,
	int flags,
	bcm_regex_policy_t * policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_create.unit = unit;
	async->args.regex_policy_create.flags = flags;
	async->args.regex_policy_create.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_destroy_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_destroy.unit = unit;
	async->args.regex_policy_destroy.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_install_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_INSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_install.unit = unit;
	async->args.regex_policy_install.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_policer_attach_async(
	int unit,
	bcm_regex_policy_t policy,
	int level,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_POLICER_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_policer_attach.unit = unit;
	async->args.regex_policy_policer_attach.policy = policy;
	async->args.regex_policy_policer_attach.level = level;
	async->args.regex_policy_policer_attach.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_policer_detach_async(
	int unit,
	bcm_regex_policy_t policy,
	int level,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_POLICER_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_policer_detach.unit = unit;
	async->args.regex_policy_policer_detach.policy = policy;
	async->args.regex_policy_policer_detach.level = level;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_policer_detach_all_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_POLICER_DETACH_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_policer_detach_all.unit = unit;
	async->args.regex_policy_policer_detach_all.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_policer_get_async(
	int unit,
	bcm_regex_policy_t policy,
	int level,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_policer_get.unit = unit;
	async->args.regex_policy_policer_get.policy = policy;
	async->args.regex_policy_policer_get.level = level;
	async->args.regex_policy_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_remove_async(
	int unit,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_remove.unit = unit;
	async->args.regex_policy_remove.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_stat_attach_async(
	int unit,
	bcm_regex_policy_t policy,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_stat_attach.unit = unit;
	async->args.regex_policy_stat_attach.policy = policy;
	async->args.regex_policy_stat_attach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_stat_detach_async(
	int unit,
	bcm_regex_policy_t policy,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_stat_detach.unit = unit;
	async->args.regex_policy_stat_detach.policy = policy;
	async->args.regex_policy_stat_detach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_policy_stat_get_async(
	int unit,
	bcm_regex_policy_t policy,
	int * stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_POLICY_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_policy_stat_get.unit = unit;
	async->args.regex_policy_stat_get.policy = policy;
	async->args.regex_policy_stat_get.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_report_register_async(
	int unit,
	uint32 reports,
	bcm_regex_report_cb callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_REPORT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_report_register.unit = unit;
	async->args.regex_report_register.reports = reports;
	async->args.regex_report_register.callback = callback;
	async->args.regex_report_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_report_unregister_async(
	int unit,
	uint32 reports,
	bcm_regex_report_cb callback,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_REPORT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_report_unregister.unit = unit;
	async->args.regex_report_unregister.reports = reports;
	async->args.regex_report_unregister.callback = callback;
	async->args.regex_report_unregister.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_add_async(
	int unit,
	int flags,
	bcm_regex_session_key_t * key,
	bcm_regex_session_t * session,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_add.unit = unit;
	async->args.regex_session_add.flags = flags;
	async->args.regex_session_add.key = key;
	async->args.regex_session_add.session = session;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_delete_async(
	int unit,
	bcm_regex_session_key_t * key,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_delete.unit = unit;
	async->args.regex_session_delete.key = key;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_get_async(
	int unit,
	int flags,
	bcm_regex_session_key_t * key,
	bcm_regex_session_t * session,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_get.unit = unit;
	async->args.regex_session_get.flags = flags;
	async->args.regex_session_get.key = key;
	async->args.regex_session_get.session = session;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_policy_update_async(
	int unit,
	int flags,
	int flow_index,
	bcm_regex_policy_t policy,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_POLICY_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_policy_update.unit = unit;
	async->args.regex_session_policy_update.flags = flags;
	async->args.regex_session_policy_update.flow_index = flow_index;
	async->args.regex_session_policy_update.policy = policy;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_session_traverse_async(
	int unit,
	int flags,
	bcm_regex_session_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_SESSION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_session_traverse.unit = unit;
	async->args.regex_session_traverse.flags = flags;
	async->args.regex_session_traverse.cb = cb;
	async->args.regex_session_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_stat_create_async(
	int unit,
	int flags,
	int nstat,
	bcm_field_stat_t * stat_arr,
	int * stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_STAT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_stat_create.unit = unit;
	async->args.regex_stat_create.flags = flags;
	async->args.regex_stat_create.nstat = nstat;
	async->args.regex_stat_create.stat_arr = stat_arr;
	async->args.regex_stat_create.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_stat_destroy_async(
	int unit,
	int stat_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_STAT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_stat_destroy.unit = unit;
	async->args.regex_stat_destroy.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_stat_get_async(
	int unit,
	bcm_regex_stat_t type,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_stat_get.unit = unit;
	async->args.regex_stat_get.type = type;
	async->args.regex_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_regex_stat_set_async(
	int unit,
	bcm_regex_stat_t type,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_REGEX_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.regex_stat_set.unit = unit;
	async->args.regex_stat_set.type = type;
	async->args.regex_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_REGEX */

void
bcm_rx_CopyToCpu_config_add_async(
	int unit,
	uint32 options,
	bcm_rx_CopyToCpu_config_t * copyToCpu_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COPYTOCPU_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_CopyToCpu_config_add.unit = unit;
	async->args.rx_CopyToCpu_config_add.options = options;
	async->args.rx_CopyToCpu_config_add.copyToCpu_config = copyToCpu_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_CopyToCpu_config_delete_async(
	int unit,
	int index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COPYTOCPU_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_CopyToCpu_config_delete.unit = unit;
	async->args.rx_CopyToCpu_config_delete.index = index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_CopyToCpu_config_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COPYTOCPU_CONFIG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_CopyToCpu_config_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_CopyToCpu_config_get_async(
	int unit,
	int index,
	bcm_rx_CopyToCpu_config_t * copyToCpu_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COPYTOCPU_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_CopyToCpu_config_get.unit = unit;
	async->args.rx_CopyToCpu_config_get.index = index;
	async->args.rx_CopyToCpu_config_get.copyToCpu_config = copyToCpu_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_CopyToCpu_config_get_all_async(
	int unit,
	int entries_max,
	bcm_rx_CopyToCpu_config_t * copyToCpu_config,
	int * entries_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COPYTOCPU_CONFIG_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_CopyToCpu_config_get_all.unit = unit;
	async->args.rx_CopyToCpu_config_get_all.entries_max = entries_max;
	async->args.rx_CopyToCpu_config_get_all.copyToCpu_config = copyToCpu_config;
	async->args.rx_CopyToCpu_config_get_all.entries_count = entries_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_active_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_ACTIVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_active.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_alloc_async(
	int unit,
	int pkt_size,
	uint32 flags,
	void ** buf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_alloc.unit = unit;
	async->args.rx_alloc.pkt_size = pkt_size;
	async->args.rx_alloc.flags = flags;
	async->args.rx_alloc.buf = (void * *)buf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_burst_get_async(
	int unit,
	int * burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_BURST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_burst_get.unit = unit;
	async->args.rx_burst_get.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_burst_set_async(
	int unit,
	int burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_BURST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_burst_set.unit = unit;
	async->args.rx_burst_set.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cfg_get_async(
	int unit,
	bcm_rx_cfg_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CFG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cfg_get.unit = unit;
	async->args.rx_cfg_get.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cfg_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CFG_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cfg_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_channels_running_async(
	int unit,
	uint32 * channels,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CHANNELS_RUNNING;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_channels_running.unit = unit;
	async->args.rx_channels_running.channels = channels;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_clear_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_clear.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_control_get_async(
	int unit,
	bcm_rx_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_control_get.unit = unit;
	async->args.rx_control_get.type = type;
	async->args.rx_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_control_set_async(
	int unit,
	bcm_rx_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_control_set.unit = unit;
	async->args.rx_control_set.type = type;
	async->args.rx_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_burst_get_async(
	int unit,
	int cos,
	int * burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_BURST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_burst_get.unit = unit;
	async->args.rx_cos_burst_get.cos = cos;
	async->args.rx_cos_burst_get.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_burst_set_async(
	int unit,
	int cos,
	int burst,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_BURST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_burst_set.unit = unit;
	async->args.rx_cos_burst_set.cos = cos;
	async->args.rx_cos_burst_set.burst = burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_max_len_get_async(
	int unit,
	int cos,
	int * max_q_len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_MAX_LEN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_max_len_get.unit = unit;
	async->args.rx_cos_max_len_get.cos = cos;
	async->args.rx_cos_max_len_get.max_q_len = max_q_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_max_len_set_async(
	int unit,
	int cos,
	int max_q_len,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_MAX_LEN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_max_len_set.unit = unit;
	async->args.rx_cos_max_len_set.cos = cos;
	async->args.rx_cos_max_len_set.max_q_len = max_q_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_rate_get_async(
	int unit,
	int cos,
	int * pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_rate_get.unit = unit;
	async->args.rx_cos_rate_get.cos = cos;
	async->args.rx_cos_rate_get.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cos_rate_set_async(
	int unit,
	int cos,
	int pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COS_RATE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cos_rate_set.unit = unit;
	async->args.rx_cos_rate_set.cos = cos;
	async->args.rx_cos_rate_set.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_delete_async(
	int unit,
	int index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_delete.unit = unit;
	async->args.rx_cosq_mapping_delete.index = index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_extended_get_async(
	int unit,
	bcm_rx_cosq_mapping_t * rx_cosq_mapping,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_EXTENDED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_extended_get.unit = unit;
	async->args.rx_cosq_mapping_extended_get.rx_cosq_mapping = rx_cosq_mapping;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_extended_set_async(
	int unit,
	uint32 options,
	bcm_rx_cosq_mapping_t * rx_cosq_mapping,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_EXTENDED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_extended_set.unit = unit;
	async->args.rx_cosq_mapping_extended_set.options = options;
	async->args.rx_cosq_mapping_extended_set.rx_cosq_mapping = rx_cosq_mapping;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_get_async(
	int unit,
	int index,
	bcm_rx_reasons_t * reasons,
	bcm_rx_reasons_t * reasons_mask,
	uint8 * int_prio,
	uint8 * int_prio_mask,
	uint32 * packet_type,
	uint32 * packet_type_mask,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_get.unit = unit;
	async->args.rx_cosq_mapping_get.index = index;
	async->args.rx_cosq_mapping_get.reasons = reasons;
	async->args.rx_cosq_mapping_get.reasons_mask = reasons_mask;
	async->args.rx_cosq_mapping_get.int_prio = int_prio;
	async->args.rx_cosq_mapping_get.int_prio_mask = int_prio_mask;
	async->args.rx_cosq_mapping_get.packet_type = packet_type;
	async->args.rx_cosq_mapping_get.packet_type_mask = packet_type_mask;
	async->args.rx_cosq_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_reasons_get_async(
	int unit,
	bcm_rx_reasons_t * reasons,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_REASONS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_reasons_get.unit = unit;
	async->args.rx_cosq_mapping_reasons_get.reasons = reasons;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_set_async(
	int unit,
	int index,
	bcm_rx_reasons_t reasons,
	bcm_rx_reasons_t reasons_mask,
	uint8 int_prio,
	uint8 int_prio_mask,
	uint32 packet_type,
	uint32 packet_type_mask,
	bcm_cos_queue_t cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_set.unit = unit;
	async->args.rx_cosq_mapping_set.index = index;
	async->args.rx_cosq_mapping_set.reasons = reasons;
	async->args.rx_cosq_mapping_set.reasons_mask = reasons_mask;
	async->args.rx_cosq_mapping_set.int_prio = int_prio;
	async->args.rx_cosq_mapping_set.int_prio_mask = int_prio_mask;
	async->args.rx_cosq_mapping_set.packet_type = packet_type;
	async->args.rx_cosq_mapping_set.packet_type_mask = packet_type_mask;
	async->args.rx_cosq_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cosq_mapping_size_get_async(
	int unit,
	int * size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_SIZE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cosq_mapping_size_get.unit = unit;
	async->args.rx_cosq_mapping_size_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cpu_rate_get_async(
	int unit,
	int * pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CPU_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cpu_rate_get.unit = unit;
	async->args.rx_cpu_rate_get.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_cpu_rate_set_async(
	int unit,
	int pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_CPU_RATE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_cpu_rate_set.unit = unit;
	async->args.rx_cpu_rate_set.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_free_async(
	int unit,
	void * pkt_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_free.unit = unit;
	async->args.rx_free.pkt_data = pkt_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_free_enqueue_async(
	int unit,
	void * pkt_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_FREE_ENQUEUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_free_enqueue.unit = unit;
	async->args.rx_free_enqueue.pkt_data = pkt_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_mtu_get_async(
	int unit,
	bcm_rx_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_MTU_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_mtu_get.unit = unit;
	async->args.rx_mtu_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_mtu_set_async(
	int unit,
	bcm_rx_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_MTU_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_mtu_set.unit = unit;
	async->args.rx_mtu_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_pool_alloc_async(
	int unit,
	int size,
	uint32 flags,
	void ** pool,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_POOL_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_pool_alloc.unit = unit;
	async->args.rx_pool_alloc.size = size;
	async->args.rx_pool_alloc.flags = flags;
	async->args.rx_pool_alloc.pool = (void * *)pool;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_pool_cleanup_async(
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_POOL_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_pool_free_async(
	int unit,
	void * buf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_POOL_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_pool_free.unit = unit;
	async->args.rx_pool_free.buf = buf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_pool_setup_async(
	int pkt_count,
	int bytes_per_pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_POOL_SETUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_pool_setup.pkt_count = pkt_count;
	async->args.rx_pool_setup.bytes_per_pkt = bytes_per_pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_pool_setup_done_async(
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_POOL_SETUP_DONE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_channel_get_async(
	int unit,
	bcm_cos_queue_t queue_id,
	bcm_rx_chan_t * chan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_CHANNEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_channel_get.unit = unit;
	async->args.rx_queue_channel_get.queue_id = queue_id;
	async->args.rx_queue_channel_get.chan_id = chan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_channel_set_async(
	int unit,
	bcm_cos_queue_t queue_id,
	bcm_rx_chan_t chan_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_CHANNEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_channel_set.unit = unit;
	async->args.rx_queue_channel_set.queue_id = queue_id;
	async->args.rx_queue_channel_set.chan_id = chan_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_max_get_async(
	int unit,
	bcm_cos_queue_t * cosq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_max_get.unit = unit;
	async->args.rx_queue_max_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_packet_count_get_async(
	int unit,
	bcm_cos_queue_t cosq,
	int * packet_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_PACKET_COUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_packet_count_get.unit = unit;
	async->args.rx_queue_packet_count_get.cosq = cosq;
	async->args.rx_queue_packet_count_get.packet_count = packet_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_rate_limit_status_get_async(
	int unit,
	bcm_cos_queue_t cosq,
	int * packet_tokens,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_RATE_LIMIT_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_rate_limit_status_get.unit = unit;
	async->args.rx_queue_rate_limit_status_get.cosq = cosq;
	async->args.rx_queue_rate_limit_status_get.packet_tokens = packet_tokens;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_register_async(
	int unit,
	const char * name,
	bcm_cos_queue_t cosq,
	bcm_rx_cb_f callback,
	uint8 priority,
	void * cookie,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_register.unit = unit;
	async->args.rx_queue_register.name = (char *)name;
	async->args.rx_queue_register.cosq = cosq;
	async->args.rx_queue_register.callback = callback;
	async->args.rx_queue_register.priority = priority;
	async->args.rx_queue_register.cookie = cookie;
	async->args.rx_queue_register.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_queue_unregister_async(
	int unit,
	bcm_cos_queue_t cosq,
	bcm_rx_cb_f callback,
	uint8 priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_QUEUE_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_queue_unregister.unit = unit;
	async->args.rx_queue_unregister.cosq = cosq;
	async->args.rx_queue_unregister.callback = callback;
	async->args.rx_queue_unregister.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_rate_get_async(
	int unit,
	int * pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_RATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_rate_get.unit = unit;
	async->args.rx_rate_get.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_rate_set_async(
	int unit,
	int pps,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_RATE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_rate_set.unit = unit;
	async->args.rx_rate_set.pps = pps;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_reasons_get_async(
	int unit,
	bcm_rx_reasons_t * reasons,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REASONS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_reasons_get.unit = unit;
	async->args.rx_reasons_get.reasons = reasons;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_reasons_policer_set_async(
	int unit,
	bcm_rx_reasons_t rx_reasons,
	bcm_policer_t polid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REASONS_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_reasons_policer_set.unit = unit;
	async->args.rx_reasons_policer_set.rx_reasons = rx_reasons;
	async->args.rx_reasons_policer_set.polid = polid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_redirect_reasons_get_async(
	int unit,
	bcm_rx_redirect_t mode,
	bcm_rx_reasons_t * reasons,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REDIRECT_REASONS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_redirect_reasons_get.unit = unit;
	async->args.rx_redirect_reasons_get.mode = mode;
	async->args.rx_redirect_reasons_get.reasons = reasons;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_redirect_reasons_set_async(
	int unit,
	bcm_rx_redirect_t mode,
	bcm_rx_reasons_t reasons,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REDIRECT_REASONS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_redirect_reasons_set.unit = unit;
	async->args.rx_redirect_reasons_set.mode = mode;
	async->args.rx_redirect_reasons_set.reasons = reasons;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_register_async(
	int unit,
	const char * name,
	bcm_rx_cb_f callback,
	uint8 priority,
	void * cookie,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_register.unit = unit;
	async->args.rx_register.name = (char *)name;
	async->args.rx_register.callback = callback;
	async->args.rx_register.priority = priority;
	async->args.rx_register.cookie = cookie;
	async->args.rx_register.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BCM_RPC_SUPPORT

void
bcm_rx_remote_pkt_alloc_async(
	int len,
	bcm_pkt_t ** pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REMOTE_PKT_ALLOC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_remote_pkt_alloc.len = len;
	async->args.rx_remote_pkt_alloc.pkt = (bcm_pkt_t * *)pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BCM_RPC_SUPPORT */

void
bcm_rx_remote_pkt_enqueue_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REMOTE_PKT_ENQUEUE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_remote_pkt_enqueue.unit = unit;
	async->args.rx_remote_pkt_enqueue.pkt = pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BCM_RPC_SUPPORT

void
bcm_rx_remote_pkt_free_async(
	bcm_pkt_t * pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_REMOTE_PKT_FREE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_remote_pkt_free.pkt = pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BCM_RPC_SUPPORT */

void
bcm_rx_sched_register_async(
	int unit,
	bcm_rx_sched_cb sched_cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SCHED_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_sched_register.unit = unit;
	async->args.rx_sched_register.sched_cb = sched_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_sched_unregister_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SCHED_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_sched_unregister.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_rx_show_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SHOW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_show.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_rx_snoop_create_async(
	int unit,
	int flags,
	int * snoop_cmnd,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SNOOP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_snoop_create.unit = unit;
	async->args.rx_snoop_create.flags = flags;
	async->args.rx_snoop_create.snoop_cmnd = snoop_cmnd;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_snoop_destroy_async(
	int unit,
	int flags,
	int snoop_cmnd,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SNOOP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_snoop_destroy.unit = unit;
	async->args.rx_snoop_destroy.flags = flags;
	async->args.rx_snoop_destroy.snoop_cmnd = snoop_cmnd;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_snoop_get_async(
	int unit,
	int snoop_cmnd,
	bcm_rx_snoop_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SNOOP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_snoop_get.unit = unit;
	async->args.rx_snoop_get.snoop_cmnd = snoop_cmnd;
	async->args.rx_snoop_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_snoop_set_async(
	int unit,
	int snoop_cmnd,
	bcm_rx_snoop_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_SNOOP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_snoop_set.unit = unit;
	async->args.rx_snoop_set.snoop_cmnd = snoop_cmnd;
	async->args.rx_snoop_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_start_async(
	int unit,
	bcm_rx_cfg_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_START;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_start.unit = unit;
	async->args.rx_start.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_stop_async(
	int unit,
	bcm_rx_cfg_t * cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_STOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_stop.unit = unit;
	async->args.rx_stop.cfg = cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_get_async(
	int unit,
	int trap_id,
	bcm_rx_trap_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_get.unit = unit;
	async->args.rx_trap_get.trap_id = trap_id;
	async->args.rx_trap_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_set_async(
	int unit,
	int trap_id,
	bcm_rx_trap_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_set.unit = unit;
	async->args.rx_trap_set.trap_id = trap_id;
	async->args.rx_trap_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_sw_to_hw_id_map_get_async(
	int unit,
	uint32 flags,
	int sw_trap_id,
	int * hw_trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_SW_TO_HW_ID_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_sw_to_hw_id_map_get.unit = unit;
	async->args.rx_trap_sw_to_hw_id_map_get.flags = flags;
	async->args.rx_trap_sw_to_hw_id_map_get.sw_trap_id = sw_trap_id;
	async->args.rx_trap_sw_to_hw_id_map_get.hw_trap_id = hw_trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_type_create_async(
	int unit,
	int flags,
	bcm_rx_trap_t type,
	int * trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_TYPE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_type_create.unit = unit;
	async->args.rx_trap_type_create.flags = flags;
	async->args.rx_trap_type_create.type = type;
	async->args.rx_trap_type_create.trap_id = trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_type_destroy_async(
	int unit,
	int trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_TYPE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_type_destroy.unit = unit;
	async->args.rx_trap_type_destroy.trap_id = trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_type_from_id_get_async(
	int unit,
	int flags,
	int trap_id,
	bcm_rx_trap_t * trap_type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_TYPE_FROM_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_type_from_id_get.unit = unit;
	async->args.rx_trap_type_from_id_get.flags = flags;
	async->args.rx_trap_type_from_id_get.trap_id = trap_id;
	async->args.rx_trap_type_from_id_get.trap_type = trap_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_trap_type_get_async(
	int unit,
	int flags,
	bcm_rx_trap_t type,
	int * trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_TRAP_TYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_trap_type_get.unit = unit;
	async->args.rx_trap_type_get.flags = flags;
	async->args.rx_trap_type_get.type = type;
	async->args.rx_trap_type_get.trap_id = trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_unit_next_get_async(
	int unit,
	int * next_unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_UNIT_NEXT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_unit_next_get.unit = unit;
	async->args.rx_unit_next_get.next_unit = next_unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_rx_unregister_async(
	int unit,
	bcm_rx_cb_f callback,
	uint8 priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_RX_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_unregister.unit = unit;
	async->args.rx_unregister.callback = callback;
	async->args.rx_unregister.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_config_get_async(
	int unit,
	bcm_sat_config_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_config_get.unit = unit;
	async->args.sat_config_get.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_config_set_async(
	int unit,
	bcm_sat_config_t * conf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_config_set.unit = unit;
	async->args.sat_config_set.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_availability_config_set_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	bcm_sat_ctf_availability_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_AVAILABILITY_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_availability_config_set.unit = unit;
	async->args.sat_ctf_availability_config_set.ctf_id = ctf_id;
	async->args.sat_ctf_availability_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_bin_limit_get_async(
	int unit,
	int max_bins_count,
	bcm_sat_ctf_bin_limit_t * bins,
	int * bins_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_BIN_LIMIT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_bin_limit_get.unit = unit;
	async->args.sat_ctf_bin_limit_get.max_bins_count = max_bins_count;
	async->args.sat_ctf_bin_limit_get.bins = bins;
	async->args.sat_ctf_bin_limit_get.bins_count = bins_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_bin_limit_set_async(
	int unit,
	int bins_count,
	bcm_sat_ctf_bin_limit_t * bins,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_BIN_LIMIT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_bin_limit_set.unit = unit;
	async->args.sat_ctf_bin_limit_set.bins_count = bins_count;
	async->args.sat_ctf_bin_limit_set.bins = bins;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_create_async(
	int unit,
	uint32 flags,
	bcm_sat_ctf_t * ctf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_create.unit = unit;
	async->args.sat_ctf_create.flags = flags;
	async->args.sat_ctf_create.ctf_id = ctf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_destroy_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_destroy.unit = unit;
	async->args.sat_ctf_destroy.ctf_id = ctf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_identifier_map_async(
	int unit,
	bcm_sat_ctf_identifier_t * identifier,
	bcm_sat_ctf_t ctf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_IDENTIFIER_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_identifier_map.unit = unit;
	async->args.sat_ctf_identifier_map.identifier = identifier;
	async->args.sat_ctf_identifier_map.ctf_id = ctf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_identifier_unmap_async(
	int unit,
	bcm_sat_ctf_identifier_t * identifier,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_IDENTIFIER_UNMAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_identifier_unmap.unit = unit;
	async->args.sat_ctf_identifier_unmap.identifier = identifier;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_packet_config_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	bcm_sat_ctf_packet_info_t * packet_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_PACKET_CONFIG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_packet_config.unit = unit;
	async->args.sat_ctf_packet_config.ctf_id = ctf_id;
	async->args.sat_ctf_packet_config.packet_info = packet_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_reports_config_set_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	bcm_sat_ctf_report_config_t * reports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_REPORTS_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_reports_config_set.unit = unit;
	async->args.sat_ctf_reports_config_set.ctf_id = ctf_id;
	async->args.sat_ctf_reports_config_set.reports = reports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_stat_config_set_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	bcm_sat_ctf_stat_config_t * stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_STAT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_stat_config_set.unit = unit;
	async->args.sat_ctf_stat_config_set.ctf_id = ctf_id;
	async->args.sat_ctf_stat_config_set.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_stat_get_async(
	int unit,
	bcm_sat_ctf_t ctf_id,
	uint32 flags,
	bcm_sat_ctf_stat_t * stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_stat_get.unit = unit;
	async->args.sat_ctf_stat_get.ctf_id = ctf_id;
	async->args.sat_ctf_stat_get.flags = flags;
	async->args.sat_ctf_stat_get.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_trap_add_async(
	int unit,
	uint32 trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_trap_add.unit = unit;
	async->args.sat_ctf_trap_add.trap_id = trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_trap_data_to_session_map_async(
	int unit,
	uint32 trap_data,
	uint32 trap_data_mask,
	uint32 session_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAP_DATA_TO_SESSION_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_trap_data_to_session_map.unit = unit;
	async->args.sat_ctf_trap_data_to_session_map.trap_data = trap_data;
	async->args.sat_ctf_trap_data_to_session_map.trap_data_mask = trap_data_mask;
	async->args.sat_ctf_trap_data_to_session_map.session_id = session_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_trap_data_to_session_unmap_async(
	int unit,
	uint32 trap_data,
	uint32 trap_data_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAP_DATA_TO_SESSION_UNMAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_trap_data_to_session_unmap.unit = unit;
	async->args.sat_ctf_trap_data_to_session_unmap.trap_data = trap_data;
	async->args.sat_ctf_trap_data_to_session_unmap.trap_data_mask = trap_data_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_trap_remove_async(
	int unit,
	uint32 trap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAP_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_trap_remove.unit = unit;
	async->args.sat_ctf_trap_remove.trap_id = trap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_trap_remove_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAP_REMOVE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_trap_remove_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_ctf_traverse_async(
	int unit,
	bcm_sat_ctf_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_CTF_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_ctf_traverse.unit = unit;
	async->args.sat_ctf_traverse.cb = cb;
	async->args.sat_ctf_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_endpoint_create_async(
	int unit,
	bcm_sat_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_ENDPOINT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_endpoint_create.unit = unit;
	async->args.sat_endpoint_create.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_endpoint_destroy_async(
	int unit,
	bcm_sat_endpoint_t endpoint,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_ENDPOINT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_endpoint_destroy.unit = unit;
	async->args.sat_endpoint_destroy.endpoint = endpoint;
	async->args.sat_endpoint_destroy.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_endpoint_destroy_all_async(
	int unit,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_ENDPOINT_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_endpoint_destroy_all.unit = unit;
	async->args.sat_endpoint_destroy_all.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_endpoint_get_async(
	int unit,
	bcm_sat_endpoint_t endpoint,
	uint32 flags,
	bcm_sat_endpoint_info_t * endpoint_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_ENDPOINT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_endpoint_get.unit = unit;
	async->args.sat_endpoint_get.endpoint = endpoint;
	async->args.sat_endpoint_get.flags = flags;
	async->args.sat_endpoint_get.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_endpoint_traverse_async(
	int unit,
	uint32 flags,
	bcm_sat_endpoint_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_ENDPOINT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_endpoint_traverse.unit = unit;
	async->args.sat_endpoint_traverse.flags = flags;
	async->args.sat_endpoint_traverse.cb = cb;
	async->args.sat_endpoint_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_event_register_async(
	int unit,
	bcm_sat_event_type_t event_type,
	bcm_sat_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_event_register.unit = unit;
	async->args.sat_event_register.event_type = event_type;
	async->args.sat_event_register.cb = cb;
	async->args.sat_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_event_unregister_async(
	int unit,
	bcm_sat_event_type_t event_type,
	bcm_sat_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_event_unregister.unit = unit;
	async->args.sat_event_unregister.event_type = event_type;
	async->args.sat_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_bandwidth_get_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	int priority,
	bcm_sat_gtf_bandwidth_t * bw,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_bandwidth_get.unit = unit;
	async->args.sat_gtf_bandwidth_get.gtf_id = gtf_id;
	async->args.sat_gtf_bandwidth_get.priority = priority;
	async->args.sat_gtf_bandwidth_get.bw = bw;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_bandwidth_set_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	int priority,
	bcm_sat_gtf_bandwidth_t * bw,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_bandwidth_set.unit = unit;
	async->args.sat_gtf_bandwidth_set.gtf_id = gtf_id;
	async->args.sat_gtf_bandwidth_set.priority = priority;
	async->args.sat_gtf_bandwidth_set.bw = bw;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_create_async(
	int unit,
	uint32 flags,
	bcm_sat_gtf_t * gtf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_create.unit = unit;
	async->args.sat_gtf_create.flags = flags;
	async->args.sat_gtf_create.gtf_id = gtf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_destroy_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_destroy.unit = unit;
	async->args.sat_gtf_destroy.gtf_id = gtf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_packet_config_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	bcm_sat_gtf_packet_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_PACKET_CONFIG;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_packet_config.unit = unit;
	async->args.sat_gtf_packet_config.gtf_id = gtf_id;
	async->args.sat_gtf_packet_config.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_packet_start_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	bcm_sat_gtf_pri_t priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_PACKET_START;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_packet_start.unit = unit;
	async->args.sat_gtf_packet_start.gtf_id = gtf_id;
	async->args.sat_gtf_packet_start.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_packet_stop_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	bcm_sat_gtf_pri_t priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_PACKET_STOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_packet_stop.unit = unit;
	async->args.sat_gtf_packet_stop.gtf_id = gtf_id;
	async->args.sat_gtf_packet_stop.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_rate_pattern_get_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	int priority,
	bcm_sat_gtf_rate_pattern_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_RATE_PATTERN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_rate_pattern_get.unit = unit;
	async->args.sat_gtf_rate_pattern_get.gtf_id = gtf_id;
	async->args.sat_gtf_rate_pattern_get.priority = priority;
	async->args.sat_gtf_rate_pattern_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_rate_pattern_set_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	int priority,
	bcm_sat_gtf_rate_pattern_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_RATE_PATTERN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_rate_pattern_set.unit = unit;
	async->args.sat_gtf_rate_pattern_set.gtf_id = gtf_id;
	async->args.sat_gtf_rate_pattern_set.priority = priority;
	async->args.sat_gtf_rate_pattern_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_stat_get_async(
	int unit,
	bcm_sat_gtf_t gtf_id,
	int priority,
	uint32 flags,
	bcm_sat_gtf_stat_counter_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_stat_get.unit = unit;
	async->args.sat_gtf_stat_get.gtf_id = gtf_id;
	async->args.sat_gtf_stat_get.priority = priority;
	async->args.sat_gtf_stat_get.flags = flags;
	async->args.sat_gtf_stat_get.type = type;
	async->args.sat_gtf_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_sat_gtf_traverse_async(
	int unit,
	bcm_sat_gtf_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SAT_GTF_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.sat_gtf_traverse.unit = unit;
	async->args.sat_gtf_traverse.cb = cb;
	async->args.sat_gtf_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_clear_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_clear.unit = unit;
	async->args.stat_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_clear_single_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CLEAR_SINGLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_clear_single.unit = unit;
	async->args.stat_clear_single.port = port;
	async->args.stat_clear_single.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_config_get_async(
	int unit,
	bcm_stat_counter_engine_t * engine,
	bcm_stat_counter_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_config_get.unit = unit;
	async->args.stat_counter_config_get.engine = engine;
	async->args.stat_counter_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_config_set_async(
	int unit,
	bcm_stat_counter_engine_t * engine,
	bcm_stat_counter_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_config_set.unit = unit;
	async->args.stat_counter_config_set.engine = engine;
	async->args.stat_counter_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_filter_get_async(
	int unit,
	bcm_stat_counter_source_t source,
	int filter_max_count,
	bcm_stat_counter_filter_t * filter_array,
	int * filter_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_FILTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_filter_get.unit = unit;
	async->args.stat_counter_filter_get.source = source;
	async->args.stat_counter_filter_get.filter_max_count = filter_max_count;
	async->args.stat_counter_filter_get.filter_array = filter_array;
	async->args.stat_counter_filter_get.filter_count = filter_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_filter_is_active_get_async(
	int unit,
	bcm_stat_counter_source_t source,
	bcm_stat_counter_filter_t filter,
	int * is_active,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_FILTER_IS_ACTIVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_filter_is_active_get.unit = unit;
	async->args.stat_counter_filter_is_active_get.source = source;
	async->args.stat_counter_filter_is_active_get.filter = filter;
	async->args.stat_counter_filter_is_active_get.is_active = is_active;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_filter_set_async(
	int unit,
	bcm_stat_counter_source_t source,
	bcm_stat_counter_filter_t * filter_array,
	int filter_count,
	int is_active,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_FILTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_filter_set.unit = unit;
	async->args.stat_counter_filter_set.source = source;
	async->args.stat_counter_filter_set.filter_array = filter_array;
	async->args.stat_counter_filter_set.filter_count = filter_count;
	async->args.stat_counter_filter_set.is_active = is_active;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_get_async(
	int unit,
	uint32 flags,
	bcm_stat_counter_input_data_t * stat_counter_input_data,
	bcm_stat_counter_output_data_t * stat_counter_output_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_get.unit = unit;
	async->args.stat_counter_get.flags = flags;
	async->args.stat_counter_get.stat_counter_input_data = stat_counter_input_data;
	async->args.stat_counter_get.stat_counter_output_data = stat_counter_output_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_lif_counting_get_async(
	int unit,
	uint32 flags,
	bcm_stat_counter_source_t * source,
	bcm_stat_counter_lif_mask_t * counting_mask,
	bcm_stat_counter_lif_stack_id_t * lif_stack_id_to_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_LIF_COUNTING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_lif_counting_get.unit = unit;
	async->args.stat_counter_lif_counting_get.flags = flags;
	async->args.stat_counter_lif_counting_get.source = source;
	async->args.stat_counter_lif_counting_get.counting_mask = counting_mask;
	async->args.stat_counter_lif_counting_get.lif_stack_id_to_count = lif_stack_id_to_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_lif_counting_range_get_async(
	int unit,
	uint32 flags,
	bcm_stat_counter_source_type_t source,
	bcm_stat_counter_lif_range_id_t range_id,
	bcm_stat_counter_lif_counting_range_t * lif_range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_LIF_COUNTING_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_lif_counting_range_get.unit = unit;
	async->args.stat_counter_lif_counting_range_get.flags = flags;
	async->args.stat_counter_lif_counting_range_get.source = source;
	async->args.stat_counter_lif_counting_range_get.range_id = range_id;
	async->args.stat_counter_lif_counting_range_get.lif_range = lif_range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_lif_counting_range_set_async(
	int unit,
	uint32 flags,
	bcm_stat_counter_source_type_t source,
	bcm_stat_counter_lif_range_id_t range_id,
	bcm_stat_counter_lif_counting_range_t * lif_range,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_LIF_COUNTING_RANGE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_lif_counting_range_set.unit = unit;
	async->args.stat_counter_lif_counting_range_set.flags = flags;
	async->args.stat_counter_lif_counting_range_set.source = source;
	async->args.stat_counter_lif_counting_range_set.range_id = range_id;
	async->args.stat_counter_lif_counting_range_set.lif_range = lif_range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_counter_lif_counting_set_async(
	int unit,
	uint32 flags,
	bcm_stat_counter_source_t * source,
	bcm_stat_counter_lif_mask_t * counting_mask,
	bcm_stat_counter_lif_stack_id_t lif_stack_id_to_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_COUNTER_LIF_COUNTING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_counter_lif_counting_set.unit = unit;
	async->args.stat_counter_lif_counting_set.flags = flags;
	async->args.stat_counter_lif_counting_set.source = source;
	async->args.stat_counter_lif_counting_set.counting_mask = counting_mask;
	async->args.stat_counter_lif_counting_set.lif_stack_id_to_count = lif_stack_id_to_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_add_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_add.unit = unit;
	async->args.stat_custom_add.port = port;
	async->args.stat_custom_add.type = type;
	async->args.stat_custom_add.trigger = trigger;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_check_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	int * result,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_CHECK;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_check.unit = unit;
	async->args.stat_custom_check.port = port;
	async->args.stat_custom_check.type = type;
	async->args.stat_custom_check.trigger = trigger;
	async->args.stat_custom_check.result = result;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_delete_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_delete.unit = unit;
	async->args.stat_custom_delete.port = port;
	async->args.stat_custom_delete.type = type;
	async->args.stat_custom_delete.trigger = trigger;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_delete_all_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_delete_all.unit = unit;
	async->args.stat_custom_delete_all.port = port;
	async->args.stat_custom_delete_all.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_get_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_get.unit = unit;
	async->args.stat_custom_get.port = port;
	async->args.stat_custom_get.type = type;
	async->args.stat_custom_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_group_create_async(
	int unit,
	uint32 mode_id,
	bcm_stat_object_t object,
	uint32 * stat_counter_id,
	uint32 * num_entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_group_create.unit = unit;
	async->args.stat_custom_group_create.mode_id = mode_id;
	async->args.stat_custom_group_create.object = object;
	async->args.stat_custom_group_create.stat_counter_id = stat_counter_id;
	async->args.stat_custom_group_create.num_entries = num_entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_custom_set_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_CUSTOM_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_set.unit = unit;
	async->args.stat_custom_set.port = port;
	async->args.stat_custom_set.type = type;
	async->args.stat_custom_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_egress_receive_tm_pointer_format_get_async(
	int unit,
	int flags,
	bcm_stat_egress_receive_tm_pointer_format_t * pointer_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_EGRESS_RECEIVE_TM_POINTER_FORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_egress_receive_tm_pointer_format_get.unit = unit;
	async->args.stat_egress_receive_tm_pointer_format_get.flags = flags;
	async->args.stat_egress_receive_tm_pointer_format_get.pointer_format = pointer_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_egress_receive_tm_pointer_format_set_async(
	int unit,
	int flags,
	bcm_stat_egress_receive_tm_pointer_format_t * pointer_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_EGRESS_RECEIVE_TM_POINTER_FORMAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_egress_receive_tm_pointer_format_set.unit = unit;
	async->args.stat_egress_receive_tm_pointer_format_set.flags = flags;
	async->args.stat_egress_receive_tm_pointer_format_set.pointer_format = pointer_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_flex_counter_get_async(
	int unit,
	uint32 stat_counter_id,
	bcm_stat_flex_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_FLEX_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_flex_counter_get.unit = unit;
	async->args.stat_flex_counter_get.stat_counter_id = stat_counter_id;
	async->args.stat_flex_counter_get.stat = stat;
	async->args.stat_flex_counter_get.num_entries = num_entries;
	async->args.stat_flex_counter_get.counter_indexes = counter_indexes;
	async->args.stat_flex_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_flex_counter_set_async(
	int unit,
	uint32 stat_counter_id,
	bcm_stat_flex_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_FLEX_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_flex_counter_set.unit = unit;
	async->args.stat_flex_counter_set.stat_counter_id = stat_counter_id;
	async->args.stat_flex_counter_set.stat = stat;
	async->args.stat_flex_counter_set.num_entries = num_entries;
	async->args.stat_flex_counter_set.counter_indexes = counter_indexes;
	async->args.stat_flex_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_flex_counter_sync_get_async(
	int unit,
	uint32 stat_counter_id,
	bcm_stat_flex_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_FLEX_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_flex_counter_sync_get.unit = unit;
	async->args.stat_flex_counter_sync_get.stat_counter_id = stat_counter_id;
	async->args.stat_flex_counter_sync_get.stat = stat;
	async->args.stat_flex_counter_sync_get.num_entries = num_entries;
	async->args.stat_flex_counter_sync_get.counter_indexes = counter_indexes;
	async->args.stat_flex_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_flex_pool_info_multi_get_async(
	int unit,
	bcm_stat_flex_direction_t direction,
	uint32 num_pools,
	bcm_stat_flex_pool_stat_info_t * flex_pool_stat,
	uint32 * actual_num_pools,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_FLEX_POOL_INFO_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_flex_pool_info_multi_get.unit = unit;
	async->args.stat_flex_pool_info_multi_get.direction = direction;
	async->args.stat_flex_pool_info_multi_get.num_pools = num_pools;
	async->args.stat_flex_pool_info_multi_get.flex_pool_stat = flex_pool_stat;
	async->args.stat_flex_pool_info_multi_get.actual_num_pools = actual_num_pools;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_get_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_get.unit = unit;
	async->args.stat_get.port = port;
	async->args.stat_get.type = type;
	async->args.stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_get32_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_get32.unit = unit;
	async->args.stat_get32.port = port;
	async->args.stat_get32.type = type;
	async->args.stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_create_async(
	int unit,
	bcm_stat_object_t object,
	bcm_stat_group_mode_t group_mode,
	uint32 * stat_counter_id,
	uint32 * num_entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_create.unit = unit;
	async->args.stat_group_create.object = object;
	async->args.stat_group_create.group_mode = group_mode;
	async->args.stat_group_create.stat_counter_id = stat_counter_id;
	async->args.stat_group_create.num_entries = num_entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_destroy_async(
	int unit,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_destroy.unit = unit;
	async->args.stat_group_destroy.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_dump_async(
	int unit,
	bcm_stat_object_t object,
	bcm_stat_group_mode_t group_mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_dump.unit = unit;
	async->args.stat_group_dump.object = object;
	async->args.stat_group_dump.group_mode = group_mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_dump_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_DUMP_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_dump_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_mode_id_config_create_async(
	int unit,
	uint32 options,
	bcm_stat_group_mode_id_config_t * stat_config,
	uint32 num_selectors,
	bcm_stat_group_mode_attr_selector_t * attr_sel,
	uint32 * mode_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_MODE_ID_CONFIG_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_mode_id_config_create.unit = unit;
	async->args.stat_group_mode_id_config_create.options = options;
	async->args.stat_group_mode_id_config_create.stat_config = stat_config;
	async->args.stat_group_mode_id_config_create.num_selectors = num_selectors;
	async->args.stat_group_mode_id_config_create.attr_sel = attr_sel;
	async->args.stat_group_mode_id_config_create.mode_id = mode_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_mode_id_config_get_async(
	int unit,
	uint32 mode_id,
	bcm_stat_group_mode_id_config_t * config,
	uint32 num_selectors,
	bcm_stat_group_mode_attr_selector_t * attr_sel,
	uint32 * actual_num_selectors,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_MODE_ID_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_mode_id_config_get.unit = unit;
	async->args.stat_group_mode_id_config_get.mode_id = mode_id;
	async->args.stat_group_mode_id_config_get.config = config;
	async->args.stat_group_mode_id_config_get.num_selectors = num_selectors;
	async->args.stat_group_mode_id_config_get.attr_sel = attr_sel;
	async->args.stat_group_mode_id_config_get.actual_num_selectors = actual_num_selectors;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_mode_id_create_async(
	int unit,
	uint32 flags,
	uint32 total_counters,
	uint32 num_selectors,
	bcm_stat_group_mode_attr_selector_t * attr_selectors,
	uint32 * mode_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_MODE_ID_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_mode_id_create.unit = unit;
	async->args.stat_group_mode_id_create.flags = flags;
	async->args.stat_group_mode_id_create.total_counters = total_counters;
	async->args.stat_group_mode_id_create.num_selectors = num_selectors;
	async->args.stat_group_mode_id_create.attr_selectors = attr_selectors;
	async->args.stat_group_mode_id_create.mode_id = mode_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_mode_id_destroy_async(
	int unit,
	uint32 mode_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_MODE_ID_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_mode_id_destroy.unit = unit;
	async->args.stat_group_mode_id_destroy.mode_id = mode_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_group_mode_id_get_async(
	int unit,
	uint32 mode_id,
	uint32 * flags,
	uint32 * total_counters,
	uint32 num_selectors,
	bcm_stat_group_mode_attr_selector_t * attr_selectors,
	uint32 * actual_num_selectors,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_GROUP_MODE_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_group_mode_id_get.unit = unit;
	async->args.stat_group_mode_id_get.mode_id = mode_id;
	async->args.stat_group_mode_id_get.flags = flags;
	async->args.stat_group_mode_id_get.total_counters = total_counters;
	async->args.stat_group_mode_id_get.num_selectors = num_selectors;
	async->args.stat_group_mode_id_get.attr_selectors = attr_selectors;
	async->args.stat_group_mode_id_get.actual_num_selectors = actual_num_selectors;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_id_get_all_async(
	int unit,
	bcm_stat_object_t object,
	int stat_max,
	uint32 * stat_array,
	int * stat_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_ID_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_id_get_all.unit = unit;
	async->args.stat_id_get_all.object = object;
	async->args.stat_id_get_all.stat_max = stat_max;
	async->args.stat_id_get_all.stat_array = stat_array;
	async->args.stat_id_get_all.stat_count = stat_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_lif_counting_profile_get_async(
	int unit,
	uint32 flags,
	int lif_counting_profile,
	bcm_stat_lif_counting_t * lif_counting,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_LIF_COUNTING_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_lif_counting_profile_get.unit = unit;
	async->args.stat_lif_counting_profile_get.flags = flags;
	async->args.stat_lif_counting_profile_get.lif_counting_profile = lif_counting_profile;
	async->args.stat_lif_counting_profile_get.lif_counting = lif_counting;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_lif_counting_profile_set_async(
	int unit,
	uint32 flags,
	int lif_counting_profile,
	bcm_stat_lif_counting_t * lif_counting,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_LIF_COUNTING_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_lif_counting_profile_set.unit = unit;
	async->args.stat_lif_counting_profile_set.flags = flags;
	async->args.stat_lif_counting_profile_set.lif_counting_profile = lif_counting_profile;
	async->args.stat_lif_counting_profile_set.lif_counting = lif_counting;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_lif_counting_stack_level_priority_get_async(
	int unit,
	uint32 flags,
	bcm_stat_lif_counting_source_t * source,
	bcm_stat_counter_lif_stack_id_t lif_stack_level,
	int * priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_LIF_COUNTING_STACK_LEVEL_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_lif_counting_stack_level_priority_get.unit = unit;
	async->args.stat_lif_counting_stack_level_priority_get.flags = flags;
	async->args.stat_lif_counting_stack_level_priority_get.source = source;
	async->args.stat_lif_counting_stack_level_priority_get.lif_stack_level = lif_stack_level;
	async->args.stat_lif_counting_stack_level_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_lif_counting_stack_level_priority_set_async(
	int unit,
	uint32 flags,
	bcm_stat_lif_counting_source_t * source,
	bcm_stat_counter_lif_stack_id_t lif_stack_level,
	int priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_LIF_COUNTING_STACK_LEVEL_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_lif_counting_stack_level_priority_set.unit = unit;
	async->args.stat_lif_counting_stack_level_priority_set.flags = flags;
	async->args.stat_lif_counting_stack_level_priority_set.source = source;
	async->args.stat_lif_counting_stack_level_priority_set.lif_stack_level = lif_stack_level;
	async->args.stat_lif_counting_stack_level_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_multi_get_async(
	int unit,
	bcm_port_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_multi_get.unit = unit;
	async->args.stat_multi_get.port = port;
	async->args.stat_multi_get.nstat = nstat;
	async->args.stat_multi_get.stat_arr = stat_arr;
	async->args.stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_multi_get32_async(
	int unit,
	bcm_port_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_multi_get32.unit = unit;
	async->args.stat_multi_get32.port = port;
	async->args.stat_multi_get32.nstat = nstat;
	async->args.stat_multi_get32.stat_arr = stat_arr;
	async->args.stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_sync_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_SYNC;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_sync.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_sync_get_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint64 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_sync_get.unit = unit;
	async->args.stat_sync_get.port = port;
	async->args.stat_sync_get.type = type;
	async->args.stat_sync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_sync_get32_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t type,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_sync_get32.unit = unit;
	async->args.stat_sync_get32.port = port;
	async->args.stat_sync_get32.type = type;
	async->args.stat_sync_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_sync_multi_get_async(
	int unit,
	bcm_port_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_SYNC_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_sync_multi_get.unit = unit;
	async->args.stat_sync_multi_get.port = port;
	async->args.stat_sync_multi_get.nstat = nstat;
	async->args.stat_sync_multi_get.stat_arr = stat_arr;
	async->args.stat_sync_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_sync_multi_get32_async(
	int unit,
	bcm_port_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_SYNC_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_sync_multi_get32.unit = unit;
	async->args.stat_sync_multi_get32.port = port;
	async->args.stat_sync_multi_get32.nstat = nstat;
	async->args.stat_sync_multi_get32.stat_arr = stat_arr;
	async->args.stat_sync_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_threshold_get_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t stat,
	bcm_stat_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_threshold_get.unit = unit;
	async->args.stat_threshold_get.port = port;
	async->args.stat_threshold_get.stat = stat;
	async->args.stat_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stat_threshold_set_async(
	int unit,
	bcm_port_t port,
	bcm_stat_val_t stat,
	bcm_stat_threshold_t * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STAT_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_threshold_set.unit = unit;
	async->args.stat_threshold_set.port = port;
	async->args.stat_threshold_set.stat = stat;
	async->args.stat_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_clear_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_clear.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_count_get_async(
	int unit,
	int * max_stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_COUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_count_get.unit = unit;
	async->args.stg_count_get.max_stg = max_stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_create_async(
	int unit,
	bcm_stg_t * stg_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_create.unit = unit;
	async->args.stg_create.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_create_id_async(
	int unit,
	bcm_stg_t stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_CREATE_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_create_id.unit = unit;
	async->args.stg_create_id.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_default_get_async(
	int unit,
	bcm_stg_t * stg_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_DEFAULT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_default_get.unit = unit;
	async->args.stg_default_get.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_default_set_async(
	int unit,
	bcm_stg_t stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_DEFAULT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_default_set.unit = unit;
	async->args.stg_default_set.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_destroy_async(
	int unit,
	bcm_stg_t stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_destroy.unit = unit;
	async->args.stg_destroy.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_list_async(
	int unit,
	bcm_stg_t ** list,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_list.unit = unit;
	async->args.stg_list.list = (bcm_stg_t * *)list;
	async->args.stg_list.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_list_destroy_async(
	int unit,
	bcm_stg_t * list,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_LIST_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_list_destroy.unit = unit;
	async->args.stg_list_destroy.list = list;
	async->args.stg_list_destroy.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_stp_get_async(
	int unit,
	bcm_stg_t stg,
	bcm_port_t port,
	int * stp_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_STP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_stp_get.unit = unit;
	async->args.stg_stp_get.stg = stg;
	async->args.stg_stp_get.port = port;
	async->args.stg_stp_get.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_stp_set_async(
	int unit,
	bcm_stg_t stg,
	bcm_port_t port,
	int stp_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_STP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_stp_set.unit = unit;
	async->args.stg_stp_set.stg = stg;
	async->args.stg_stp_set.port = port;
	async->args.stg_stp_set.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_vlan_add_async(
	int unit,
	bcm_stg_t stg,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_VLAN_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_add.unit = unit;
	async->args.stg_vlan_add.stg = stg;
	async->args.stg_vlan_add.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_vlan_list_async(
	int unit,
	bcm_stg_t stg,
	bcm_vlan_t ** list,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_VLAN_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_list.unit = unit;
	async->args.stg_vlan_list.stg = stg;
	async->args.stg_vlan_list.list = (bcm_vlan_t * *)list;
	async->args.stg_vlan_list.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_vlan_list_destroy_async(
	int unit,
	bcm_vlan_t * list,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_VLAN_LIST_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_list_destroy.unit = unit;
	async->args.stg_vlan_list_destroy.list = list;
	async->args.stg_vlan_list_destroy.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_vlan_remove_async(
	int unit,
	bcm_stg_t stg,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_VLAN_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_remove.unit = unit;
	async->args.stg_vlan_remove.stg = stg;
	async->args.stg_vlan_remove.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stg_vlan_remove_all_async(
	int unit,
	bcm_stg_t stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STG_VLAN_REMOVE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_remove_all.unit = unit;
	async->args.stg_vlan_remove_all.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_domain_stk_trunk_add_async(
	int unit,
	int tm_domain,
	bcm_trunk_t stk_trunk,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_DOMAIN_STK_TRUNK_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_domain_stk_trunk_add.unit = unit;
	async->args.stk_domain_stk_trunk_add.tm_domain = tm_domain;
	async->args.stk_domain_stk_trunk_add.stk_trunk = stk_trunk;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_domain_stk_trunk_delete_async(
	int unit,
	int tm_domain,
	bcm_trunk_t stk_trunk,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_DOMAIN_STK_TRUNK_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_domain_stk_trunk_delete.unit = unit;
	async->args.stk_domain_stk_trunk_delete.tm_domain = tm_domain;
	async->args.stk_domain_stk_trunk_delete.stk_trunk = stk_trunk;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_domain_stk_trunk_get_async(
	int unit,
	bcm_trunk_t stk_trunk,
	int domain_max,
	int * domain_array,
	int * domain_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_DOMAIN_STK_TRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_domain_stk_trunk_get.unit = unit;
	async->args.stk_domain_stk_trunk_get.stk_trunk = stk_trunk;
	async->args.stk_domain_stk_trunk_get.domain_max = domain_max;
	async->args.stk_domain_stk_trunk_get.domain_array = domain_array;
	async->args.stk_domain_stk_trunk_get.domain_count = domain_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fabric_map_get_async(
	int unit,
	bcm_gport_t switch_port,
	bcm_gport_t * fabric_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FABRIC_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fabric_map_get.unit = unit;
	async->args.stk_fabric_map_get.switch_port = switch_port;
	async->args.stk_fabric_map_get.fabric_port = fabric_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fabric_map_set_async(
	int unit,
	bcm_gport_t switch_port,
	bcm_gport_t fabric_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FABRIC_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fabric_map_set.unit = unit;
	async->args.stk_fabric_map_set.switch_port = switch_port;
	async->args.stk_fabric_map_set.fabric_port = fabric_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fmod_lmod_mapping_get_async(
	int unit,
	bcm_port_t port,
	bcm_module_t * fmod,
	bcm_module_t * lmod,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FMOD_LMOD_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fmod_lmod_mapping_get.unit = unit;
	async->args.stk_fmod_lmod_mapping_get.port = port;
	async->args.stk_fmod_lmod_mapping_get.fmod = fmod;
	async->args.stk_fmod_lmod_mapping_get.lmod = lmod;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fmod_lmod_mapping_set_async(
	int unit,
	bcm_port_t port,
	bcm_module_t fmod,
	bcm_module_t lmod,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FMOD_LMOD_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fmod_lmod_mapping_set.unit = unit;
	async->args.stk_fmod_lmod_mapping_set.port = port;
	async->args.stk_fmod_lmod_mapping_set.fmod = fmod;
	async->args.stk_fmod_lmod_mapping_set.lmod = lmod;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fmod_smod_mapping_get_async(
	int unit,
	bcm_port_t port,
	bcm_module_t fmod,
	bcm_module_t * smod,
	bcm_port_t * sport,
	uint32 * nports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FMOD_SMOD_MAPPING_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fmod_smod_mapping_get.unit = unit;
	async->args.stk_fmod_smod_mapping_get.port = port;
	async->args.stk_fmod_smod_mapping_get.fmod = fmod;
	async->args.stk_fmod_smod_mapping_get.smod = smod;
	async->args.stk_fmod_smod_mapping_get.sport = sport;
	async->args.stk_fmod_smod_mapping_get.nports = nports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_fmod_smod_mapping_set_async(
	int unit,
	bcm_port_t port,
	bcm_module_t fmod,
	bcm_module_t smod,
	bcm_port_t sport,
	uint32 nports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_FMOD_SMOD_MAPPING_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_fmod_smod_mapping_set.unit = unit;
	async->args.stk_fmod_smod_mapping_set.port = port;
	async->args.stk_fmod_smod_mapping_set.fmod = fmod;
	async->args.stk_fmod_smod_mapping_set.smod = smod;
	async->args.stk_fmod_smod_mapping_set.sport = sport;
	async->args.stk_fmod_smod_mapping_set.nports = nports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_gport_sysport_get_async(
	int unit,
	bcm_gport_t gport,
	bcm_gport_t * sysport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_GPORT_SYSPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_gport_sysport_get.unit = unit;
	async->args.stk_gport_sysport_get.gport = gport;
	async->args.stk_gport_sysport_get.sysport = sysport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_mode_get_async(
	int unit,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_mode_get.unit = unit;
	async->args.stk_mode_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_mode_set_async(
	int unit,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_mode_set.unit = unit;
	async->args.stk_mode_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_add_async(
	int unit,
	bcm_stk_modid_config_t * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_add.unit = unit;
	async->args.stk_modid_config_add.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_delete_async(
	int unit,
	bcm_stk_modid_config_t * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_delete.unit = unit;
	async->args.stk_modid_config_delete.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_get_async(
	int unit,
	bcm_stk_modid_config_t * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_get.unit = unit;
	async->args.stk_modid_config_get.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_get_all_async(
	int unit,
	int modid_max,
	bcm_stk_modid_config_t * modid_array,
	int * modid_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_get_all.unit = unit;
	async->args.stk_modid_config_get_all.modid_max = modid_max;
	async->args.stk_modid_config_get_all.modid_array = modid_array;
	async->args.stk_modid_config_get_all.modid_count = modid_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_config_set_async(
	int unit,
	bcm_stk_modid_config_t * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_config_set.unit = unit;
	async->args.stk_modid_config_set.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_count_async(
	int unit,
	int * num_modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_COUNT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_count.unit = unit;
	async->args.stk_modid_count.num_modid = num_modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_domain_add_async(
	int unit,
	int modid,
	int tm_domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_DOMAIN_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_domain_add.unit = unit;
	async->args.stk_modid_domain_add.modid = modid;
	async->args.stk_modid_domain_add.tm_domain = tm_domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_domain_delete_async(
	int unit,
	int modid,
	int tm_domain,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_DOMAIN_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_domain_delete.unit = unit;
	async->args.stk_modid_domain_delete.modid = modid;
	async->args.stk_modid_domain_delete.tm_domain = tm_domain;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_domain_get_async(
	int unit,
	int tm_domain,
	int mod_max,
	int * mod_array,
	int * mod_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_DOMAIN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_domain_get.unit = unit;
	async->args.stk_modid_domain_get.tm_domain = tm_domain;
	async->args.stk_modid_domain_get.mod_max = mod_max;
	async->args.stk_modid_domain_get.mod_array = mod_array;
	async->args.stk_modid_domain_get.mod_count = mod_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_get_async(
	int unit,
	int * modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_get.unit = unit;
	async->args.stk_modid_get.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modid_set_async(
	int unit,
	int modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modid_set.unit = unit;
	async->args.stk_modid_set.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modmap_enable_get_async(
	int unit,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODMAP_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modmap_enable_get.unit = unit;
	async->args.stk_modmap_enable_get.port = port;
	async->args.stk_modmap_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modmap_enable_set_async(
	int unit,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODMAP_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modmap_enable_set.unit = unit;
	async->args.stk_modmap_enable_set.port = port;
	async->args.stk_modmap_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modmap_map_async(
	int unit,
	int setget,
	bcm_module_t mod_in,
	bcm_port_t port_in,
	bcm_module_t * mod_out,
	bcm_port_t * port_out,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODMAP_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modmap_map.unit = unit;
	async->args.stk_modmap_map.setget = setget;
	async->args.stk_modmap_map.mod_in = mod_in;
	async->args.stk_modmap_map.port_in = port_in;
	async->args.stk_modmap_map.mod_out = mod_out;
	async->args.stk_modmap_map.port_out = port_out;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modmap_register_async(
	int unit,
	bcm_stk_modmap_cb_t func,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODMAP_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modmap_register.unit = unit;
	async->args.stk_modmap_register.func = func;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modmap_unregister_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODMAP_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modmap_unregister.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_add_async(
	int unit,
	int modid,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_add.unit = unit;
	async->args.stk_modport_add.modid = modid;
	async->args.stk_modport_add.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_clear_async(
	int unit,
	int modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_clear.unit = unit;
	async->args.stk_modport_clear.modid = modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_clear_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_CLEAR_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_clear_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_delete_async(
	int unit,
	int modid,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_delete.unit = unit;
	async->args.stk_modport_delete.modid = modid;
	async->args.stk_modport_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_get_async(
	int unit,
	int modid,
	int * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_get.unit = unit;
	async->args.stk_modport_get.modid = modid;
	async->args.stk_modport_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_get_all_async(
	int unit,
	int modid,
	int port_max,
	int * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_get_all.unit = unit;
	async->args.stk_modport_get_all.modid = modid;
	async->args.stk_modport_get_all.port_max = port_max;
	async->args.stk_modport_get_all.port_array = port_array;
	async->args.stk_modport_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_remote_map_get_async(
	int unit,
	bcm_gport_t port,
	uint32 flags,
	int * remote_modid,
	bcm_port_t * remote_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_REMOTE_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_remote_map_get.unit = unit;
	async->args.stk_modport_remote_map_get.port = port;
	async->args.stk_modport_remote_map_get.flags = flags;
	async->args.stk_modport_remote_map_get.remote_modid = remote_modid;
	async->args.stk_modport_remote_map_get.remote_port = remote_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_remote_map_set_async(
	int unit,
	bcm_gport_t port,
	uint32 flags,
	int remote_modid,
	bcm_port_t remote_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_REMOTE_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_remote_map_set.unit = unit;
	async->args.stk_modport_remote_map_set.port = port;
	async->args.stk_modport_remote_map_set.flags = flags;
	async->args.stk_modport_remote_map_set.remote_modid = remote_modid;
	async->args.stk_modport_remote_map_set.remote_port = remote_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_modport_set_async(
	int unit,
	int modid,
	int port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODPORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_modport_set.unit = unit;
	async->args.stk_modport_set.modid = modid;
	async->args.stk_modport_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_control_get_async(
	int unit,
	uint32 flags,
	bcm_module_t module,
	bcm_stk_module_control_t control,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_control_get.unit = unit;
	async->args.stk_module_control_get.flags = flags;
	async->args.stk_module_control_get.module = module;
	async->args.stk_module_control_get.control = control;
	async->args.stk_module_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_control_set_async(
	int unit,
	uint32 flags,
	bcm_module_t module,
	bcm_stk_module_control_t control,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_control_set.unit = unit;
	async->args.stk_module_control_set.flags = flags;
	async->args.stk_module_control_set.module = module;
	async->args.stk_module_control_set.control = control;
	async->args.stk_module_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_enable_async(
	int unit,
	bcm_module_t modid,
	int nports,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_enable.unit = unit;
	async->args.stk_module_enable.modid = modid;
	async->args.stk_module_enable.nports = nports;
	async->args.stk_module_enable.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_max_get_async(
	int unit,
	uint32 flags,
	bcm_module_t * max_module,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_max_get.unit = unit;
	async->args.stk_module_max_get.flags = flags;
	async->args.stk_module_max_get.max_module = max_module;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_max_set_async(
	int unit,
	uint32 flags,
	bcm_module_t max_module,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_MAX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_max_set.unit = unit;
	async->args.stk_module_max_set.flags = flags;
	async->args.stk_module_max_set.max_module = max_module;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_protocol_get_async(
	int unit,
	bcm_module_t modid,
	bcm_module_protocol_t * protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_PROTOCOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_protocol_get.unit = unit;
	async->args.stk_module_protocol_get.modid = modid;
	async->args.stk_module_protocol_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_module_protocol_set_async(
	int unit,
	bcm_module_t modid,
	bcm_module_protocol_t protocol,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MODULE_PROTOCOL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_module_protocol_set.unit = unit;
	async->args.stk_module_protocol_set.modid = modid;
	async->args.stk_module_protocol_set.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_my_modid_get_async(
	int unit,
	int * my_modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MY_MODID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_my_modid_get.unit = unit;
	async->args.stk_my_modid_get.my_modid = my_modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_my_modid_set_async(
	int unit,
	int my_modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_MY_MODID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_my_modid_set.unit = unit;
	async->args.stk_my_modid_set.my_modid = my_modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_pbmp_get_async(
	int unit,
	bcm_pbmp_t * cur_pbm,
	bcm_pbmp_t * inactive_pbm,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PBMP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_pbmp_get.unit = unit;
	async->args.stk_pbmp_get.cur_pbm = cur_pbm;
	async->args.stk_pbmp_get.inactive_pbm = inactive_pbm;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_get_async(
	int unit,
	bcm_port_t port,
	uint32 * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_get.unit = unit;
	async->args.stk_port_get.port = port;
	async->args.stk_port_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modmap_group_get_async(
	int unit,
	bcm_port_t port,
	int * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modmap_group_get.unit = unit;
	async->args.stk_port_modmap_group_get.port = port;
	async->args.stk_port_modmap_group_get.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modmap_group_max_get_async(
	int unit,
	int * max_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modmap_group_max_get.unit = unit;
	async->args.stk_port_modmap_group_max_get.max_group = max_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modmap_group_set_async(
	int unit,
	bcm_port_t port,
	int group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modmap_group_set.unit = unit;
	async->args.stk_port_modmap_group_set.port = port;
	async->args.stk_port_modmap_group_set.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_add_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	bcm_port_t dest_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_add.unit = unit;
	async->args.stk_port_modport_add.ing_port = ing_port;
	async->args.stk_port_modport_add.dest_modid = dest_modid;
	async->args.stk_port_modport_add.dest_port = dest_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_clear_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_clear.unit = unit;
	async->args.stk_port_modport_clear.ing_port = ing_port;
	async->args.stk_port_modport_clear.dest_modid = dest_modid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_clear_all_async(
	int unit,
	bcm_port_t ing_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_CLEAR_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_clear_all.unit = unit;
	async->args.stk_port_modport_clear_all.ing_port = ing_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_delete_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	bcm_port_t dest_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_delete.unit = unit;
	async->args.stk_port_modport_delete.ing_port = ing_port;
	async->args.stk_port_modport_delete.dest_modid = dest_modid;
	async->args.stk_port_modport_delete.dest_port = dest_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_get_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	bcm_port_t * dest_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_get.unit = unit;
	async->args.stk_port_modport_get.ing_port = ing_port;
	async->args.stk_port_modport_get.dest_modid = dest_modid;
	async->args.stk_port_modport_get.dest_port = dest_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_get_all_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	int dest_port_max,
	bcm_port_t * dest_port_array,
	int * dest_port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_get_all.unit = unit;
	async->args.stk_port_modport_get_all.ing_port = ing_port;
	async->args.stk_port_modport_get_all.dest_modid = dest_modid;
	async->args.stk_port_modport_get_all.dest_port_max = dest_port_max;
	async->args.stk_port_modport_get_all.dest_port_array = dest_port_array;
	async->args.stk_port_modport_get_all.dest_port_count = dest_port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_modport_set_async(
	int unit,
	bcm_port_t ing_port,
	bcm_module_t dest_modid,
	bcm_port_t dest_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_MODPORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_modport_set.unit = unit;
	async->args.stk_port_modport_set.ing_port = ing_port;
	async->args.stk_port_modport_set.dest_modid = dest_modid;
	async->args.stk_port_modport_set.dest_port = dest_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_port_set_async(
	int unit,
	bcm_port_t port,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_port_set.unit = unit;
	async->args.stk_port_set.port = port;
	async->args.stk_port_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_steering_clear_async(
	int unit,
	int steer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_STEERING_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_steering_clear.unit = unit;
	async->args.stk_steering_clear.steer_id = steer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_steering_clear_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_STEERING_CLEAR_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_steering_clear_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_steering_multicast_set_async(
	int unit,
	int steer_id,
	bcm_multicast_t mgid_lo,
	bcm_multicast_t mgid_hi,
	int num_queue_groups,
	bcm_gport_t * queue_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_STEERING_MULTICAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_steering_multicast_set.unit = unit;
	async->args.stk_steering_multicast_set.steer_id = steer_id;
	async->args.stk_steering_multicast_set.mgid_lo = mgid_lo;
	async->args.stk_steering_multicast_set.mgid_hi = mgid_hi;
	async->args.stk_steering_multicast_set.num_queue_groups = num_queue_groups;
	async->args.stk_steering_multicast_set.queue_group = queue_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_steering_unicast_set_async(
	int unit,
	int steer_id,
	bcm_module_t destmod_lo,
	bcm_module_t destmod_hi,
	int num_queue_groups,
	bcm_gport_t * queue_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_STEERING_UNICAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_steering_unicast_set.unit = unit;
	async->args.stk_steering_unicast_set.steer_id = steer_id;
	async->args.stk_steering_unicast_set.destmod_lo = destmod_lo;
	async->args.stk_steering_unicast_set.destmod_hi = destmod_hi;
	async->args.stk_steering_unicast_set.num_queue_groups = num_queue_groups;
	async->args.stk_steering_unicast_set.queue_group = queue_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_sysport_gport_get_async(
	int unit,
	bcm_gport_t sysport,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_SYSPORT_GPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_sysport_gport_get.unit = unit;
	async->args.stk_sysport_gport_get.sysport = sysport;
	async->args.stk_sysport_gport_get.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_sysport_gport_set_async(
	int unit,
	bcm_gport_t sysport,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_SYSPORT_GPORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_sysport_gport_set.unit = unit;
	async->args.stk_sysport_gport_set.sysport = sysport;
	async->args.stk_sysport_gport_set.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_system_gport_map_create_async(
	int unit,
	bcm_stk_system_gport_map_t * sys_gport_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_SYSTEM_GPORT_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_system_gport_map_create.unit = unit;
	async->args.stk_system_gport_map_create.sys_gport_map = sys_gport_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_system_gport_map_destroy_async(
	int unit,
	bcm_gport_t system_gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_SYSTEM_GPORT_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_system_gport_map_destroy.unit = unit;
	async->args.stk_system_gport_map_destroy.system_gport = system_gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_system_gport_map_get_async(
	int unit,
	bcm_stk_system_gport_map_t * sys_gport_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_SYSTEM_GPORT_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_system_gport_map_get.unit = unit;
	async->args.stk_system_gport_map_get.sys_gport_map = sys_gport_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_ucbitmap_del_async(
	int unit,
	bcm_port_t port,
	int modid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_UCBITMAP_DEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_ucbitmap_del.unit = unit;
	async->args.stk_ucbitmap_del.port = port;
	async->args.stk_ucbitmap_del.modid = modid;
	async->args.stk_ucbitmap_del.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_ucbitmap_get_async(
	int unit,
	int port,
	int modid,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_UCBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_ucbitmap_get.unit = unit;
	async->args.stk_ucbitmap_get.port = port;
	async->args.stk_ucbitmap_get.modid = modid;
	async->args.stk_ucbitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_ucbitmap_set_async(
	int unit,
	int port,
	int modid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_UCBITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_ucbitmap_set.unit = unit;
	async->args.stk_ucbitmap_set.port = port;
	async->args.stk_ucbitmap_set.modid = modid;
	async->args.stk_ucbitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_update_callback_register_async(
	int unit,
	bcm_stk_cb_f cb,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_UPDATE_CALLBACK_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_update_callback_register.unit = unit;
	async->args.stk_update_callback_register.cb = cb;
	async->args.stk_update_callback_register.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_stk_update_callback_unregister_async(
	int unit,
	bcm_stk_cb_f cb,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_STK_UPDATE_CALLBACK_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stk_update_callback_unregister.unit = unit;
	async->args.stk_update_callback_unregister.cb = cb;
	async->args.stk_update_callback_unregister.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_gport_modport_get_async(
	int unit,
	bcm_gport_t subport_gport,
	bcm_module_t * module,
	bcm_port_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GPORT_MODPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_gport_modport_get.unit = unit;
	async->args.subport_gport_modport_get.subport_gport = subport_gport;
	async->args.subport_gport_modport_get.module = module;
	async->args.subport_gport_modport_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_create_async(
	int unit,
	bcm_subport_group_config_t * config,
	bcm_gport_t * group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_create.unit = unit;
	async->args.subport_group_create.config = config;
	async->args.subport_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_destroy_async(
	int unit,
	bcm_gport_t group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_destroy.unit = unit;
	async->args.subport_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_get_async(
	int unit,
	bcm_gport_t group,
	bcm_subport_group_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_get.unit = unit;
	async->args.subport_group_get.group = group;
	async->args.subport_group_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_linkphy_config_get_async(
	int unit,
	bcm_gport_t port,
	bcm_subport_group_linkphy_config_t * linkphy_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_LINKPHY_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_linkphy_config_get.unit = unit;
	async->args.subport_group_linkphy_config_get.port = port;
	async->args.subport_group_linkphy_config_get.linkphy_config = linkphy_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_linkphy_config_set_async(
	int unit,
	bcm_gport_t port,
	bcm_subport_group_linkphy_config_t * linkphy_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_LINKPHY_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_linkphy_config_set.unit = unit;
	async->args.subport_group_linkphy_config_set.port = port;
	async->args.subport_group_linkphy_config_set.linkphy_config = linkphy_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_group_traverse_async(
	int unit,
	bcm_gport_t subport_group,
	bcm_subport_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_traverse.unit = unit;
	async->args.subport_group_traverse.subport_group = subport_group;
	async->args.subport_group_traverse.cb = cb;
	async->args.subport_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_linkphy_rx_error_register_async(
	int unit,
	bcm_subport_linkphy_rx_errors_t errors,
	bcm_subport_linkphy_rx_error_reg_info_t * reg_info,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_LINKPHY_RX_ERROR_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_linkphy_rx_error_register.unit = unit;
	async->args.subport_linkphy_rx_error_register.errors = errors;
	async->args.subport_linkphy_rx_error_register.reg_info = reg_info;
	async->args.subport_linkphy_rx_error_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_linkphy_rx_error_unregister_async(
	int unit,
	bcm_subport_linkphy_rx_errors_t errors,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_LINKPHY_RX_ERROR_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_linkphy_rx_error_unregister.unit = unit;
	async->args.subport_linkphy_rx_error_unregister.errors = errors;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_add_async(
	int unit,
	bcm_subport_config_t * config,
	bcm_gport_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_add.unit = unit;
	async->args.subport_port_add.config = config;
	async->args.subport_port_add.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_delete_async(
	int unit,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_delete.unit = unit;
	async->args.subport_port_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_get_async(
	int unit,
	bcm_gport_t port,
	bcm_subport_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_get.unit = unit;
	async->args.subport_port_get.port = port;
	async->args.subport_port_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_stat_get_async(
	int unit,
	bcm_gport_t port,
	int stream_id,
	bcm_subport_stat_t stat_type,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_stat_get.unit = unit;
	async->args.subport_port_stat_get.port = port;
	async->args.subport_port_stat_get.stream_id = stream_id;
	async->args.subport_port_stat_get.stat_type = stat_type;
	async->args.subport_port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_stat_set_async(
	int unit,
	bcm_gport_t port,
	int stream_id,
	bcm_subport_stat_t stat_type,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_stat_set.unit = unit;
	async->args.subport_port_stat_set.port = port;
	async->args.subport_port_stat_set.stream_id = stream_id;
	async->args.subport_port_stat_set.stat_type = stat_type;
	async->args.subport_port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_subport_port_traverse_async(
	int unit,
	bcm_subport_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SUBPORT_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_traverse.unit = unit;
	async->args.subport_port_traverse.cb = cb;
	async->args.subport_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_create_async(
	int unit,
	uint32 options,
	bcm_switch_agm_info_t * agm_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_create.unit = unit;
	async->args.switch_agm_create.options = options;
	async->args.switch_agm_create.agm_info = agm_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_destroy_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_destroy.unit = unit;
	async->args.switch_agm_destroy.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_enable_get_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_enable_get.unit = unit;
	async->args.switch_agm_enable_get.agm_id = agm_id;
	async->args.switch_agm_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_enable_set_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_enable_set.unit = unit;
	async->args.switch_agm_enable_set.agm_id = agm_id;
	async->args.switch_agm_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_get_async(
	int unit,
	bcm_switch_agm_info_t * agm_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_get.unit = unit;
	async->args.switch_agm_get.agm_info = agm_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_l3_ecmp_attach_get_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	bcm_if_t * l3_ecmp_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_L3_ECMP_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_l3_ecmp_attach_get.unit = unit;
	async->args.switch_agm_l3_ecmp_attach_get.agm_id = agm_id;
	async->args.switch_agm_l3_ecmp_attach_get.l3_ecmp_id = l3_ecmp_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_stat_clear_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_stat_clear.unit = unit;
	async->args.switch_agm_stat_clear.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_stat_get_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	int nstat,
	bcm_switch_agm_stat_t * stat_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_stat_get.unit = unit;
	async->args.switch_agm_stat_get.agm_id = agm_id;
	async->args.switch_agm_stat_get.nstat = nstat;
	async->args.switch_agm_stat_get.stat_arr = stat_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_traverse_async(
	int unit,
	int flags,
	bcm_switch_agm_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_traverse.unit = unit;
	async->args.switch_agm_traverse.flags = flags;
	async->args.switch_agm_traverse.trav_fn = trav_fn;
	async->args.switch_agm_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_agm_trunk_attach_get_async(
	int unit,
	bcm_switch_agm_id_t agm_id,
	bcm_trunk_t * trunk_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_AGM_TRUNK_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_agm_trunk_attach_get.unit = unit;
	async->args.switch_agm_trunk_attach_get.agm_id = agm_id;
	async->args.switch_agm_trunk_attach_get.trunk_id = trunk_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_get_async(
	int unit,
	bcm_switch_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_get.unit = unit;
	async->args.switch_control_get.type = type;
	async->args.switch_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_indexed_get_async(
	int unit,
	bcm_switch_control_key_t key,
	bcm_switch_control_info_t * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_INDEXED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_indexed_get.unit = unit;
	async->args.switch_control_indexed_get.key = key;
	async->args.switch_control_indexed_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_indexed_set_async(
	int unit,
	bcm_switch_control_key_t key,
	bcm_switch_control_info_t value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_INDEXED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_indexed_set.unit = unit;
	async->args.switch_control_indexed_set.key = key;
	async->args.switch_control_indexed_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_switch_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_port_get.unit = unit;
	async->args.switch_control_port_get.port = port;
	async->args.switch_control_port_get.type = type;
	async->args.switch_control_port_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_port_set_async(
	int unit,
	bcm_port_t port,
	bcm_switch_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_port_set.unit = unit;
	async->args.switch_control_port_set.port = port;
	async->args.switch_control_port_set.type = type;
	async->args.switch_control_port_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_control_set_async(
	int unit,
	bcm_switch_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_set.unit = unit;
	async->args.switch_control_set.type = type;
	async->args.switch_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_dram_vendor_info_get_async(
	int unit,
	bcm_switch_dram_vendor_info_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_DRAM_VENDOR_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_dram_vendor_info_get.unit = unit;
	async->args.switch_dram_vendor_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_create_async(
	int unit,
	bcm_switch_encap_info_t * encap_info,
	bcm_if_t * encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_create.unit = unit;
	async->args.switch_encap_create.encap_info = encap_info;
	async->args.switch_encap_create.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_destroy_async(
	int unit,
	bcm_if_t encap_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_destroy.unit = unit;
	async->args.switch_encap_destroy.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_get_async(
	int unit,
	bcm_if_t encap_id,
	bcm_switch_encap_info_t * encap_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_get.unit = unit;
	async->args.switch_encap_get.encap_id = encap_id;
	async->args.switch_encap_get.encap_info = encap_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_set_async(
	int unit,
	bcm_if_t encap_id,
	bcm_switch_encap_info_t * encap_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_set.unit = unit;
	async->args.switch_encap_set.encap_id = encap_id;
	async->args.switch_encap_set.encap_info = encap_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_encap_traverse_async(
	int unit,
	bcm_switch_encap_traverse_cb cb_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ENCAP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_encap_traverse.unit = unit;
	async->args.switch_encap_traverse.cb_fn = cb_fn;
	async->args.switch_encap_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_event_control_get_async(
	int unit,
	bcm_switch_event_t event,
	bcm_switch_event_control_t type,
	uint32 * value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_EVENT_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_event_control_get.unit = unit;
	async->args.switch_event_control_get.event = event;
	async->args.switch_event_control_get.type = type;
	async->args.switch_event_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_event_control_set_async(
	int unit,
	bcm_switch_event_t event,
	bcm_switch_event_control_t type,
	uint32 value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_EVENT_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_event_control_set.unit = unit;
	async->args.switch_event_control_set.event = event;
	async->args.switch_event_control_set.type = type;
	async->args.switch_event_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_event_register_async(
	int unit,
	bcm_switch_event_cb_t cb,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_event_register.unit = unit;
	async->args.switch_event_register.cb = cb;
	async->args.switch_event_register.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_event_unregister_async(
	int unit,
	bcm_switch_event_cb_t cb,
	void * userdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_event_unregister.unit = unit;
	async->args.switch_event_unregister.cb = cb;
	async->args.switch_event_unregister.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_banks_config_get_async(
	int unit,
	bcm_switch_hash_table_t hash_table,
	uint32 bank_num,
	int * hash_type,
	uint32 * hash_offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_BANKS_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_banks_config_get.unit = unit;
	async->args.switch_hash_banks_config_get.hash_table = hash_table;
	async->args.switch_hash_banks_config_get.bank_num = bank_num;
	async->args.switch_hash_banks_config_get.hash_type = hash_type;
	async->args.switch_hash_banks_config_get.hash_offset = hash_offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_banks_config_set_async(
	int unit,
	bcm_switch_hash_table_t hash_table,
	uint32 bank_num,
	int hash_type,
	uint32 hash_offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_BANKS_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_banks_config_set.unit = unit;
	async->args.switch_hash_banks_config_set.hash_table = hash_table;
	async->args.switch_hash_banks_config_set.bank_num = bank_num;
	async->args.switch_hash_banks_config_set.hash_type = hash_type;
	async->args.switch_hash_banks_config_set.hash_offset = hash_offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_banks_max_get_async(
	int unit,
	bcm_switch_hash_table_t hash_table,
	uint32 * bank_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_BANKS_MAX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_banks_max_get.unit = unit;
	async->args.switch_hash_banks_max_get.hash_table = hash_table;
	async->args.switch_hash_banks_max_get.bank_count = bank_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_create_async(
	int unit,
	bcm_field_group_t group,
	bcm_hash_entry_t * entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_create.unit = unit;
	async->args.switch_hash_entry_create.group = group;
	async->args.switch_hash_entry_create.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_create_qset_async(
	int unit,
	bcm_field_qset_t qset,
	bcm_hash_entry_t * entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_CREATE_QSET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_create_qset.unit = unit;
	async->args.switch_hash_entry_create_qset.qset = qset;
	async->args.switch_hash_entry_create_qset.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_destroy_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_destroy.unit = unit;
	async->args.switch_hash_entry_destroy.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_get_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_switch_hash_entry_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_get.unit = unit;
	async->args.switch_hash_entry_get.entry = entry;
	async->args.switch_hash_entry_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_install_async(
	int unit,
	bcm_hash_entry_t entry,
	uint32 offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_INSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_install.unit = unit;
	async->args.switch_hash_entry_install.entry = entry;
	async->args.switch_hash_entry_install.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_reinstall_async(
	int unit,
	bcm_hash_entry_t entry,
	uint32 offset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_REINSTALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_reinstall.unit = unit;
	async->args.switch_hash_entry_reinstall.entry = entry;
	async->args.switch_hash_entry_reinstall.offset = offset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_remove_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_remove.unit = unit;
	async->args.switch_hash_entry_remove.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_set_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_switch_hash_entry_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_set.unit = unit;
	async->args.switch_hash_entry_set.entry = entry;
	async->args.switch_hash_entry_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_entry_traverse_async(
	int unit,
	int flags,
	bcm_switch_hash_entry_traverse_cb cb_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_ENTRY_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_entry_traverse.unit = unit;
	async->args.switch_hash_entry_traverse.flags = flags;
	async->args.switch_hash_entry_traverse.cb_fn = cb_fn;
	async->args.switch_hash_entry_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_qualify_data_async(
	int unit,
	bcm_hash_entry_t entry,
	int qual_id,
	uint32 data,
	uint32 mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_QUALIFY_DATA;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_qualify_data.unit = unit;
	async->args.switch_hash_qualify_data.entry = entry;
	async->args.switch_hash_qualify_data.qual_id = qual_id;
	async->args.switch_hash_qualify_data.data = data;
	async->args.switch_hash_qualify_data.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_qualify_udf_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_udf_id_t udf_id,
	int length,
	uint8 * data,
	uint8 * mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_QUALIFY_UDF;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_qualify_udf.unit = unit;
	async->args.switch_hash_qualify_udf.entry = entry;
	async->args.switch_hash_qualify_udf.udf_id = udf_id;
	async->args.switch_hash_qualify_udf.length = length;
	async->args.switch_hash_qualify_udf.data = data;
	async->args.switch_hash_qualify_udf.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_hash_qualify_udf_get_async(
	int unit,
	bcm_hash_entry_t entry,
	bcm_udf_id_t udf_id,
	int max_length,
	uint8 * data,
	uint8 * mask,
	int * actual_length,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_HASH_QUALIFY_UDF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_hash_qualify_udf_get.unit = unit;
	async->args.switch_hash_qualify_udf_get.entry = entry;
	async->args.switch_hash_qualify_udf_get.udf_id = udf_id;
	async->args.switch_hash_qualify_udf_get.max_length = max_length;
	async->args.switch_hash_qualify_udf_get.data = data;
	async->args.switch_hash_qualify_udf_get.mask = mask;
	async->args.switch_hash_qualify_udf_get.actual_length = actual_length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_ipv6_reserved_multicast_addr_get_async(
	int unit,
	bcm_ip6_t * ip6_addr,
	bcm_ip6_t * ip6_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_IPV6_RESERVED_MULTICAST_ADDR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_ipv6_reserved_multicast_addr_get.unit = unit;
	async->args.switch_ipv6_reserved_multicast_addr_get.ip6_addr = ip6_addr;
	async->args.switch_ipv6_reserved_multicast_addr_get.ip6_mask = ip6_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_ipv6_reserved_multicast_addr_set_async(
	int unit,
	bcm_ip6_t ip6_addr,
	bcm_ip6_t ip6_mask,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_IPV6_RESERVED_MULTICAST_ADDR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_ipv6_reserved_multicast_addr_set.unit = unit;
	async->args.switch_ipv6_reserved_multicast_addr_set.ip6_addr = (uint8 *)ip6_addr;
	async->args.switch_ipv6_reserved_multicast_addr_set.ip6_mask = (uint8 *)ip6_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_l3_protocol_group_get_async(
	int unit,
	uint32 * group_members,
	bcm_l3_protocol_group_id_t * group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_L3_PROTOCOL_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_l3_protocol_group_get.unit = unit;
	async->args.switch_l3_protocol_group_get.group_members = group_members;
	async->args.switch_l3_protocol_group_get.group_id = group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_l3_protocol_group_set_async(
	int unit,
	uint32 group_members,
	bcm_l3_protocol_group_id_t group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_L3_PROTOCOL_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_l3_protocol_group_set.unit = unit;
	async->args.switch_l3_protocol_group_set.group_members = group_members;
	async->args.switch_l3_protocol_group_set.group_id = group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_lif_property_get_async(
	int unit,
	bcm_switch_lif_property_t lif_property,
	bcm_switch_lif_property_config_t * lif_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_LIF_PROPERTY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_lif_property_get.unit = unit;
	async->args.switch_lif_property_get.lif_property = lif_property;
	async->args.switch_lif_property_get.lif_config = lif_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_lif_property_set_async(
	int unit,
	bcm_switch_lif_property_t lif_property,
	bcm_switch_lif_property_config_t * lif_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_LIF_PROPERTY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_lif_property_set.unit = unit;
	async->args.switch_lif_property_set.lif_property = lif_property;
	async->args.switch_lif_property_set.lif_config = lif_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_add_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_switch_match_config_info_t * config_info,
	int * match_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_add.unit = unit;
	async->args.switch_match_config_add.match_service = match_service;
	async->args.switch_match_config_add.config_info = config_info;
	async->args.switch_match_config_add.match_id = match_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_delete_async(
	int unit,
	bcm_switch_match_service_t match_service,
	int match_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_delete.unit = unit;
	async->args.switch_match_config_delete.match_service = match_service;
	async->args.switch_match_config_delete.match_id = match_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_delete_all_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_delete_all.unit = unit;
	async->args.switch_match_config_delete_all.match_service = match_service;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_get_async(
	int unit,
	bcm_switch_match_service_t match_service,
	int match_id,
	bcm_switch_match_config_info_t * config_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_get.unit = unit;
	async->args.switch_match_config_get.match_service = match_service;
	async->args.switch_match_config_get.match_id = match_id;
	async->args.switch_match_config_get.config_info = config_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_set_async(
	int unit,
	bcm_switch_match_service_t match_service,
	int match_id,
	bcm_switch_match_config_info_t * config_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_set.unit = unit;
	async->args.switch_match_config_set.match_service = match_service;
	async->args.switch_match_config_set.match_id = match_id;
	async->args.switch_match_config_set.config_info = config_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_config_traverse_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_switch_match_config_traverse_cb cb_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONFIG_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_config_traverse.unit = unit;
	async->args.switch_match_config_traverse.match_service = match_service;
	async->args.switch_match_config_traverse.cb_fn = cb_fn;
	async->args.switch_match_config_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_control_get_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_switch_match_control_type_t control_type,
	bcm_gport_t gport,
	bcm_switch_match_control_info_t * control_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_control_get.unit = unit;
	async->args.switch_match_control_get.match_service = match_service;
	async->args.switch_match_control_get.control_type = control_type;
	async->args.switch_match_control_get.gport = gport;
	async->args.switch_match_control_get.control_info = control_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_control_set_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_switch_match_control_type_t control_type,
	bcm_gport_t gport,
	bcm_switch_match_control_info_t * control_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_control_set.unit = unit;
	async->args.switch_match_control_set.match_service = match_service;
	async->args.switch_match_control_set.control_type = control_type;
	async->args.switch_match_control_set.gport = gport;
	async->args.switch_match_control_set.control_info = control_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_match_control_traverse_async(
	int unit,
	bcm_switch_match_service_t match_service,
	bcm_switch_match_control_traverse_cb cb_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_MATCH_CONTROL_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_match_control_traverse.unit = unit;
	async->args.switch_match_control_traverse.match_service = match_service;
	async->args.switch_match_control_traverse.cb_fn = cb_fn;
	async->args.switch_match_control_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_network_group_config_get_async(
	int unit,
	bcm_switch_network_group_t source_network_group_id,
	bcm_switch_network_group_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_NETWORK_GROUP_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_network_group_config_get.unit = unit;
	async->args.switch_network_group_config_get.source_network_group_id = source_network_group_id;
	async->args.switch_network_group_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_network_group_config_set_async(
	int unit,
	bcm_switch_network_group_t source_network_group_id,
	bcm_switch_network_group_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_NETWORK_GROUP_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_network_group_config_set.unit = unit;
	async->args.switch_network_group_config_set.source_network_group_id = source_network_group_id;
	async->args.switch_network_group_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_object_count_get_async(
	int unit,
	bcm_switch_object_t object,
	int * entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OBJECT_COUNT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_object_count_get.unit = unit;
	async->args.switch_object_count_get.object = object;
	async->args.switch_object_count_get.entries = entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_object_count_multi_get_async(
	int unit,
	int object_size,
	bcm_switch_object_t * object_array,
	int * entries,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OBJECT_COUNT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_object_count_multi_get.unit = unit;
	async->args.switch_object_count_multi_get.object_size = object_size;
	async->args.switch_object_count_multi_get.object_array = object_array;
	async->args.switch_object_count_multi_get.entries = entries;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_olp_l2_addr_add_async(
	int unit,
	uint32 options,
	bcm_switch_olp_l2_addr_t * l2_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OLP_L2_ADDR_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_olp_l2_addr_add.unit = unit;
	async->args.switch_olp_l2_addr_add.options = options;
	async->args.switch_olp_l2_addr_add.l2_addr = l2_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_olp_l2_addr_delete_async(
	int unit,
	bcm_switch_olp_l2_addr_t * l2_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OLP_L2_ADDR_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_olp_l2_addr_delete.unit = unit;
	async->args.switch_olp_l2_addr_delete.l2_addr = l2_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_olp_l2_addr_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OLP_L2_ADDR_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_olp_l2_addr_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_olp_l2_addr_get_async(
	int unit,
	bcm_switch_olp_l2_addr_t * l2_addr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OLP_L2_ADDR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_olp_l2_addr_get.unit = unit;
	async->args.switch_olp_l2_addr_get.l2_addr = l2_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_olp_l2_addr_traverse_async(
	int unit,
	bcm_switch_olp_l2_addr_traverse_cb cb_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_OLP_L2_ADDR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_olp_l2_addr_traverse.unit = unit;
	async->args.switch_olp_l2_addr_traverse.cb_fn = cb_fn;
	async->args.switch_olp_l2_addr_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_pkt_info_hash_get_async(
	int unit,
	bcm_switch_pkt_info_t * pkt_info,
	bcm_gport_t * dst_gport,
	bcm_if_t * dst_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_PKT_INFO_HASH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_pkt_info_hash_get.unit = unit;
	async->args.switch_pkt_info_hash_get.pkt_info = pkt_info;
	async->args.switch_pkt_info_hash_get.dst_gport = dst_gport;
	async->args.switch_pkt_info_hash_get.dst_intf = dst_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_pkt_trace_info_get_async(
	int unit,
	uint32 options,
	uint8 port,
	int len,
	uint8 * data,
	bcm_switch_pkt_trace_info_t * pkt_trace_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_PKT_TRACE_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_pkt_trace_info_get.unit = unit;
	async->args.switch_pkt_trace_info_get.options = options;
	async->args.switch_pkt_trace_info_get.port = port;
	async->args.switch_pkt_trace_info_get.len = len;
	async->args.switch_pkt_trace_info_get.data = data;
	async->args.switch_pkt_trace_info_get.pkt_trace_info = pkt_trace_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_rcpu_decap_priority_map_get_async(
	int unit,
	int decap_pri,
	int * internal_cpu_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_RCPU_DECAP_PRIORITY_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_decap_priority_map_get.unit = unit;
	async->args.switch_rcpu_decap_priority_map_get.decap_pri = decap_pri;
	async->args.switch_rcpu_decap_priority_map_get.internal_cpu_pri = internal_cpu_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_rcpu_decap_priority_map_set_async(
	int unit,
	int decap_pri,
	int internal_cpu_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_RCPU_DECAP_PRIORITY_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_decap_priority_map_set.unit = unit;
	async->args.switch_rcpu_decap_priority_map_set.decap_pri = decap_pri;
	async->args.switch_rcpu_decap_priority_map_set.internal_cpu_pri = internal_cpu_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_rcpu_encap_priority_map_get_async(
	int unit,
	uint32 flags,
	int internal_cpu_pri,
	int * encap_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_RCPU_ENCAP_PRIORITY_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_encap_priority_map_get.unit = unit;
	async->args.switch_rcpu_encap_priority_map_get.flags = flags;
	async->args.switch_rcpu_encap_priority_map_get.internal_cpu_pri = internal_cpu_pri;
	async->args.switch_rcpu_encap_priority_map_get.encap_pri = encap_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_rcpu_encap_priority_map_set_async(
	int unit,
	uint32 flags,
	int internal_cpu_pri,
	int encap_pri,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_RCPU_ENCAP_PRIORITY_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_encap_priority_map_set.unit = unit;
	async->args.switch_rcpu_encap_priority_map_set.flags = flags;
	async->args.switch_rcpu_encap_priority_map_set.internal_cpu_pri = internal_cpu_pri;
	async->args.switch_rcpu_encap_priority_map_set.encap_pri = encap_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_rov_get_async(
	int unit,
	uint32 flags,
	uint32 * rov,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_ROV_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rov_get.unit = unit;
	async->args.switch_rov_get.flags = flags;
	async->args.switch_rov_get.rov = rov;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_service_get_async(
	int unit,
	bcm_switch_service_t service,
	bcm_switch_service_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_SERVICE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_service_get.unit = unit;
	async->args.switch_service_get.service = service;
	async->args.switch_service_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_service_set_async(
	int unit,
	bcm_switch_service_t service,
	bcm_switch_service_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_SERVICE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_service_set.unit = unit;
	async->args.switch_service_set.service = service;
	async->args.switch_service_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_stable_register_async(
	int unit,
	bcm_switch_read_func_t rf,
	bcm_switch_write_func_t wf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_STABLE_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_stable_register.unit = unit;
	async->args.switch_stable_register.rf = rf;
	async->args.switch_stable_register.wf = wf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_temperature_monitor_get_async(
	int unit,
	int temperature_max,
	bcm_switch_temperature_monitor_t * temperature_array,
	int * temperature_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TEMPERATURE_MONITOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_temperature_monitor_get.unit = unit;
	async->args.switch_temperature_monitor_get.temperature_max = temperature_max;
	async->args.switch_temperature_monitor_get.temperature_array = temperature_array;
	async->args.switch_temperature_monitor_get.temperature_count = temperature_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_thermo_sensor_read_async(
	int unit,
	bcm_switch_thermo_sensor_type_t sensor_type,
	int interface_id,
	bcm_switch_thermo_sensor_t * sensor_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_THERMO_SENSOR_READ;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_thermo_sensor_read.unit = unit;
	async->args.switch_thermo_sensor_read.sensor_type = sensor_type;
	async->args.switch_thermo_sensor_read.interface_id = interface_id;
	async->args.switch_thermo_sensor_read.sensor_data = sensor_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_add_async(
	int unit,
	uint32 options,
	bcm_switch_tpid_info_t * tpid_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_add.unit = unit;
	async->args.switch_tpid_add.options = options;
	async->args.switch_tpid_add.tpid_info = tpid_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_class_get_async(
	int unit,
	bcm_switch_tpid_class_t * tpid_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_class_get.unit = unit;
	async->args.switch_tpid_class_get.tpid_class = tpid_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_delete_async(
	int unit,
	bcm_switch_tpid_info_t * tpid_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_delete.unit = unit;
	async->args.switch_tpid_delete.tpid_info = tpid_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_get_async(
	int unit,
	bcm_switch_tpid_info_t * tpid_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_get.unit = unit;
	async->args.switch_tpid_get.tpid_info = tpid_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_tpid_get_all_async(
	int unit,
	int size,
	bcm_switch_tpid_info_t * tpid_info_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_TPID_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_tpid_get_all.unit = unit;
	async->args.switch_tpid_get_all.size = size;
	async->args.switch_tpid_get_all.tpid_info_array = tpid_info_array;
	async->args.switch_tpid_get_all.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_user_buffer_read_async(
	int unit,
	uint32 flags,
	bcm_switch_user_buffer_type_t buff_type,
	uint8 * buf,
	int offset,
	int nbytes,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_USER_BUFFER_READ;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_user_buffer_read.unit = unit;
	async->args.switch_user_buffer_read.flags = flags;
	async->args.switch_user_buffer_read.buff_type = buff_type;
	async->args.switch_user_buffer_read.buf = buf;
	async->args.switch_user_buffer_read.offset = offset;
	async->args.switch_user_buffer_read.nbytes = nbytes;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_switch_user_buffer_write_async(
	int unit,
	uint32 flags,
	bcm_switch_user_buffer_type_t buff_type,
	uint8 * buf,
	int offset,
	int nbytes,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_SWITCH_USER_BUFFER_WRITE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_user_buffer_write.unit = unit;
	async->args.switch_user_buffer_write.flags = flags;
	async->args.switch_user_buffer_write.buff_type = buff_type;
	async->args.switch_user_buffer_write.buf = buf;
	async->args.switch_user_buffer_write.offset = offset;
	async->args.switch_user_buffer_write.nbytes = nbytes;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_PTP

void
bcm_tdpll_dpll_bandwidth_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_bandwidth_t * bandwidth,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_BANDWIDTH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_bandwidth_get.unit = unit;
	async->args.tdpll_dpll_bandwidth_get.stack_id = stack_id;
	async->args.tdpll_dpll_bandwidth_get.dpll_index = dpll_index;
	async->args.tdpll_dpll_bandwidth_get.bandwidth = bandwidth;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_bandwidth_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_bandwidth_t * bandwidth,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_BANDWIDTH_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_bandwidth_set.unit = unit;
	async->args.tdpll_dpll_bandwidth_set.stack_id = stack_id;
	async->args.tdpll_dpll_bandwidth_set.dpll_index = dpll_index;
	async->args.tdpll_dpll_bandwidth_set.bandwidth = bandwidth;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_bindings_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_bindings_t * bindings,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_BINDINGS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_bindings_get.unit = unit;
	async->args.tdpll_dpll_bindings_get.stack_id = stack_id;
	async->args.tdpll_dpll_bindings_get.dpll_index = dpll_index;
	async->args.tdpll_dpll_bindings_get.bindings = bindings;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_bindings_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_bindings_t * bindings,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_BINDINGS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_bindings_set.unit = unit;
	async->args.tdpll_dpll_bindings_set.stack_id = stack_id;
	async->args.tdpll_dpll_bindings_set.dpll_index = dpll_index;
	async->args.tdpll_dpll_bindings_set.bindings = bindings;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_phase_control_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_phase_control_t * phase_control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_PHASE_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_phase_control_get.unit = unit;
	async->args.tdpll_dpll_phase_control_get.stack_id = stack_id;
	async->args.tdpll_dpll_phase_control_get.dpll_index = dpll_index;
	async->args.tdpll_dpll_phase_control_get.phase_control = phase_control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_phase_control_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_tdpll_dpll_phase_control_t * phase_control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_PHASE_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_phase_control_set.unit = unit;
	async->args.tdpll_dpll_phase_control_set.stack_id = stack_id;
	async->args.tdpll_dpll_phase_control_set.dpll_index = dpll_index;
	async->args.tdpll_dpll_phase_control_set.phase_control = phase_control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_dpll_reference_get_async(
	int unit,
	int stack_id,
	int max_num_dpll,
	int * dpll_ref,
	int * num_dpll,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_DPLL_REFERENCE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_dpll_reference_get.unit = unit;
	async->args.tdpll_dpll_reference_get.stack_id = stack_id;
	async->args.tdpll_dpll_reference_get.max_num_dpll = max_num_dpll;
	async->args.tdpll_dpll_reference_get.dpll_ref = dpll_ref;
	async->args.tdpll_dpll_reference_get.num_dpll = num_dpll;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_holdover_ql_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_esmc_quality_level_t * ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_HOLDOVER_QL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_holdover_ql_get.unit = unit;
	async->args.tdpll_esmc_holdover_ql_get.stack_id = stack_id;
	async->args.tdpll_esmc_holdover_ql_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_holdover_ql_get.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_holdover_ql_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_esmc_quality_level_t ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_HOLDOVER_QL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_holdover_ql_set.unit = unit;
	async->args.tdpll_esmc_holdover_ql_set.stack_id = stack_id;
	async->args.tdpll_esmc_holdover_ql_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_holdover_ql_set.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_mac_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_mac_get.unit = unit;
	async->args.tdpll_esmc_mac_get.stack_id = stack_id;
	async->args.tdpll_esmc_mac_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_mac_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_MAC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_mac_set.unit = unit;
	async->args.tdpll_esmc_mac_set.stack_id = stack_id;
	async->args.tdpll_esmc_mac_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_mac_set.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_ql_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_esmc_quality_level_t * ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_QL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_ql_get.unit = unit;
	async->args.tdpll_esmc_ql_get.stack_id = stack_id;
	async->args.tdpll_esmc_ql_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_ql_get.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_ql_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_esmc_quality_level_t ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_QL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_ql_set.unit = unit;
	async->args.tdpll_esmc_ql_set.stack_id = stack_id;
	async->args.tdpll_esmc_ql_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_ql_set.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_rx_enable_get_async(
	int unit,
	int stack_id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_RX_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_rx_enable_get.unit = unit;
	async->args.tdpll_esmc_rx_enable_get.stack_id = stack_id;
	async->args.tdpll_esmc_rx_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_rx_enable_set_async(
	int unit,
	int stack_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_RX_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_rx_enable_set.unit = unit;
	async->args.tdpll_esmc_rx_enable_set.stack_id = stack_id;
	async->args.tdpll_esmc_rx_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_rx_portbitmap_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_RX_PORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_rx_portbitmap_get.unit = unit;
	async->args.tdpll_esmc_rx_portbitmap_get.stack_id = stack_id;
	async->args.tdpll_esmc_rx_portbitmap_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_rx_portbitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_rx_portbitmap_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_RX_PORTBITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_rx_portbitmap_set.unit = unit;
	async->args.tdpll_esmc_rx_portbitmap_set.stack_id = stack_id;
	async->args.tdpll_esmc_rx_portbitmap_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_rx_portbitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_rx_state_machine_async(
	int unit,
	int stack_id,
	int ingress_port,
	bcm_esmc_pdu_data_t * esmc_pdu_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_RX_STATE_MACHINE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_rx_state_machine.unit = unit;
	async->args.tdpll_esmc_rx_state_machine.stack_id = stack_id;
	async->args.tdpll_esmc_rx_state_machine.ingress_port = ingress_port;
	async->args.tdpll_esmc_rx_state_machine.esmc_pdu_data = esmc_pdu_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_tx_enable_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_TX_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_tx_enable_get.unit = unit;
	async->args.tdpll_esmc_tx_enable_get.stack_id = stack_id;
	async->args.tdpll_esmc_tx_enable_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_tx_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_tx_enable_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_TX_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_tx_enable_set.unit = unit;
	async->args.tdpll_esmc_tx_enable_set.stack_id = stack_id;
	async->args.tdpll_esmc_tx_enable_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_tx_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_tx_portbitmap_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_TX_PORTBITMAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_tx_portbitmap_get.unit = unit;
	async->args.tdpll_esmc_tx_portbitmap_get.stack_id = stack_id;
	async->args.tdpll_esmc_tx_portbitmap_get.dpll_index = dpll_index;
	async->args.tdpll_esmc_tx_portbitmap_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_esmc_tx_portbitmap_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_ESMC_TX_PORTBITMAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_esmc_tx_portbitmap_set.unit = unit;
	async->args.tdpll_esmc_tx_portbitmap_set.stack_id = stack_id;
	async->args.tdpll_esmc_tx_portbitmap_set.dpll_index = dpll_index;
	async->args.tdpll_esmc_tx_portbitmap_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_best_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	int * best_clock,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_BEST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_best_get.unit = unit;
	async->args.tdpll_input_clock_best_get.stack_id = stack_id;
	async->args.tdpll_input_clock_best_get.dpll_index = dpll_index;
	async->args.tdpll_input_clock_best_get.best_clock = best_clock;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_control_async(
	int unit,
	int stack_id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_CONTROL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_control.unit = unit;
	async->args.tdpll_input_clock_control.stack_id = stack_id;
	async->args.tdpll_input_clock_control.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_enable_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_enable_get.unit = unit;
	async->args.tdpll_input_clock_enable_get.stack_id = stack_id;
	async->args.tdpll_input_clock_enable_get.clock_index = clock_index;
	async->args.tdpll_input_clock_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_enable_set_async(
	int unit,
	int stack_id,
	int clock_index,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_enable_set.unit = unit;
	async->args.tdpll_input_clock_enable_set.stack_id = stack_id;
	async->args.tdpll_input_clock_enable_set.clock_index = clock_index;
	async->args.tdpll_input_clock_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_frequency_error_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * freq_error_ppb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_FREQUENCY_ERROR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_frequency_error_get.unit = unit;
	async->args.tdpll_input_clock_frequency_error_get.stack_id = stack_id;
	async->args.tdpll_input_clock_frequency_error_get.clock_index = clock_index;
	async->args.tdpll_input_clock_frequency_error_get.freq_error_ppb = freq_error_ppb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_frequency_get_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 * clock_frequency,
	uint32 * tsevent_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_FREQUENCY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_frequency_get.unit = unit;
	async->args.tdpll_input_clock_frequency_get.stack_id = stack_id;
	async->args.tdpll_input_clock_frequency_get.clock_index = clock_index;
	async->args.tdpll_input_clock_frequency_get.clock_frequency = clock_frequency;
	async->args.tdpll_input_clock_frequency_get.tsevent_frequency = tsevent_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_frequency_set_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 clock_frequency,
	uint32 tsevent_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_FREQUENCY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_frequency_set.unit = unit;
	async->args.tdpll_input_clock_frequency_set.stack_id = stack_id;
	async->args.tdpll_input_clock_frequency_set.clock_index = clock_index;
	async->args.tdpll_input_clock_frequency_set.clock_frequency = clock_frequency;
	async->args.tdpll_input_clock_frequency_set.tsevent_frequency = tsevent_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_l1mux_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_input_clock_l1mux_t * l1mux,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_L1MUX_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_l1mux_get.unit = unit;
	async->args.tdpll_input_clock_l1mux_get.stack_id = stack_id;
	async->args.tdpll_input_clock_l1mux_get.clock_index = clock_index;
	async->args.tdpll_input_clock_l1mux_get.l1mux = l1mux;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_l1mux_set_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_input_clock_l1mux_t * l1mux,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_L1MUX_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_l1mux_set.unit = unit;
	async->args.tdpll_input_clock_l1mux_set.stack_id = stack_id;
	async->args.tdpll_input_clock_l1mux_set.clock_index = clock_index;
	async->args.tdpll_input_clock_l1mux_set.l1mux = l1mux;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_lockout_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * lockout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_LOCKOUT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_lockout_get.unit = unit;
	async->args.tdpll_input_clock_lockout_get.stack_id = stack_id;
	async->args.tdpll_input_clock_lockout_get.clock_index = clock_index;
	async->args.tdpll_input_clock_lockout_get.lockout = lockout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_lockout_set_async(
	int unit,
	int stack_id,
	int clock_index,
	int lockout,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_LOCKOUT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_lockout_set.unit = unit;
	async->args.tdpll_input_clock_lockout_set.stack_id = stack_id;
	async->args.tdpll_input_clock_lockout_set.clock_index = clock_index;
	async->args.tdpll_input_clock_lockout_set.lockout = lockout;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_mac_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MAC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_mac_get.unit = unit;
	async->args.tdpll_input_clock_mac_get.stack_id = stack_id;
	async->args.tdpll_input_clock_mac_get.clock_index = clock_index;
	async->args.tdpll_input_clock_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_mac_set_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_mac_t * mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MAC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_mac_set.unit = unit;
	async->args.tdpll_input_clock_mac_set.stack_id = stack_id;
	async->args.tdpll_input_clock_mac_set.clock_index = clock_index;
	async->args.tdpll_input_clock_mac_set.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_callback_register_async(
	int unit,
	int stack_id,
	bcm_tdpll_input_clock_monitor_cb monitor_cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_CALLBACK_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_callback_register.unit = unit;
	async->args.tdpll_input_clock_monitor_callback_register.stack_id = stack_id;
	async->args.tdpll_input_clock_monitor_callback_register.monitor_cb = monitor_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_callback_unregister_async(
	int unit,
	int stack_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_CALLBACK_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_callback_unregister.unit = unit;
	async->args.tdpll_input_clock_monitor_callback_unregister.stack_id = stack_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_interval_get_async(
	int unit,
	int stack_id,
	uint32 * monitor_interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_INTERVAL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_interval_get.unit = unit;
	async->args.tdpll_input_clock_monitor_interval_get.stack_id = stack_id;
	async->args.tdpll_input_clock_monitor_interval_get.monitor_interval = monitor_interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_interval_set_async(
	int unit,
	int stack_id,
	uint32 monitor_interval,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_INTERVAL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_interval_set.unit = unit;
	async->args.tdpll_input_clock_monitor_interval_set.stack_id = stack_id;
	async->args.tdpll_input_clock_monitor_interval_set.monitor_interval = monitor_interval;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_threshold_get_async(
	int unit,
	int stack_id,
	bcm_tdpll_input_clock_monitor_type_t threshold_type,
	uint32 * threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_threshold_get.unit = unit;
	async->args.tdpll_input_clock_monitor_threshold_get.stack_id = stack_id;
	async->args.tdpll_input_clock_monitor_threshold_get.threshold_type = threshold_type;
	async->args.tdpll_input_clock_monitor_threshold_get.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_monitor_threshold_set_async(
	int unit,
	int stack_id,
	bcm_tdpll_input_clock_monitor_type_t threshold_type,
	uint32 threshold,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_MONITOR_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_monitor_threshold_set.unit = unit;
	async->args.tdpll_input_clock_monitor_threshold_set.stack_id = stack_id;
	async->args.tdpll_input_clock_monitor_threshold_set.threshold_type = threshold_type;
	async->args.tdpll_input_clock_monitor_threshold_set.threshold = threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_priority_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_PRIORITY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_priority_get.unit = unit;
	async->args.tdpll_input_clock_priority_get.stack_id = stack_id;
	async->args.tdpll_input_clock_priority_get.clock_index = clock_index;
	async->args.tdpll_input_clock_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_priority_set_async(
	int unit,
	int stack_id,
	int clock_index,
	int priority,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_PRIORITY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_priority_set.unit = unit;
	async->args.tdpll_input_clock_priority_set.stack_id = stack_id;
	async->args.tdpll_input_clock_priority_set.clock_index = clock_index;
	async->args.tdpll_input_clock_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_ql_enabled_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	int * ql_enabled,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_QL_ENABLED_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_ql_enabled_get.unit = unit;
	async->args.tdpll_input_clock_ql_enabled_get.stack_id = stack_id;
	async->args.tdpll_input_clock_ql_enabled_get.dpll_index = dpll_index;
	async->args.tdpll_input_clock_ql_enabled_get.ql_enabled = ql_enabled;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_ql_enabled_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	int ql_enabled,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_QL_ENABLED_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_ql_enabled_set.unit = unit;
	async->args.tdpll_input_clock_ql_enabled_set.stack_id = stack_id;
	async->args.tdpll_input_clock_ql_enabled_set.dpll_index = dpll_index;
	async->args.tdpll_input_clock_ql_enabled_set.ql_enabled = ql_enabled;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_ql_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_esmc_quality_level_t * ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_QL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_ql_get.unit = unit;
	async->args.tdpll_input_clock_ql_get.stack_id = stack_id;
	async->args.tdpll_input_clock_ql_get.clock_index = clock_index;
	async->args.tdpll_input_clock_ql_get.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_ql_set_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_esmc_quality_level_t ql,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_QL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_ql_set.unit = unit;
	async->args.tdpll_input_clock_ql_set.stack_id = stack_id;
	async->args.tdpll_input_clock_ql_set.clock_index = clock_index;
	async->args.tdpll_input_clock_ql_set.ql = ql;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_revertive_get_async(
	int unit,
	int stack_id,
	int dpll_index,
	int * revertive,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_REVERTIVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_revertive_get.unit = unit;
	async->args.tdpll_input_clock_revertive_get.stack_id = stack_id;
	async->args.tdpll_input_clock_revertive_get.dpll_index = dpll_index;
	async->args.tdpll_input_clock_revertive_get.revertive = revertive;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_revertive_set_async(
	int unit,
	int stack_id,
	int dpll_index,
	int revertive,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_REVERTIVE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_revertive_set.unit = unit;
	async->args.tdpll_input_clock_revertive_set.stack_id = stack_id;
	async->args.tdpll_input_clock_revertive_set.dpll_index = dpll_index;
	async->args.tdpll_input_clock_revertive_set.revertive = revertive;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_selector_callback_register_async(
	int unit,
	int stack_id,
	bcm_tdpll_input_clock_selector_cb selector_cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_SELECTOR_CALLBACK_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_selector_callback_register.unit = unit;
	async->args.tdpll_input_clock_selector_callback_register.stack_id = stack_id;
	async->args.tdpll_input_clock_selector_callback_register.selector_cb = selector_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_selector_callback_unregister_async(
	int unit,
	int stack_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_SELECTOR_CALLBACK_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_selector_callback_unregister.unit = unit;
	async->args.tdpll_input_clock_selector_callback_unregister.stack_id = stack_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_threshold_state_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_input_clock_monitor_type_t threshold_type,
	int * threshold_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_THRESHOLD_STATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_threshold_state_get.unit = unit;
	async->args.tdpll_input_clock_threshold_state_get.stack_id = stack_id;
	async->args.tdpll_input_clock_threshold_state_get.clock_index = clock_index;
	async->args.tdpll_input_clock_threshold_state_get.threshold_type = threshold_type;
	async->args.tdpll_input_clock_threshold_state_get.threshold_state = threshold_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_valid_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * valid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_VALID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_valid_get.unit = unit;
	async->args.tdpll_input_clock_valid_get.stack_id = stack_id;
	async->args.tdpll_input_clock_valid_get.clock_index = clock_index;
	async->args.tdpll_input_clock_valid_get.valid = valid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_input_clock_valid_set_async(
	int unit,
	int stack_id,
	int clock_index,
	int valid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_INPUT_CLOCK_VALID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_input_clock_valid_set.unit = unit;
	async->args.tdpll_input_clock_valid_set.stack_id = stack_id;
	async->args.tdpll_input_clock_valid_set.clock_index = clock_index;
	async->args.tdpll_input_clock_valid_set.valid = valid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_deriv_frequency_get_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 * deriv_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_DERIV_FREQUENCY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_deriv_frequency_get.unit = unit;
	async->args.tdpll_output_clock_deriv_frequency_get.stack_id = stack_id;
	async->args.tdpll_output_clock_deriv_frequency_get.clock_index = clock_index;
	async->args.tdpll_output_clock_deriv_frequency_get.deriv_frequency = deriv_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_deriv_frequency_set_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 deriv_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_DERIV_FREQUENCY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_deriv_frequency_set.unit = unit;
	async->args.tdpll_output_clock_deriv_frequency_set.stack_id = stack_id;
	async->args.tdpll_output_clock_deriv_frequency_set.clock_index = clock_index;
	async->args.tdpll_output_clock_deriv_frequency_set.deriv_frequency = deriv_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_enable_get_async(
	int unit,
	int stack_id,
	int clock_index,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_enable_get.unit = unit;
	async->args.tdpll_output_clock_enable_get.stack_id = stack_id;
	async->args.tdpll_output_clock_enable_get.clock_index = clock_index;
	async->args.tdpll_output_clock_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_enable_set_async(
	int unit,
	int stack_id,
	int clock_index,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_enable_set.unit = unit;
	async->args.tdpll_output_clock_enable_set.stack_id = stack_id;
	async->args.tdpll_output_clock_enable_set.clock_index = clock_index;
	async->args.tdpll_output_clock_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_holdover_data_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_holdover_data_t * hdata,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_HOLDOVER_DATA_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_holdover_data_get.unit = unit;
	async->args.tdpll_output_clock_holdover_data_get.stack_id = stack_id;
	async->args.tdpll_output_clock_holdover_data_get.clock_index = clock_index;
	async->args.tdpll_output_clock_holdover_data_get.hdata = hdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_holdover_frequency_set_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_frequency_correction_t hfreq,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_HOLDOVER_FREQUENCY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_holdover_frequency_set.unit = unit;
	async->args.tdpll_output_clock_holdover_frequency_set.stack_id = stack_id;
	async->args.tdpll_output_clock_holdover_frequency_set.clock_index = clock_index;
	async->args.tdpll_output_clock_holdover_frequency_set.hfreq = hfreq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_holdover_mode_get_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_holdover_mode_t * hmode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_HOLDOVER_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_holdover_mode_get.unit = unit;
	async->args.tdpll_output_clock_holdover_mode_get.stack_id = stack_id;
	async->args.tdpll_output_clock_holdover_mode_get.clock_index = clock_index;
	async->args.tdpll_output_clock_holdover_mode_get.hmode = hmode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_holdover_mode_set_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_tdpll_holdover_mode_t hmode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_HOLDOVER_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_holdover_mode_set.unit = unit;
	async->args.tdpll_output_clock_holdover_mode_set.stack_id = stack_id;
	async->args.tdpll_output_clock_holdover_mode_set.clock_index = clock_index;
	async->args.tdpll_output_clock_holdover_mode_set.hmode = hmode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_holdover_reset_async(
	int unit,
	int stack_id,
	int clock_index,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_HOLDOVER_RESET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_holdover_reset.unit = unit;
	async->args.tdpll_output_clock_holdover_reset.stack_id = stack_id;
	async->args.tdpll_output_clock_holdover_reset.clock_index = clock_index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_synth_frequency_get_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 * synth_frequency,
	uint32 * tsevent_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_SYNTH_FREQUENCY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_synth_frequency_get.unit = unit;
	async->args.tdpll_output_clock_synth_frequency_get.stack_id = stack_id;
	async->args.tdpll_output_clock_synth_frequency_get.clock_index = clock_index;
	async->args.tdpll_output_clock_synth_frequency_get.synth_frequency = synth_frequency;
	async->args.tdpll_output_clock_synth_frequency_get.tsevent_frequency = tsevent_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tdpll_output_clock_synth_frequency_set_async(
	int unit,
	int stack_id,
	int clock_index,
	uint32 synth_frequency,
	uint32 tsevent_frequency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TDPLL_OUTPUT_CLOCK_SYNTH_FREQUENCY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tdpll_output_clock_synth_frequency_set.unit = unit;
	async->args.tdpll_output_clock_synth_frequency_set.stack_id = stack_id;
	async->args.tdpll_output_clock_synth_frequency_set.clock_index = clock_index;
	async->args.tdpll_output_clock_synth_frequency_set.synth_frequency = synth_frequency;
	async->args.tdpll_output_clock_synth_frequency_set.tsevent_frequency = tsevent_frequency;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_PTP */

void
bcm_time_bs_log_configure_get_async(
	int unit,
	bcm_time_bs_log_cfg_t * bs_log_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_BS_LOG_CONFIGURE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_bs_log_configure_get.unit = unit;
	async->args.time_bs_log_configure_get.bs_log_cfg = bs_log_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_bs_log_configure_set_async(
	int unit,
	bcm_time_bs_log_cfg_t bs_log_cfg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_BS_LOG_CONFIGURE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_bs_log_configure_set.unit = unit;
	async->args.time_bs_log_configure_set.bs_log_cfg = bs_log_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_capture_get_async(
	int unit,
	bcm_time_if_t intf_id,
	bcm_time_capture_t * time,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_CAPTURE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_capture_get.unit = unit;
	async->args.time_capture_get.intf_id = intf_id;
	async->args.time_capture_get.time = time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_deinit_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_DEINIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_deinit.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_heartbeat_enable_get_async(
	int unit,
	bcm_time_if_t id,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_HEARTBEAT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_heartbeat_enable_get.unit = unit;
	async->args.time_heartbeat_enable_get.id = id;
	async->args.time_heartbeat_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_heartbeat_enable_set_async(
	int unit,
	bcm_time_if_t id,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_HEARTBEAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_heartbeat_enable_set.unit = unit;
	async->args.time_heartbeat_enable_set.id = id;
	async->args.time_heartbeat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_heartbeat_register_async(
	int unit,
	bcm_time_if_t id,
	bcm_time_heartbeat_cb f,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_HEARTBEAT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_heartbeat_register.unit = unit;
	async->args.time_heartbeat_register.id = id;
	async->args.time_heartbeat_register.f = f;
	async->args.time_heartbeat_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_heartbeat_unregister_async(
	int unit,
	bcm_time_if_t id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_HEARTBEAT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_heartbeat_unregister.unit = unit;
	async->args.time_heartbeat_unregister.id = id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_interface_add_async(
	int unit,
	bcm_time_interface_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INTERFACE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_interface_add.unit = unit;
	async->args.time_interface_add.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_interface_delete_async(
	int unit,
	bcm_time_if_t intf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INTERFACE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_interface_delete.unit = unit;
	async->args.time_interface_delete.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_interface_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INTERFACE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_interface_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_interface_get_async(
	int unit,
	bcm_time_interface_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INTERFACE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_interface_get.unit = unit;
	async->args.time_interface_get.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_interface_traverse_async(
	int unit,
	bcm_time_interface_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_INTERFACE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_interface_traverse.unit = unit;
	async->args.time_interface_traverse.cb = cb;
	async->args.time_interface_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_synce_clock_get_async(
	int unit,
	bcm_time_synce_clock_src_type_t clk_src,
	bcm_time_synce_divisor_setting_t * divisor_setting,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_SYNCE_CLOCK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_synce_clock_get.unit = unit;
	async->args.time_synce_clock_get.clk_src = clk_src;
	async->args.time_synce_clock_get.divisor_setting = divisor_setting;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_synce_clock_set_async(
	int unit,
	bcm_time_synce_clock_src_type_t clk_src,
	bcm_time_synce_divisor_setting_t * divisor_setting,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_SYNCE_CLOCK_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_synce_clock_set.unit = unit;
	async->args.time_synce_clock_set.clk_src = clk_src;
	async->args.time_synce_clock_set.divisor_setting = divisor_setting;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_trigger_enable_get_async(
	int unit,
	bcm_time_if_t id,
	uint32 * mode_flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_TRIGGER_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_trigger_enable_get.unit = unit;
	async->args.time_trigger_enable_get.id = id;
	async->args.time_trigger_enable_get.mode_flags = mode_flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_time_trigger_enable_set_async(
	int unit,
	bcm_time_if_t id,
	uint32 mode_flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TIME_TRIGGER_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.time_trigger_enable_set.unit = unit;
	async->args.time_trigger_enable_set.id = id;
	async->args.time_trigger_enable_set.mode_flags = mode_flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_topo_port_get_async(
	int unit,
	int dest_modid,
	bcm_port_t * exit_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TOPO_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.topo_port_get.unit = unit;
	async->args.topo_port_get.dest_modid = dest_modid;
	async->args.topo_port_get.exit_port = exit_port;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_trill_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_adjacency_add_async(
	int unit,
	bcm_trill_multicast_adjacency_t * trill_multicast_adjacency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ADJACENCY_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_adjacency_add.unit = unit;
	async->args.trill_multicast_adjacency_add.trill_multicast_adjacency = trill_multicast_adjacency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_adjacency_delete_async(
	int unit,
	bcm_trill_multicast_adjacency_t * trill_multicast_adjacency,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ADJACENCY_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_adjacency_delete.unit = unit;
	async->args.trill_multicast_adjacency_delete.trill_multicast_adjacency = trill_multicast_adjacency;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_adjacency_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ADJACENCY_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_adjacency_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_adjacency_traverse_async(
	int unit,
	bcm_trill_multicast_adjacency_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ADJACENCY_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_adjacency_traverse.unit = unit;
	async->args.trill_multicast_adjacency_traverse.cb = cb;
	async->args.trill_multicast_adjacency_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_delete_all_async(
	int unit,
	bcm_trill_name_t root_name,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_delete_all.unit = unit;
	async->args.trill_multicast_delete_all.root_name = root_name;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_entry_add_async(
	int unit,
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_add.unit = unit;
	async->args.trill_multicast_entry_add.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_entry_delete_async(
	int unit,
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_delete.unit = unit;
	async->args.trill_multicast_entry_delete.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_entry_get_async(
	int unit,
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_get.unit = unit;
	async->args.trill_multicast_entry_get.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_entry_traverse_async(
	int unit,
	bcm_trill_multicast_entry_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_traverse.unit = unit;
	async->args.trill_multicast_entry_traverse.cb = cb;
	async->args.trill_multicast_entry_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_source_add_async(
	int unit,
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t port,
	bcm_if_t encap_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_add.unit = unit;
	async->args.trill_multicast_source_add.root_name = root_name;
	async->args.trill_multicast_source_add.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_add.port = port;
	async->args.trill_multicast_source_add.encap_intf = encap_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_source_delete_async(
	int unit,
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t port,
	bcm_if_t encap_intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_delete.unit = unit;
	async->args.trill_multicast_source_delete.root_name = root_name;
	async->args.trill_multicast_source_delete.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_delete.port = port;
	async->args.trill_multicast_source_delete.encap_intf = encap_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_source_get_async(
	int unit,
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t * port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_get.unit = unit;
	async->args.trill_multicast_source_get.root_name = root_name;
	async->args.trill_multicast_source_get.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_multicast_source_traverse_async(
	int unit,
	bcm_trill_multicast_source_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_traverse.unit = unit;
	async->args.trill_multicast_source_traverse.cb = cb;
	async->args.trill_multicast_source_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_port_add_async(
	int unit,
	bcm_trill_port_t * trill_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_add.unit = unit;
	async->args.trill_port_add.trill_port = trill_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_port_delete_async(
	int unit,
	bcm_gport_t trill_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_delete.unit = unit;
	async->args.trill_port_delete.trill_port_id = trill_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_port_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_port_get_async(
	int unit,
	bcm_trill_port_t * trill_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_get.unit = unit;
	async->args.trill_port_get.trill_port = trill_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_port_get_all_async(
	int unit,
	int port_max,
	bcm_trill_port_t * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_PORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_get_all.unit = unit;
	async->args.trill_port_get_all.port_max = port_max;
	async->args.trill_port_get_all.port_array = port_array;
	async->args.trill_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_rbridge_entry_add_async(
	int unit,
	bcm_trill_rbridge_t * trill_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_RBRIDGE_ENTRY_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_rbridge_entry_add.unit = unit;
	async->args.trill_rbridge_entry_add.trill_entry = trill_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_rbridge_entry_delete_async(
	int unit,
	bcm_trill_rbridge_t * trill_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_RBRIDGE_ENTRY_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_rbridge_entry_delete.unit = unit;
	async->args.trill_rbridge_entry_delete.trill_entry = trill_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_rbridge_entry_get_async(
	int unit,
	bcm_trill_rbridge_t * trill_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_RBRIDGE_ENTRY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_rbridge_entry_get.unit = unit;
	async->args.trill_rbridge_entry_get.trill_entry = trill_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_stat_clear_async(
	int unit,
	bcm_port_t port,
	bcm_trill_stat_t stat,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_STAT_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_clear.unit = unit;
	async->args.trill_stat_clear.port = port;
	async->args.trill_stat_clear.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_stat_get_async(
	int unit,
	bcm_port_t port,
	bcm_trill_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_get.unit = unit;
	async->args.trill_stat_get.port = port;
	async->args.trill_stat_get.stat = stat;
	async->args.trill_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_stat_get32_async(
	int unit,
	bcm_port_t port,
	bcm_trill_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_get32.unit = unit;
	async->args.trill_stat_get32.port = port;
	async->args.trill_stat_get32.stat = stat;
	async->args.trill_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_vpn_create_async(
	int unit,
	bcm_trill_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_VPN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_vpn_create.unit = unit;
	async->args.trill_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_vpn_destroy_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_VPN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_vpn_destroy.unit = unit;
	async->args.trill_vpn_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_vpn_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_VPN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_vpn_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_vpn_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_trill_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_vpn_get.unit = unit;
	async->args.trill_vpn_get.vpn = vpn;
	async->args.trill_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trill_vpn_traverse_async(
	int unit,
	bcm_trill_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRILL_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_vpn_traverse.unit = unit;
	async->args.trill_vpn_traverse.cb = cb;
	async->args.trill_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_trunk_agm_attach_async(
	int unit,
	bcm_trunk_t trunk_id,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_AGM_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_agm_attach.unit = unit;
	async->args.trunk_agm_attach.trunk_id = trunk_id;
	async->args.trunk_agm_attach.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_agm_attach_get_async(
	int unit,
	bcm_trunk_t trunk_id,
	bcm_switch_agm_id_t * agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_AGM_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_agm_attach_get.unit = unit;
	async->args.trunk_agm_attach_get.trunk_id = trunk_id;
	async->args.trunk_agm_attach_get.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_agm_detach_async(
	int unit,
	bcm_trunk_t trunk_id,
	bcm_switch_agm_id_t agm_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_AGM_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_agm_detach.unit = unit;
	async->args.trunk_agm_detach.trunk_id = trunk_id;
	async->args.trunk_agm_detach.agm_id = agm_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_bitmap_expand_async(
	int unit,
	bcm_pbmp_t * pbmp_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_BITMAP_EXPAND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_bitmap_expand.unit = unit;
	async->args.trunk_bitmap_expand.pbmp_ptr = pbmp_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_chip_info_get_async(
	int unit,
	bcm_trunk_chip_info_t * ta_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_CHIP_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_chip_info_get.unit = unit;
	async->args.trunk_chip_info_get.ta_info = ta_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_create_async(
	int unit,
	uint32 flags,
	bcm_trunk_t * tid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_create.unit = unit;
	async->args.trunk_create.flags = flags;
	async->args.trunk_create.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_destroy_async(
	int unit,
	bcm_trunk_t tid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_destroy.unit = unit;
	async->args.trunk_destroy.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_egress_get_async(
	int unit,
	bcm_trunk_t tid,
	bcm_pbmp_t * pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_egress_get.unit = unit;
	async->args.trunk_egress_get.tid = tid;
	async->args.trunk_egress_get.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_egress_set_async(
	int unit,
	bcm_trunk_t tid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_EGRESS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_egress_set.unit = unit;
	async->args.trunk_egress_set.tid = tid;
	async->args.trunk_egress_set.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_ethertype_get_async(
	int unit,
	uint32 * flags,
	int ethertype_max,
	int * ethertype_array,
	int * ethertype_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_ETHERTYPE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_ethertype_get.unit = unit;
	async->args.trunk_ethertype_get.flags = flags;
	async->args.trunk_ethertype_get.ethertype_max = ethertype_max;
	async->args.trunk_ethertype_get.ethertype_array = ethertype_array;
	async->args.trunk_ethertype_get.ethertype_count = ethertype_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_ethertype_set_async(
	int unit,
	uint32 flags,
	int ethertype_count,
	int * ethertype_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_ETHERTYPE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_ethertype_set.unit = unit;
	async->args.trunk_ethertype_set.flags = flags;
	async->args.trunk_ethertype_set.ethertype_count = ethertype_count;
	async->args.trunk_ethertype_set.ethertype_array = ethertype_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_failover_get_async(
	int unit,
	bcm_trunk_t tid,
	bcm_gport_t failport,
	int * psc,
	uint32 * flags,
	int array_size,
	bcm_gport_t * fail_to_array,
	int * array_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_FAILOVER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_failover_get.unit = unit;
	async->args.trunk_failover_get.tid = tid;
	async->args.trunk_failover_get.failport = failport;
	async->args.trunk_failover_get.psc = psc;
	async->args.trunk_failover_get.flags = flags;
	async->args.trunk_failover_get.array_size = array_size;
	async->args.trunk_failover_get.fail_to_array = fail_to_array;
	async->args.trunk_failover_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_failover_set_async(
	int unit,
	bcm_trunk_t tid,
	bcm_gport_t failport,
	int psc,
	uint32 flags,
	int count,
	bcm_gport_t * fail_to_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_FAILOVER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_failover_set.unit = unit;
	async->args.trunk_failover_set.tid = tid;
	async->args.trunk_failover_set.failport = failport;
	async->args.trunk_failover_set.psc = psc;
	async->args.trunk_failover_set.flags = flags;
	async->args.trunk_failover_set.count = count;
	async->args.trunk_failover_set.fail_to_array = fail_to_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_find_async(
	int unit,
	bcm_module_t modid,
	bcm_port_t port,
	bcm_trunk_t * tid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_find.unit = unit;
	async->args.trunk_find.modid = modid;
	async->args.trunk_find.port = port;
	async->args.trunk_find.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_get_async(
	int unit,
	bcm_trunk_t tid,
	bcm_trunk_info_t * t_data,
	int member_max,
	bcm_trunk_member_t * member_array,
	int * member_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_get.unit = unit;
	async->args.trunk_get.tid = tid;
	async->args.trunk_get.t_data = t_data;
	async->args.trunk_get.member_max = member_max;
	async->args.trunk_get.member_array = member_array;
	async->args.trunk_get.member_count = member_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_gport_add_async(
	int unit,
	bcm_trunk_t tid,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_gport_add.unit = unit;
	async->args.trunk_gport_add.tid = tid;
	async->args.trunk_gport_add.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_gport_delete_async(
	int unit,
	bcm_trunk_t tid,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_GPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_gport_delete.unit = unit;
	async->args.trunk_gport_delete.tid = tid;
	async->args.trunk_gport_delete.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_gport_delete_all_async(
	int unit,
	bcm_trunk_t tid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_GPORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_gport_delete_all.unit = unit;
	async->args.trunk_gport_delete_all.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_gport_get_all_async(
	int unit,
	bcm_trunk_t tid,
	int gport_size,
	bcm_gport_t * gport_array,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_GPORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_gport_get_all.unit = unit;
	async->args.trunk_gport_get_all.tid = tid;
	async->args.trunk_gport_get_all.gport_size = gport_size;
	async->args.trunk_gport_get_all.gport_array = gport_array;
	async->args.trunk_gport_get_all.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_mcast_join_async(
	int unit,
	bcm_trunk_t tid,
	bcm_vlan_t vid,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MCAST_JOIN;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_mcast_join.unit = unit;
	async->args.trunk_mcast_join.tid = tid;
	async->args.trunk_mcast_join.vid = vid;
	async->args.trunk_mcast_join.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_member_add_async(
	int unit,
	bcm_trunk_t tid,
	bcm_trunk_member_t * member,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MEMBER_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_add.unit = unit;
	async->args.trunk_member_add.tid = tid;
	async->args.trunk_member_add.member = member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_member_delete_async(
	int unit,
	bcm_trunk_t tid,
	bcm_trunk_member_t * member,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MEMBER_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_delete.unit = unit;
	async->args.trunk_member_delete.tid = tid;
	async->args.trunk_member_delete.member = member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_member_delete_all_async(
	int unit,
	bcm_trunk_t tid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MEMBER_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_delete_all.unit = unit;
	async->args.trunk_member_delete_all.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_member_status_get_async(
	int unit,
	bcm_gport_t member,
	int * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MEMBER_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_status_get.unit = unit;
	async->args.trunk_member_status_get.member = member;
	async->args.trunk_member_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_member_status_set_async(
	int unit,
	bcm_gport_t member,
	int status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_MEMBER_STATUS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_status_set.unit = unit;
	async->args.trunk_member_status_set.member = member;
	async->args.trunk_member_status_set.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_ipmc_get_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int idx,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_IPMC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_ipmc_get.unit = unit;
	async->args.trunk_override_ipmc_get.port = port;
	async->args.trunk_override_ipmc_get.tid = tid;
	async->args.trunk_override_ipmc_get.idx = idx;
	async->args.trunk_override_ipmc_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_ipmc_set_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int idx,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_IPMC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_ipmc_set.unit = unit;
	async->args.trunk_override_ipmc_set.port = port;
	async->args.trunk_override_ipmc_set.tid = tid;
	async->args.trunk_override_ipmc_set.idx = idx;
	async->args.trunk_override_ipmc_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_mcast_get_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int idx,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_MCAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_mcast_get.unit = unit;
	async->args.trunk_override_mcast_get.port = port;
	async->args.trunk_override_mcast_get.tid = tid;
	async->args.trunk_override_mcast_get.idx = idx;
	async->args.trunk_override_mcast_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_mcast_set_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int idx,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_MCAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_mcast_set.unit = unit;
	async->args.trunk_override_mcast_set.port = port;
	async->args.trunk_override_mcast_set.tid = tid;
	async->args.trunk_override_mcast_set.idx = idx;
	async->args.trunk_override_mcast_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_ucast_get_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int modid,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_UCAST_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_ucast_get.unit = unit;
	async->args.trunk_override_ucast_get.port = port;
	async->args.trunk_override_ucast_get.tid = tid;
	async->args.trunk_override_ucast_get.modid = modid;
	async->args.trunk_override_ucast_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_ucast_set_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int modid,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_UCAST_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_ucast_set.unit = unit;
	async->args.trunk_override_ucast_set.port = port;
	async->args.trunk_override_ucast_set.tid = tid;
	async->args.trunk_override_ucast_set.modid = modid;
	async->args.trunk_override_ucast_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_vlan_get_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	bcm_vlan_t vid,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_vlan_get.unit = unit;
	async->args.trunk_override_vlan_get.port = port;
	async->args.trunk_override_vlan_get.tid = tid;
	async->args.trunk_override_vlan_get.vid = vid;
	async->args.trunk_override_vlan_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_override_vlan_set_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	bcm_vlan_t vid,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_override_vlan_set.unit = unit;
	async->args.trunk_override_vlan_set.port = port;
	async->args.trunk_override_vlan_set.tid = tid;
	async->args.trunk_override_vlan_set.vid = vid;
	async->args.trunk_override_vlan_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_pool_get_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int * size,
	int weights[BCM_TRUNK_MAX_PORTCNT],
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_POOL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_pool_get.unit = unit;
	async->args.trunk_pool_get.port = port;
	async->args.trunk_pool_get.tid = tid;
	async->args.trunk_pool_get.size = size;
	async->args.trunk_pool_get.weights = (int *)weights;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_pool_set_async(
	int unit,
	bcm_port_t port,
	bcm_trunk_t tid,
	int size,
	const int weights[BCM_TRUNK_MAX_PORTCNT],
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_POOL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_pool_set.unit = unit;
	async->args.trunk_pool_set.port = port;
	async->args.trunk_pool_set.tid = tid;
	async->args.trunk_pool_set.size = size;
	async->args.trunk_pool_set.weights = (int *)weights;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_psc_get_async(
	int unit,
	bcm_trunk_t tid,
	int * psc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_PSC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_psc_get.unit = unit;
	async->args.trunk_psc_get.tid = tid;
	async->args.trunk_psc_get.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_psc_set_async(
	int unit,
	bcm_trunk_t tid,
	int psc,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_PSC_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_psc_set.unit = unit;
	async->args.trunk_psc_set.tid = tid;
	async->args.trunk_psc_set.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_resilient_replace_async(
	int unit,
	uint32 flags,
	bcm_trunk_resilient_entry_t * match_entry,
	int * num_entries,
	bcm_trunk_resilient_entry_t * replace_entry,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_RESILIENT_REPLACE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_resilient_replace.unit = unit;
	async->args.trunk_resilient_replace.flags = flags;
	async->args.trunk_resilient_replace.match_entry = match_entry;
	async->args.trunk_resilient_replace.num_entries = num_entries;
	async->args.trunk_resilient_replace.replace_entry = replace_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_resilient_traverse_async(
	int unit,
	uint32 flags,
	bcm_trunk_resilient_entry_t * match_entry,
	bcm_trunk_resilient_traverse_cb trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_RESILIENT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_resilient_traverse.unit = unit;
	async->args.trunk_resilient_traverse.flags = flags;
	async->args.trunk_resilient_traverse.match_entry = match_entry;
	async->args.trunk_resilient_traverse.trav_fn = trav_fn;
	async->args.trunk_resilient_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_set_async(
	int unit,
	bcm_trunk_t tid,
	bcm_trunk_info_t * trunk_info,
	int member_count,
	bcm_trunk_member_t * member_array,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_set.unit = unit;
	async->args.trunk_set.tid = tid;
	async->args.trunk_set.trunk_info = trunk_info;
	async->args.trunk_set.member_count = member_count;
	async->args.trunk_set.member_array = member_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_trunk_spa_to_system_phys_port_map_get_async(
	int unit,
	uint32 flags,
	uint32 system_port_aggregate,
	bcm_gport_t * gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TRUNK_SPA_TO_SYSTEM_PHYS_PORT_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_spa_to_system_phys_port_map_get.unit = unit;
	async->args.trunk_spa_to_system_phys_port_map_get.flags = flags;
	async->args.trunk_spa_to_system_phys_port_map_get.system_port_aggregate = system_port_aggregate;
	async->args.trunk_spa_to_system_phys_port_map_get.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_control_get_async(
	int unit,
	bcm_tsn_control_t type,
	uint32 * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_control_get.unit = unit;
	async->args.tsn_control_get.type = type;
	async->args.tsn_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_control_set_async(
	int unit,
	bcm_tsn_control_t type,
	uint32 arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_control_set.unit = unit;
	async->args.tsn_control_set.type = type;
	async->args.tsn_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_event_notification_traverse_async(
	int unit,
	bcm_tsn_event_notification_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_EVENT_NOTIFICATION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_event_notification_traverse.unit = unit;
	async->args.tsn_event_notification_traverse.cb = cb;
	async->args.tsn_event_notification_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_event_register_async(
	int unit,
	bcm_tsn_event_type_t event,
	bcm_tsn_event_source_t * src,
	bcm_tsn_event_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_EVENT_REGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_event_register.unit = unit;
	async->args.tsn_event_register.event = event;
	async->args.tsn_event_register.src = src;
	async->args.tsn_event_register.cb = cb;
	async->args.tsn_event_register.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_event_unregister_async(
	int unit,
	bcm_tsn_event_type_t event,
	bcm_tsn_event_source_t * src,
	bcm_tsn_event_cb cb,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_EVENT_UNREGISTER;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_event_unregister.unit = unit;
	async->args.tsn_event_unregister.event = event;
	async->args.tsn_event_unregister.src = src;
	async->args.tsn_event_unregister.cb = cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flow_config_get_async(
	int unit,
	bcm_tsn_flow_t flow_id,
	bcm_tsn_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOW_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flow_config_get.unit = unit;
	async->args.tsn_flow_config_get.flow_id = flow_id;
	async->args.tsn_flow_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flow_config_set_async(
	int unit,
	bcm_tsn_flow_t flow_id,
	bcm_tsn_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOW_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flow_config_set.unit = unit;
	async->args.tsn_flow_config_set.flow_id = flow_id;
	async->args.tsn_flow_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_config_get_async(
	int unit,
	bcm_tsn_flowset_t flowset,
	bcm_tsn_pri_map_t * pri_map,
	bcm_tsn_flow_config_t * default_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_config_get.unit = unit;
	async->args.tsn_flowset_config_get.flowset = flowset;
	async->args.tsn_flowset_config_get.pri_map = pri_map;
	async->args.tsn_flowset_config_get.default_config = default_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_create_async(
	int unit,
	bcm_tsn_pri_map_t pri_map,
	bcm_tsn_flow_config_t * default_config,
	bcm_tsn_flowset_t * flowset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_create.unit = unit;
	async->args.tsn_flowset_create.pri_map = pri_map;
	async->args.tsn_flowset_create.default_config = default_config;
	async->args.tsn_flowset_create.flowset = flowset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_destroy_async(
	int unit,
	bcm_tsn_flowset_t flowset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_destroy.unit = unit;
	async->args.tsn_flowset_destroy.flowset = flowset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_flow_get_async(
	int unit,
	bcm_tsn_flowset_t flowset,
	int index,
	bcm_tsn_flow_t * flow_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_FLOW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_flow_get.unit = unit;
	async->args.tsn_flowset_flow_get.flowset = flowset;
	async->args.tsn_flowset_flow_get.index = index;
	async->args.tsn_flowset_flow_get.flow_id = flow_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_status_get_async(
	int unit,
	bcm_tsn_flowset_t flowset,
	bcm_tsn_flowset_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_status_get.unit = unit;
	async->args.tsn_flowset_status_get.flowset = flowset;
	async->args.tsn_flowset_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_flowset_traverse_async(
	int unit,
	bcm_tsn_flowset_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_FLOWSET_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_flowset_traverse.unit = unit;
	async->args.tsn_flowset_traverse.cb = cb;
	async->args.tsn_flowset_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_ingress_mtu_config_get_async(
	int unit,
	bcm_tsn_ingress_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_INGRESS_MTU_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_ingress_mtu_config_get.unit = unit;
	async->args.tsn_ingress_mtu_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_ingress_mtu_config_set_async(
	int unit,
	bcm_tsn_ingress_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_INGRESS_MTU_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_ingress_mtu_config_set.unit = unit;
	async->args.tsn_ingress_mtu_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_ingress_stu_config_get_async(
	int unit,
	bcm_tsn_ingress_stu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_INGRESS_STU_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_ingress_stu_config_get.unit = unit;
	async->args.tsn_ingress_stu_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_ingress_stu_config_set_async(
	int unit,
	bcm_tsn_ingress_stu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_INGRESS_STU_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_ingress_stu_config_set.unit = unit;
	async->args.tsn_ingress_stu_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_mtu_profile_create_async(
	int unit,
	bcm_tsn_mtu_profile_type_t type,
	bcm_tsn_mtu_config_t * config,
	int * mtu_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_MTU_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_mtu_profile_create.unit = unit;
	async->args.tsn_mtu_profile_create.type = type;
	async->args.tsn_mtu_profile_create.config = config;
	async->args.tsn_mtu_profile_create.mtu_profile_id = mtu_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_mtu_profile_destroy_async(
	int unit,
	int mtu_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_MTU_PROFILE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_mtu_profile_destroy.unit = unit;
	async->args.tsn_mtu_profile_destroy.mtu_profile_id = mtu_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_mtu_profile_get_async(
	int unit,
	int mtu_profile_id,
	bcm_tsn_mtu_profile_type_t * type,
	bcm_tsn_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_MTU_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_mtu_profile_get.unit = unit;
	async->args.tsn_mtu_profile_get.mtu_profile_id = mtu_profile_id;
	async->args.tsn_mtu_profile_get.type = type;
	async->args.tsn_mtu_profile_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_mtu_profile_set_async(
	int unit,
	int mtu_profile_id,
	bcm_tsn_mtu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_MTU_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_mtu_profile_set.unit = unit;
	async->args.tsn_mtu_profile_set.mtu_profile_id = mtu_profile_id;
	async->args.tsn_mtu_profile_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_mtu_profile_traverse_async(
	int unit,
	bcm_tsn_mtu_profile_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_MTU_PROFILE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_mtu_profile_traverse.unit = unit;
	async->args.tsn_mtu_profile_traverse.cb = cb;
	async->args.tsn_mtu_profile_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_control_get_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_control_t type,
	uint32 * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_control_get.unit = unit;
	async->args.tsn_port_control_get.port = port;
	async->args.tsn_port_control_get.type = type;
	async->args.tsn_port_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_control_set_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_control_t type,
	uint32 arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_control_set.unit = unit;
	async->args.tsn_port_control_set.port = port;
	async->args.tsn_port_control_set.type = type;
	async->args.tsn_port_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_get_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_get.unit = unit;
	async->args.tsn_port_stat_get.port = port;
	async->args.tsn_port_stat_get.stat = stat;
	async->args.tsn_port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_get32.unit = unit;
	async->args.tsn_port_stat_get32.port = port;
	async->args.tsn_port_stat_get32.stat = stat;
	async->args.tsn_port_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_multi_get_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_multi_get.unit = unit;
	async->args.tsn_port_stat_multi_get.port = port;
	async->args.tsn_port_stat_multi_get.nstat = nstat;
	async->args.tsn_port_stat_multi_get.stat_arr = stat_arr;
	async->args.tsn_port_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_multi_get32_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_multi_get32.unit = unit;
	async->args.tsn_port_stat_multi_get32.port = port;
	async->args.tsn_port_stat_multi_get32.nstat = nstat;
	async->args.tsn_port_stat_multi_get32.stat_arr = stat_arr;
	async->args.tsn_port_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_multi_set_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_multi_set.unit = unit;
	async->args.tsn_port_stat_multi_set.port = port;
	async->args.tsn_port_stat_multi_set.nstat = nstat;
	async->args.tsn_port_stat_multi_set.stat_arr = stat_arr;
	async->args.tsn_port_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_multi_set32_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_multi_set32.unit = unit;
	async->args.tsn_port_stat_multi_set32.port = port;
	async->args.tsn_port_stat_multi_set32.nstat = nstat;
	async->args.tsn_port_stat_multi_set32.stat_arr = stat_arr;
	async->args.tsn_port_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_set_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_set.unit = unit;
	async->args.tsn_port_stat_set.port = port;
	async->args.tsn_port_stat_set.stat = stat;
	async->args.tsn_port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_set32.unit = unit;
	async->args.tsn_port_stat_set32.port = port;
	async->args.tsn_port_stat_set32.stat = stat;
	async->args.tsn_port_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_sync_get.unit = unit;
	async->args.tsn_port_stat_sync_get.port = port;
	async->args.tsn_port_stat_sync_get.stat = stat;
	async->args.tsn_port_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_sync_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_sync_get32.unit = unit;
	async->args.tsn_port_stat_sync_get32.port = port;
	async->args.tsn_port_stat_sync_get32.stat = stat;
	async->args.tsn_port_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_sync_multi_get_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SYNC_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_sync_multi_get.unit = unit;
	async->args.tsn_port_stat_sync_multi_get.port = port;
	async->args.tsn_port_stat_sync_multi_get.nstat = nstat;
	async->args.tsn_port_stat_sync_multi_get.stat_arr = stat_arr;
	async->args.tsn_port_stat_sync_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_port_stat_sync_multi_get32_async(
	int unit,
	bcm_gport_t port,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PORT_STAT_SYNC_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_port_stat_sync_multi_get32.unit = unit;
	async->args.tsn_port_stat_sync_multi_get32.port = port;
	async->args.tsn_port_stat_sync_multi_get32.nstat = nstat;
	async->args.tsn_port_stat_sync_multi_get32.stat_arr = stat_arr;
	async->args.tsn_port_stat_sync_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_pri_map_create_async(
	int unit,
	bcm_tsn_pri_map_config_t * config,
	bcm_tsn_pri_map_t * map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PRI_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_pri_map_create.unit = unit;
	async->args.tsn_pri_map_create.config = config;
	async->args.tsn_pri_map_create.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_pri_map_destroy_async(
	int unit,
	bcm_tsn_pri_map_t map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PRI_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_pri_map_destroy.unit = unit;
	async->args.tsn_pri_map_destroy.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_pri_map_get_async(
	int unit,
	bcm_tsn_pri_map_t map_id,
	bcm_tsn_pri_map_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PRI_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_pri_map_get.unit = unit;
	async->args.tsn_pri_map_get.map_id = map_id;
	async->args.tsn_pri_map_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_pri_map_set_async(
	int unit,
	bcm_tsn_pri_map_t map_id,
	bcm_tsn_pri_map_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PRI_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_pri_map_set.unit = unit;
	async->args.tsn_pri_map_set.map_id = map_id;
	async->args.tsn_pri_map_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_pri_map_traverse_async(
	int unit,
	bcm_tsn_pri_map_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_PRI_MAP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_pri_map_traverse.unit = unit;
	async->args.tsn_pri_map_traverse.cb = cb;
	async->args.tsn_pri_map_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_enable_async(
	int unit,
	int enable,
	bcm_tsn_sr_auto_learn_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_ENABLE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_enable.unit = unit;
	async->args.tsn_sr_auto_learn_enable.enable = enable;
	async->args.tsn_sr_auto_learn_enable.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_enable_get_async(
	int unit,
	int * enabled,
	bcm_tsn_sr_auto_learn_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_enable_get.unit = unit;
	async->args.tsn_sr_auto_learn_enable_get.enabled = enabled;
	async->args.tsn_sr_auto_learn_enable_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_group_create_async(
	int unit,
	bcm_tsn_sr_auto_learn_group_config_t * config,
	int * group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_group_create.unit = unit;
	async->args.tsn_sr_auto_learn_group_create.config = config;
	async->args.tsn_sr_auto_learn_group_create.group_id = group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_group_destroy_async(
	int unit,
	int group_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_group_destroy.unit = unit;
	async->args.tsn_sr_auto_learn_group_destroy.group_id = group_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_group_get_async(
	int unit,
	int group_id,
	bcm_tsn_sr_auto_learn_group_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_group_get.unit = unit;
	async->args.tsn_sr_auto_learn_group_get.group_id = group_id;
	async->args.tsn_sr_auto_learn_group_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_group_set_async(
	int unit,
	int group_id,
	bcm_tsn_sr_auto_learn_group_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_group_set.unit = unit;
	async->args.tsn_sr_auto_learn_group_set.group_id = group_id;
	async->args.tsn_sr_auto_learn_group_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_auto_learn_group_traverse_async(
	int unit,
	bcm_tsn_sr_auto_learn_group_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_AUTO_LEARN_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_auto_learn_group_traverse.unit = unit;
	async->args.tsn_sr_auto_learn_group_traverse.cb = cb;
	async->args.tsn_sr_auto_learn_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_get.unit = unit;
	async->args.tsn_sr_flow_stat_get.flow = flow;
	async->args.tsn_sr_flow_stat_get.stat = stat;
	async->args.tsn_sr_flow_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_get32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_get32.unit = unit;
	async->args.tsn_sr_flow_stat_get32.flow = flow;
	async->args.tsn_sr_flow_stat_get32.stat = stat;
	async->args.tsn_sr_flow_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_group_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_group_type_t group_type,
	bcm_tsn_stat_group_t * stat_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_group_get.unit = unit;
	async->args.tsn_sr_flow_stat_group_get.flow = flow;
	async->args.tsn_sr_flow_stat_group_get.group_type = group_type;
	async->args.tsn_sr_flow_stat_group_get.stat_group = stat_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_group_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_group_type_t group_type,
	bcm_tsn_stat_group_t stat_group,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_group_set.unit = unit;
	async->args.tsn_sr_flow_stat_group_set.flow = flow;
	async->args.tsn_sr_flow_stat_group_set.group_type = group_type;
	async->args.tsn_sr_flow_stat_group_set.stat_group = stat_group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_multi_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_multi_get.unit = unit;
	async->args.tsn_sr_flow_stat_multi_get.flow = flow;
	async->args.tsn_sr_flow_stat_multi_get.nstat = nstat;
	async->args.tsn_sr_flow_stat_multi_get.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_multi_get32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_multi_get32.unit = unit;
	async->args.tsn_sr_flow_stat_multi_get32.flow = flow;
	async->args.tsn_sr_flow_stat_multi_get32.nstat = nstat;
	async->args.tsn_sr_flow_stat_multi_get32.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_multi_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_multi_set.unit = unit;
	async->args.tsn_sr_flow_stat_multi_set.flow = flow;
	async->args.tsn_sr_flow_stat_multi_set.nstat = nstat;
	async->args.tsn_sr_flow_stat_multi_set.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_multi_set32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_multi_set32.unit = unit;
	async->args.tsn_sr_flow_stat_multi_set32.flow = flow;
	async->args.tsn_sr_flow_stat_multi_set32.nstat = nstat;
	async->args.tsn_sr_flow_stat_multi_set32.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_set.unit = unit;
	async->args.tsn_sr_flow_stat_set.flow = flow;
	async->args.tsn_sr_flow_stat_set.stat = stat;
	async->args.tsn_sr_flow_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_set32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_set32.unit = unit;
	async->args.tsn_sr_flow_stat_set32.flow = flow;
	async->args.tsn_sr_flow_stat_set32.stat = stat;
	async->args.tsn_sr_flow_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_sync_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_sync_get.unit = unit;
	async->args.tsn_sr_flow_stat_sync_get.flow = flow;
	async->args.tsn_sr_flow_stat_sync_get.stat = stat;
	async->args.tsn_sr_flow_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_sync_get32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	bcm_tsn_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_sync_get32.unit = unit;
	async->args.tsn_sr_flow_stat_sync_get32.flow = flow;
	async->args.tsn_sr_flow_stat_sync_get32.stat = stat;
	async->args.tsn_sr_flow_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_sync_multi_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SYNC_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_sync_multi_get.unit = unit;
	async->args.tsn_sr_flow_stat_sync_multi_get.flow = flow;
	async->args.tsn_sr_flow_stat_sync_multi_get.nstat = nstat;
	async->args.tsn_sr_flow_stat_sync_multi_get.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_sync_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flow_stat_sync_multi_get32_async(
	int unit,
	bcm_tsn_sr_flow_t flow,
	int nstat,
	bcm_tsn_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOW_STAT_SYNC_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flow_stat_sync_multi_get32.unit = unit;
	async->args.tsn_sr_flow_stat_sync_multi_get32.flow = flow;
	async->args.tsn_sr_flow_stat_sync_multi_get32.nstat = nstat;
	async->args.tsn_sr_flow_stat_sync_multi_get32.stat_arr = stat_arr;
	async->args.tsn_sr_flow_stat_sync_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flowset_destroy_async(
	int unit,
	bcm_tsn_sr_flowset_t flowset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOWSET_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flowset_destroy.unit = unit;
	async->args.tsn_sr_flowset_destroy.flowset = flowset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flowset_flow_get_async(
	int unit,
	bcm_tsn_sr_flowset_t flowset,
	int index,
	bcm_tsn_sr_flow_t * flow_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOWSET_FLOW_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flowset_flow_get.unit = unit;
	async->args.tsn_sr_flowset_flow_get.flowset = flowset;
	async->args.tsn_sr_flowset_flow_get.index = index;
	async->args.tsn_sr_flowset_flow_get.flow_id = flow_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flowset_status_get_async(
	int unit,
	bcm_tsn_sr_flowset_t flowset,
	bcm_tsn_sr_flowset_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOWSET_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flowset_status_get.unit = unit;
	async->args.tsn_sr_flowset_status_get.flowset = flowset;
	async->args.tsn_sr_flowset_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_flowset_traverse_async(
	int unit,
	int is_rx,
	bcm_tsn_sr_flowset_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_FLOWSET_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_flowset_traverse.unit = unit;
	async->args.tsn_sr_flowset_traverse.is_rx = is_rx;
	async->args.tsn_sr_flowset_traverse.cb = cb;
	async->args.tsn_sr_flowset_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_port_config_get_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_sr_port_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_PORT_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_port_config_get.unit = unit;
	async->args.tsn_sr_port_config_get.port = port;
	async->args.tsn_sr_port_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_port_config_set_async(
	int unit,
	bcm_gport_t port,
	bcm_tsn_sr_port_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_PORT_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_port_config_set.unit = unit;
	async->args.tsn_sr_port_config_set.port = port;
	async->args.tsn_sr_port_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_config_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_rx_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_config_get.unit = unit;
	async->args.tsn_sr_rx_flow_config_get.flow_id = flow_id;
	async->args.tsn_sr_rx_flow_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_config_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_rx_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_config_set.unit = unit;
	async->args.tsn_sr_rx_flow_config_set.flow_id = flow_id;
	async->args.tsn_sr_rx_flow_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_reset_async(
	int unit,
	uint32 flags,
	bcm_tsn_sr_flow_t flow_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_RESET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_reset.unit = unit;
	async->args.tsn_sr_rx_flow_reset.flags = flags;
	async->args.tsn_sr_rx_flow_reset.flow_id = flow_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_seqnum_history_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	int offset_in_bits,
	int max_size_in_bits,
	uint8 * history_bits,
	int * actual_size_in_bits,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_SEQNUM_HISTORY_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_seqnum_history_get.unit = unit;
	async->args.tsn_sr_rx_flow_seqnum_history_get.flow_id = flow_id;
	async->args.tsn_sr_rx_flow_seqnum_history_get.offset_in_bits = offset_in_bits;
	async->args.tsn_sr_rx_flow_seqnum_history_get.max_size_in_bits = max_size_in_bits;
	async->args.tsn_sr_rx_flow_seqnum_history_get.history_bits = history_bits;
	async->args.tsn_sr_rx_flow_seqnum_history_get.actual_size_in_bits = actual_size_in_bits;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_seqnum_history_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	int offset_in_bits,
	int size_in_bits,
	uint8 * history_bits,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_SEQNUM_HISTORY_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_seqnum_history_set.unit = unit;
	async->args.tsn_sr_rx_flow_seqnum_history_set.flow_id = flow_id;
	async->args.tsn_sr_rx_flow_seqnum_history_set.offset_in_bits = offset_in_bits;
	async->args.tsn_sr_rx_flow_seqnum_history_set.size_in_bits = size_in_bits;
	async->args.tsn_sr_rx_flow_seqnum_history_set.history_bits = history_bits;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flow_status_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_rx_flow_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOW_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flow_status_get.unit = unit;
	async->args.tsn_sr_rx_flow_status_get.flow_id = flow_id;
	async->args.tsn_sr_rx_flow_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flowset_config_get_async(
	int unit,
	bcm_tsn_sr_flowset_t flowset,
	bcm_tsn_pri_map_t * pri_map,
	bcm_tsn_sr_rx_flow_config_t * default_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOWSET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flowset_config_get.unit = unit;
	async->args.tsn_sr_rx_flowset_config_get.flowset = flowset;
	async->args.tsn_sr_rx_flowset_config_get.pri_map = pri_map;
	async->args.tsn_sr_rx_flowset_config_get.default_config = default_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_rx_flowset_create_async(
	int unit,
	bcm_tsn_pri_map_t pri_map,
	bcm_tsn_sr_rx_flow_config_t * default_config,
	bcm_tsn_sr_flowset_t * flowset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_RX_FLOWSET_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_rx_flowset_create.unit = unit;
	async->args.tsn_sr_rx_flowset_create.pri_map = pri_map;
	async->args.tsn_sr_rx_flowset_create.default_config = default_config;
	async->args.tsn_sr_rx_flowset_create.flowset = flowset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_tx_flow_config_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_tx_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_TX_FLOW_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_tx_flow_config_get.unit = unit;
	async->args.tsn_sr_tx_flow_config_get.flow_id = flow_id;
	async->args.tsn_sr_tx_flow_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_tx_flow_config_set_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_tx_flow_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_TX_FLOW_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_tx_flow_config_set.unit = unit;
	async->args.tsn_sr_tx_flow_config_set.flow_id = flow_id;
	async->args.tsn_sr_tx_flow_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_tx_flow_status_get_async(
	int unit,
	bcm_tsn_sr_flow_t flow_id,
	bcm_tsn_sr_tx_flow_status_t * status,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_TX_FLOW_STATUS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_tx_flow_status_get.unit = unit;
	async->args.tsn_sr_tx_flow_status_get.flow_id = flow_id;
	async->args.tsn_sr_tx_flow_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_tx_flowset_config_get_async(
	int unit,
	bcm_tsn_sr_flowset_t flowset,
	bcm_tsn_pri_map_t * pri_map,
	bcm_tsn_sr_tx_flow_config_t * default_config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_TX_FLOWSET_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_tx_flowset_config_get.unit = unit;
	async->args.tsn_sr_tx_flowset_config_get.flowset = flowset;
	async->args.tsn_sr_tx_flowset_config_get.pri_map = pri_map;
	async->args.tsn_sr_tx_flowset_config_get.default_config = default_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_sr_tx_flowset_create_async(
	int unit,
	bcm_tsn_pri_map_t pri_map,
	bcm_tsn_sr_tx_flow_config_t * default_config,
	bcm_tsn_sr_flowset_t * flowset,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_SR_TX_FLOWSET_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_sr_tx_flowset_create.unit = unit;
	async->args.tsn_sr_tx_flowset_create.pri_map = pri_map;
	async->args.tsn_sr_tx_flowset_create.default_config = default_config;
	async->args.tsn_sr_tx_flowset_create.flowset = flowset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_group_create_async(
	int unit,
	bcm_tsn_stat_group_type_t group_type,
	int count,
	bcm_tsn_stat_t * stat_arr,
	bcm_tsn_stat_group_t * id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_GROUP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_group_create.unit = unit;
	async->args.tsn_stat_group_create.group_type = group_type;
	async->args.tsn_stat_group_create.count = count;
	async->args.tsn_stat_group_create.stat_arr = stat_arr;
	async->args.tsn_stat_group_create.id = id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_group_destroy_async(
	int unit,
	bcm_tsn_stat_group_t id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_GROUP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_group_destroy.unit = unit;
	async->args.tsn_stat_group_destroy.id = id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_group_get_async(
	int unit,
	bcm_tsn_stat_group_t id,
	bcm_tsn_stat_group_type_t * group_type,
	int max,
	bcm_tsn_stat_t * stat_arr,
	int * count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_GROUP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_group_get.unit = unit;
	async->args.tsn_stat_group_get.id = id;
	async->args.tsn_stat_group_get.group_type = group_type;
	async->args.tsn_stat_group_get.max = max;
	async->args.tsn_stat_group_get.stat_arr = stat_arr;
	async->args.tsn_stat_group_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_group_set_async(
	int unit,
	bcm_tsn_stat_group_t id,
	int count,
	bcm_tsn_stat_t * stat_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_GROUP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_group_set.unit = unit;
	async->args.tsn_stat_group_set.id = id;
	async->args.tsn_stat_group_set.count = count;
	async->args.tsn_stat_group_set.stat_arr = stat_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_group_traverse_async(
	int unit,
	bcm_tsn_stat_group_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_GROUP_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_group_traverse.unit = unit;
	async->args.tsn_stat_group_traverse.cb = cb;
	async->args.tsn_stat_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_threshold_get_async(
	int unit,
	bcm_tsn_stat_threshold_source_t source,
	bcm_tsn_stat_t stat,
	bcm_tsn_stat_threshold_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_THRESHOLD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_threshold_get.unit = unit;
	async->args.tsn_stat_threshold_get.source = source;
	async->args.tsn_stat_threshold_get.stat = stat;
	async->args.tsn_stat_threshold_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stat_threshold_set_async(
	int unit,
	bcm_tsn_stat_threshold_source_t source,
	bcm_tsn_stat_t stat,
	bcm_tsn_stat_threshold_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STAT_THRESHOLD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stat_threshold_set.unit = unit;
	async->args.tsn_stat_threshold_set.source = source;
	async->args.tsn_stat_threshold_set.stat = stat;
	async->args.tsn_stat_threshold_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stu_profile_create_async(
	int unit,
	bcm_tsn_stu_profile_type_t type,
	bcm_tsn_stu_config_t * config,
	int * stu_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STU_PROFILE_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stu_profile_create.unit = unit;
	async->args.tsn_stu_profile_create.type = type;
	async->args.tsn_stu_profile_create.config = config;
	async->args.tsn_stu_profile_create.stu_profile_id = stu_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stu_profile_destroy_async(
	int unit,
	int stu_profile_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STU_PROFILE_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stu_profile_destroy.unit = unit;
	async->args.tsn_stu_profile_destroy.stu_profile_id = stu_profile_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stu_profile_get_async(
	int unit,
	int stu_profile_id,
	bcm_tsn_stu_profile_type_t * type,
	bcm_tsn_stu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STU_PROFILE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stu_profile_get.unit = unit;
	async->args.tsn_stu_profile_get.stu_profile_id = stu_profile_id;
	async->args.tsn_stu_profile_get.type = type;
	async->args.tsn_stu_profile_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stu_profile_set_async(
	int unit,
	int stu_profile_id,
	bcm_tsn_stu_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STU_PROFILE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stu_profile_set.unit = unit;
	async->args.tsn_stu_profile_set.stu_profile_id = stu_profile_id;
	async->args.tsn_stu_profile_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tsn_stu_profile_traverse_async(
	int unit,
	bcm_tsn_stu_profile_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TSN_STU_PROFILE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tsn_stu_profile_traverse.unit = unit;
	async->args.tsn_stu_profile_traverse.cb = cb;
	async->args.tsn_stu_profile_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_tunnel_config_get_async(
	int unit,
	bcm_tunnel_config_t * tconfig,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_config_get.unit = unit;
	async->args.tunnel_config_get.tconfig = tconfig;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_config_set_async(
	int unit,
	bcm_tunnel_config_t * tconfig,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_CONFIG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_config_set.unit = unit;
	async->args.tunnel_config_set.tconfig = tconfig;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_create_async(
	int unit,
	uint32 flags,
	int * dscp_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_create.unit = unit;
	async->args.tunnel_dscp_map_create.flags = flags;
	async->args.tunnel_dscp_map_create.dscp_map_id = dscp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_destroy_async(
	int unit,
	int dscp_map_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_destroy.unit = unit;
	async->args.tunnel_dscp_map_destroy.dscp_map_id = dscp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_get_async(
	int unit,
	int dscp_map_id,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_get.unit = unit;
	async->args.tunnel_dscp_map_get.dscp_map_id = dscp_map_id;
	async->args.tunnel_dscp_map_get.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_port_get_async(
	int unit,
	bcm_port_t port,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_port_get.unit = unit;
	async->args.tunnel_dscp_map_port_get.port = port;
	async->args.tunnel_dscp_map_port_get.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_port_set_async(
	int unit,
	bcm_port_t port,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_port_set.unit = unit;
	async->args.tunnel_dscp_map_port_set.port = port;
	async->args.tunnel_dscp_map_port_set.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_dscp_map_set_async(
	int unit,
	int dscp_map_id,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_set.unit = unit;
	async->args.tunnel_dscp_map_set.dscp_map_id = dscp_map_id;
	async->args.tunnel_dscp_map_set.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_initiator_clear_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_CLEAR;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_clear.unit = unit;
	async->args.tunnel_initiator_clear.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_initiator_create_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_tunnel_initiator_t * tunnel,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_create.unit = unit;
	async->args.tunnel_initiator_create.intf = intf;
	async->args.tunnel_initiator_create.tunnel = tunnel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_initiator_get_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_tunnel_initiator_t * tunnel,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_get.unit = unit;
	async->args.tunnel_initiator_get.intf = intf;
	async->args.tunnel_initiator_get.tunnel = tunnel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_initiator_set_async(
	int unit,
	bcm_l3_intf_t * intf,
	bcm_tunnel_initiator_t * tunnel,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_set.unit = unit;
	async->args.tunnel_initiator_set.intf = intf;
	async->args.tunnel_initiator_set.tunnel = tunnel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_initiator_traverse_async(
	int unit,
	bcm_tunnel_initiator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_traverse.unit = unit;
	async->args.tunnel_initiator_traverse.cb = cb;
	async->args.tunnel_initiator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_add_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_add.unit = unit;
	async->args.tunnel_terminator_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_config_add_async(
	int unit,
	uint32 flags,
	bcm_tunnel_terminator_config_key_t * config_key,
	bcm_tunnel_terminator_config_action_t * config_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_config_add.unit = unit;
	async->args.tunnel_terminator_config_add.flags = flags;
	async->args.tunnel_terminator_config_add.config_key = config_key;
	async->args.tunnel_terminator_config_add.config_action = config_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_config_delete_async(
	int unit,
	bcm_tunnel_terminator_config_key_t * config_key,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_config_delete.unit = unit;
	async->args.tunnel_terminator_config_delete.config_key = config_key;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_config_get_async(
	int unit,
	bcm_tunnel_terminator_config_key_t * config_key,
	bcm_tunnel_terminator_config_action_t * config_action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_config_get.unit = unit;
	async->args.tunnel_terminator_config_get.config_key = config_key;
	async->args.tunnel_terminator_config_get.config_action = config_action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_create_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_create.unit = unit;
	async->args.tunnel_terminator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_delete_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_delete.unit = unit;
	async->args.tunnel_terminator_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_get_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_get.unit = unit;
	async->args.tunnel_terminator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_traverse_async(
	int unit,
	bcm_tunnel_terminator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_traverse.unit = unit;
	async->args.tunnel_terminator_traverse.cb = cb;
	async->args.tunnel_terminator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_update_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_update.unit = unit;
	async->args.tunnel_terminator_update.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_vlan_get_async(
	int unit,
	bcm_gport_t tunnel,
	bcm_vlan_vector_t * vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_vlan_get.unit = unit;
	async->args.tunnel_terminator_vlan_get.tunnel = tunnel;
	async->args.tunnel_terminator_vlan_get.vlan_vec = vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tunnel_terminator_vlan_set_async(
	int unit,
	bcm_gport_t tunnel,
	bcm_vlan_vector_t vlan_vec,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_vlan_set.unit = unit;
	async->args.tunnel_terminator_vlan_set.tunnel = tunnel;
	async->args.tunnel_terminator_vlan_set.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_tx_async(
	int unit,
	bcm_pkt_t * tx_pkt,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx.unit = unit;
	async->args.tx.tx_pkt = tx_pkt;
	async->args.tx.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_array_async(
	int unit,
	bcm_pkt_t ** pkt,
	int count,
	bcm_pkt_cb_f all_done_cb,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_ARRAY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_array.unit = unit;
	async->args.tx_array.pkt = (bcm_pkt_t * *)pkt;
	async->args.tx_array.count = count;
	async->args.tx_array.all_done_cb = all_done_cb;
	async->args.tx_array.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BCM_RPC_SUPPORT

void
bcm_tx_cpu_tunnel_async(
	bcm_pkt_t * pkt,
	int dest_unit,
	int remote_port,
	uint32 flags,
	bcm_cpu_tunnel_mode_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_CPU_TUNNEL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_cpu_tunnel.pkt = pkt;
	async->args.tx_cpu_tunnel.dest_unit = dest_unit;
	async->args.tx_cpu_tunnel.remote_port = remote_port;
	async->args.tx_cpu_tunnel.flags = flags;
	async->args.tx_cpu_tunnel.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_cpu_tunnel_get_async(
	bcm_tx_cpu_tunnel_f * f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_CPU_TUNNEL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_cpu_tunnel_get.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_cpu_tunnel_set_async(
	bcm_tx_cpu_tunnel_f f,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_CPU_TUNNEL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_cpu_tunnel_set.f = f;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BCM_RPC_SUPPORT */
#ifdef	BROADCOM_DEBUG

void
bcm_tx_dv_dump_async(
	int unit,
	void * dv_p,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_DV_DUMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_dv_dump.unit = unit;
	async->args.tx_dv_dump.dv_p = dv_p;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_tx_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_list_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_pkt_cb_f all_done_cb,
	void * cookie,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_list.unit = unit;
	async->args.tx_list.pkt = pkt;
	async->args.tx_list.all_done_cb = all_done_cb;
	async->args.tx_list.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_pkt_l2_map_async(
	int unit,
	bcm_pkt_t * pkt,
	bcm_mac_t dest_mac,
	int vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_PKT_L2_MAP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_pkt_l2_map.unit = unit;
	async->args.tx_pkt_l2_map.pkt = pkt;
	async->args.tx_pkt_l2_map.dest_mac = (uint8 *)dest_mac;
	async->args.tx_pkt_l2_map.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_tx_pkt_setup_async(
	int unit,
	bcm_pkt_t * tx_pkt,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_PKT_SETUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_pkt_setup.unit = unit;
	async->args.tx_pkt_setup.tx_pkt = tx_pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	BROADCOM_DEBUG

void
bcm_tx_show_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TX_SHOW;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_show.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* BROADCOM_DEBUG */

void
bcm_txbeacon_destroy_async(
	int unit,
	bcm_txbeacon_pkt_id_t pkt_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_destroy.unit = unit;
	async->args.txbeacon_destroy.pkt_id = pkt_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_init_async(
	int unit,
	int uC,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_init.unit = unit;
	async->args.txbeacon_init.uC = uC;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_pkt_get_async(
	int unit,
	bcm_txbeacon_t * txbeacon,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_PKT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_pkt_get.unit = unit;
	async->args.txbeacon_pkt_get.txbeacon = txbeacon;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_pkt_setup_async(
	int unit,
	bcm_txbeacon_t * txbeacon,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_PKT_SETUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_pkt_setup.unit = unit;
	async->args.txbeacon_pkt_setup.txbeacon = txbeacon;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_start_async(
	int unit,
	bcm_txbeacon_pkt_id_t pkt_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_START;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_start.unit = unit;
	async->args.txbeacon_start.pkt_id = pkt_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_stop_async(
	int unit,
	bcm_txbeacon_pkt_id_t pkt_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_STOP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_stop.unit = unit;
	async->args.txbeacon_stop.pkt_id = pkt_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_txbeacon_traverse_async(
	int unit,
	bcm_txbeacon_traverse_cb_t trav_fn,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_TXBEACON_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.txbeacon_traverse.unit = unit;
	async->args.txbeacon_traverse.trav_fn = trav_fn;
	async->args.txbeacon_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_create_async(
	int unit,
	bcm_udf_alloc_hints_t * hints,
	bcm_udf_t * udf_info,
	bcm_udf_id_t * udf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_create.unit = unit;
	async->args.udf_create.hints = hints;
	async->args.udf_create.udf_info = udf_info;
	async->args.udf_create.udf_id = udf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_destroy_async(
	int unit,
	bcm_udf_id_t udf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_destroy.unit = unit;
	async->args.udf_destroy.udf_id = udf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_get_async(
	int unit,
	bcm_udf_id_t udf_id,
	bcm_udf_t * udf_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_get.unit = unit;
	async->args.udf_get.udf_id = udf_id;
	async->args.udf_get.udf_info = udf_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_get_all_async(
	int unit,
	int max,
	bcm_udf_id_t * udf_id_list,
	int * actual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_get_all.unit = unit;
	async->args.udf_get_all.max = max;
	async->args.udf_get_all.udf_id_list = udf_id_list;
	async->args.udf_get_all.actual = actual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_hash_config_add_async(
	int unit,
	uint32 options,
	bcm_udf_hash_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_HASH_CONFIG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_hash_config_add.unit = unit;
	async->args.udf_hash_config_add.options = options;
	async->args.udf_hash_config_add.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_hash_config_delete_async(
	int unit,
	bcm_udf_hash_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_HASH_CONFIG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_hash_config_delete.unit = unit;
	async->args.udf_hash_config_delete.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_hash_config_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_HASH_CONFIG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_hash_config_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_hash_config_get_async(
	int unit,
	bcm_udf_hash_config_t * config,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_HASH_CONFIG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_hash_config_get.unit = unit;
	async->args.udf_hash_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_hash_config_get_all_async(
	int unit,
	int max,
	bcm_udf_hash_config_t * config_list,
	int * actual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_HASH_CONFIG_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_hash_config_get_all.unit = unit;
	async->args.udf_hash_config_get_all.max = max;
	async->args.udf_hash_config_get_all.config_list = config_list;
	async->args.udf_hash_config_get_all.actual = actual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_oper_mode_get_async(
	int unit,
	bcm_udf_oper_mode_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_OPER_MODE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_oper_mode_get.unit = unit;
	async->args.udf_oper_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_oper_mode_set_async(
	int unit,
	bcm_udf_oper_mode_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_OPER_MODE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_oper_mode_set.unit = unit;
	async->args.udf_oper_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_add_async(
	int unit,
	bcm_udf_id_t udf_id,
	bcm_udf_pkt_format_id_t pkt_format_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_add.unit = unit;
	async->args.udf_pkt_format_add.udf_id = udf_id;
	async->args.udf_pkt_format_add.pkt_format_id = pkt_format_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_create_async(
	int unit,
	bcm_udf_pkt_format_options_t options,
	bcm_udf_pkt_format_info_t * pkt_format,
	bcm_udf_pkt_format_id_t * pkt_format_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_create.unit = unit;
	async->args.udf_pkt_format_create.options = options;
	async->args.udf_pkt_format_create.pkt_format = pkt_format;
	async->args.udf_pkt_format_create.pkt_format_id = pkt_format_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_delete_async(
	int unit,
	bcm_udf_id_t udf_id,
	bcm_udf_pkt_format_id_t pkt_format_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_delete.unit = unit;
	async->args.udf_pkt_format_delete.udf_id = udf_id;
	async->args.udf_pkt_format_delete.pkt_format_id = pkt_format_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_delete_all_async(
	int unit,
	bcm_udf_id_t udf_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_delete_all.unit = unit;
	async->args.udf_pkt_format_delete_all.udf_id = udf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_destroy_async(
	int unit,
	bcm_udf_pkt_format_id_t pkt_format_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_destroy.unit = unit;
	async->args.udf_pkt_format_destroy.pkt_format_id = pkt_format_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_get_async(
	int unit,
	bcm_udf_pkt_format_id_t pkt_format_id,
	int max,
	bcm_udf_id_t * udf_id_list,
	int * actual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_get.unit = unit;
	async->args.udf_pkt_format_get.pkt_format_id = pkt_format_id;
	async->args.udf_pkt_format_get.max = max;
	async->args.udf_pkt_format_get.udf_id_list = udf_id_list;
	async->args.udf_pkt_format_get.actual = actual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_get_all_async(
	int unit,
	bcm_udf_id_t udf_id,
	int max,
	bcm_udf_pkt_format_id_t * pkt_format_id_list,
	int * actual,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_get_all.unit = unit;
	async->args.udf_pkt_format_get_all.udf_id = udf_id;
	async->args.udf_pkt_format_get_all.max = max;
	async->args.udf_pkt_format_get_all.pkt_format_id_list = pkt_format_id_list;
	async->args.udf_pkt_format_get_all.actual = actual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_udf_pkt_format_info_get_async(
	int unit,
	bcm_udf_pkt_format_id_t pkt_format_id,
	bcm_udf_pkt_format_info_t * pkt_format,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_UDF_PKT_FORMAT_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.udf_pkt_format_info_get.unit = unit;
	async->args.udf_pkt_format_info_get.pkt_format_id = pkt_format_id;
	async->args.udf_pkt_format_info_get.pkt_format = pkt_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_block_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_block_t * vlan_block,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_BLOCK_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_block_get.unit = unit;
	async->args.vlan_block_get.vlan = vlan;
	async->args.vlan_block_get.vlan_block = vlan_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_block_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_block_t * vlan_block,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_BLOCK_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_block_set.unit = unit;
	async->args.vlan_block_set.vlan = vlan;
	async->args.vlan_block_set.vlan_block = vlan_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_get_async(
	int unit,
	bcm_vlan_control_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_get.unit = unit;
	async->args.vlan_control_get.type = type;
	async->args.vlan_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_port_get_async(
	int unit,
	int port,
	bcm_vlan_control_port_t type,
	int * arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_port_get.unit = unit;
	async->args.vlan_control_port_get.port = port;
	async->args.vlan_control_port_get.type = type;
	async->args.vlan_control_port_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_port_set_async(
	int unit,
	int port,
	bcm_vlan_control_port_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_PORT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_port_set.unit = unit;
	async->args.vlan_control_port_set.port = port;
	async->args.vlan_control_port_set.type = type;
	async->args.vlan_control_port_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_set_async(
	int unit,
	bcm_vlan_control_t type,
	int arg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_set.unit = unit;
	async->args.vlan_control_set.type = type;
	async->args.vlan_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_vlan_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_control_vlan_t * control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_get.unit = unit;
	async->args.vlan_control_vlan_get.vlan = vlan;
	async->args.vlan_control_vlan_get.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_vlan_selective_get_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 valid_fields,
	bcm_vlan_control_vlan_t * control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_SELECTIVE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_selective_get.unit = unit;
	async->args.vlan_control_vlan_selective_get.vlan = vlan;
	async->args.vlan_control_vlan_selective_get.valid_fields = valid_fields;
	async->args.vlan_control_vlan_selective_get.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_vlan_selective_set_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 valid_fields,
	bcm_vlan_control_vlan_t * control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_SELECTIVE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_selective_set.unit = unit;
	async->args.vlan_control_vlan_selective_set.vlan = vlan;
	async->args.vlan_control_vlan_selective_set.valid_fields = valid_fields;
	async->args.vlan_control_vlan_selective_set.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_control_vlan_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_control_vlan_t control,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_set.unit = unit;
	async->args.vlan_control_vlan_set.vlan = vlan;
	async->args.vlan_control_vlan_set.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_create_async(
	int unit,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_create.unit = unit;
	async->args.vlan_create.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_cross_connect_add_async(
	int unit,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_gport_t port_1,
	bcm_gport_t port_2,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_add.unit = unit;
	async->args.vlan_cross_connect_add.outer_vlan = outer_vlan;
	async->args.vlan_cross_connect_add.inner_vlan = inner_vlan;
	async->args.vlan_cross_connect_add.port_1 = port_1;
	async->args.vlan_cross_connect_add.port_2 = port_2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_cross_connect_delete_async(
	int unit,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_delete.unit = unit;
	async->args.vlan_cross_connect_delete.outer_vlan = outer_vlan;
	async->args.vlan_cross_connect_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_cross_connect_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_cross_connect_traverse_async(
	int unit,
	bcm_vlan_cross_connect_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_traverse.unit = unit;
	async->args.vlan_cross_connect_traverse.cb = cb;
	async->args.vlan_cross_connect_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_default_get_async(
	int unit,
	bcm_vlan_t * vid_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DEFAULT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_default_get.unit = unit;
	async->args.vlan_default_get.vid_ptr = vid_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_default_set_async(
	int unit,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DEFAULT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_default_set.unit = unit;
	async->args.vlan_default_set.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_destroy_async(
	int unit,
	bcm_vlan_t vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_destroy.unit = unit;
	async->args.vlan_destroy.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_add_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_add.unit = unit;
	async->args.vlan_dtag_add.port = port;
	async->args.vlan_dtag_add.old_vid = old_vid;
	async->args.vlan_dtag_add.new_vid = new_vid;
	async->args.vlan_dtag_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_delete_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_delete.unit = unit;
	async->args.vlan_dtag_delete.port = port;
	async->args.vlan_dtag_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_get_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_get.unit = unit;
	async->args.vlan_dtag_get.port = port;
	async->args.vlan_dtag_get.old_vid = old_vid;
	async->args.vlan_dtag_get.new_vid = new_vid;
	async->args.vlan_dtag_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_range_add_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t new_vid,
	int int_prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_add.unit = unit;
	async->args.vlan_dtag_range_add.port = port;
	async->args.vlan_dtag_range_add.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_add.old_vid_high = old_vid_high;
	async->args.vlan_dtag_range_add.new_vid = new_vid;
	async->args.vlan_dtag_range_add.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_range_delete_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_delete.unit = unit;
	async->args.vlan_dtag_range_delete.port = port;
	async->args.vlan_dtag_range_delete.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_delete.old_vid_high = old_vid_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_range_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_range_get_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t * new_vid,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_get.unit = unit;
	async->args.vlan_dtag_range_get.port = port;
	async->args.vlan_dtag_range_get.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_get.old_vid_high = old_vid_high;
	async->args.vlan_dtag_range_get.new_vid = new_vid;
	async->args.vlan_dtag_range_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_range_traverse_async(
	int unit,
	bcm_vlan_dtag_range_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_traverse.unit = unit;
	async->args.vlan_dtag_range_traverse.cb = cb;
	async->args.vlan_dtag_range_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_dtag_traverse_async(
	int unit,
	bcm_vlan_dtag_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_DTAG_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_traverse.unit = unit;
	async->args.vlan_dtag_traverse.cb = cb;
	async->args.vlan_dtag_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_egress_policer_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_EGRESS_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_egress_policer_get.unit = unit;
	async->args.vlan_egress_policer_get.vlan = vlan;
	async->args.vlan_egress_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_egress_policer_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_EGRESS_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_egress_policer_set.unit = unit;
	async->args.vlan_egress_policer_set.vlan = vlan;
	async->args.vlan_egress_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_add_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_gport_t port,
	int flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_add.unit = unit;
	async->args.vlan_gport_add.vlan = vlan;
	async->args.vlan_gport_add.port = port;
	async->args.vlan_gport_add.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_delete_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_delete.unit = unit;
	async->args.vlan_gport_delete.vlan = vlan;
	async->args.vlan_gport_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_delete_all_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_delete_all.unit = unit;
	async->args.vlan_gport_delete_all.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_extended_delete_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_gport_t port,
	int flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_EXTENDED_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_extended_delete.unit = unit;
	async->args.vlan_gport_extended_delete.vlan = vlan;
	async->args.vlan_gport_extended_delete.port = port;
	async->args.vlan_gport_extended_delete.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_gport_t port,
	int * flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_get.unit = unit;
	async->args.vlan_gport_get.vlan = vlan;
	async->args.vlan_gport_get.port = port;
	async->args.vlan_gport_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_get_all_async(
	int unit,
	bcm_vlan_t vlan,
	int array_max,
	bcm_gport_t * gport_array,
	int * flags_array,
	int * array_size,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_get_all.unit = unit;
	async->args.vlan_gport_get_all.vlan = vlan;
	async->args.vlan_gport_get_all.array_max = array_max;
	async->args.vlan_gport_get_all.gport_array = gport_array;
	async->args.vlan_gport_get_all.flags_array = flags_array;
	async->args.vlan_gport_get_all.array_size = array_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_gport_info_get_async(
	int unit,
	bcm_vlan_gport_info_t * vlan_gport_info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_GPORT_INFO_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_info_get.unit = unit;
	async->args.vlan_gport_info_get.vlan_gport_info = vlan_gport_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_action_add_async(
	int unit,
	bcm_vlan_ip_t * vlan_ip,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_add.unit = unit;
	async->args.vlan_ip_action_add.vlan_ip = vlan_ip;
	async->args.vlan_ip_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_action_delete_async(
	int unit,
	bcm_vlan_ip_t * vlan_ip,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_delete.unit = unit;
	async->args.vlan_ip_action_delete.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_action_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_action_get_async(
	int unit,
	bcm_vlan_ip_t * vlan_ip,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_get.unit = unit;
	async->args.vlan_ip_action_get.vlan_ip = vlan_ip;
	async->args.vlan_ip_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_action_traverse_async(
	int unit,
	bcm_vlan_ip_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_traverse.unit = unit;
	async->args.vlan_ip_action_traverse.cb = cb;
	async->args.vlan_ip_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_add_async(
	int unit,
	bcm_vlan_ip_t * vlan_ip,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_add.unit = unit;
	async->args.vlan_ip_add.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_delete_async(
	int unit,
	bcm_vlan_ip_t * vlan_ip,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_delete.unit = unit;
	async->args.vlan_ip_delete.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_ip_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_IP_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_list_async(
	int unit,
	bcm_vlan_data_t ** listp,
	int * countp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_LIST;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_list.unit = unit;
	async->args.vlan_list.listp = (bcm_vlan_data_t * *)listp;
	async->args.vlan_list.countp = countp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_list_by_pbmp_async(
	int unit,
	bcm_pbmp_t ports,
	bcm_vlan_data_t ** listp,
	int * countp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_LIST_BY_PBMP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_list_by_pbmp.unit = unit;
	async->args.vlan_list_by_pbmp.ports = ports;
	async->args.vlan_list_by_pbmp.listp = (bcm_vlan_data_t * *)listp;
	async->args.vlan_list_by_pbmp.countp = countp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_list_destroy_async(
	int unit,
	bcm_vlan_data_t * list,
	int count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_LIST_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_list_destroy.unit = unit;
	async->args.vlan_list_destroy.list = list;
	async->args.vlan_list_destroy.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_action_add_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_add.unit = unit;
	async->args.vlan_mac_action_add.mac = (uint8 *)mac;
	async->args.vlan_mac_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_action_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_delete.unit = unit;
	async->args.vlan_mac_action_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_action_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_action_get_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_get.unit = unit;
	async->args.vlan_mac_action_get.mac = (uint8 *)mac;
	async->args.vlan_mac_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_action_traverse_async(
	int unit,
	bcm_vlan_mac_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_traverse.unit = unit;
	async->args.vlan_mac_action_traverse.cb = cb;
	async->args.vlan_mac_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_add_async(
	int unit,
	bcm_mac_t mac,
	bcm_vlan_t vid,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_add.unit = unit;
	async->args.vlan_mac_add.mac = (uint8 *)mac;
	async->args.vlan_mac_add.vid = vid;
	async->args.vlan_mac_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_delete.unit = unit;
	async->args.vlan_mac_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mac_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MAC_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mcast_flood_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_mcast_flood_t * mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MCAST_FLOOD_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mcast_flood_get.unit = unit;
	async->args.vlan_mcast_flood_get.vlan = vlan;
	async->args.vlan_mcast_flood_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_mcast_flood_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_mcast_flood_t mode,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_MCAST_FLOOD_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mcast_flood_set.unit = unit;
	async->args.vlan_mcast_flood_set.vlan = vlan;
	async->args.vlan_mcast_flood_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_policer_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_policer_get.unit = unit;
	async->args.vlan_policer_get.vlan = vlan;
	async->args.vlan_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_policer_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_policer_set.unit = unit;
	async->args.vlan_policer_set.vlan = vlan;
	async->args.vlan_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_add_async(
	int unit,
	bcm_vlan_t vid,
	bcm_pbmp_t pbmp,
	bcm_pbmp_t ubmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_add.unit = unit;
	async->args.vlan_port_add.vid = vid;
	async->args.vlan_port_add.pbmp = pbmp;
	async->args.vlan_port_add.ubmp = ubmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_create_async(
	int unit,
	bcm_vlan_port_t * vlan_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_create.unit = unit;
	async->args.vlan_port_create.vlan_port = vlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_default_action_delete_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_delete.unit = unit;
	async->args.vlan_port_default_action_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_default_action_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_get.unit = unit;
	async->args.vlan_port_default_action_get.port = port;
	async->args.vlan_port_default_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_default_action_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_set.unit = unit;
	async->args.vlan_port_default_action_set.port = port;
	async->args.vlan_port_default_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_destroy_async(
	int unit,
	bcm_gport_t gport,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_destroy.unit = unit;
	async->args.vlan_port_destroy.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_egress_default_action_delete_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_delete.unit = unit;
	async->args.vlan_port_egress_default_action_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_egress_default_action_get_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_get.unit = unit;
	async->args.vlan_port_egress_default_action_get.port = port;
	async->args.vlan_port_egress_default_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_egress_default_action_set_async(
	int unit,
	bcm_port_t port,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_set.unit = unit;
	async->args.vlan_port_egress_default_action_set.port = port;
	async->args.vlan_port_egress_default_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_egress_policer_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_policer_get.unit = unit;
	async->args.vlan_port_egress_policer_get.vlan = vlan;
	async->args.vlan_port_egress_policer_get.port = port;
	async->args.vlan_port_egress_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_egress_policer_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_policer_set.unit = unit;
	async->args.vlan_port_egress_policer_set.vlan = vlan;
	async->args.vlan_port_egress_policer_set.port = port;
	async->args.vlan_port_egress_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_find_async(
	int unit,
	bcm_vlan_port_t * vlan_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_FIND;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_find.unit = unit;
	async->args.vlan_port_find.vlan_port = vlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_get_async(
	int unit,
	bcm_vlan_t vid,
	bcm_pbmp_t * pbmp,
	bcm_pbmp_t * ubmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_get.unit = unit;
	async->args.vlan_port_get.vid = vid;
	async->args.vlan_port_get.pbmp = pbmp;
	async->args.vlan_port_get.ubmp = ubmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_policer_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_policer_t * policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_POLICER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_policer_get.unit = unit;
	async->args.vlan_port_policer_get.vlan = vlan;
	async->args.vlan_port_policer_get.port = port;
	async->args.vlan_port_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_policer_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_policer_t policer_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_POLICER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_policer_set.unit = unit;
	async->args.vlan_port_policer_set.vlan = vlan;
	async->args.vlan_port_policer_set.port = port;
	async->args.vlan_port_policer_set.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_protocol_action_add_async(
	int unit,
	bcm_port_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_add.unit = unit;
	async->args.vlan_port_protocol_action_add.port = port;
	async->args.vlan_port_protocol_action_add.frame = frame;
	async->args.vlan_port_protocol_action_add.ether = ether;
	async->args.vlan_port_protocol_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_protocol_action_delete_async(
	int unit,
	bcm_port_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_delete.unit = unit;
	async->args.vlan_port_protocol_action_delete.port = port;
	async->args.vlan_port_protocol_action_delete.frame = frame;
	async->args.vlan_port_protocol_action_delete.ether = ether;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_protocol_action_delete_all_async(
	int unit,
	bcm_port_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_delete_all.unit = unit;
	async->args.vlan_port_protocol_action_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_protocol_action_get_async(
	int unit,
	bcm_port_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_get.unit = unit;
	async->args.vlan_port_protocol_action_get.port = port;
	async->args.vlan_port_protocol_action_get.frame = frame;
	async->args.vlan_port_protocol_action_get.ether = ether;
	async->args.vlan_port_protocol_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_protocol_action_traverse_async(
	int unit,
	bcm_vlan_port_protocol_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_traverse.unit = unit;
	async->args.vlan_port_protocol_action_traverse.cb = cb;
	async->args.vlan_port_protocol_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_remove_async(
	int unit,
	bcm_vlan_t vid,
	bcm_pbmp_t pbmp,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_REMOVE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_remove.unit = unit;
	async->args.vlan_port_remove.vid = vid;
	async->args.vlan_port_remove.pbmp = pbmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_enable_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	int * enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_ENABLE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_enable_get.unit = unit;
	async->args.vlan_port_stat_enable_get.vlan = vlan;
	async->args.vlan_port_stat_enable_get.port = port;
	async->args.vlan_port_stat_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_enable_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_enable_set.unit = unit;
	async->args.vlan_port_stat_enable_set.vlan = vlan;
	async->args.vlan_port_stat_enable_set.port = port;
	async->args.vlan_port_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_get.unit = unit;
	async->args.vlan_port_stat_get.vlan = vlan;
	async->args.vlan_port_stat_get.port = port;
	async->args.vlan_port_stat_get.cos = cos;
	async->args.vlan_port_stat_get.stat = stat;
	async->args.vlan_port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_get32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_get32.unit = unit;
	async->args.vlan_port_stat_get32.vlan = vlan;
	async->args.vlan_port_stat_get32.port = port;
	async->args.vlan_port_stat_get32.cos = cos;
	async->args.vlan_port_stat_get32.stat = stat;
	async->args.vlan_port_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_multi_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_multi_get.unit = unit;
	async->args.vlan_port_stat_multi_get.vlan = vlan;
	async->args.vlan_port_stat_multi_get.port = port;
	async->args.vlan_port_stat_multi_get.cos = cos;
	async->args.vlan_port_stat_multi_get.nstat = nstat;
	async->args.vlan_port_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_port_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_multi_get32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_multi_get32.unit = unit;
	async->args.vlan_port_stat_multi_get32.vlan = vlan;
	async->args.vlan_port_stat_multi_get32.port = port;
	async->args.vlan_port_stat_multi_get32.cos = cos;
	async->args.vlan_port_stat_multi_get32.nstat = nstat;
	async->args.vlan_port_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_port_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_multi_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_multi_set.unit = unit;
	async->args.vlan_port_stat_multi_set.vlan = vlan;
	async->args.vlan_port_stat_multi_set.port = port;
	async->args.vlan_port_stat_multi_set.cos = cos;
	async->args.vlan_port_stat_multi_set.nstat = nstat;
	async->args.vlan_port_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_port_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_multi_set32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_multi_set32.unit = unit;
	async->args.vlan_port_stat_multi_set32.vlan = vlan;
	async->args.vlan_port_stat_multi_set32.port = port;
	async->args.vlan_port_stat_multi_set32.cos = cos;
	async->args.vlan_port_stat_multi_set32.nstat = nstat;
	async->args.vlan_port_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_port_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_set.unit = unit;
	async->args.vlan_port_stat_set.vlan = vlan;
	async->args.vlan_port_stat_set.port = port;
	async->args.vlan_port_stat_set.cos = cos;
	async->args.vlan_port_stat_set.stat = stat;
	async->args.vlan_port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_stat_set32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_port_t port,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_stat_set32.unit = unit;
	async->args.vlan_port_stat_set32.vlan = vlan;
	async->args.vlan_port_stat_set32.port = port;
	async->args.vlan_port_stat_set32.cos = cos;
	async->args.vlan_port_stat_set32.stat = stat;
	async->args.vlan_port_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_translation_get_async(
	int unit,
	bcm_vlan_port_translation_t * vlan_port_translation,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_TRANSLATION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_translation_get.unit = unit;
	async->args.vlan_port_translation_get.vlan_port_translation = vlan_port_translation;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_port_translation_set_async(
	int unit,
	bcm_vlan_port_translation_t * vlan_port_translation,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_PORT_TRANSLATION_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_translation_set.unit = unit;
	async->args.vlan_port_translation_set.vlan_port_translation = vlan_port_translation;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_attach_async(
	int unit,
	bcm_vlan_t vlan,
	int qmid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_attach.unit = unit;
	async->args.vlan_queue_map_attach.vlan = vlan;
	async->args.vlan_queue_map_attach.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_attach_get_async(
	int unit,
	bcm_vlan_t vlan,
	int * qmid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_attach_get.unit = unit;
	async->args.vlan_queue_map_attach_get.vlan = vlan;
	async->args.vlan_queue_map_attach_get.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_create_async(
	int unit,
	uint32 flags,
	int * qmid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_create.unit = unit;
	async->args.vlan_queue_map_create.flags = flags;
	async->args.vlan_queue_map_create.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_destroy_async(
	int unit,
	int qmid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_destroy.unit = unit;
	async->args.vlan_queue_map_destroy.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_detach_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_detach.unit = unit;
	async->args.vlan_queue_map_detach.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_detach_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_detach_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_get_async(
	int unit,
	int qmid,
	int pkt_pri,
	int cfi,
	int * queue,
	int * color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_get.unit = unit;
	async->args.vlan_queue_map_get.qmid = qmid;
	async->args.vlan_queue_map_get.pkt_pri = pkt_pri;
	async->args.vlan_queue_map_get.cfi = cfi;
	async->args.vlan_queue_map_get.queue = queue;
	async->args.vlan_queue_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_queue_map_set_async(
	int unit,
	int qmid,
	int pkt_pri,
	int cfi,
	int queue,
	int color,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_set.unit = unit;
	async->args.vlan_queue_map_set.qmid = qmid;
	async->args.vlan_queue_map_set.pkt_pri = pkt_pri;
	async->args.vlan_queue_map_set.cfi = cfi;
	async->args.vlan_queue_map_set.queue = queue;
	async->args.vlan_queue_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_attach_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_attach.unit = unit;
	async->args.vlan_stat_attach.vlan = vlan;
	async->args.vlan_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_counter_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_counter_get.unit = unit;
	async->args.vlan_stat_counter_get.vlan = vlan;
	async->args.vlan_stat_counter_get.stat = stat;
	async->args.vlan_stat_counter_get.num_entries = num_entries;
	async->args.vlan_stat_counter_get.counter_indexes = counter_indexes;
	async->args.vlan_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_counter_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_counter_set.unit = unit;
	async->args.vlan_stat_counter_set.vlan = vlan;
	async->args.vlan_stat_counter_set.stat = stat;
	async->args.vlan_stat_counter_set.num_entries = num_entries;
	async->args.vlan_stat_counter_set.counter_indexes = counter_indexes;
	async->args.vlan_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_counter_sync_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_counter_sync_get.unit = unit;
	async->args.vlan_stat_counter_sync_get.vlan = vlan;
	async->args.vlan_stat_counter_sync_get.stat = stat;
	async->args.vlan_stat_counter_sync_get.num_entries = num_entries;
	async->args.vlan_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.vlan_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_detach_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_detach.unit = unit;
	async->args.vlan_stat_detach.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_detach_with_id_async(
	int unit,
	bcm_vlan_t vlan,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_DETACH_WITH_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_detach_with_id.unit = unit;
	async->args.vlan_stat_detach_with_id.vlan = vlan;
	async->args.vlan_stat_detach_with_id.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_enable_set_async(
	int unit,
	bcm_vlan_t vlan,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_enable_set.unit = unit;
	async->args.vlan_stat_enable_set.vlan = vlan;
	async->args.vlan_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_get.unit = unit;
	async->args.vlan_stat_get.vlan = vlan;
	async->args.vlan_stat_get.cos = cos;
	async->args.vlan_stat_get.stat = stat;
	async->args.vlan_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_get32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_get32.unit = unit;
	async->args.vlan_stat_get32.vlan = vlan;
	async->args.vlan_stat_get32.cos = cos;
	async->args.vlan_stat_get32.stat = stat;
	async->args.vlan_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_id_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_vlan_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_id_get.unit = unit;
	async->args.vlan_stat_id_get.vlan = vlan;
	async->args.vlan_stat_id_get.stat = stat;
	async->args.vlan_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_multi_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_get.unit = unit;
	async->args.vlan_stat_multi_get.vlan = vlan;
	async->args.vlan_stat_multi_get.cos = cos;
	async->args.vlan_stat_multi_get.nstat = nstat;
	async->args.vlan_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_multi_get32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_get32.unit = unit;
	async->args.vlan_stat_multi_get32.vlan = vlan;
	async->args.vlan_stat_multi_get32.cos = cos;
	async->args.vlan_stat_multi_get32.nstat = nstat;
	async->args.vlan_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_multi_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_set.unit = unit;
	async->args.vlan_stat_multi_set.vlan = vlan;
	async->args.vlan_stat_multi_set.cos = cos;
	async->args.vlan_stat_multi_set.nstat = nstat;
	async->args.vlan_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_multi_set32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_set32.unit = unit;
	async->args.vlan_stat_multi_set32.vlan = vlan;
	async->args.vlan_stat_multi_set32.cos = cos;
	async->args.vlan_stat_multi_set32.nstat = nstat;
	async->args.vlan_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_set_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_set.unit = unit;
	async->args.vlan_stat_set.vlan = vlan;
	async->args.vlan_stat_set.cos = cos;
	async->args.vlan_stat_set.stat = stat;
	async->args.vlan_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_set32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_set32.unit = unit;
	async->args.vlan_stat_set32.vlan = vlan;
	async->args.vlan_stat_set32.cos = cos;
	async->args.vlan_stat_set32.stat = stat;
	async->args.vlan_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_sync_get_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_sync_get.unit = unit;
	async->args.vlan_stat_sync_get.vlan = vlan;
	async->args.vlan_stat_sync_get.cos = cos;
	async->args.vlan_stat_sync_get.stat = stat;
	async->args.vlan_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stat_sync_get32_async(
	int unit,
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_sync_get32.unit = unit;
	async->args.vlan_stat_sync_get32.vlan = vlan;
	async->args.vlan_stat_sync_get32.cos = cos;
	async->args.vlan_stat_sync_get32.stat = stat;
	async->args.vlan_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stg_get_async(
	int unit,
	bcm_vlan_t vid,
	bcm_stg_t * stg_ptr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STG_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stg_get.unit = unit;
	async->args.vlan_stg_get.vid = vid;
	async->args.vlan_stg_get.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stg_set_async(
	int unit,
	bcm_vlan_t vid,
	bcm_stg_t stg,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STG_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stg_set.unit = unit;
	async->args.vlan_stg_set.vid = vid;
	async->args.vlan_stg_set.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stp_get_async(
	int unit,
	bcm_vlan_t vid,
	bcm_port_t port,
	int * stp_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STP_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stp_get.unit = unit;
	async->args.vlan_stp_get.vid = vid;
	async->args.vlan_stp_get.port = port;
	async->args.vlan_stp_get.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_stp_set_async(
	int unit,
	bcm_vlan_t vid,
	bcm_port_t port,
	int stp_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_STP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stp_set.unit = unit;
	async->args.vlan_stp_set.vid = vid;
	async->args.vlan_stp_set.port = port;
	async->args.vlan_stp_set.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_add_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_add.unit = unit;
	async->args.vlan_translate_action_add.port = port;
	async->args.vlan_translate_action_add.key_type = key_type;
	async->args.vlan_translate_action_add.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_add.inner_vlan = inner_vlan;
	async->args.vlan_translate_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_class_get_async(
	int unit,
	bcm_vlan_translate_action_class_t * action_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_CLASS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_class_get.unit = unit;
	async->args.vlan_translate_action_class_get.action_class = action_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_class_set_async(
	int unit,
	bcm_vlan_translate_action_class_t * action_class,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_CLASS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_class_set.unit = unit;
	async->args.vlan_translate_action_class_set.action_class = action_class;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_create_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_create.unit = unit;
	async->args.vlan_translate_action_create.port = port;
	async->args.vlan_translate_action_create.key_type = key_type;
	async->args.vlan_translate_action_create.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_create.inner_vlan = inner_vlan;
	async->args.vlan_translate_action_create.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_delete_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_delete.unit = unit;
	async->args.vlan_translate_action_delete.port = port;
	async->args.vlan_translate_action_delete.key_type = key_type;
	async->args.vlan_translate_action_delete.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_get.unit = unit;
	async->args.vlan_translate_action_get.port = port;
	async->args.vlan_translate_action_get.key_type = key_type;
	async->args.vlan_translate_action_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_id_create_async(
	int unit,
	uint32 flags,
	int * action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ID_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_id_create.unit = unit;
	async->args.vlan_translate_action_id_create.flags = flags;
	async->args.vlan_translate_action_id_create.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_id_destroy_async(
	int unit,
	uint32 flags,
	int action_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ID_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_id_destroy.unit = unit;
	async->args.vlan_translate_action_id_destroy.flags = flags;
	async->args.vlan_translate_action_id_destroy.action_id = action_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_id_destroy_all_async(
	int unit,
	uint32 flags,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ID_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_id_destroy_all.unit = unit;
	async->args.vlan_translate_action_id_destroy_all.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_id_get_async(
	int unit,
	uint32 flags,
	int action_id,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_id_get.unit = unit;
	async->args.vlan_translate_action_id_get.flags = flags;
	async->args.vlan_translate_action_id_get.action_id = action_id;
	async->args.vlan_translate_action_id_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_id_set_async(
	int unit,
	uint32 flags,
	int action_id,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ID_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_id_set.unit = unit;
	async->args.vlan_translate_action_id_set.flags = flags;
	async->args.vlan_translate_action_id_set.action_id = action_id;
	async->args.vlan_translate_action_id_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_range_add_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_add.unit = unit;
	async->args.vlan_translate_action_range_add.port = port;
	async->args.vlan_translate_action_range_add.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_add.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_add.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_add.inner_vlan_high = inner_vlan_high;
	async->args.vlan_translate_action_range_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_range_delete_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_delete.unit = unit;
	async->args.vlan_translate_action_range_delete.port = port;
	async->args.vlan_translate_action_range_delete.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_delete.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_delete.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_delete.inner_vlan_high = inner_vlan_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_range_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_range_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_get.unit = unit;
	async->args.vlan_translate_action_range_get.port = port;
	async->args.vlan_translate_action_range_get.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_get.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_get.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_get.inner_vlan_high = inner_vlan_high;
	async->args.vlan_translate_action_range_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_range_traverse_async(
	int unit,
	bcm_vlan_translate_action_range_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_traverse.unit = unit;
	async->args.vlan_translate_action_range_traverse.cb = cb;
	async->args.vlan_translate_action_range_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_action_traverse_async(
	int unit,
	bcm_vlan_translate_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_traverse.unit = unit;
	async->args.vlan_translate_action_traverse.cb = cb;
	async->args.vlan_translate_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_add_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_add.unit = unit;
	async->args.vlan_translate_add.port = port;
	async->args.vlan_translate_add.old_vid = old_vid;
	async->args.vlan_translate_add.new_vid = new_vid;
	async->args.vlan_translate_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_delete_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_delete.unit = unit;
	async->args.vlan_translate_delete.port = port;
	async->args.vlan_translate_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_action_add_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_add.unit = unit;
	async->args.vlan_translate_egress_action_add.port_class = port_class;
	async->args.vlan_translate_egress_action_add.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_add.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_action_delete_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_delete.unit = unit;
	async->args.vlan_translate_egress_action_delete.port_class = port_class;
	async->args.vlan_translate_egress_action_delete.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_action_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_get.unit = unit;
	async->args.vlan_translate_egress_action_get.port_class = port_class;
	async->args.vlan_translate_egress_action_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_action_traverse_async(
	int unit,
	bcm_vlan_translate_egress_action_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_traverse.unit = unit;
	async->args.vlan_translate_egress_action_traverse.cb = cb;
	async->args.vlan_translate_egress_action_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_add_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_add.unit = unit;
	async->args.vlan_translate_egress_add.port = port;
	async->args.vlan_translate_egress_add.old_vid = old_vid;
	async->args.vlan_translate_egress_add.new_vid = new_vid;
	async->args.vlan_translate_egress_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_delete_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_delete.unit = unit;
	async->args.vlan_translate_egress_delete.port = port;
	async->args.vlan_translate_egress_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_get_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_get.unit = unit;
	async->args.vlan_translate_egress_get.port = port;
	async->args.vlan_translate_egress_get.old_vid = old_vid;
	async->args.vlan_translate_egress_get.new_vid = new_vid;
	async->args.vlan_translate_egress_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_gport_action_add_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GPORT_ACTION_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_gport_action_add.unit = unit;
	async->args.vlan_translate_egress_gport_action_add.port = port;
	async->args.vlan_translate_egress_gport_action_add.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_gport_action_add.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_gport_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_gport_action_delete_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GPORT_ACTION_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_gport_action_delete.unit = unit;
	async->args.vlan_translate_egress_gport_action_delete.port = port;
	async->args.vlan_translate_egress_gport_action_delete.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_gport_action_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_gport_action_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GPORT_ACTION_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_gport_action_get.unit = unit;
	async->args.vlan_translate_egress_gport_action_get.port = port;
	async->args.vlan_translate_egress_gport_action_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_gport_action_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_gport_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_attach_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_attach.unit = unit;
	async->args.vlan_translate_egress_stat_attach.port_class = port_class;
	async->args.vlan_translate_egress_stat_attach.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_attach.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_counter_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_counter_get.unit = unit;
	async->args.vlan_translate_egress_stat_counter_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_counter_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_counter_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_counter_get.stat = stat;
	async->args.vlan_translate_egress_stat_counter_get.num_entries = num_entries;
	async->args.vlan_translate_egress_stat_counter_get.counter_indexes = counter_indexes;
	async->args.vlan_translate_egress_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_counter_set_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_counter_set.unit = unit;
	async->args.vlan_translate_egress_stat_counter_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_counter_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_counter_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_counter_set.stat = stat;
	async->args.vlan_translate_egress_stat_counter_set.num_entries = num_entries;
	async->args.vlan_translate_egress_stat_counter_set.counter_indexes = counter_indexes;
	async->args.vlan_translate_egress_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_counter_sync_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_counter_sync_get.unit = unit;
	async->args.vlan_translate_egress_stat_counter_sync_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_counter_sync_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_counter_sync_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_counter_sync_get.stat = stat;
	async->args.vlan_translate_egress_stat_counter_sync_get.num_entries = num_entries;
	async->args.vlan_translate_egress_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.vlan_translate_egress_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_detach_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_detach.unit = unit;
	async->args.vlan_translate_egress_stat_detach.port_class = port_class;
	async->args.vlan_translate_egress_stat_detach.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_detach.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_enable_set_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_enable_set.unit = unit;
	async->args.vlan_translate_egress_stat_enable_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_enable_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_enable_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_get.unit = unit;
	async->args.vlan_translate_egress_stat_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_get.stat = stat;
	async->args.vlan_translate_egress_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_get32_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_get32.unit = unit;
	async->args.vlan_translate_egress_stat_get32.port_class = port_class;
	async->args.vlan_translate_egress_stat_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_get32.stat = stat;
	async->args.vlan_translate_egress_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_id_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_id_get.unit = unit;
	async->args.vlan_translate_egress_stat_id_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_id_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_id_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_id_get.stat = stat;
	async->args.vlan_translate_egress_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_multi_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_get.unit = unit;
	async->args.vlan_translate_egress_stat_multi_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_get.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_multi_get32_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_get32.unit = unit;
	async->args.vlan_translate_egress_stat_multi_get32.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_get32.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_multi_set_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_set.unit = unit;
	async->args.vlan_translate_egress_stat_multi_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_set.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_multi_set32_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_set32.unit = unit;
	async->args.vlan_translate_egress_stat_multi_set32.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_set32.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_set_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_set.unit = unit;
	async->args.vlan_translate_egress_stat_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_set.stat = stat;
	async->args.vlan_translate_egress_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_set32_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_set32.unit = unit;
	async->args.vlan_translate_egress_stat_set32.port_class = port_class;
	async->args.vlan_translate_egress_stat_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_set32.stat = stat;
	async->args.vlan_translate_egress_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_sync_get_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_sync_get.unit = unit;
	async->args.vlan_translate_egress_stat_sync_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_sync_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_sync_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_sync_get.stat = stat;
	async->args.vlan_translate_egress_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_stat_sync_get32_async(
	int unit,
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_sync_get32.unit = unit;
	async->args.vlan_translate_egress_stat_sync_get32.port_class = port_class;
	async->args.vlan_translate_egress_stat_sync_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_sync_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_sync_get32.stat = stat;
	async->args.vlan_translate_egress_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_egress_traverse_async(
	int unit,
	bcm_vlan_translate_egress_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_traverse.unit = unit;
	async->args.vlan_translate_egress_traverse.cb = cb;
	async->args.vlan_translate_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_get_async(
	int unit,
	int port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_get.unit = unit;
	async->args.vlan_translate_get.port = port;
	async->args.vlan_translate_get.old_vid = old_vid;
	async->args.vlan_translate_get.new_vid = new_vid;
	async->args.vlan_translate_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_range_add_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t new_vid,
	int int_prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_add.unit = unit;
	async->args.vlan_translate_range_add.port = port;
	async->args.vlan_translate_range_add.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_add.old_vid_high = old_vid_high;
	async->args.vlan_translate_range_add.new_vid = new_vid;
	async->args.vlan_translate_range_add.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_range_delete_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_delete.unit = unit;
	async->args.vlan_translate_range_delete.port = port;
	async->args.vlan_translate_range_delete.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_delete.old_vid_high = old_vid_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_range_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_range_get_async(
	int unit,
	int port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t * new_vid,
	int * int_prio,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_get.unit = unit;
	async->args.vlan_translate_range_get.port = port;
	async->args.vlan_translate_range_get.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_get.old_vid_high = old_vid_high;
	async->args.vlan_translate_range_get.new_vid = new_vid;
	async->args.vlan_translate_range_get.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_range_traverse_async(
	int unit,
	bcm_vlan_translate_range_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_traverse.unit = unit;
	async->args.vlan_translate_range_traverse.cb = cb;
	async->args.vlan_translate_range_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_attach_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_attach.unit = unit;
	async->args.vlan_translate_stat_attach.port = port;
	async->args.vlan_translate_stat_attach.key_type = key_type;
	async->args.vlan_translate_stat_attach.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_attach.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_counter_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_counter_get.unit = unit;
	async->args.vlan_translate_stat_counter_get.port = port;
	async->args.vlan_translate_stat_counter_get.key_type = key_type;
	async->args.vlan_translate_stat_counter_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_counter_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_counter_get.stat = stat;
	async->args.vlan_translate_stat_counter_get.num_entries = num_entries;
	async->args.vlan_translate_stat_counter_get.counter_indexes = counter_indexes;
	async->args.vlan_translate_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_counter_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_counter_set.unit = unit;
	async->args.vlan_translate_stat_counter_set.port = port;
	async->args.vlan_translate_stat_counter_set.key_type = key_type;
	async->args.vlan_translate_stat_counter_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_counter_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_counter_set.stat = stat;
	async->args.vlan_translate_stat_counter_set.num_entries = num_entries;
	async->args.vlan_translate_stat_counter_set.counter_indexes = counter_indexes;
	async->args.vlan_translate_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_counter_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_counter_sync_get.unit = unit;
	async->args.vlan_translate_stat_counter_sync_get.port = port;
	async->args.vlan_translate_stat_counter_sync_get.key_type = key_type;
	async->args.vlan_translate_stat_counter_sync_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_counter_sync_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_counter_sync_get.stat = stat;
	async->args.vlan_translate_stat_counter_sync_get.num_entries = num_entries;
	async->args.vlan_translate_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.vlan_translate_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_detach_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_detach.unit = unit;
	async->args.vlan_translate_stat_detach.port = port;
	async->args.vlan_translate_stat_detach.key_type = key_type;
	async->args.vlan_translate_stat_detach.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_detach.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_enable_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_enable_set.unit = unit;
	async->args.vlan_translate_stat_enable_set.port = port;
	async->args.vlan_translate_stat_enable_set.key_type = key_type;
	async->args.vlan_translate_stat_enable_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_enable_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_get.unit = unit;
	async->args.vlan_translate_stat_get.port = port;
	async->args.vlan_translate_stat_get.key_type = key_type;
	async->args.vlan_translate_stat_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_get.stat = stat;
	async->args.vlan_translate_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_get32.unit = unit;
	async->args.vlan_translate_stat_get32.port = port;
	async->args.vlan_translate_stat_get32.key_type = key_type;
	async->args.vlan_translate_stat_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_get32.stat = stat;
	async->args.vlan_translate_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_id_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_id_get.unit = unit;
	async->args.vlan_translate_stat_id_get.port = port;
	async->args.vlan_translate_stat_id_get.key_type = key_type;
	async->args.vlan_translate_stat_id_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_id_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_id_get.stat = stat;
	async->args.vlan_translate_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_multi_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_get.unit = unit;
	async->args.vlan_translate_stat_multi_get.port = port;
	async->args.vlan_translate_stat_multi_get.key_type = key_type;
	async->args.vlan_translate_stat_multi_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_get.nstat = nstat;
	async->args.vlan_translate_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_multi_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_get32.unit = unit;
	async->args.vlan_translate_stat_multi_get32.port = port;
	async->args.vlan_translate_stat_multi_get32.key_type = key_type;
	async->args.vlan_translate_stat_multi_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_get32.nstat = nstat;
	async->args.vlan_translate_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_multi_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_set.unit = unit;
	async->args.vlan_translate_stat_multi_set.port = port;
	async->args.vlan_translate_stat_multi_set.key_type = key_type;
	async->args.vlan_translate_stat_multi_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_set.nstat = nstat;
	async->args.vlan_translate_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_multi_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_set32.unit = unit;
	async->args.vlan_translate_stat_multi_set32.port = port;
	async->args.vlan_translate_stat_multi_set32.key_type = key_type;
	async->args.vlan_translate_stat_multi_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_set32.nstat = nstat;
	async->args.vlan_translate_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_set.unit = unit;
	async->args.vlan_translate_stat_set.port = port;
	async->args.vlan_translate_stat_set.key_type = key_type;
	async->args.vlan_translate_stat_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_set.stat = stat;
	async->args.vlan_translate_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_set32.unit = unit;
	async->args.vlan_translate_stat_set32.port = port;
	async->args.vlan_translate_stat_set32.key_type = key_type;
	async->args.vlan_translate_stat_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_set32.stat = stat;
	async->args.vlan_translate_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_sync_get.unit = unit;
	async->args.vlan_translate_stat_sync_get.port = port;
	async->args.vlan_translate_stat_sync_get.key_type = key_type;
	async->args.vlan_translate_stat_sync_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_sync_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_sync_get.stat = stat;
	async->args.vlan_translate_stat_sync_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_stat_sync_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SYNC_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_sync_get32.unit = unit;
	async->args.vlan_translate_stat_sync_get32.port = port;
	async->args.vlan_translate_stat_sync_get32.key_type = key_type;
	async->args.vlan_translate_stat_sync_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_sync_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_sync_get32.stat = stat;
	async->args.vlan_translate_stat_sync_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_translate_traverse_async(
	int unit,
	bcm_vlan_translate_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_TRANSLATE_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_traverse.unit = unit;
	async->args.vlan_translate_traverse.cb = cb;
	async->args.vlan_translate_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vector_flags_set_async(
	int unit,
	bcm_vlan_vector_t vlan_vector,
	uint32 flags_mask,
	uint32 flags_value,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VECTOR_FLAGS_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vector_flags_set.unit = unit;
	async->args.vlan_vector_flags_set.vlan_vector = (uint32 *)vlan_vector;
	async->args.vlan_vector_flags_set.flags_mask = flags_mask;
	async->args.vlan_vector_flags_set.flags_value = flags_value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vector_stp_set_async(
	int unit,
	bcm_vlan_vector_t vlan_vector,
	bcm_port_t port,
	int stp_state,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VECTOR_STP_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vector_stp_set.unit = unit;
	async->args.vlan_vector_stp_set.vlan_vector = (uint32 *)vlan_vector;
	async->args.vlan_vector_stp_set.port = port;
	async->args.vlan_vector_stp_set.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_vlan_vpn_create_async(
	int unit,
	bcm_vlan_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VPN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vpn_create.unit = unit;
	async->args.vlan_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vpn_destroy_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VPN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vpn_destroy.unit = unit;
	async->args.vlan_vpn_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vpn_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VPN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vpn_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vpn_get_async(
	int unit,
	bcm_vpn_t vpn,
	bcm_vlan_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vpn_get.unit = unit;
	async->args.vlan_vpn_get.vpn = vpn;
	async->args.vlan_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vlan_vpn_traverse_async(
	int unit,
	bcm_vlan_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VLAN_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vpn_traverse.unit = unit;
	async->args.vlan_vpn_traverse.cb = cb;
	async->args.vlan_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcm_vswitch_create_async(
	int unit,
	bcm_vlan_t * vsi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_create.unit = unit;
	async->args.vswitch_create.vsi = vsi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_create_with_id_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CREATE_WITH_ID;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_create_with_id.unit = unit;
	async->args.vswitch_create_with_id.vsi = vsi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_cross_connect_add_async(
	int unit,
	bcm_vswitch_cross_connect_t * gports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CROSS_CONNECT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_cross_connect_add.unit = unit;
	async->args.vswitch_cross_connect_add.gports = gports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_cross_connect_delete_async(
	int unit,
	bcm_vswitch_cross_connect_t * gports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CROSS_CONNECT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_cross_connect_delete.unit = unit;
	async->args.vswitch_cross_connect_delete.gports = gports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_cross_connect_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CROSS_CONNECT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_cross_connect_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_cross_connect_get_async(
	int unit,
	bcm_vswitch_cross_connect_t * gports,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CROSS_CONNECT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_cross_connect_get.unit = unit;
	async->args.vswitch_cross_connect_get.gports = gports;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_cross_connect_traverse_async(
	int unit,
	bcm_vswitch_cross_connect_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_CROSS_CONNECT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_cross_connect_traverse.unit = unit;
	async->args.vswitch_cross_connect_traverse.cb = cb;
	async->args.vswitch_cross_connect_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_destroy_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_destroy.unit = unit;
	async->args.vswitch_destroy.vsi = vsi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_flexible_connect_add_async(
	int unit,
	uint32 flags,
	bcm_vswitch_flexible_connect_match_t * port_match,
	bcm_vswitch_flexible_connect_fwd_t * port_fwd,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_FLEXIBLE_CONNECT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_flexible_connect_add.unit = unit;
	async->args.vswitch_flexible_connect_add.flags = flags;
	async->args.vswitch_flexible_connect_add.port_match = port_match;
	async->args.vswitch_flexible_connect_add.port_fwd = port_fwd;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_flexible_connect_delete_async(
	int unit,
	bcm_vswitch_flexible_connect_match_t * port_match,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_FLEXIBLE_CONNECT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_flexible_connect_delete.unit = unit;
	async->args.vswitch_flexible_connect_delete.port_match = port_match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_flexible_connect_get_async(
	int unit,
	uint32 flags,
	bcm_vswitch_flexible_connect_match_t * port_match,
	bcm_vswitch_flexible_connect_fwd_t * port_fwd,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_FLEXIBLE_CONNECT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_flexible_connect_get.unit = unit;
	async->args.vswitch_flexible_connect_get.flags = flags;
	async->args.vswitch_flexible_connect_get.port_match = port_match;
	async->args.vswitch_flexible_connect_get.port_fwd = port_fwd;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_port_add_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_port_add.unit = unit;
	async->args.vswitch_port_add.vsi = vsi;
	async->args.vswitch_port_add.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_port_delete_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_gport_t port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_port_delete.unit = unit;
	async->args.vswitch_port_delete.vsi = vsi;
	async->args.vswitch_port_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_port_delete_all_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_port_delete_all.unit = unit;
	async->args.vswitch_port_delete_all.vsi = vsi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_port_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vlan_t * vsi,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_port_get.unit = unit;
	async->args.vswitch_port_get.port = port;
	async->args.vswitch_port_get.vsi = vsi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vswitch_port_traverse_async(
	int unit,
	bcm_vlan_t vsi,
	bcm_vswitch_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VSWITCH_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vswitch_port_traverse.unit = unit;
	async->args.vswitch_port_traverse.vsi = vsi;
	async->args.vswitch_port_traverse.cb = cb;
	async->args.vswitch_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcm_vxlan_cleanup_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_CLEANUP;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_cleanup.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_attach_async(
	int unit,
	bcm_ip_t vxlan_dip,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_attach.unit = unit;
	async->args.vxlan_dip_stat_attach.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_counter_get_async(
	int unit,
	bcm_ip_t vxlan_dip,
	bcm_vxlan_dip_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_counter_get.unit = unit;
	async->args.vxlan_dip_stat_counter_get.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_counter_get.stat = stat;
	async->args.vxlan_dip_stat_counter_get.num_entries = num_entries;
	async->args.vxlan_dip_stat_counter_get.counter_indexes = counter_indexes;
	async->args.vxlan_dip_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_counter_set_async(
	int unit,
	bcm_ip_t vxlan_dip,
	bcm_vxlan_dip_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_counter_set.unit = unit;
	async->args.vxlan_dip_stat_counter_set.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_counter_set.stat = stat;
	async->args.vxlan_dip_stat_counter_set.num_entries = num_entries;
	async->args.vxlan_dip_stat_counter_set.counter_indexes = counter_indexes;
	async->args.vxlan_dip_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_detach_async(
	int unit,
	bcm_ip_t vxlan_dip,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_detach.unit = unit;
	async->args.vxlan_dip_stat_detach.vxlan_dip = vxlan_dip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_id_get_async(
	int unit,
	bcm_ip_t vxlan_dip,
	bcm_vxlan_dip_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_id_get.unit = unit;
	async->args.vxlan_dip_stat_id_get.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_id_get.stat = stat;
	async->args.vxlan_dip_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_multi_get_async(
	int unit,
	bcm_ip_t vxlan_dip,
	int nstat,
	bcm_vxlan_dip_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_multi_get.unit = unit;
	async->args.vxlan_dip_stat_multi_get.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_multi_get.nstat = nstat;
	async->args.vxlan_dip_stat_multi_get.stat_arr = stat_arr;
	async->args.vxlan_dip_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_multi_get32_async(
	int unit,
	bcm_ip_t vxlan_dip,
	int nstat,
	bcm_vxlan_dip_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_multi_get32.unit = unit;
	async->args.vxlan_dip_stat_multi_get32.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_multi_get32.nstat = nstat;
	async->args.vxlan_dip_stat_multi_get32.stat_arr = stat_arr;
	async->args.vxlan_dip_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_multi_set_async(
	int unit,
	bcm_ip_t vxlan_dip,
	int nstat,
	bcm_vxlan_dip_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_multi_set.unit = unit;
	async->args.vxlan_dip_stat_multi_set.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_multi_set.nstat = nstat;
	async->args.vxlan_dip_stat_multi_set.stat_arr = stat_arr;
	async->args.vxlan_dip_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_dip_stat_multi_set32_async(
	int unit,
	bcm_ip_t vxlan_dip,
	int nstat,
	bcm_vxlan_dip_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_DIP_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_dip_stat_multi_set32.unit = unit;
	async->args.vxlan_dip_stat_multi_set32.vxlan_dip = vxlan_dip;
	async->args.vxlan_dip_stat_multi_set32.nstat = nstat;
	async->args.vxlan_dip_stat_multi_set32.stat_arr = stat_arr;
	async->args.vxlan_dip_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_add_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_vxlan_port_t * vxlan_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_add.unit = unit;
	async->args.vxlan_port_add.l2vpn = l2vpn;
	async->args.vxlan_port_add.vxlan_port = vxlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_delete_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_gport_t vxlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_delete.unit = unit;
	async->args.vxlan_port_delete.l2vpn = l2vpn;
	async->args.vxlan_port_delete.vxlan_port_id = vxlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_delete_all_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_delete_all.unit = unit;
	async->args.vxlan_port_delete_all.l2vpn = l2vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_get_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_vxlan_port_t * vxlan_port,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_get.unit = unit;
	async->args.vxlan_port_get.l2vpn = l2vpn;
	async->args.vxlan_port_get.vxlan_port = vxlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_get_all_async(
	int unit,
	bcm_vpn_t l2vpn,
	int port_max,
	bcm_vxlan_port_t * port_array,
	int * port_count,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_GET_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_get_all.unit = unit;
	async->args.vxlan_port_get_all.l2vpn = l2vpn;
	async->args.vxlan_port_get_all.port_max = port_max;
	async->args.vxlan_port_get_all.port_array = port_array;
	async->args.vxlan_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_port_traverse_async(
	int unit,
	bcm_vxlan_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_port_traverse.unit = unit;
	async->args.vxlan_port_traverse.cb = cb;
	async->args.vxlan_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_attach_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	uint32 stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_ATTACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_attach.unit = unit;
	async->args.vxlan_stat_attach.port = port;
	async->args.vxlan_stat_attach.vpn = vpn;
	async->args.vxlan_stat_attach.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_counter_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_vxlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_COUNTER_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_counter_get.unit = unit;
	async->args.vxlan_stat_counter_get.port = port;
	async->args.vxlan_stat_counter_get.vpn = vpn;
	async->args.vxlan_stat_counter_get.stat = stat;
	async->args.vxlan_stat_counter_get.num_entries = num_entries;
	async->args.vxlan_stat_counter_get.counter_indexes = counter_indexes;
	async->args.vxlan_stat_counter_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_counter_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_vxlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_COUNTER_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_counter_set.unit = unit;
	async->args.vxlan_stat_counter_set.port = port;
	async->args.vxlan_stat_counter_set.vpn = vpn;
	async->args.vxlan_stat_counter_set.stat = stat;
	async->args.vxlan_stat_counter_set.num_entries = num_entries;
	async->args.vxlan_stat_counter_set.counter_indexes = counter_indexes;
	async->args.vxlan_stat_counter_set.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_counter_sync_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_vxlan_stat_t stat,
	uint32 num_entries,
	uint32 * counter_indexes,
	bcm_stat_value_t * counter_values,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_COUNTER_SYNC_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_counter_sync_get.unit = unit;
	async->args.vxlan_stat_counter_sync_get.port = port;
	async->args.vxlan_stat_counter_sync_get.vpn = vpn;
	async->args.vxlan_stat_counter_sync_get.stat = stat;
	async->args.vxlan_stat_counter_sync_get.num_entries = num_entries;
	async->args.vxlan_stat_counter_sync_get.counter_indexes = counter_indexes;
	async->args.vxlan_stat_counter_sync_get.counter_values = counter_values;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_detach_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_detach.unit = unit;
	async->args.vxlan_stat_detach.port = port;
	async->args.vxlan_stat_detach.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_enable_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int enable,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_ENABLE_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_enable_set.unit = unit;
	async->args.vxlan_stat_enable_set.port = port;
	async->args.vxlan_stat_enable_set.vpn = vpn;
	async->args.vxlan_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_id_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	bcm_vxlan_stat_t stat,
	uint32 * stat_counter_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_ID_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_id_get.unit = unit;
	async->args.vxlan_stat_id_get.port = port;
	async->args.vxlan_stat_id_get.vpn = vpn;
	async->args.vxlan_stat_id_get.stat = stat;
	async->args.vxlan_stat_id_get.stat_counter_id = stat_counter_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_multi_get_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_vxlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_MULTI_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_multi_get.unit = unit;
	async->args.vxlan_stat_multi_get.port = port;
	async->args.vxlan_stat_multi_get.vpn = vpn;
	async->args.vxlan_stat_multi_get.nstat = nstat;
	async->args.vxlan_stat_multi_get.stat_arr = stat_arr;
	async->args.vxlan_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_multi_get32_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_vxlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_MULTI_GET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_multi_get32.unit = unit;
	async->args.vxlan_stat_multi_get32.port = port;
	async->args.vxlan_stat_multi_get32.vpn = vpn;
	async->args.vxlan_stat_multi_get32.nstat = nstat;
	async->args.vxlan_stat_multi_get32.stat_arr = stat_arr;
	async->args.vxlan_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_multi_set_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_vxlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_MULTI_SET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_multi_set.unit = unit;
	async->args.vxlan_stat_multi_set.port = port;
	async->args.vxlan_stat_multi_set.vpn = vpn;
	async->args.vxlan_stat_multi_set.nstat = nstat;
	async->args.vxlan_stat_multi_set.stat_arr = stat_arr;
	async->args.vxlan_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_stat_multi_set32_async(
	int unit,
	bcm_gport_t port,
	bcm_vpn_t vpn,
	int nstat,
	bcm_vxlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_STAT_MULTI_SET32;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_stat_multi_set32.unit = unit;
	async->args.vxlan_stat_multi_set32.port = port;
	async->args.vxlan_stat_multi_set32.vpn = vpn;
	async->args.vxlan_stat_multi_set32.nstat = nstat;
	async->args.vxlan_stat_multi_set32.stat_arr = stat_arr;
	async->args.vxlan_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_initiator_create_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_INITIATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_initiator_create.unit = unit;
	async->args.vxlan_tunnel_initiator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_initiator_destroy_async(
	int unit,
	bcm_gport_t vxlan_tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_INITIATOR_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_initiator_destroy.unit = unit;
	async->args.vxlan_tunnel_initiator_destroy.vxlan_tunnel_id = vxlan_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_initiator_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_INITIATOR_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_initiator_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_initiator_get_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_INITIATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_initiator_get.unit = unit;
	async->args.vxlan_tunnel_initiator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_initiator_traverse_async(
	int unit,
	bcm_tunnel_initiator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_INITIATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_initiator_traverse.unit = unit;
	async->args.vxlan_tunnel_initiator_traverse.cb = cb;
	async->args.vxlan_tunnel_initiator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_create_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_create.unit = unit;
	async->args.vxlan_tunnel_terminator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_destroy_async(
	int unit,
	bcm_gport_t vxlan_tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_destroy.unit = unit;
	async->args.vxlan_tunnel_terminator_destroy.vxlan_tunnel_id = vxlan_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_get_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_get.unit = unit;
	async->args.vxlan_tunnel_terminator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_traverse_async(
	int unit,
	bcm_tunnel_terminator_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_traverse.unit = unit;
	async->args.vxlan_tunnel_terminator_traverse.cb = cb;
	async->args.vxlan_tunnel_terminator_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_tunnel_terminator_update_async(
	int unit,
	bcm_tunnel_terminator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_TUNNEL_TERMINATOR_UPDATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_tunnel_terminator_update.unit = unit;
	async->args.vxlan_tunnel_terminator_update.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_vpn_create_async(
	int unit,
	bcm_vxlan_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_VPN_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_vpn_create.unit = unit;
	async->args.vxlan_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_vpn_destroy_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_VPN_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_vpn_destroy.unit = unit;
	async->args.vxlan_vpn_destroy.l2vpn = l2vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_vpn_destroy_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_VPN_DESTROY_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_vpn_destroy_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_vpn_get_async(
	int unit,
	bcm_vpn_t l2vpn,
	bcm_vxlan_vpn_config_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_VPN_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_vpn_get.unit = unit;
	async->args.vxlan_vpn_get.l2vpn = l2vpn;
	async->args.vxlan_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_vxlan_vpn_traverse_async(
	int unit,
	bcm_vxlan_vpn_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_VXLAN_VPN_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vxlan_vpn_traverse.unit = unit;
	async->args.vxlan_vpn_traverse.cb = cb;
	async->args.vxlan_vpn_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_client_add_async(
	int unit,
	bcm_wlan_client_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_CLIENT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_add.unit = unit;
	async->args.wlan_client_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_client_delete_async(
	int unit,
	bcm_mac_t mac,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_CLIENT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_delete.unit = unit;
	async->args.wlan_client_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_client_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_CLIENT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_client_get_async(
	int unit,
	bcm_mac_t mac,
	bcm_wlan_client_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_CLIENT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_get.unit = unit;
	async->args.wlan_client_get.mac = (uint8 *)mac;
	async->args.wlan_client_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_client_traverse_async(
	int unit,
	bcm_wlan_client_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_CLIENT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_traverse.unit = unit;
	async->args.wlan_client_traverse.cb = cb;
	async->args.wlan_client_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_detach_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_DETACH;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_init_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_INIT;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_init.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_port_add_async(
	int unit,
	bcm_wlan_port_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_PORT_ADD;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_add.unit = unit;
	async->args.wlan_port_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_port_delete_async(
	int unit,
	bcm_gport_t wlan_port_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_PORT_DELETE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_delete.unit = unit;
	async->args.wlan_port_delete.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_port_delete_all_async(
	int unit,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_PORT_DELETE_ALL;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_delete_all.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_port_get_async(
	int unit,
	bcm_gport_t wlan_port_id,
	bcm_wlan_port_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_PORT_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_get.unit = unit;
	async->args.wlan_port_get.wlan_port_id = wlan_port_id;
	async->args.wlan_port_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_port_traverse_async(
	int unit,
	bcm_wlan_port_traverse_cb cb,
	void * user_data,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_PORT_TRAVERSE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_traverse.unit = unit;
	async->args.wlan_port_traverse.cb = cb;
	async->args.wlan_port_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_tunnel_initiator_create_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_CREATE;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_create.unit = unit;
	async->args.wlan_tunnel_initiator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_tunnel_initiator_destroy_async(
	int unit,
	bcm_gport_t wlan_tunnel_id,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_DESTROY;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_destroy.unit = unit;
	async->args.wlan_tunnel_initiator_destroy.wlan_tunnel_id = wlan_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcm_wlan_tunnel_initiator_get_async(
	int unit,
	bcm_tunnel_initiator_t * info,
	bcm_async_cb_t async_callback,
	void *async_cookie)
{
	bcm_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcm_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_GET;
	async->run = bcm_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_get.unit = unit;
	async->args.wlan_tunnel_initiator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */
#endif	/* BCM_ASYNC_SUPPORT */
