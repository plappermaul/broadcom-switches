/*
 * $Id: field_tests.c,v 1.201 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * Module: Field Processor APIs
 *
 * Purpose:
 *     'Field Processor' (FP) API for Dune Packet Processor devices
 *       Tests Functions
 *       PPD layer feature enumeration
 *       BCM layer feature configuration
 */
#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_FP

#define _ERR_CHECK_BCM_PETRA_FIELD_TEST_RESET(rv) \
    do { \
      if((rv) == -1) /* tr 141 failed */ { \
        _BCM_PETRA_FIELD_TEST_FAIL_MSG; \
        goto fail; \
      } \
    } while(0)

#include <soc/hwstate/hw_log.h>
#include <shared/bsl.h>
#include <appl/diag/shell.h>
#include <bcm/field.h>
#include <bcm/error.h>

#include <bcm_int/petra_dispatch.h>
#include <bcm_int/dpp/field_int.h>
#include <bcm_int/dpp/l3.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/qos.h>
#include <bcm_int/common/debug.h>

#include <shared/alloc.h>
#include <sal/appl/sal.h>

#include <shared/swstate/access/sw_state_access.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_fp.h>
#include <soc/dpp/ARAD/arad_pmf_low_level_ce.h>
#include <soc/dpp/ARAD/arad_sw_db.h>
#include <soc/dpp/ARAD/arad_header_parsing_utils.h>
#include <soc/dpp/PPD/ppd_api_diag.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_diag.h>
#include <appl/diag/test.h>
#include <soc/dcmn/dcmn_wb.h>

extern int test_dispatch(int u, test_t *test, int loops, args_t *a);

extern int init_deinit_test(int u, args_t *a, void *p);
extern int init_deinit_test_init(int unit, args_t *a, void **p);
extern int init_deinit_test_done(int unit, void *p);

/* The slow level is according to the run time of the test:
 * 0 - till 0.3 seconds
 * 1 - 0.3 seconds to 3 seconds 
 * 2 - 3 seconds to 8 seconds 
 * 3 - 8 seconds to 20 seconds 
 * 4 - more then 20 seconds 
 */

#define _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SUPER_FAST(slow_level, nof_iterations)\
    switch(slow_level) {\
    case 0:\
        nof_iterations = 2;\
        break;\
    case 1:\
        nof_iterations = 1;\
        break;\
    default:\
        nof_iterations = 0;\
        break;\
    }

#define _BCM_PETRA_FIELD_TEST_NOF_ITERATION_FAST(slow_level, nof_iterations)\
    switch(slow_level) {\
    case 0:\
        nof_iterations = 10;\
        break;\
    case 1:\
        nof_iterations = 10;\
        break;\
    case 2:\
        nof_iterations = 5;\
        break;\
    default:\
        nof_iterations = 0;\
        break;\
    }

#define _BCM_PETRA_FIELD_TEST_NOF_ITERATION_MEDIUM(slow_level, nof_iterations)\
    switch(slow_level) {\
    case 0:\
        nof_iterations = 100;\
        break;\
    case 1:\
        nof_iterations = 50;\
        break;\
    case 2:\
        nof_iterations = 5;\
        break;\
    case 3:\
        nof_iterations = 8;\
        break;\
    case 4:\
        nof_iterations = 1;\
        break;\
    default:\
        nof_iterations = 0;\
        break;\
    }

#define _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SLOW(slow_level, nof_iterations)\
    switch(slow_level) {\
    case 0:\
        nof_iterations = 10000;\
        break;\
    case 1:\
        nof_iterations = 5000;\
        break;\
    case 2:\
        nof_iterations = 500;\
        break;\
    case 3:\
        nof_iterations = 100;\
        break;\
    case 4:\
        nof_iterations = 10;\
        break;\
    default:\
        nof_iterations = 0;\
        break;\
    }
#define _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN      -1

#define _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST       10

#define _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage)\
    (stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL ? 2 : 1)
#define _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX 2
#define _BCM_PETRA_FIELD_TEST_NOF_INTERNAL_ENTRY_IDS(unit)  SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit)
#define _BCM_PETRA_FIELD_TEST_NOF_EXTERNAL_ENTRY_IDS  SOC_TMC_TCAM_NL_88650_MAX_NOF_ENTRIES
#define _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_FULL_TCAM   1<<14  
#define _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_FULL_TCAM_PERF(unit)     SOC_DPP_DEFS_GET(unit, nof_tcam_entries_160_bits)
#define _BCM_PETRA_FIELD_TEST_NOF_PRIORITIES_FULL_TCAM_PERF 5
#define _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_PER_PRIO_FULL_TCAM_PERF(unit)   (SOC_DPP_DEFS_GET(unit, nof_tcam_big_bank_lines) / 2) /* 2 priority blocks per big bank */
#define _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH           512
#define _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY 12
#define _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY    9
#define _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)\
    ((nof_iterations) >=  10000 ? (2*1024) : 100)
#define _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST 100

#define _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE         320
#define _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_SIZE_PERF        160 /* Predefined group bank size for the performance tests */
#define _BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD  7

#define _BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST           120 /*127 (Highest priority - 7 priorities used for ITMH programmable mode)*/
#define _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST            0

#define _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX       3
#define _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(stage) \
    (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS ? 3 : 1)
#define _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX       3

/* number of field groups we will create in the test of field_group_destroy in order to have failure in the creation */
#define _BCM_FIELD_GROUP_TEST_NOF_GROUPS_DESTROY      10
#define _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS 7

#define _BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID        120 /*127 (Highest group id - 7 groups used for ITMH programmable mode)*/
#define _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_QUALIFIERS(stage)\
    (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS ? 6 : 4)
    
/* It has no meaning for egress */    
#define _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_ACTIONS 2

#define _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS    1
#define _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_ITEMS_TO_TEST   100

#define _BCM_PETRA_FIELD_TYPE_ETHR                    0
#define _BCM_PETRA_FIELD_TYPE_IPV4                    1
#define _BCM_PETRA_FIELD_TYPE_IPV6                    2
#define _BCM_PETRA_FIELD_TYPE_MPLS                    3
#define _BCM_PETRA_FIELD_NOF_TYPES                    4

#define _BCM_PETRA_FIELD_QUAL_CHAIN                   2
#define _BCM_PETRA_FIELD_ACTION_CHAIN                 2

#define _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)      ( SOC_IS_QAX(unit)?  120 : 160 )             

#define _BCM_PETRA_FIELD_PRIORITY_TEST_NOF_ENTRIES(nof_iterations) \
    ((nof_iterations) >=  10000 ? (3*1024) : 100)
#define _BCM_PETRA_FIELD_PRIORITY_TEST_NOF_FLIPS      4

#define _BCM_PETRA_FIELD_EGRESS_COS_PROFILE_FOR_HIT_CHECK 5

#define _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES  SOC_PPC_FP_NOF_MACRO_SIMPLES
#define _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACROS         SOC_PPC_FP_NOF_MACROS

#define _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS  4

#define _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_ACTION_CHECKED   -16

#define _BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS  4
#define _BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_NOF_ENTRIES_TO_INSTALL_IN_BATCH    200

#define _BCM_PETRA_FIELD_TEST_CASCADED_MIN_NOF_BITS   4
#define _BCM_PETRA_FIELD_TEST_CASCADED_MAX_NOF_BITS(unit)   (SOC_DPP_DEFS_GET(unit, tcam_cascaded_data_nof_bits) - 4)
#define _BCM_PETRA_FIELD_TEST_CASCADED_FORWARDING_VLAN_ID_NEW_VALUE  10

#define _BCM_PETRA_FIELD_TEST_NOF_PRESELS             5

#define _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS     4
#define _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS   5
#define _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS 4
#define _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_FLIPS   10
#define _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PACKETS_TO_SEND        10

/*
 * Checking if system mode is FRETTA-XR.
 * Used in _BCM_PETRA_FIELD_TEST_USED_ITMH_DATA_QUALIFIERS(unit) for calculating 
 * of used ITMH qualifiers.
 */
int fretta_xr_mode_check(int unit)
{
    char *fretta_mode;

    fretta_mode = soc_property_get_str(unit, "dvapi_system_indicator");
    if(fretta_mode == NULL || strcmp(fretta_mode, "FRETTA-XR")) {
        return 0;
    }else{
        return 1;
    }
}
#define _BCM_PETRA_FIELD_TEST_USED_ITMH_DATA_QUALIFIERS(unit)        (fretta_xr_mode_check(unit) ? 7 : 6) /*6 last dataquals are used for ITMH programmable mode setting, but fretta mode uses 7*/
#define _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit)            (SOC_PPC_FP_QUAL_HDR_USER_DEF_LAST - SOC_PPC_FP_QUAL_HDR_USER_DEF_0 - _BCM_PETRA_FIELD_TEST_USED_ITMH_DATA_QUALIFIERS(unit))
#define _BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_OFFSET(unit)        (SOC_IS_QAX(unit)? 296:504)
#define _BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_LENGTH              32

#define _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION           5
#define _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAX_LSB_FIELD_GROUPS 4 /* the same for msb */
#define _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH  32
#define _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP 2
#define _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_DIRECT_EXTRACTION          48

/* Direct extraction: more than 19b in Arad, 24b in Jericho - e.g. Trap action */
#define _BCM_PETRA_FIELD_TEST_LARGE_DIRECT_EXTRACTION_ACTION         (SOC_IS_JERICHO(unit)? bcmFieldActionTrap: bcmFieldActionLearnInVPortNew)

#define _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES       20
#define _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_QUALIFIERS_LENGTH_SMALL_BANK 7

#define _BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC          2
#define _BCM_PETRA_FIELD_TEST_ITMH_NOF_ACTIONS                       21

#define _BCM_PETRA_FIELD_TEST_ITMH_PARSING_TEST_NOF_FLIPS            100

/* Macros */
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_WARN \
    bsl_check(bslLayerBcm, bslSourceFp, bslSeverityWarn, unit)
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR \
    bsl_check(bslLayerBcm, bslSourceFp, bslSeverityError, unit)
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB \
    bsl_check(bslLayerBcm, bslSourceFp, bslSeverityVerbose, unit)
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VVERB \
    bsl_check(bslLayerBcm, bslSourceFp, bslSeverityDebug, unit)
#if _BCM_DPP_FIELD_EXCESS_VERBOSITY
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB \
    bsl_check(bslLayerBcm, bslSourceFp, bslSeverityDebug, unit)
#else /* _BCM_DPP_FIELD_EXCESS_VERBOSITY */
#define _BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB 0
#endif /* _BCM_DPP_FIELD_EXCESS_VERBOSITY */

#define _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)\
    ((stage) == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS ? "Ingress" : \
    ((stage) == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS ? "Egress" : "External")) 


#define _BCM_PETRA_FIELD_TEST_FAIL_MSG\
    LOG_ERROR(BSL_LS_BCM_FP,\
              (BSL_META_U(unit,\
                          "Failed in field_tests.c line %d.\n"), __LINE__));

#define _BCM_PETRA_TEST_DEINIT_INIT(unit, rv)\
{\
    test_t test;\
    test.t_name = "DEINT INIT (SOC BCM)";\
    test.t_flags = 0x80100000;\
    test.t_test = 141;\
    test.t_loops = 1;\
    test.t_init_f = init_deinit_test_init;\
    test.t_done_f = init_deinit_test_done;\
    test.t_test_f = init_deinit_test;\
    test.t_default_string = 0x0;\
    test.t_override_string = 0x0;\
    test.t_runs = 0;\
    test.t_success = 0;\
    test.t_fail = 0;\
    WB_TEST(_ERR_CHECK_BCM_PETRA_FIELD_TEST_RESET(rv));\
    rv = test_dispatch(unit, &test, -1, NULL);\
    if(rv != BCM_E_NONE) {\
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;\
        goto fail;\
    }\
    _DCMN_BCM_WARM_BOOT_API_TEST_OVERRIDE_WB_TEST_MODE(unit);\
}


typedef enum{
    _bcmPetraFieldTestSuperFast = 0,
    _bcmPetraFieldTestFast = 1,
    _bcmPetraFieldTestMedium = 2,
    _bcmPetraFieldTestSlow = 3,
    _bcmPetraFieldTestScan = 4
}_bcmPetraFieldTestSpeedMode;


typedef struct _bcm_petra_field_test_qualify_info_e
{
    uint8                 is_valid;
    uint8                 is_undefined;/* if TRUE - data qualifier */
    bcm_field_qualify_t   qualify;
    uint32                data[_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32];
    uint32                mask[_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32];
}_bcm_petra_field_test_qualify_info_t;

typedef struct _bcm_petra_field_test_action_info_s
{
    uint8                 is_valid;
    bcm_field_action_t    action;
    uint32                param0;
    uint32                param1;
}_bcm_petra_field_test_action_info_t;

typedef struct _bcm_petra_field_test_entry_info_e
{
    bcm_field_entry_t  id;
    int  priority;
    _bcm_petra_field_test_qualify_info_t quals_info[_BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY];
    _bcm_petra_field_test_action_info_t  actions_info[_BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY];
}_bcm_petra_field_test_entry_info_t;

typedef struct _bcm_petra_field_test_qualifier_info_e
{
    bcm_field_qualify_t qualify;
    int (*set)(void); /* the prototype will be casted */
    int (*get)(void); /* the prototype will be casted */
    uint32 size; /* in bits */
    uint32 prototype_id; /* see details below */
}_bcm_petra_field_test_qualifier_info_t;

typedef struct _bcm_petra_field_test_vlan_header_e{
    uint16 vlan_id;
    uint8 cfi;
    uint8 pri;
    uint16 tag_protocol_id;
}_bcm_petra_field_test_vlan_header_t;

typedef struct _bcm_petra_field_test_ethernet_header_e{
    uint16 ethertype;
    uint8 nof_vlans;
    _bcm_petra_field_test_vlan_header_t vlans[2];
    bcm_mac_t source_address;
    bcm_mac_t destination_address;
}_bcm_petra_field_test_ethernet_header_t;

typedef struct _bcm_petra_field_test_ipv4_header_e{
    bcm_ip_t destination_address;
    bcm_ip_t source_address;
    uint16 header_checksum;
    uint8 protocol;
    uint8 time_to_live;
    uint16 fragment_offset;
    uint8 flags;
    uint16 identification;
    uint16 total_length;
    uint8 ecn;
    uint8 dscp;/* include the ecn*/
    uint8 internet_header_length;
    uint8 version;
}_bcm_petra_field_test_ipv4_header_t;

typedef struct _bcm_petra_field_test_ipv6_header_e{
    bcm_ip6_t destination_address;
    bcm_ip6_t source_address;
    uint8 hop_limit;
    uint8 next_header;
    uint16 payload_length;
    uint32 flow_label;
    uint8 traffic_class;
    uint8 version;
}_bcm_petra_field_test_ipv6_header_t;

typedef struct _bcm_petra_field_test_mpls_header_e{
    uint8 time_to_live;
    uint8 bos;
    uint8 exp;
    uint32 label;
}_bcm_petra_field_test_mpls_header_t;

typedef struct _bcm_petra_field_test_tcp_header_e{
/* 
 * just for the tests.
 * Don't have all the attributes
 */
    uint16 destination_port;
    uint16 source_port;
    uint8 control;
}_bcm_petra_field_test_tcp_header_t;
     
STATIC _bcm_petra_field_test_qualifier_info_t qualifiers_info[] = {
    {bcmFieldQualifySrcIp6,                             (int (*)(void)) bcm_field_qualify_SrcIp6,                             (int (*)(void)) bcm_field_qualify_SrcIp6_get,                             0, 0},
    {bcmFieldQualifyDstIp6,                             (int (*)(void)) bcm_field_qualify_DstIp6,                             (int (*)(void)) bcm_field_qualify_DstIp6_get,                             0, 0},
    {bcmFieldQualifySrcIp6High,                         (int (*)(void)) bcm_field_qualify_SrcIp6High,                         (int (*)(void)) bcm_field_qualify_SrcIp6High_get,                         0, 0},
    {bcmFieldQualifyDstIp6High,                         (int (*)(void)) bcm_field_qualify_DstIp6High,                         (int (*)(void)) bcm_field_qualify_DstIp6High_get,                         0, 0},
    {bcmFieldQualifySrcIp6Low,                          (int (*)(void)) bcm_field_qualify_SrcIp6Low,                          (int (*)(void)) bcm_field_qualify_SrcIp6Low_get,                          0, 0},
    {bcmFieldQualifyDstIp6Low,                          (int (*)(void)) bcm_field_qualify_DstIp6Low,                          (int (*)(void)) bcm_field_qualify_DstIp6Low_get,                          0, 0},
    {bcmFieldQualifySrcMac,                             (int (*)(void)) bcm_field_qualify_SrcMac,                             (int (*)(void)) bcm_field_qualify_SrcMac_get,                             0, 1},
    {bcmFieldQualifyDstMac,                             (int (*)(void)) bcm_field_qualify_DstMac,                             (int (*)(void)) bcm_field_qualify_DstMac_get,                             0, 1},
    {bcmFieldQualifySnap,                               (int (*)(void)) bcm_field_qualify_Snap,                               (int (*)(void)) bcm_field_qualify_Snap_get,                               0, 2},
    {bcmFieldQualifySrcIp,                              (int (*)(void)) bcm_field_qualify_SrcIp,                              (int (*)(void)) bcm_field_qualify_SrcIp_get,                              0, 3},
    {bcmFieldQualifyDstIp,                              (int (*)(void)) bcm_field_qualify_DstIp,                              (int (*)(void)) bcm_field_qualify_DstIp_get,                              0, 3},
    {bcmFieldQualifyLlc,                                (int (*)(void)) bcm_field_qualify_Llc,                                (int (*)(void)) bcm_field_qualify_Llc_get,                                0, 4},
    {bcmFieldQualifyInPort,                             (int (*)(void)) bcm_field_qualify_InPort,                             (int (*)(void)) bcm_field_qualify_InPort_get,                             0, 5},
    {bcmFieldQualifyInPorts,                            (int (*)(void)) bcm_field_qualify_InPorts,                            (int (*)(void)) bcm_field_qualify_InPorts_get,                            0, 6},
    {bcmFieldQualifyOutPorts,                           (int (*)(void)) bcm_field_qualify_OutPorts,                           (int (*)(void)) bcm_field_qualify_OutPorts_get,                           0, 6},
    {bcmFieldQualifyDrop,                               (int (*)(void)) bcm_field_qualify_Drop,                               (int (*)(void)) bcm_field_qualify_Drop_get,                               0, 7},
    {bcmFieldQualifyIp6FlowLabel,                       (int (*)(void)) bcm_field_qualify_Ip6FlowLabel,                       (int (*)(void)) bcm_field_qualify_Ip6FlowLabel_get,                       0, 8},
    {bcmFieldQualifyOuterVlan,                          (int (*)(void)) bcm_field_qualify_OuterVlan,                          (int (*)(void)) bcm_field_qualify_OuterVlan_get,                          0, 9},
    {bcmFieldQualifyOuterVlanId,                        (int (*)(void)) bcm_field_qualify_OuterVlanId,                        (int (*)(void)) bcm_field_qualify_OuterVlanId_get,                        0, 9},
    {bcmFieldQualifyOuterVlanPri,                       (int (*)(void)) bcm_field_qualify_OuterVlanPri,                       (int (*)(void)) bcm_field_qualify_OuterVlanPri_get,                       0, 7},
    {bcmFieldQualifyOuterVlanCfi,                       (int (*)(void)) bcm_field_qualify_OuterVlanCfi,                       (int (*)(void)) bcm_field_qualify_OuterVlanCfi_get,                       0, 7},
    {bcmFieldQualifyOuterVlanPriCfi,                    (int (*)(void)) bcm_field_qualify_OuterVlanPriCfi,                    (int (*)(void)) bcm_field_qualify_OuterVlanPriCfi_get,                    0, 7},
    {bcmFieldQualifyInnerVlan,                          (int (*)(void)) bcm_field_qualify_InnerVlan,                          (int (*)(void)) bcm_field_qualify_InnerVlan_get,                          0, 9},
    {bcmFieldQualifyInnerVlanId,                        (int (*)(void)) bcm_field_qualify_InnerVlanId,                        (int (*)(void)) bcm_field_qualify_InnerVlanId_get,                        0, 9},
    {bcmFieldQualifyInnerVlanPri,                       (int (*)(void)) bcm_field_qualify_InnerVlanPri,                       (int (*)(void)) bcm_field_qualify_InnerVlanPri_get,                       0, 7},
    {bcmFieldQualifyInnerVlanCfi,                       (int (*)(void)) bcm_field_qualify_InnerVlanCfi,                       (int (*)(void)) bcm_field_qualify_InnerVlanCfi_get,                       0, 7},
    {bcmFieldQualifyLookupStatus,                       NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyRangeCheck,                         NULL,                                                                 NULL,                                                                     0, 10},
    {bcmFieldQualifyL4PortRangeCheck,                   NULL,                                                                 NULL,                                                                     0, 10},
    {bcmFieldQualifyL4SrcPort,                          (int (*)(void)) bcm_field_qualify_L4SrcPort,                          (int (*)(void)) bcm_field_qualify_L4SrcPort_get,                          0, 11},
    {bcmFieldQualifyL4DstPort,                          (int (*)(void)) bcm_field_qualify_L4DstPort,                          (int (*)(void)) bcm_field_qualify_L4DstPort_get,                          0, 11},
    {bcmFieldQualifyEtherType,                          (int (*)(void)) bcm_field_qualify_EtherType,                          (int (*)(void)) bcm_field_qualify_EtherType_get,                          0, 12},
    {bcmFieldQualifyIpProtocol,                         (int (*)(void)) bcm_field_qualify_IpProtocol,                         (int (*)(void)) bcm_field_qualify_IpProtocol_get,                         0, 7},
    {bcmFieldQualifyIp6NextHeader,                      (int (*)(void)) bcm_field_qualify_Ip6NextHeader,                      (int (*)(void)) bcm_field_qualify_Ip6NextHeader_get,                      0, 7},
    {bcmFieldQualifyDSCP,                               (int (*)(void)) bcm_field_qualify_DSCP,                               (int (*)(void)) bcm_field_qualify_DSCP_get,                               0, 7},
    {bcmFieldQualifyTos,                                (int (*)(void)) bcm_field_qualify_Tos,                                (int (*)(void)) bcm_field_qualify_Tos_get,                                0, 7},
    {bcmFieldQualifyIp6TrafficClass,                    (int (*)(void)) bcm_field_qualify_Ip6TrafficClass,                    (int (*)(void)) bcm_field_qualify_Ip6TrafficClass_get,                    0, 7},
    {bcmFieldQualifyTtl,                                (int (*)(void)) bcm_field_qualify_Ttl,                                (int (*)(void)) bcm_field_qualify_Ttl_get,                                0, 7},
    {bcmFieldQualifyIp6HopLimit,                        (int (*)(void)) bcm_field_qualify_Ip6HopLimit,                        (int (*)(void)) bcm_field_qualify_Ip6HopLimit_get,                        0, 7},
    {bcmFieldQualifySrcModid,                           NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifySrcPortTgid,                        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifySrcPort,                            (int (*)(void)) bcm_field_qualify_SrcPort,                            (int (*)(void)) bcm_field_qualify_SrcPort_get,                            0, 13},
    {bcmFieldQualifySrcTrunk,                           (int (*)(void)) bcm_field_qualify_SrcTrunk,                           (int (*)(void)) bcm_field_qualify_SrcTrunk_get,                           0, 14},
    {bcmFieldQualifyDstModid,                           NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyDstPortTgid,                        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyDstPort,                            (int (*)(void)) bcm_field_qualify_DstPort,                            (int (*)(void)) bcm_field_qualify_DstPort_get,                            0, 13},
    {bcmFieldQualifyDstTrunk,                           (int (*)(void)) bcm_field_qualify_DstTrunk,                           (int (*)(void)) bcm_field_qualify_DstTrunk_get,                           0, 14},
    {bcmFieldQualifyTcpControl,                         (int (*)(void)) bcm_field_qualify_TcpControl,                         (int (*)(void)) bcm_field_qualify_TcpControl_get,                         0, 7},
    {bcmFieldQualifyPacketRes,                          (int (*)(void)) bcm_field_qualify_PacketRes,                          (int (*)(void)) bcm_field_qualify_PacketRes_get,                          0, 8},
    {bcmFieldQualifyPacketFormat,                       NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifySrcClassL2,                         (int (*)(void)) bcm_field_qualify_SrcClassL2,                         (int (*)(void)) bcm_field_qualify_SrcClassL2_get,                         0, 8},
    {bcmFieldQualifySrcClassL3,                         (int (*)(void)) bcm_field_qualify_SrcClassL3,                         (int (*)(void)) bcm_field_qualify_SrcClassL3_get,                         0, 8},
    {bcmFieldQualifySrcClassField,                      (int (*)(void)) bcm_field_qualify_SrcClassField,                      (int (*)(void)) bcm_field_qualify_SrcClassField_get,                      0, 8},
    {bcmFieldQualifyDstClassL2,                         (int (*)(void)) bcm_field_qualify_DstClassL2,                         (int (*)(void)) bcm_field_qualify_DstClassL2_get,                         0, 8},
    {bcmFieldQualifyDstClassL3,                         (int (*)(void)) bcm_field_qualify_DstClassL3,                         (int (*)(void)) bcm_field_qualify_DstClassL3_get,                         0, 8},
    {bcmFieldQualifyDstClassField,                      (int (*)(void)) bcm_field_qualify_DstClassField,                      (int (*)(void)) bcm_field_qualify_DstClassField_get,                      0, 8},
    {bcmFieldQualifyIpInfo,                             (int (*)(void)) bcm_field_qualify_IpInfo,                             (int (*)(void)) bcm_field_qualify_IpInfo_get,                             0, 8},
    {bcmFieldQualifyIpProtocolCommon,                   (int (*)(void)) bcm_field_qualify_IpProtocolCommon,                   (int (*)(void)) bcm_field_qualify_IpProtocolCommon_get,                   0, 15},
    {bcmFieldQualifyMHOpcode,                           (int (*)(void)) bcm_field_qualify_MHOpcode,                           (int (*)(void)) bcm_field_qualify_MHOpcode_get,                           0, 7},
    {bcmFieldQualifyIpFlags,                            (int (*)(void)) bcm_field_qualify_IpFlags,                            (int (*)(void)) bcm_field_qualify_IpFlags_get,                            0, 7},
    {bcmFieldQualifyInnerTpid,                          (int (*)(void)) bcm_field_qualify_InnerTpid,                          (int (*)(void)) bcm_field_qualify_InnerTpid_get,                          0, 16},
    {bcmFieldQualifyOuterTpid,                          (int (*)(void)) bcm_field_qualify_OuterTpid,                          (int (*)(void)) bcm_field_qualify_OuterTpid_get,                          0, 16},
    {bcmFieldQualifyInnerIpType,                        (int (*)(void)) bcm_field_qualify_InnerIpType,                        (int (*)(void)) bcm_field_qualify_InnerIpType_get,                        0, 17},
    {bcmFieldQualifyTunnelType,                         (int (*)(void)) bcm_field_qualify_TunnelType,                         (int (*)(void)) bcm_field_qualify_TunnelType_get,                         0, 18},
    {bcmFieldQualifyLoopbackType,                       (int (*)(void)) bcm_field_qualify_LoopbackType,                       (int (*)(void)) bcm_field_qualify_LoopbackType_get,                       0, 19},
    {bcmFieldQualifyLoopback,                           (int (*)(void)) bcm_field_qualify_Loopback,                           (int (*)(void)) bcm_field_qualify_Loopback_get,                           0, 7},
    {bcmFieldQualifyIpType,                             (int (*)(void)) bcm_field_qualify_IpType,                             (int (*)(void)) bcm_field_qualify_IpType_get,                             0, 17},
    {bcmFieldQualifyForwardingType,                     (int (*)(void)) bcm_field_qualify_ForwardingType,                     (int (*)(void)) bcm_field_qualify_ForwardingType_get,                     0, 20},
    {bcmFieldQualifyDecap,                              NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyHiGig,                              (int (*)(void)) bcm_field_qualify_HiGig,                              (int (*)(void)) bcm_field_qualify_HiGig_get,                              0, 7},
    {bcmFieldQualifyHiGigProxy,                         NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyDstHiGig,                           (int (*)(void)) bcm_field_qualify_DstHiGig,                           (int (*)(void)) bcm_field_qualify_DstHiGig_get,                           0, 7},
    {bcmFieldQualifyStage,                              (int (*)(void)) bcm_field_qualify_Stage,                              (int (*)(void)) bcm_field_qualify_Stage_get,                              0, 21},
    {bcmFieldQualifyStageIngress,                       NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressSecurity,               NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressQoS,                    NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageLookup,                        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageEgress,                        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageEgressSecurity,                NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageExternal,                      NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifySrcIpEqualDstIp,                    (int (*)(void)) bcm_field_qualify_SrcIpEqualDstIp,                    (int (*)(void)) bcm_field_qualify_SrcIpEqualDstIp_get,                    0, 22},
    {bcmFieldQualifyEqualL4Port,                        (int (*)(void)) bcm_field_qualify_EqualL4Port,                        (int (*)(void)) bcm_field_qualify_EqualL4Port_get,                        0, 22},
    {bcmFieldQualifyTcpSequenceZero,                    (int (*)(void)) bcm_field_qualify_TcpSequenceZero,                    (int (*)(void)) bcm_field_qualify_TcpSequenceZero_get,                    0, 22},
    {bcmFieldQualifyTcpHeaderSize,                      (int (*)(void)) bcm_field_qualify_TcpHeaderSize,                      (int (*)(void)) bcm_field_qualify_TcpHeaderSize_get,                      0, 7},
    {bcmFieldQualifyInterfaceClassL2,                   (int (*)(void)) bcm_field_qualify_InterfaceClassL2,                   (int (*)(void)) bcm_field_qualify_InterfaceClassL2_get,                   0, 8},
    {bcmFieldQualifyInterfaceClassL3,                   (int (*)(void)) bcm_field_qualify_InterfaceClassL3,                   (int (*)(void)) bcm_field_qualify_InterfaceClassL3_get,                   0, 8},
    {bcmFieldQualifyInterfaceClassPort,                 (int (*)(void)) bcm_field_qualify_InterfaceClassPort,                 (int (*)(void)) bcm_field_qualify_InterfaceClassPort_get,                 0, 8},
    {bcmFieldQualifyL3Routable,                         (int (*)(void)) bcm_field_qualify_L3Routable,                         (int (*)(void)) bcm_field_qualify_L3Routable_get,                         0, 7},
    {bcmFieldQualifyIpFrag,                             (int (*)(void)) bcm_field_qualify_IpFrag,                             (int (*)(void)) bcm_field_qualify_IpFrag_get,                             0, 23},
    {bcmFieldQualifyVrf,                                (int (*)(void)) bcm_field_qualify_Vrf,                                (int (*)(void)) bcm_field_qualify_Vrf_get,                                0, 8},
    {bcmFieldQualifyL3Ingress,                          (int (*)(void)) bcm_field_qualify_L3Ingress,                          (int (*)(void)) bcm_field_qualify_L3Ingress_get,                          0, 8},
    {bcmFieldQualifyOutPort,                            (int (*)(void)) bcm_field_qualify_OutPort,                            (int (*)(void)) bcm_field_qualify_OutPort_get,                            0, 5},
    {bcmFieldQualifyIp4,                                NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyIp6,                                NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyL2Format,                           (int (*)(void)) bcm_field_qualify_L2Format,                           (int (*)(void)) bcm_field_qualify_L2Format_get,                           0, 24},
    {bcmFieldQualifyVlanFormat,                         (int (*)(void)) bcm_field_qualify_VlanFormat,                         (int (*)(void)) bcm_field_qualify_VlanFormat_get,                         0, 7},
    {bcmFieldQualifyTranslatedVlanFormat,               (int (*)(void)) bcm_field_qualify_TranslatedVlanFormat,               (int (*)(void)) bcm_field_qualify_TranslatedVlanFormat_get,               0, 7},
    {bcmFieldQualifyExtensionHeaderType,                (int (*)(void)) bcm_field_qualify_ExtensionHeaderType,                (int (*)(void)) bcm_field_qualify_ExtensionHeaderType_get,                0, 7},
    {bcmFieldQualifyExtensionHeaderSubCode,             (int (*)(void)) bcm_field_qualify_ExtensionHeaderSubCode,             (int (*)(void)) bcm_field_qualify_ExtensionHeaderSubCode_get,             0, 7},
    {bcmFieldQualifyExtensionHeader2Type,               (int (*)(void)) bcm_field_qualify_ExtensionHeader2Type,               (int (*)(void)) bcm_field_qualify_ExtensionHeader2Type_get,               0, 7},
    {bcmFieldQualifyL4Ports,                            (int (*)(void)) bcm_field_qualify_L4Ports,                            (int (*)(void)) bcm_field_qualify_L4Ports_get,                            0, 7},
    {bcmFieldQualifyMirrorCopy,                         (int (*)(void)) bcm_field_qualify_MirrorCopy,                         (int (*)(void)) bcm_field_qualify_MirrorCopy_get,                         0, 7},
    {bcmFieldQualifyTunnelTerminated,                   (int (*)(void)) bcm_field_qualify_TunnelTerminated,                   (int (*)(void)) bcm_field_qualify_TunnelTerminated_get,                   0, 7},
    {bcmFieldQualifyMplsTerminated,                     (int (*)(void)) bcm_field_qualify_MplsTerminated,                     (int (*)(void)) bcm_field_qualify_MplsTerminated_get,                     0, 7},
    {bcmFieldQualifyInnerSrcIp,                         (int (*)(void)) bcm_field_qualify_InnerSrcIp,                         (int (*)(void)) bcm_field_qualify_InnerSrcIp_get,                         0, 3},
    {bcmFieldQualifyInnerDstIp,                         (int (*)(void)) bcm_field_qualify_InnerDstIp,                         (int (*)(void)) bcm_field_qualify_InnerDstIp_get,                         0, 3},
    {bcmFieldQualifyInnerSrcIp6,                        (int (*)(void)) bcm_field_qualify_InnerSrcIp6,                        (int (*)(void)) bcm_field_qualify_InnerSrcIp6_get,                        0, 0},
    {bcmFieldQualifyInnerDstIp6,                        (int (*)(void)) bcm_field_qualify_InnerDstIp6,                        (int (*)(void)) bcm_field_qualify_InnerDstIp6_get,                        0, 0},
    {bcmFieldQualifyInnerSrcIp6High,                    (int (*)(void)) bcm_field_qualify_InnerSrcIp6High,                    (int (*)(void)) bcm_field_qualify_InnerSrcIp6High_get,                    0, 0},
    {bcmFieldQualifyInnerDstIp6High,                    (int (*)(void)) bcm_field_qualify_InnerDstIp6High,                    (int (*)(void)) bcm_field_qualify_InnerDstIp6High_get,                    0, 0},
    {bcmFieldQualifyInnerTtl,                           (int (*)(void)) bcm_field_qualify_InnerTtl,                           (int (*)(void)) bcm_field_qualify_InnerTtl_get,                           0, 7},
    {bcmFieldQualifyInnerIp6HopLimit,                   NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyInnerTos,                           (int (*)(void)) bcm_field_qualify_InnerTos,                           (int (*)(void)) bcm_field_qualify_InnerTos_get,                           0, 7},
    {bcmFieldQualifyInnerDSCP,                          (int (*)(void)) bcm_field_qualify_InnerDSCP,                          (int (*)(void)) bcm_field_qualify_InnerDSCP_get,                          0, 7},
    {bcmFieldQualifyInnerIp6TrafficClass,               NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyInnerIpProtocol,                    (int (*)(void)) bcm_field_qualify_InnerIpProtocol,                    (int (*)(void)) bcm_field_qualify_InnerIpProtocol_get,                    0, 7},
    {bcmFieldQualifyInnerIp6NextHeader,                 NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyInnerIpFrag,                        (int (*)(void)) bcm_field_qualify_InnerIpFrag,                        (int (*)(void)) bcm_field_qualify_InnerIpFrag_get,                        0, 23},
    {bcmFieldQualifyVlanTranslationHit,                 (int (*)(void)) bcm_field_qualify_VlanTranslationHit,                 (int (*)(void)) bcm_field_qualify_VlanTranslationHit_get,                 0, 7},
    {bcmFieldQualifyForwardingVlanValid,                (int (*)(void)) bcm_field_qualify_ForwardingVlanValid,                (int (*)(void)) bcm_field_qualify_ForwardingVlanValid_get,                0, 7},
    {bcmFieldQualifyIngressStpState,                    (int (*)(void)) bcm_field_qualify_IngressStpState,                    (int (*)(void)) bcm_field_qualify_IngressStpState_get,                    0, 7},
    {bcmFieldQualifyL2SrcHit,                           (int (*)(void)) bcm_field_qualify_L2SrcHit,                           (int (*)(void)) bcm_field_qualify_L2SrcHit_get,                           0, 7},
    {bcmFieldQualifyL2SrcStatic,                        (int (*)(void)) bcm_field_qualify_L2SrcStatic,                        (int (*)(void)) bcm_field_qualify_L2SrcStatic_get,                        0, 7},
    {bcmFieldQualifyL2DestHit,                          (int (*)(void)) bcm_field_qualify_L2DestHit,                          (int (*)(void)) bcm_field_qualify_L2DestHit_get,                          0, 7},
    {bcmFieldQualifyL2StationMove,                      (int (*)(void)) bcm_field_qualify_L2StationMove,                      (int (*)(void)) bcm_field_qualify_L2StationMove_get,                      0, 7},
    {bcmFieldQualifyL2CacheHit,                         (int (*)(void)) bcm_field_qualify_L2CacheHit,                         (int (*)(void)) bcm_field_qualify_L2CacheHit_get,                         0, 7},
    {bcmFieldQualifyL3SrcHostHit,                       (int (*)(void)) bcm_field_qualify_L3SrcHostHit,                       (int (*)(void)) bcm_field_qualify_L3SrcHostHit_get,                       0, 7},
    {bcmFieldQualifyL3DestHostHit,                      (int (*)(void)) bcm_field_qualify_L3DestHostHit,                      (int (*)(void)) bcm_field_qualify_L3DestHostHit_get,                      0, 7},
    {bcmFieldQualifyL3DestRouteHit,                     (int (*)(void)) bcm_field_qualify_L3DestRouteHit,                     (int (*)(void)) bcm_field_qualify_L3DestRouteHit_get,                     0, 7},
    {bcmFieldQualifyIpmcStarGroupHit,                   (int (*)(void)) bcm_field_qualify_IpmcStarGroupHit,                   (int (*)(void)) bcm_field_qualify_IpmcStarGroupHit_get,                   0, 7},
    {bcmFieldQualifyDosAttack,                          (int (*)(void)) bcm_field_qualify_DosAttack,                          (int (*)(void)) bcm_field_qualify_DosAttack_get,                          0, 7},
    {bcmFieldQualifyIpAuth,                             (int (*)(void)) bcm_field_qualify_IpAuth,                             (int (*)(void)) bcm_field_qualify_IpAuth_get,                             0, 7},
    {bcmFieldQualifyClassId,                            NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyBigIcmpCheck,                       (int (*)(void)) bcm_field_qualify_BigIcmpCheck,                       (int (*)(void)) bcm_field_qualify_BigIcmpCheck_get,                       0, 8},
    {bcmFieldQualifyIcmpTypeCode,                       (int (*)(void)) bcm_field_qualify_IcmpTypeCode,                       (int (*)(void)) bcm_field_qualify_IcmpTypeCode_get,                       0, 12},
    {bcmFieldQualifyIgmpTypeMaxRespTime,                (int (*)(void)) bcm_field_qualify_IgmpTypeMaxRespTime,                (int (*)(void)) bcm_field_qualify_IgmpTypeMaxRespTime_get,                0, 12},
    {bcmFieldQualifyInnerIpProtocolCommon,              (int (*)(void)) bcm_field_qualify_InnerIpProtocolCommon,              (int (*)(void)) bcm_field_qualify_InnerIpProtocolCommon_get,              0, 15},
    {bcmFieldQualifyInnerL4SrcPort,                     (int (*)(void)) bcm_field_qualify_InnerL4SrcPort,                     (int (*)(void)) bcm_field_qualify_InnerL4SrcPort_get,                     0, 11},
    {bcmFieldQualifyInnerL4DstPort,                     (int (*)(void)) bcm_field_qualify_InnerL4DstPort,                     (int (*)(void)) bcm_field_qualify_InnerL4DstPort_get,                     0, 11},
    {bcmFieldQualifyInnerIp6FlowLabel,                  (int (*)(void)) bcm_field_qualify_InnerIp6FlowLabel,                  (int (*)(void)) bcm_field_qualify_InnerIp6FlowLabel_get,                  0, 8},
    {bcmFieldQualifyDstL3Egress,                        (int (*)(void)) bcm_field_qualify_DstL3Egress,                        (int (*)(void)) bcm_field_qualify_DstL3Egress_get,                        0, 25},
    {bcmFieldQualifyDstMulticastGroup,                  (int (*)(void)) bcm_field_qualify_DstMulticastGroup,                  (int (*)(void)) bcm_field_qualify_DstMulticastGroup_get,                  0, 26},
    {bcmFieldQualifySrcMplsGport,                       (int (*)(void)) bcm_field_qualify_SrcMplsGport,                       (int (*)(void)) bcm_field_qualify_SrcMplsGport_get,                       0, 26},
    {bcmFieldQualifyDstMplsGport,                       (int (*)(void)) bcm_field_qualify_DstMplsGport,                       (int (*)(void)) bcm_field_qualify_DstMplsGport_get,                       0, 26},
    {bcmFieldQualifySrcMimGport,                        (int (*)(void)) bcm_field_qualify_SrcMimGport,                        (int (*)(void)) bcm_field_qualify_SrcMimGport_get,                        0, 26},
    {bcmFieldQualifyDstMimGport,                        (int (*)(void)) bcm_field_qualify_DstMimGport,                        (int (*)(void)) bcm_field_qualify_DstMimGport_get,                        0, 26},
    {bcmFieldQualifySrcWlanGport,                       (int (*)(void)) bcm_field_qualify_SrcWlanGport,                       (int (*)(void)) bcm_field_qualify_SrcWlanGport_get,                       0, 26},
    {bcmFieldQualifyDstWlanGport,                       (int (*)(void)) bcm_field_qualify_DstWlanGport,                       (int (*)(void)) bcm_field_qualify_DstWlanGport_get,                       0, 26},
    {bcmFieldQualifySrcModPortGport,                    (int (*)(void)) bcm_field_qualify_SrcModPortGport,                    (int (*)(void)) bcm_field_qualify_SrcModPortGport_get,                    0, 26},
    {bcmFieldQualifySrcModuleGport,                     (int (*)(void)) bcm_field_qualify_SrcModuleGport,                     (int (*)(void)) bcm_field_qualify_SrcModuleGport_get,                     0, 26},
    {bcmFieldQualifyColor,                              (int (*)(void)) bcm_field_qualify_Color,                              (int (*)(void)) bcm_field_qualify_Color_get,                              0, 27},
    {bcmFieldQualifyIntPriority,                        (int (*)(void)) bcm_field_qualify_IntPriority,                        (int (*)(void)) bcm_field_qualify_IntPriority_get,                        0, 7},
    {bcmFieldQualifyForwardingVlanId,                   (int (*)(void)) bcm_field_qualify_ForwardingVlanId,                   (int (*)(void)) bcm_field_qualify_ForwardingVlanId_get,                   0, 9},
    {bcmFieldQualifyVpn,                                (int (*)(void)) bcm_field_qualify_Vpn,                                (int (*)(void)) bcm_field_qualify_Vpn_get,                                0, 28},
    {bcmFieldQualifyFlowId,                             (int (*)(void)) bcm_field_qualify_FlowId,                             (int (*)(void)) bcm_field_qualify_FlowId_get,                             0, 12},
    {bcmFieldQualifyInVPort,                            (int (*)(void)) bcm_field_qualify_InVPort32,                          (int (*)(void)) bcm_field_qualify_InVPort32_get,                          0, 8},
    {bcmFieldQualifyOutVPort,                           (int (*)(void)) bcm_field_qualify_OutVPort32,                         (int (*)(void)) bcm_field_qualify_OutVPort32_get,                         0, 8},
    {bcmFieldQualifyFibreChanOuter,                     (int (*)(void)) bcm_field_qualify_FibreChanOuter,                     (int (*)(void)) bcm_field_qualify_FibreChanOuter_get,                     0, 29},
    {bcmFieldQualifyFibreChanInner,                     (int (*)(void)) bcm_field_qualify_FibreChanInner,                     (int (*)(void)) bcm_field_qualify_FibreChanInner_get,                     0, 29},
    {bcmFieldQualifyVnTag,                              (int (*)(void)) bcm_field_qualify_VnTag,                              (int (*)(void)) bcm_field_qualify_VnTag_get,                              0, 8},
    {bcmFieldQualifyCnTag,                              (int (*)(void)) bcm_field_qualify_CnTag,                              (int (*)(void)) bcm_field_qualify_CnTag_get,                              0, 8},
    {bcmFieldQualifyFabricQueueTag,                     (int (*)(void)) bcm_field_qualify_FabricQueueTag,                     (int (*)(void)) bcm_field_qualify_FabricQueueTag_get,                     0, 8},
    {bcmFieldQualifyMyStationHit,                       NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyDstMultipath,                       NULL,                                                                 NULL,                                                                     0, 25},
    {bcmFieldQualifyL2PayloadFirstEightBytes,           NULL,                                                                 NULL,                                                                     0, 30},
    {bcmFieldQualifySrcVirtualPortValid,                NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyDstL3EgressNextHops,                NULL,                                                                 NULL,                                                                     0, 8},
    {bcmFieldQualifyRecoverableDrop,                    NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyRepCopy,                            NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyIpTunnelHit,                        (int (*)(void)) bcm_field_qualify_IpTunnelHit,                        (int (*)(void)) bcm_field_qualify_IpTunnelHit_get,                        0, 7},
    {bcmFieldQualifyMplsLabel1Hit,                      NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyTrillEgressRbridgeHit,              NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyL2GreSrcIpHit,                      NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMimSrcGportHit,                     NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMplsLabel2Hit,                      NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyTrillIngressRbridgeHit,             NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyL2GreVfiHit,                        NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMimVfiHit,                          NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyGenericAssociatedChannelLabelValid, NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyRouterAlertLabelValid,              NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyDstIpLocal,                         NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyNormalizeIpAddrs,                   NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyNormalizeMacAddrs,                  NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyIpAddrsNormalized,                  NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMacAddrsNormalized,                 NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMplsForwardingLabel,                (int (*)(void)) bcm_field_qualify_MplsForwardingLabel,                (int (*)(void)) bcm_field_qualify_MplsForwardingLabel_get,                0, 8},
    {bcmFieldQualifyMplsForwardingLabelTtl,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelTtl,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelTtl_get,             0, 7},
    {bcmFieldQualifyMplsForwardingLabelBos,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelBos,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelBos_get,             0, 7},
    {bcmFieldQualifyMplsForwardingLabelExp,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelExp,             (int (*)(void)) bcm_field_qualify_MplsForwardingLabelExp_get,             0, 7},
    {bcmFieldQualifyMplsForwardingLabelId,              (int (*)(void)) bcm_field_qualify_MplsForwardingLabelId,              (int (*)(void)) bcm_field_qualify_MplsForwardingLabelId_get,              0, 8},
    {bcmFieldQualifyMplsControlWord,                    NULL,                                                                 NULL,                                                                     0, 8},
    {bcmFieldQualifyRtag7AHashUpper,                    NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyRtag7AHashLower,                    NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyRtag7BHashUpper,                    NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyRtag7BHashLower,                    NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyMplsForwardingLabelAction,          (int (*)(void)) bcm_field_qualify_MplsForwardingLabelAction32,        (int (*)(void)) bcm_field_qualify_MplsForwardingLabelAction32_get,        0, 8},
    {bcmFieldQualifyMplsControlWordValid,               NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyEgressClass,                        NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyEgressClassL3Interface,             NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyEgressClassTrill,                   NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyEgressClassWlan,                    NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyEgressClassL2Gre,                   NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyLlidValue,                          NULL,                                                                 NULL,                                                                     0, 12},
    {bcmFieldQualifyCpuQueue,                           NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMpls,                               NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifySrcGport,                           (int (*)(void)) bcm_field_qualify_SrcGport,                           (int (*)(void)) bcm_field_qualify_SrcGport_get,                           0, 26},
    {bcmFieldQualifyHeaderFormat,                       (int (*)(void)) bcm_field_qualify_HeaderFormat,                       (int (*)(void)) bcm_field_qualify_HeaderFormat_get,                       0, 31},
    {bcmFieldQualifyHeaderFormatSet,                    (int (*)(void)) bcm_field_qualify_HeaderFormatSet,                    (int (*)(void)) bcm_field_qualify_HeaderFormatSet_get,                    0, 32},
    {bcmFieldQualifyL2Learn,                            (int (*)(void)) bcm_field_qualify_L2Learn,                            (int (*)(void)) bcm_field_qualify_L2Learn_get,                            0, 7},
    {bcmFieldQualifyPortOrientation,                    (int (*)(void)) bcm_field_qualify_PortOrientation,                    (int (*)(void)) bcm_field_qualify_PortOrientation_get,                    0, 7},
    {bcmFieldQualifyEcnValue,                           (int (*)(void)) bcm_field_qualify_EcnValue,                           (int (*)(void)) bcm_field_qualify_EcnValue_get,                           0, 7},
    {bcmFieldQualifyRxTrapCode,                         (int (*)(void)) bcm_field_qualify_RxTrapCode,                         (int (*)(void)) bcm_field_qualify_RxTrapCode_get,                         0, 33},
    {bcmFieldQualifyPtch,                               (int (*)(void)) bcm_field_qualify_Ptch,                               (int (*)(void)) bcm_field_qualify_Ptch_get,                               0, 7},
    {bcmFieldQualifyMplsBos,                            (int (*)(void)) bcm_field_qualify_MplsBos,                            (int (*)(void)) bcm_field_qualify_MplsBos_get,                            0, 7},
    {bcmFieldQualifyRxTrapData,                         (int (*)(void)) bcm_field_qualify_RxTrapData,                         (int (*)(void)) bcm_field_qualify_RxTrapData_get,                         0, 8},
    {bcmFieldQualifyPolicerIntPrio,                     (int (*)(void)) bcm_field_qualify_PolicerIntPrio,                     (int (*)(void)) bcm_field_qualify_PolicerIntPrio_get,                     0, 7},
    {bcmFieldQualifyPacketTerminatedBytes,              (int (*)(void)) bcm_field_qualify_PacketTerminatedBytes,              (int (*)(void)) bcm_field_qualify_PacketTerminatedBytes_get,              0, 8},
    {bcmFieldQualifyBypassFilter,                       (int (*)(void)) bcm_field_qualify_BypassFilter,                       (int (*)(void)) bcm_field_qualify_BypassFilter_get,                       0, 7},
    {bcmFieldQualifyReplicantAny,                       (int (*)(void)) bcm_field_qualify_ReplicantAny,                       (int (*)(void)) bcm_field_qualify_ReplicantAny_get,                       0, 7},
    {bcmFieldQualifyReplicantFirst,                     (int (*)(void)) bcm_field_qualify_ReplicantFirst,                     (int (*)(void)) bcm_field_qualify_ReplicantFirst_get,                     0, 7},
    {bcmFieldQualifyTrillEgressRbridge,                 (int (*)(void)) bcm_field_qualify_TrillEgressRbridge,                 (int (*)(void)) bcm_field_qualify_TrillEgressRbridge_get,                 0, 8},
    {bcmFieldQualifyISid,                               (int (*)(void)) bcm_field_qualify_ISid,                               (int (*)(void)) bcm_field_qualify_ISid_get,                               0, 8},
    {bcmFieldQualifyInterfaceClassProcessingPort,       (int (*)(void)) bcm_field_qualify_InterfaceClassProcessingPort,       (int (*)(void)) bcm_field_qualify_InterfaceClassProcessingPort_get,       0, 34},
    {bcmFieldQualifyDstRpfGport,                        (int (*)(void)) bcm_field_qualify_DstRpfGport,                        (int (*)(void)) bcm_field_qualify_DstRpfGport_get,                        0, 26},
    {bcmFieldQualifyTrunkHashResult,                    (int (*)(void)) bcm_field_qualify_TrunkHashResult,                    (int (*)(void)) bcm_field_qualify_TrunkHashResult_get,                    0, 8},
    {bcmFieldQualifyDhcp,                               (int (*)(void)) bcm_field_qualify_Dhcp,                               (int (*)(void)) bcm_field_qualify_Dhcp_get,                               0, 7},
    {bcmFieldQualifySnoopCopy,                          (int (*)(void)) bcm_field_qualify_SnoopCopy,                          (int (*)(void)) bcm_field_qualify_SnoopCopy_get,                          0, 7},
    {bcmFieldQualifyForwardCopy,                        (int (*)(void)) bcm_field_qualify_ForwardCopy,                        (int (*)(void)) bcm_field_qualify_ForwardCopy_get,                        0, 7},
    {bcmFieldQualifyInterfaceClassVPort,                (int (*)(void)) bcm_field_qualify_InterfaceClassVPort,                (int (*)(void)) bcm_field_qualify_InterfaceClassVPort_get,                0, 8},
    {bcmFieldQualifyVPortRangeCheck,                    NULL,                                                                 NULL,                                                                     0, 10},
    {bcmFieldQualifyPacketLengthRangeCheck,             NULL,                                                                 NULL,                                                                     0, 10},
    {bcmFieldQualifyStageIngressVlanTranslation,        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressTunnelTerminated,       NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressMplsTerminated,         NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressIpTunnel,               NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressL2Src,                  NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressL2Dest,                 NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressL3SrcRoute,             NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressL3DestRoute,            NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyStageIngressIpmc,                   NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyTunnelTerminatedHit,                NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMplsTerminatedHit,                  NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyL3SrcRouteHit,                      (int (*)(void)) bcm_field_qualify_L3SrcRouteHit,                      (int (*)(void)) bcm_field_qualify_L3SrcRouteHit_get,                      0, 7},
    {bcmFieldQualifyIpmcHit,                            (int (*)(void)) bcm_field_qualify_IpmcHit,                            (int (*)(void)) bcm_field_qualify_IpmcHit_get,                            0, 7},
    {bcmFieldQualifyVlanTranslationValue,               (int (*)(void)) bcm_field_qualify_VlanTranslationValue,               (int (*)(void)) bcm_field_qualify_VlanTranslationValue_get,               0, 34},
    {bcmFieldQualifyTunnelTerminatedValue,              (int (*)(void)) bcm_field_qualify_TunnelTerminatedValue,              (int (*)(void)) bcm_field_qualify_TunnelTerminatedValue_get,              0, 34},
    {bcmFieldQualifyMplsTerminatedValue,                (int (*)(void)) bcm_field_qualify_MplsTerminatedValue,                (int (*)(void)) bcm_field_qualify_MplsTerminatedValue_get,                0, 34},
    {bcmFieldQualifyIpTunnelValue,                      (int (*)(void)) bcm_field_qualify_IpTunnelValue,                      (int (*)(void)) bcm_field_qualify_IpTunnelValue_get,                      0, 34},
    {bcmFieldQualifyL2SrcValue,                         (int (*)(void)) bcm_field_qualify_L2SrcValue,                         (int (*)(void)) bcm_field_qualify_L2SrcValue_get,                         0, 34},
    {bcmFieldQualifyL2DestValue,                        (int (*)(void)) bcm_field_qualify_L2DestValue,                        (int (*)(void)) bcm_field_qualify_L2DestValue_get,                        0, 34},
    {bcmFieldQualifyL3SrcRouteValue,                    (int (*)(void)) bcm_field_qualify_L3SrcRouteValue,                    (int (*)(void)) bcm_field_qualify_L3SrcRouteValue_get,                    0, 34},
    {bcmFieldQualifyL3DestRouteValue,                   (int (*)(void)) bcm_field_qualify_L3DestRouteValue,                   (int (*)(void)) bcm_field_qualify_L3DestRouteValue_get,                   0, 34},
    {bcmFieldQualifyIpmcValue,                          (int (*)(void)) bcm_field_qualify_IpmcValue,                          (int (*)(void)) bcm_field_qualify_IpmcValue_get,                          0, 34},
    {bcmFieldQualifyLearnSrcMac,                        (int (*)(void)) bcm_field_qualify_LearnSrcMac,                        (int (*)(void)) bcm_field_qualify_LearnSrcMac_get,                        0, 1},
    {bcmFieldQualifyLearnVlan,                          (int (*)(void)) bcm_field_qualify_LearnVlan,                          (int (*)(void)) bcm_field_qualify_LearnVlan_get,                          0, 9},
    {bcmFieldQualifyLearnSrcPort,                       (int (*)(void)) bcm_field_qualify_LearnSrcPort,                       (int (*)(void)) bcm_field_qualify_LearnSrcPort_get,                       0, 26},
    {bcmFieldQualifyPacketSize,                         (int (*)(void)) bcm_field_qualify_PacketSize,                         (int (*)(void)) bcm_field_qualify_PacketSize_get,                         0, 8},
    {bcmFieldQualifyInnerSrcMac,                        (int (*)(void)) bcm_field_qualify_InnerSrcMac,                        (int (*)(void)) bcm_field_qualify_InnerSrcMac_get,                        0, 1},
    {bcmFieldQualifyInnerDstMac,                        (int (*)(void)) bcm_field_qualify_InnerDstMac,                        (int (*)(void)) bcm_field_qualify_InnerDstMac_get,                        0, 1},
    {bcmFieldQualifyInnerEtherType,                     (int (*)(void)) bcm_field_qualify_InnerEtherType,                     (int (*)(void)) bcm_field_qualify_InnerEtherType_get,                     0, 12},
    {bcmFieldQualifyMplsLabel1,                         (int (*)(void)) bcm_field_qualify_MplsLabel1,                         (int (*)(void)) bcm_field_qualify_MplsLabel1_get,                         0, 8},
    {bcmFieldQualifyMplsLabel1Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Ttl_get,                      0, 7},
    {bcmFieldQualifyMplsLabel1Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Bos_get,                      0, 7},
    {bcmFieldQualifyMplsLabel1Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel1Exp_get,                      0, 7},
    {bcmFieldQualifyMplsLabel1Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel1Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel1Id_get,                       0, 8},
    {bcmFieldQualifyMplsLabel2,                         (int (*)(void)) bcm_field_qualify_MplsLabel2,                         (int (*)(void)) bcm_field_qualify_MplsLabel2_get,                         0, 8},
    {bcmFieldQualifyMplsLabel2Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Ttl_get,                      0, 7},
    {bcmFieldQualifyMplsLabel2Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Bos_get,                      0, 7},
    {bcmFieldQualifyMplsLabel2Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel2Exp_get,                      0, 7},
    {bcmFieldQualifyMplsLabel2Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel2Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel2Id_get,                       0, 8},
    {bcmFieldQualifyMplsLabel3,                         (int (*)(void)) bcm_field_qualify_MplsLabel3,                         (int (*)(void)) bcm_field_qualify_MplsLabel3_get,                         0, 8},
    {bcmFieldQualifyMplsLabel3Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Ttl,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Ttl_get,                      0, 7},
    {bcmFieldQualifyMplsLabel3Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Bos,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Bos_get,                      0, 7},
    {bcmFieldQualifyMplsLabel3Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Exp,                      (int (*)(void)) bcm_field_qualify_MplsLabel3Exp_get,                      0, 7},
    {bcmFieldQualifyMplsLabel3Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel3Id,                       (int (*)(void)) bcm_field_qualify_MplsLabel3Id_get,                       0, 8},
    {bcmFieldQualifyCascadedKeyValue,                   (int (*)(void)) bcm_field_qualify_CascadedKeyValue,                   (int (*)(void)) bcm_field_qualify_CascadedKeyValue_get,                   0, 8},
    {bcmFieldQualifyMplsOuterLabelPop,                  NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyMplsStationHitTunnelUnterminated,   NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyIngressClassField,                  NULL,                                                                 NULL,                                                                     0, 8},
    {bcmFieldQualifyIngressInterfaceClassPort,          NULL,                                                                 NULL,                                                                     0, 8},
    {bcmFieldQualifyExternalValue0,                     (int (*)(void)) bcm_field_qualify_ExternalValue0,                     (int (*)(void)) bcm_field_qualify_ExternalValue0_get,                     0, 34},
    {bcmFieldQualifyExternalValue1,                     (int (*)(void)) bcm_field_qualify_ExternalValue1,                     (int (*)(void)) bcm_field_qualify_ExternalValue1_get,                     0, 34},
    {bcmFieldQualifyExternalValue2,                     (int (*)(void)) bcm_field_qualify_ExternalValue2,                     (int (*)(void)) bcm_field_qualify_ExternalValue2_get,                     0, 34},
    {bcmFieldQualifyExternalValue3,                     (int (*)(void)) bcm_field_qualify_ExternalValue3,                     (int (*)(void)) bcm_field_qualify_ExternalValue3_get,                     0, 34},
    {bcmFieldQualifyExternalValue4,                     (int (*)(void)) bcm_field_qualify_ExternalValue4,                     (int (*)(void)) bcm_field_qualify_ExternalValue4_get,                     0, 34},
    {bcmFieldQualifyExternalValue5,                     (int (*)(void)) bcm_field_qualify_ExternalValue5,                     (int (*)(void)) bcm_field_qualify_ExternalValue5_get,                     0, 34},
    {bcmFieldQualifyExternalHit0,                       (int (*)(void)) bcm_field_qualify_ExternalHit0,                       (int (*)(void)) bcm_field_qualify_ExternalHit0_get,                       0, 7},
    {bcmFieldQualifyExternalHit1,                       (int (*)(void)) bcm_field_qualify_ExternalHit1,                       (int (*)(void)) bcm_field_qualify_ExternalHit1_get,                       0, 7},
    {bcmFieldQualifyExternalHit2,                       (int (*)(void)) bcm_field_qualify_ExternalHit2,                       (int (*)(void)) bcm_field_qualify_ExternalHit2_get,                       0, 7},
    {bcmFieldQualifyExternalHit3,                       (int (*)(void)) bcm_field_qualify_ExternalHit3,                       (int (*)(void)) bcm_field_qualify_ExternalHit3_get,                       0, 7},
    {bcmFieldQualifyExternalHit4,                       (int (*)(void)) bcm_field_qualify_ExternalHit4,                       (int (*)(void)) bcm_field_qualify_ExternalHit4_get,                       0, 7},
    {bcmFieldQualifyExternalHit5,                       (int (*)(void)) bcm_field_qualify_ExternalHit5,                       (int (*)(void)) bcm_field_qualify_ExternalHit5_get,                       0, 7},
    {bcmFieldQualifyVpnUnknownDstMacDstPort,            NULL,                                                                 NULL,                                                                     0, 26},
    {bcmFieldQualifyVxlanNetworkId,                     NULL,                                                                 NULL,                                                                     0, 8},
    {bcmFieldQualifyVxlanFlags,                         NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyNatNeeded,                          NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyNatDstRealmId,                      NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyNatSrcRealmId,                      NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyIcmpError,                          NULL,                                                                 NULL,                                                                     0, 7},
    {bcmFieldQualifyTunnelId,                           (int (*)(void)) bcm_field_qualify_TunnelId,                           (int (*)(void)) bcm_field_qualify_TunnelId_get,                           0, 8},
    {bcmFieldQualifyArpSenderIp4,                       (int (*)(void)) bcm_field_qualify_ArpSenderIp4,                       (int (*)(void)) bcm_field_qualify_ArpSenderIp4_get,                       0, 8},
    {bcmFieldQualifyArpTargetIp4,                       (int (*)(void)) bcm_field_qualify_ArpTargetIp4,                       (int (*)(void)) bcm_field_qualify_ArpTargetIp4_get,                       0, 8},
    {bcmFieldQualifyArpOpcode,                          (int (*)(void)) bcm_field_qualify_ArpOpcode,                          (int (*)(void)) bcm_field_qualify_ArpOpcode_get,                          0, 35},
    {bcmFieldQualifyTranslatedOuterVlan,                (int (*)(void)) bcm_field_qualify_TranslatedOuterVlan,                (int (*)(void)) bcm_field_qualify_TranslatedOuterVlan_get,                0, 9},
    {bcmFieldQualifyTranslatedOuterVlanId,              (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanId,              (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanId_get,              0, 9},
    {bcmFieldQualifyTranslatedOuterVlanPri,             (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanPri,             (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanPri_get,             0, 7},
    {bcmFieldQualifyTranslatedOuterVlanCfi,             (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanCfi,             (int (*)(void)) bcm_field_qualify_TranslatedOuterVlanCfi_get,             0, 7},
    {bcmFieldQualifyTranslatedInnerVlan,                (int (*)(void)) bcm_field_qualify_TranslatedInnerVlan,                (int (*)(void)) bcm_field_qualify_TranslatedInnerVlan_get,                0, 9},
    {bcmFieldQualifyTranslatedInnerVlanId,              (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanId,              (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanId_get,              0, 9},
    {bcmFieldQualifyTranslatedInnerVlanPri,             (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanPri,             (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanPri_get,             0, 7},
    {bcmFieldQualifyTranslatedInnerVlanCfi,             (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanCfi,             (int (*)(void)) bcm_field_qualify_TranslatedInnerVlanCfi_get,             0, 7},
    {bcmFieldQualifyConstantZero,                       NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyConstantOne,                        NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyForwardingHeaderOffset,             (int (*)(void)) bcm_field_qualify_ForwardingHeaderOffset,             (int (*)(void)) bcm_field_qualify_ForwardingHeaderOffset_get,             0, 36},
    {bcmFieldQualifyL3SrcBind,                          NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyIngressVPortBridgeDisable,          (int (*)(void)) bcm_field_qualify_IngressVPortBridgeDisable,          (int (*)(void)) bcm_field_qualify_IngressVPortBridgeDisable_get,          0, 7},
    {bcmFieldQualifyAppType,                            (int (*)(void)) bcm_field_qualify_AppType,                            (int (*)(void)) bcm_field_qualify_AppType_get,                            0, 37},
    {bcmFieldQualifyMirrorEgressDisabled,               (int (*)(void)) bcm_field_qualify_MirrorEgressDisabled,               (int (*)(void)) bcm_field_qualify_MirrorEgressDisabled_get,               0, 7},
    {bcmFieldQualifyBypassSrcMacFilter,                 (int (*)(void)) bcm_field_qualify_BypassSrcMacFilter,                 (int (*)(void)) bcm_field_qualify_BypassSrcMacFilter_get,                 0, 7},
    {bcmFieldQualifyRxTrapCodeForSnoop,                 (int (*)(void)) bcm_field_qualify_RxTrapCodeForSnoop,                 (int (*)(void)) bcm_field_qualify_RxTrapCodeForSnoop_get,                 0, 8},
    {bcmFieldQualifyNativeVSwitch,                      (int (*)(void)) bcm_field_qualify_NativeVSwitch,                      (int (*)(void)) bcm_field_qualify_NativeVSwitch_get,                      0, 12},
    {bcmFieldQualifyFhei,                               (int (*)(void)) bcm_field_qualify_Fhei,                               (int (*)(void)) bcm_field_qualify_Fhei_get,                               0, 34},
    {bcmFieldQualifyFheiSize,                           (int (*)(void)) bcm_field_qualify_FheiSize,                           (int (*)(void)) bcm_field_qualify_FheiSize_get,                           0, 8},
    {bcmFieldQualifyOuterVlanActionRange,               (int (*)(void)) bcm_field_qualify_OuterVlanActionRange,               (int (*)(void)) bcm_field_qualify_OuterVlanActionRange_get,               0, 9},
    {bcmFieldQualifyInnerVlanActionRange,               (int (*)(void)) bcm_field_qualify_InnerVlanActionRange,               (int (*)(void)) bcm_field_qualify_InnerVlanActionRange_get,               0, 9},
    {bcmFieldQualifyOamInLifIdValid,                    (int (*)(void)) bcm_field_qualify_OamInLifIdValid,                    (int (*)(void)) bcm_field_qualify_OamInLifIdValid_get,                    0, 7},
    {bcmFieldQualifyOamInLifId,                         (int (*)(void)) bcm_field_qualify_OamInLifId,                         (int (*)(void)) bcm_field_qualify_OamInLifId_get,                         0, 8},
    {bcmFieldQualifyOamUpMep,                           (int (*)(void)) bcm_field_qualify_OamUpMep,                           (int (*)(void)) bcm_field_qualify_OamUpMep_get,                           0, 7},
    {bcmFieldQualifyOamSubtype,                         (int (*)(void)) bcm_field_qualify_OamSubtype,                         (int (*)(void)) bcm_field_qualify_OamSubtype_get,                         0, 7},
    {bcmFieldQualifyOamHeaderOffset,                    (int (*)(void)) bcm_field_qualify_OamHeaderOffset,                    (int (*)(void)) bcm_field_qualify_OamHeaderOffset_get,                    0, 8},
    {bcmFieldQualifyOamStampOffset,                     (int (*)(void)) bcm_field_qualify_OamStampOffset,                     (int (*)(void)) bcm_field_qualify_OamStampOffset_get,                     0, 8},
    {bcmFieldQualifyOamMepId,                           (int (*)(void)) bcm_field_qualify_OamMepId,                           (int (*)(void)) bcm_field_qualify_OamMepId_get,                           0, 8},
    {bcmFieldQualifyOamMeterDisable,                    (int (*)(void)) bcm_field_qualify_OamMeterDisable,                    (int (*)(void)) bcm_field_qualify_OamMeterDisable_get,                    0, 7},
    {bcmFieldQualifyOamTsSystemHeader ,                 (int (*)(void)) bcm_field_qualify_OamTsSystemHeader,                  (int (*)(void)) bcm_field_qualify_OamTsSystemHeader_get,                  0, 34},
    {bcmFieldQualifyEthernetOamHeaderBits0_31,          (int (*)(void)) bcm_field_qualify_EthernetOamHeaderBits0_31,          (int (*)(void)) bcm_field_qualify_EthernetOamHeaderBits0_31_get,          0, 8},
    {bcmFieldQualifyEthernetOamHeaderBits32_63,         (int (*)(void)) bcm_field_qualify_EthernetOamHeaderBits32_63,         (int (*)(void)) bcm_field_qualify_EthernetOamHeaderBits32_63_get,         0, 8},
    {bcmFieldQualifyMplsOamHeaderBits0_31,              (int (*)(void)) bcm_field_qualify_MplsOamHeaderBits0_31,              (int (*)(void)) bcm_field_qualify_MplsOamHeaderBits0_31_get,              0, 8},
    {bcmFieldQualifyMplsOamHeaderBits32_63,             (int (*)(void)) bcm_field_qualify_MplsOamHeaderBits32_63,             (int (*)(void)) bcm_field_qualify_MplsOamHeaderBits32_63_get,             0, 8},
    {bcmFieldQualifyMplsOamACH,                         (int (*)(void)) bcm_field_qualify_MplsOamACH,                         (int (*)(void)) bcm_field_qualify_MplsOamACH_get,                         0, 8},
    {bcmFieldQualifyOamHeaderBits0_31,                  (int (*)(void)) bcm_field_qualify_OamHeaderBits0_31,                  (int (*)(void)) bcm_petra_field_qualify_OamHeaderBits0_31_get,            0, 8},
    {bcmFieldQualifyOamHeaderBits32_63,                 (int (*)(void)) bcm_field_qualify_OamHeaderBits32_63,                 (int (*)(void)) bcm_petra_field_qualify_OamHeaderBits32_63_get,           0, 8},
    {bcmFieldQualifyInterfaceInPorts,                   (int (*)(void)) bcm_field_qualify_InterfaceInPorts,                   (int (*)(void)) bcm_field_qualify_InterfaceInPorts_get,                   0, 6},
    {bcmFieldQualifyHashValue,                          NULL,                                                                 NULL,                                                                     0, -1},
    {bcmFieldQualifyInVPortWide,                        (int (*)(void)) bcm_field_qualify_InVPortWide,                        (int (*)(void)) bcm_field_qualify_InVPortWide_get,                        0, 34},
    {bcmFieldQualifyStackingRoute,                      (int (*)(void)) bcm_field_qualify_StackingRoute,                      (int (*)(void)) bcm_field_qualify_StackingRoute_get,                 0, 8},
    {bcmFieldQualifyDstSysPortExt,                      (int (*)(void)) bcm_field_qualify_DstSysPortExt,                      (int (*)(void)) bcm_field_qualify_DstSysPortExt_get,                           0, 12},
    {bcmFieldQualifyForwardHdrSrcMac,                   (int (*)(void)) bcm_field_qualify_ForwardHdrSrcMac,                   (int (*)(void)) bcm_field_qualify_ForwardHdrSrcMac_get,                   0, 1},
    {bcmFieldQualifyForwardHdrDstMac,                   (int (*)(void)) bcm_field_qualify_ForwardHdrDstMac,                   (int (*)(void)) bcm_field_qualify_ForwardHdrDstMac_get,                   0, 1},
    {bcmFieldQualifyForwardHdrVlanId,                   (int (*)(void)) bcm_field_qualify_ForwardHdrVlanId,                   (int (*)(void)) bcm_field_qualify_ForwardHdrVlanId_get,                   0, 9},
    {bcmFieldQualifyLearnInVPort,                       (int (*)(void)) bcm_field_qualify_LearnInVPort,                       (int (*)(void)) bcm_field_qualify_LearnInVPort_get,                       0, 8},
    {bcmFieldQualifyLearnExtension,                     (int (*)(void)) bcm_field_qualify_LearnExtension,                     (int (*)(void)) bcm_field_qualify_LearnExtension_get,                     0, 27},
    {bcmFieldQualifyVlanAction,                         (int (*)(void)) bcm_field_qualify_VlanAction,                         (int (*)(void)) bcm_field_qualify_VlanAction_get,                         0, 8},
    {bcmFieldQualifyRxTrapStrength,                     (int (*)(void)) bcm_field_qualify_RxTrapStrength,                     (int (*)(void)) bcm_field_qualify_RxTrapStrength_get,                     0, 8},
    {bcmFieldQualifyGeneratedTtl,                       (int (*)(void)) bcm_field_qualify_GeneratedTtl,                       (int (*)(void)) bcm_field_qualify_GeneratedTtl_get,                       0, 8},
    {bcmFieldQualifyIpMulticastCompatible,              (int (*)(void)) bcm_field_qualify_IpMulticastCompatible,              (int (*)(void)) bcm_field_qualify_IpMulticastCompatible_get,              0, 8},
    {bcmFieldQualifyIncomingIpIfClass,                  (int (*)(void)) bcm_field_qualify_IncomingIpIfClass,                  (int (*)(void)) bcm_field_qualify_IncomingIpIfClass_get,                  0, 8},
    {bcmFieldQualifyCount,                              NULL,                                                                 NULL,                                                                     0, -1},
};                                                             
/*
 * The prototype_id options are:
 *  0  int (*) (int, bcm_field_entry_t, bcm_ip6_t, bcm_ip6_t)
 *  1  int (*) (int, bcm_field_entry_t, bcm_mac_t, bcm_mac_t)
 *  2  int (*) (int, bcm_field_entry_t, bcm_field_snap_header_t, bcm_field_snap_header_t)
 *  3  int (*) (int, bcm_field_entry_t, bcm_ip_t, bcm_ip_t)
 *  4  int (*) (int, bcm_field_entry_t, bcm_field_llc_header_t, bcm_field_llc_header_t)
 *  5  int (*) (int, bcm_field_entry_t, bcm_port_t, bcm_port_t)
 *  6  int (*) (int, bcm_field_entry_t, bcm_pbmp_t, bcm_pbmp_t)
 *  7  int (*) (int, bcm_field_entry_t, uint8, uint8)
 *  8  int (*) (int, bcm_field_entry_t, uint32, uint32)
 *  9  int (*) (int, bcm_field_entry_t, bcm_vlan_t, bcm_vlan_t)
 * 10  int (*) (int, bcm_field_entry_t, bcm_field_range_t, int)
 * 11  int (*) (int, bcm_field_entry_t, bcm_l4_port_t, bcm_l4_port_t)
 * 12  int (*) (int, bcm_field_entry_t, uint16, uint16)
 * 13  int (*) (int, bcm_field_entry_t, bcm_module_t, bcm_module_t, bcm_port_t, bcm_port_t)
 * 14  int (*) (int, bcm_field_entry_t, bcm_trunk_t, bcm_trunk_t)
 * 15  int (*) (int, bcm_field_entry_t, bcm_field_IpProtocolCommon_t)
 * 16  int (*) (int, bcm_field_entry_t, uint16)
 * 17  int (*) (int, bcm_field_entry_t, bcm_field_IpType_t)
 * 18  int (*) (int, bcm_field_entry_t, bcm_field_TunnelType_t)
 * 19  int (*) (int, bcm_field_entry_t, bcm_field_LoopbackType_t)
 * 20  int (*) (int, bcm_field_entry_t, bcm_field_ForwardingType_t)
 * 21  int (*) (int, bcm_field_entry_t, bcm_field_stage_t)
 * 22  int (*) (int, bcm_field_entry_t, uint32)
 * 23  int (*) (int, bcm_field_entry_t, bcm_field_IpFrag_t)
 * 24  int (*) (int, bcm_field_entry_t, bcm_field_L2Format_t)
 * 25  int (*) (int, bcm_field_entry_t, bcm_if_t)
 * 26  int (*) (int, bcm_field_entry_t, bcm_gport_t)
 * 27  int (*) (int, bcm_field_entry_t, uint8)
 * 28  int (*) (int, bcm_field_entry_t, bcm_vpn_t, bcm_vpn_t)
 * 29  int (*) (int, bcm_field_entry_t, bcm_field_FibreChan_t)
 * 30  int (*) (int, bcm_field_entry_t, uint32, uint32, uint32, uint32)
 * 31  int (*) (int, bcm_field_entry_t, bcm_field_header_format_t)
 * 32  int (*) (int, bcm_field_entry_t, bcm_field_header_format_set_t)
 * 33  int (*) (int, bcm_field_entry_t, bcm_rx_trap_t)
 * 34  int (*) (int, bcm_field_entry_t, uint64, uint64)
 * 35  int (*) (int, bcm_field_entry_t, bcm_field_ArpOpcode_t)
 * 36  int (*) (int, bcm_field_entry_t, bcm_field_data_offset_base_t, uint32, uint32)
 * 37  int (*) (int, bcm_field_entry_t, bcm_field_AppType_t)
 */

/* for prototype id 15 - from the U.M. */
CONST STATIC bcm_field_IpProtocolCommon_t supported_IpProtocolCommon_Ingress[] = {
    bcmFieldIpProtocolCommonTcp,
    bcmFieldIpProtocolCommonUdp,
    bcmFieldIpProtocolCommonIgmp,
    bcmFieldIpProtocolCommonIcmp,
    bcmFieldIpProtocolCommonIp6Icmp,
    bcmFieldIpProtocolCommonIpInIp,
    bcmFieldIpProtocolCommonIp6InIp,
    bcmFieldIpProtocolCommonUnknown,
    bcmFieldIpProtocolCommonMplsInIp
};

#define NOF_SUPPORTED_IP_PROTOCOL_COMMON_INGRESS        sizeof(supported_IpProtocolCommon_Ingress)/sizeof(bcm_field_IpProtocolCommon_t)


CONST STATIC bcm_field_IpProtocolCommon_t *supported_IpProtocolCommon_Egress = supported_IpProtocolCommon_Ingress;

#define NOF_SUPPORTED_IP_PROTOCOL_COMMON_EGRESS         NOF_SUPPORTED_IP_PROTOCOL_COMMON_INGRESS

/* for prototype id 17 from field_utils.c*/
CONST STATIC bcm_field_IpType_t supported_IpType_Ingress[] = {
    bcmFieldIpTypeIpv4Any,
    bcmFieldIpTypeIpv6,
    bcmFieldIpTypeArp,
    /*bcmFieldIpTypeTrill, */
    /*bcmFieldIpTypeMim, - not good. Hard to explain... */ 
    bcmFieldIpTypeMplsUnicast,
    bcmFieldIpTypeAny
};

#define NOF_SUPPORTED_IP_TYPE_INGRESS       sizeof(supported_IpType_Ingress)/sizeof(bcm_field_IpType_t)


CONST STATIC bcm_field_IpType_t *supported_IpType_Egress = supported_IpType_Ingress;

#define NOF_SUPPORTED_IP_TYPE_EGRESS        NOF_SUPPORTED_IP_TYPE_INGRESS

/* for prototype id 18 from field_utils.c */
CONST STATIC bcm_field_TunnelType_t supported_TunnelType_Ingress[] = {
    bcmFieldTunnelTypeIp,
    bcmFieldTunnelTypeIp6,
    bcmFieldTunnelTypeMpls,
    bcmFieldTunnelTypeMplsControlWord,
    bcmFieldTunnelTypeMplsLabel2,
    bcmFieldTunnelTypeMplsLabel2ControlWord,
    bcmFieldTunnelTypeMplsLabel3,
    bcmFieldTunnelTypeMplsLabel3ControlWord,
    bcmFieldTunnelTypeTrill,
    bcmFieldTunnelTypeNone
};

#define NOF_SUPPORTED_TUNNEL_TYPE_INGRESS       sizeof(supported_TunnelType_Ingress)/sizeof(bcm_field_TunnelType_t)


CONST STATIC bcm_field_TunnelType_t *supported_TunnelType_Egress = supported_TunnelType_Ingress;

#define NOF_SUPPORTED_TUNNEL_TYPE_EGRESS        NOF_SUPPORTED_TUNNEL_TYPE_INGRESS

/* for prototype id 37 from field_utils.c */
CONST STATIC bcm_field_AppType_t supported_AppType_Ingress[] = {
    bcmFieldAppTypeL2,             
    bcmFieldAppTypeIp4Ucast,       
    bcmFieldAppTypeIp6Ucast,       
    bcmFieldAppTypeIp6Mcast,       
    bcmFieldAppTypeMpls,           
    bcmFieldAppTypeTrillUcast,     
    bcmFieldAppTypeTrillMcast,     
    bcmFieldAppTypeTrafficManagement,
    bcmFieldAppTypeMiM,            
    bcmFieldAppTypeIp4UcastRpf,    
    bcmFieldAppTypeIp6UcastRpf,    
    bcmFieldAppTypeIp4McastRpf,    
    bcmFieldAppTypeCompIp4McastRpf,
    bcmFieldAppTypeFCoE,           
    bcmFieldAppTypeFCoETransit,    
    bcmFieldAppTypeFCoEVft,        
    bcmFieldAppTypeFCoERemote,     
    bcmFieldAppTypeFCoEVftRemote,  
    bcmFieldAppTypeIp4MacSrcBind,  
    bcmFieldAppTypeIp6MacSrcBind,  
    bcmFieldAppTypeIp4SrcBind,     
    bcmFieldAppTypeIp6SrcBind
};

/* for prototype id 19 - Not supported */

/* for prototype id 20 - from the U.M. */
CONST STATIC bcm_field_ForwardingType_t supported_ForwardingType_Ingress[] = {
    bcmFieldForwardingTypeL2,
    bcmFieldForwardingTypeIp4Ucast,
    bcmFieldForwardingTypeIp4Mcast,
    bcmFieldForwardingTypeIp6Ucast,
    bcmFieldForwardingTypeIp6Mcast,
    bcmFieldForwardingTypeMpls,
    bcmFieldForwardingTypeTrill,
    bcmFieldForwardingTypeRxReason
    /* bcmFieldForwardingTypeTrafficManagement is reserved for TM applications */
    /* bcmFieldForwardingTypeSnoop is missing */
};

#define NOF_SUPPORTED_FORWARDING_TYPE_INGRESS       sizeof(supported_ForwardingType_Ingress)/sizeof(bcm_field_ForwardingType_t)


CONST STATIC bcm_field_ForwardingType_t *supported_ForwardingType_Egress = supported_ForwardingType_Ingress;

#define NOF_SUPPORTED_FORWARDING_TYPE_EGRESS        NOF_SUPPORTED_FORWARDING_TYPE_INGRESS

/* for prototype id 21 */
CONST STATIC bcm_field_stage_t supported_stage_Ingress[] = {
    bcmFieldStageIngress,
    bcmFieldStageEgress
};

#define NOF_SUPPORTED_STAGE_INGRESS         sizeof(supported_stage_Ingress)/sizeof(bcm_field_stage_t)

CONST STATIC bcm_field_stage_t *supported_stage_Egress = supported_stage_Ingress;

#define NOF_SUPPORTED_STAGE_EGRESS          NOF_SUPPORTED_STAGE_INGRESS

/* for prototype id 23 - from the U.M. */
CONST STATIC bcm_field_IpFrag_t supported_IpFrag_Ingress[] = {
    bcmFieldIpFragNon,
    bcmFieldIpFragAny
};

#define NOF_SUPPORTED_IP_FRAG_INGRESS        sizeof(supported_IpFrag_Ingress)/sizeof(bcm_field_IpFrag_t)

CONST STATIC bcm_field_IpFrag_t supported_Jer_IpFrag_Ingress[] = {
    bcmFieldIpFragNonOrFirst,
    bcmFieldIpFragNotFirst
};

#define NOF_SUPPORTED_JER_IP_FRAG_INGRESS    sizeof(supported_Jer_IpFrag_Ingress)/sizeof(bcm_field_IpFrag_t)


CONST STATIC bcm_field_IpFrag_t *supported_IpFrag_Egress = supported_IpFrag_Ingress;

#define NOF_SUPPORTED_IP_FRAG_EGRESS         NOF_SUPPORTED_IP_FRAG_INGRESS

/* for prototype id 24 - from the U.M. */
CONST STATIC bcm_field_L2Format_t supported_L2Format_Ingress[] = {
    bcmFieldL2FormatAny,
    bcmFieldL2FormatEthII,
    bcmFieldL2FormatSnap,
    bcmFieldL2FormatLlc,
};

#define NOF_SUPPORTED_L2_FORMAT_INGRESS     sizeof(supported_L2Format_Ingress)/sizeof(bcm_field_L2Format_t)


CONST STATIC bcm_field_L2Format_t *supported_L2Format_Egress = supported_L2Format_Ingress;

#define NOF_SUPPORTED_L2_FORMAT_EGRESS      NOF_SUPPORTED_L2_FORMAT_INGRESS

/* for prototype id 29  - Not supported */

/* for prototype id 31 - from field_utils */
CONST STATIC bcm_field_header_format_t supported_header_format_Ingress[] = {
    bcmFieldHeaderFormatL2,
    bcmFieldHeaderFormatIp4,
    bcmFieldHeaderFormatIp6,
    bcmFieldHeaderFormatMplsLabel1,
    bcmFieldHeaderFormatMplsLabel2,
    bcmFieldHeaderFormatMplsLabel3,
    bcmFieldHeaderFormatIp4AnyL2L3,
    bcmFieldHeaderFormatIp6AnyL2L3,
    bcmFieldHeaderFormatMplsLabel1AnyL2L3,
    bcmFieldHeaderFormatMplsLabel2AnyL2L3,
    bcmFieldHeaderFormatMplsLabel3AnyL2L3,
    bcmFieldHeaderFormatEthEth,
    bcmFieldHeaderFormatEthTrillEth,
    bcmFieldHeaderFormatIp4Ip4,
    bcmFieldHeaderFormatIp6Ip4,
    bcmFieldHeaderFormatIp4MplsLabel1,
    bcmFieldHeaderFormatIp4MplsLabel2,
    bcmFieldHeaderFormatIp4MplsLabel3,
    bcmFieldHeaderFormatIp6MplsLabel1,
    bcmFieldHeaderFormatIp6MplsLabel2,
    bcmFieldHeaderFormatIp6MplsLabel3,
    bcmFieldHeaderFormatEthMplsLabel1,
    bcmFieldHeaderFormatEthMplsLabel2,
    bcmFieldHeaderFormatEthMplsLabel3
};


CONST STATIC bcm_field_header_format_t *supported_header_format_Egress = supported_header_format_Ingress;

/* for prototype id 33 - will be created automatically in the upload */

/* for prototype id 35 */
CONST STATIC bcm_field_ArpOpcode_t supported_ArpOpcode_Ingress[] = {
    bcmFieldArpOpcodeRequest,
    bcmFieldArpOpcodeReply,
};

void _bcm_petra_field_test_qual_remove_from_qset(bcm_field_qset_t *valid_qset)
{
    /*Qualifiers that shouldn't be used in a qset while creating field group*/
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyCascadedKeyValue);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyIsEqualValue);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyHashValue);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyStageIngress);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyStageEgress);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyStageExternal);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyLearnInVPort);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyLearnSrcPort);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyLearnExtension);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyGeneratedTtl);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyIpMulticastCompatible);
}

void _bcm_petra_field_test_ip_qual_remove_from_qset(bcm_field_qset_t *valid_qset)
{
    /*Qualifiers that shouldn't be used in a qset while creating field group*/
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyIp4);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyIp6);
    BCM_FIELD_QSET_REMOVE(*valid_qset, bcmFieldQualifyMpls);
}

/* for prototype id 36 */
STATIC void supported_data_offset_base(uint8 is_for_data_qualifier, uint8 is_for_entries, const bcm_field_data_offset_base_t **array, int *size){
    CONST static bcm_field_data_offset_base_t supported[] = {
        bcmFieldDataOffsetBasePacketStart,
        bcmFieldDataOffsetBaseL2Header,
        bcmFieldDataOffsetBaseFirstHeader,
        bcmFieldDataOffsetBaseSecondHeader,
        bcmFieldDataOffsetBaseThirdHeader,
        bcmFieldDataOffsetBaseFourthHeader,
        bcmFieldDataOffsetBaseForwardingHeader,
        bcmFieldDataOffsetBaseNextForwardingHeader
    };

    if(!size) {
        *array = NULL;
        return;
    }

    *array = supported;

    if(is_for_data_qualifier) {
        /* we can take also the 2 last offset base */
        if(is_for_entries) {
            /* take only 5 */
            *size = 5;
        } else {
            *size = 8;
        }
    } else {
        *size = 6;
    }
}

/* Takes the random value x the number of iteration i and returns the rand value*/
STATIC uint32 _bcm_petra_field_rand_val(uint32 x, uint32 i)
{
    uint16 x1 = x & 0xffff;
    uint16 x2 = (x >> 16) & 0xffff;
    return (i + 1) * x1 + (x2 + i) * i;
}

/*
 * Get the length of the qualifier as it lays in the hardware. Both of the cases: best and worst
 */
STATIC bcm_error_t _bcm_petra_field_test_qualify_hardware_length(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_qualify_t qualify, uint32 *length_best, uint32 *length_worst)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_QUAL_TYPE *soc_ppd_qual_ptr;
    bcm_error_t rv;
    unsigned int exposed, hardwareBestCase, hardwareWorstCase;
    uint32 ppd_qual_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, stage, 1 << type, qualify, &soc_ppd_qual_ptr);

    BCM_IF_ERROR_RETURN(rv);
    if(length_best) {
        *length_best = 0;
    }
    if(length_worst) {
        *length_worst = 0;
    }

    for(ppd_qual_ndx = 0; ppd_qual_ndx < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_ndx) {
        if((soc_ppd_qual_ptr[ppd_qual_ndx] != BCM_FIELD_ENTRY_INVALID) &&(soc_ppd_qual_ptr[ppd_qual_ndx] < SOC_PPC_NOF_FP_QUAL_TYPES)) {
            rv = _bcm_dpp_ppd_qual_bits(unit, stage, soc_ppd_qual_ptr[ppd_qual_ndx], &exposed, &hardwareBestCase, &hardwareWorstCase);
            BCM_IF_ERROR_RETURN(rv);
            if(length_best) {
                *length_best += hardwareBestCase;
            }
            if(length_worst) {
                *length_worst += hardwareWorstCase;
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the length of the qualifier as it lays in the hardware. Best case only
 */
STATIC bcm_error_t _bcm_petra_field_test_qualify_hardware_length_best(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_qualify_t qualify, uint32 *length)
{
    bcm_error_t rv;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(length);

    rv = _bcm_petra_field_test_qualify_hardware_length(unit, stage, type, qualify, length, NULL);
    BCM_IF_ERROR_RETURN(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the length of the qualifier as it lays in the hardware. Worst case only
 */
STATIC bcm_error_t _bcm_petra_field_test_qualify_hardware_length_worst(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_qualify_t qualify, uint32 *length)
{
    bcm_error_t rv;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(length);

    rv = _bcm_petra_field_test_qualify_hardware_length(unit, stage, type, qualify, NULL, length);
    BCM_IF_ERROR_RETURN(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the length of kwy (i.e. qset that includes qualifiers and not data qualifiers)
 */
STATIC bcm_error_t _bcm_petra_field_test_key_length_best(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_qset_t qset, uint32 *length)
{
    bcm_error_t rv;
    bcm_field_qualify_t cur_qualifier;
    uint32 cur_qualifier_length;
    uint32 type;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(length);
    
    type = _BCM_PETRA_FIELD_TYPE_ETHR;
    if(BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyIp4)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV4;
    } else if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyIp6)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV6;
    } else if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyMpls)) {
        type = _BCM_PETRA_FIELD_TYPE_MPLS;
    }

    *length = 0;
    
    for(cur_qualifier = 0; cur_qualifier < bcmFieldQualifyCount; ++cur_qualifier) {
        if(BCM_FIELD_QSET_TEST(qset, cur_qualifier)) {
            rv = _bcm_petra_field_test_qualify_hardware_length_best(unit, stage, type, cur_qualifier, &cur_qualifier_length);
            BCM_IF_ERROR_RETURN(rv); 
            *length += cur_qualifier_length;
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the exposed length of qualifier which determines the maximal value of this.
 * Needed to choose random mask and value for the qualifier
 */
STATIC bcm_error_t _bcm_petra_field_test_qualify_exposed_length(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_qualify_t qualify, uint32 *length)
{
    bcm_dpp_field_info_OLD_t *unitData;
    bcm_error_t rv;

    int ppd_qual_ndx;
    SOC_PPC_FP_QUAL_TYPE *ppdQual;
    unsigned int len[_BCM_PETRA_FIELD_QUAL_CHAIN];
    int32 *qualMap ;
    int32 qualMaps_handle ;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_QUALMAPS.get(unit, qualify, &qualMaps_handle)) ;

    if(qualMaps_handle == 0)
    {
        /* i.e. the qualifier is not supported */
        *length = 0;
        BCM_EXIT;
    }
    
    /* get the qualifier mapping */
    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData,
                                         stage,
                                         (type == 0xffffffff) ? 0xf : (1 << type),
                                         qualify,
                                         &ppdQual);
    
    BCM_IF_ERROR_RETURN(rv);
    SOC_SAND_QUALMAPS_CONVERT_HANDLE_TO_ELEMENT(unit,qualMaps_handle,qualMap) ;
    if (qualMap[_BCM_DPP_FIELD_QUALMAP_OFFSET_LENGTH] > 0) {
        *length = qualMap[_BCM_DPP_FIELD_QUALMAP_OFFSET_LENGTH];
    } else {
        for (ppd_qual_ndx = 0, *length = 0;
             (BCM_E_NONE == rv) &&
             (ppd_qual_ndx < unitData->devInfo->qualChain);
             ppd_qual_ndx++) {
            if ((ppdQual[ppd_qual_ndx] < SOC_PPC_NOF_FP_QUAL_TYPES) &&(ppdQual[ppd_qual_ndx] != BCM_FIELD_ENTRY_INVALID)) {
                rv = _bcm_dpp_ppd_qual_bits(unit,
                                            stage,
                                            ppdQual[ppd_qual_ndx],
                                            &(len[ppd_qual_ndx]),
                                            NULL,
                                            NULL);
                *length += len[ppd_qual_ndx];
            }
        }
        BCM_IF_ERROR_RETURN(rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the length of the qualifier as it lays in the hardware
 */
STATIC bcm_error_t _bcm_petra_field_test_data_qualifier_length(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 qual_id, uint32 *length)
{
    bcm_error_t rv;
    bcm_field_data_qualifier_t dq;
    
    bcm_field_data_qualifier_t_init(&dq);
    dq.flags = BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES;
    rv = bcm_petra_field_data_qualifier_get(unit, qual_id, &dq);

    if(rv != BCM_E_NONE){
        return rv;
    }
    
    *length = dq.length;
    if((dq.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
    /* i.e the size is in bytes */
        *length *= 8;
    }
    return BCM_E_NONE;
}

/*
 * get the length of the action in bits
 */
 
STATIC bcm_error_t _bcm_petra_field_test_action_length(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_action_t action, uint32 *length)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_ACTION_TYPE *soc_ppd_action_ptr;
    bcm_error_t rv;
    unsigned int action_length;
    uint32 ppd_action_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(length);
    
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_act_from_bcm_act(unitData, stage, action, &soc_ppd_action_ptr);

    BCM_IF_ERROR_RETURN(rv);

    *length = 0;

    for(ppd_action_ndx = 0; ppd_action_ndx < _BCM_PETRA_FIELD_ACTION_CHAIN; ++ppd_action_ndx) {
        if((soc_ppd_action_ptr[ppd_action_ndx] < SOC_PPC_NOF_FP_ACTION_TYPES) && (soc_ppd_action_ptr[ppd_action_ndx] != BCM_FIELD_ENTRY_INVALID)) {
            rv = _bcm_dpp_ppd_action_bits(unit, stage, soc_ppd_action_ptr[ppd_action_ndx], &action_length);
            BCM_IF_ERROR_RETURN(rv);
            *length += action_length;
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC bcm_error_t _bcm_petra_field_test_action_length_with_ppd_actions(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_action_t action, uint32 *length, uint32 *nof_ppd_actions)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_ACTION_TYPE *soc_ppd_action_ptr;
    bcm_error_t rv;
    unsigned int action_length;
    uint32 ppd_action_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(length);
    
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_act_from_bcm_act(unitData, stage, action, &soc_ppd_action_ptr);

    BCM_IF_ERROR_RETURN(rv);

    *length = 0;

    for(ppd_action_ndx = 0; ppd_action_ndx < _BCM_PETRA_FIELD_ACTION_CHAIN; ++ppd_action_ndx) {
        if((soc_ppd_action_ptr[ppd_action_ndx] < SOC_PPC_NOF_FP_ACTION_TYPES) && (soc_ppd_action_ptr[ppd_action_ndx] != BCM_FIELD_ENTRY_INVALID)) {
            rv = _bcm_dpp_ppd_action_bits(unit, stage, soc_ppd_action_ptr[ppd_action_ndx], &action_length);
            BCM_IF_ERROR_RETURN(rv);
            *length += action_length;
            *nof_ppd_actions += 1;
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC bcm_error_t _bcm_petra_field_test_action_length_with_valid_bit(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_action_t action, uint32 *length) {
    bcm_error_t rv;
    uint32 nof_ppd_actions = 0;
    rv = _bcm_petra_field_test_action_length_with_ppd_actions(unit, stage, action, length, &nof_ppd_actions);
    if(rv != BCM_E_NONE) {
        return rv;
    }
    *length += nof_ppd_actions; /* adding a valid bit for each ppd action*/
    return BCM_E_NONE;
}

/* 
 * This function gets the length of each one of the qualifiers and put the value in the global array qualifiers_info
 */
STATIC cmd_result_t _bcm_petra_field_test_set_qualifiers_info(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type)
{
    static uint8 is_qualifiers_info_set = 0;
    static int   qualifiers_info_unit = -1;
    static _bcm_dpp_field_stage_idx_t qualifiers_info_stage;
    static uint32 qualifiers_info_type = 0xffffffff;

    bcm_error_t rv;
    uint32 qual_ndx;
    bcm_field_qset_t valid_qset;
    bcm_field_aset_t junk; 

    if(is_qualifiers_info_set && qualifiers_info_unit == unit && qualifiers_info_stage == stage && qualifiers_info_type == type) {
        return CMD_OK;
    }

    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, stage, type, &valid_qset, &junk);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    
    for(qual_ndx = 0; ((qualifiers_info[qual_ndx].qualify != bcmFieldQualifyCount) && (qualifiers_info[qual_ndx].qualify != BCM_FIELD_ENTRY_INVALID)); ++qual_ndx) {
        if(qualifiers_info[qual_ndx].set != NULL) {
            if(BCM_FIELD_QSET_TEST(valid_qset, qualifiers_info[qual_ndx].qualify)) {
                rv = _bcm_petra_field_test_qualify_exposed_length(unit, stage, type, qualifiers_info[qual_ndx].qualify, &qualifiers_info[qual_ndx].size);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
        }
    }
    is_qualifiers_info_set = 1;

    qualifiers_info_unit = unit;
    qualifiers_info_stage = stage;
    qualifiers_info_type = type;
    
    return CMD_OK;
}

STATIC void buffer_to_mac(uint32 *buffer, bcm_mac_t *mac_t)
{
    (*mac_t)[5] = buffer[0] & 0xff;
    (*mac_t)[4] = (buffer[0] >> 8) & 0xff;
    (*mac_t)[3] = (buffer[0] >> 16) & 0xff;
    (*mac_t)[2] = (buffer[0] >> 24) & 0xff;
    (*mac_t)[1] = buffer[1] & 0xff;
    (*mac_t)[0] = (buffer[1] >> 8) & 0xff;
}

STATIC void mac_to_buffer(bcm_mac_t mac_t, uint32 *buffer)
{
    buffer[0] = mac_t[5];
    buffer[0] |= mac_t[4] << 8;
    buffer[0] |= mac_t[3] << 16;
    buffer[0] |= mac_t[2] << 24;
    buffer[1] = mac_t[1];
    buffer[1] |= mac_t[0] << 8;
}

STATIC void buffer_to_ip6(uint32 *buffer, bcm_ip6_t *ip6)
{
    uint32 i;
    for(i = 0; i < 4; ++i) {
        (*ip6)[15 - 4*i] = buffer[i] & 0xff;
        (*ip6)[14 - 4*i] = (buffer[i] >> 8) & 0xff;
        (*ip6)[13 - 4*i] = (buffer[i] >> 16) & 0xff;
        (*ip6)[12 - 4*i] = (buffer[i] >> 24) & 0xff;
    }
}


STATIC soc_error_t get_vaild_local_port(int unit, soc_port_t *port_result) {
    int port_itr;
    uint32 is_valid_port = FALSE;
    soc_port_if_t port_interface_type;

    for ( port_itr = 0 ; port_itr < _BCM_DPP_NOF_LOCAL_PORTS(unit) ; port_itr++ ) {
        if ( soc_port_sw_db_is_valid_port_get(unit, port_itr, &is_valid_port) != SOC_E_NONE ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return SOC_E_FAIL;
        }
        if ( is_valid_port ) {
            if ( soc_port_sw_db_interface_type_get(unit,port_itr,&port_interface_type) != SOC_E_NONE ){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return SOC_E_FAIL;
            }
            /* check if it's a nif port*/
            if ( (port_interface_type == SOC_PORT_IF_ILKN) || (port_interface_type == SOC_PORT_IF_CAUI) || (port_interface_type == SOC_PORT_IF_XFI)) {                
                *port_result = port_itr;
                return SOC_E_NONE;
            }
        }
    }
    return SOC_E_FAIL;
}

STATIC void ip6_to_buffer(bcm_ip6_t ip6, uint32 *buffer)
{
    uint32 i;
    for(i = 0; i < 4; ++i) {
        buffer[i] = ip6[15 - 4*i];
        buffer[i] |= ip6[14 - 4*i] << 8;
        buffer[i] |= ip6[13 - 4*i] << 16;
        buffer[i] |= ip6[12 - 4*i] << 24;
    }
}

/*
 * This function gets unit, entry, qualifier, arrays that contains the data and the mask (if needed mask).
 * The function casts the prototype of the qualifier set function from the table qualifiers_info
 * to the adequate one according to the type_id stored in this table and operates it.
 */
  
STATIC bcm_error_t _bcm_petra_field_test_operate_set_function(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_entry_t entry, bcm_field_qualify_t qualifier, uint32 *data, uint32 *mask)
{
    cmd_result_t result;
    int prototype = -1;
    int qual_index;

    BCMDNX_INIT_FUNC_DEFS;

    for(qual_index=0; ((qualifiers_info[qual_index].qualify != bcmFieldQualifyCount) && (qualifiers_info[qual_index].qualify != BCM_FIELD_ENTRY_INVALID)); ++qual_index) {
        if(qualifiers_info[qual_index].qualify == qualifier) {
            prototype = qualifiers_info[qual_index].prototype_id;
            break;
        }
    }

    
    result = _bcm_petra_field_test_set_qualifiers_info(unit, stage, type);
    if(result != CMD_OK) {
        return BCM_E_FAIL;
    }

    switch(prototype) {
        case 0: 
        {
            bcm_ip6_t s_data, s_mask;
            if(qualifier == bcmFieldQualifySrcIp6High || qualifier == bcmFieldQualifyDstIp6High) {
                /* and hence put the data in the high address */
                uint32 tmp_data[4];
                uint32 tmp_mask[4];
                
                tmp_data[0] = 0;
                tmp_data[1] = 0;
                tmp_data[2] = data[0];
                tmp_data[3] = data[1];
                tmp_mask[0] = 0;
                tmp_mask[1] = 0;
                tmp_mask[2] = mask[0];
                tmp_mask[3] = mask[1];
                buffer_to_ip6(tmp_data, &s_data);
                buffer_to_ip6(tmp_mask, &s_mask);
            } else {
                /* even toogh the qualifier has only the lower address the high should be 0 */
                buffer_to_ip6(data, &s_data);
                buffer_to_ip6(mask, &s_mask);
            }

            return ((int (*) (int, bcm_field_entry_t, bcm_ip6_t, bcm_ip6_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 1:
        {
            bcm_mac_t s_data, s_mask;
            buffer_to_mac(data, &s_data);
            buffer_to_mac(mask, &s_mask);
            return ((int (*) (int, bcm_field_entry_t, bcm_mac_t, bcm_mac_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 2:
        {
            bcm_field_snap_header_t s_data, s_mask;
            s_data.org_code = data[0];
            s_data.type = data[1] & 0xffff;
            s_mask.org_code = mask[0];
            s_mask.type = mask[1] & 0xffff;
            return ((int (*) (int, bcm_field_entry_t, bcm_field_snap_header_t, bcm_field_snap_header_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 3:
        {
            bcm_ip_t s_data, s_mask;
            /* bcm_ip_t is uint32 */
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_ip_t, bcm_ip_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 4:
        {
            bcm_field_llc_header_t s_data, s_mask;
            s_data.dsap = data[0] & 0xff;
            s_data.ssap = (data[0] >> 8) & 0xff;
            s_data.control = (data[0] >> 16) & 0xff;
            s_mask.dsap = mask[0] & 0xff;
            s_mask.ssap = (mask[0] >> 8)  & 0xff;
            s_mask.control = (mask[0] >> 16) & 0xff;
            return ((int (*) (int, bcm_field_entry_t, bcm_field_llc_header_t, bcm_field_llc_header_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 5:
        {
            /* bcm_port_t is int - we assume 32 bits*/
            bcm_port_t s_data, s_mask;
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_port_t, bcm_port_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 6:
        {
            bcm_pbmp_t s_data, s_mask;
            uint32 port;
            uint32 is_valid;

            BCM_PBMP_CLEAR(s_data);
            BCM_PBMP_CLEAR(s_mask);
            for(port =0; port < _BCM_DPP_NOF_LOCAL_PORTS(unit); ++port){

                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port, &is_valid));

                if (is_valid) {
                /* filter only valid ports */
                    if(SHR_BITGET(data, port)) {
                        BCM_PBMP_PORT_ADD(s_data, port);
                    }
                }

                if(SHR_BITGET(mask, port)) {
                    BCM_PBMP_PORT_ADD(s_mask, port);
                }

            }
            return ((int (*) (int, bcm_field_entry_t, bcm_pbmp_t, bcm_pbmp_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 7:
        {
            uint8 s_data, s_mask;
            s_data = data[0] & 0xff;
            s_mask = mask[0] & 0xff;
            return ((int (*) (int, bcm_field_entry_t, uint8, uint8)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 8:
        {
            uint32 s_data, s_mask;
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*) (int, bcm_field_entry_t, uint32, uint32)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 9:
        {
            bcm_vlan_t s_data, s_mask;
            /* bcm_vlan_t is uint16 */
            s_data = data[0] & 0xffff;
            s_mask = mask[0] & 0xffff;
            return ((int (*) (int, bcm_field_entry_t, bcm_vlan_t, bcm_vlan_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 10:
        {
            /* will be implemented latter*/
            return BCM_E_UNAVAIL;
            /* return ((int (*) (int, bcm_field_entry_t, bcm_field_range_t, int)) qualifiers_info[qual_index].set(unit, entry, s_data, s_mask); */
        }
        case 11:
        {
            bcm_l4_port_t s_data, s_mask;
            /* bcm_l4_port_t is int - we assume 32-bits*/
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_l4_port_t, bcm_l4_port_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 12:
        {
            uint16 s_data, s_mask;
            s_data = data[0] & 0xffff;
            s_mask = mask[0] & 0xffff; 
            return ((int (*) (int, bcm_field_entry_t, uint16, uint16)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 13:
        {
            /* will be implemented latter */
            return BCM_E_UNAVAIL;
            /* return ((int (*) (int, bcm_field_entry_t, bcm_module_t, bcm_module_t, bcm_port_t, bcm_port_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);*/
        }
        case 14:
        {
            bcm_trunk_t s_data, s_mask;
            /* bcm_truck_t is int -we assume 32-bits */
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_trunk_t, bcm_trunk_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 15:
        {
            bcm_field_IpProtocolCommon_t s_data;
            /* bcm_field_IpProtocolCommon_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_IpProtocolCommon_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 16:
        {
            uint16 s_data;
            s_data = data[0] & 0xffff;
            return ((int (*) (int, bcm_field_entry_t, uint16))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 17:
        {
            bcm_field_IpType_t s_data;
            /* bcm_field_IpType_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_IpType_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 18:
        {
            bcm_field_TunnelType_t s_data;
            /* bcm_field_TunnelType_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_TunnelType_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 19:
        {
            bcm_field_LoopbackType_t s_data;
            /* bcm_field_LoopbackType_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_LoopbackType_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 20:
        {
            bcm_field_ForwardingType_t s_data;
            /* bcm_field_ForwardingType_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_ForwardingType_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 21:
        {
            bcm_field_stage_t s_data;
            /* bcm_field_stage_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_stage_t))qualifiers_info[qual_index].set)(unit, entry, s_data);            
        }
        case 22:
        {
            uint32 s_data;
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, uint32))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 23:
        {
            bcm_field_IpFrag_t s_data;
            /* bcm_field_IpFrag_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_IpFrag_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 24:
        {
            bcm_field_L2Format_t s_data;
            /* bcm_field_L2Format_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_L2Format_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 25:
        {
            bcm_if_t s_data;
            /* bcm_if_t is int - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_if_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 26:
        {
            bcm_gport_t s_data;
            /* bcm_gport_t is int - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_gport_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 27:
        {
            uint8 s_data;
            s_data = data[0] & 0xff;
            return ((int (*) (int, bcm_field_entry_t, uint8))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 28:
        {
            bcm_vpn_t s_data, s_mask;
            /* bcm_vpn_t is uint16 */
            s_data = data[0] & 0xffff;
            s_mask = mask[0] & 0xffff;
            return ((int (*) (int, bcm_field_entry_t, bcm_vpn_t, bcm_vpn_t))qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 29:
        {
            bcm_field_FibreChan_t s_data;
            /* bcm_field_FibreChan_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_FibreChan_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 30:
        {
            return BCM_E_UNAVAIL;
            /* will be implemented latter */
            /* return ((int (*) (int, bcm_field_entry_t, uint32, uint32, uint32, uint32)) */
        }
        case 31:
        {
            bcm_field_header_format_t s_data;
            /* bcm_field_header_format_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_header_format_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 32:
        {
            bcm_field_header_format_set_t s_data;
            uint32 index;
            BCM_FIELD_HEADER_FORMAT_SET_INIT(s_data);
            for(index = 0; index < bcmFieldHeaderFormatCount; ++index) {
                if (SHR_BITGET(data, index)) {
                    BCM_FIELD_HEADER_FORMAT_SET_ADD(s_data, index);
                }
            }
            return ((int (*) (int, bcm_field_entry_t, bcm_field_header_format_set_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 33:
        {
            bcm_rx_trap_t s_data;
            /* bcm_rx_trap_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_rx_trap_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 34:
        {
            uint64 s_data, s_mask;
            COMPILER_64_SET(s_data, data[1], data[0]);
            COMPILER_64_SET(s_mask, mask[1], mask[0]);
            return ((int (*) (int, bcm_field_entry_t, uint64, uint64))qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);
        }
        case 35:
        {
            bcm_field_ArpOpcode_t s_data;
            /* bcm_field_ArpOpcode_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_ArpOpcode_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        case 36:
        {
            /* here we take data[0] and mask[0] for data and mask, and data offset base will be in data[1] */
            bcm_field_data_offset_base_t offset_base = data[1];
            uint32 s_data, s_mask;
            s_data = data[0];
            s_mask = mask[0];
            return ((int (*)(int, bcm_field_entry_t, bcm_field_data_offset_base_t, uint32, uint32))qualifiers_info[qual_index].set)(unit, entry, offset_base, s_data, s_mask);
        }
        case 37:
        {
            bcm_field_AppType_t s_data;
            /* bcm_field_AppType_t is enumerator - we assume 32 bits*/
            s_data = data[0];
            return ((int (*) (int, bcm_field_entry_t, bcm_field_AppType_t))qualifiers_info[qual_index].set)(unit, entry, s_data);
        }
        default:
            return BCM_E_FAIL;
    }
exit:
    BCMDNX_FUNC_RETURN;

}

/*
 * This function gets unit, entry, qualifier, arrays that contains the data and the mask to be get.
 * The function casts the prototype of the qualifier get function from the table qualifiers_info
 * to the adequate one according to the type_id stored in this table and operates it.
 */

STATIC bcm_error_t _bcm_petra_field_test_operate_get_function(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_entry_t entry, bcm_field_qualify_t qualifier, uint32 *data, uint32 *mask)
{
    cmd_result_t result;
    bcm_error_t rv;
    int prototype = -1;
    int qual_index;

    for(qual_index=0; (qualifiers_info[qual_index].qualify != bcmFieldQualifyCount) && (qualifiers_info[qual_index].qualify != BCM_FIELD_ENTRY_INVALID); ++qual_index) {
        if(qualifiers_info[qual_index].qualify == qualifier) {
            prototype = qualifiers_info[qual_index].prototype_id;
            break;
        }
    }

    
    result = _bcm_petra_field_test_set_qualifiers_info(unit, stage, type);
    if(result != CMD_OK) {
        return BCM_E_FAIL;
    }

    sal_memset(data, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
    sal_memset(mask, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);

    switch(prototype) {
        case 0: 
        {
            bcm_ip6_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_ip6_t*, bcm_ip6_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            if(qualifier == bcmFieldQualifySrcIp6High || qualifier == bcmFieldQualifyDstIp6High) {
                /* and hence put the high address in the data */
                uint32 tmp_data[4];
                uint32 tmp_mask[4];
                
                ip6_to_buffer(s_data, tmp_data);
                ip6_to_buffer(s_mask, tmp_mask);
                data[0] = tmp_data[2];
                data[1] = tmp_data[3];
                mask[0] = tmp_mask[2];
                mask[1] = tmp_mask[3];
            } else {
                /* even toogh the qualifier has only the lower address the high should be 0 */
                ip6_to_buffer(s_data, data);
                ip6_to_buffer(s_mask, mask);
            }
            return rv; 
        }
        case 1:
        {
            bcm_mac_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_mac_t*, bcm_mac_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            mac_to_buffer(s_data, data);
            mac_to_buffer(s_mask, mask);
            return rv;
        }
        case 2:
        {
            bcm_field_snap_header_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_snap_header_t*, bcm_field_snap_header_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] = s_data.org_code;
            data[1] = s_data.type;
            mask[0] |= s_mask.org_code;
            mask[1] |= s_mask.type;
            return rv;
        }
        case 3:
        {
            bcm_ip_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_ip_t*, bcm_ip_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            /* bcm_ip_t is uint32 */
            data[0] = s_data;
            mask[0] = s_mask;
            return rv;
        }
        case 4:
        {
            bcm_field_llc_header_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_llc_header_t*, bcm_field_llc_header_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] |= s_data.dsap;
            data[0] |= s_data.ssap << 8;
            data[0] |= s_data.control << 16;
            mask[0] |= s_mask.dsap;
            mask[0] |= s_mask.ssap << 8;
            mask[0] |= s_mask.control << 16;
            return rv;
        }
        case 5:
        {
            /* bcm_port_t is int - we assume 32 bits*/
            bcm_port_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_port_t*, bcm_port_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] = s_data;
            mask[0] = s_mask;
            return rv;
        }
        case 6:
        {
            bcm_pbmp_t s_data, s_mask;
            uint32 port;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_pbmp_t*, bcm_pbmp_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            for(port =0; port < _BCM_DPP_NOF_LOCAL_PORTS(unit); ++port){
                if(BCM_PBMP_MEMBER(s_data, port)) {
                    SHR_BITSET(data, port);
                }
                if(BCM_PBMP_MEMBER(s_mask, port)) {
                    SHR_BITSET(mask, port);
                }
            }
            return rv;
        }
        case 7:
        {
            uint8 s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, uint8*, uint8*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] |= s_data;
            mask[0] |= s_mask;
            return rv;
        }
        case 8:
        {
            uint32 s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, uint32*, uint32*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] = s_data;
            mask[0] = s_mask;
            return rv;
        }
        case 9:
        {
            bcm_vlan_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_vlan_t*, bcm_vlan_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            /* bcm_vlan_t is uint16 */
            data[0] |= s_data;
            mask[0] |= s_mask;
            return rv;
        }
        case 10:
        {
            /* will be implemented latter*/
            return BCM_E_UNAVAIL;
            /* return ((int (*) (int, bcm_field_entry_t, bcm_field_range_t, int)) qualifiers_info[qual_index].set(unit, entry, s_data, s_mask); */
        }
        case 11:
        {
            bcm_l4_port_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_l4_port_t*, bcm_l4_port_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            /* bcm_l4_port_t is int - we assume 32-bits*/
            data[0] = s_data;
            mask[0] = s_mask;
            return rv;
        }
        case 12:
        {
            uint16 s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, uint16*, uint16*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] = s_data;
            mask[0] = s_mask; 
            return rv;
        }
        case 13:
        {
            /* will be implemented latter */
            return BCM_E_UNAVAIL;
            /* return ((int (*) (int, bcm_field_entry_t, bcm_module_t, bcm_module_t, bcm_port_t, bcm_port_t)) qualifiers_info[qual_index].set)(unit, entry, s_data, s_mask);*/
        }
        case 14:
        {
            bcm_trunk_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_trunk_t*, bcm_trunk_t*)) qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            /* bcm_truck_t is int -we assume 32-bits */
            data[0] = s_data;
            mask[0] = s_mask;
            return rv;
        }
        case 15:
        {
            bcm_field_IpProtocolCommon_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_IpProtocolCommon_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_IpProtocolCommon_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 16:
        {
            uint16 s_data;
            rv = ((int (*) (int, bcm_field_entry_t, uint16*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            data[0] |= s_data;
            return rv;
        }
        case 17:
        {
            bcm_field_IpType_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_IpType_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_IpType_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 18:
        {
            bcm_field_TunnelType_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_TunnelType_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_TunnelType_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 19:
        {
            bcm_field_LoopbackType_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_LoopbackType_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_LoopbackType_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 20:
        {
            bcm_field_ForwardingType_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_ForwardingType_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_ForwardingType_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 21:
        {
            bcm_field_stage_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_stage_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_stage_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 22:
        {
            uint32 s_data;
            rv = ((int (*) (int, bcm_field_entry_t, uint32*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            data[0] = s_data;
            return rv;
        }
        case 23:
        {
            bcm_field_IpFrag_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_IpFrag_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_IpFrag_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 24:
        {
            bcm_field_L2Format_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_L2Format_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_L2Format_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 25:
        {
            bcm_if_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_if_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_if_t is int - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 26:
        {
            bcm_gport_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_gport_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_gport_t is int - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 27:
        {
            uint8 s_data;
            rv = ((int (*) (int, bcm_field_entry_t, uint8*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            data[0] |= s_data;
            return rv;
        }
        case 28:
        {
            bcm_vpn_t s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_vpn_t*, bcm_vpn_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            /* bcm_vpn_t is uint16 */
            data[0] |= s_data;
            mask[0] |= s_mask;
            return rv;
        }
        case 29:
        {
            bcm_field_FibreChan_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_FibreChan_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_FibreChan_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 30:
        {
            return BCM_E_UNAVAIL;
            /* will be implemented latter */
            /* return ((int (*) (int, bcm_field_entry_t, uint32, uint32, uint32, uint32)) */
        }
        case 31:
        {
            bcm_field_header_format_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_header_format_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_header_format_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 32:
        {
            bcm_field_header_format_set_t s_data;
            uint32 index;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_header_format_set_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            for(index = 0; index < bcmFieldHeaderFormatCount; ++index) {
                if (BCM_FIELD_HEADER_FORMAT_SET_TEST(s_data, index)) {
                    SHR_BITSET(data, index);
                }
            }
            return rv;
        }
        case 33:
        {
            bcm_rx_trap_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_rx_trap_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_rx_trap_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        case 34:
        {
            uint64 s_data, s_mask;
            rv = ((int (*) (int, bcm_field_entry_t, uint64*, uint64*))qualifiers_info[qual_index].get)(unit, entry, &s_data, &s_mask);
            data[0] = COMPILER_64_LO(s_data);
            data[1] = COMPILER_64_HI(s_data);
            mask[0] = COMPILER_64_LO(s_mask);
            mask[1] = COMPILER_64_HI(s_mask);
            return rv; 
        }
        case 35:
        {
            bcm_field_ArpOpcode_t s_data;
            /* bcm_field_ArpOpcode_t is enumerator - we assume 32 bits*/
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_ArpOpcode_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            data[0] = s_data;
            return rv;
        }
        case 36:
        {
            /* here we take data[0] and mask[0] for data and mask, and data offset base will be in data[1] */
            bcm_field_data_offset_base_t offset_base;
            uint32 s_data, s_mask;
            rv = ((int (*)(int, bcm_field_entry_t, bcm_field_data_offset_base_t*, uint32*, uint32*))qualifiers_info[qual_index].get)(unit, entry, &offset_base, &s_data, &s_mask);
            data[0] = s_data;
            data[1] = offset_base;
            mask[0] = s_mask;
            return rv;
        }
        case 37:
        {
            bcm_field_AppType_t s_data;
            rv = ((int (*) (int, bcm_field_entry_t, bcm_field_AppType_t*))qualifiers_info[qual_index].get)(unit, entry, &s_data);
            /* bcm_field_AppType_t is enumerator - we assume 32 bits*/
            data[0] = s_data;
            return rv;
        }
        default:
            return BCM_E_FAIL;
    }
}

/* Getting adequate value and mask to the qualifier, it should be such that the retrieved value and mask will be the same */
STATIC cmd_result_t _bcm_petra_field_test_get_valid_value_and_mask(int unit,
                                                                   _bcm_dpp_field_stage_idx_t stage,
                                                                   uint32 type,
                                                                   bcm_field_qualify_t qualifier,
                                                                   uint32 x,
                                                                   uint32 *data,
                                                                   uint32 *mask)
{
    uint32 second_rand_param = 0;
    cmd_result_t result;
    int prototype = -1;
    int i, qual_index;
    soc_port_t src_port_number;


    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        const static char *qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Getting valid value and mask for the qualifier %s (%d)\n"), qualifiers_names[qualifier], qualifier));
    }
    if ( get_vaild_local_port(unit,&src_port_number) != SOC_E_NONE ) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }    
    for(qual_index=0; (qualifiers_info[qual_index].qualify != bcmFieldQualifyCount) && (qualifiers_info[qual_index].qualify != BCM_FIELD_ENTRY_INVALID); ++qual_index) {
        if(qualifiers_info[qual_index].qualify == qualifier) {
            prototype = qualifiers_info[qual_index].prototype_id;
            break;
        }
    }

    result = _bcm_petra_field_test_set_qualifiers_info(unit, stage, type);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }

    sal_memset(data, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
    sal_memset(mask, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
    /*
     * The prototypes ids are:
     *  0  int (*) (int, bcm_field_entry_t, bcm_ip6_t, bcm_ip6_t)
     *  1  int (*) (int, bcm_field_entry_t, bcm_mac_t, bcm_mac_t)
     *  2  int (*) (int, bcm_field_entry_t, bcm_field_snap_header_t, bcm_field_snap_header_t)
     *  3  int (*) (int, bcm_field_entry_t, bcm_ip_t, bcm_ip_t)
     *  4  int (*) (int, bcm_field_entry_t, bcm_field_llc_header_t, bcm_field_llc_header_t)
     *  5  int (*) (int, bcm_field_entry_t, bcm_port_t, bcm_port_t)
     *  6  int (*) (int, bcm_field_entry_t, bcm_pbmp_t, bcm_pbmp_t)
     *  7  int (*) (int, bcm_field_entry_t, uint8, uint8)
     *  8  int (*) (int, bcm_field_entry_t, uint32, uint32)
     *  9  int (*) (int, bcm_field_entry_t, bcm_vlan_t, bcm_vlan_t)
     * 10  int (*) (int, bcm_field_entry_t, bcm_field_range_t, int)
     * 11  int (*) (int, bcm_field_entry_t, bcm_l4_port_t, bcm_l4_port_t)
     * 12  int (*) (int, bcm_field_entry_t, uint16, uint16)
     * 13  int (*) (int, bcm_field_entry_t, bcm_module_t, bcm_module_t, bcm_port_t, bcm_port_t)
     * 14  int (*) (int, bcm_field_entry_t, bcm_trunk_t, bcm_trunk_t)
     * 15  int (*) (int, bcm_field_entry_t, bcm_field_IpProtocolCommon_t)
     * 16  int (*) (int, bcm_field_entry_t, uint16)
     * 17  int (*) (int, bcm_field_entry_t, bcm_field_IpType_t)
     * 18  int (*) (int, bcm_field_entry_t, bcm_field_TunnelType_t)
     * 19  int (*) (int, bcm_field_entry_t, bcm_field_LoopbackType_t)
     * 20  int (*) (int, bcm_field_entry_t, bcm_field_ForwardingType_t)
     * 21  int (*) (int, bcm_field_entry_t, bcm_field_stage_t)
     * 22  int (*) (int, bcm_field_entry_t, uint32)
     * 23  int (*) (int, bcm_field_entry_t, bcm_field_IpFrag_t)
     * 24  int (*) (int, bcm_field_entry_t, bcm_field_L2Format_t)
     * 25  int (*) (int, bcm_field_entry_t, bcm_if_t)
     * 26  int (*) (int, bcm_field_entry_t, bcm_gport_t)
     * 27  int (*) (int, bcm_field_entry_t, uint8)
     * 28  int (*) (int, bcm_field_entry_t, bcm_vpn_t, bcm_vpn_t)
     * 29  int (*) (int, bcm_field_entry_t, bcm_field_FibreChan_t)
     * 30  int (*) (int, bcm_field_entry_t, uint32, uint32, uint32, uint32)
     * 31  int (*) (int, bcm_field_entry_t, bcm_field_header_format_t)
     * 32  int (*) (int, bcm_field_entry_t, bcm_field_header_format_set_t)
     * 33  int (*) (int, bcm_field_entry_t, bcm_rx_trap_t)
     * 34  int (*) (int, bcm_field_entry_t, uint64, uint64)
     * 35  int (*) (int, bcm_field_entry_t, bcm_field_ArpOpcode_t)
     * 36  int (*) (int, bcm_field_entry_t, bcm_field_data_offset_base_t, uint32, uint32)
     * 37  int (*) (int, bcm_field_entry_t, bcm_field_AppType_t)
     */

    /* enumerators */
    if(prototype == 15) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_IP_PROTOCOL_COMMON_INGRESS;
            data[0] = supported_IpProtocolCommon_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_IP_PROTOCOL_COMMON_EGRESS;
            data[0] = supported_IpProtocolCommon_Egress[i];
        }
    } else if(prototype == 17) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_IP_TYPE_INGRESS;
            data[0] = supported_IpType_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_IP_TYPE_EGRESS;
            data[0] = supported_IpType_Egress[i];
        }        
    } else if(prototype == 18) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_TUNNEL_TYPE_INGRESS;
            data[0] = supported_TunnelType_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_TUNNEL_TYPE_EGRESS;
            data[0] = supported_TunnelType_Egress[i];
        }
    } else if(prototype == 19) {
        /* Do nothing we don't support it */
    } else if(prototype == 20) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_FORWARDING_TYPE_INGRESS;
            data[0] = supported_ForwardingType_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_FORWARDING_TYPE_EGRESS;
            data[0] = supported_ForwardingType_Egress[i];
        }
    } else if(prototype == 21) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_STAGE_INGRESS;
            data[0] = supported_stage_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_STAGE_EGRESS;
            data[0] = supported_stage_Egress[i];
        }
    } else if(prototype == 23) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (SOC_IS_JERICHO(unit) ? NOF_SUPPORTED_JER_IP_FRAG_INGRESS : NOF_SUPPORTED_IP_FRAG_INGRESS);
            data[0] = ( SOC_IS_JERICHO(unit) && (soc_property_get(unit, spn_FIELD_IP_FIRST_FRAGMENT_PARSED, TRUE)))  ? supported_Jer_IpFrag_Ingress[i] : supported_IpFrag_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_IP_FRAG_EGRESS;
            data[0] = supported_IpFrag_Egress[i];
        }
    } else if(prototype == 24) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_L2_FORMAT_INGRESS;
            data[0] = supported_L2Format_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                NOF_SUPPORTED_L2_FORMAT_EGRESS;
            data[0] = supported_L2Format_Egress[i];
        }
    } else if(prototype == 29) {
        /* Do nothing we don't support it */
    } else if(prototype == 31) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (sizeof(supported_header_format_Ingress)/sizeof(bcm_field_header_format_t));
            data[0] = supported_header_format_Ingress[i];
        } else {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (sizeof(supported_header_format_Egress)/sizeof(bcm_field_L2Format_t));
            data[0] = supported_header_format_Egress[i];
        }
    } else if(prototype == 33) {
        static uint8 is_set = 0;
        static _bcm_dpp_field_stage_idx_t cur_stage;
        static bcm_rx_trap_t supported[bcmRxTrapCount];
        static uint32 supported_count;
        int soc_ppd_trap_id;
                
        if(!is_set || cur_stage != stage) {
            supported_count = 0;
            for(i=0; i < bcmRxTrapCount; ++i) {
                _bcm_dpp_rx_ppd_trap_get(unit, i, &soc_ppd_trap_id);
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                    || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    if(soc_ppd_trap_id && 
                        ((soc_ppd_trap_id & 0x20000000) == 0) /* i.e it is not egress trap code */) {
                        supported[supported_count++] = i;
                    }
                } else {
                    if(soc_ppd_trap_id & 0x20000000/* This is the flag indicating that this is egress trap code */) {
                        supported[supported_count++] = i;
                    }
                }
            }
            is_set = TRUE;
            cur_stage = stage;
        }
        if(supported_count == 0) {
            LOG_INFO(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "Not supported rx trap\n")));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        data[0] = supported[_bcm_petra_field_rand_val(x, second_rand_param++) % supported_count];
        
    } else if(prototype == 35) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (sizeof(supported_ArpOpcode_Ingress)/sizeof(bcm_field_ArpOpcode_t));
            data[0] = supported_ArpOpcode_Ingress[i];
        }
    } else if(prototype == 36) {
        /* data[0] and mask[0] will have  the data and mask.
          data[1] will have the bae offset */
        const bcm_field_data_offset_base_t *valid_offset_bases;
        int valid_offset_bases_size;
        
        supported_data_offset_base(FALSE, FALSE, &valid_offset_bases, &valid_offset_bases_size);
        i = _bcm_petra_field_rand_val(x, second_rand_param++) % valid_offset_bases_size;
        data[1] = valid_offset_bases[i];
        data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x80;
        mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x80;
        data[0] &= mask[0];
    } else if(prototype == 37) {
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
            || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (sizeof(supported_AppType_Ingress)/sizeof(bcm_field_AppType_t));
            data[0] = supported_AppType_Ingress[i];
        }
    } else if (prototype == 5) {
        data[0] = src_port_number;
        mask[0] = 0xFFFFFFFF;
    } else if (prototype == 6) {
        /* port bit map */
    } else if(prototype == 26) {
        /* gport */
    } else {
        if(qualifier == bcmFieldQualifyPacketRes) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                data[0] = BCM_FIELD_PKT_RES_BPDU;
                mask[0] = 0x1f;
            } else {
                data[0] = BCM_FIELD_PKT_RES_UNKNOWN;
                mask[0] = 0x1f;
            }
        } else if(qualifier == bcmFieldQualifyIngressStpState) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(i == 0) {
                data[0] = 0;
                mask[0] = 0;
            } else {
                i = _bcm_petra_field_rand_val(x, second_rand_param++) % 3;
                if(i == 0) {
                    data[0] = BCM_STG_STP_BLOCK;
                } else if(i == 1) {
                    data[0] = BCM_STG_STP_LEARN;
                } else {
                    data[0] = BCM_STG_STP_FORWARD;
                }
                mask[0] = 0x7;
            }
        } else if(qualifier == bcmFieldQualifyDstL3Egress) {
            BCM_L3_ITF_SET(data[0], BCM_L3_ITF_TYPE_FEC, 0);
        } else if (qualifier == bcmFieldQualifyColor) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            if (i == 0) {
                data[0] = BCM_FIELD_COLOR_GREEN;
            } else if(i == 1) {
                data[0] = BCM_FIELD_COLOR_YELLOW;
            } else if(i == 2) {
                data[0] = BCM_FIELD_COLOR_RED;
            } else {
                data[0] = BCM_FIELD_COLOR_BLACK;
            }
        } else if(qualifier == bcmFieldQualifyVlanFormat && ( stage != _BCM_DPP_FIELD_STAGE_INDEX_EGRESS && SOC_DPP_IS_VLAN_TRANSLATE_MODE_NORMAL(unit)) ) {
            /* in these cases the mask should be all 0 or all 1. In the Egress - it is a regular qualifier */
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(i == 0) {
                data[0] = 0;
                mask[0] = 0;
            } else {
                i = _bcm_petra_field_rand_val(x, second_rand_param++) % 5;
                if(i == 0) {
                    data[0] = 0;
                } else if(i == 1) {
                    data[0] = BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED;
                } else if (i == 2) {
                    data[0] = BCM_FIELD_VLAN_FORMAT_INNER_TAGGED | BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED;
                } else if(i == 3) {
                    data[0] = BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED_VID_ZERO;
                } else {
                    data[0] = BCM_FIELD_VLAN_FORMAT_INNER_TAGGED | BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED_VID_ZERO;
                }
                mask[0] = 0xF;
            }
        } else if (qualifier == bcmFieldQualifyEcnValue) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(i == 0) {
                data[0] = 0;
                mask[0] = 0;
            } else {
                data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 3;
                /* the data may be 0, 1, or 3. not 2.
                   In Egress it also can't be 0. */
                if(data[0] == 2) {
                    ++(data[0]);
                }
                if(data[0] == 0 && stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
                    ++(data[0]);
                }
                i = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
                if(i == 0) {
                    mask[0] = 0;
                } else {
                    mask[0] = 0x3;
                }
            }
        } else if (qualifier == bcmFieldQualifyInnerTpid) {
            data[0] = 0x8100;
        } else if (qualifier == bcmFieldQualifyOuterTpid) {
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(i == 0) {
                data[0] = 0x8100;
            } else {
                data[0] = 0x9100;
            }
            /* The data may be changed, because if there is single valn it may be 0x8100,
             * and in there is inner vlan also it may be 0x9100 */
        } else if(qualifier == bcmFieldQualifyEtherType || qualifier == bcmFieldQualifyInnerEtherType) {
            do {
                /* The data can't be 0x5dc or below because it will not be translated as ethertype */
                data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % (0x10000 - 0x5dd);
                data[0] += 0x5dd;
                
                mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
                data[0] &= mask[0];
            }
            /* in all if this case the ethertype will be identified as vlan and not ethertype */
            while(data[0] == 0x8100
                || data[0] == 0x88a8
                || data[0] == 0x9100
                || data[0] == 0x9200
                || data[0] == 0x9300
                || data[0] < 0x5dd);
            /* in case that we use ipv4 ipv6 or mpls headers the value and mask may be changed */
        } else if(qualifier == bcmFieldQualifyISid || qualifier == bcmFieldQualifyTrillEgressRbridge) {
            /* This qualifiers' relevant size is 16 although it is 24 */
            data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
            mask[0] = (_bcm_petra_field_rand_val(x, second_rand_param++) % (0x10000 - 1)) + 1;/* the mast can't be 0 */
            data[0] &= mask[0];
        } else if(qualifier == bcmFieldQualifyDrop) {
            /* data is 0 and mask is 0, or data is 1 and mask is 1 */
            data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            mask[0] = data[0];
        } else if(qualifier == bcmFieldQualifyL2Learn) {
            data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            data[0] &= mask[0];
        } else if(qualifier == bcmFieldQualifyFlowId) {
            /* This qualifier's relevant size is 16 although it is 19 */
            data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
            mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
            data[0] &= mask[0];
        } else if(qualifier == bcmFieldQualifyIpInfo) {
            /* It has only two flags */
            uint8 tmp_data = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            uint8 tmp_mask = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            tmp_data &= tmp_mask;
            data[0] = 0;
            mask[0] = 0;
            if((tmp_data & 0x1) 
                && (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                    || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) ) {
                data[0] |= BCM_FIELD_IP_CHECKSUM_OK;
            }
            if(tmp_data & 0x2) {
                data[0] |= BCM_FIELD_IP_VERSION_ERR;
            }
            if((tmp_data & 0x1) 
                && (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                    || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) ) {
                mask[0] |= BCM_FIELD_IP_CHECKSUM_OK;
            }
            if(tmp_mask & 0x2) {
                mask[0] |= BCM_FIELD_IP_VERSION_ERR;
            }
        } else if(qualifier == bcmFieldQualifyDstMac) {
            /* we don't want that data == 0 && mask == 1 */
            do {
                data[0] = _bcm_petra_field_rand_val(x, second_rand_param++);
                mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++);
                data[0] &= mask[0];
                data[1] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
                mask[1] = _bcm_petra_field_rand_val(x, second_rand_param++) % 0x10000;
                data[1] &= mask[1];
            } while (data[0] == 0 && mask[0] == 0xffffffff && data[1] == 0 && mask[1] == 0xffff);
        } else if(qualifier == bcmFieldQualifyForwardCopy ||
                  qualifier == bcmFieldQualifyMirrorCopy ||
                  qualifier == bcmFieldQualifySnoopCopy ) {
            /* In all these cases the data and mask can be 0 or 1 only  */
            data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            mask[0] = data[0];
        } else if(qualifier == bcmFieldQualifyFheiSize) {
            /* The data can be one of 0,3,5,8 ; The mask can be 0x0 or 0x3 only */
            i = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            if(i == 0) {
                data[0] = 0;
            } else if(i == 1) {
                data[0] = 3;
            } else if (i == 2) {
                data[0] = 5;
            } else if(i == 3) {
                data[0] = 8;
            }
            mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(mask[0] == 1) {
                mask[0] = -1;
            } 
            data[0] &= mask[0];
        } else if(qualifier == bcmFieldQualifyInterfaceClassVPort) {
            mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
        } else {
            if(qualifiers_info[qual_index].size == 0) {
                if(qualifier == bcmFieldQualifyDstPort) {
                /* in this case the size is 0, however nothing should be done */
                    return CMD_OK;
                }
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "The qualifier %d is not supported \n"), qualifier));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }

            /* value */
            for(i = 0; i < qualifiers_info[qual_index].size; i+=32) {
                if(qualifiers_info[qual_index].size - i >= 32) {
                    data[i/32] = _bcm_petra_field_rand_val(x, second_rand_param++);
                } else {
                    data[i/32] = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (qualifiers_info[qual_index].size - i));
                }
            }
            /* mask if needed */
            if((prototype  >= 0 && prototype <=9) || prototype == 11 || prototype == 12 || prototype == 14 || prototype == 27 || prototype == 28 || prototype == 34) {
                for(i = 0; i < qualifiers_info[qual_index].size; i+=32) {
                    if(qualifiers_info[qual_index].size - i >= 32) {
                        mask[i/32] = _bcm_petra_field_rand_val(x, second_rand_param++);
                    } else {
                        mask[i/32] = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (qualifiers_info[qual_index].size - i));
                    }
                    data[i/32] &= mask[i/32];
                }
            }
        }
    }
    return CMD_OK;
}

/*
 * taking the speed mode and returns the number of iterations.
 */
STATIC int _bcm_petra_field_test_speed_mode_to_iterations_number(_bcmPetraFieldTestSpeedMode mode, uint8 slow_level, uint32 *nof_iterations)
{
    switch(mode) {
    case _bcmPetraFieldTestSuperFast:
        _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SUPER_FAST(slow_level, *nof_iterations);
        break;
    case _bcmPetraFieldTestFast:
        _BCM_PETRA_FIELD_TEST_NOF_ITERATION_FAST(slow_level, *nof_iterations);
        break;
    case _bcmPetraFieldTestMedium:
        _BCM_PETRA_FIELD_TEST_NOF_ITERATION_MEDIUM(slow_level, *nof_iterations);
        break;
    case _bcmPetraFieldTestSlow:
        _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SLOW(slow_level, *nof_iterations);
        break;
    case _bcmPetraFieldTestScan:
        *nof_iterations = _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN;
        break;
    default:
        return 1;
    }
    return 0;
}

/*
 * This function get empty set, 
 * fills it with max_items items and return vector of the selected items
 */
STATIC uint32* _bcm_petra_field_create_set(
    void *set,
    void (add_function)(void *set, uint32 item),
    uint8 (test_function)(void *set, uint32 item),
    int nof_items,
    void *valid_items_set,
    uint32 max_items,
    uint32 x
    )
{
    uint32 second_rand_param = 0;
    uint32 *items;
    uint32 *valid_items = NULL;
    uint32 item_idx, index;
    uint32 item;
    uint32 nof_valid_items = 0;
    int unit = BSL_UNIT_UNKNOWN;

    /* Taking max_items items */
    items = sal_alloc(max_items*sizeof(uint32), "_bcm_petra_field_create_set.items");
    if(!items) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META("Allocation failure \n")));
        }
        return NULL;
    }

    /* counting the number of the valid items. if it smaller or equal to max_items, take all of them */
    for(item = 0; item < nof_items; ++item) {
        if(test_function(valid_items_set, item)) {
            ++nof_valid_items;
        }
    }
    
    if(nof_valid_items <= max_items) {
        item_idx = 0;
        for(item = 0; item < nof_items; ++item) {
            if(test_function(valid_items_set, item)) {
                items[item_idx++] = item;
                add_function(set, item);
            }
        }
        for(item = nof_valid_items; item < max_items; ++item) {
            items[item_idx++] = 0xffffffff; /* invalid item */
        }
        return items;
    }

    valid_items = sal_alloc(nof_valid_items*sizeof(uint32), "_bcm_petra_field_create_set.valid_items");
    if(!valid_items) {
        sal_free(items);
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META("Allocation failure \n")));
        }
        return NULL;
    }
    
    item_idx = 0;
    for(item = 0; item < nof_items; ++item) {
        if(test_function(valid_items_set, item)) {
            valid_items[item_idx++] = item;
        }
    }
    
    /* The idea is to take randomly one of the items in valid_items[0 ... nof_valid_items -item_idx],
      Then take the item in the end of valid_items and put it in the index of this item such that in each iteration
      valid_items[0 ... nof_valid_items -item_idx] contain the items that haven't been selected */
    for(item_idx = 0; item_idx < max_items; ++item_idx) {
        index = _bcm_petra_field_rand_val(x, second_rand_param++)%(nof_valid_items - item_idx);
        item = valid_items[index];
        valid_items[index] = valid_items[nof_valid_items - item_idx - 1];
        items[item_idx] = item;
        add_function(set, item);
    }
    sal_free(valid_items);

    return items;
}

/*
 * This function takes max_items items 
 * add set them to empty set (such as qualifiers set actions set etc.) 
 * Then it takes randomly _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST and check if they are in the set.
 * Then it removes all the items from the set. 
 * Then it verify that no item is in the qse for _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST items 
 * return 0 in success and 1 in failure 
 */
STATIC uint8 _bcm_petra_field_add_and_remove_test(
    void *(init_function)(void),
    void (add_function)(void *set, uint32 item),
    void (remove_function)(void *set, uint32 item),
    uint8 (test_function)(void *set, uint32 item),
    void (print_function)(const void *set),
    const char **items_name,
    int nof_items,
    void *valid_items_set,
    uint32 max_items,
    uint32 x
    )
{
    uint32 second_rand_param = 0;
    uint32 *items;
    int item_idx, item_idx_2;
    int item;
    uint8 is_in_list;
    uint8 test_res;
    void *set;
    int unit = BSL_UNIT_UNKNOWN;

    /* Creating set*/
    set = init_function();
    if(!set) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Allocation failure \n")));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }

    /* Selecting items */
    items = _bcm_petra_field_create_set(set, add_function, test_function, nof_items, valid_items_set, max_items, x);
    if(!items) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }

    /* Printing the list */
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VVERB) {
        print_function(set);
    }

    /* Testing */
    for(item_idx = 0; item_idx < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++item_idx) {
        item = _bcm_petra_field_rand_val(x, second_rand_param++) % nof_items;
        test_res = test_function(set, item);
        is_in_list = FALSE;
        for(item_idx_2 = 0; item_idx_2 < max_items; ++item_idx_2) {
            if(items[item_idx_2] == item) {
                is_in_list = TRUE;
                break;
            }
        }
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            if(test_res && is_in_list) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "%s is in the list and the test function returned true - OK\n"), items_name[item]));
            } else if(!test_res && !is_in_list) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "%s is in not the list and the test function returned false - OK\n"), items_name[item]));
            }else if(test_res) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FAILURE: %s is in not the list and the test function returned true\n"), items_name[item]));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
                sal_free(items);
                sal_free(set);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return 1;
            } else {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FAILURE: %s is in the list and the test function returned false\n"), items_name[item]));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
                sal_free(items);
                sal_free(set);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return 1;
            }
        }
    }
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "end\n\n")));
    }

    /* Remove all the items */
    for(item_idx = 0; item_idx < max_items; ++item_idx) {
        if(items[item_idx] == 0xffffffff) {
        /* i.e. All the valid items have been taken and the other marked as invalid */
            break;
        }
        remove_function(set, items[item_idx]);
    }
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "All the items removed\n")));
    }

    /* Verifying that there is no items */
    for(item_idx = 0; item_idx < max_items; ++item_idx) {
        if(items[item_idx] != 0xffffffff && test_function(set, items[item_idx])) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FAILURE: %s is in not the list and the test function returned true\n"), items_name[items[item_idx]]));
            }
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            sal_free(items);
            sal_free(set);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
        }
    }

    sal_free(items);
    sal_free(set);
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The add and remove test finished successfully\n\n")));
    return 0;
}

/*
 * This function takes one item 
 * add set it to empty set (such as qualifiers set actions set etc.) 
 * Then it takes randomly _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST and check if they are in the set.
 * Then it removes this item from the set. 
 * Then it verify that the set is empty 
 * return 0 in success and 1 in failure 
 */
STATIC uint8 _bcm_petra_field_add_and_remove_scan_test(
    void *(init_function)(void),
    void (add_function)(void *set, uint32 item),
    void (remove_function)(void *set, uint32 item),
    uint8 (test_function)(void *set, uint32 item),
    void (print_function)(const void *set),
    const char **items_name,
    int nof_items
    )
{
    int item_idx;
    uint32 cur_item;
    int item;
    uint8 test_res;
    void *set;
    uint8 failure = FALSE;
    int unit = BSL_UNIT_UNKNOWN;

    /* Creating set*/
    set = init_function();
    if(!set) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Allocation failure \n")));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }

    for(cur_item = 0; cur_item < nof_items; ++cur_item) {
        add_function(set, cur_item);

        /* Printing the list */
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VVERB) {
            print_function(set);
        }

        /* Testing */
        for(item_idx = 0; item_idx < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++item_idx) {
            item = sal_rand() % nof_items;
            test_res = test_function(set, item);
            if(test_res && item == cur_item) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "%s is in the list and the test function returned true - OK\n"), items_name[item]));
                }
            } else if(!test_res && item != cur_item) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "%s is in not the list and the test function returned false - OK\n"), items_name[item]));
                }
            }else if(test_res) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "FAILURE: %s is in not the list and the test function returned true\n"), items_name[item]));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    failure = TRUE;
                }
            } else {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "FAILURE: %s is in the list and the test function returned false\n"), items_name[item]));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    failure = TRUE;
                }
            }
        }
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "end\n\n")));
        }

        /* Remove the item */
        remove_function(set, cur_item);

        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "All the items removed\n")));
        }

        /* Verifying that there is no item */
        if(test_function(set, cur_item)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FAILURE: %s is in not the list and the test function returned true\n"), items_name[cur_item]));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            failure = TRUE;
        }
    }

    sal_free(set);
    if(!failure){
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The add and remove test finished successfully\n\n")));
    }
    return failure;
}

/*
 * The function gets the set of valid qualifiers and actions for specific type selected randomly
 * Return 0 in success, 1 in failure 
 * if type is 0 then type will be chosen randomly, otherwise it will take the required type
 */
uint8 _bcm_petra_field_test_qualify_and_action_get_valid_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, int type, bcm_field_qset_t *valid_qset, bcm_field_aset_t *valid_aset)
{
    uint32 second_rand_param=0;
    bcm_field_qset_t valid_qset_get;
    bcm_field_aset_t valid_aset_get;
    bcm_error_t rv;

    if(type == 0) {
        type = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_NOF_TYPES;
    }

    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, stage, type, &valid_qset_get, &valid_aset_get);
    if(rv) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(valid_aset) {
        *valid_aset = valid_aset_get;
    }
    if(valid_qset) {
        *valid_qset = valid_qset_get;
    }
    return 0;
}

uint8 _bcm_petra_field_test_qualify_get_valid_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, bcm_field_qset_t *valid_set)
{
    return _bcm_petra_field_test_qualify_and_action_get_valid_set(unit, stage, x, 0, valid_set, NULL);
}

STATIC void* _bcm_petra_field_test_qualify_set_init(void)
{
    bcm_field_qset_t *init = sal_alloc(sizeof(bcm_field_qset_t), 0);
    BCM_FIELD_QSET_INIT(*init);
    return init;
}
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
/*******************************************************************************/
STATIC void _bcm_petra_field_test_qualify_set_add(bcm_field_qset_t *set, uint32 item)
{
    BCM_FIELD_QSET_ADD(*set, item);
}

STATIC void _bcm_petra_field_test_qualify_set_remove(bcm_field_qset_t *set, uint32 item)
{
    BCM_FIELD_QSET_REMOVE(*set, item);
}

STATIC uint8 _bcm_petra_field_test_qualify_set_test(bcm_field_qset_t *set, uint32 item)
{
    return (BCM_FIELD_QSET_TEST(*set, item) != 0);
}

STATIC void _bcm_petra_field_qualify_set_print(const bcm_field_qset_t *qset)
{
#ifdef BROADCOM_DEBUG
    LOG_CLI((BSL_META("Printing the qualifiers in the set:\n")));
    _bcm_dpp_field_qset_dump(*qset, "bcmFieldQualify");
    LOG_CLI((BSL_META("--- The end of the set ---\n\n")));
#endif /* BROADCOM_DEBUG */
}

cmd_result_t _bcm_petra_field_test_qualify_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    const static char *item_names[] = BCM_FIELD_QUALIFY_STRINGS;

    bcm_field_qset_t valid_set;
    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove for qualify set\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : qset, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));
    
    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_add_and_remove_scan_test(
            (void* (*)(void)) _bcm_petra_field_test_qualify_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
            (void (*)(const void*)) _bcm_petra_field_qualify_set_print,
            item_names,
            bcmFieldQualifyCount);
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
        }
        if(_bcm_petra_field_test_qualify_get_valid_set(unit, stage, x, &valid_set)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Getting the valid items set failed\n")));
            }
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(_bcm_petra_field_add_and_remove_test(
            (void* (*)(void)) _bcm_petra_field_test_qualify_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
            (void (*)(const void*)) _bcm_petra_field_qualify_set_print,
            item_names,
            bcmFieldQualifyCount,
            &valid_set,
            16,
            x) ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    return CMD_OK;
}

uint8 _bcm_petra_field_test_action_get_valid_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, bcm_field_aset_t *valid_set)
{
    return _bcm_petra_field_test_qualify_and_action_get_valid_set(unit, stage, x, 0, NULL, valid_set);
}

STATIC void* _bcm_petra_field_test_action_set_init(void)
{
    bcm_field_aset_t *init = sal_alloc(sizeof(bcm_field_aset_t), 0);
    BCM_FIELD_ASET_INIT(*init);
    return init;
}

STATIC void _bcm_petra_field_test_action_set_add(bcm_field_aset_t *set, uint32 item)
{
    BCM_FIELD_ASET_ADD(*set, item);
}

STATIC void _bcm_petra_field_test_action_set_remove(bcm_field_aset_t *set, uint32 item)
{
    BCM_FIELD_ASET_REMOVE(*set, item);
}

STATIC uint8 _bcm_petra_field_test_action_set_test(bcm_field_aset_t *set, uint32 item)
{
    return (BCM_FIELD_ASET_TEST(*set, item) != 0);
}

STATIC void _bcm_petra_field_action_set_print(const bcm_field_aset_t *aset)
{
#ifdef BROADCOM_DEBUG
    LOG_CLI((BSL_META("Printing the actions in the set:\n")));
    _bcm_dpp_field_aset_dump(*aset, "bcmFieldAction");
    LOG_CLI((BSL_META("--- The end of the set ---\n\n")));
#endif
}

cmd_result_t _bcm_petra_field_test_action_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    const static char *item_names[] = BCM_FIELD_ACTION_STRINGS;

    bcm_field_aset_t valid_set;
    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove for action set\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : aset, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_add_and_remove_scan_test(
            (void* (*)(void)) _bcm_petra_field_test_action_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_action_set_test,
            (void (*)(const void*)) _bcm_petra_field_action_set_print,
            item_names,
            bcmFieldActionCount);
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
        }
        if(_bcm_petra_field_test_action_get_valid_set(unit, stage, x, &valid_set)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Getting the valid items set failed\n")));
            }
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(_bcm_petra_field_add_and_remove_test(
            (void* (*)(void)) _bcm_petra_field_test_action_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_action_set_test,
            (void (*)(const void*)) _bcm_petra_field_action_set_print,
            item_names,
            bcmFieldActionCount,
            &valid_set,
            8,
            x) ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    return CMD_OK;
}

uint8 _bcm_petra_field_test_data_qualifier_get_valid_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, bcm_field_qset_t *valid_set)
{
    uint32 data_qual_id;
    bcm_error_t rv;
    
    BCM_FIELD_QSET_INIT(*valid_set);
    for(data_qual_id = 0; data_qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++data_qual_id) {
        rv = bcm_field_qset_data_qualifier_add(unit, valid_set, data_qual_id);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
        }
    }
    
    return 0;
}

STATIC void* _bcm_petra_field_test_data_qualifier_set_init(void)
{
    bcm_field_qset_t *init = sal_alloc(sizeof(bcm_field_qset_t), 0);
    BCM_FIELD_QSET_INIT(*init);
    return init;
}

static int data_qualifier_add_remove_test_unit;

STATIC void _bcm_petra_field_test_data_qualifier_set_add(bcm_field_qset_t *set, uint32 item)
{
    bcm_error_t rv;
    rv = bcm_field_qset_data_qualifier_add(data_qualifier_add_remove_test_unit, set, item);
    if(rv != BCM_E_NONE) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META("Failure in bcm_field_qset_data_qualifier_add\n")));
    }
}

STATIC void _bcm_petra_field_test_data_qualifier_set_remove(bcm_field_qset_t *set, uint32 item)
{
    bcm_error_t rv;
    rv = bcm_field_qset_data_qualifier_delete(data_qualifier_add_remove_test_unit, set, item);
    if(rv != BCM_E_NONE) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META("Failure in bcm_field_qset_data_qualifier_delete\n")));
    }
}

STATIC uint8 _bcm_petra_field_test_data_qualifier_set_test(bcm_field_qset_t *set, uint32 item)
{
    int qual_arr[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(data_qualifier_add_remove_test_unit) + 1];
    int qual_count;
    int qual_idx;
    bcm_error_t rv;
    
    rv = bcm_field_qset_data_qualifier_get(data_qualifier_add_remove_test_unit,
                                           *set,
                                           _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(data_qualifier_add_remove_test_unit) + 1,
                                           qual_arr,
                                           &qual_count);
    if(rv != BCM_E_NONE) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META("Failure in bcm_field_qset_data_qualifier_get\n")));
    }
    for(qual_idx = 0; qual_idx < qual_count; ++qual_idx) {
        if(qual_arr[qual_idx] == item) {
            return 1;
        }
    }                        
    return 0;
}

STATIC void _bcm_petra_field_data_qualifier_set_print(const bcm_field_qset_t *qset)
{
#ifdef BROADCOM_DEBUG
    int qual_arr[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(data_qualifier_add_remove_test_unit) + 1];
    int qual_count;
    int qual_idx;
    bcm_error_t rv;
    bcm_field_qset_t lcl_qset;
    int unit = BSL_UNIT_UNKNOWN;
    
    sal_memcpy(&lcl_qset, qset, sizeof(bcm_field_qset_t));

    LOG_CLI((BSL_META_U(unit,
                        "Printing the presel ids in the set:\n")));
    rv = bcm_field_qset_data_qualifier_get(data_qualifier_add_remove_test_unit,
                                           lcl_qset,
                                           _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(data_qualifier_add_remove_test_unit) + 1,
                                           qual_arr,
                                           &qual_count);
    if(rv != BCM_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "Failure in bcm_field_qset_data_qualifier_get\n")));
    }
    for(qual_idx = 0; qual_idx < qual_count; ++qual_idx) {
        LOG_CLI((BSL_META_U(unit,
                            "%d "), qual_arr[qual_idx]));
    }                        

    LOG_CLI((BSL_META_U(unit,
                        "\n")));
    LOG_CLI((BSL_META_U(unit,
                        "--- The end of the set ---\n\n")));
#endif /* BROADCOM_DEBUG */
}

cmd_result_t _bcm_petra_field_test_data_qualifier_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    const static char *item_names[] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
        "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
        "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
        "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
        "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
        "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
        "60", "61", "62", "63"};

    bcm_field_qset_t valid_set;
    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove for data qualifier set\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : data_qualifier_set, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_add_and_remove_scan_test(
            (void* (*)(void)) _bcm_petra_field_test_data_qualifier_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_test,
            (void (*)(const void*)) _bcm_petra_field_data_qualifier_set_print,
            item_names,
            _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1);
    }

    data_qualifier_add_remove_test_unit = unit;
    
    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
        }
        if(_bcm_petra_field_test_data_qualifier_get_valid_set(unit, stage, x, &valid_set)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Getting the valid items set failed\n")));
            }
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(_bcm_petra_field_add_and_remove_test(
            (void* (*)(void)) _bcm_petra_field_test_data_qualifier_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_test,
            (void (*)(const void*)) _bcm_petra_field_data_qualifier_set_print,
            item_names,
            _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1,
            &valid_set,
            8,
            x) ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    return CMD_OK;
}

STATIC bcm_error_t _bcm_petra_field_test_qualifier_is_lsb_is_msb(int unit,
                                                                 bcm_field_qualify_t qualifier,
                                                                 uint8 *is_lsb,
                                                                 uint8 *is_msb)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_QUAL_TYPE *soc_ppd_qual_ptr;
    uint8 is_lsb_lcl[_BCM_PETRA_FIELD_QUAL_CHAIN], is_msb_lcl[_BCM_PETRA_FIELD_QUAL_CHAIN];
    bcm_error_t rv;
    uint32 ppd_qual_idx;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, 0xff, qualifier, &soc_ppd_qual_ptr);
    BCM_IF_ERROR_RETURN(rv);

    for(ppd_qual_idx = 0; ppd_qual_idx < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx) {
        uint32 soc_sand_res;
        ARAD_PMF_CE_IRPP_QUALIFIER_INFO     junk;
        soc_sand_res = arad_pmf_ce_internal_field_info_find(unit,
                                                            soc_ppd_qual_ptr[ppd_qual_idx],
                                                            _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                            FALSE,
                                                            &is_lsb_lcl[ppd_qual_idx],
                                                            &junk);
        SOC_SAND_IF_ERR_EXIT(soc_sand_res);
        soc_sand_res = arad_pmf_ce_internal_field_info_find(unit,
                                                            soc_ppd_qual_ptr[ppd_qual_idx],
                                                            _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                            TRUE,
                                                            &is_msb_lcl[ppd_qual_idx],
                                                            &junk);
        SOC_SAND_IF_ERR_EXIT(soc_sand_res);
        if(!is_lsb_lcl[ppd_qual_idx] && !is_msb_lcl[ppd_qual_idx]) {
            is_lsb_lcl[ppd_qual_idx] = TRUE;
            is_msb_lcl[ppd_qual_idx] = TRUE;
        }
    }
    if(is_lsb) {
        *is_lsb = TRUE;
    }
    if(is_msb) {
        *is_msb = TRUE;
    }
    
    for(ppd_qual_idx = 0; ppd_qual_idx < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx) {
        if(!is_lsb_lcl[ppd_qual_idx]) {
            if(is_lsb) {
                *is_lsb = FALSE;
            }
        }
        if(!is_msb_lcl[ppd_qual_idx]) {
            if(is_msb) {
                *is_msb = FALSE;
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* Available resources for single program */
STATIC uint32 lsb_ces;
STATIC uint32 msb_ces;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
STATIC uint32 total_nof_ces;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
STATIC uint32 nof_actions;

/* Available resources for single field group */
STATIC uint32 lsb_qualifiers_available_length;
STATIC uint32 msb_qualifiers_available_length;

/* function for verifying available resources 
 *
 * _bcm_petra_field_test_reset_resources - reset the available resources
 * 
 * _bcm_petra_field_test_reset_field_group_resources - reset the available resources for single field group
 * 
 * _bcm_petra_field_test_take_qualifier - check that we can add qualifier to field group without copy engines overflow
 *
 * _bcm_petra_field_test_take_action - verify that we can have another action without overflow the maximal actions
 */
STATIC void _bcm_petra_field_test_reset_resources(void)
{
    lsb_ces = 16;
    msb_ces = 16;
    nof_actions = 32;
}

STATIC void _bcm_petra_field_test_reset_field_group_resources(uint32 maximal_key_length){
    lsb_qualifiers_available_length = maximal_key_length;
    msb_qualifiers_available_length = maximal_key_length;
}

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
STATIC void _bcm_petra_field_test_kbp_reset_resources(void)
{
    total_nof_ces = 4;
}
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

STATIC uint8 _bcm_petra_field_test_take_action(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 action)
{
    if(nof_actions){
        --nof_actions;
        return TRUE;
    }
    return FALSE;
}

/*
 * get the number of resources for qualifier in the worst case. 
 * it take its hardware length for each of the possible hardware qualifiers, and any 16 bits or less may take 1 c.e.
 * it determines also the number of hardware qualifiers
 */
STATIC bcm_error_t _bcm_petra_field_test_qualify_get_nof_resorces(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, bcm_field_qualify_t qualify, uint32 *nof_ces, uint32 *nof_hw_quals)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_QUAL_TYPE *soc_ppd_qual_ptr;
    bcm_error_t rv;
    unsigned int exposed, hardwareBestCase, hardwareWorstCase;
    uint32 ppd_qual_idx;

    BCMDNX_INIT_FUNC_DEFS;

    
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, stage, 1 << type, qualify, &soc_ppd_qual_ptr);

    BCM_IF_ERROR_RETURN(rv);

    if(nof_ces) {
        *nof_ces = 0;
    }

    for(ppd_qual_idx = 0; ppd_qual_idx < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx) {
        if( (soc_ppd_qual_ptr[ppd_qual_idx] < SOC_PPC_NOF_FP_QUAL_TYPES) && (soc_ppd_qual_ptr[ppd_qual_idx] != BCM_FIELD_ENTRY_INVALID)) {
            if(nof_hw_quals) {
                *nof_hw_quals = ppd_qual_idx + 1;
            }
            rv = _bcm_dpp_ppd_qual_bits(unit, stage, soc_ppd_qual_ptr[ppd_qual_idx], &exposed, &hardwareBestCase, &hardwareWorstCase);
            BCM_IF_ERROR_RETURN(rv);
            if(nof_ces) {
                *nof_ces += hardwareWorstCase / 16;
                if(hardwareWorstCase % 16) {
                    ++(*nof_ces);
                }
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC uint8 _bcm_petra_field_test_take_qualifier(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 qualifier)
{
    bcm_error_t rv;
    uint8 is_lsb, is_msb;
    uint32 nof_ces = 0;
    uint32 qual_length;
    rv = _bcm_petra_field_test_qualifier_is_lsb_is_msb(unit, (bcm_field_qualify_t) qualifier, &is_lsb, &is_msb);
    if(rv != BCM_E_NONE) {
        return FALSE;
    }
    
    rv = _bcm_petra_field_test_qualify_get_nof_resorces(unit, stage, type, (bcm_field_qualify_t) qualifier, &nof_ces, NULL);
    if(rv != BCM_E_NONE) {
        return FALSE;
    }

	rv = _bcm_petra_field_test_qualify_hardware_length_worst(unit, stage, type, (bcm_field_qualify_t) qualifier, &qual_length);
    if(rv != BCM_E_NONE) {
        return FALSE;
    }
    
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
/* In this case the limit is not tp take more than 4 ces. */
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        if(nof_ces < total_nof_ces) {
            total_nof_ces-=nof_ces;
            return TRUE;
        }
        return FALSE;
    }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    if (SOC_IS_JERICHO(unit)) {
        if (lsb_ces >= nof_ces)
        {
            lsb_ces -= nof_ces;
        }
        else if (msb_ces >= nof_ces)
        {
            msb_ces -= nof_ces;
        }
        else {
            return FALSE;
        }
    }

    else {
            /* if the qualifier is only one of them it will take only msb or lsb.
             * if the qualifier can be both of them, we may not know which c.e. will be taken, assume that it will take msb and lsb
             */
            if(is_lsb && lsb_ces < nof_ces) {
                return FALSE;
            }
            if(is_msb && msb_ces < nof_ces) {
                return FALSE;
            }
            
            /* verify no exceed of the lsb and msb buffer.
             * if the qualifier can be nor lsb either msb, we can be confident
             * because of the check that the total length doen't excess the maximal key length
             */
            if(is_lsb && !is_msb && qual_length > lsb_qualifiers_available_length) {
                return FALSE;
            }

            if(is_msb && !is_lsb && qual_length > msb_qualifiers_available_length) {
                return FALSE;
            }

            if(is_lsb) {
                lsb_ces -= nof_ces;
                if(!is_msb) {
                    lsb_qualifiers_available_length -= qual_length;
                }
            }
            if(is_msb) {
                msb_ces -= nof_ces;
                if(!is_lsb) {
                    msb_qualifiers_available_length -= qual_length;
                }
            }
    }

    return TRUE;
}

/*
 * This function get empty set, 
 * fills it with items and while the length doesn't excess the max_length
 */
STATIC bcm_error_t _bcm_petra_field_create_set_max_length(
    int unit,
    _bcm_dpp_field_stage_idx_t stage,
    uint32 type,
    void *set,
    void (add_function)(void *set, uint32 item),
    uint8 (test_function)(void *set, uint32 item),
    bcm_error_t (length_function)(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 item, uint32 *length),
    bcm_error_t (can_be_both)(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 item1, uint32 item2, uint8 *res),
    uint8 (take_resource_function)(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 type, uint32 item),
    int nof_items,
    void *valid_items_set,
    uint32 max_length,
    uint32 max_items,
    uint32 x
)
{
    bcm_error_t rv;
    uint32 second_rand_param = 0;
    uint32 nof_items_in_set;
    uint32 item_idx;
    uint8 to_continue;
    int last_avail_item_ndx;
    uint32 item;
    uint32 length = 0, item_length;
    int *items_not_selected_yet;
    uint8 can_insert;
    uint32 *selected_items = NULL;
    int exit_code ;
    int ret ;

    ret = 0 ;
    exit_code = 0 ;

    items_not_selected_yet = sal_alloc(nof_items*sizeof(int), "_bcm_petra_field_create_set_max_length.items_not_selected_yet");
    if(!items_not_selected_yet) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        ret = BCM_E_FAIL;
        exit_code = 5 ;
        goto exit ;
    }
    selected_items = sal_alloc(max_items*sizeof(int), "_bcm_petra_field_create_set_max_length.max_items");
    if(!selected_items) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure\n")));
        sal_free(items_not_selected_yet);
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        ret = BCM_E_FAIL;
        exit_code = 6 ;
        goto exit ;
    }
    
    for(item_idx = 0; item_idx <nof_items; ++item_idx) {
        items_not_selected_yet[item_idx] = item_idx;
    }
    
    last_avail_item_ndx = nof_items - 1;
    
    for(nof_items_in_set = 0; nof_items_in_set < max_items && length < max_length ; ++nof_items_in_set) {
        do
        {
            do 
            {
                item_idx = _bcm_petra_field_rand_val(x, second_rand_param++)% (last_avail_item_ndx + 1);
                item = items_not_selected_yet[item_idx];
                items_not_selected_yet[item_idx] = items_not_selected_yet[last_avail_item_ndx--];
            } 
            while(last_avail_item_ndx >= 0 && !test_function(valid_items_set, item));

            if(last_avail_item_ndx < 0) {
                /* i.e all the valid items selected */
                sal_free(items_not_selected_yet);
                sal_free(selected_items);
                if(nof_items_in_set == 0) {
                    /* i.e. no item has been selected */
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    ret = BCM_E_FAIL;
                    exit_code = 7 ;
                    goto exit ;
                } else {
                    ret = BCM_E_NONE;
                    exit_code = 8 ;
                    goto exit ;
                }
            }

            to_continue = FALSE;
            /* check that the new item can be with all the previous */
            for(item_idx = 0; item_idx < nof_items_in_set; ++item_idx) {
                rv = can_be_both(unit, stage, type, item, selected_items[item_idx], &can_insert);
                if(rv != BCM_E_NONE) {
                    sal_free(items_not_selected_yet);
                    sal_free(selected_items);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    ret = rv ;
                    exit_code = 9 ;
                    goto exit ;
                }
                if(!can_insert) {
                    to_continue = TRUE;
                    break;
                }
            }
            if(to_continue) {
                continue;
            }
            /* updating the length */
            rv = length_function(unit, stage, type, item, &item_length);
            if(rv != BCM_E_NONE) {
                sal_free(items_not_selected_yet);
                sal_free(selected_items);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                ret = rv ;
                exit_code = 10 ;
                goto exit ;
            }
            if((length + item_length <= max_length)  && take_resource_function(unit, stage, type, item)) {
                add_function(set, item);
                length += item_length;
                selected_items[nof_items_in_set] = item;
            } else {
                /* Try to take shorter item */
                to_continue = TRUE;
            }
        }
        while(to_continue);
    }

    sal_free(items_not_selected_yet);
    sal_free(selected_items);
    ret = BCM_E_NONE;
    goto exit ;
exit:
    if (exit_code) {
        LOG_INFO(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
            "Error exit. Exit code %d\r\n"),exit_code)) ;
    }
    return (ret) ;
}

STATIC bcm_error_t _bcm_petra_field_test_qualify_can_be_both(int unit,
                                                             _bcm_dpp_field_stage_idx_t stage,
                                                             uint32 type,
                                                             bcm_field_qualify_t qualify1,
                                                             bcm_field_qualify_t qualify2,
                                                             uint8 *answer)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_QUAL_TYPE *soc_ppd_qual_ptr1, *soc_ppd_qual_ptr2;
    bcm_error_t rv;
    uint32 ppd_qual_idx1, ppd_qual_idx2;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, stage, (type == 0xffffffff) ? 0xf : (1 << type), qualify1, &soc_ppd_qual_ptr1);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        LOG_ERROR(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "qualify1 %d\n"), qualify1));
        goto exit;
    }
    rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, stage, (type == 0xffffffff) ? 0xf : (1 << type), qualify2, &soc_ppd_qual_ptr2);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        LOG_ERROR(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "qualify2 %d\n"), qualify2));
        goto exit;
    }
    
    for(ppd_qual_idx1 = 0; ppd_qual_idx1 < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx1) {
        for(ppd_qual_idx2 = 0; ppd_qual_idx2 < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx2) {
            if((soc_ppd_qual_ptr1[ppd_qual_idx1] < SOC_PPC_NOF_FP_QUAL_TYPES ) &&
			   (soc_ppd_qual_ptr1[ppd_qual_idx1] != BCM_FIELD_ENTRY_INVALID )  &&
                soc_ppd_qual_ptr1[ppd_qual_idx1] == soc_ppd_qual_ptr2[ppd_qual_idx2]) {
                *answer = FALSE;
                BCM_EXIT;
            }
        }
    }
    
    *answer = TRUE;
    
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC bcm_error_t _bcm_petra_field_test_data_qualifiers_can_be_both(int unit,
                                                                     _bcm_dpp_field_stage_idx_t stage,
                                                                     uint32 type,
                                                                     uint32 item1,
                                                                     uint32 item2,
                                                                     uint8 *answer)
{
    /* we check this only for predefined data qualifiers */
    bcm_error_t rv;
    bcm_field_data_qualifier_t dq1, dq2;
    
    rv = bcm_field_data_qualifier_get(unit, item1, &dq1);
    if(rv != BCM_E_NONE) {
        return rv;
    }
        
    rv = bcm_field_data_qualifier_get(unit, item2, &dq2);
    if(rv != BCM_E_NONE) {
        return rv;
    }

    if((dq1.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) && (dq2.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED)) {
        return _bcm_petra_field_test_qualify_can_be_both(unit, stage, 0xffffffff, dq1.qualifier, dq2.qualifier, answer);
    }
    
    *answer = TRUE;
    return BCM_E_NONE;
}

STATIC bcm_error_t _bcm_petra_field_test_action_can_be_both(int unit,
                                                            _bcm_dpp_field_stage_idx_t stage,
                                                            uint32 type,
                                                            bcm_field_action_t action1,
                                                            bcm_field_action_t action2,
                                                            uint8 *answer)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_ACTION_TYPE *soc_ppd_action_ptr1, *soc_ppd_action_ptr2;
    bcm_error_t rv;
    uint32 ppd_action_idx1, ppd_action_idx2;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_act_from_bcm_act(unitData, stage, action1, &soc_ppd_action_ptr1);
    BCM_IF_ERROR_RETURN(rv);
    rv = _bcm_dpp_ppd_act_from_bcm_act(unitData, stage, action2, &soc_ppd_action_ptr2);
    BCM_IF_ERROR_RETURN(rv);

    for(ppd_action_idx1 = 0; ppd_action_idx1 < _BCM_PETRA_FIELD_ACTION_CHAIN; ++ppd_action_idx1) {
        for(ppd_action_idx2 = 0; ppd_action_idx2 < _BCM_PETRA_FIELD_ACTION_CHAIN; ++ppd_action_idx2) {
            if((soc_ppd_action_ptr1[ppd_action_idx1] < SOC_PPC_NOF_FP_ACTION_TYPES) &&
                (soc_ppd_action_ptr1[ppd_action_idx1] != BCM_FIELD_ENTRY_INVALID) &&
                (soc_ppd_action_ptr1[ppd_action_idx1] == soc_ppd_action_ptr2[ppd_action_idx2])) {
                *answer = FALSE;
                BCM_EXIT;
            }
        }
    }
    
    *answer = TRUE;
    
exit:
    BCMDNX_FUNC_RETURN;
}

static const bcm_field_qset_t *get_set_get_qual_failure(void){
    const static bcm_field_qualify_t set_get_qual_failure[] = {
        /* Range Qualifiers */
        bcmFieldQualifyPacketLengthRangeCheck,
        bcmFieldQualifyRangeCheck,
        bcmFieldQualifyVPortRangeCheck,

        bcmFieldQualifyRxTrapCode,
        bcmFieldQualifySrcIp6High,
        bcmFieldQualifyDstIp6High,
        bcmFieldQualifyDstL3Egress,
        
        bcmFieldQualifyConstantZero,
        bcmFieldQualifyConstantOne,
        bcmFieldQualifyFlowId,
        bcmFieldQualifyAppType
    };

    static uint8 is_set = FALSE;
    static bcm_field_qset_t qset;
    uint32 i;
    
    if(!is_set){
        BCM_FIELD_QSET_INIT(qset);
        for(i = 0; i < sizeof(set_get_qual_failure)/sizeof(bcm_field_qualify_t); ++i) {
            BCM_FIELD_QSET_ADD(qset, set_get_qual_failure[i]);
        }
        is_set = TRUE;
    }
    
    return &qset;
}

static const bcm_field_qset_t *get_ingress_traffic_failure(void){
    const static bcm_field_qualify_t ingress_traffic_failure[] = {
        /* traffic failure - test exist */
        bcmFieldQualifyEcnValue,
        bcmFieldQualifyL4SrcPort,
        bcmFieldQualifyL4DstPort,
        bcmFieldQualifyTcpControl,
        bcmFieldQualifyInnerSrcIp,
        bcmFieldQualifyInnerDstIp,
        bcmFieldQualifyInnerTtl,
        bcmFieldQualifyInnerIpProtocol,
        bcmFieldQualifyInnerIpFrag,
        bcmFieldQualifyInnerSrcMac,
        bcmFieldQualifyInnerDstMac,
        bcmFieldQualifyInnerEtherType,
        bcmFieldQualifyExtensionHeaderType,
    
        /* no test for these qualifiers */
        bcmFieldQualifyPacketRes,
        bcmFieldQualifyTunnelType,
        bcmFieldQualifyForwardingType,
        bcmFieldQualifyInterfaceClassL2,
        bcmFieldQualifyVrf,
        bcmFieldQualifyL3Ingress,
        bcmFieldQualifyL2Format,
        bcmFieldQualifyL2DestHit,
        bcmFieldQualifyL2StationMove,
        bcmFieldQualifyL3DestHostHit,
        bcmFieldQualifyColor,
        bcmFieldQualifyVlanTranslationHit,
        bcmFieldQualifyL3DestRouteHit,
        bcmFieldQualifyIntPriority,
        bcmFieldQualifyL2SrcHit,
        bcmFieldQualifyHeaderFormat,
        bcmFieldQualifyTunnelTerminated,
        bcmFieldQualifyRxTrapCode,
        bcmFieldQualifyPtch,
        bcmFieldQualifyRxTrapData,
        bcmFieldQualifyPacketTerminatedBytes,
        bcmFieldQualifyPolicerIntPrio,
        bcmFieldQualifyInterfaceClassVPort,
        bcmFieldQualifyVlanTranslationValue,
        bcmFieldQualifyTunnelTerminatedValue,
        bcmFieldQualifyMplsTerminatedValue,
        bcmFieldQualifyIpTunnelValue,
        bcmFieldQualifyL3SrcRouteValue,
        bcmFieldQualifyL3DestRouteValue,
        bcmFieldQualifyPacketSize,
        bcmFieldQualifyIpmcHit,
        bcmFieldQualifyL3SrcRouteHit,
        bcmFieldQualifyDhcp,
        bcmFieldQualifyPortOrientation,
        bcmFieldQualifyMplsTerminated,
        bcmFieldQualifyInnerTos,
        bcmFieldQualifyInnerL4SrcPort,
        bcmFieldQualifyInnerL4DstPort,
        bcmFieldQualifyInVPort,
        bcmFieldQualifyOutVPort,
        bcmFieldQualifyIpTunnelHit,
        bcmFieldQualifyMplsForwardingLabel,
        bcmFieldQualifyMplsForwardingLabelAction,
        bcmFieldQualifyIpFlags,
        bcmFieldQualifyMplsForwardingLabelExp,
        bcmFieldQualifyMplsForwardingLabelId,
        bcmFieldQualifyVlanFormat,
        bcmFieldQualifyIngressStpState,
        bcmFieldQualifyVpn,
        bcmFieldQualifyFlowId,
        bcmFieldQualifyTrillEgressRbridge,
        bcmFieldQualifyISid,
        bcmFieldQualifyL2SrcValue,
        bcmFieldQualifyL2DestValue,
        bcmFieldQualifyIpmcValue,
        bcmFieldQualifyLearnSrcMac,
        bcmFieldQualifyLearnVlan,
        bcmFieldQualifyMplsForwardingLabelTtl,
        bcmFieldQualifyCascadedKeyValue,
        bcmFieldQualifyL2Learn,
        bcmFieldQualifyMplsForwardingLabelBos,
        bcmFieldQualifyDrop,
        bcmFieldQualifyDstMulticastGroup,
        bcmFieldQualifySrcMplsGport,
        bcmFieldQualifyDstMplsGport,
        bcmFieldQualifySrcMimGport,
        bcmFieldQualifyDstMimGport,
        bcmFieldQualifySrcWlanGport,
        bcmFieldQualifyDstWlanGport,
        bcmFieldQualifySrcModPortGport,
        bcmFieldQualifySrcModuleGport,
        bcmFieldQualifySrcGport,
        bcmFieldQualifyDstRpfGport,
        bcmFieldQualifyLearnSrcPort,
        bcmFieldQualifyLearnInVPort,
        bcmFieldQualifyTunnelId,
        bcmFieldQualifyArpSenderIp4,
        bcmFieldQualifyArpTargetIp4,
        bcmFieldQualifyArpOpcode,
        bcmFieldQualifyTranslatedOuterVlan, 
        bcmFieldQualifyTranslatedOuterVlanId, 
        bcmFieldQualifyTranslatedOuterVlanPri,
        bcmFieldQualifyTranslatedOuterVlanCfi,
        bcmFieldQualifyTranslatedInnerVlan, 
        bcmFieldQualifyTranslatedInnerVlanId, 
        bcmFieldQualifyTranslatedInnerVlanPri,
        bcmFieldQualifyTranslatedInnerVlanCfi,
        bcmFieldQualifyForwardingHeaderOffset,
        bcmFieldQualifyExternalValue0,      
        bcmFieldQualifyExternalValue1,      
        bcmFieldQualifyExternalValue2,     
        bcmFieldQualifyExternalValue3,     
        bcmFieldQualifyExternalValue4,     
        bcmFieldQualifyExternalValue5,     
        bcmFieldQualifyExternalHit0,       
        bcmFieldQualifyExternalHit1,       
        bcmFieldQualifyExternalHit2,       
        bcmFieldQualifyExternalHit3,       
        bcmFieldQualifyExternalHit4,       
        bcmFieldQualifyExternalHit5,       
        bcmFieldQualifyIngressVPortBridgeDisable,
        bcmFieldQualifyMirrorEgressDisabled,
        bcmFieldQualifyBypassSrcMacFilter,
        bcmFieldQualifyRxTrapCodeForSnoop,
        bcmFieldQualifyFhei,
        bcmFieldQualifyFheiSize,
        bcmFieldQualifyOuterVlanActionRange,
        bcmFieldQualifyInnerVlanActionRange,
        bcmFieldQualifyOamInLifIdValid,
        bcmFieldQualifyOamInLifId,
        bcmFieldQualifyOamUpMep,
        bcmFieldQualifyOamSubtype,
        bcmFieldQualifyOamHeaderOffset,
        bcmFieldQualifyOamStampOffset,
        bcmFieldQualifyOamMepId,
        bcmFieldQualifyOamMeterDisable,
        bcmFieldQualifyOamTsSystemHeader,
        bcmFieldQualifyEthernetOamHeaderBits0_31,    
        bcmFieldQualifyEthernetOamHeaderBits32_63,   
        bcmFieldQualifyMplsOamHeaderBits0_31,        
        bcmFieldQualifyMplsOamHeaderBits32_63,       
        bcmFieldQualifyMplsOamACH,                   
        bcmFieldQualifyOamHeaderBits0_31,            
        bcmFieldQualifyOamHeaderBits32_63,           
        bcmFieldQualifyInVPortWide,  
        bcmFieldQualifyStackingRoute,
        bcmFieldQualifyDstSysPortExt,       
        bcmFieldQualifyOuterVlanPriCfi,          
        bcmFieldQualifyForwardHdrSrcMac,
        bcmFieldQualifyForwardHdrDstMac,
        bcmFieldQualifyForwardHdrVlanId,
        bcmFieldQualifyLearnExtension,
        bcmFieldQualifyVlanAction,
        bcmFieldQualifyNativeVSwitch,
        bcmFieldQualifyRxTrapStrength,
        bcmFieldQualifyIncomingIpIfClass,
    };
    static uint8 is_set = FALSE;
    static bcm_field_qset_t qset;
    uint32 i;
    
    if(!is_set){
        BCM_FIELD_QSET_INIT(qset);
        for(i = 0; i < sizeof(ingress_traffic_failure)/sizeof(bcm_field_qualify_t); ++i) {
            BCM_FIELD_QSET_ADD(qset, ingress_traffic_failure[i]);
        }
        is_set = TRUE;
    }
    
    return &qset;
}

static const bcm_field_qset_t *get_ingress_traffic_failure_not_scan(void){
    const static bcm_field_qualify_t ingress_traffic_failure_not_scan[] = {
        /* These qualifiers causes failure if we want to use the qualifier EtheType
           Or another header, because of failure in the identification of the inner vlan */
        bcmFieldQualifyInnerVlan,
        bcmFieldQualifyInnerVlanId,
        bcmFieldQualifyInnerVlanPri,
        bcmFieldQualifyInnerVlanCfi,
        bcmFieldQualifyInnerTpid
    };
    static uint8 is_set = FALSE;
    static bcm_field_qset_t qset;
    uint32 i;
    
    if(!is_set){
        BCM_FIELD_QSET_INIT(qset);
        for(i = 0; i < sizeof(ingress_traffic_failure_not_scan)/sizeof(bcm_field_qualify_t); ++i) {
            BCM_FIELD_QSET_ADD(qset, ingress_traffic_failure_not_scan[i]);
        }
        is_set = TRUE;
    }
    
    return &qset;
}

/*
 * This function get qset and aset randomly for field group
 * The function gets also the sum of the qualifiers and the sum actions and updates them 
 * sum_qualifiers and sum_actions may be null. 
 */
STATIC cmd_result_t _bcm_petra_field_test_field_group_get_qset_and_aset(int unit,
                                                                        _bcm_dpp_field_stage_idx_t stage,
                                                                        uint32 nof_residual_groups, /* the number of field group we would like to create 
                                                                                                     * not include this field group */
                                                                        uint32 x,
                                                                        uint8 is_data_qualifier,
                                                                        uint8 is_large_de,
                                                                        int type,
                                                                        uint32 max_bank_size,
                                                                        bcm_field_qset_t *qset,
                                                                        bcm_field_aset_t *aset,
                                                                        uint32 *sum_qualifiers,
                                                                        uint32 *sum_actions,
                                                                        uint8 perf /*For performance tests, to read max_bank_size as bank_size*/)
{
    bcm_error_t rv;
    uint32 second_rand_param = 0;
    int rnd;
    uint32 data_qual_id;
    bcm_field_qualify_t qual;
    bcm_field_action_t action;
    uint32 max_qualifiers_length;
    uint32 max_actions_length;
    uint32 max_qualifiers;
    uint32 max_actions;
    bcm_field_qset_t valid_qset;
    bcm_field_aset_t valid_aset;
    int qual_arr[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1];
    int qual_count;
    bcm_field_data_qualifier_t dq;
    uint32 hw_length;
    uint32 sw_length;
    uint32 nof_hw_quals;

    /* qset */
    if(!perf) {
        rnd = _bcm_petra_field_rand_val(x, second_rand_param++)%3;
        if(rnd == 0 && max_bank_size >= 320) {
            max_qualifiers_length = 320 - 3*_BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;/* It may be split in 4 zones */
        } else if(rnd == 1 && max_bank_size >= 160) {
            max_qualifiers_length = 160 - _BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;/* it may be split in 2 zones */
        } else {
            max_qualifiers_length = 80;/* must be in only single zone - no split overheadr */
        }
    } else { /* For performance tests, take the predefined max_qualifiers_length _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_SIZE_PERF */
        max_qualifiers_length = _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_SIZE_PERF /* and calculate split overhead as above*/
            - (4 / (_BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE / _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_SIZE_PERF) - 1)
            *  _BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;
    }
    _bcm_petra_field_test_reset_field_group_resources(max_qualifiers_length / 2);
               
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        max_qualifiers_length = 160 - _BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;/* it may be split in 2 zones */
    }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    if(_bcm_petra_field_test_qualify_and_action_get_valid_set(unit, stage, x, type, &valid_qset, &valid_aset)) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Failed to get valid qset and aset\n")));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

              
    max_qualifiers = _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_QUALIFIERS(stage);
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        if(nof_residual_groups > 0) {
            max_qualifiers = 1;
        } else {
            max_qualifiers = 4;
        }
    }
    /* In order not to take bcmFieldActionExternalValue[0/1]Set
     * that are not available if the AppType is not L2 only. */
    BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionExternalValue0Set);
#ifdef BCM_88660_A0
      if ((SOC_IS_ARADPLUS(unit)) && (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_rpf_fwd_parallel", 0) == 0)){
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionExternalValue2Set);
      }
      else
#endif /* BCM_88660_A0 */
      {
          BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionExternalValue1Set);
      }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    if(sum_qualifiers) {
        if (*sum_qualifiers + _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_QUALIFIERS(stage) + nof_residual_groups > 64) {
            max_qualifiers = 64 - *sum_qualifiers - nof_residual_groups;
        }
    }

    type = _BCM_PETRA_FIELD_TYPE_ETHR;
    BCM_FIELD_QSET_INIT(*qset);
    if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyIp4)) {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyIp4);
        BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIp4);
        type = _BCM_PETRA_FIELD_TYPE_IPV4;
    } else if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyIp6)) {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyIp6);
        BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIp6);
        type = _BCM_PETRA_FIELD_TYPE_IPV6;
    } else if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyMpls)) {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyMpls);
        BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyMpls);
        type = _BCM_PETRA_FIELD_TYPE_MPLS;
    }

    _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);

    #if defined(INCLUDE_KBP) && !defined(BCM_88030)
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        if(nof_residual_groups > 0) {
            uint32 nof_ces;

            /* remove all the qualifiers that have more than 2 ce-s */
            for(qual =0; qual < bcmFieldQualifyCount; ++qual) {
                if(BCM_FIELD_QSET_TEST(valid_qset, qual)) {
                    rv = _bcm_petra_field_test_qualify_get_nof_resorces(unit, stage, type, qual, &nof_ces, NULL);
                    if(rv != BCM_E_NONE) {
                        return CMD_FAIL;
                    }
                    if(nof_ces > 2) {
                        BCM_FIELD_QSET_REMOVE(valid_qset, qual);
                    }
                }
            }
        }
    }                
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    
    if(!is_data_qualifier) {
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    stage,
                                                    type,
                                                    qset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
                                                    _bcm_petra_field_test_qualify_hardware_length_worst,
                                                    _bcm_petra_field_test_qualify_can_be_both,
                                                    _bcm_petra_field_test_take_qualifier,
                                                    bcmFieldQualifyCount,
                                                    &valid_qset,
                                                    max_qualifiers_length,
                                                    max_qualifiers,
                                                    x + second_rand_param++);
    } else {
        data_qualifier_add_remove_test_unit = unit;
        for(data_qual_id = 0; data_qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++data_qual_id) {
            bcm_field_data_qualifier_t_init(&dq);
            rv = bcm_field_data_qualifier_get(unit, data_qual_id, &dq);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if((dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) &&
                !BCM_FIELD_QSET_TEST(valid_qset, dq.qualifier)) {
                /* Remove it from the valid_qset. It may be in the valid qset */ 
                rv = bcm_field_qset_data_qualifier_delete(unit, &valid_qset, data_qual_id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            } else {
                if(is_large_de) {
                    /* we can't take qualifiers that have 2 hardware qualifiers */
                    rv = _bcm_petra_field_test_qualify_get_nof_resorces(unit, stage, type, dq.qualifier, NULL, &nof_hw_quals);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(nof_hw_quals > 1) {
                        continue;
                    }

                    /* remove qualifiers whose length is not equal to their hardware length */
                    rv = _bcm_petra_field_test_qualify_hardware_length_best(unit, stage, type, dq.qualifier, &hw_length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    rv = _bcm_petra_field_test_qualify_exposed_length(unit, stage, type, dq.qualifier, &sw_length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(hw_length != sw_length) {
                        continue;
                    }
                }

                rv = bcm_field_qset_data_qualifier_add(unit, &valid_qset, data_qual_id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
        }

        if(is_large_de) {
            max_qualifiers = 8;
            rv = _bcm_petra_field_test_action_length(unit, stage, _BCM_PETRA_FIELD_TEST_LARGE_DIRECT_EXTRACTION_ACTION, &max_qualifiers_length);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    stage,
                                                    0xffffffff,
                                                    qset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_data_qualifier_set_test,
                                                    _bcm_petra_field_test_data_qualifier_length,
                                                    _bcm_petra_field_test_data_qualifiers_can_be_both,
                                                    _bcm_petra_field_test_take_action,
                                                    _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1,
                                                    &valid_qset,
                                                    max_qualifiers_length,
                                                    max_qualifiers,
                                                    x + second_rand_param++);
    }

    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(!is_data_qualifier){
        for(qual = 0; qual < bcmFieldQualifyCount; ++qual) {
            if(BCM_FIELD_QSET_TEST(*qset, qual)  
                && qual != bcmFieldQualifyIp4 && qual != bcmFieldQualifyIp6 && qual != bcmFieldQualifyMpls) {
                if(sum_qualifiers)
                  ++(*sum_qualifiers);
            }
        }
    } else {
         rv = bcm_field_qset_data_qualifier_get(unit,
                                                *qset,
                                                _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1,
                                                qual_arr,
                                                &qual_count);
         if(rv != BCM_E_NONE) {
             _BCM_PETRA_FIELD_TEST_FAIL_MSG;
             return CMD_FAIL;
         }
         *sum_qualifiers += qual_count;
    }

    /* aset - ingress and external only */
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS ||
        stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        BCM_FIELD_ASET_INIT(*aset);

        max_actions = _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_ACTIONS;
        if(sum_actions) {
            if (*sum_actions + _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_ACTIONS + nof_residual_groups > 32) {
                max_actions = 32 - *sum_actions - nof_residual_groups;
            }
        }

        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionCascadedKeyValueSet);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionSnoopAndTrap);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStatAndPolicer);

        if (!SOC_IS_JERICHO_PLUS(unit)) {
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionPphSnoopCode);
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile0Set);
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile1Set);
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile2Set);
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile3Set);
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfileDirectSet);

            LOG_INFO(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                    "%s(): Action does not exist for this device. This is just a message.\n"),
                                                                                                __FUNCTION__));
        }

        rnd = _bcm_petra_field_rand_val(x, second_rand_param++)%3;
        if(rnd == 0) {
            max_actions_length = 80;
        } else if(rnd == 1) {
            max_actions_length = 40;
        } else {
            max_actions_length = 20;
        } 
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            max_actions_length = 40;
        }            
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        if(!is_large_de) {
            if (!SOC_IS_ARADPLUS(unit)) {
                BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionInterfaceClassVPort);
                LOG_INFO(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                        "%s(): bcmFieldActionInterfaceClassVPort does not exist for Arad and below. This is just a message.\n"),
                                                                                                    __FUNCTION__));
            }
            rv = _bcm_petra_field_create_set_max_length(unit,
                                                        stage,
                                                        0,
                                                        aset, 
                                                        (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_add,
                                                        (uint8 (*)(void*, uint32)) _bcm_petra_field_test_action_set_test,
                                                        _bcm_petra_field_test_action_length_with_valid_bit,
                                                        _bcm_petra_field_test_action_can_be_both,
                                                        _bcm_petra_field_test_take_action,
                                                        bcmFieldActionCount,
                                                        &valid_aset,
                                                        max_actions_length,
                                                        max_actions,
                                                        x + second_rand_param++);
            if(rv != BCM_E_NONE) {  
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        } else {
            BCM_FIELD_ASET_ADD(*aset, _BCM_PETRA_FIELD_TEST_LARGE_DIRECT_EXTRACTION_ACTION);
        }

        for(action = 0; action < bcmFieldActionCount; ++action) {
            if(BCM_FIELD_ASET_TEST(*aset, action)) {
                if(sum_actions)
                  ++(*sum_actions);
            } 
        }
    } else {
        sal_memcpy(aset, &valid_aset, sizeof(*aset));
    }
     
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyStageIngress);
    } else if (stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyStageEgress);
    } else {
        BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyStageExternal);
    }

    return CMD_OK;
}

#ifdef BROADCOM_DEBUG
STATIC bcm_error_t _bcm_petra_field_test_group_dump(int unit,
                                                    uint8 group_id)
{
    bcm_dpp_field_info_OLD_t *unitData;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_dump(unitData, group_id, "", FALSE));

exit:
    BCMDNX_FUNC_RETURN;
}

#endif

/*
 * This function fills by random values the array of the filed groups
 */
STATIC cmd_result_t _bcm_petra_field_test_fill_field_groups(int unit,
                                                            _bcm_dpp_field_stage_idx_t stage,
                                                            uint32 x,
                                                            uint8 is_data_qualifier,
                                                            uint8 is_large_de,
                                                            int type,
                                                            uint32 max_bank_size,
                                                            bcm_field_group_config_t *field_groups,
                                                            int nof_groups,
                                                            uint8 perf /* For performance tests, do same field group size */)
{
    uint32 fg_idx, fg_idx_2;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint8 does_exist_already;
    uint32 sum_actions = 0;
    uint32 sum_qualifiers = 0;
    cmd_result_t result;
    uint8 nof_not_explicit = 0;

    _bcm_petra_field_test_reset_resources();
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
    _bcm_petra_field_test_kbp_reset_resources();
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
        /* id */
        bcm_field_group_config_t_init(&field_groups[fg_idx]);
        if(fg_idx + nof_not_explicit >= nof_groups) {
            /* We want the implicit field groups to be in the end 
               in order that they will not catch the explicit id of the next field groups */
            is_explicit_id = FALSE;
        } else {
            do
            {
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if (!is_explicit_id) {
                    ++nof_not_explicit;
                }
            }
            while(!is_explicit_id && (fg_idx + nof_not_explicit < nof_groups));
        }
        if(is_explicit_id) {
            do
            {
                id = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                does_exist_already = FALSE;
                for(fg_idx_2 = 0; fg_idx_2 < fg_idx ;++fg_idx_2) {
                    if (id == field_groups[fg_idx_2].group) {
                        does_exist_already = TRUE;
                        break;
                    }
                }
            }
            while(does_exist_already);
            field_groups[fg_idx].group = id;
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
        }

        /* priority */
        do
        {
            field_groups[fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
            does_exist_already = FALSE;
            for(fg_idx_2 = 0; fg_idx_2 < fg_idx ; ++fg_idx_2) {
                if (field_groups[fg_idx].priority == field_groups[fg_idx_2].priority) {
                    does_exist_already = TRUE;
                    break;
                }
            }
        }
        while(does_exist_already);

        /* qset and aset */ 
        result = _bcm_petra_field_test_field_group_get_qset_and_aset(unit,
                                                                     stage,
                                                                     nof_groups - 1 - fg_idx,
                                                                     x + second_rand_param++,
                                                                     is_data_qualifier,
                                                                     is_large_de,
                                                                     type,
                                                                     max_bank_size,
                                                                     &field_groups[fg_idx].qset,
                                                                     &field_groups[fg_idx].aset,
                                                                     &sum_qualifiers,
                                                                     &sum_actions,
                                                                     perf);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
        }
        if(is_large_de) {
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_MODE;
            field_groups[fg_idx].mode = bcmFieldGroupModeDirectExtraction;
        }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            /* preselectors */
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
            BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
            BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, fg_idx + 3);
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    }
    return CMD_OK;
}

CONST STATIC bcm_field_qualify_t _bcm_petra_field_test_comfortable_qualifier_for_direct_table[] = {
    bcmFieldQualifyTtl,
    bcmFieldQualifyInnerTtl,
    bcmFieldQualifyL3DestHostHit,
    bcmFieldQualifyL3SrcHostHit,
    bcmFieldQualifyVlanTranslationHit,
    bcmFieldQualifyIpTunnelHit,
    bcmFieldQualifyL2DestHit,
    bcmFieldQualifyL2SrcHit,
    bcmFieldQualifyL3DestRouteHit,
    bcmFieldQualifyL3SrcRouteHit,
    bcmFieldQualifyIpmcHit,
    bcmFieldQualifyPacketTerminatedBytes,
    bcmFieldQualifyTrunkHashResult,
    bcmFieldQualifyIntPriority,
    bcmFieldQualifyCnTag,
    bcmFieldQualifyOuterVlanPri,
    bcmFieldQualifyOuterVlanCfi,
    bcmFieldQualifyInnerVlanPri,
    bcmFieldQualifyInnerVlanCfi,
    bcmFieldQualifyTranslatedOuterVlanPri,
    bcmFieldQualifyTranslatedOuterVlanCfi,
    bcmFieldQualifyTranslatedInnerVlanPri,
    bcmFieldQualifyTranslatedInnerVlanCfi,
    bcmFieldQualifyMplsForwardingLabelExp,
    bcmFieldQualifyMplsForwardingLabelBos,
    bcmFieldQualifyMplsForwardingLabelTtl,
    bcmFieldQualifyMplsLabel1Exp,
    bcmFieldQualifyMplsLabel1Bos,
    bcmFieldQualifyMplsLabel1Ttl,
    bcmFieldQualifyMplsLabel2Exp,
    bcmFieldQualifyMplsLabel2Bos,
    bcmFieldQualifyMplsLabel2Ttl,
    bcmFieldQualifyMplsLabel3Exp,
    bcmFieldQualifyMplsLabel3Bos,
    bcmFieldQualifyMplsLabel3Ttl,
    bcmFieldQualifyPtch,
    bcmFieldQualifyExternalValue0,      
    bcmFieldQualifyExternalValue1,      
    bcmFieldQualifyExternalValue2,     
    bcmFieldQualifyExternalValue3,     
    bcmFieldQualifyExternalValue4,     
    bcmFieldQualifyExternalValue5,     
    bcmFieldQualifyExternalHit0,       
    bcmFieldQualifyExternalHit1,       
    bcmFieldQualifyExternalHit2,       
    bcmFieldQualifyExternalHit3,       
    bcmFieldQualifyExternalHit4,       
    bcmFieldQualifyExternalHit5,       
    bcmFieldQualifyIngressVPortBridgeDisable
};

/* remove from the valid aset actions that don't fill the constrain that the hw action value is equal to param0 */
STATIC void _bcm_petra_field_test_dt_remove_inadequate_actions(bcm_field_aset_t *aset) {
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionDropPrecedence);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionForwardingTypeNew);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionFilters);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionCnmCancel);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionMacDaKnown);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionDoNotLearn);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStartPacketStrip);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionClassSourceSet);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionClassDestSet);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionEcnNew);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionOrientationSet);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionFabricHeaderSet);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionOam); 
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionIEEE1588);   
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionSnoopAndTrap);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStatAndPolicer);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionTrapCodeQualifier);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionPphSnoopCode); 
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStaggeredPreselProfile0Set);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStaggeredPreselProfile1Set);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStaggeredPreselProfile2Set);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStaggeredPreselProfile3Set);
    BCM_FIELD_ASET_REMOVE(*aset, bcmFieldActionStaggeredPreselProfileDirectSet);
}
/*
 * This function fills by random values the array of the filed groups for direct table mode
 */
STATIC cmd_result_t _bcm_petra_field_test_fill_field_groups_dt(int unit,
                                                               uint32 x,
                                                               bcm_field_group_config_t *field_groups,
                                                               int nof_groups)
{
    uint32 fg_idx, fg_idx_2;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint8 does_exist_already;
    bcm_field_qset_t valid_qset;
    bcm_field_aset_t valid_aset;
    bcm_error_t rv;
    uint8 nof_not_explicit = 0;
    bcm_field_qualify_t qual;
    uint8 is_lsb_qualifier;
    uint32 maximal_key_length;
    uint32 max_qualifiers_per_fg;
    uint32 max_actions_per_fg;
    uint32 type;
    uint32 qual_idx;
    static bcm_field_qset_t comfortable;
    static uint8 is_comfortable_set = FALSE;

    _bcm_petra_field_test_reset_resources();
    for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
        bcm_field_group_config_t_init(&field_groups[fg_idx]);
        /* id */
        if(fg_idx + nof_not_explicit >= nof_groups) {
            /* We want the implicit field groups to be in the end 
               in order that they will not catch the explicit id of the next field groups */
            is_explicit_id = FALSE;
        } else {
            do
            {
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if (!is_explicit_id) {
                    ++nof_not_explicit;
                }
            }
            while(!is_explicit_id && (fg_idx + nof_not_explicit < nof_groups));
        }
        if(is_explicit_id) {
            do
            {
                id = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                does_exist_already = FALSE;
                for(fg_idx_2 = 0; fg_idx_2 < fg_idx ; ++fg_idx_2) {
                    if (id == field_groups[fg_idx_2].group) {
                        does_exist_already = TRUE;
                        break;
                    }
                }
            }
            while(does_exist_already);
            field_groups[fg_idx].group = id;
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
        }
        
        /* priority */
        do
        {
            field_groups[fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
            does_exist_already = FALSE;
            for(fg_idx_2 = 0; fg_idx_2 < fg_idx ; ++fg_idx_2) {
                if (field_groups[fg_idx].priority == field_groups[fg_idx_2].priority) {
                    does_exist_already = TRUE;
                    break;
                }
            }
        }
        while(does_exist_already);

        /* qset and aset */
        if(_bcm_petra_field_test_qualify_and_action_get_valid_set(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, x, 0, &valid_qset, &valid_aset)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Failed to get valid qset and aset\n")));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        /* qset */
        BCM_FIELD_QSET_INIT(field_groups[fg_idx].qset);
        type = _BCM_PETRA_FIELD_TYPE_ETHR;
        if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyIp4)) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyIp4);
            BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIp4);
            type = _BCM_PETRA_FIELD_TYPE_IPV4;
        } else if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyIp6)) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyIp6);
            BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIp6);
            type = _BCM_PETRA_FIELD_TYPE_IPV6;
        } else if(BCM_FIELD_QSET_TEST(valid_qset, bcmFieldQualifyMpls)) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyMpls);
            BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyMpls);
            type = _BCM_PETRA_FIELD_TYPE_MPLS;
        } 

        _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);

        /* take only "comfortable" qualifiers */
        if(!is_comfortable_set) {
            BCM_FIELD_QSET_INIT(comfortable);
            for(qual_idx = 0;
                qual_idx < sizeof(_bcm_petra_field_test_comfortable_qualifier_for_direct_table)/sizeof(bcm_field_qualify_t);
                ++qual_idx) {
                BCM_FIELD_QSET_ADD(comfortable, _bcm_petra_field_test_comfortable_qualifier_for_direct_table[qual_idx]);
            }
            is_comfortable_set = TRUE;
        }

        /* remove msb qualifiers and not "comfortable" qualifiers */
        for(qual = 0; qual < bcmFieldQualifyCount; ++qual) {
            if(BCM_FIELD_QSET_TEST(valid_qset, qual)) {
                rv = _bcm_petra_field_test_qualifier_is_lsb_is_msb(unit, qual, &is_lsb_qualifier, NULL);
                if (rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(!is_lsb_qualifier) {
                    BCM_FIELD_QSET_REMOVE(valid_qset, qual);
                }

                if(!BCM_FIELD_QSET_TEST(comfortable, qual)) {
                    BCM_FIELD_QSET_REMOVE(valid_qset, qual);
                }
            }
        }

        if(nof_groups <= SOC_DPP_DEFS_GET(unit, nof_tcam_small_banks)) {
            /* in the test with entries we may use less than SOC_DPP_DEFS_GET(unit, nof_tcam_small_banks) field groups */
            maximal_key_length = SOC_DPP_DEFS_GET(unit, tcam_big_bank_key_nof_bits);
        } else if (fg_idx + SOC_DPP_DEFS_GET(unit, nof_tcam_small_banks) < nof_groups) {
            /* The last SOC_DPP_DEFS_GET(unit, nof_tcam_small_banks) field groups should be inserted to the small banks - the others in big bank */
            maximal_key_length = SOC_DPP_DEFS_GET(unit, tcam_big_bank_key_nof_bits);
        } else {        
            maximal_key_length = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_QUALIFIERS_LENGTH_SMALL_BANK;
        }
        max_qualifiers_per_fg = (nof_groups > 1) ? 1 /* take only 1 qualifier, to have enough c.e.-s */: maximal_key_length;

        _bcm_petra_field_test_reset_field_group_resources(maximal_key_length);/* anyway all the qualifiers must be lsb */
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                    type,
                                                    &field_groups[fg_idx].qset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
                                                    _bcm_petra_field_test_qualify_hardware_length_worst,
                                                    _bcm_petra_field_test_qualify_can_be_both,
                                                    _bcm_petra_field_test_take_qualifier,
                                                    bcmFieldQualifyCount,
                                                    &valid_qset,
                                                    maximal_key_length,
                                                    max_qualifiers_per_fg,
                                                    x + second_rand_param++);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        
        max_actions_per_fg = (nof_groups > 1) ? 1 /* take only 1 action */: SOC_DPP_DEFS_GET(unit, tcam_action_width);
        /* aset */
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionCascadedKeyValueSet);
        _bcm_petra_field_test_dt_remove_inadequate_actions(&valid_aset);

        if (!SOC_IS_ARADPLUS(unit)) {
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionInterfaceClassVPort);
            LOG_INFO(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                    "%s(): bcmFieldActionInterfaceClassVPort does not exist for Arad and below. This is just a message.\n"),
                                                                                                __FUNCTION__));
        }
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                    0,
                                                    &field_groups[fg_idx].aset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_action_set_test,
                                                    _bcm_petra_field_test_action_length_with_valid_bit,
                                                    _bcm_petra_field_test_action_can_be_both,
                                                    _bcm_petra_field_test_take_action,
                                                    bcmFieldActionCount,
                                                    &valid_aset,
                                                    SOC_DPP_DEFS_GET(unit, tcam_action_width),
                                                    max_actions_per_fg,
                                                    x + second_rand_param++);
        if(rv != BCM_E_NONE) {  
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
                
        field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_MODE;
        field_groups[fg_idx].mode = bcmFieldGroupModeDirect;
        if(!(maximal_key_length == SOC_DPP_DEFS_GET(unit, tcam_big_bank_key_nof_bits))) {
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_SMALL;
        }
    }
    return CMD_OK;
}

/*
 * This function gets the data of the field group. according to the field group's id it retrieves the priority qset aset,
 * and compares them to the data stored in the structure.
 */
STATIC cmd_result_t _bcm_petra_field_field_group_get_and_compare(int unit,
                                                                 bcm_field_group_config_t *field_group,
                                                                 uint8 print_anyway)
{
    bcm_error_t rv;
    int priority_verify;
    bcm_field_qset_t qset_verify;
    bcm_field_group_mode_t mode_verify;
    bcm_field_aset_t aset_verify;
    
    const static char *modes[] = BCM_FIELD_GROUP_MODE_STRINGS;
    
    rv = bcm_field_group_get(unit, field_group->group, &qset_verify);
    if(rv != BCM_E_NONE) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - failed to retrieve the field_group\n"), field_group->group));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    /* qset comparing */
    /* we just verify that what we have inserted is included. We may have another qualifiers */
    rv = _bcm_dpp_field_qset_subset(qset_verify, field_group->qset);
    if(rv != BCM_E_NONE) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - the qset retrieved is not including the qset set  \n"), field_group->group));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    /* Priority comparing */
    rv = bcm_field_group_priority_get(unit, field_group->group, &priority_verify);
    if(rv != BCM_E_NONE) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - bcm_field_group_priority_get failed\n"), field_group->group));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    if(priority_verify != field_group->priority) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - priorities mismatch: set as %d retrieved %d\n"), field_group->group, field_group->priority, priority_verify));
        }
    }

    if(field_group->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE) {
        /* verify the mode */
        rv = bcm_field_group_mode_get(unit, field_group->group, &mode_verify);
        if(rv != BCM_E_NONE) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "group id %d - bcm_field_group_mode_get failed\n"), field_group->group));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        
        if(mode_verify != field_group->mode) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "group id %d - Modes mismatch: set %s, get %s.\n"), field_group->group, modes[field_group->mode], modes[mode_verify]));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }        
        
    /* aset comparing - Skip in the egress stage */
    if(BCM_FIELD_QSET_TEST(field_group->qset, bcmFieldQualifyStageEgress)){
        return CMD_OK;
    }
    
    rv = bcm_field_group_action_get(unit, field_group->group, &aset_verify);
    if(rv != BCM_E_NONE) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - bcm_field_group_action_get failed\n"), field_group->group));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    /* we just verify that what we have inserted is included. We may have another actions */
    rv = _bcm_dpp_field_aset_subset(aset_verify, field_group->aset);
    if(rv != BCM_E_NONE) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "group id %d - the aset retrieved is not including the aset set \n"), field_group->group));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    return CMD_OK;
}

/*
 * This function gets the data of the entry. according to the entrie's id it retrieves the priority qualifiers' data and mask
 * actions' param0 and param1,
 * and compares them to the data stored in the structure.
 */
STATIC cmd_result_t _bcm_petra_field_test_retrieve_entry_and_compare(int unit,
                                                                     _bcm_dpp_field_stage_idx_t stage,
                                                                     _bcm_petra_field_test_entry_info_t *entry,
                                                                     uint8 is_direct_table,
                                                                     uint8 print_anyway)
{
    bcm_error_t rv;
    int priority_verify;
    int qual_idx, action_idx, index;
    uint32 data_verify[_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32];
    uint32 mask_verify[_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32];
    uint32 param0_verify, param1_verify;
    const static char *qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
    const static char *actions_names[] = BCM_FIELD_ACTION_STRINGS;
    uint8 data8[8];
    uint8 mask8[8];
    uint16 length;
    uint32 qual_length;
    uint32 type = _BCM_PETRA_FIELD_TYPE_ETHR;
    int nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    int size_to_cmp = (_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH / 2) * nof_cores /8; /* 256 / 8 per each core */
    if(!is_direct_table) {
        if(!_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry->id)) {
            rv = bcm_field_entry_prio_get(unit, entry->id, &priority_verify);

            if(rv != BCM_E_NONE) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "entry %d exist and bcm_field_entry_prio_get didn\'t return BCM_E_NONE.\n"), entry->id));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        
            /* priority verification */
            if(priority_verify != entry->priority) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "entry %d priority mismatch: set %d get %d.\n"), entry->id, entry->priority, priority_verify));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    }
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp4) {
            type = _BCM_PETRA_FIELD_TYPE_IPV4;
            break;
        }
        if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp6) {
            type = _BCM_PETRA_FIELD_TYPE_IPV6;
            break;
        }
        if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyMpls) {
            type = _BCM_PETRA_FIELD_TYPE_MPLS;
            break;
        }
    }
    
    /* qualifiers verification */ 
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        /* Do not check the qualifier for Direct Extraction entries if its mask is 0 */
        if(entry->quals_info[qual_idx].is_valid 
           && ((entry->id < _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) 
                || entry->id >= (_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) + _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_DIRECT_EXTRACTION)) 
               || entry->quals_info[qual_idx].mask[0])) {
            if((!entry->quals_info[qual_idx].is_undefined)) {
                if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyOutPort ||
                    entry->quals_info[qual_idx].qualify == bcmFieldQualifyOutPorts) {
                    /* For theses qualifiers the get function don't work well */
                    continue;
                }

                if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    rv = _bcm_petra_field_test_operate_get_function(unit, stage, type, entry->id, entry->quals_info[qual_idx].qualify, data_verify , mask_verify);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(sal_memcmp(entry->quals_info[qual_idx].data, data_verify, size_to_cmp)) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d qualifier %s data mismatch.\n") , entry->id, qualifiers_names[entry->quals_info[qual_idx].qualify]));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(sal_memcmp(entry->quals_info[qual_idx].mask, mask_verify, size_to_cmp)) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d qualifier %s mask mismatch. Expected %d, Got %d\n") , entry->id, qualifiers_names[entry->quals_info[qual_idx].qualify], *entry->quals_info[qual_idx].mask, *mask_verify));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            } else {
                if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    /* we do it to avoid msb alignment */
                    rv = _bcm_petra_field_test_data_qualifier_length(unit, stage, type, entry->quals_info[qual_idx].qualify, &qual_length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }

                    sal_memset(data8, 0, 8);
                    sal_memset(mask8, 0, 8);
                    rv = bcm_field_qualify_data_get(unit, entry->id, entry->quals_info[qual_idx].qualify, qual_length/8 + 1, data8, mask8, &length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                
                    /* we opposite the data and mask */
                    for(index = 0; index < length / 2; ++index) {
                        data8[index] ^= data8[length - 1 - index];
                        data8[length - 1 - index] ^= data8[index];
                        data8[index] ^= data8[length - 1 - index];
                        mask8[index] ^= mask8[length - 1 - index];
                        mask8[length - 1 - index] ^= mask8[index];
                        mask8[index] ^= mask8[length - 1 - index];
                    }
                    data_verify[0] = data8[0];
                    data_verify[0] |= data8[1] << 8;
                    data_verify[0] |= data8[2] << 16;
                    data_verify[0] |= data8[3] << 24;
                    data_verify[1] = data8[4];
                    data_verify[1] |= data8[5] << 8;
                    data_verify[1] |= data8[6] << 16;
                    data_verify[1] |= data8[7] << 24;
                    mask_verify[0] = mask8[0];
                    mask_verify[0] |= mask8[1] << 8;
                    mask_verify[0] |= mask8[2] << 16;
                    mask_verify[0] |= mask8[3] << 24;
                    mask_verify[1] = mask8[4];
                    mask_verify[1] |= mask8[5] << 8;
                    mask_verify[1] |= mask8[6] << 16;
                    mask_verify[1] |= mask8[7] << 24;

                    if(data_verify[0] != entry->quals_info[qual_idx].data[0]) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d data_qualifier %d data low mismatch.\n") , entry->id, entry->quals_info[qual_idx].qualify));
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             " set 0x%x, get 0x%x.\n"), entry->quals_info[qual_idx].data[0], data_verify[0]));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(mask_verify[0] != entry->quals_info[qual_idx].mask[0]) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d data_qualifier %d mask low mismatch.\n") , entry->id, entry->quals_info[qual_idx].qualify));
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             " set 0x%x, get 0x%x.\n"), entry->quals_info[qual_idx].mask[0], mask_verify[0]));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(data_verify[1] != entry->quals_info[qual_idx].data[1]) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d data_qualifier %d data high mismatch.\n") , entry->id, entry->quals_info[qual_idx].qualify));
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             " set 0x%x, get 0x%x.\n"), entry->quals_info[qual_idx].data[1], data_verify[1]));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(mask_verify[1] != entry->quals_info[qual_idx].mask[1]) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d data_qualifier %d mask high mismatch.\n") , entry->id, entry->quals_info[qual_idx].qualify));
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             " set 0x%x, get 0x%x.\n"), entry->quals_info[qual_idx].mask[1], mask_verify[1]));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }
        }
    }

    /* actions verification */
    if(!_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry->id)) {
        for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
            if(entry->actions_info[action_idx].is_valid) {
                rv = bcm_field_action_get(unit, entry->id, entry->actions_info[action_idx].action, &param0_verify, &param1_verify);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(entry->actions_info[action_idx].param0 != param0_verify) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d action %s param0 retrieving mismatch set %d get %d.\n"),
                                  entry->id, actions_names[entry->actions_info[action_idx].action], entry->actions_info[action_idx].param0, param0_verify));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(entry->actions_info[action_idx].param1 != param1_verify) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR || print_anyway) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "entry %d action %s param1 retrieving mismatch set %d get %d.\n"),
                                  entry->id, actions_names[entry->actions_info[action_idx].action], entry->actions_info[action_idx].param1, param1_verify));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
        }
    }
    
    return CMD_OK;
}

/* Set data and mask for qualifier */
STATIC cmd_result_t _bcm_petra_field_test_set_qualifier(int unit,
                                                        _bcm_dpp_field_stage_idx_t stage,
                                                        uint32 type,
                                                        bcm_field_qualify_t qualifier,
                                                        uint32 x,
                                                        uint32 *data,
                                                        uint32 *mask)
{
    uint32 second_rand_param = 0;
    cmd_result_t result;
    result = _bcm_petra_field_test_set_qualifiers_info(unit, stage, type);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    result = _bcm_petra_field_test_get_valid_value_and_mask(unit, stage, type, qualifier, x + second_rand_param++, data, mask);

    return result;
}

/*
 * get randomly param0 and param1 for action
 */
STATIC cmd_result_t _bcm_petra_field_test_set_action(int unit,
                                                     bcm_field_action_t action,
                                                     uint32 x,
                                                     uint32 *param0,
                                                     uint32 *param1)
{

    uint32 second_rand_param = 0;

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        const static char *actions_names[] = BCM_FIELD_ACTION_STRINGS;
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Getting valid param0 and param1 for the action %s (%d)\n"), actions_names[action], action));
    }

    switch(action) {
        case bcmFieldActionUsePolicerResult:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 
                (BCM_FIELD_USE_POLICER_RESULT_EGRESS + 1);
            *param1 = 0;
            break;
        case bcmFieldActionSystemHeaderSet:
            *param0 = bcmFieldSystemHeaderPphEei;
            *param1 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFFFFFF + 1);
            break;
        case bcmFieldActionLearnForwardingVlanIdNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0x7FFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionFilters:
            *param0 = BCM_FIELD_FILTER_SA_DISABLED;
            *param1 = 0;
            break;
        case bcmFieldActionOrientationSet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++)
                % (bcmFieldOrientationAccess + 1);
            *param1 = 0;
            break;
        case bcmFieldActionDhcpPkt:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            *param1 = 0;
            break;
        case bcmFieldActionStartPacketStrip:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) %
                (bcmFieldStartToFwdNextStrip + 1);
            *param1 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0x1F + 1);
            break;
        case bcmFieldActionForwardingTypeNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++)
                % 10;
            if(*param0 == 0) {
                *param0 = bcmFieldForwardingTypeL2;
            } else {
                *param0 += -1 + bcmFieldForwardingTypeIp4Ucast;
            } 
            *param1 = 0;
            break;
        case bcmFieldActionStatTag:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionMultipathHashAdditionalInfo:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFFFFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionTrunkHashKeySet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFFFFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionDropPrecedence:
            *param0 = (_bcm_petra_field_rand_val(x, second_rand_param++)
                % (BCM_FIELD_COLOR_BLACK - BCM_FIELD_COLOR_GREEN)) + BCM_FIELD_COLOR_GREEN;
            *param1 = 0;
            break;
        case bcmFieldActionMirrorEgressDisable:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            *param0 = 0;
            break;
        case bcmFieldActionVrfSet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionDscpNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionTtlSet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionVSwitchNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (0xFFFF + 1);
            *param1 = 0;
            break;
        case bcmFieldActionEcnNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            *param1 = 0;
            break;
        case bcmFieldActionPrioIntNew:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 8;
            *param1 = 0;
            break;
        case bcmFieldActionPphPresentSet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
            *param1 = 0;
            break;
        case bcmFieldActionFabricHeaderSet:
            *param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % 16;
            *param1 = 0;
            break;
        case bcmFieldActionExternalValue0Set:
        case bcmFieldActionExternalValue1Set:
        case bcmFieldActionExternalValue2Set:
        case bcmFieldActionExternalValue3Set:
        case bcmFieldActionExternalValue4Set:
        case bcmFieldActionExternalValue5Set:
            *param0 = 1 + _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 16) - 1);
            *param1 = 0;
            break;
        case bcmFieldActionCnmCancel:
        case bcmFieldActionMacDaKnown:
        case bcmFieldActionDoNotLearn:
        default:
            *param0 = 0;
            *param1 = 0;
    }
    return CMD_OK;
}

/* The following function return 0 is success and 1 in failure */
STATIC uint8 _bcm_petra_field_test_vlan_header_to_buffer(_bcm_petra_field_test_vlan_header_t *vlan_header, uint32* buffer)
{
    if(vlan_header->cfi > 1) {
        return 1;
    }
    if(vlan_header->pri > 7) {
        return 1;
    }
    if(vlan_header->vlan_id > 4095) {
        return 1;
    }
    
    *buffer = (uint32)vlan_header->vlan_id;
    *buffer |= (uint32)vlan_header->cfi << 12;
    *buffer |= (uint32)vlan_header->pri << 13;
    *buffer |= (uint32)vlan_header->tag_protocol_id << 16;
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_ethernet_header_to_buffer(_bcm_petra_field_test_ethernet_header_t *ethernet_header, uint32 *buffer)
{
    uint32 vlan_buf;
    uint32 mac_buf[2];
    int unit = BSL_UNIT_UNKNOWN;

    if(ethernet_header->nof_vlans > 2) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    
    buffer[0] = (uint32)ethernet_header->ethertype;

    /* inner vlan if esxist */
    if(ethernet_header->nof_vlans == 2)
    {    
        if(_bcm_petra_field_test_vlan_header_to_buffer(&ethernet_header->vlans[1], &vlan_buf)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
        }
        buffer[0] |= (vlan_buf & 0xffff) << 16;
        buffer[1] = vlan_buf >> 16;
    }

    /* outer vlan if exist */    
    if(ethernet_header->nof_vlans >= 1)
    {
        if(_bcm_petra_field_test_vlan_header_to_buffer(&ethernet_header->vlans[0], &vlan_buf)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
        }
        buffer[ethernet_header->nof_vlans -1] |= (vlan_buf & 0xffff) << 16;
        buffer[ethernet_header->nof_vlans] = vlan_buf >> 16;
    } 
    
    mac_to_buffer(ethernet_header->source_address, mac_buf);
    buffer[ethernet_header->nof_vlans] |= (mac_buf[0] & 0xffff) << 16;
    buffer[ethernet_header->nof_vlans + 1] = (mac_buf[0] >> 16) & 0xffff;
    buffer[ethernet_header->nof_vlans + 1] |= (mac_buf[1] & 0xffff) << 16;
    mac_to_buffer(ethernet_header->destination_address, &buffer[ethernet_header->nof_vlans + 2]);
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_ipv4_header_to_buffer(_bcm_petra_field_test_ipv4_header_t *ipv4_header, uint32 *buffer)
{
    int unit = BSL_UNIT_UNKNOWN;

    if(ipv4_header->fragment_offset > 0x1fff) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv4_header->flags > 0x7) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv4_header->ecn > 0x3) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv4_header->dscp && ipv4_header->ecn) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv4_header->internet_header_length > 0xf) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv4_header->version > 0xf) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    
    buffer[0] = ipv4_header->destination_address;
    buffer[1] = ipv4_header->source_address;
    buffer[2] = ipv4_header->header_checksum;
    buffer[2] |= (uint32)ipv4_header->protocol << 16;
    buffer[2] |= (uint32)ipv4_header->time_to_live << 24;
    buffer[3] = ipv4_header->fragment_offset;
    buffer[3] |= (uint32)ipv4_header->flags << 13;
    buffer[3] |= (uint32)ipv4_header->identification << 16;
    buffer[4] = ipv4_header->total_length;
    if(ipv4_header->ecn) {
        buffer[4] |= (uint32)ipv4_header->ecn << 16;
    }
    if(ipv4_header->dscp) {
        buffer[4] |= (uint32)ipv4_header->dscp << 16;
    }
    buffer[4] |= (uint32)ipv4_header->internet_header_length << 24;
    buffer[4] |= (uint32)ipv4_header->version << 28;
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_ipv6_header_to_buffer(_bcm_petra_field_test_ipv6_header_t *ipv6_header, uint32 *buffer){
    int unit = BSL_UNIT_UNKNOWN;
    
    if(ipv6_header->flow_label > 0xfffff){
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(ipv6_header->version > 0xf) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    
    ip6_to_buffer(ipv6_header->destination_address, buffer);
    ip6_to_buffer(ipv6_header->source_address, &buffer[4]);
    buffer[8] = ipv6_header->hop_limit;
    buffer[8] |= ipv6_header->next_header << 8;
    buffer[8] |= ipv6_header->payload_length << 16;
    buffer[9] = ipv6_header->flow_label;
    buffer[9] |= ipv6_header->traffic_class << 20;
    buffer[9] |= ipv6_header->version << 28;
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_mpls_header_to_buffer(_bcm_petra_field_test_mpls_header_t *mpls_header, uint32 *buffer)
{
    int unit = BSL_UNIT_UNKNOWN;
    
    if(mpls_header->bos > 1) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(mpls_header->exp > 0x7) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    if(mpls_header->label > 0xfffff) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    *buffer = mpls_header->time_to_live;
    *buffer |= mpls_header->bos << 8;
    *buffer |= mpls_header->exp << 9;
    *buffer |= mpls_header->label << 12;
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_buffer_to_mpls_header(uint32 value, _bcm_petra_field_test_mpls_header_t *mpls_header)
{
    mpls_header->time_to_live = value & 0xff;
    mpls_header->bos = (value >> 8) & 0x1;
    mpls_header->exp  = (value >> 9) & 0x7;
    mpls_header->label  = value >> 12;
    
    return 0;
}

STATIC uint8 _bcm_petra_field_test_tcp_header_to_buffer(_bcm_petra_field_test_tcp_header_t *tcp_header, uint32 *buffer)
{
    int unit = BSL_UNIT_UNKNOWN;
    
    if(tcp_header->control > 0x3f) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return 1;
    }
    
    sal_memset(buffer, 0x0, 20);
    
    buffer[1] |= tcp_header->control << 16;
    buffer[4] = tcp_header->destination_port;
    buffer[4] |= tcp_header->source_port << 16;
    
    return 0;
}

/* for fliping only one bit to cause not match and then not hitting */
STATIC uint8 first_set_bit_ndx(uint32 mask)
{
    uint8 ndx = 0;

    if(mask == 0) {
        return 0xff;
    }
    
    while((mask & 0x1) == 0)
    {
        mask >>= 1;
        ++ndx;
    }
    return ndx;
}

/* If we wand to use the qualifier MplsLabel2XXX, we can't expect MplsLabel1Bos to be true.
  If so, changing the data of the qualifier MplsLabel1Bos. The same if we want to use MplsLabel3XXX
  idx can be 1 or 2 */
  
STATIC cmd_result_t _bcm_petra_field_reset_MplsLabelXBos_assert(int unit,
                                                                _bcm_dpp_field_stage_idx_t stage,
                                                                uint8 idx,
                                                                uint8 is_predefined,
                                                                bcm_field_group_t fg_id,
                                                                _bcm_petra_field_test_entry_info_t *entry)
{
    uint32 qual_idx;
    uint8 should_reinstall = FALSE;
    bcm_error_t rv;
    uint32 action_index;

    const static bcm_field_qualify_t relevant_qualifier_bos[] = {-1, bcmFieldQualifyMplsLabel1Bos, bcmFieldQualifyMplsLabel2Bos};
    const static bcm_field_qualify_t relevant_qualifier_all[] = {-1, bcmFieldQualifyMplsLabel1, bcmFieldQualifyMplsLabel2};
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].qualify == relevant_qualifier_bos[idx]) {
            if (entry->quals_info[qual_idx].data[0] == 1 &&  entry->quals_info[qual_idx].mask[0] == 1) {
            /* i.e. The first mpls should be the last */
                if(is_predefined) {
                    return CMD_NOTIMPL;
                } else {
                    entry->quals_info[qual_idx].data[0] = 0;
                    should_reinstall = TRUE;
                    break;
                }
            }
        } else if(entry->quals_info[qual_idx].qualify == relevant_qualifier_all[idx]) {
            if ((entry->quals_info[qual_idx].data[0] & (1 << 8) ) &&  (entry->quals_info[qual_idx].mask[0] & (1 << 8)) ) {
            /* i.e. The first mpls should be the last ,because of the Bos bit is set*/
                if(is_predefined) {
                    return CMD_NOTIMPL;
                } else {
                    entry->quals_info[qual_idx].data[0] &= ~(1 << 8);
                    should_reinstall = TRUE;
                    break;
                }
            }
        }
    }
    if(should_reinstall) {
        rv = bcm_field_entry_destroy(unit, entry->id);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        rv = bcm_field_entry_create(unit, fg_id, &entry->id);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
            if(entry->quals_info[qual_idx].is_valid) {
                _bcm_petra_field_test_operate_set_function(unit,
                                                           stage,
                                                           _BCM_PETRA_FIELD_TYPE_MPLS,
                                                           entry->id,
                                                           entry->quals_info[qual_idx].qualify,
                                                           entry->quals_info[qual_idx].data,
                                                           entry->quals_info[qual_idx].mask);
            }
        }
        for(action_index = 0; action_index < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_index) {
            if(entry->actions_info[action_index].is_valid) {
                rv = bcm_field_action_add(unit,
                                          entry->id,
                                          entry->actions_info[action_index].action,
                                          entry->actions_info[action_index].param0,
                                          entry->actions_info[action_index].param1);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
        }
        rv = bcm_field_entry_install(unit, entry->id);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    return CMD_OK;
}


STATIC uint8 ip_protocol_common_to_protocol_id(bcm_field_IpProtocolCommon_t bcm_protocol_common, uint8 *protocol)
{
    int unit = BSL_UNIT_UNKNOWN;
    
    switch(bcm_protocol_common) {
        case bcmFieldIpProtocolCommonTcp:
            *protocol = 6;
            break;
        case bcmFieldIpProtocolCommonUdp:
            *protocol = 17;
            break;
        case bcmFieldIpProtocolCommonIgmp:
            *protocol = 2;
            break;
        case bcmFieldIpProtocolCommonIcmp:
            *protocol = 1;
            break;
        case bcmFieldIpProtocolCommonIp6Icmp:
            *protocol = 58;
            break;
        case bcmFieldIpProtocolCommonIp6HopByHop:
            *protocol = 0;
            break;
        case bcmFieldIpProtocolCommonIpInIp:
            *protocol = 4;
            break;
        case bcmFieldIpProtocolCommonTcpUdp:
            *protocol = 6; /* we choose TCP */
            break;
        case bcmFieldIpProtocolCommonUnknown:
            *protocol = 5;/* this is the choose */
            break;
        case bcmFieldIpProtocolCommonIp6InIp:
            *protocol = 0x29;
            break;
        case bcmFieldIpProtocolCommonMplsInIp:
            *protocol = 0x89;
            break;
        default:
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
    }
    
    return 0;
}

STATIC uint8 ip_protocol_common_to_protocol_id_mismatch(bcm_field_IpProtocolCommon_t bcm_protocol_common, uint8 *protocol)
{
    int unit = BSL_UNIT_UNKNOWN;
    
    switch(bcm_protocol_common) {
        case bcmFieldIpProtocolCommonTcp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonUdp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonIgmp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonIcmp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonIp6Icmp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonIp6HopByHop:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonIpInIp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonTcpUdp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonUnknown:
            *protocol = 6;/* tcp */
            break;
        case bcmFieldIpProtocolCommonIp6InIp:
            *protocol = 5;
            break;
        case bcmFieldIpProtocolCommonMplsInIp:
            *protocol = 5;
            break;
        default:
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
    }
    
    return 0;
}

STATIC uint8 ip_type_to_ethertype_id(bcm_field_IpType_t bcm_ip_type, uint16 *ethertype) {
    int unit = BSL_UNIT_UNKNOWN;
    
    switch(bcm_ip_type) {
        case bcmFieldIpTypeIpv4Any:
            *ethertype = 0x800;
            break;
        case bcmFieldIpTypeIpv6:
            *ethertype = 0x86dd;
            break;
        case bcmFieldIpTypeArp:
            *ethertype = 0x0806;
            break;
        case bcmFieldIpTypeTrill:
            *ethertype = 0xfefe;
            break;
        case bcmFieldIpTypeMim:
            *ethertype = 0x88e7;
            break;
        case bcmFieldIpTypeMplsUnicast:
            *ethertype = 0x8847;
            break;
        case bcmFieldIpTypeAny:
            *ethertype = 0x801;
            break;
        default:
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
    }
    return 0;
}

STATIC uint8 ip_type_to_ethertype_id_mismatch(bcm_field_IpType_t bcm_ip_type, uint16 *ethertype) {
    int unit = BSL_UNIT_UNKNOWN;
    
    switch(bcm_ip_type) {
        case bcmFieldIpTypeIpv4Any:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeIpv6:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeArp:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeTrill:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeMim:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeMplsUnicast:
            *ethertype = 0x801;
            break;
        case bcmFieldIpTypeAny:
            *ethertype = 0x800;
            break;
        default:
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return 1;
    }
    return 0;
}

/* Build packet for data qualifiers.
 * We assume that we have ipv4 Other ipv6 other ethernet
 */
STATIC cmd_result_t _bcm_petra_field_test_data_qualifiers_build_packet(int unit,
                                                                       _bcm_petra_field_test_entry_info_t *entry,
                                                                       uint8 should_hit,
                                                                       uint32 *buffer)
{
    /* in the case we want not hit, if all the masks are 0 it may hit anyway */
    uint8 may_not_hit = FALSE;
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    _bcm_petra_field_test_ipv4_header_t ipv4_header;
    _bcm_petra_field_test_ipv6_header_t ipv6_header;
    uint32 qual_idx;
    uint32 tmp_data;
    uint32 tmp_buffer[10];
    bcm_field_data_qualifier_t dq;
    bcm_error_t rv;
    uint32 dq_offset_addition;   

    sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
    sal_memset(&ipv4_header, 0x0, sizeof(ipv4_header));
    sal_memset(&ipv6_header, 0x0, sizeof(ipv6_header));

    sal_memset(buffer, 0xa5, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
    /* The headers will override part of the payload latter */

    ethernet_header.ethertype = 0x86dd; /* ipv6 */
    ethernet_header.nof_vlans = 1;
    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
    
    /* s.a. != 0 */    
    mac_to_buffer(ethernet_header.destination_address, tmp_buffer);
    tmp_buffer[0] = 0x1;
    buffer_to_mac(tmp_buffer, &ethernet_header.destination_address);
    
    ipv6_header.version = 6;
    ipv6_header.payload_length = _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - 60 - 14 - 4 * ethernet_header.nof_vlans; 
    ipv6_header.next_header = 4; /* ipv4 */
    
    ipv4_header.version = 4;
    ipv4_header.internet_header_length = 0x5;
    
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ipv4_header_to_buffer(&ipv4_header, tmp_buffer)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
            - 320
            - 160,
        tmp_buffer,
        0,
        160);

    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ipv6_header_to_buffer(&ipv6_header, tmp_buffer)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
            - 320,
        tmp_buffer,
        0,
        320);
                        
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ethernet_header_to_buffer(&ethernet_header, tmp_buffer)) {
        return CMD_FAIL;
    }
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */,
        tmp_buffer,
        0,
        112 + 32*ethernet_header.nof_vlans);
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].is_valid) {
            bcm_field_data_qualifier_t_init(&dq);
            rv = bcm_field_data_qualifier_get(unit, entry->quals_info[qual_idx].qualify, &dq);
            if (rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if(dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) {
                dq.offset /= 8;
            } 
            if(dq.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) {
                dq.length /= 8;
            }
            
            /* allign the offset to refers the ethernet */
            if(dq.offset_base == bcmFieldDataOffsetBaseFirstHeader) {
                dq_offset_addition= 18;
            } else if(dq.offset_base == bcmFieldDataOffsetBaseSecondHeader) {
                dq_offset_addition = 58;
            } else if(dq.offset_base == bcmFieldDataOffsetBaseThirdHeader) {
                /* in case of negative offset */
                dq_offset_addition = 78;
            } else {
                dq_offset_addition = 0;
            }
            if(dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE) {
                SHR_BITCOPY_RANGE(buffer, (_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) + dq.offset - dq_offset_addition - dq.length)*8,
                    entry->quals_info[qual_idx].data, 0, 8 * dq.length);
            } else {
                SHR_BITCOPY_RANGE(buffer, (_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - dq.offset - dq_offset_addition - dq.length)*8,
                    entry->quals_info[qual_idx].data, 0, 8 * dq.length);
            }
        }
    }

    if(!should_hit) {
        for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx)
        {
            if(entry->quals_info[qual_idx].is_valid && entry->quals_info[qual_idx].mask[0]) {
                bcm_field_data_qualifier_t_init(&dq);
                rv = bcm_field_data_qualifier_get(unit, entry->quals_info[qual_idx].qualify, &dq);
                if (rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) {
                    dq.offset /= 8;
                } 
                if(dq.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) {
                    dq.length /= 8;
                }
            
                /* allign the offset to refers the ethernet */
                if(dq.offset_base == bcmFieldDataOffsetBaseFirstHeader) {
                    dq_offset_addition= 18;
                } else if(dq.offset_base == bcmFieldDataOffsetBaseSecondHeader) {
                    dq_offset_addition = 58;
                } else if(dq.offset_base == bcmFieldDataOffsetBaseThirdHeader) {
                    /* in case of negative offset */
                    dq_offset_addition = 78;
                } else {
                    dq_offset_addition = 0;
                }
                tmp_data = entry->quals_info[qual_idx].data[0];
                tmp_data ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                if(dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE) {
                    SHR_BITCOPY_RANGE(buffer, (_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) + dq.offset - dq_offset_addition - dq.length)*8,
                        &tmp_data, 0, 8 * dq.length);
                } else {
                    SHR_BITCOPY_RANGE(buffer, (_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - dq.offset - dq_offset_addition - dq.length)*8,
                        &tmp_data, 0, 8 * dq.length);
                }
                may_not_hit = TRUE;
            }
                        
            if(may_not_hit) {
                break;
            }            
        }
    }
    
    if(!should_hit && !may_not_hit) {
        return CMD_NOTIMPL;
    }

    return CMD_OK;
}

/* This function takes entry, and according to the qualifiers build packet in buffer that may hit or not according to should_hit
 * The buffer filled such that buffer[0] contains the 32 lsb bits etc.
 */
STATIC cmd_result_t _bcm_petra_field_test_build_packet(int unit,
                                                       _bcm_dpp_field_stage_idx_t stage,
                                                       bcm_field_group_t fg_id,
                                                       _bcm_petra_field_test_entry_info_t *entry,
                                                       uint8 should_hit,
                                                       uint8 is_predefined,
                                                       uint32 *buffer)
{
    /* in the case we want not hit, if all the masks are 0 it may hit anyway */
    uint8 may_not_hit = FALSE;
    
    uint32 qual_idx;
    uint32 tmp_buffer[10];    
    _bcm_petra_field_test_ethernet_header_t ethernet_header, inner_ethernet_header;
    _bcm_petra_field_test_ipv4_header_t ipv4_header, inner_ipv4_header;
    uint8 is_ipv4 = FALSE;
    _bcm_petra_field_test_ipv6_header_t ipv6_header;
    uint8 is_ipv6 = FALSE;
    _bcm_petra_field_test_mpls_header_t mpls_header;
    _bcm_petra_field_test_mpls_header_t mpls_header2, mpls_header3;
    uint8 is_mpls = FALSE;
    uint8 nof_mpls = 0;
    soc_port_t port_number;

    
    _bcm_petra_field_test_tcp_header_t tcp_header;
    uint8 has_tcp = FALSE;
    uint8 has_inner_ipv4 = FALSE;/* if we wand ipv4 over ipv4 over ethernet */
    uint8 has_ipv4 = FALSE;/* if we wand ipv4 over ipv6 */
    uint8 has_inner_ethernet = FALSE;
    cmd_result_t result;
    uint32 tmp_data[4];
    
    if(entry->quals_info[0].is_undefined) {
        return _bcm_petra_field_test_data_qualifiers_build_packet(unit, entry, should_hit, buffer);
    }
    
    sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
    sal_memset(&inner_ethernet_header, 0x0, sizeof(inner_ethernet_header));
    sal_memset(&ipv4_header, 0x0, sizeof(ipv4_header));
    sal_memset(&inner_ipv4_header, 0x0, sizeof(inner_ipv4_header));
    sal_memset(&ipv6_header, 0x0, sizeof(ipv6_header));
    sal_memset(&mpls_header, 0x0, sizeof(mpls_header));
    sal_memset(&mpls_header2, 0x0, sizeof(mpls_header2));
    sal_memset(&mpls_header3, 0x0, sizeof(mpls_header3));
    sal_memset(&tcp_header, 0x0, sizeof(tcp_header));

    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp4) {
            is_ipv4 = TRUE;
            break;
        } else if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp6) {
            is_ipv6 = TRUE;
            break;
        } else if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyMpls) {
            is_mpls = TRUE;
            nof_mpls = 1;
            break;
        }
    }    
    if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].is_valid) {
            switch(entry->quals_info[qual_idx].qualify)
            {
                case bcmFieldQualifySrcIp6:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    buffer_to_ip6(entry->quals_info[qual_idx].data, &ipv6_header.source_address);
                    break;
                case bcmFieldQualifyDstIp6:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    buffer_to_ip6(entry->quals_info[qual_idx].data, &ipv6_header.destination_address);
                    break;
                case bcmFieldQualifySrcIp6High:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    tmp_data[0] = 0;
                    tmp_data[1] = 0;
                    tmp_data[2] = entry->quals_info[qual_idx].data[0];
                    tmp_data[3] = entry->quals_info[qual_idx].data[1];
                    buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                    break;
                case bcmFieldQualifyDstIp6High:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    tmp_data[0] = 0;
                    tmp_data[1] = 0;
                    tmp_data[2] = entry->quals_info[qual_idx].data[0];
                    tmp_data[3] = entry->quals_info[qual_idx].data[1];
                    buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                    break;
                case bcmFieldQualifySrcIp6Low:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ip6_to_buffer(ipv6_header.source_address, tmp_data);
                    tmp_data[0] = entry->quals_info[qual_idx].data[0];
                    tmp_data[1] = entry->quals_info[qual_idx].data[1];
                    buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                    break;
                case bcmFieldQualifyDstIp6Low:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ip6_to_buffer(ipv6_header.destination_address, tmp_data);
                    tmp_data[0] = entry->quals_info[qual_idx].data[0];
                    tmp_data[1] = entry->quals_info[qual_idx].data[1];
                    buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                    break;
                case bcmFieldQualifySrcIp:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ipv4_header.source_address = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyDstIp:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ipv4_header.destination_address = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyIp6FlowLabel:
                    if(!is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ipv6_header.flow_label = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyIpProtocol:
                /* also bcmFieldQualifyIp6NextHeader */
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        ipv4_header.protocol = entry->quals_info[qual_idx].data[0];
                    } else {
                        ipv6_header.next_header = entry->quals_info[qual_idx].data[0];
                    }
                    break;
                case bcmFieldQualifyDSCP:
                /* also bcmFieldQualifyTos
                 and bcmFieldQualifyIp6TrafficClass */
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        ipv4_header.dscp = entry->quals_info[qual_idx].data[0];
                    } else {
                        ipv6_header.traffic_class = entry->quals_info[qual_idx].data[0];
                    }
                    break;
                case bcmFieldQualifyTtl:
                /* also bcmFieldQualifyIp6HopLimit */
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        ipv4_header.time_to_live = entry->quals_info[qual_idx].data[0];
                    } else {
                        ipv6_header.hop_limit = entry->quals_info[qual_idx].data[0];
                    }
                    break;
                case bcmFieldQualifyEcnValue:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    ipv4_header.ecn = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyMplsBos:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.bos = entry->quals_info[qual_idx].data[0];
                    if(entry->quals_info[qual_idx].data[0] == 0 && entry->quals_info[qual_idx].mask[0] == 1) {
                        /* in this case we should have 3 mpls headers and all of them should have 0 in the Bos */
                        nof_mpls = 3;
                        mpls_header2.bos = 0;
                        mpls_header3.bos = 0;
                    }
                    break;
                case bcmFieldQualifyMplsLabel1:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    _bcm_petra_field_test_buffer_to_mpls_header(entry->quals_info[qual_idx].data[0], &mpls_header);
                    break;
                case bcmFieldQualifyMplsLabel1Ttl:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.time_to_live = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyMplsLabel1Bos:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.bos = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyMplsLabel1Exp:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.exp = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyMplsLabel1Id:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.label = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyMplsLabel2:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    _bcm_petra_field_test_buffer_to_mpls_header(entry->quals_info[qual_idx].data[0], &mpls_header2);
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    break;
                case bcmFieldQualifyMplsLabel2Ttl:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header2.time_to_live = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    break;
                case bcmFieldQualifyMplsLabel2Bos:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header2.bos = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    break;
                case bcmFieldQualifyMplsLabel2Exp:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header2.exp = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    break;
                case bcmFieldQualifyMplsLabel2Id:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header2.label = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    break;
                case bcmFieldQualifyMplsLabel3:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    _bcm_petra_field_test_buffer_to_mpls_header(entry->quals_info[qual_idx].data[0], &mpls_header3);
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    if(nof_mpls < 3) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 2, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header2.bos = 0;
                        nof_mpls = 3;
                    }
                    break;
                case bcmFieldQualifyMplsLabel3Ttl:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header3.time_to_live = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    if(nof_mpls < 3) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 2, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header2.bos = 0;
                        nof_mpls = 3;
                    }
                    break;
                case bcmFieldQualifyMplsLabel3Bos:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header3.bos = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    if(nof_mpls < 3) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 2, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header2.bos = 0;
                        nof_mpls = 3;
                    }
                    break;
                case bcmFieldQualifyMplsLabel3Exp:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header3.exp = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    if(nof_mpls < 3) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 2, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header2.bos = 0;
                        nof_mpls = 3;
                    }
                    break;
                case bcmFieldQualifyMplsLabel3Id:
                    if(!is_mpls) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header3.label = entry->quals_info[qual_idx].data[0];
                    if(nof_mpls < 2) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 1, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header.bos = 0;
                        nof_mpls = 2;
                    }
                    if(nof_mpls < 3) {
                        result = _bcm_petra_field_reset_MplsLabelXBos_assert(unit, stage, 2, is_predefined, fg_id, entry);
                        if(result != CMD_OK) {
                            if(result != CMD_NOTIMPL) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            }
                            return result;
                        }
                        mpls_header2.bos = 0;
                        nof_mpls = 3;
                    }
                    break;
                case bcmFieldQualifySrcMac:
                    buffer_to_mac(entry->quals_info[qual_idx].data, &ethernet_header.source_address);
                    break;
                case bcmFieldQualifyDstMac:
                    if(entry->quals_info[qual_idx].data[0] == 0 && entry->quals_info[qual_idx].data[1] == 0 && should_hit) {
                        uint32 tmp_address[2];
                        tmp_address[0] = 0;
                        tmp_address[1] = 0;
                        if(~entry->quals_info[qual_idx].mask[0]) {
                            tmp_address[0] ^= 1 << first_set_bit_ndx(~entry->quals_info[qual_idx].mask[0]);
                        } else {
                            tmp_address[1] ^= 1 << first_set_bit_ndx(~entry->quals_info[qual_idx].mask[1]);
                        }
                        buffer_to_mac(tmp_address, &ethernet_header.destination_address);
                    } else {
                        buffer_to_mac(entry->quals_info[qual_idx].data, &ethernet_header.destination_address);
                    }                        
                    break;
                case bcmFieldQualifyInnerVlan:
                    if(ethernet_header.nof_vlans < 2){
                        ethernet_header.nof_vlans = 2;
                    }
                    ethernet_header.vlans[1].vlan_id = entry->quals_info[qual_idx].data[0] & 0xfff;
                    ethernet_header.vlans[1].cfi = (entry->quals_info[qual_idx].data[0] >> 12) & 0x1;
                    ethernet_header.vlans[1].pri = (entry->quals_info[qual_idx].data[0] >> 13) & 0x7;
                    ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                    break;
                case bcmFieldQualifyInnerVlanId:
                    if(ethernet_header.nof_vlans < 2){
                        ethernet_header.nof_vlans = 2;
                    }
                    ethernet_header.vlans[1].vlan_id = entry->quals_info[qual_idx].data[0];
                    ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                    break;
                case bcmFieldQualifyInnerVlanPri:
                    if(ethernet_header.nof_vlans < 2){
                        ethernet_header.nof_vlans = 2;
                    }
                    ethernet_header.vlans[1].pri = entry->quals_info[qual_idx].data[0];
                    ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                    break;
                case bcmFieldQualifyInnerVlanCfi:
                    if(ethernet_header.nof_vlans < 2){
                        ethernet_header.nof_vlans = 2;
                    }
                    ethernet_header.vlans[1].cfi = entry->quals_info[qual_idx].data[0];
                    ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                    break;
                case bcmFieldQualifyInnerTpid:
                    if(ethernet_header.nof_vlans < 2){
                        ethernet_header.nof_vlans = 2;
                    }
                    if(!is_predefined){
                        if(entry->quals_info[qual_idx].data[0] != 0x8100) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "The value of the Inner Tpid must be 0x8100.\n")));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                    } else {
                        if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) != (0x8100 & entry->quals_info[qual_idx].mask[0]) ){
                            return CMD_NOTIMPL;
                        }
                    }
                    ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                    break;
                case bcmFieldQualifyOuterVlan:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    ethernet_header.vlans[0].vlan_id = entry->quals_info[qual_idx].data[0] & 0xfff;
                    ethernet_header.vlans[0].cfi = (entry->quals_info[qual_idx].data[0] >> 12) & 0x1;
                    ethernet_header.vlans[0].pri = (entry->quals_info[qual_idx].data[0] >> 13) & 0x7;
                    break;
                case bcmFieldQualifyOuterVlanId:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    ethernet_header.vlans[0].vlan_id = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyForwardingVlanId:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    ethernet_header.vlans[0].vlan_id = 0x1;
                    if(is_predefined && (entry->quals_info[qual_idx].data[0] != 0x1 || entry->quals_info[qual_idx].mask[0] != 0x1)){
                        return CMD_NOTIMPL;
                    }
                    if(!is_predefined) {
                        if(bcm_petra_field_qualify_ForwardingVlanId(unit, entry->id, 0x1, 0x1) != BCM_E_NONE ){
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                        if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                    }
                    break;
                case bcmFieldQualifyOuterVlanPri:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    ethernet_header.vlans[0].pri = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyOuterVlanCfi:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    ethernet_header.vlans[0].cfi = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyOuterTpid:
                    if(ethernet_header.nof_vlans < 1){
                        ethernet_header.nof_vlans = 1;
                        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                    }
                    if(!is_predefined) {
                        if(entry->quals_info[qual_idx].data[0] != 0x8100 && entry->quals_info[qual_idx].data[0] != 0x9100) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "The value of the Outer Tpid must be 0x8100 if no Inner Vlan.\n")));
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     " and must be 0x9100 if There is Inner Vlan.\n")));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                        if(ethernet_header.nof_vlans == 1 && entry->quals_info[qual_idx].data[0] != 0x8100 && should_hit) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "Changing the data of the qualifier OuterTpid to 0x8100.\n")));
                            }
                            if(bcm_field_qualify_OuterTpid(unit, entry->id, 0x8100) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            entry->quals_info[qual_idx].data[0] = 0x8100;
                            ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                        } else if(ethernet_header.nof_vlans == 2 && entry->quals_info[qual_idx].data[0] != 0x9100 && should_hit) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "Changing the data of the qualifier OuterTpid to 0x9100.\n")));
                            }
                            if(bcm_field_qualify_OuterTpid(unit, entry->id, 0x9100) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            entry->quals_info[qual_idx].data[0] = 0x9100;
                            ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                        }
                    } else {
                        if(ethernet_header.nof_vlans == 1 && should_hit) {
                            if( (entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) == (0x8100 & entry->quals_info[qual_idx].mask[0]) ) {
                                ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                            } else {
                                return CMD_NOTIMPL;
                            }
                        } else if(ethernet_header.nof_vlans == 2 && should_hit) {
                            if( (entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) == (0x9100 & entry->quals_info[qual_idx].mask[0]) ) {
                                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                            } else {
                                return CMD_NOTIMPL;
                            }
                        }
                    }
                    break;
                case bcmFieldQualifyEtherType:
                    ethernet_header.ethertype = entry->quals_info[qual_idx].data[0];
                    {
                        uint32 tmp_bit_can_be_changed = entry->quals_info[qual_idx].mask[0];
                        while(tmp_bit_can_be_changed &&
                            (ethernet_header.ethertype == 0x8100
                            || ethernet_header.ethertype == 0x88a8
                            || ethernet_header.ethertype == 0x9100
                            || ethernet_header.ethertype == 0x9200
                            || ethernet_header.ethertype == 0x9300
                            || ethernet_header.ethertype < 0x5dd) )
                        {
                            ethernet_header.ethertype ^= 1 << first_set_bit_ndx(tmp_bit_can_be_changed);
                            tmp_bit_can_be_changed ^= 1 << first_set_bit_ndx(tmp_bit_can_be_changed);
                        }
                    }
                    if (ethernet_header.ethertype == 0x8100
                        || ethernet_header.ethertype == 0x88a8
                        || ethernet_header.ethertype == 0x9100
                        || ethernet_header.ethertype == 0x9200
                        || ethernet_header.ethertype == 0x9300
                        || ethernet_header.ethertype < 0x5dd) {
                        return CMD_NOTIMPL;
                    }
                    if(is_ipv4) {
                        if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) !=
                            (0x800 & entry->quals_info[qual_idx].mask[0]) ) {
                            entry->quals_info[qual_idx].data[0] = 0x800;
                            entry->quals_info[qual_idx].mask[0] = 0xffff;
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "Changing the data of the qualifier EtherType to 0x800 and the mask to 0xffff.\n")));
                            }
                            if(bcm_field_qualify_EtherType(unit,
                                                           entry->id,
                                                           entry->quals_info[qual_idx].data[0],
                                                           entry->quals_info[qual_idx].mask[0]) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        }
                    } else if (is_ipv6) {
                        if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) !=
                            (0x86dd & entry->quals_info[qual_idx].mask[0]) ) {
                            entry->quals_info[qual_idx].data[0] = 0x86dd;
                            entry->quals_info[qual_idx].mask[0] = 0xffff;
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "Changing the data of the qualifier EtherType to 0x86dd and the mask to 0xffff.\n")));
                            }
                            if(bcm_field_qualify_EtherType(unit,
                                                           entry->id,
                                                           entry->quals_info[qual_idx].data[0],
                                                           entry->quals_info[qual_idx].mask[0]) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        }
                    } else if (is_mpls) {
                        if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) !=
                            (0x8847 & entry->quals_info[qual_idx].mask[0]) ) {
                            entry->quals_info[qual_idx].data[0] = 0x8847;
                            entry->quals_info[qual_idx].mask[0] = 0xffff;
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "Changing the data of the qualifier EtherType to 0x8847 and the mask to 0xffff.\n")));
                            }
                            if(bcm_field_qualify_EtherType(unit,
                                                           entry->id,
                                                           entry->quals_info[qual_idx].data[0],
                                                           entry->quals_info[qual_idx].mask[0]) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        }
                    }
                    break;
                case bcmFieldQualifyIpProtocolCommon:
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        if(ip_protocol_common_to_protocol_id(entry->quals_info[qual_idx].data[0], &ipv4_header.protocol)) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                    } else {
                        if(ip_protocol_common_to_protocol_id(entry->quals_info[qual_idx].data[0], &ipv6_header.next_header)) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                    }
                    break;
                case bcmFieldQualifyIpType:
                    if(ip_type_to_ethertype_id(entry->quals_info[qual_idx].data[0], &ethernet_header.ethertype)) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    break;
                case bcmFieldQualifyIpFrag:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if((entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNon) ||
                       (SOC_IS_JERICHO(unit) && (soc_property_get(unit, spn_FIELD_IP_FIRST_FRAGMENT_PARSED, TRUE)) && (entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNonOrFirst)) ) {
                        ipv4_header.flags = 0x2;/* not fragmented */
                    } else if ((entry->quals_info[qual_idx].data[0] == bcmFieldIpFragAny) ||
                       (SOC_IS_JERICHO(unit) && (soc_property_get(unit, spn_FIELD_IP_FIRST_FRAGMENT_PARSED, TRUE)) && (entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNotFirst)) ) {
                        ipv4_header.flags = 0x0;/* fragmented */
                        ipv4_header.fragment_offset = 1480;
                    }
                    break;
                case bcmFieldQualifyTcpControl:
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    has_tcp = TRUE;
                    tcp_header.control = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyL4SrcPort:
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    has_tcp = TRUE;
                    tcp_header.source_port = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyL4DstPort:
                    if(!is_ipv4 && !is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    has_tcp = TRUE;
                    tcp_header.destination_port = entry->quals_info[qual_idx].data[0];
                    break;
                case bcmFieldQualifyInnerSrcIp:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    inner_ipv4_header.source_address = entry->quals_info[qual_idx].data[0];
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                    break;
                case bcmFieldQualifyInnerDstIp:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    inner_ipv4_header.destination_address = entry->quals_info[qual_idx].data[0];
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                    break;
                case bcmFieldQualifyInnerTtl:
                /* also bcmFieldQualifyInnerIp6HopLimit */
                    if(!is_ipv4 && ! is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        inner_ipv4_header.time_to_live = entry->quals_info[qual_idx].data[0];
                        has_inner_ipv4 = TRUE;
                        ipv4_header.protocol = 4;
                    } else {
                        ipv6_header.hop_limit = entry->quals_info[qual_idx].data[0];
                        has_ipv4 = TRUE;
                        ipv4_header.protocol = 0x29;
                    } 
                    break;
                case bcmFieldQualifyInnerIpProtocol:
                /* also bcmFieldQualifyInnerIp6NextHeader */
                    if(!is_ipv4 && ! is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        inner_ipv4_header.protocol = entry->quals_info[qual_idx].data[0];
                        has_inner_ipv4 = TRUE;
                        ipv4_header.protocol = 4;
                    } else {
                        ipv6_header.next_header = entry->quals_info[qual_idx].data[0];
                        has_ipv4 = TRUE;
                        ipv4_header.protocol = 0x29;
                    } 
                    break;
                case bcmFieldQualifyInnerTos:
                /* also bcmFieldQualifyInnerDSCP
                    and bcmFieldQualifyInnerIp6TrafficClass */
                    if(!is_ipv4 && ! is_ipv6) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(is_ipv4) {
                        inner_ipv4_header.dscp = entry->quals_info[qual_idx].data[0];
                        has_inner_ipv4 = TRUE;
                        ipv4_header.protocol = 4;
                    } else {
                        ipv6_header.traffic_class = entry->quals_info[qual_idx].data[0];
                        has_ipv4 = TRUE;
                        ipv4_header.protocol = 0x29;
                    } 
                    break;
                case bcmFieldQualifyInnerIpFrag:
                    if(!is_ipv4) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                    if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNon) {
                        inner_ipv4_header.flags = 0x2;/* not fragmented */
                    } else if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragAny) {
                        inner_ipv4_header.flags = 0x0;/* fragmented */
                        inner_ipv4_header.fragment_offset = 5;
                    }
                    break;
                case bcmFieldQualifyInnerSrcMac:
                    if(!is_mpls || nof_mpls > 1) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.bos = 1;
                    has_inner_ethernet = TRUE;
                    buffer_to_mac(entry->quals_info[qual_idx].data, &inner_ethernet_header.source_address);
                    break;
                case bcmFieldQualifyInnerDstMac:
                    if(!is_mpls || nof_mpls > 1) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.bos = 1;
                    has_inner_ethernet = TRUE;
                    buffer_to_mac(entry->quals_info[qual_idx].data, &inner_ethernet_header.destination_address);
                    break;
                case bcmFieldQualifyInnerEtherType:
                    if(!is_mpls || nof_mpls > 1) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    mpls_header.bos = 1;
                    inner_ethernet_header.ethertype = entry->quals_info[qual_idx].data[0];
                    break;                  
                case bcmFieldQualifyInterfaceClassProcessingPort:
                    {
                        bcm_port_class_t pclass;
                        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                            pclass = bcmPortClassFieldIngressPacketProcessing;
                        } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
                            pclass = bcmPortClassFieldEgressPacketProcessing;
                        } else {
                            pclass = bcmPortClassFieldLookup;
                        }
                        
                        if(bcm_port_class_set(unit,
                                              port_number,
                                              pclass,
                                              entry->quals_info[qual_idx].data[0]) != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                    }
                    break;
                case bcmFieldQualifyInterfaceClassPort:
                    if(bcm_port_class_set(unit,
                                          port_number,
                                          bcmPortClassFieldIngress,
                                          entry->quals_info[qual_idx].data[0]) != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    break;
                default:
                    break;/* do nothing */
            }
        }
    }

    if(!should_hit) {
        for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx)
        {
            if(entry->quals_info[qual_idx].is_valid) {
                switch(entry->quals_info[qual_idx].qualify)
                {
                    case bcmFieldQualifySrcIp6:
                        {
                            int j;
                            for(j = 0; j < 4; ++j) {
                                if(entry->quals_info[qual_idx].mask[j]) {
                                    ip6_to_buffer(ipv6_header.source_address, tmp_data);
                                    tmp_data[j] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[j]);
                                    buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                                    may_not_hit = TRUE;
                                    break;
                                }
                            }
                        }
                        break;
                    case bcmFieldQualifyDstIp6:
                        {
                            int j;
                            for(j = 0; j < 4; ++j) {
                                if(entry->quals_info[qual_idx].mask[j]) {
                                    ip6_to_buffer(ipv6_header.destination_address, tmp_data);
                                    tmp_data[j] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[j]);
                                    buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                                    may_not_hit = TRUE;
                                    break;
                                }
                            }
                        }
                        break;
                    case bcmFieldQualifySrcIp6High:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            ip6_to_buffer(ipv6_header.source_address, tmp_data);
                            tmp_data[2] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                            may_not_hit = TRUE;
                        } else if(entry->quals_info[qual_idx].mask[1]) {
                            ip6_to_buffer(ipv6_header.source_address, tmp_data);
                            tmp_data[3] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[1]);
                            buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                            may_not_hit = TRUE;
                        } 
                        break;
                    case bcmFieldQualifyDstIp6High:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            ip6_to_buffer(ipv6_header.destination_address, tmp_data);
                            tmp_data[2] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                            may_not_hit = TRUE;
                        } else if(entry->quals_info[qual_idx].mask[1]) {
                            ip6_to_buffer(ipv6_header.destination_address, tmp_data);
                            tmp_data[3] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[1]);
                            buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                            may_not_hit = TRUE;
                        } 
                        break;
                    case bcmFieldQualifySrcIp6Low:
                        {
                            int j;
                            for(j = 0; j < 2; ++j) {
                                if(entry->quals_info[qual_idx].mask[j]) {
                                    ip6_to_buffer(ipv6_header.source_address, tmp_data);
                                    tmp_data[j] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[j]);
                                    buffer_to_ip6(tmp_data, &ipv6_header.source_address);
                                    may_not_hit = TRUE;
                                    break;
                                }
                            }
                        }
                        break;
                    case bcmFieldQualifyDstIp6Low:
                        {
                            int j;
                            for(j = 0; j < 2; ++j) {
                                if(entry->quals_info[qual_idx].mask[j]) {
                                    ip6_to_buffer(ipv6_header.destination_address, tmp_data);
                                    tmp_data[j] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[j]);
                                    buffer_to_ip6(tmp_data, &ipv6_header.destination_address);
                                    may_not_hit = TRUE;
                                    break;
                                }
                            }
                        }
                        break;
                    case bcmFieldQualifySrcIp:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            ipv4_header.source_address ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyDstIp:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            ipv4_header.destination_address ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyIp6FlowLabel:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfffff) {
                            ipv6_header.flow_label ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyIpProtocol:
                    /* also bcmFieldQualifyIp6NextHeader */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                ipv4_header.protocol ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.next_header ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyDSCP:
                    /* also bcmFieldQualifyTos
                    and bcmFieldQualifyIp6TrafficClass */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                ipv4_header.dscp ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.traffic_class ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyTtl:
                    /* also bcmFieldQualifyIp6HopLimit */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                ipv4_header.time_to_live ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.hop_limit ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyEcnValue:
                        if(entry->quals_info[qual_idx].mask[0] & 0x3) {
                            ipv4_header.ecn ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsBos:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            mpls_header.bos ^= 0x1;
                            if(entry->quals_info[qual_idx].data[0] == 1) {
                                /* and hence to not hit we should have 3 mpls, and in all of them the Bos should be 0 */
                                nof_mpls = 3;
                                mpls_header2.bos = 0;
                                mpls_header3.bos = 0;
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel1:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            tmp_data[0] = entry->quals_info[qual_idx].data[0];
                            tmp_data[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            _bcm_petra_field_test_buffer_to_mpls_header(tmp_data[0], &mpls_header);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel1Ttl:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7f) {
                            mpls_header.time_to_live ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel1Bos:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            mpls_header.bos ^= 0x1;
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel1Exp:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7) {
                            mpls_header.exp ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel1Id:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfffff) {
                            mpls_header.label ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel2:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            tmp_data[0] = entry->quals_info[qual_idx].data[0];
                            tmp_data[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            _bcm_petra_field_test_buffer_to_mpls_header(tmp_data[0], &mpls_header2);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel2Ttl:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7f) {
                            mpls_header2.time_to_live ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel2Bos:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            mpls_header2.bos ^= 0x1;
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel2Exp:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7) {
                            mpls_header2.exp ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel2Id:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfffff) {
                            mpls_header2.label ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel3:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            tmp_data[0] = entry->quals_info[qual_idx].data[0];
                            tmp_data[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            _bcm_petra_field_test_buffer_to_mpls_header(tmp_data[0], &mpls_header3);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel3Ttl:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7f) {
                            mpls_header3.time_to_live ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel3Bos:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            mpls_header3.bos ^= 0x1;
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel3Exp:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7) {
                            mpls_header3.exp ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyMplsLabel3Id:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfffff) {
                            mpls_header3.label ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifySrcMac:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            uint32 data_tag[2];
                            mac_to_buffer(ethernet_header.source_address, data_tag);
                            data_tag[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            buffer_to_mac(data_tag, &ethernet_header.source_address);
                            may_not_hit = TRUE;
                        } else if(entry->quals_info[qual_idx].mask[1] & 0xffff) {
                            uint32 data_tag[2];
                            mac_to_buffer(ethernet_header.source_address, data_tag);
                            data_tag[1] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[1]);
                            buffer_to_mac(data_tag, &ethernet_header.source_address);
                            may_not_hit = TRUE;
                        }                        
                        break;
                    case bcmFieldQualifyDstMac:
                        {
                            uint32 data_tag[2];
                            uint32 mask_tag[2];
                            mac_to_buffer(ethernet_header.destination_address, data_tag);
                            mask_tag[0] = entry->quals_info[qual_idx].mask[0];
                            mask_tag[1] = entry->quals_info[qual_idx].mask[1];
                            do
                            {
                                if(entry->quals_info[qual_idx].mask[0]) {
                                    data_tag[0] ^= 1 << first_set_bit_ndx(mask_tag[0]);
                                    mask_tag[0] ^= 1 << first_set_bit_ndx(mask_tag[0]);
                                } else if(entry->quals_info[qual_idx].mask[1] & 0xffff) {
                                    data_tag[1] ^= 1 << first_set_bit_ndx(mask_tag[1]);
                                    mask_tag[1] ^= 1 << first_set_bit_ndx(mask_tag[1]);
                                }
                            } while (data_tag[0] == 0 && data_tag[1] == 0 && (mask_tag[0] || mask_tag[1]));
                            if(data_tag[0] || data_tag[1] ) {
                                buffer_to_mac(data_tag, &ethernet_header.destination_address);
                                may_not_hit = TRUE;
                            }
                        }                        
                        break;
                    case bcmFieldQualifyInnerVlan:
                        if(entry->quals_info[qual_idx].mask[0] & 0xffff) {
                            uint8 first_bit = first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            if(first_bit < 12) {
                                ethernet_header.vlans[1].vlan_id ^= 1 << first_bit;
                            } else if(first_bit == 12) {
                                ethernet_header.vlans[1].cfi ^= 1;
                            } else {
                                ethernet_header.vlans[1].pri ^= 1 << (first_bit - 13);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerVlanId:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfff) {
                            ethernet_header.vlans[1].vlan_id ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerVlanPri:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7) {
                            ethernet_header.vlans[1].pri ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerVlanCfi:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            ethernet_header.vlans[1].cfi ^= 0x1;
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerTpid:
                        if(!is_predefined){
                            ethernet_header.vlans[1].tag_protocol_id = 0x9100;
                            may_not_hit = TRUE;
                        } else {
                            if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) != (0x9100 & entry->quals_info[qual_idx].mask[0]) ) {
                                ethernet_header.vlans[1].tag_protocol_id = 0x9100;
                                may_not_hit = TRUE;
                            }
                        }
                        break;
                    case bcmFieldQualifyOuterVlan:
                        if(entry->quals_info[qual_idx].mask[0] & 0xffff) {
                            uint8 first_bit = first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            if(first_bit < 12) {
                                ethernet_header.vlans[0].vlan_id ^= 1 << first_bit;
                            } else if(first_bit == 12) {
                                ethernet_header.vlans[0].cfi ^= 1;
                            } else {
                                ethernet_header.vlans[0].pri ^= 1 << (first_bit - 13);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyOuterVlanId:
                        if(entry->quals_info[qual_idx].mask[0] & 0xfff) {
                            ethernet_header.vlans[0].vlan_id ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyForwardingVlanId:
                        if(is_predefined && (entry->quals_info[qual_idx].data[0] != 0x0 || entry->quals_info[qual_idx].mask[0] != 0x1)){
                            return CMD_NOTIMPL;
                        }
                        if(!is_predefined) {
                            if(bcm_field_qualify_ForwardingVlanId(unit, entry->id, 0x0, 0x1) != BCM_E_NONE ){
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(bcm_field_entry_install(unit, entry->id) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyOuterVlanPri:
                        if(entry->quals_info[qual_idx].mask[0] & 0x7) {
                            ethernet_header.vlans[0].pri ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyOuterVlanCfi:
                        if(entry->quals_info[qual_idx].mask[0] & 0x1) {
                            ethernet_header.vlans[0].cfi ^= 0x1;
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyOuterTpid:
                        if(!is_predefined) {
                            if(entry->quals_info[qual_idx].data[0] == 0x8100) {
                                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                            } else {
                                ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                            }                            
                            may_not_hit = TRUE;
                        } else {
                            if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) != (0x8100 & entry->quals_info[qual_idx].mask[0]) ) {
                                ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                                may_not_hit = TRUE;
                            } else if((entry->quals_info[qual_idx].data[0] & entry->quals_info[qual_idx].mask[0]) != (0x9100 & entry->quals_info[qual_idx].mask[0]) ) {
                                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                                may_not_hit = TRUE;
                            }
                        } 
                        break;
                    case bcmFieldQualifyEtherType:
                        if(!is_ipv4 && !is_ipv6 && !is_mpls && entry->quals_info[qual_idx].mask[0] & 0xffff) {
                            uint16 tmp_mask = entry->quals_info[qual_idx].mask[0];
                            uint16 tmp_ethertype = ethernet_header.ethertype;
                            do {
                                tmp_ethertype ^= 1 << first_set_bit_ndx(tmp_mask);
                                tmp_mask ^= 1 << first_set_bit_ndx(tmp_mask);
                            }
                            while(tmp_mask && 
                                (tmp_ethertype == 0x8100
                                    || tmp_ethertype == 0x88a8
                                    || tmp_ethertype == 0x9100
                                    || tmp_ethertype == 0x9200
                                    || tmp_ethertype == 0x9300
                                    || tmp_ethertype < 0x5dd));
                            if(!(tmp_ethertype == 0x8100
                                    || tmp_ethertype == 0x88a8
                                    || tmp_ethertype == 0x9100
                                    || tmp_ethertype == 0x9200
                                    || tmp_ethertype == 0x9300
                                    || tmp_ethertype < 0x5dd)) {
                                ethernet_header.ethertype = tmp_ethertype;
                                may_not_hit = TRUE;
                            }
                        }
                        break;
                    case bcmFieldQualifyIpProtocolCommon:
                        if(is_ipv4) {
                            if(ip_protocol_common_to_protocol_id_mismatch(entry->quals_info[qual_idx].data[0], &ipv4_header.protocol)) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        } else { 
                            if(ip_protocol_common_to_protocol_id_mismatch(entry->quals_info[qual_idx].data[0], &ipv6_header.next_header)) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyIpType:
                        if(ip_type_to_ethertype_id_mismatch(entry->quals_info[qual_idx].data[0], &ethernet_header.ethertype)) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyIpFrag:
                        if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNon ||
                           (SOC_IS_JERICHO(unit) && (soc_property_get(unit, spn_FIELD_IP_FIRST_FRAGMENT_PARSED, TRUE)) && (entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNonOrFirst)) ) {
                            ipv4_header.flags = 0x0;/* fragmented */
                            ipv4_header.fragment_offset = 0x5; /* not first */
                        } else if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragAny ||
                           (SOC_IS_JERICHO(unit) && (soc_property_get(unit, spn_FIELD_IP_FIRST_FRAGMENT_PARSED, TRUE)) && (entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNotFirst)) ) {
                            ipv4_header.fragment_offset = 0x0; /* first */
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyTcpControl:
                        if(entry->quals_info[qual_idx].mask[0] & 0x3f) {
                            tcp_header.control ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyL4SrcPort:
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            tcp_header.source_port ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyL4DstPort:
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            tcp_header.destination_port ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerSrcIp:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            inner_ipv4_header.source_address ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerDstIp:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            inner_ipv4_header.destination_address ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerTtl:
                    /* also bcmFieldQualifyInnerIp6HopLimit */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                inner_ipv4_header.time_to_live ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.hop_limit ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyInnerIpProtocol:
                    /* also bcmFieldQualifyInnerIp6NextHeader */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                inner_ipv4_header.protocol ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.next_header ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyInnerTos:
                    /* also bcmFieldQualifyInnerDSCP
                        and bcmFieldQualifyInnerIp6TrafficClass */
                        if(entry->quals_info[qual_idx].mask[0] & 0xff) {
                            if(is_ipv4) {
                                inner_ipv4_header.dscp ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            } else {
                                ipv6_header.traffic_class ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            }
                            may_not_hit = TRUE;
                        }
                        break;
                    case bcmFieldQualifyInnerIpFrag:
                        if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragNon) {
                            inner_ipv4_header.flags = 0x0;/* fragmented */
                            inner_ipv4_header.fragment_offset = 0x5; /* not first */
                        } else if(entry->quals_info[qual_idx].data[0] == bcmFieldIpFragAny) {
                            inner_ipv4_header.fragment_offset = 0x0; /* first */
                        }
                        may_not_hit = TRUE;
                        break;
                    case bcmFieldQualifyInnerSrcMac:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            uint32 data_tag[2];
                            mac_to_buffer(inner_ethernet_header.source_address, data_tag);
                            data_tag[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            buffer_to_mac(data_tag, &inner_ethernet_header.source_address);
                            may_not_hit = TRUE;
                        } else if(entry->quals_info[qual_idx].mask[1] & 0xffff) {
                            uint32 data_tag[2];
                            mac_to_buffer(inner_ethernet_header.source_address, data_tag);
                            data_tag[1] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[1]);
                            buffer_to_mac(data_tag, &inner_ethernet_header.source_address);
                            may_not_hit = TRUE;
                        }                        
                        break;
                    case bcmFieldQualifyInnerDstMac:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            uint32 data_tag[2];
                            mac_to_buffer(inner_ethernet_header.destination_address, data_tag);
                            data_tag[0] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            buffer_to_mac(data_tag, &inner_ethernet_header.destination_address);
                            may_not_hit = TRUE;
                        } else if(entry->quals_info[qual_idx].mask[1] & 0xffff) {
                            uint32 data_tag[2];
                            mac_to_buffer(inner_ethernet_header.destination_address, data_tag);
                            data_tag[1] ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[1]);
                            buffer_to_mac(data_tag, &inner_ethernet_header.destination_address);
                            may_not_hit = TRUE;
                        }                        
                        break;
                    case bcmFieldQualifyInnerEtherType:
                        if(!is_mpls && entry->quals_info[qual_idx].mask[0] & 0xffff) {
                            uint16 tmp_mask = entry->quals_info[qual_idx].mask[0];
                            uint16 tmp_ethertype = inner_ethernet_header.ethertype;
                            do {
                                tmp_ethertype ^= 1 << first_set_bit_ndx(tmp_mask);
                                tmp_mask ^= 1 << first_set_bit_ndx(tmp_mask);
                            }
                            while(tmp_mask && 
                                (tmp_ethertype == 0x8100
                                    || tmp_ethertype == 0x88a8
                                    || tmp_ethertype == 0x9100
                                    || tmp_ethertype == 0x9200
                                    || tmp_ethertype == 0x9300
                                    || tmp_ethertype < 0x5dd));
                            if(!(tmp_ethertype == 0x8100
                                    || tmp_ethertype == 0x88a8
                                    || tmp_ethertype == 0x9100
                                    || tmp_ethertype == 0x9200
                                    || tmp_ethertype == 0x9300
                                    || tmp_ethertype < 0x5dd)) {
                                inner_ethernet_header.ethertype = tmp_ethertype;
                                may_not_hit = TRUE;
                            }
                        }
                        break;
                    case bcmFieldQualifyInterfaceClassProcessingPort:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            uint32 port_profile = entry->quals_info[qual_idx].data[0];
                            bcm_port_class_t pclass;
                            port_profile ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                                pclass = bcmPortClassFieldIngressPacketProcessing;
                            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
                                pclass = bcmPortClassFieldEgressPacketProcessing;
                            } else {
                                pclass = bcmPortClassFieldLookup;
                            }
                        
                            if(bcm_port_class_set(unit,
                                                  port_number,
                                                  pclass,
                                                  port_profile) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            may_not_hit = TRUE;
                        }   
                        break;
                    case bcmFieldQualifyInterfaceClassPort:
                        if(entry->quals_info[qual_idx].mask[0]) {
                            uint32 port_profile = entry->quals_info[qual_idx].data[0];
                            port_profile ^= 1 << first_set_bit_ndx(entry->quals_info[qual_idx].mask[0]);
                            if(bcm_port_class_set(unit,
                                                  port_number,
                                                  bcmPortClassFieldIngress,
                                                  port_profile) != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            may_not_hit = TRUE;
                        }   
                        break;
                    default:
                        break;/* do nothing */
                }
            }
            if(may_not_hit) {
                break;
            }            
        }
    }
    
    if(!should_hit && !may_not_hit) {
        return CMD_NOTIMPL;
    }

    sal_memset(buffer, 0xa5, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
    /* The headers will override part of the payload latter */
    
    mac_to_buffer(ethernet_header.destination_address, tmp_buffer);
    if(tmp_buffer[0] == 0 && (tmp_buffer[1] & 0xffff) == 0) {
        /* we want that s.a != 0 */
        tmp_buffer[0] = 0x1;
        buffer_to_mac(tmp_buffer, &ethernet_header.destination_address);
    }
    
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(is_ipv4){
        ipv4_header.version = 4;
        ipv4_header.internet_header_length = 0x5;
        ipv4_header.total_length = 0x24;
        ethernet_header.ethertype = 0x800;

        if(has_inner_ipv4) {
            inner_ipv4_header.version = 4;
            inner_ipv4_header.internet_header_length = 0x5;
            inner_ipv4_header.total_length = 0x24;
            if(_bcm_petra_field_test_ipv4_header_to_buffer(&inner_ipv4_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        
        if(has_tcp) {
            if(has_inner_ipv4) {
                inner_ipv4_header.protocol = 6;
            } else {
                ipv4_header.protocol = 6;
            }
            if(_bcm_petra_field_test_tcp_header_to_buffer(&tcp_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160
                    - 160*has_inner_ipv4
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        
        if(_bcm_petra_field_test_ipv4_header_to_buffer(&ipv4_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 160,
            tmp_buffer,
            0,
            160);
    } else if(is_ipv6) {
        ipv6_header.version = 6;
        ipv6_header.payload_length = _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - 40 - 14 - 4 * ethernet_header.nof_vlans; 
        ethernet_header.ethertype = 0x86dd;
        if(has_ipv4) {
            ipv4_header.version = 4;
            ipv4_header.internet_header_length = 0x5;
            ipv4_header.total_length = 0x24;
            ethernet_header.ethertype = 0x800;
            if(_bcm_petra_field_test_ipv4_header_to_buffer(&ipv4_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160,
                tmp_buffer,
                0,
                160);
        }

        if(has_tcp) {
            ipv6_header.next_header = 6;
            if(_bcm_petra_field_test_tcp_header_to_buffer(&tcp_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 320
                    - 160*has_ipv4
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        if(_bcm_petra_field_test_ipv6_header_to_buffer(&ipv6_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 320
                - 160*has_ipv4,
            tmp_buffer,
            0,
            320);
    } else if(is_mpls) {
        ethernet_header.ethertype = 0x8847;
        if(nof_mpls == 3) {
            if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header3, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 32 * 3,
                tmp_buffer,
                0,
                32);
        }
        if(nof_mpls >= 2) {
            if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header2, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 32 * 2,
                tmp_buffer,
                0,
                32);
        }
        
        if(has_inner_ethernet) {
            if(_bcm_petra_field_test_ethernet_header_to_buffer(&inner_ethernet_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    -32
                    - (112 + 32*inner_ethernet_header.nof_vlans), /* ethernet header length */
                tmp_buffer,
                0,
                112 + 32*inner_ethernet_header.nof_vlans);
        }
                        
        if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 32,
            tmp_buffer,
            0,
            32);
    }
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ethernet_header_to_buffer(&ethernet_header, tmp_buffer)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */,
        tmp_buffer,
        0,
        112 + 32*ethernet_header.nof_vlans);
    
    return CMD_OK;
}

/* verify that no action occurred */
STATIC uint8 no_actions_verification(SOC_PPC_FP_PACKET_DIAG_INFO *info, uint8 is_de)
{
    int32 cycle, macro;
    for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
        if(!is_de) {
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                if(info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID
                    && info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_NOP) {
                    return FALSE;
                }
            }
        } else {
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACROS - 1; macro >= 0; --macro) {
                if(info->macro[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID
                   && info->macro[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_NOP) {
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}

STATIC uint8 _bcm_petra_field_test_check_hit(SOC_PPC_FP_PACKET_DIAG_INFO *info, _bcm_dpp_field_stage_idx_t stage, uint8 is_de, uint8 is_dt)
{
    uint32 cycle, bank;
    uint32 egress_action;
    if(is_de) {
        return !no_actions_verification(info, TRUE);
    }
    if(is_dt) {
        return !no_actions_verification(info, FALSE);
    }
    
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
            for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                if(info->tcam[cycle][bank].is_match) {
                    return TRUE;
                }
            }
        }
    } else {
        for(egress_action = 0; egress_action < SOC_DPP_DEFS_MAX(NOF_EGRESS_PMF_ACTIONS); ++egress_action) {
            if(info->egress_action[egress_action].type == SOC_PPC_FP_ACTION_TYPE_COS_PROFILE &&
                info->egress_action[egress_action].val == _BCM_PETRA_FIELD_EGRESS_COS_PROFILE_FOR_HIT_CHECK) {
                return TRUE;
            }
        }
    }
             
    return FALSE;
}

/*
 * By this function we sends traffic.
 * We save the packet information in order to rend it latter.
 */ 
STATIC cmd_result_t _bcm_petra_field_test_soc_ppd_fp_ire_traffic_send(int unit,
                                                                      SOC_PPC_FP_PACKET *packet,
                                                                      int tx_count,
                                                                      int core,
                                                                      uint8 resend)
{
    static SOC_PPC_FP_PACKET last_packet;
    uint32 soc_sand_res;
    
    if(resend) {
        soc_sand_res = soc_ppd_fp_ire_traffic_send(unit, &last_packet, 1, core);
        if(SOC_SAND_FAILURE(soc_sand_res)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        return CMD_OK;
    }
    
    if(packet == NULL) {
        return CMD_FAIL;
    }

    /* save the sent packet */    
    sal_memcpy(&last_packet, packet, sizeof(SOC_PPC_FP_PACKET));

    /* send the packet */
    soc_sand_res = soc_ppd_fp_ire_traffic_send(unit, &last_packet, tx_count, core);
    if(SOC_SAND_FAILURE(soc_sand_res)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    return CMD_OK;
}

STATIC cmd_result_t _bcm_petra_field_send_packet_and_get_information(int unit,
                                                                     uint32 *buffer,
                                                                     uint32 local_port_src,
                                                                     int tx_count,
                                                                     SOC_PPC_FP_PACKET_DIAG_INFO **info_out)
{
    SOC_PPC_FP_PACKET *packet = NULL;
    uint32 index;
    uint32 soc_sand_res;
    /* NOTE: The static variable info may cause critical section problem if 2 threads will run test in the same time.
      We assume that it will not happen. If it will happen we should change the code.
      The reason for this is stack overflow problem. The structure is very big */
    static SOC_PPC_FP_PACKET_DIAG_INFO info;
    int learn_mode;
    int rv;
    int core;
    uint32 tm_port;

    /*Disable learn mode*/
    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &learn_mode);

    if (rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
    }

    rv = bcm_switch_control_set(unit, bcmSwitchL2LearnMode, BCM_L2_LEARN_DISABLE | learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
    }

    packet = sal_alloc(sizeof(SOC_PPC_FP_PACKET), "_bcm_petra_field_send_packet_and_get_information.packet");
    if(!packet) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    SOC_PPC_FP_PACKET_clear(packet);
            
    packet->local_port_src = local_port_src;
    packet->size_bytes = _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit);
            
    /* we want the buffer to be opposite to send it */
    for(index = 0; index < _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) / sizeof(uint32); ++index)
    {
        SHR_BITCOPY_RANGE(packet->buffer, index*32, buffer, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 - 32*(index + 1), 32);
    }
    soc_sand_res = soc_port_sw_db_local_to_tm_port_get(unit, local_port_src, &tm_port, &core);
    if(SOC_SAND_FAILURE(soc_sand_res)) {
        sal_free(packet);
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(_bcm_petra_field_test_soc_ppd_fp_ire_traffic_send(unit, packet, tx_count, core, FALSE) != CMD_OK) {
        sal_free(packet);
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
   
    /* get the information */
    soc_sand_res = soc_ppd_fp_packet_diag_get(unit, core, &info);
    if(SOC_SAND_FAILURE(soc_sand_res)) {
        sal_free(packet);
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    *info_out = &info;
    sal_free(packet);
    return CMD_OK;  
}

/* This function take entry data of predefined qualifiers data and mask and translates it to regular qualifiers
 * It is done to use the build packet of regular qualifiers.
 */
STATIC cmd_result_t _bcm_petra_field_test_modify_entry_from_dq_to_defined(int unit, _bcm_petra_field_test_entry_info_t *entry)
{
    bcm_error_t rv;
    uint32 qual_idx;
    bcm_field_data_qualifier_t dq;
    uint64 edata, emask;
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].is_undefined) {
            entry->quals_info[qual_idx].is_undefined = FALSE;

            if(entry->quals_info[qual_idx].is_valid) {
                bcm_field_data_qualifier_t_init(&dq);
                dq.flags = BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES | BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES;
                rv = bcm_field_data_qualifier_get(unit, entry->quals_info[qual_idx].qualify, &dq);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if((dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) == 0) {
                    /* i.e it is not for existing qualifier */
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
             
                /* we wand the resolution in bits */
                if((dq.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
                    dq.length *= 8;
                }
                if((dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) == 0) {
                    dq.offset *= 8;
                }
            
                /* The length of the qualifier is not expected to be more then 64 bits */
                COMPILER_64_SET(edata, entry->quals_info[qual_idx].data[1], entry->quals_info[qual_idx].data[0]);
                COMPILER_64_SET(emask, entry->quals_info[qual_idx].mask[1], entry->quals_info[qual_idx].mask[0]);
                COMPILER_64_SHL(edata, dq.offset);
                COMPILER_64_SHL(emask, dq.offset);
                entry->quals_info[qual_idx].data[0] = COMPILER_64_LO(edata);
                entry->quals_info[qual_idx].data[1] = COMPILER_64_HI(edata);
                entry->quals_info[qual_idx].mask[0] = COMPILER_64_LO(emask);
                entry->quals_info[qual_idx].mask[1] = COMPILER_64_HI(emask);
                entry->quals_info[qual_idx].qualify = dq.qualifier;
            }
        }
    }
    
    return CMD_OK;
}

/*
 * get the ppd action(s) from bcm actions
 */
STATIC bcm_error_t _bcm_petra_field_test_to_ppd_actions(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_action_t action, SOC_PPC_FP_ACTION_TYPE **ppd_actions)
{
    bcm_dpp_field_info_OLD_t *unitData;
    bcm_error_t rv;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    rv = _bcm_dpp_ppd_act_from_bcm_act(unitData, stage, action, ppd_actions);

    BCM_IF_ERROR_RETURN(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

/* Translating the bcm action to ppd actions */
STATIC bcm_error_t _bcm_petra_field_test_actions_to_ppd_actions(int unit,
                                                                _bcm_dpp_field_stage_idx_t stage,
                                                                const bcm_field_action_t *actions,
                                                                int nof_actions,
                                                                SOC_PPC_FP_ACTION_TYPE *ppd_actions)
{
    uint32 action_idx, ppd_action_idx;
    bcm_error_t rv;
    SOC_PPC_FP_ACTION_TYPE *cur_action_ppd_ptr;

    for(action_idx = 0; action_idx < nof_actions; ++action_idx) {
        rv = _bcm_petra_field_test_to_ppd_actions(unit, stage, actions[action_idx], &cur_action_ppd_ptr);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return rv;
        }
        
        for(ppd_action_idx = 0; ppd_action_idx < _BCM_PETRA_FIELD_ACTION_CHAIN; ++ppd_action_idx) {
            if((cur_action_ppd_ptr[ppd_action_idx] < SOC_PPC_NOF_FP_ACTION_TYPES) && (cur_action_ppd_ptr[ppd_action_idx] != BCM_FIELD_ENTRY_INVALID)) {
                /* we assume that there is only 1 ppd action */
                ppd_actions[action_idx] = cur_action_ppd_ptr[ppd_action_idx];
                break;
            }
        }
    }
    return BCM_E_NONE;
}

#if ! defined(PLISIM)  
STATIC uint8 actions_verification(SOC_PPC_FP_PACKET_DIAG_INFO *info,
                                  const SOC_PPC_FP_ACTION_TYPE *ppd_actions,
                                  uint32 nof_actions,
                                  int32 *expected_actions,
                                  uint8 is_de)
{
    int32 cycle, macro, action_idx;
    int unit = BSL_UNIT_UNKNOWN;
    
    for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
        if(!is_de) {
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                for(action_idx = 0; action_idx < nof_actions; ++action_idx) {
                    if(info->macro_simple[cycle][macro].action.type == ppd_actions[action_idx] &&
                        expected_actions[action_idx] > 0) {
                        if(info->macro_simple[cycle][macro].action.val !=  expected_actions[action_idx]) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "Incorrect expeceted action value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return FALSE;
                        }
                        expected_actions[action_idx] = _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_ACTION_CHECKED;
                    }
                }
            }
        } else {
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACROS - 1; macro >= 0; --macro) {
                for(action_idx = 0; action_idx < nof_actions; ++action_idx) {
                    if(info->macro[cycle][macro].action.type == ppd_actions[action_idx] &&
                        expected_actions[action_idx] > 0) {
                        if(info->macro[cycle][macro].action.val !=  expected_actions[action_idx]) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "Incorrect expeceted action value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return FALSE;
                        }
                        expected_actions[action_idx] = _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_ACTION_CHECKED;
                    }
                }
            }
        }
    }
    return TRUE;
}
#endif /* ! defined(PLISIM) */  

/* The traffic test for entry
 * It takes an entry, build packet, in the first time the packet may not cause hit, and in the seocnd time may cause hit
 */
STATIC cmd_result_t _bcm_petra_field_test_traffic_test(int unit,
                                                       _bcm_dpp_field_stage_idx_t stage,
                                                       uint8 is_predefined,
                                                       uint8 is_de,
                                                       uint8 is_dt,
                                                       bcm_field_group_t fg_id,
                                                       _bcm_petra_field_test_entry_info_t *entry,
                                                       int tx_count)
{
    bcm_error_t rv;
    cmd_result_t result;
    uint32 *buffer = NULL;
    uint8 should_hit;
    uint32 local_port_src = 1;
    uint32 qual_idx;
    uint8 is_empty = TRUE;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    uint32 nof_actions = 0;
    uint32 action_idx;
    SOC_PPC_FP_PACKET_DIAG_INFO* info;
    uint8 hit;
    soc_port_t port_number;
    
    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    local_port_src = port_number;

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        if(bcm_port_force_forward_set(unit, local_port_src, local_port_src, TRUE) != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } 
    
    /* if the entry has no qualifiers - do nothing */
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].is_valid) {
            is_empty = FALSE;
            break;
        }
    }
    if(is_empty) {
        result = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        return CMD_OK;
    }
    
    if(is_predefined) {
        result = _bcm_petra_field_test_modify_entry_from_dq_to_defined(unit, entry);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    
    buffer = sal_alloc(_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit), "_bcm_petra_field_test_traffic_test.buffer");
    if(!buffer) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    for(should_hit = FALSE; should_hit <= TRUE; ++should_hit)
    {
        sal_memset(buffer, 0x0, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
        result = _bcm_petra_field_test_build_packet(unit, stage, fg_id, entry, should_hit, is_predefined, buffer);
        if(result == CMD_NOTIMPL) {
            if(is_predefined || !should_hit) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    if(!should_hit) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Skipping the test of not hit. All the masks are 0.\n")));
                    } else {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Skipping the test of hit. Can\'t build adequate packets.\n")));
                    }
                }
            }
            continue;
        } else if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        
        if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        /* send the buffer and get the information */
        result = _bcm_petra_field_send_packet_and_get_information(unit, buffer, port_number, tx_count, &info);
        if(result != CMD_OK){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            SOC_PPC_FP_PACKET_DIAG_ACTION_ELK *action_elk;
            hit = FALSE;
            for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
                if(entry->actions_info[action_idx].action >= bcmFieldActionExternalValue0Set &&
                    entry->actions_info[action_idx].action <= bcmFieldActionExternalValue3Set) {
                    action_elk = &info->elk_action[entry->actions_info[action_idx].action - bcmFieldActionExternalValue0Set];
                    if(entry->actions_info[action_idx].is_valid) {
                        if(action_elk->hit && action_elk->action.val == entry->actions_info[action_idx].param0) {
                            hit = TRUE;
                        }
                    } else {
                        if(action_elk->hit && action_elk->action.val == 0) {
                            hit = TRUE;
                        }
                    }
                }
				else if(entry->actions_info[action_idx].action == bcmFieldActionExternalValue4Set ||
                        entry->actions_info[action_idx].action == bcmFieldActionExternalValue5Set) {
                    action_elk = &info->elk_action[4 + entry->actions_info[action_idx].action - bcmFieldActionExternalValue4Set];
                    if(entry->actions_info[action_idx].is_valid) {
                        if(action_elk->hit && action_elk->action.val == entry->actions_info[action_idx].param0) {
                            hit = TRUE;
                        }
                    } else {
                        if(action_elk->hit && action_elk->action.val == 0) {
                            hit = TRUE;
                        }
                    }
                }
            }
        } else
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        {
            if(is_dt && should_hit) {
                nof_actions = 0;
                for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
                    if(entry->actions_info[action_idx].is_valid) {
                        ++nof_actions;
                    }
                }
                if(nof_actions == 0) {
                    /* In this case no action should occur and hence, the criteria is wrong */
                    hit = TRUE;
                } else {
                    hit = _bcm_petra_field_test_check_hit(info, stage, FALSE, TRUE);
                }
            } else {
                hit =  _bcm_petra_field_test_check_hit(info, stage, is_de, is_dt);
            }
        }
#ifndef PLISIM      
        if(hit && !should_hit) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Hit occurred although it shouldn\'t occur\n")));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        } else if (!hit && should_hit) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Hit didn\'t occur although it should occur\n")));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
#endif /* not PLISIM */
        if(is_dt && hit) {
            /* action values verification */
            bcm_error_t rv;
            uint32 action_idx2;
            bcm_field_action_t *actions = NULL;
            SOC_PPC_FP_ACTION_TYPE *ppd_actions = NULL;
            int32 *expected_actions = NULL;
            if(nof_actions > 0) {
                actions = sal_alloc(sizeof(bcm_field_action_t) * nof_actions, "_bcm_petra_field_test_traffic_test.actions");
                if(!actions) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                    ppd_actions = sal_alloc(sizeof(SOC_PPC_FP_ACTION_TYPE) * nof_actions, "_bcm_petra_field_test_traffic_test.ppd_actions");
                if(!ppd_actions) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    sal_free(actions);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                expected_actions = sal_alloc(sizeof(int32) * nof_actions, "_bcm_petra_field_test_traffic_test.expected_actions");
                if(!expected_actions) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    sal_free(actions);
                    sal_free(ppd_actions);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                action_idx2 = 0;
            
                for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
                    if(entry->actions_info[action_idx].is_valid) {
                        actions[action_idx2] = entry->actions_info[action_idx].action;
                        expected_actions[action_idx2] = entry->actions_info[action_idx].param0;
                        ++action_idx2;
                    }
                }
                rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions, nof_actions, ppd_actions);
                if(rv != BCM_E_NONE) {
                    sal_free(actions);
                    sal_free(ppd_actions);
                    sal_free(expected_actions);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
#ifndef PLISIM  
                if(!actions_verification(info, ppd_actions, nof_actions, expected_actions, FALSE)) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    sal_free(actions);
                    sal_free(ppd_actions);
                    sal_free(expected_actions);
                    goto fail;
                }
#endif /* not PLISIM */
                sal_free(actions);
                sal_free(ppd_actions);
                sal_free(expected_actions);
            }
        }
    }

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        if(bcm_port_force_forward_set(unit, local_port_src, local_port_src, FALSE) != BCM_E_NONE) {
            sal_free(buffer); 
            return CMD_FAIL;
        }
    }

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    sal_free(buffer); 
    return CMD_OK;
    
fail:
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        if(bcm_port_force_forward_set(unit, local_port_src, local_port_src, TRUE) != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        }
    }
    if(buffer) {
        sal_free(buffer);
    }
    return CMD_FAIL;
}

STATIC cmd_result_t _bcm_petra_field_test_get_unavailable_ports(int unit, _bcm_dpp_field_profile_type_t profile_type, int *nof_cores, _bcm_dpp_core_ports_bitmap_t *unavail_ports)
{
     _bcm_dpp_core_ports_bitmap_t  profile_ports[MAX_NUM_OF_CORES];
    uint32 profile;
    int    rv;
    int    core, pp_port; 
    uint32      is_valid;


    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, unavail_ports);
              
    for(profile = 1; profile < _BCM_DPP_PRESEL_NOF_PORT_PROFILES; ++profile) {
        rv = _bcm_dpp_field_presel_port_profile_get(unit, profile_type, profile, nof_cores, profile_ports);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        for (core=0; core<*nof_cores; core++) {
            SHR_BITOR_RANGE(unavail_ports[core], profile_ports[core], 0, _BCM_DPP_NOF_PORTS_PER_CORE(unit), unavail_ports[core]);

            for ( pp_port=0; pp_port < _BCM_DPP_NOF_PORTS_PER_CORE(unit); pp_port++ ) {

                if ((SHR_BITGET(unavail_ports[core], pp_port))) {
                    rv = soc_port_sw_db_pp_is_valid_get(unit, core, pp_port, &is_valid);
                    if(rv != SOC_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    
                    if (!is_valid) {
                        SHR_BITCLR(unavail_ports[core], pp_port);
                    }
                }

            }
        }
    }

    return CMD_OK;
}

/* Set data and mask for pre-selectors */
STATIC cmd_result_t _bcm_petra_field_test_set_presel(int unit,
                                                     _bcm_dpp_field_stage_idx_t stage,
                                                     uint32 type,
                                                     bcm_field_qualify_t qualifier,
                                                     uint32 x,
                                                     uint32 *data,
                                                     uint32 *mask)
{
    uint32 second_rand_param = 0;
    cmd_result_t result;
    int          core;
    int          nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    uint32      is_valid;
    soc_error_t soc_rv;
    char *coremode;

    /* The number of cores used */
    coremode = soc_property_get_str(unit,spn_DEVICE_CORE_MODE);
    if(!coremode) {
        coremode="NULL";
    }
    if ( SOC_IS_JERICHO(unit) && !strcmp(coremode,"SINGLE_CORE") ) {
        nof_cores = 1;
    }

    result = _bcm_petra_field_test_set_qualifiers_info(unit, stage, type);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    sal_memset(data, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
    sal_memset(mask, 0x0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
    switch(qualifier) {
        case bcmFieldQualifyHeaderFormat:
        case bcmFieldQualifyForwardingType:
            result = _bcm_petra_field_test_get_valid_value_and_mask(unit, stage, type, qualifier, x + second_rand_param++, data, mask);
            /* here no mask and hence the mask will be zero */
            break;
        case bcmFieldQualifyStage:
            switch(stage) {
                case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
                    *data = bcmFieldStageIngress;
                    break;
                case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
                    *data = bcmFieldStageEgress;
                    break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
                case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
                    *data = bcmFieldStageExternal;
                    break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

                /* we may not reach to the default */
                default:
                    break;
            }
            *mask = 0;
            break;
        case bcmFieldQualifyInPort:
        case bcmFieldQualifyOutPort:
            {
                _bcm_dpp_core_ports_bitmap_t *unavail_ports = NULL;
                int tmp, found = FALSE;
                uint32      is_valid;
                soc_port_t  lport;
                uint32 max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);

                unavail_ports = sal_alloc(sizeof(_bcm_dpp_core_ports_bitmap_t)*MAX_NUM_OF_CORES, "_bcm_petra_field_test_set_presel.unavail_ports");
                if(unavail_ports == NULL) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if (qualifier==bcmFieldQualifyInPort) {
                    result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeInPort, &nof_cores, unavail_ports);
                } else {
                    result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeOutPort, &nof_cores, unavail_ports);
                }
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    sal_free(unavail_ports);
                    return result;
                }
                /* we assume that there is an available port */
                core = sal_rand() % nof_cores;
                do{
                    *data = 1 + _bcm_petra_field_rand_val(x, second_rand_param++) % (_BCM_DPP_NOF_PORTS_PER_CORE(unit) - 1);
                    tmp = SHR_BITGET(unavail_ports[0], *data);
                    soc_rv = soc_port_sw_db_pp_is_valid_get(unit, 0, *data, &is_valid);
                    if (soc_rv != SOC_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        sal_free(unavail_ports);
                        return CMD_FAIL;
                    }


                    if (is_valid) {
                        soc_rv = soc_port_sw_db_pp_to_local_port_get(unit, 0, *data, &lport);
                        if (soc_rv != SOC_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            sal_free(unavail_ports);
                            return CMD_FAIL;
                        }
                         
                    }
                    
                    found = !tmp && is_valid && (lport < max_port );

                } while(!found);
                *data = lport; 
                *mask = 0xffffffff;
                sal_free(unavail_ports);
            }
            break;
        case bcmFieldQualifyInPorts:
        case bcmFieldQualifyInterfaceInPorts:
        case bcmFieldQualifyOutPorts:
            {
                _bcm_dpp_core_ports_bitmap_t *unavail_ports = NULL;
                uint32 index, bit_val;
                uint8 have_port = FALSE;
                soc_port_t  local_port;

                unavail_ports = sal_alloc(sizeof(_bcm_dpp_core_ports_bitmap_t)*MAX_NUM_OF_CORES, "_bcm_petra_field_test_set_presel.unavail_ports");
                if(unavail_ports == NULL) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if (qualifier == bcmFieldQualifyInPorts) {
                    result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeInPort, &nof_cores, unavail_ports);
                }
                else if (qualifier == bcmFieldQualifyInterfaceInPorts){
                    result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeInterfaceInPort, &nof_cores, unavail_ports);
                } else {   
                    result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeOutPort, &nof_cores, unavail_ports);
                      
                }
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    sal_free(unavail_ports);
                    return result;
                }
                for (core = 0; core < nof_cores; core++) {
                    for (index = 0; index < _BCM_DPP_NOF_PORTS_PER_CORE(unit); index ++) {

                        bit_val = 0;
                        soc_rv = soc_port_sw_db_pp_is_valid_get(unit, core, index, &is_valid);
                        if (soc_rv != SOC_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            sal_free(unavail_ports);
                            return CMD_FAIL;
                        }

                        if (is_valid) {
                            soc_rv = soc_port_sw_db_pp_to_local_port_get(unit, core, index, &local_port);
                            if (soc_rv != SOC_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                sal_free(unavail_ports);
                                return CMD_FAIL;
                            }

                            bit_val = SHR_BITGET(unavail_ports[core], index);
                            SHR_BITSET(mask, local_port);

                        }

                        if (is_valid && bit_val && (index != 0)) {
                            SHR_BITSET(data, local_port);
                             have_port = TRUE;
                        } else {
                        }
                    }
                }

                if(!have_port) {
                    /* we must take at least one port */
                    core = sal_rand() % nof_cores;
                    do{
                        index = 1 + _bcm_petra_field_rand_val(x, second_rand_param++) % (_BCM_DPP_NOF_PORTS_PER_CORE(unit) - 1);
                        soc_rv = soc_port_sw_db_pp_is_valid_get(unit, core, index, &is_valid);
                        if (soc_rv != SOC_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            sal_free(unavail_ports);
                            return CMD_FAIL;
                        }

                        if (is_valid) {
                            soc_rv = soc_port_sw_db_pp_to_local_port_get(unit, core, index, &local_port);
                            if (soc_rv != SOC_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                sal_free(unavail_ports);
                                return CMD_FAIL;
                            }

                        }


                    } while(SHR_BITGET(unavail_ports[core], index)  || !is_valid);
                    SHR_BITSET(data, local_port);
                }
                sal_free(unavail_ports);
            }
            sal_memset(mask, 0xffffffff, nof_cores * _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/8);
            break;

        default:
            do {
                result = _bcm_petra_field_test_get_valid_value_and_mask(unit, stage, type, qualifier, x + second_rand_param++, data, mask);
            } while(*mask == 0);
    }         
    return result;
}

/* The function checks if new qualifier can be inserted, according to traffic constrains.
   We assume that the qualifiers in the entry are ordered */
STATIC uint8 _bcm_petra_field_test_can_insert_qualifier_traffic(bcm_field_qualify_t qualify, CONST bcm_field_qset_t *fg_qset, bcm_field_qset_t *cur_key)
{
    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure(), qualify)) {
        return FALSE;
    }

    if(!BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyMpls)) {
        if(qualify == bcmFieldQualifyMplsBos ||
            qualify == bcmFieldQualifyInnerSrcMac ||
            qualify == bcmFieldQualifyInnerDstMac ||
            qualify == bcmFieldQualifyInnerEtherType){
            return FALSE;
        }
    }
    if(!BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyIp4)) {
        if(qualify == bcmFieldQualifyIpFrag ||
            qualify == bcmFieldQualifyInnerIpFrag ||
            qualify == bcmFieldQualifyEcnValue){
            return FALSE;
        }
    }

    if(!BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyIp4) &&
        !BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyIp6)) {
        if(qualify == bcmFieldQualifyIpProtocolCommon){
            return FALSE;
        }
    }

    if(BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyIp4) ||
        BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyIp6) ||
        BCM_FIELD_QSET_TEST(*fg_qset, bcmFieldQualifyMpls) ){
        if(qualify == bcmFieldQualifyIpType){
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyEcnValue) {
    /* verify that the qualifier bcmFieldQualifyDSCP is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyDSCP)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyInnerVlanId ||
        qualify == bcmFieldQualifyInnerVlanPri ||
        qualify == bcmFieldQualifyInnerVlanCfi) {
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyInnerVlan)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyOuterVlanId ||
        qualify == bcmFieldQualifyForwardingVlanId ||
        qualify == bcmFieldQualifyOuterVlanPri ||
        qualify == bcmFieldQualifyOuterVlanCfi) {
        /* verify that bcmFieldQualifyOuterVlan is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyOuterVlan)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyForwardingVlanId) {
        /* verify that bcmFieldQualifyOuterVlanId is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyOuterVlanId)) {
            return FALSE;
        }
    }
                    
    if(qualify == bcmFieldQualifyIpProtocolCommon) {
        /* verify that bcmFieldQualifyIpProtocol is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyIpProtocol)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyIpType) {
        /* verify that bcmFieldQualifyEtherType is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyEtherType)) {
            return FALSE;
        }
    }
                    
    if(qualify == bcmFieldQualifySrcIp6High || qualify == bcmFieldQualifySrcIp6Low) {
        /* verify that bcmFieldQualifySrcIp6 is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifySrcIp6)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyDstIp6High || qualify == bcmFieldQualifyDstIp6Low) {
        /* verify that bcmFieldQualifyDstIp6 is not valid */
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyDstIp6)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyMplsLabel1Ttl ||
       qualify == bcmFieldQualifyMplsLabel1Bos ||
       qualify == bcmFieldQualifyMplsLabel1Exp ||
       qualify == bcmFieldQualifyMplsLabel1Id) {
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyMplsLabel1)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyMplsLabel2Ttl ||
       qualify == bcmFieldQualifyMplsLabel2Bos ||
       qualify == bcmFieldQualifyMplsLabel2Exp ||
       qualify == bcmFieldQualifyMplsLabel2Id) {
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyMplsLabel2)) {
            return FALSE;
        }
    }

    if(qualify == bcmFieldQualifyMplsLabel3Ttl ||
       qualify == bcmFieldQualifyMplsLabel3Bos ||
       qualify == bcmFieldQualifyMplsLabel3Exp ||
       qualify == bcmFieldQualifyMplsLabel3Id) {
        if(BCM_FIELD_QSET_TEST(*cur_key, bcmFieldQualifyMplsLabel3)) {
            return FALSE;
        }
    }

    return TRUE;
}

STATIC cmd_result_t _bcm_petra_field_test_set_entry_qualifiers(int unit, _bcm_dpp_field_stage_idx_t stage, CONST bcm_field_qset_t *qset, uint8 with_traffic, uint8 perf, uint32 x, uint8 is_scan_mode, _bcm_petra_field_test_entry_info_t *entry)
{
    bcm_error_t rv;
    cmd_result_t result;
    uint32 second_rand_param = 0;
    uint32 qual_index;
    bcm_field_qualify_t qualify;
    uint32 qual_idx_2;
    bcm_field_qset_t cur_key;
    uint32 type;
    uint32 skip_this_cycle ;
    
    type = _BCM_PETRA_FIELD_TYPE_ETHR;
    if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV4;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV6;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls)) {
        type = _BCM_PETRA_FIELD_TYPE_MPLS;
    }
    
    /* for each qualifier decide if it will be taken */
    qual_index = 0;
    BCM_FIELD_QSET_INIT(cur_key);

    if(entry->id & BCM_FIELD_QUALIFY_PRESEL) {
        /* set the stage */
        entry->quals_info[qual_index].qualify = bcmFieldQualifyStage;
        entry->quals_info[qual_index].is_valid = TRUE;
        entry->quals_info[qual_index].is_undefined = FALSE;
        SHR_BITCLR_RANGE(entry->quals_info[qual_index].mask, 0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH);
        SHR_BITCLR_RANGE(entry->quals_info[qual_index].data, 0, _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH);
        switch(stage) {
            case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
                entry->quals_info[qual_index].data[0] = bcmFieldStageIngress;
                break;
            case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
                entry->quals_info[qual_index].data[0] = bcmFieldStageEgress;
                break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
            case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
                entry->quals_info[qual_index].data[0] = bcmFieldStageExternal;
                break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

            /* we may not reach to the default */
            default:
                break;
        }
        rv = bcm_field_qualify_Stage(unit, entry->id, entry->quals_info[qual_index].data[0]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        qual_index++;
    }
        
    for(qualify = 0; qualify < bcmFieldQualifyCount; ++qualify) {
        skip_this_cycle = 0 ;
        if(BCM_FIELD_QSET_TEST(*qset, qualify)) {
            entry->quals_info[qual_index].qualify = qualify;
	    entry->quals_info[qual_index].is_undefined = FALSE;
	    if (SOC_IS_JERICHO(unit)) {
                /*
                 * For Jericho, we do not allow the usage of 'bcmFieldQualifyOutPort' qualifier since
                 * it does not have a 'core' bit and, so, the port is ambiguous.
                 */
                if (qualify == bcmFieldQualifyOutPort) {
                    entry->quals_info[qual_index].is_valid = FALSE;
                    skip_this_cycle = 1 ;
                }
            }
            if (!skip_this_cycle) {
                if(qualify == bcmFieldQualifyIp4 ||
                    qualify == bcmFieldQualifyIp6 ||
                    qualify == bcmFieldQualifyMpls ||
                    qualify == bcmFieldQualifyStageIngress || 
                    qualify == bcmFieldQualifyStageEgress ||
                qualify == bcmFieldQualifyStageExternal) {
                    entry->quals_info[qual_index].is_valid = FALSE;
                    skip_this_cycle = 1 ;
                }
            }
            if (!skip_this_cycle) {
                entry->quals_info[qual_index].is_valid = is_scan_mode ||
                    perf || 
                    (_bcm_petra_field_rand_val(x, second_rand_param++) % 2);
                if(BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), qualify)){
                    entry->quals_info[qual_index].is_valid = FALSE;
                    continue;
                }

                if(entry->id & BCM_FIELD_QUALIFY_PRESEL) {
                    if(qualify == bcmFieldQualifyStage) {
                        /* it have been already set */
                        continue;
                    }
                    /* bcmFieldQualifyInPort and bcmFieldQualifyInPorts can't be both */
                    if(qualify == bcmFieldQualifyInPorts) {
                        for(qual_idx_2 = 0; qual_idx_2 < qual_index; ++qual_idx_2) {
                            if ( (entry->quals_info[qual_idx_2].qualify == bcmFieldQualifyInPort) || 
                                 (entry->quals_info[qual_idx_2].qualify == bcmFieldQualifyInterfaceInPorts) ) {
                                entry->quals_info[qual_index].is_valid = FALSE;
                                break;
                            }
                        }
                    }

                    /* bcmFieldQualifyOutPort and bcmFieldQualifyOutPorts can't be both */
                    if(qualify == bcmFieldQualifyOutPort) {
                        for(qual_idx_2 = 0; qual_idx_2 < qual_index; ++qual_idx_2) {
                            if(entry->quals_info[qual_idx_2].is_valid
                                && entry->quals_info[qual_idx_2].qualify == bcmFieldQualifyOutPorts){
                                entry->quals_info[qual_index].is_valid = FALSE;
                                break;
                            }
                        }
                    }
                }

                if(with_traffic) {
                    if(!is_scan_mode) {
                        if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), qualify)) {
                            entry->quals_info[qual_index].is_valid = FALSE;
                        }
                    }
                    if(entry->quals_info[qual_index].is_valid) {
                        entry->quals_info[qual_index].is_valid = _bcm_petra_field_test_can_insert_qualifier_traffic(qualify, qset, &cur_key);
                    }
                }
                            
                if(entry->quals_info[qual_index].is_valid) {
                    BCM_FIELD_QSET_ADD(cur_key, qualify);    
                    /* for each valid qualifier get a random value (and mask if needed) and set them in the hardware */
                    if((entry->id & BCM_FIELD_QUALIFY_PRESEL) == 0) {
                        result = _bcm_petra_field_test_set_qualifier(unit,
                                                                     stage,
                                                                     type,
                                                                     qualify,
                                                                     x + second_rand_param++,
                                                                     entry->quals_info[qual_index].data,
                                                                     entry->quals_info[qual_index].mask);
                    } else {
                        result = _bcm_petra_field_test_set_presel(unit,
                                                                  stage,
                                                                  type,
                                                                  qualify,
                                                                  x + second_rand_param,
                                                                  entry->quals_info[qual_index].data,
                                                                  entry->quals_info[qual_index].mask);
                    }
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return result;
                    }

                    rv = _bcm_petra_field_test_operate_set_function(unit,
                                                                    stage,
                                                                    type,
                                                                    entry->id,
                                                                    qualify,
                                                                    entry->quals_info[qual_index].data,
                                                                    entry->quals_info[qual_index].mask);
                    if(rv == BCM_E_UNAVAIL) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_WARN) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "Failure: the qualifier %d is not supported yet\n"), qualify));
                        }
                        entry->quals_info[qual_index].is_valid = FALSE;
                    } else if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }
            ++qual_index;
        }
    }
    for(; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
        entry->quals_info[qual_index].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
        entry->quals_info[qual_index].is_valid = FALSE;
    }

    return CMD_OK;
}

/* return 1 if the intervals [first_left, first_right] and [second_left, second_right] have intersection not empty
   0, otherwise */ 
STATIC uint8 have_intersection(int first_left, int first_right, int second_right, int second_left) {
    if(first_left <= second_left && second_left <= first_right) {
        /* the intersection is [second_left, min(first_right, second_right)] */
        return TRUE;
    } else if(second_left <= first_left && first_left <= second_right) {
        /* the intersection is [first_left, min(first_right,second_right)] */
        return TRUE;
    } else if(first_left <= second_left && first_right >= second_right) {
        /* the intersection is [second_left, second_right] */
        return TRUE;
    } else if(first_left >= second_left && first_right <= second_right) {
        /* the intersection is [first_left, first_right] */
        return TRUE;
    } else {
        return FALSE;
    }
}

STATIC cmd_result_t _bcm_petra_field_test_set_entry_data_qualifiers(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_qset_t *qset, uint8 with_traffic, uint32 x, uint8 is_scan_mode, _bcm_petra_field_test_entry_info_t *entry)
{
    bcm_error_t rv;
    cmd_result_t result;
    uint32 second_rand_param = 0;
    uint32 qual_index, qual_index_2;
    uint32 index;
    bcm_field_qset_t cur_key, fg_predefined_qset;
    int qual_arr[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1];
    uint8 can_be_valid[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1];
    int qual_count;
    bcm_field_data_qualifier_t *dq = NULL;
    uint32 qual_length;
    uint8 data8[8], mask8[8];
    uint64 edata, emask;
    uint32 type = _BCM_PETRA_FIELD_TYPE_ETHR;
    if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV4;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV6;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls)) {
        type = _BCM_PETRA_FIELD_TYPE_MPLS;
    }

    qual_index = 0;
    rv = bcm_field_qset_data_qualifier_get(unit,
                                           *qset,
                                           _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1,
                                           qual_arr,
                                           &qual_count);
    if(rv != BCM_E_NONE){
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    
    BCM_FIELD_QSET_INIT(fg_predefined_qset);
    BCM_FIELD_QSET_INIT(cur_key);
    dq = sal_alloc(sizeof(*dq) * (_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1), "_bcm_petra_field_test_set_entry_data_qualifiers.dq");
    if(!dq) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failue\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(qual_index = 0; qual_index < qual_count; ++qual_index) {
        bcm_field_data_qualifier_t_init(&dq[qual_index]);
        can_be_valid[qual_index] = TRUE;
        rv = bcm_field_data_qualifier_get(unit, qual_arr[qual_index], &dq[qual_index]);
        if (rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            sal_free(dq);
            return CMD_FAIL;
        }
        if((dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) == 0) {
            dq[qual_index].offset *= 8;
        } 
        if((dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
            dq[qual_index].length *= 8;
        } 

        if(dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) {
            BCM_FIELD_QSET_ADD(fg_predefined_qset, dq[qual_index].qualifier);
        }
        if(dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE) {
            dq[qual_index].flags &= ~BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE;
            /* we will translate it to positive data qualifier */
            /* we assume that we have ipv4 over ipv6 over ethernet with one vlan */
            switch(dq[qual_index].offset_base) {
                case bcmFieldDataOffsetBaseThirdHeader:
                    dq[qual_index].offset_base = bcmFieldDataOffsetBasePacketStart;
                    if(dq[qual_index].offset > (160 + 320 + 144) && with_traffic) {
                        can_be_valid[qual_index] = FALSE;
                    }
                    dq[qual_index].offset = (160 + 320 + 144) - dq[qual_index].offset;
                    break;
                case bcmFieldDataOffsetBaseSecondHeader:
                    dq[qual_index].offset_base = bcmFieldDataOffsetBasePacketStart;
                    if(dq[qual_index].offset > (320 + 144) && with_traffic) {
                        can_be_valid[qual_index] = FALSE;
                    }
                    dq[qual_index].offset = (320 + 144) - dq[qual_index].offset;
                    break;
                case bcmFieldDataOffsetBaseFirstHeader:
                    dq[qual_index].offset_base = bcmFieldDataOffsetBasePacketStart;
                    if(dq[qual_index].offset > 144 && with_traffic) {
                        can_be_valid[qual_index] = FALSE;
                    }
                    dq[qual_index].offset = 144 - dq[qual_index].offset;
                    break;
                default:
                    sal_free(dq);
                    return CMD_FAIL;
            } 
        }
    }

    if(qual_count > _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY - 1) {
        if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4) ||
            BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6) ||
            BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls) ) {
            qual_count = _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY - 1;
        } else {
            qual_count = _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY;
        }
    }
    
    /* for each qualifier decide if it will be taken */
    for(qual_index = 0; qual_index < qual_count; ++qual_index) {
        entry->quals_info[qual_index].qualify = qual_arr[qual_index];
        entry->quals_info[qual_index].is_undefined = TRUE;    
        entry->quals_info[qual_index].is_valid = can_be_valid[qual_index] &&
            (is_scan_mode || (_bcm_petra_field_rand_val(x, second_rand_param++) % 2));

        if(with_traffic && entry->quals_info[qual_index].is_valid) {
        /* in some cases we will disable qualifier:
           if it points to place that should have constant.
           we assume that the header format is ipv4 over ipv6 over ethernet with one vlan.
           another case is that we have overlapping */
            if((dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) == 0) {
                /* offsets of places with constant values */
                if(dq[qual_index].offset_base == bcmFieldDataOffsetBasePacketStart ||
                    dq[qual_index].offset_base == bcmFieldDataOffsetBaseL2Header) {
                    /* bytes 0 in order to assert s.a. != 0 */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset/8 + dq[qual_index].length/8 - 1, 6, 6)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* bytes 12-13 tpid of the vlan */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 12, 13)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* bytes 16-17 ethertype */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 16, 17)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 18 ipv6 version */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 18, 18)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 22-24 ipv6 payload length and next header */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 22, 24)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 58 ipv4 header */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 58, 58)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 59 ipv4 internet_header_length */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 59, 59)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                } else if(dq[qual_index].offset_base == bcmFieldDataOffsetBaseFirstHeader) {
                    /* byte 0 ipv6 version */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 0, 0)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 4-6 ipv6 payload length and next header */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 4, 6)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 40 ipv4 header */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 40, 40)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 41 ipv4 internet_header_length */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 41, 41)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                } else if(dq[qual_index].offset_base == bcmFieldDataOffsetBaseSecondHeader) {
                    /* byte 0 ipv4 header */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 0, 0)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                    /* byte 1 ipv4 internet_header_length */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, 1, 1)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                }
                        
                /* overlapping checking */

                /* scaling the offset according to the ethernet as base to check overlapping 
                   we will not use the offset any more. Only for overlapping checking */
                if(dq[qual_index].offset_base == bcmFieldDataOffsetBaseFirstHeader) {
                    dq[qual_index].offset += 18 * 8;
                } else if(dq[qual_index].offset_base == bcmFieldDataOffsetBaseSecondHeader) {
                    dq[qual_index].offset += 58 * 8;
                }
                for(qual_index_2 = 0; qual_index_2 < qual_index; ++qual_index_2) {
                    /* no need to scale the precious dq-s they have already scaled */
                    if(have_intersection(dq[qual_index].offset / 8, dq[qual_index].offset / 8 + dq[qual_index].length / 8 - 1, dq[qual_index_2].offset / 8, dq[qual_index_2].offset / 8 + dq[qual_index_2].length / 8 - 1)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                        break;
                    }
                }
            } else {
                if(!is_scan_mode) {
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), dq[qual_index].qualifier)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                }
                if(entry->quals_info[qual_index].is_valid) {
                    entry->quals_info[qual_index].is_valid = _bcm_petra_field_test_can_insert_qualifier_traffic(dq[qual_index].qualifier, &fg_predefined_qset, &cur_key);
                }
                if(entry->quals_info[qual_index].is_valid) {
                    BCM_FIELD_QSET_ADD(cur_key, dq[qual_index].qualifier);
                }
            }
        }

        if(entry->quals_info[qual_index].is_valid) {
            /* for each valid qualifier get a random value (and mask if needed) and set them in the hardware */
            if(dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) {
                result = _bcm_petra_field_test_set_qualifier(unit,
                                                             stage,
                                                             type,
                                                             dq[qual_index].qualifier,
                                                             x + second_rand_param++,
                                                             entry->quals_info[qual_index].data,
                                                             entry->quals_info[qual_index].mask);
                if(result != CMD_OK) {
                    sal_free(dq);
                    return result;
                }
                
                /* In these cases no mask */
                if(dq[qual_index].qualifier == bcmFieldQualifyInnerTpid || dq[qual_index].qualifier == bcmFieldQualifyOuterTpid) {
                    entry->quals_info[qual_index].mask[0] = 0xffff;
                }
                
                /* scale the data and mask */
                COMPILER_64_SET(edata, entry->quals_info[qual_index].data[1], entry->quals_info[qual_index].data[0]);
                COMPILER_64_SET(emask, entry->quals_info[qual_index].mask[1], entry->quals_info[qual_index].mask[0]);
                COMPILER_64_SHR(edata, dq[qual_index].offset);
                COMPILER_64_SHR(emask, dq[qual_index].offset);
                if(dq[qual_index].length < 32) {
                   entry->quals_info[qual_index].data[0] = COMPILER_64_LO(edata) & ((1 << dq[qual_index].length) - 1);
                   entry->quals_info[qual_index].mask[0] = COMPILER_64_LO(emask) & ((1 << dq[qual_index].length) - 1);
                   entry->quals_info[qual_index].data[1] = 0;
                   entry->quals_info[qual_index].mask[1] = 0;
                } else {
                   entry->quals_info[qual_index].data[0] = COMPILER_64_LO(edata);
                   entry->quals_info[qual_index].mask[0] = COMPILER_64_LO(emask);
                   if(dq[qual_index].length < 64) {
                       entry->quals_info[qual_index].data[1] = COMPILER_64_HI(edata) & ((1 << (dq[qual_index].length - 32)) - 1);
                       entry->quals_info[qual_index].mask[1] = COMPILER_64_HI(emask) & ((1 << (dq[qual_index].length - 32)) - 1);
                   } else {
                       entry->quals_info[qual_index].data[1] = COMPILER_64_HI(edata);
                       entry->quals_info[qual_index].mask[1] = COMPILER_64_HI(emask);
                   }
                }
            } else {            
                if(dq[qual_index].length < 32) {
                    entry->quals_info[qual_index].data[0] = 
                        _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << dq[qual_index].length);
                    entry->quals_info[qual_index].mask[0] = 
                        _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << dq[qual_index].length);
                    entry->quals_info[qual_index].data[0] &= entry->quals_info[qual_index].mask[0];
                    entry->quals_info[qual_index].data[1] = 0;
                    entry->quals_info[qual_index].mask[1] = 0;
                } else {
                    entry->quals_info[qual_index].data[0] = 
                        _bcm_petra_field_rand_val(x, second_rand_param++);
                    entry->quals_info[qual_index].mask[0] = 
                        _bcm_petra_field_rand_val(x, second_rand_param++);
                    if(dq[qual_index].length < 64) {
                        entry->quals_info[qual_index].data[1] = 
                            _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (dq[qual_index].length - 32));
                        entry->quals_info[qual_index].mask[1] = 
                            _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (dq[qual_index].length - 32));
                    } else {
                        entry->quals_info[qual_index].data[1] = 
                            _bcm_petra_field_rand_val(x, second_rand_param++);
                        entry->quals_info[qual_index].mask[1] = 
                            _bcm_petra_field_rand_val(x, second_rand_param++);
                    }
                    entry->quals_info[qual_index].data[0] &= entry->quals_info[qual_index].mask[0];
                    entry->quals_info[qual_index].data[1] &= entry->quals_info[qual_index].mask[1];
                }
            }
            data8[0] = entry->quals_info[qual_index].data[0] & 0xff;
            data8[1] = (entry->quals_info[qual_index].data[0] & 0xff00) >> 8;
            data8[2] = (entry->quals_info[qual_index].data[0] & 0xff0000) >> 16;
            data8[3] = (entry->quals_info[qual_index].data[0] & 0xff000000) >> 24;
            data8[4] = entry->quals_info[qual_index].data[1] & 0xff;
            data8[5] = (entry->quals_info[qual_index].data[1] & 0xff00) >> 8;
            data8[6] = (entry->quals_info[qual_index].data[1] & 0xff0000) >> 16;
            data8[7] = (entry->quals_info[qual_index].data[1] & 0xff000000) >> 24;
            mask8[0] = entry->quals_info[qual_index].mask[0] & 0xff;
            mask8[1] = (entry->quals_info[qual_index].mask[0] & 0xff00) >> 8;
            mask8[2] = (entry->quals_info[qual_index].mask[0] & 0xff0000) >> 16;
            mask8[3] = (entry->quals_info[qual_index].mask[0] & 0xff000000) >> 24;
            mask8[4] = entry->quals_info[qual_index].mask[1] & 0xff;
            mask8[5] = (entry->quals_info[qual_index].mask[1] & 0xff00) >> 8;
            mask8[6] = (entry->quals_info[qual_index].mask[1] & 0xff0000) >> 16;
            mask8[7] = (entry->quals_info[qual_index].mask[1] & 0xff000000) >> 24;
            qual_length = dq[qual_index].length;
            if(qual_length % 8){
                qual_length /= 8;
                ++qual_length;
            } else {
                qual_length /= 8;
            }
            /* we opposite the data and mask */
            for(index = 0; index < qual_length / 2; ++index) {
                data8[index] ^= data8[qual_length - 1 - index];
                data8[qual_length - 1 - index] ^= data8[index];
                data8[index] ^= data8[qual_length - 1 - index];
                mask8[index] ^= mask8[qual_length - 1 - index];
                mask8[qual_length - 1 - index] ^= mask8[index];
                mask8[index] ^= mask8[qual_length - 1 - index];
            }
            rv = bcm_field_qualify_data(unit, entry->id, qual_arr[qual_index], data8, mask8, qual_length);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                sal_free(dq);
                return CMD_FAIL;
            }
        }
    }
    sal_free(dq);

    qual_index = qual_count;
    
    if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4)) {
        entry->quals_info[qual_index].qualify = bcmFieldQualifyIp4;
        entry->quals_info[qual_index].is_valid = FALSE;
        ++qual_index;
    } else if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6)) {
        entry->quals_info[qual_index].qualify = bcmFieldQualifyIp6;
        entry->quals_info[qual_index].is_valid = FALSE;
        ++qual_index;
    } else if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls)) {
        entry->quals_info[qual_index].qualify = bcmFieldQualifyMpls;
        entry->quals_info[qual_index].is_valid = FALSE;
        ++qual_index;
    }

    for(; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
        entry->quals_info[qual_index].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
        entry->quals_info[qual_index].is_valid = FALSE;
    }
    return CMD_OK;
}

static const bcm_field_aset_t* get_set_get_action_failure(void){
    const static bcm_field_action_t set_get_action_failure[] = {
        bcmFieldActionMirrorIngress,
        bcmFieldActionL3Switch,
        bcmFieldActionPolicerLevel0,
        bcmFieldActionPolicerLevel1,
        bcmFieldActionSnoop,
        bcmFieldActionDstRpfGportNew,
        bcmFieldActionSrcGportNew,
        bcmFieldActionIngressGportSet,
        bcmFieldActionLearnSrcPortNew,
        bcmFieldActionTrap,
        bcmFieldActionTrapReduced,
        bcmFieldActionLearnInVPortNew,
    
        /* failure in egress stage */
        bcmFieldActionCosQNew,
        bcmFieldActionMirrorEgress,
        bcmFieldActionStat0,
        bcmFieldActionVSQ,
    
        bcmFieldActionStat,
        bcmFieldActionStatVportNew,
        bcmFieldActionRedirect,
        bcmFieldActionRedirectPort,
        bcmFieldActionRedirectVportPort,
    
        /* This action causes failure in the entry installation*/
        bcmFieldActionVportNew,
        bcmFieldActionTrapCodeQualifier,
        bcmFieldActionPphSnoopCode,
        bcmFieldActionStaggeredPreselProfile0Set,
        bcmFieldActionStaggeredPreselProfile1Set,
        bcmFieldActionStaggeredPreselProfile2Set,
        bcmFieldActionStaggeredPreselProfile3Set,
        bcmFieldActionStaggeredPreselProfileDirectSet,

        /* Double Action */
        bcmFieldActionSnoopAndTrap,
        bcmFieldActionStatAndPolicer
    };    
    static uint8 is_set = FALSE;
    static bcm_field_aset_t aset;
    uint32 index;
    
    if(!is_set){
        BCM_FIELD_ASET_INIT(aset);
        for(index = 0; index < sizeof(set_get_action_failure)/sizeof(bcm_field_action_t); ++index) {
            BCM_FIELD_ASET_ADD(aset, set_get_action_failure[index]);
        }
        is_set = TRUE;
    }
    
    return &aset;
}

STATIC cmd_result_t _bcm_petra_field_test_set_entry_actions(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_aset_t *aset, uint8 with_traffic, uint8 is_scan_mode, uint8 perf, uint32 x, _bcm_petra_field_test_entry_info_t *entry)
{
    bcm_error_t rv;
    cmd_result_t result;
    bcm_field_action_t action;
    uint32 action_index;
    uint32 second_rand_param = 0;
    
    action_index = 0;
    for(action = 0; action < bcmFieldActionCount; ++action) {
        if(BCM_FIELD_ASET_TEST(*aset, action)) {
            entry->actions_info[action_index].action = action;
            if((stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS || is_scan_mode || perf) && with_traffic) {
                entry->actions_info[action_index].is_valid = TRUE;
            } else {
                entry->actions_info[action_index].is_valid = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            }
            
            if(BCM_FIELD_ASET_TEST(*get_set_get_action_failure(), action)) {
                entry->actions_info[action_index].is_valid = FALSE;
            }

            if(action == bcmFieldActionCascadedKeyValueSet) {
                entry->actions_info[action_index].is_valid = FALSE;
            }

            if(entry->actions_info[action_index].is_valid) {
                /* for each valid action get a random param0 and param1 and set them in the hardware */
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS && with_traffic) {
                    entry->actions_info[action_index].param0 = _BCM_PETRA_FIELD_EGRESS_COS_PROFILE_FOR_HIT_CHECK +
                        (BCM_INT_QOS_MAP_TYPE_EGRESS << BCM_INT_QOS_MAP_TYPE_SHIFT);
                    entry->actions_info[action_index].param1 = 0;
                } else {
                    result = _bcm_petra_field_test_set_action(unit,
                                                              action,
                                                              x + second_rand_param++,
                                                              &entry->actions_info[action_index].param0,
                                                              &entry->actions_info[action_index].param1);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return result;
                    }
                }
                rv = bcm_field_action_add(unit,
                                          entry->id,
                                          action,
                                          entry->actions_info[action_index].param0,
                                          entry->actions_info[action_index].param1);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
            ++action_index;
        }
    }
    
    for(; action_index < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_index) {
        entry->actions_info[action_index].is_valid = FALSE;
    }
    
    return CMD_OK;
}

#ifdef BCM_WARM_BOOT_SUPPORT
static args_t wb_args;
#define _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv)\
{\
    test_t test;\
    test.t_name = "WARMBOOT test";\
    test.t_flags = 3;\
    test.t_test = 141;\
    test.t_loops = 1;\
    test.t_init_f = init_deinit_test_init;\
    test.t_done_f = init_deinit_test_done;\
    test.t_test_f = init_deinit_test;\
    test.t_default_string = 0x0;\
    test.t_override_string = 0x0;\
    test.t_runs = 0;\
    test.t_success = 0;\
    test.t_fail = 0;\
    wb_args.a_cmd = "TestRun";\
    wb_args.a_argv[0] = "tr";\
    wb_args.a_argv[1] = "141";\
    wb_args.a_argv[2] = "Warmboot=1";\
    sal_strncpy(wb_args.a_buffer, "tr\0141\0Warmboot=1", ARGS_BUFFER);\
    wb_args.a_argc = 3;\
    wb_args.a_arg = 2;\
    rv = test_dispatch(unit, &test, -1, &wb_args);\
    if(rv != BCM_E_NONE) {\
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;\
        goto fail;\
    }\
}
#endif /* BCM_WARM_BOOT_SUPPORT */

/*
 * The function gets field group information that has been set to the hardware with one qualifier and one action.
 * The functiuon creates one entry set it in the hardware and if the parameter with_traffic is set it send packet
 *  to  verify hit (ingress stage only).
 */
STATIC cmd_result_t _bcm_petra_field_entry_scan_test(int unit, _bcm_dpp_field_stage_idx_t stage, bcm_field_group_config_t *field_group, uint8 with_traffic, uint8 is_predefined, uint8 do_warmboot)
{
    _bcm_petra_field_test_entry_info_t *entry;
    bcm_error_t rv;
    cmd_result_t result;

    entry = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t), "_bcm_petra_field_entry_scan_test.entry");
    if(!entry) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "memory allocation failure.\n")));
        return CMD_FAIL;
    }
    
    rv = bcm_field_entry_create(unit, field_group->group, &entry->id);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    /* priority */
    if(field_group->mode != bcmFieldGroupModeDirect) {
        entry->priority = sal_rand() & BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
        rv = bcm_field_entry_prio_set(unit, entry->id, entry->priority);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    
    if(is_predefined) {
        result = _bcm_petra_field_test_set_entry_data_qualifiers(unit, stage, &field_group->qset, with_traffic, sal_rand(), TRUE, entry);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    } else {
        result = _bcm_petra_field_test_set_entry_qualifiers(unit, stage, &field_group->qset, with_traffic, FALSE, sal_rand(), TRUE, entry);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    /* actions of the entry */
    result = _bcm_petra_field_test_set_entry_actions(unit, stage, &field_group->aset, with_traffic, TRUE, FALSE, sal_rand(), entry);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    rv = bcm_field_entry_install(unit, entry->id);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    if(do_warmboot && field_group->mode != bcmFieldGroupModeDirect) {
        _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
    }
#endif

    result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, entry, (field_group->mode == bcmFieldGroupModeDirect), TRUE);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    
    if(with_traffic) {
        result = _bcm_petra_field_test_traffic_test(unit, stage, is_predefined, FALSE, (field_group->mode == bcmFieldGroupModeDirect), field_group->group, entry, 1);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    
    rv = bcm_field_entry_destroy(unit, entry->id);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    
    sal_free(entry);
    return CMD_OK;

fail:
    sal_free(entry);
    return CMD_FAIL;
}


STATIC cmd_result_t _bcm_petra_field_test_fill_data_qualifier_with_qualifier(int unit,
                                                                            _bcm_dpp_field_stage_idx_t stage,
                                                                            uint32 x,
                                                                            bcm_field_qualify_t qualifier,
                                                                            uint8 is_de_large,
                                                                            bcm_field_data_qualifier_t *dq)
{
    uint32 second_rand_param = 0;
    uint32 rnd;
    bcm_error_t rv;
    uint32 length;
    uint32 offset_bit;
    
    /* flags */
    dq->flags = BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED;
    /* flags - with id */
    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
    if(rnd) {
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
        dq->qual_id = (_bcm_petra_field_rand_val(x, second_rand_param++) % 
        _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit)) + 1;
    }
    
    /* flags - replace */
    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
    if(rnd) {
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_REPLACE;
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
        dq->qual_id = 0;
    }
    
    /* flags - offset bit resolution */
    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
    if(rnd) {
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES;
    }
    
    /* flags - length bit resolution */
    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
    if(rnd) {
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES;
    }
    
    /* get the qualifier length */
    rv = _bcm_petra_field_test_qualify_exposed_length(unit, stage, 0xffffffff, qualifier, &length);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
        
    /* offset */
    dq->offset = _bcm_petra_field_rand_val(x, second_rand_param++) % 
        length;
    if((dq->flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) == 0) {
        dq->offset /= 8;
        offset_bit = dq->offset * 8;
    } else {
        if(is_de_large && ((dq->offset % 4) > 0) ) {
            dq->offset -= dq->offset % 4;
        }
        offset_bit = dq->offset;
    }
        
    /* length */
    if(length - offset_bit < 8) {
        /* we can't take 1 byte, and hence we must set this flag */
        dq->flags |= BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES;
    }

    if(length == offset_bit) {
        dq->length = 1;
    } else {
        dq->length = _bcm_petra_field_rand_val(x, second_rand_param++) %
            (length - offset_bit) + 1;
    }

    
    if(dq->length > 32) {
        dq->length = 32;
    }
    
    if(is_de_large && dq->length > 16) {
        /* in this case the length can't be more than 16 */
        dq->length = 16;
    }

    if(is_de_large && ((dq->length % 4) > 0) ) {
        dq->length -= dq->length % 4;
        if(dq->length == 0) {
            dq->length = 4;
        }
    }

    if((dq->flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
        dq->length /= 8;
        if(dq->length == 0) {
            ++dq->length;
        }
    }
    
    dq->qualifier = qualifier;

    /* stage */
    switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS:
            dq->stage = bcmFieldStageEgress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            dq->stage = bcmFieldStageExternal;
            break;
        default:
            dq->stage = bcmFieldStageIngress;
            break;
    }   
    
    return CMD_OK;
}

static CONST bcm_field_qset_t* _bcm_petra_field_test_supported_qualifiers_for_data_qualifier(int unit, _bcm_dpp_field_stage_idx_t stage) {
    CONST static bcm_field_qualify_t supported_qualifiers_for_data_qualifier_ingress[] = {
            bcmFieldQualifySrcIp6High,
            bcmFieldQualifyDstIp6High,
            bcmFieldQualifySrcIp6Low,
            bcmFieldQualifyDstIp6Low,
            /* bcmFieldQualifyDSCP, */
            /* bcmFieldQualifyTtl, */
            bcmFieldQualifyTcpControl,
            bcmFieldQualifyInnerSrcIp,
            bcmFieldQualifyInnerDstIp,
            bcmFieldQualifyInnerTos,
            bcmFieldQualifyInnerTtl,
            bcmFieldQualifyInnerIpProtocol,
            bcmFieldQualifyInnerL4SrcPort,
            bcmFieldQualifyInnerL4DstPort,
            bcmFieldQualifyL3DestHostHit,
            bcmFieldQualifyL3SrcHostHit,
            bcmFieldQualifyVlanTranslationHit,
            bcmFieldQualifyTunnelTerminated,
            bcmFieldQualifyMplsTerminated,
            bcmFieldQualifyIpTunnelHit,
            bcmFieldQualifyL2DestHit,
            bcmFieldQualifyL2SrcHit,
            bcmFieldQualifyL3DestRouteHit,
            bcmFieldQualifyL3SrcRouteHit,
            bcmFieldQualifyIpmcHit,
            bcmFieldQualifyVlanTranslationValue,
            bcmFieldQualifyTunnelTerminatedValue,
            bcmFieldQualifyMplsTerminatedValue,
            bcmFieldQualifyIpTunnelValue,
            bcmFieldQualifyL2DestValue,
            bcmFieldQualifyL2SrcValue,
            bcmFieldQualifyL3DestRouteValue,
            bcmFieldQualifyL3SrcRouteValue,
            bcmFieldQualifyIpmcValue,
            bcmFieldQualifyInterfaceClassProcessingPort,
            bcmFieldQualifyInVPort,
            bcmFieldQualifyOutVPort,
            bcmFieldQualifyDrop,
            bcmFieldQualifyDstMulticastGroup,
            bcmFieldQualifyFlowId,
            bcmFieldQualifyVpn,
            bcmFieldQualifyPacketTerminatedBytes,
            bcmFieldQualifyIntPriority,
            bcmFieldQualifyDstMac,
            bcmFieldQualifySrcMac,
            bcmFieldQualifyInnerSrcMac,
            bcmFieldQualifyOuterTpid,
            bcmFieldQualifyOuterVlanId,
            bcmFieldQualifyOuterVlanPri,
            bcmFieldQualifyOuterVlanCfi,
            bcmFieldQualifyOuterVlan,
            bcmFieldQualifyInnerTpid,
            bcmFieldQualifyInnerVlanId,
            bcmFieldQualifyInnerVlanPri,
            bcmFieldQualifyInnerVlanCfi,
            bcmFieldQualifyInnerVlan,
            bcmFieldQualifySrcIp,
            bcmFieldQualifyDstIp,
            /*bcmFieldQualifyIpProtocol,*/
            bcmFieldQualifyIpFlags,
            bcmFieldQualifyL4DstPort,
            bcmFieldQualifyL4SrcPort,
            bcmFieldQualifyIp6FlowLabel,
            bcmFieldQualifyMplsForwardingLabel,
            bcmFieldQualifyMplsForwardingLabelId,
            bcmFieldQualifyMplsForwardingLabelTtl,
            bcmFieldQualifyMplsForwardingLabelBos,
            bcmFieldQualifyMplsForwardingLabelExp,
            bcmFieldQualifyMplsLabel1,
            bcmFieldQualifyMplsLabel1Id,
            bcmFieldQualifyMplsLabel1Ttl,
            bcmFieldQualifyMplsLabel1Bos,
            bcmFieldQualifyMplsLabel1Exp,
            bcmFieldQualifyMplsLabel2,
            bcmFieldQualifyMplsLabel2Id,
            bcmFieldQualifyMplsLabel2Ttl,
            bcmFieldQualifyMplsLabel2Bos,
            bcmFieldQualifyMplsLabel2Exp,
            bcmFieldQualifyMplsLabel3,
            bcmFieldQualifyMplsLabel3Id,
            bcmFieldQualifyMplsLabel3Ttl,
            bcmFieldQualifyMplsLabel3Bos,
            bcmFieldQualifyMplsLabel3Exp,
            bcmFieldQualifyInPort,
            bcmFieldQualifyPtch,
            bcmFieldQualifyMplsBos,
            bcmFieldQualifyDstL3Egress,
            bcmFieldQualifyRxTrapData,
            bcmFieldQualifyPolicerIntPrio,
            bcmFieldQualifyInterfaceClassL2,
            bcmFieldQualifyForwardingVlanId,
            bcmFieldQualifyPortOrientation,
            bcmFieldQualifyLearnSrcMac,
            bcmFieldQualifyLearnVlan,
            bcmFieldQualifyLearnSrcPort,
            bcmFieldQualifyL2StationMove,
            bcmFieldQualifyDhcp,
            bcmFieldQualifyTrillEgressRbridge,
            bcmFieldQualifyISid,
            bcmFieldQualifyMplsForwardingLabelAction,
            bcmFieldQualifyL3Ingress,
            bcmFieldQualifyExternalValue0,      
            bcmFieldQualifyExternalValue1,      
            bcmFieldQualifyExternalValue2,     
            bcmFieldQualifyExternalValue3,     
            bcmFieldQualifyExternalValue4,     
            bcmFieldQualifyExternalValue5,     
            bcmFieldQualifyExternalHit0,       
            bcmFieldQualifyExternalHit1,       
            bcmFieldQualifyExternalHit2,       
            bcmFieldQualifyExternalHit3,       
            bcmFieldQualifyExternalHit4,
            bcmFieldQualifyExternalHit5,       
		    bcmFieldQualifyIngressVPortBridgeDisable
    };

    CONST static bcm_field_qualify_t supported_qualifiers_for_data_qualifier_egress[] = {
            bcmFieldQualifySrcMac,
            bcmFieldQualifyDstMac,
            bcmFieldQualifySrcIp,
            bcmFieldQualifyDstIp,
            bcmFieldQualifyDSCP,
            bcmFieldQualifyTtl,
            bcmFieldQualifyDstClassField,
            bcmFieldQualifySrcClassField,
            bcmFieldQualifyInterfaceClassPort,
            bcmFieldQualifyInterfaceClassProcessingPort,
            bcmFieldQualifyInVPort,
            bcmFieldQualifyOutVPort,
            bcmFieldQualifyPacketSize,
            bcmFieldQualifyVrf,
            bcmFieldQualifyVpn,
            bcmFieldQualifyPacketTerminatedBytes,
            bcmFieldQualifyOutPort,
            bcmFieldQualifyTrunkHashResult,
            bcmFieldQualifyIntPriority,
            bcmFieldQualifyInterfaceClassVPort,
            bcmFieldQualifyForwardCopy,
            bcmFieldQualifySnoopCopy,
            bcmFieldQualifyMirrorCopy,
            bcmFieldQualifyPacketRes,
            bcmFieldQualifyEcnValue,
            bcmFieldQualifyReplicantFirst,
            bcmFieldQualifyReplicantAny,
            bcmFieldQualifyCnTag,
            bcmFieldQualifyOuterTpid,
            bcmFieldQualifyOuterVlanId,
            bcmFieldQualifyOuterVlanPri,
            bcmFieldQualifyOuterVlanCfi,
            bcmFieldQualifyOuterVlan,
            bcmFieldQualifyInnerTpid,
            bcmFieldQualifyInnerVlanId,
            bcmFieldQualifyInnerVlanPri,
            bcmFieldQualifyInnerVlanCfi,
            bcmFieldQualifyInnerVlan,
            bcmFieldQualifyTranslatedOuterVlanId,
            bcmFieldQualifyTranslatedOuterVlanPri,
            bcmFieldQualifyTranslatedOuterVlanCfi,
            bcmFieldQualifyTranslatedOuterVlan,
            bcmFieldQualifyTranslatedInnerVlanId,
            bcmFieldQualifyTranslatedInnerVlanPri,
            bcmFieldQualifyTranslatedInnerVlanCfi,
            bcmFieldQualifyTranslatedInnerVlan,
            bcmFieldQualifyIpProtocol,
            bcmFieldQualifyL4DstPort,
            bcmFieldQualifyL4SrcPort,
            bcmFieldQualifyIp6FlowLabel,
            bcmFieldQualifyMplsForwardingLabel,
            bcmFieldQualifyMplsForwardingLabelId,
            bcmFieldQualifyMplsForwardingLabelTtl,
            bcmFieldQualifyMplsForwardingLabelBos,
            bcmFieldQualifyMplsForwardingLabelExp,
            bcmFieldQualifyL2Learn
    };

    /* will be set to zero in the bringup */
    static uint8 is_set[_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL + 1];

    static bcm_field_qset_t qset[_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL + 1];
    uint32 qual_index;
    uint32 type;
    bcm_field_qset_t valid_external_qset[_BCM_PETRA_FIELD_NOF_TYPES];
    bcm_field_aset_t junk;
    bcm_error_t rv;
    
    if(!is_set[stage]) {
        BCM_FIELD_QSET_INIT(qset[stage]);
        if(stage != _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                for(type = 0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
                    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, stage, type, &valid_external_qset[type], &junk);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return NULL;
                    }
                }
            }
            for(qual_index = 0;
                qual_index < sizeof(supported_qualifiers_for_data_qualifier_ingress)/sizeof(bcm_field_qualify_t);
                ++qual_index) {
                BCM_FIELD_QSET_ADD(qset[stage], supported_qualifiers_for_data_qualifier_ingress[qual_index]);
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    /* Remove qualifiers are not supported in the external stage */
                    for(type = 0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
                        if(BCM_FIELD_QSET_TEST(valid_external_qset[type], supported_qualifiers_for_data_qualifier_ingress[qual_index])) {
                            break;
                        }
                        if(type == _BCM_PETRA_FIELD_NOF_TYPES - 1) {
                            /* i.e. there is no type of external stage which this qualifier is supported in */
                            BCM_FIELD_QSET_REMOVE(qset[stage], supported_qualifiers_for_data_qualifier_ingress[qual_index]);
                        }
                    }
                }
            }
        } else {
            for(qual_index = 0;
                qual_index < sizeof(supported_qualifiers_for_data_qualifier_egress)/sizeof(bcm_field_qualify_t);
                ++qual_index) {
                BCM_FIELD_QSET_ADD(qset[stage], supported_qualifiers_for_data_qualifier_egress[qual_index]);
            }
        }
        is_set[stage] = TRUE;
    }
    
    return &qset[stage];
}
    

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
static args_t args;
#ifdef BCM_88660_A0
#define _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv)\
{\
    test_t test;\
    cmd_result_t _result = CMD_OK;\
    test.t_name = "DEINT INIT (SOC BCM)";\
    test.t_flags = 0x80100000;\
    test.t_test = 141;\
    test.t_loops = 1;\
    test.t_init_f = init_deinit_test_init;\
    test.t_done_f = init_deinit_test_done;\
    test.t_test_f = init_deinit_test;\
    test.t_default_string = 0x0;\
    test.t_override_string = 0x0;\
    test.t_runs = 0;\
    test.t_success = 0;\
    test.t_fail = 0;\
    args.a_cmd = "TestRun";\
    args.a_argv[0] = "tr";\
    args.a_argv[1] = "141";\
    args.a_argv[2] = "noelkappl=1";\
    if((SOC_IS_ARADPLUS(unit)) && (SOC_DPP_CONFIG(unit)->arad->init.elk.ext_interface_mode)) {\
        args.a_argv[3] = "ElkIlknRev=0";\
        sal_strcpy(args.a_buffer, "tr\0141\0noelkappl=0\0ElkIlknRev=0");\
    } else{\
        args.a_argv[3] = "ElkIlknRev=1";\
        sal_strcpy(args.a_buffer, "tr\0141\0noelkappl=0\0ElkIlknRev=1");\
    }\
    args.a_argc = 4;\
    args.a_arg = 2;\
    WB_TEST(rv = dcmn_bcm_warm_boot_api_test_reset(unit));\
    WB_TEST(_ERR_CHECK_BCM_PETRA_FIELD_TEST_RESET(rv));\
    _result = sh_process_command(unit, "kbp deinit_appl");\
    if(_result != CMD_OK) {\
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;\
        goto fail;\
    }\
\
    rv = test_dispatch(unit, &test, -1, &args);\
    if(rv != BCM_E_NONE) {\
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;\
        goto fail;\
    }\
    _DCMN_BCM_WARM_BOOT_API_TEST_OVERRIDE_WB_TEST_MODE(unit);\
}

#else

#define _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv)\
{\
    test_t test;\
    cmd_result_t _result = CMD_OK;\
    test.t_name = "DEINT INIT (SOC BCM)";\
    test.t_flags = 0x80100000;\
    test.t_test = 141;\
    test.t_loops = 1;\
    test.t_init_f = init_deinit_test_init;\
    test.t_done_f = init_deinit_test_done;\
    test.t_test_f = init_deinit_test;\
    test.t_default_string = 0x0;\
    test.t_override_string = 0x0;\
    test.t_runs = 0;\
    test.t_success = 0;\
    test.t_fail = 0;\
    args.a_cmd = "TestRun";\
    args.a_argv[0] = "tr";\
    args.a_argv[1] = "141";\
    args.a_argv[2] = "noelkappl=0";\
    args.a_argv[3] = "ElkIlknRev=1";\
    sal_strcpy(args.a_buffer, "tr\0141\0noelkappl=1\0ElkIlknRev=1");\
    args.a_argc = 4;\
    args.a_arg = 2;\
    WB_TEST(rv = dcmn_bcm_warm_boot_api_test_reset(unit));\
    WB_TEST(_ERR_CHECK_BCM_PETRA_FIELD_TEST_RESET(rv));\
    _result = sh_process_command(unit, "kbp deinit_appl");\
    if(_result != CMD_OK) {\
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;\
        goto fail;\
    }\
\
    rv = test_dispatch(unit, &test, -1, &args);\
    if(rv != BCM_E_NONE) {\
        LOG_ERROR(BSL_LS_BCM_FP, \
                  (BSL_META_U(unit, \
                              "Failed.\n")));\
        goto fail;\
    }\
    _DCMN_BCM_WARM_BOOT_API_TEST_OVERRIDE_WB_TEST_MODE(unit);\
}

#endif

STATIC bcm_error_t _bcm_petra_field_test_kbp_set_presels(int unit,
                                                          uint32 nof_presels)
{
    CONST static bcm_field_AppType_t supported_app_type [] = {
        bcmFieldAppTypeL2,
        bcmFieldAppTypeIp4Ucast,
        bcmFieldAppTypeIp4UcastRpf,
    };
    bcm_error_t rv;
    uint32 presel_idx, presel_idx_2;
    int presel_flags = 0;

    for(presel_idx = 0; presel_idx < nof_presels; ++presel_idx) {
        if(soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
            rv = bcm_field_presel_create_stage_id(unit, bcmFieldStageIngress, presel_idx +3);
            presel_flags = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_INGRESS;
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            rv = bcm_field_qualify_Stage(unit, (presel_idx + 3) | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldStageExternal);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        } else {
            rv = bcm_field_presel_create_id(unit, presel_idx +3);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            rv = bcm_field_qualify_Stage(unit, (presel_idx + 3) | BCM_FIELD_QUALIFY_PRESEL, bcmFieldStageExternal);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
    }

    for(presel_idx = 0;
        presel_idx < nof_presels && presel_idx < (sizeof(supported_app_type) / sizeof(supported_app_type[0]));
        ++presel_idx) {
        rv = bcm_field_qualify_AppType(unit, (presel_idx + 3) | BCM_FIELD_QUALIFY_PRESEL | presel_flags, supported_app_type[presel_idx]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    if(presel_idx < (sizeof(supported_app_type) / sizeof(supported_app_type[0])) ){
        for(presel_idx_2 = --presel_idx;
            presel_idx_2 < (sizeof(supported_app_type) / sizeof(supported_app_type[0]));
            ++presel_idx_2) {
            rv = bcm_field_qualify_AppType(unit, (presel_idx + 3) | BCM_FIELD_QUALIFY_PRESEL | presel_flags, supported_app_type[presel_idx_2]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        } 
    }

    return BCM_E_NONE;

fail:
    for(presel_idx = 0; presel_idx < nof_presels; ++presel_idx) {
        bcm_field_presel_destroy(unit, presel_idx + 3);
    }
    return rv;
}

STATIC cmd_result_t _bcm_petra_field_test_kbp_init(int unit) {
    cmd_result_t result = CMD_OK;
    result = sh_process_command(unit, "kbp init_appl");;
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    return result;
}
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

/* The scan test for field group, and entry with and without traffic
 * It goes over all the qualifiers and actions to verify that all of them are ok.
 * In the field group test it creates field group with one qualifier and one action install, retrieve and destroy the field group
 * For the entry test it chooses randomly data and mask for the qualifier, randomly param0 and param1 for the action, and retrieves them
 * If we want traffic also it sends packet to verify hit/not hit. */
STATIC cmd_result_t _bcm_petra_field_test_field_group_and_entry_scan(int unit, _bcm_dpp_field_stage_idx_t stage, uint8 is_direct_table, uint8 entry_also, uint8 with_traffic, uint8 is_predefined, uint8 do_warmboot)
{
    bcm_field_group_config_t field_group;
    _bcm_dpp_field_type_idx_t type, type1;
    bcm_field_qset_t valid_qset;
    bcm_field_aset_t valid_aset;
    bcm_field_qset_t valid_qset_external[_BCM_PETRA_FIELD_NOF_TYPES];
    bcm_field_aset_t valid_aset_external[_BCM_PETRA_FIELD_NOF_TYPES];
    bcm_field_qualify_t cur_qualifier, last_qualifier;
    uint8 is_lsb_qualifier;
    bcm_field_action_t cur_action, last_action;
    bcm_error_t rv;
    cmd_result_t result;
    uint32 item;    
    bcm_field_group_t id;
    uint8 invalid_item;
    uint32 qual_length;
    uint32 action_length;
    bcm_field_qset_t qset_verify;
    uint8 can_fit_small_bank = TRUE;
    const static char* qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
    const static char* actions_names[] = BCM_FIELD_ACTION_STRINGS;
    
    for(type = 0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
        if(stage != _BCM_DPP_FIELD_STAGE_INDEX_EGRESS || !with_traffic) {
            rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, stage, type, &valid_qset, &valid_aset);
            if(rv != BCM_E_NONE) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Failed to get valid qset and aset\n")));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        } else {
            BCM_FIELD_QSET_INIT(valid_qset);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifySrcMac);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyDstMac);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlan);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanId);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanPri);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanCfi);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlan);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanId);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanPri);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanCfi);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInterfaceClassProcessingPort);

            /* needed just for selecting action for the entry test with traffic */
            BCM_FIELD_ASET_INIT(valid_aset);
            BCM_FIELD_ASET_ADD(valid_aset, bcmFieldActionQosMapIdNew);
        }
        

        _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);

        /* Remove Action Cascaded from ASET, as it cannot be created
         * without first creating the second stage Field Group. */
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionCascadedKeyValueSet);
        /* Remove Action StatTag from ASET, because it was hardware
         * removed on QAX. */
        if(SOC_IS_QAX(unit)) {
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStatTag);
        }

        /* Remove qualifier EthernetData from QSET, because it is
         * supported only as a data qualifier. */
		BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyEthernetData);
        
        if(entry_also && with_traffic && 
            (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) ) {
            if(type != _BCM_PETRA_FIELD_TYPE_MPLS) {
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyMplsBos);
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInnerSrcMac);
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInnerDstMac);
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInnerEtherType);            
            }
        
            if(type != _BCM_PETRA_FIELD_TYPE_IPV4) {
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIpFrag);
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInnerIpFrag);
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyEcnValue);
            }
        
            if(type != _BCM_PETRA_FIELD_TYPE_IPV4 && type != _BCM_PETRA_FIELD_TYPE_IPV6) {
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIpProtocolCommon);
            }
        
            if(type != _BCM_PETRA_FIELD_TYPE_ETHR)
            {
                BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyIpType);
            }
        }
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL && !with_traffic) {
            /* In this case we would like to loop on all the qualifiers of all the types only once */
            valid_qset_external[type] = valid_qset;
            valid_aset_external[type] = valid_aset;
            if(type == _BCM_PETRA_FIELD_NOF_TYPES - 1) {
                for(type1 = 0; type1 < type; ++type1) {
                    for(cur_qualifier = 0; cur_qualifier < bcmFieldQualifyCount; ++cur_qualifier) {
                        if(BCM_FIELD_QSET_TEST(valid_qset_external[type1], cur_qualifier)) {
                            BCM_FIELD_QSET_ADD(valid_qset, cur_qualifier);
                        }
                    }
                    for(cur_action = 0; cur_action < bcmFieldActionCount; ++cur_action) {
                        if(BCM_FIELD_ASET_TEST(valid_aset_external[type1], cur_action)) {
                            BCM_FIELD_ASET_ADD(valid_aset, cur_action);
                        }
                    }
                }
            } else {
                continue;
            }
        }
        
        if(is_direct_table && entry_also && with_traffic) {
            _bcm_petra_field_test_dt_remove_inadequate_actions(&valid_aset);
        }

        last_qualifier = bcmFieldQualifyCount;
        last_action = bcmFieldActionCount;
        cur_qualifier = 0;
        cur_action = 0;
        bcm_field_group_config_t_init(&field_group);
                    
        while(TRUE) {
            /* priority */
            field_group.priority = sal_rand()
                %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;

            /* qset */
            do{
                invalid_item = FALSE;
                if(cur_qualifier == bcmFieldQualifyCount) {
                    break;
                }
                
                if(cur_qualifier == bcmFieldQualifyIp4 ||
                    cur_qualifier == bcmFieldQualifyIp6 ||
                    cur_qualifier == bcmFieldQualifyMpls ||
                    cur_qualifier == bcmFieldQualifyStageIngress ||
                    cur_qualifier  == bcmFieldQualifyStageEgress ||
                    cur_qualifier == bcmFieldQualifyStageExternal) {
                    
                    ++cur_qualifier;
                    invalid_item = TRUE;
                    continue;
                }                

                if(!BCM_FIELD_QSET_TEST(valid_qset, cur_qualifier)) {
                    ++cur_qualifier;
                    invalid_item = TRUE;
                    continue;
                } 

                if(entry_also && BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), cur_qualifier)) {
                    ++cur_qualifier;
                    invalid_item = TRUE;
                    continue;
                }

                if(entry_also && with_traffic && 
                    (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) &&
                    BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure(), cur_qualifier)) {
                    ++cur_qualifier;
                    invalid_item = TRUE;
                    continue;
                }

                if(is_predefined) {
                    
                    /* verifythat the qualifier may be data qualifier */
                    if(!BCM_FIELD_QSET_TEST(*_bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage), cur_qualifier)){
                        ++cur_qualifier;
                        invalid_item = TRUE;
                        continue;
                    }
                } else {

                    if(is_direct_table) {
                        rv =  _bcm_petra_field_test_qualify_hardware_length_best(unit, stage, type, cur_qualifier, &qual_length);
                        if (rv != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            return CMD_FAIL;
                        }
                        if(qual_length > SOC_DPP_DEFS_GET(unit, tcam_big_bank_key_nof_bits)) {
                            ++cur_qualifier;
                            invalid_item = TRUE;
                        } else {
                            rv = _bcm_petra_field_test_qualifier_is_lsb_is_msb(unit, cur_qualifier, &is_lsb_qualifier, NULL);
                            if (rv != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                return CMD_FAIL;
                            }
                            if(!is_lsb_qualifier) {
                                ++cur_qualifier;
                                invalid_item = TRUE;
                            }
                            if(!invalid_item) {
                                can_fit_small_bank = qual_length <= _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_QUALIFIERS_LENGTH_SMALL_BANK;
                            }
                        }
                    }
                }
            }
            while(invalid_item);

            
            /* aset */
            do{
                invalid_item = FALSE;
                if(cur_action == bcmFieldActionCount) {
                    break;
                }

                if(!SOC_IS_ARADPLUS(unit) && cur_action == bcmFieldActionInterfaceClassVPort) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }

                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionPphSnoopCode) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }
                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionStaggeredPreselProfile0Set) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }
                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionStaggeredPreselProfile1Set) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }
                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionStaggeredPreselProfile2Set) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }
                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionStaggeredPreselProfile3Set) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }
                if(!SOC_IS_JERICHO_PLUS(unit) && cur_action == bcmFieldActionStaggeredPreselProfileDirectSet) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                }

                if(!BCM_FIELD_ASET_TEST(valid_aset, cur_action)) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                } 

                if(entry_also && BCM_FIELD_ASET_TEST(*get_set_get_action_failure(), cur_action)) {
                    ++cur_action;
                    invalid_item = TRUE;
                    continue;
                } 
                
                if(is_direct_table) {
                    rv =  _bcm_petra_field_test_action_length_with_valid_bit(unit, stage, type, cur_action, &action_length);
                    if (rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(action_length > SOC_DPP_DEFS_GET(unit, tcam_action_width)) {
                        ++cur_action;
                        invalid_item = TRUE;
                    }
                }
            }
            while(invalid_item);
            
            if(cur_qualifier == bcmFieldQualifyCount && cur_action == bcmFieldActionCount) {
                /* i.e. no changes for the prevoious iteration to this */
                break;
            }

            if(cur_qualifier == bcmFieldQualifyCount) {
                if(last_qualifier == bcmFieldQualifyCount) {
                    /* There has been no valid qualifier in this type */
                    break;
                }
                cur_qualifier = last_qualifier;
            }
            
            last_qualifier = cur_qualifier;

            if(cur_action == bcmFieldActionCount) {
                if(last_action == bcmFieldActionCount) {
                    /* There has been no valid action in this type */
                    break;
                }
                cur_action = last_action;
            }
            
            last_action = cur_action;
            
            BCM_FIELD_QSET_INIT(field_group.qset);
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyStageIngress);
            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
                BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyStageEgress);
            } else {
                BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyStageExternal);
            }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);

                /* In order that we will take App type L2 only and we will be able to take all the actions */
                rv = _bcm_petra_field_test_kbp_set_presels(unit, 2);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                BCM_FIELD_PRESEL_INIT(field_group.preselset);
                BCM_FIELD_PRESEL_ADD(field_group.preselset, 3);
                field_group.flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;            
            }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

            if(is_predefined) {
                bcm_field_data_qualifier_t dq;
                bcm_field_data_qualifier_t_init(&dq);
                result = _bcm_petra_field_test_fill_data_qualifier_with_qualifier(unit, stage, sal_rand(), cur_qualifier, FALSE, &dq);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return result;
                }
                dq.flags &= ~BCM_FIELD_DATA_QUALIFIER_REPLACE;
                dq.flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
                dq.qual_id = 0;
                rv = bcm_field_data_qualifier_create(unit, &dq);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                
#ifdef BCM_WARM_BOOT_SUPPORT
                if(do_warmboot) {
                    _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
                }
#endif
                rv = bcm_field_qset_data_qualifier_add(unit, &field_group.qset, 0);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            } else {
                BCM_FIELD_QSET_ADD(field_group.qset, cur_qualifier);
            }
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL || with_traffic) {
                if(type == _BCM_PETRA_FIELD_TYPE_IPV4) {
                    BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyIp4);
                } else if(type == _BCM_PETRA_FIELD_TYPE_IPV6) {
                    BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyIp6);
                } else if(type == _BCM_PETRA_FIELD_TYPE_MPLS) {
                    BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyMpls);
                }
            } else {
                if(!BCM_FIELD_QSET_TEST(valid_qset_external[_BCM_PETRA_FIELD_TYPE_ETHR], cur_qualifier)) {
                    if(BCM_FIELD_QSET_TEST(valid_qset_external[_BCM_PETRA_FIELD_TYPE_IPV4], cur_qualifier)) {
                        BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyIp4);
                    } else if(BCM_FIELD_QSET_TEST(valid_qset_external[_BCM_PETRA_FIELD_TYPE_IPV6], cur_qualifier)) {
                        BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyIp6);
                    } else if(BCM_FIELD_QSET_TEST(valid_qset_external[_BCM_PETRA_FIELD_TYPE_MPLS], cur_qualifier)) {
                        BCM_FIELD_QSET_ADD(field_group.qset, bcmFieldQualifyMpls);
                    }
                }
            }

            /* In the stage of egress - needed only to the entry test - to check just this action */            
            BCM_FIELD_ASET_INIT(field_group.aset);
            BCM_FIELD_ASET_ADD(field_group.aset, cur_action);
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                field_group.flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
            }
            
            /* printing the qualifier and the action */
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "qualify = %s (%d), action = %s (%d)\n"), 
                                 qualifiers_names[cur_qualifier], cur_qualifier,
                      actions_names[cur_action], cur_action));
            
            if(is_direct_table) {
                field_group.flags |= BCM_FIELD_GROUP_CREATE_WITH_MODE;
                field_group.mode = bcmFieldGroupModeDirect;
                if(!can_fit_small_bank) {
                    field_group.flags |= BCM_FIELD_GROUP_CREATE_SMALL;
                    rv = bcm_field_group_config_create(unit, &field_group);
                    /* it should fail because it can't fit small bank */
                    if(rv == BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    field_group.flags &= ~BCM_FIELD_GROUP_CREATE_SMALL;                     
                }
            }
            
            /* Creating the group */
            rv = bcm_field_group_config_create(unit, &field_group);
            if (rv != BCM_E_NONE) {
                bcm_field_group_destroy(unit, field_group.group);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                result = _bcm_petra_field_test_kbp_init(unit);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                rv = _bcm_petra_field_test_group_dump(unit, field_group.group);
                if(rv != BCM_E_NONE) {
                    bcm_field_group_destroy(unit, field_group.group);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot && !entry_also) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif
            /* Existence check */
            for(item = 0; item < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++item) {
                id = sal_rand() % (_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                rv = bcm_field_group_get(unit, id, &qset_verify);
                if(id != field_group.group) {
                    if(rv != BCM_E_NOT_FOUND) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "group id %d - doen't exist and bcm_field_group_get didn\'t return BCM_E_NOT_FOUND\n"), id));
                        }
                        bcm_field_group_destroy(unit, field_group.group);
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    } else {
                        continue;
                    }
                } else {
                    if(rv != BCM_E_NONE) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "group id %d - exist but bcm_field_group_get failed\n"), id));
                        }
                        bcm_field_group_destroy(unit, field_group.group);
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }            

            /* retrieve and compare */
            result = _bcm_petra_field_field_group_get_and_compare(unit, &field_group, FALSE);
            if(result != CMD_OK) {
                bcm_field_group_destroy(unit, field_group.group);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            } 
            
            if(entry_also) {
                result = _bcm_petra_field_entry_scan_test(unit, stage, &field_group, with_traffic, is_predefined, do_warmboot);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }                    
            }                
            
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_group_destroy(unit, field_group.group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }

            if(is_predefined && stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_data_qualifier_destroy(unit, 0);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
            ++cur_qualifier;
            ++cur_action;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "\n")));
        }
    }
    return CMD_OK;
#if (defined(BCM_WARM_BOOT_SUPPORT)) || (defined(INCLUDE_KBP) && !defined(BCM_88030))
fail:
    return CMD_FAIL;
#endif /* (defined(BCM_WARM_BOOT_SUPPORT)) || (defined(INCLUDE_KBP) && !defined(BCM_88030)) */
}

/* calculating the expected action values */
STATIC bcm_error_t expected_actions_value(int unit,
                                          const bcm_field_action_t *actions,
                                          int nof_actions,
                                          bcm_field_group_t *field_group_ids,
                                          bcm_field_entry_t *entries,
                                          uint32 nof_fgs_and_entries,
                                          int32 *expected_actions)
{           
    uint32 fg_idx, action_idx;
    int32 highest_action_value;
    int32 highest_priority;
    int *priorities;
    uint32 param0, param1;
    bcm_error_t rv;
    
    priorities = sal_alloc(sizeof(int) * nof_fgs_and_entries, "expected_actions_value.priorities");
    if(!priorities) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return BCM_E_MEMORY;
    }
    
    /* retrieving the priorities */
    for(fg_idx = 0; fg_idx < nof_fgs_and_entries; ++fg_idx) {
        rv = bcm_field_group_priority_get(unit, field_group_ids[fg_idx], &priorities[fg_idx]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    
    for(action_idx = 0; action_idx < nof_actions; ++action_idx) {
        highest_action_value = -1;
        highest_priority = 0x80000000;
        for(fg_idx = 0; fg_idx < nof_fgs_and_entries; ++fg_idx) {
            rv = bcm_field_action_get(unit, entries[fg_idx], actions[action_idx], &param0, &param1);
            if(rv == BCM_E_NOT_FOUND) {
                continue;
            }
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            if(highest_action_value == -1 || priorities[fg_idx] > highest_priority ) {
                highest_action_value = param0;
                highest_priority = priorities[fg_idx];   
            }
        }
        expected_actions[action_idx] = highest_action_value;
    }
    
    sal_free(priorities);
    return BCM_E_NONE;
    
fail:
    sal_free(priorities);
    return rv;
}

STATIC cmd_result_t _bcm_petra_field_test_send_header_and_get_info(int unit,
                                                                   _bcm_petra_field_test_ethernet_header_t *ethernet_header,
                                                                   uint32 local_port_src,
                                                                   SOC_PPC_FP_PACKET_DIAG_INFO **info)
{
    uint32 *buffer;
    uint32 tmp_buffer[6];
    cmd_result_t res = CMD_OK;
    
    buffer = sal_alloc(_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit), "_bcm_petra_field_test_send_header_and_get_info.buffer");
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ethernet_header_to_buffer(ethernet_header, tmp_buffer)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    sal_memset(buffer, 0xa5, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header->nof_vlans) /* ethernet header length */,
        tmp_buffer,
        0,
        112 + 32*ethernet_header->nof_vlans);

    res = _bcm_petra_field_send_packet_and_get_information(unit, buffer, local_port_src, 1, info);

    sal_free(buffer);

    return(res);
}

/*  
 * Assumptions: 
 * 1. each aset in the field group has no more then 2 actions, and the number of the actions in all of the field groups is no more then 32
 * 2. each qset in the field group has no more then 6 qualifiers, and the number of the qualifiers in all of the field groups is no more then 24
 * 3. The maximal priority is 127
 * 4. bcmFieldQualify[inner]{Src/Dst]Ip6 will be removed from the valid qset
 */
STATIC cmd_result_t _bcm_petra_field_test_field_group_tag(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 nof_fgs, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 with_destroy, uint8 with_traffic, uint8 has_de, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 action_idx;
    uint32 app_type_idx, app_type_idx2;
    uint32 flip, loop_counter = 0;
    uint32 second_rand_param = 0;
    uint32 id;
    uint8 does_exist_already;
    cmd_result_t result = CMD_OK;
    bcm_error_t rv;
    int tmp;
    soc_port_t port_number;

    /* These variable may be set only once. Done to avoid coverity stack use.*/
    static bcm_field_qset_t qset;
    static bcm_field_aset_t aset;
    static uint8 is_qset_and_ast_set = FALSE;
    
    /* We need qset_verify only for checking the Existence of field group. We don't use this variable */
    static bcm_field_qset_t qset_verify;

    uint32 action_length;
    uint32 param0;
    bcm_field_entry_t entries[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX];
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    const static bcm_field_action_t actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS] = {
        bcmFieldActionLearnForwardingVlanIdNew,
        bcmFieldActionDhcpPkt,
        bcmFieldActionPrioIntNew,
        bcmFieldActionMirrorEgressDisable,
        bcmFieldActionDscpNew,
        bcmFieldActionTtlSet,
        bcmFieldActionVrfSet
    };
    SOC_PPC_FP_ACTION_TYPE ppd_actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS];
    
    bcm_field_group_config_t *field_groups[_BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX];
    bcm_field_group_t fg_ids[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX];

    bcm_field_group_t destroy_fg_ids[_BCM_FIELD_GROUP_TEST_NOF_GROUPS_DESTROY];
    int fg_priorities[_BCM_FIELD_GROUP_TEST_NOF_GROUPS_DESTROY];
    int32 expected_actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS];
    bcm_field_group_config_t *de = NULL;
    bcm_field_extraction_action_t extract;
    bcm_field_extraction_field_t ext_pcp;
    SOC_PPC_FP_PACKET_DIAG_INFO *info;


    if(!is_qset_and_ast_set) {
        BCM_FIELD_QSET_INIT(qset);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyOuterVlanPri);

        BCM_FIELD_ASET_INIT(aset);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionDrop);
        is_qset_and_ast_set = TRUE;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        if(with_destroy) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "This test has no meaning in scan mode\n")));
            return CMD_OK;
        } else {
            result = _bcm_petra_field_test_field_group_and_entry_scan(unit, stage, FALSE, FALSE, FALSE, FALSE, do_warmboot);
            if(result == CMD_OK) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "The test finished successfully\n")));
            } else {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            }
            return result;
        }
    }
    
    if(with_destroy && with_traffic) {
        /* Translating the bcm action to ppd actions */
        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS, ppd_actions);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }


    field_groups[0] = sal_alloc(sizeof(bcm_field_group_config_t) * _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX, "_bcm_petra_field_test_field_group_tag.field_groups");
    if(!field_groups[0]) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    for(app_type_idx = 1; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
        field_groups[app_type_idx] = NULL;
    }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        for(app_type_idx = 1; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
            field_groups[app_type_idx] = sal_alloc(sizeof(bcm_field_group_config_t) * _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX, "_bcm_petra_field_test_field_group_tag.field_groups");
            if(!field_groups[app_type_idx]) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Memory allocation failure.\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                for(app_type_idx2 = 0; app_type_idx2 < app_type_idx; ++app_type_idx2) {
                    sal_free(field_groups[app_type_idx2]);
                }
                return CMD_FAIL;
            }
        }
    }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
            rv = _bcm_petra_field_test_kbp_set_presels(unit, _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                for(app_type_idx = 1; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
                    sal_free(field_groups[app_type_idx]);
                }
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        if(with_destroy && with_traffic) {
            for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                bcm_field_group_config_t_init(&field_groups[0][fg_idx]);
                
                /* in this case we will take very specific qset and aset */
                BCM_FIELD_QSET_INIT(field_groups[0][fg_idx].qset);
                BCM_FIELD_QSET_ADD(field_groups[0][fg_idx].qset, bcmFieldQualifyOuterVlanPri);
        
                BCM_FIELD_ASET_INIT(field_groups[0][fg_idx].aset);
                for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS; ++action_idx) {
                    BCM_FIELD_ASET_ADD(field_groups[0][fg_idx].aset, actions[action_idx]);
                }
                
                /* priority */
                if(!has_de) {
                    do
                    {
                        field_groups[0][fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                            %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx ; ++fg_idx2) {
                            if (field_groups[0][fg_idx].priority == field_groups[0][fg_idx2].priority) {
                                does_exist_already = TRUE;
                                break;
                            }
                        }
                    }
                    while(does_exist_already);
                } else {
                    field_groups[0][fg_idx].priority = nof_fgs - fg_idx;
                }
                
                field_groups[0][fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
            }
        } else {
            for(app_type_idx = 0; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
                if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL && app_type_idx > 0) {
                    continue;
                }
                result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, FALSE, FALSE, 0, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE, field_groups[app_type_idx], nof_fgs, 0);
                if(result != CMD_OK) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "x = %d\n"), x));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    for(app_type_idx2 = 1; app_type_idx2 < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx2) {
                        if(field_groups[app_type_idx2]) {
                            sal_free(field_groups[app_type_idx2]);
                        }
                    }
                    return result;
                }
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                        BCM_FIELD_PRESEL_INIT(field_groups[app_type_idx][fg_idx].preselset);
                        BCM_FIELD_PRESEL_ADD(field_groups[app_type_idx][fg_idx].preselset, app_type_idx + 3);
                    }
                    if(nof_fgs > 1) {
                        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++fg_idx) {
                            BCM_FIELD_ASET_INIT(field_groups[app_type_idx][fg_idx].aset);
                            /* In order not to take bcmFieldActionExternalValue[0/1]Set
                             * that are not available if the AppType is not L2 only. */
                            BCM_FIELD_ASET_ADD(field_groups[app_type_idx][fg_idx].aset, bcmFieldActionExternalValue0Set + fg_idx + 2);
                        }
                    }
                }
            }
            if(has_de) {
                if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "The test is not valid for egress with direct extration field group\n")));
                    sal_free(field_groups[0]);
                    return CMD_FAIL;
                }
                de = sal_alloc(sizeof(bcm_field_group_config_t), "_bcm_petra_field_test_field_group_tag.de");
                if(!de) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Memory allocation failure.\n")));
                    sal_free(field_groups[0]);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                bcm_field_group_config_t_init(de);
                de->flags = BCM_FIELD_GROUP_CREATE_WITH_MODE | BCM_FIELD_GROUP_CREATE_WITH_ASET;
                de->mode = bcmFieldGroupModeDirectExtraction;
                BCM_FIELD_QSET_INIT(de->qset);
                BCM_FIELD_QSET_ADD(de->qset, bcmFieldQualifyStageIngress);
                BCM_FIELD_QSET_ADD(de->qset, bcmFieldQualifyOuterVlanPri);
                BCM_FIELD_ASET_INIT(de->aset);
                BCM_FIELD_ASET_ADD(de->aset, bcmFieldActionDscpNew/*FIX*/);

                de->priority = nof_fgs + 1;

                rv = bcm_field_group_config_create(unit, de);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }

                rv = bcm_field_entry_create_id(unit, de->group, nof_fgs);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_group_destroy(unit, de->group);
                    sal_free(de);
                    sal_free(field_groups[0]);
                    return CMD_FAIL;
                }
            
                bcm_field_extraction_action_t_init(&extract);
                bcm_field_extraction_field_t_init(&ext_pcp);
                extract.action = bcmFieldActionDscpNew/*FIX*/;
                extract.bias = 0;

                ext_pcp.flags = 0;
                ext_pcp.bits = 3;
                ext_pcp.lsb = 0;
                ext_pcp.qualifier = bcmFieldQualifyOuterVlanPri;
                rv = bcm_field_direct_extraction_action_add(unit, nof_fgs, extract, 1, &ext_pcp);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_entry_destroy(unit, nof_fgs);
                    bcm_field_group_destroy(unit, de->group);
                    sal_free(de);
                    sal_free(field_groups[0]);
                    return CMD_FAIL;
                }
                rv = bcm_field_entry_install(unit, nof_fgs);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_entry_destroy(unit, nof_fgs);
                    bcm_field_group_destroy(unit, de->group);
                    sal_free(de);
                    sal_free(field_groups[0]);
                    return CMD_FAIL;
                }
            }
        }

        /* Creating the filed groups */
        for(app_type_idx = 0; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL && app_type_idx > 0) {
                continue;
            }
            for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                /* if we have explicit id we must verfy that this id is available */
                if(app_type_idx > 0 && (field_groups[app_type_idx][fg_idx].flags & BCM_FIELD_GROUP_CREATE_WITH_ID)) {
                    do{
                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            if(field_groups[app_type_idx][fg_idx2].group == field_groups[app_type_idx][fg_idx].group) {
                                does_exist_already = TRUE;
                                field_groups[app_type_idx][fg_idx].group =  _bcm_petra_field_rand_val(x, second_rand_param++)
                                    %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                                break;
                            }
                        }
                        if(!does_exist_already) {
                            for(app_type_idx2 = 0; app_type_idx2 < app_type_idx; ++app_type_idx2) {
                                for(fg_idx2 = 0; fg_idx2 < nof_fgs; ++fg_idx2) {
                                    if(field_groups[app_type_idx2][fg_idx2].group == field_groups[app_type_idx][fg_idx].group) {
                                        does_exist_already = TRUE;
                                        field_groups[app_type_idx][fg_idx].group =  _bcm_petra_field_rand_val(x, second_rand_param++)
                                            %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                                        break;
                                    }
                                }
                                if(does_exist_already) {
                                    break;
                                }
                            }
                        }
                    }while (does_exist_already);
                }
                /* verifying no re use of previous priority */
                if(app_type_idx > 0) {
                    do{
                        uint32 fg_idx3;

                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            if(field_groups[app_type_idx][fg_idx2].priority == field_groups[app_type_idx][fg_idx].priority) {
                                does_exist_already = TRUE;
                                field_groups[app_type_idx][fg_idx].priority =  _bcm_petra_field_rand_val(x, second_rand_param++)
                                    %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST)
                                    + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                                break;
                            }
                        }
                        if(!does_exist_already) {
                            for(app_type_idx2 = 0; app_type_idx2 < app_type_idx; ++app_type_idx2) {
                                for(fg_idx3 = 0; fg_idx3 < nof_fgs; ++fg_idx3) {
                                    if(field_groups[app_type_idx2][fg_idx3].priority == field_groups[app_type_idx][fg_idx].priority) {
                                        does_exist_already = TRUE;
                                        field_groups[app_type_idx][fg_idx].priority =  _bcm_petra_field_rand_val(x, second_rand_param++)
                                            %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST)
                                            + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                                        break;
                                    }
                                }
                                if(does_exist_already) {
                                    break;
                                }
                            }
                        }
                    }while (does_exist_already);
                }

                rv = bcm_field_group_config_create(unit, &field_groups[app_type_idx][fg_idx]);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                fg_ids[fg_idx] = field_groups[app_type_idx][fg_idx].group;

#ifdef BROADCOM_DEBUG
                /* Dumping the field group */
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Dumping the field group: \n")));
                    rv = _bcm_petra_field_test_group_dump(unit, field_groups[app_type_idx][fg_idx].group);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "\n\n")));
                }
#endif
            }
        }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        if(with_destroy) {
            /* create many field groups till there is no place to add another field group */
            loop_counter = (SOC_IS_JERICHO(unit)) ? 1: _BCM_FIELD_GROUP_TEST_NOF_GROUPS_DESTROY; 
            for(fg_idx = 0; fg_idx < loop_counter; ++fg_idx) {
                do{
                    does_exist_already = FALSE;
                    fg_priorities[fg_idx] = sal_rand() % (_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                    for(fg_idx2 = 0; fg_idx2 < nof_fgs; ++fg_idx2) {
                        if(field_groups[0][fg_idx2].priority == fg_priorities[fg_idx]) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                    if(!does_exist_already) {
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            if(fg_priorities[fg_idx2] == fg_priorities[fg_idx]) {
                                does_exist_already = TRUE;
                                break;
                            }
                        }
                    }
                    if(!does_exist_already && has_de) {
                        if (fg_priorities[fg_idx] == de->priority) {
                            does_exist_already = TRUE;
                        }
                    }
                } while(does_exist_already);                      
                
                rv = bcm_field_group_create(unit, qset, fg_priorities[fg_idx], &destroy_fg_ids[fg_idx]);
                if (BCM_E_NONE != rv) {
                    /* We will use it in the loop of destroying the field groups */
                    loop_counter = fg_idx;
                    break;
                }
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS
                    || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    /* destroy_fg_ids[fg_idx] is set in the function bcm_field_group_create */
                    /* coverity[uninit_use_in_call:FALSE] */
                    rv = bcm_field_group_action_set(unit, destroy_fg_ids[fg_idx], aset);
                    if (BCM_E_NONE != rv) {
                        /* We will use it in the loop of destroying the field groups 
                         * Because the group has been created we need also to destroy it,
                         * so the last index should be fg_idx*/
                        loop_counter = fg_idx + 1;
                        break;
                    }
                }
            }
            /* in case of using traffic also - to the "good" field groups:
                   - create entry, insert to the entry all the actions and take random value to each action */
            if(with_traffic) {
                for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                    /* create entry */
                    rv = bcm_field_entry_create_id(unit, field_groups[0][fg_idx].group, fg_idx);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                    
                    /* priority */
                    rv = bcm_field_entry_prio_set(unit, fg_idx, 1);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }

                    rv = bcm_field_qualify_OuterVlanPri(unit, fg_idx, 0x7, 0x7);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                    
                    for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS; ++action_idx) {
                        if(_bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
                            /* getting the length of the action */
                            rv = _bcm_petra_field_test_action_length(unit, stage, actions[action_idx], &action_length);
                            if(rv != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                goto fail;
                            }
                            
                            param0 = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << action_length);
                            rv = bcm_field_action_add(unit, fg_idx, actions[action_idx], param0, 0);
                            if(rv != BCM_E_NONE) {
                                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                goto fail;
                            }
                        }
                    }
                    
                    rv = bcm_field_entry_install(unit, fg_idx);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                    
                    entries[fg_idx] = fg_idx;
                }
                
#ifdef BCM_WARM_BOOT_SUPPORT
                if(do_warmboot) {
                    _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
                }
#endif
                /* sending traffic */
                rv = expected_actions_value(unit, actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS, fg_ids, entries, nof_fgs, expected_actions);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
    
                sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
                ethernet_header.nof_vlans = 1;
                ethernet_header.vlans[0].pri = 0x7;
                ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                ethernet_header.destination_address[5] = 0x1;
        
                if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, port_number, &info);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }                
#ifndef PLISIM
                if(!_bcm_petra_field_test_check_hit(info, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, FALSE, FALSE)) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Hit didn't occur\n")));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
        
                if(!actions_verification(info, ppd_actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_DESTROY_WITH_TRAFFIC_NOF_ACTIONS, expected_actions, FALSE)){
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
#endif /* not def PLISIM */
            } else {
#ifdef BCM_WARM_BOOT_SUPPORT
                if(do_warmboot) {
                    _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
                }
#endif
            }
        } else {
#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif
            /* Checking existing ids */
            for(flip = 0; flip < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++flip) {
                id = _bcm_petra_field_rand_val(x, second_rand_param++)
                     %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                does_exist_already = FALSE;
                for(app_type_idx = 0; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
                    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL && app_type_idx > 0) {
                        continue;
                    }
                    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                        if(field_groups[app_type_idx][fg_idx].group == id) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                }

                /* Existence */
                rv = bcm_field_group_get(unit, id, &qset_verify);
                if(!does_exist_already) {
                    if(rv != BCM_E_NOT_FOUND) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "group id %d - doen't appear in the list and bcm_field_group_get didn\'t return BCM_E_NOT_FOUND\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    } else {
                        continue;
                    }
                } else {
                    if(rv != BCM_E_NONE) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "group id %d - exist in the list but bcm_field_group_get failed\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }

            /* Taking existing group and check the retrieved attributes */
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                app_type_idx =  _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX;
            } else {
                app_type_idx = 0;
            }
            tmp = _bcm_petra_field_rand_val(x, second_rand_param++) %nof_fgs;

            result = _bcm_petra_field_field_group_get_and_compare(unit,
                                                                  &field_groups[app_type_idx][tmp],
                                                                  FALSE);

            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "group id %d app_type_idx %d, x %d\n"), id, app_type_idx, tmp
                            		 ));
                goto fail;
            }
        }
        
        result = CMD_OK;
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            if(with_destroy && with_traffic) {
                rv = bcm_field_entry_destroy(unit, fg_idx);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_group_destroy(unit, field_groups[0][fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(has_de) {
            rv = bcm_field_entry_destroy(unit, nof_fgs);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            rv =  bcm_field_group_destroy(unit, de->group);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
        
        if(with_destroy) {
            for(fg_idx = 0; fg_idx < loop_counter; ++fg_idx) {
                rv = bcm_field_group_destroy(unit, destroy_fg_ids[fg_idx]);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

    }
    
    if(has_de) {
        sal_free(de);
    }
    for(app_type_idx = 0; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
        if(field_groups[app_type_idx]){
            sal_free(field_groups[app_type_idx]);
        }
    }

    if(result != CMD_OK) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        return result;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        if(with_traffic && with_destroy) {
            bcm_field_entry_destroy(unit, fg_idx);
        }
        bcm_field_group_destroy(unit, field_groups[0][fg_idx].group);
    }
    if(has_de) {
        bcm_field_entry_destroy(unit, nof_fgs);
        if(de) {
            bcm_field_group_destroy(unit, de->group);
            sal_free(de);
        }
    }
    for(app_type_idx = 0; app_type_idx < _BCM_PETRA_FIELD_TEST_NOF_APP_TYPES_MAX; ++app_type_idx) {
        if(field_groups[app_type_idx]){
            sal_free(field_groups[app_type_idx]);
        }
    }
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_field_group(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot) {
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_field_group_tag(unit, stage, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(stage), x, mode, FALSE, FALSE, FALSE, do_warmboot);
}

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
cmd_result_t _bcm_petra_field_test_field_group_2(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot) {
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid for the external stage only!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group 2 field groups per AppType\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_field_group_tag(unit, stage, 2, x, mode, FALSE, FALSE, FALSE, do_warmboot);
}
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

cmd_result_t _bcm_petra_field_test_field_group_destroy(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot) {
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the external stage!\n")));
        return CMD_FAIL;
    }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group, add more field groups to cause failure, destroy all and repeat\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_destroy, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_field_group_tag(unit, stage, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(stage), x, mode, TRUE, FALSE, FALSE, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_field_group_destroy_with_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot) {
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    cmd_result_t result;
    bcm_error_t rv;

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group, add more field groups to cause failure, send traffic and destroy all and repeat\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_destroy_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    result = _bcm_petra_field_test_field_group_tag(unit, stage, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(stage), x, mode, TRUE, TRUE, FALSE, do_warmboot);

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    return result;
}

cmd_result_t _bcm_petra_field_test_field_group_destroy_with_traffic_and_de_fg(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot) {
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group, add more field groups to cause failure, send traffic and destroy all and repeat with additional direct extraction field group.\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_destroy_traffic_de, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_field_group_tag(unit, stage, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(stage), x, mode, TRUE, TRUE, TRUE, do_warmboot);
}

/* This function check if there is intersection between 2 entries
  i.e. if they have a shared qualifier and there are values that can match both of the entries.
  Needed to direct table */
STATIC uint8 entries_have_intersection(_bcm_petra_field_test_entry_info_t *entry1, _bcm_petra_field_test_entry_info_t *entry2)
{
    uint32 qual_idx;
    uint32 common_mask;
    int unit = BSL_UNIT_UNKNOWN;
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
    /* we may assume that the entries have the same qualifiers in the same order,
       however, verify */
        if(entry1->quals_info[qual_idx].qualify != entry2->quals_info[qual_idx].qualify) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "The entries don\'t have the same qualifiers\n")));
            return TRUE;
        }
    }
    
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry1->quals_info[qual_idx].is_valid && entry2->quals_info[qual_idx].is_valid){
            /* we may assume that only data[0] and mask[0] are relevant */
            common_mask = entry1->quals_info[qual_idx].mask[0] & entry2->quals_info[qual_idx].mask[0];
            if((entry1->quals_info[qual_idx].data[0] & common_mask) != (entry2->quals_info[qual_idx].data[0] & common_mask)) {
                return FALSE; /* Enough one bit is different to be different entries */
            }
        }
    }    
    
    return TRUE;
}

/* get the key size in hardware: 80/160/320 bits */
bcm_error_t _bcm_petra_field_test_get_key_hw_length(int unit, bcm_field_group_t group, uint32 *key_size)
{
    bcm_dpp_field_info_OLD_t *unitData;
    uint32 db_id_ndx;
    uint32 tcam_db_id;
    ARAD_TCAM_BANK_ENTRY_SIZE entry_size;
    bcm_error_t rv;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(key_size);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.hwHandle.get(unit, group, &db_id_ndx));
    tcam_db_id = ARAD_PP_FP_DB_ID_TO_TCAM_DB(db_id_ndx);
    rv = sw_state_access[unit].dpp.soc.arad.tm.tcam.tcam_db.entry_size.get(unit, tcam_db_id, &entry_size);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return rv;
    }
    switch(entry_size){
        case ARAD_TCAM_BANK_ENTRY_SIZE_320_BITS:
            *key_size = 320;
            break;
        case ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS:
            *key_size = 160;
            break;
        case ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS:
            *key_size = 80;
            break;
        default:
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Failed to get field group key size in hardware\n")));
                return BCM_E_INTERNAL;
            }
            break;
    }
exit:
    BCMDNX_FUNC_RETURN;
}
/* The test for entries
 * it create field groups. Then fill's randomly entries and retrieves and compare some of them chosen randomly.
 * If we have traffic only one entry is created, and according to the entry calls to the traffic test.
 * If we measure performance, traffic is sent in bulk to hit redirect action, and rate compared to benchmark  .
 */
STATIC cmd_result_t _bcm_petra_field_test_entry_and_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 with_traffic, uint8 is_direct_table, uint8 perf, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 entry_idx, entry_idx2;
    uint32 flip;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint32 priority;
    uint8 does_exist_already;
    cmd_result_t result;
    bcm_error_t rv;
    int priority_verify;
    uint32 nof_entries;
    uint32 qual_index;
    uint32 key_hw_size[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    uint8 is_uninstalled;
    bcm_field_action_t action_perf = bcmFieldActionRedirectPort;
    sal_usecs_t start_time;
    sal_usecs_t end_time;
    int min_rate;
    int tx_count = 10000;

    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    _bcm_petra_field_test_entry_info_t *entries[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];

    /* Benchmark values for rate (in pps): measured in 6.4.10 - 5% */
    if(SOC_IS_JERICHO(unit)) {
        min_rate = 2500;
    } else  {
        min_rate = 300; /* 6.4.10 benchmark: 952*/
    }

    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
        entries[fg_idx] = NULL;
    }
    
    if(x == 0) {
        if(with_traffic && !is_direct_table) {
            if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
                return CMD_FAIL;
            }
        } else {
            if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
                return CMD_FAIL;
            }
        }
    } else {
        nof_iterations = 1;
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Test of entries\n")));
    }
    
    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_test_field_group_and_entry_scan(unit, stage, is_direct_table, TRUE, with_traffic, FALSE, do_warmboot);
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations ; ++iteration_idx) {
        if(!with_traffic && iteration_idx >= 100) {
        /* In This test for slow mode we take only 100 iterations, but a lot of entries */
        /* nof_iterations can be more then 100 */
        /* coverity[dead_error_line:FALSE] */
            break;
        }
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
                rv = _bcm_petra_field_test_kbp_set_presels(unit, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        if(is_direct_table) {
            result = _bcm_petra_field_test_fill_field_groups_dt(unit, x + second_rand_param++, field_groups, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
        } else {
            result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, FALSE, FALSE, 0, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE, field_groups, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), 0);
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                    BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
                    BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, 3);

                    BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
                    /* In order not to take bcmFieldActionExternalValue[0/1]Set
                     * that are not available if the AppType is not L2 only. */
                    if(perf) {
                        BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, action_perf);
                    } else {
                        BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionExternalValue2Set + fg_idx);
                    }
                }
            }
        }
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS && with_traffic) {
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                BCM_FIELD_QSET_INIT(field_groups[fg_idx].qset);
                                
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyStageEgress);
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyOuterVlanPri);
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyOuterVlanCfi);
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyInnerVlanPri);
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyInnerVlanCfi);
                if(!is_direct_table) {
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifySrcMac);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyDstMac);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyOuterVlan);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyOuterVlanId);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyInnerVlan);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyInnerVlanId);
                    BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyInterfaceClassProcessingPort);
                }


                BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
                if(perf) {
                    BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, action_perf);
                } else {
                    BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionQosMapIdNew);
                }
            }
        }
        
        
        /* Creating the field groups */
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_fg_only;
            }
                
#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_fg_only;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_fg_only;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            if(!is_direct_table) {
                rv = _bcm_petra_field_test_get_key_hw_length(unit, field_groups[fg_idx].group, &key_hw_size[fg_idx]);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                    nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                }
            } else {
                nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
            }
            
            if(with_traffic) {
                nof_entries = 1;
            }
            
            entries[fg_idx] = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t)*nof_entries, "");
            if(!entries[fg_idx]) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Memory allocation failure\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* fill entries */
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx){

                /* entry id*/
                if(!perf) {
                    is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                } else {
                    is_explicit_id = 0;
                }
                if(is_explicit_id) {
                    do
                    {
                        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                            id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                                %_BCM_PETRA_FIELD_TEST_NOF_EXTERNAL_ENTRY_IDS) + _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                        } else {
                            id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                                %_BCM_PETRA_FIELD_TEST_NOF_INTERNAL_ENTRY_IDS(unit)) + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam);
                        }
                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            uint32 nof_entries_2;
                            if(!is_direct_table) {
                                nof_entries_2 = (11*1024*key_hw_size[fg_idx2]) / 160;
                                if (nof_entries_2 > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                                    nof_entries_2 = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                                }
                            } else {
                                nof_entries_2 = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
                            }
            
                            if(with_traffic) {
                                nof_entries_2 = 1;
                            }
                            for(entry_idx2 = 0; entry_idx2 < nof_entries_2 ; ++entry_idx2) {
                                if (id == entries[fg_idx2][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                            if (does_exist_already) {
                                break;
                            }
                        }

                        if(!does_exist_already) {
                            for(entry_idx2 = 0; entry_idx2 < entry_idx ; ++entry_idx2) {
                                if (id == entries[fg_idx][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    while(does_exist_already);
                    entries[fg_idx][entry_idx].id = id;
                }

                if(is_explicit_id) {
                    rv = bcm_field_entry_create_id(unit, field_groups[fg_idx].group, entries[fg_idx][entry_idx].id);
                } else {
                    rv = bcm_field_entry_create(unit, field_groups[fg_idx].group, &entries[fg_idx][entry_idx].id);
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                second_rand_param = 0;
                /* priority */
                if(!is_direct_table) {
                    if(perf) {
                        priority = 1;
                    } else {
                        do
                        {
                            priority = _bcm_petra_field_rand_val(x, second_rand_param++) &
                                BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
                            if(priority == 0) {
                                ++priority;
                            }
                            does_exist_already = FALSE;
                            for(entry_idx2 = 0; entry_idx2 < entry_idx ; ++entry_idx2) {
                                if (priority == entries[fg_idx][entry_idx2].priority) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                        }
                        while(does_exist_already);
                    }
                    entries[fg_idx][entry_idx].priority = priority;
                    rv = bcm_field_entry_prio_set(unit, entries[fg_idx][entry_idx].id, entries[fg_idx][entry_idx].priority);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }

                /* set the qualifiers */
                result = _bcm_petra_field_test_set_entry_qualifiers(unit, stage, &field_groups[fg_idx].qset, with_traffic, perf, x + second_rand_param++, FALSE, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                            
                if(is_direct_table) {
                    uint8 can_be_inserted = FALSE;
                    /* if the entry is empty - remove it but not in the traffic test. In the traffic test don't remove */
                    if(!with_traffic) {
                        for(qual_index = 0; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
                            if(entries[fg_idx][entry_idx].quals_info[qual_index].is_valid){
                                can_be_inserted = TRUE;
                            }
                        }
                    } else {
                        can_be_inserted = TRUE;
                    }
                    for(entry_idx2 = 0; entry_idx2 < entry_idx; ++entry_idx2) {
                        if(can_be_inserted) {
                            if(entries_have_intersection(&entries[fg_idx][entry_idx], &entries[fg_idx][entry_idx2])) {
                                /* remove the qualifiers from the last entry */
                                for(qual_index = 0; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
                                    entries[fg_idx][entry_idx].quals_info[qual_index].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
                                    entries[fg_idx][entry_idx].quals_info[qual_index].is_valid = FALSE;
                                }
                                can_be_inserted = FALSE;
                                break;
                            }
                        }
                    }
                    if(!can_be_inserted) {
                        /* uninstall the entry */
                        rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                        if(rv != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                        continue;
                    }
                }
                
                /* actions of the entries */
                result = _bcm_petra_field_test_set_entry_actions(unit, stage, &field_groups[fg_idx].aset, with_traffic, FALSE, perf, x + second_rand_param++, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                rv = bcm_field_entry_install(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        if(!with_traffic) {
            /* Existence test */
            for(flip = 0; flip < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST; ++flip) {
                if(perf) {
                    id = flip;
                } else {
                    id = _bcm_petra_field_rand_val(x, second_rand_param++);
                }
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    id = (id
                        %_BCM_PETRA_FIELD_TEST_NOF_EXTERNAL_ENTRY_IDS) + _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                } else {
                    id = (id
                        %_BCM_PETRA_FIELD_TEST_NOF_INTERNAL_ENTRY_IDS(unit)) + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam);
                }
                does_exist_already = FALSE;

                /* looking for this id */
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                    if(!is_direct_table) {
                        nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                        if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                            nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                        }
                    } else {
                         nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
                    }

                    for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                        if (entries[fg_idx][entry_idx].id == id) {
                            if(is_direct_table) {
                                /* skip uninstalled entries */
                                is_uninstalled = TRUE;
                                for(qual_index = 0; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
                                    if(entries[fg_idx][entry_idx].quals_info[qual_index].is_valid){
                                        is_uninstalled = FALSE;
                                        break;
                                    }
                                }
                                if(is_uninstalled) {
                                    continue;
                                }
                            }
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                    if (does_exist_already) {
                        break;
                    }
                }
                if(is_direct_table) {
                    /* Here we will try to create this entry and see if it exsits */
                    rv = bcm_field_entry_create_id(unit, field_groups[0].group, id);
                    if(does_exist_already) {
                        if(rv != BCM_E_EXISTS) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "entry %d exists and bcm_field_entry_create_id didn\'t return BCM_E_EXISTS.\n"), id));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else {
                        if(rv != BCM_E_NONE) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "entry %d doen\'t exist and bcm_field_entry_create_id Failed.\n"), id));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                        rv = bcm_field_entry_destroy(unit, id);
                        if(rv != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    }
                } else {
                    rv = bcm_field_entry_prio_get(unit, id, &priority_verify);

                    if(!does_exist_already) {
                        if(rv != BCM_E_NOT_FOUND) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "entry %d doesn\'t exist and bcm_field_entry_prio_get didn\'t return BCM_E_NOT_FOUND.\n"), id));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else {
                        if(rv != BCM_E_NONE) {
                            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                                LOG_INFO(BSL_LS_BCM_FP,
                                         (BSL_META_U(unit,
                                                     "entry %d exist and bcm_field_entry_prio_get didn\'t return BCM_E_NONE.\n"), id));
                            }
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    }
                }
            }

            /* priority qualifiers and actions verification */
            for(flip = 0; flip < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST; ++flip) {
                if(perf) {
                    fg_idx = flip % (_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
                } else {
                    fg_idx = _bcm_petra_field_rand_val(x, second_rand_param++)
                        %(_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
                }

                if(!is_direct_table) {
                    nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                    if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                        nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                    }
                } else {
                     nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
                }

                if(perf) {
                    entry_idx = flip % nof_entries;
                } else {
                    entry_idx = _bcm_petra_field_rand_val(x, second_rand_param++)%nof_entries;
                }
                if(is_direct_table) {
                    /* skip uninstalled entries */
                    is_uninstalled = TRUE;
                    for(qual_index = 0; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
                        if(entries[fg_idx][entry_idx].quals_info[qual_index].is_valid){
                            is_uninstalled = FALSE;
                            break;
                        }
                    }
                    if(is_uninstalled) {
                        continue;
                    }
                }
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &entries[fg_idx][entry_idx], is_direct_table, FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        } else {
            /* traffic test - we have only 1 entry */
            if(perf) {
                LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Sending %d packets...\n"), tx_count));


                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Start of time measurement.\n\n")));
                start_time = sal_time_usecs();
                result = _bcm_petra_field_test_traffic_test(unit, stage, FALSE, FALSE, is_direct_table, field_groups[0].group, &entries[0][0], tx_count);                
                end_time = sal_time_usecs();
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "End of time measurement.\n\n")));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Result:\n")));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "_______\n")));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Number of packets sent : %d\n"), tx_count));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Time : %d usecs\n"), end_time-start_time));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Rate : %f pps\n"), (tx_count/((end_time-start_time)/1000000.0))));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Min benchmark rate : %d pps\n"), min_rate));
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")));
                if ( (tx_count/((end_time-start_time)/1000000.0)) < min_rate) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Traffic is slower than minimum rate!\n")));

                    goto fail;
                }
            } else {
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                    result = _bcm_petra_field_test_traffic_test(unit, stage, FALSE, FALSE, is_direct_table, field_groups[fg_idx].group, &entries[fg_idx][0], 1);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            if(!is_direct_table) {
                nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                    nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                }
            } else {
                 nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
            }

            if(with_traffic) {
                nof_entries = 1;
            }
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                if(is_direct_table && !with_traffic) {
                    /* skip uninstalled entries */
                    is_uninstalled = TRUE;
                    for(qual_index = 0; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
                        if(entries[fg_idx][entry_idx].quals_info[qual_index].is_valid){
                            is_uninstalled = FALSE;
                            break;
                        }
                    }
                    if(is_uninstalled) {
                        continue;
                    }
                }
                rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
            sal_free(entries[fg_idx]);
            entries[fg_idx] = NULL;
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return result;
        }
    }

    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx =0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            if(entries[fg_idx]) {
                if(!is_direct_table) {
                    nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                    if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                        nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                    }
                } else {
                    nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_NOF_ENTRIES;
                }

                if(with_traffic) {
                    nof_entries = 1;
                }
                for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                    bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                }
            }
        }
    }

    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
        if(entries[fg_idx] != NULL) {
            sal_free(entries[fg_idx]);
        }
    }

destroy_fg_only:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_entry(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : entry, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_entry_and_traffic(unit, stage, x, mode, FALSE, FALSE, FALSE, do_warmboot);
    
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

cmd_result_t _bcm_petra_field_test_entry_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    bcm_error_t rv;
    cmd_result_t result;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries with traffic \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    result = _bcm_petra_field_test_entry_and_traffic(unit, stage, x, mode, TRUE, FALSE, FALSE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    return result;
}

cmd_result_t _bcm_petra_field_test_entry_traffic_perf(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    bcm_error_t rv;
    cmd_result_t result;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries with traffic \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    result = _bcm_petra_field_test_entry_and_traffic(unit, stage, x, mode, TRUE, FALSE, TRUE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    return result;
}

/* This function indicates the index of the entry in witch the hit should occur */
STATIC int32 _bcm_petra_field_test_index_to_hit(_bcm_petra_field_test_entry_info_t *entries, int32 size, uint32* data, uint32 size_in_bits)
{
    uint32 entry_idx;
    int32 hit_index = -1;
    uint32 highest_priority = 0;
    uint32 tmp_data[_BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32];

    sal_memset(tmp_data, 0x0, sizeof(tmp_data));        
    for(entry_idx = 0; entry_idx < size; ++entry_idx) {
        SHR_BITCOPY_RANGE(tmp_data, 0, data, 0, size_in_bits);
        SHR_BITAND_RANGE(tmp_data, entries[entry_idx].quals_info[0].mask, 0, size_in_bits, tmp_data);
        if(SHR_BITEQ_RANGE(tmp_data, entries[entry_idx].quals_info[0].data, 0, size_in_bits)) {
            /* may hit in this index */
            if(hit_index == -1 || entries[entry_idx].priority > highest_priority) {
                hit_index = entry_idx;
                highest_priority = entries[entry_idx].priority;
            }
        }
    }
    
    return hit_index;
}

/* The test of entry priority.
 * It craetes one field group, and many entries with teh same qualifier.
 * it takes randomly value that may hit at leaast in one of the entries and check if the hit occured in the right entry
 */
STATIC cmd_result_t _bcm_petra_field_test_entry_priority_and_shared_bank(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 nof_fgs, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;
    bcm_error_t rv = BCM_E_NONE;
    bcm_field_group_config_t fg_config[_BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS];
    _bcm_petra_field_test_entry_info_t *entries[_BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS];
    uint8 *entries_to_remove[_BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS];
    uint32 *valid_indecies[_BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS];
    uint32 cur_entry_idx[_BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_MAX_DBS];
    uint32 nof_entries;
    uint32 iteration_idx;
    uint32 entry_idx;
    uint32 qual_idx, data_idx, action_idx;
    uint32 fg_idx, fg_idx2;
    uint32 flip;
    uint32 item;
    uint32 presel_idx;
    uint32 test[1];
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    int32 index_to_hit;
    uint32 index;
    uint32 nof_iterations;
    uint32 second_rand_param = 0;
    uint32 *not_full_fgs = NULL;
    uint32 last_not_full_idx;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    SOC_PPC_FP_PACKET_DIAG_INFO *info;
    uint8 success;
    int stage_value = 0;
    int presel_flags = 0;
	
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }


    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 2, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        result = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);

        return result;
    }

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        nof_entries = _BCM_PETRA_FIELD_PRIORITY_TEST_NOF_ENTRIES(nof_iterations);
    } else if(nof_fgs <= 1) {
        nof_entries = 1000;
    } else {
        nof_entries = 250;
    }

    not_full_fgs = sal_alloc(sizeof(uint32) * nof_fgs, "");
    if(!not_full_fgs) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure\n")));
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        entries[fg_idx] = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t)*nof_entries, "");
        if(!entries[fg_idx]) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Memory allocation failure\n")));
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                sal_free(entries[fg_idx2]);
                sal_free(entries_to_remove[fg_idx2]);
                sal_free(valid_indecies[fg_idx2]);
            }
            sal_free(not_full_fgs);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        entries_to_remove[fg_idx] = sal_alloc(nof_entries, "");
        if(!entries_to_remove[fg_idx]) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Memory allocation failure\n")));
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            sal_free(entries[fg_idx]);
            for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                sal_free(entries[fg_idx2]);
                sal_free(entries_to_remove[fg_idx2]);
                sal_free(valid_indecies[fg_idx2]);
            }
            sal_free(not_full_fgs);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        valid_indecies[fg_idx] = sal_alloc(sizeof(uint32)*nof_entries, "");
        if(!valid_indecies[fg_idx]) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Memory allocation failure\n")));
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            sal_free(entries_to_remove[fg_idx]);
            sal_free(entries[fg_idx]);
            for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                sal_free(entries[fg_idx2]);
                sal_free(entries_to_remove[fg_idx2]);
                sal_free(valid_indecies[fg_idx2]);
            }
            sal_free(not_full_fgs);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    
    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        if(nof_fgs > 1) {
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                /* creating 3 presels one for HeaderFormat l2, one for ipv4 and one for ipv6*/
                if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                    rv = bcm_field_presel_create_id(unit, 0);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    rv = bcm_field_presel_create_id(unit, 1);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    rv = bcm_field_presel_create_id(unit, 2);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                } else {
                    presel_flags = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_INGRESS;
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, 0);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, 1);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, 2);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                }

                rv = bcm_field_qualify_HeaderFormat(unit, 0 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatL2);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }

                rv = bcm_field_qualify_HeaderFormat(unit, 1 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp4);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }

                rv = bcm_field_qualify_HeaderFormat(unit, 2 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp6);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }
            }
        }
        
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
            rv = _bcm_petra_field_test_kbp_set_presels(unit, 2);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_presels_only;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            bcm_field_group_config_t_init(&fg_config[fg_idx]);
            
            /* qset: stage and valn priority */
            BCM_FIELD_QSET_INIT(fg_config[fg_idx].qset);
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || (nof_fgs >= 4 && ((fg_idx + 1) % 2) == 0) ) {
                BCM_FIELD_QSET_ADD(fg_config[fg_idx].qset, bcmFieldQualifyStageIngress);
            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                BCM_FIELD_QSET_ADD(fg_config[fg_idx].qset, bcmFieldQualifyStageExternal);
            }
            BCM_FIELD_QSET_ADD(fg_config[fg_idx].qset, bcmFieldQualifyOuterVlanPri);
    
            fg_config[fg_idx].priority = fg_idx + 1;
    
            /* aset - */
            fg_config[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
            BCM_FIELD_ASET_INIT(fg_config[fg_idx].aset);
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || (nof_fgs >= 4 && ((fg_idx + 1) % 2) == 0) ){
                BCM_FIELD_ASET_ADD(fg_config[fg_idx].aset, bcmFieldActionSystemHeaderSet);
            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                BCM_FIELD_ASET_ADD(fg_config[fg_idx].aset, bcmFieldActionExternalValue0Set + fg_idx);
                fg_config[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
                BCM_FIELD_PRESEL_INIT(fg_config[fg_idx].preselset);
                BCM_FIELD_PRESEL_ADD(fg_config[fg_idx].preselset, 3);
            }

            if(nof_fgs > 1 && stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            /* preselctors */
                fg_config[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
                BCM_FIELD_PRESEL_INIT(fg_config[fg_idx].preselset);
                BCM_FIELD_PRESEL_ADD(fg_config[fg_idx].preselset, fg_idx);                
            }
            
            rv = bcm_field_group_config_create(unit, &fg_config[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            cur_entry_idx[fg_idx] = 0;
            not_full_fgs[fg_idx] = fg_idx;
        }

        last_not_full_idx = nof_fgs - 1;
        
        /* filling the entries */
        for(entry_idx = 0; entry_idx < nof_entries*nof_fgs; ++entry_idx){

            index = _bcm_petra_field_rand_val(x, second_rand_param++) % (last_not_full_idx + 1);
            fg_idx = not_full_fgs[index];
            
            /* id */
            rv = bcm_field_entry_create(unit, fg_config[fg_idx].group, &entries[fg_idx][cur_entry_idx[fg_idx]].id);
            if(rv != BCM_E_NONE){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        
            /* priority */
            entries[fg_idx][cur_entry_idx[fg_idx]].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                     & BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
            if(entries[fg_idx][cur_entry_idx[fg_idx]].priority == 0) {
                ++entries[fg_idx][cur_entry_idx[fg_idx]].priority;
            }
            rv = bcm_field_entry_prio_set(unit, entries[fg_idx][cur_entry_idx[fg_idx]].id, entries[fg_idx][cur_entry_idx[fg_idx]].priority);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            /* qualifier set */
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].is_valid = TRUE;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].is_undefined = FALSE;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].qualify = bcmFieldQualifyOuterVlanPri;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0] = _bcm_petra_field_rand_val(x, second_rand_param++)%8;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++)%8;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0] &= entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0];
            for(data_idx = 1; data_idx < _BCM_PETRA_FIELD_MAX_QUALIFY_LENGTH/32; ++data_idx) {
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[data_idx] = 0;
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[data_idx] = 0;
            }
                            
            for(qual_idx = 1; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[qual_idx].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[qual_idx].is_valid = FALSE;
            }

            rv = bcm_field_qualify_OuterVlanPri(unit,
                                                entries[fg_idx][cur_entry_idx[fg_idx]].id,
                                                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0],
                                                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        
            /* action */
            entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].is_valid = TRUE;
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || (nof_fgs >= 4 && ((fg_idx + 1) % 2) == 0)) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action = bcmFieldActionSystemHeaderSet;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0 = bcmFieldSystemHeaderPphEei;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1 = entries[fg_idx][cur_entry_idx[fg_idx]].id;
            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action = bcmFieldActionExternalValue0Set + fg_idx;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0 = entries[fg_idx][cur_entry_idx[fg_idx]].id - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1 = 0;
            }            
            for(action_idx = 1; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[action_idx].is_valid = FALSE;
            }
        
            rv = bcm_field_action_add(unit,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].id,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        
            /* install */
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || nof_fgs < 4 ) {
                rv = bcm_field_entry_install(unit, entries[fg_idx][cur_entry_idx[fg_idx]].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            } else if((entry_idx == (nof_entries*nof_fgs -1)) || (((entry_idx + 1) % _BCM_PETRA_FIELD_TEST_ENTRY_PRIORITY_NOF_ENTRIES_TO_INSTALL_IN_BATCH) == 0) ) {
                for(fg_idx2 = 0; fg_idx2 < nof_fgs; ++fg_idx2) {
                    rv = bcm_field_group_install(unit, fg_config[fg_idx2].group);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }

            cur_entry_idx[fg_idx]++;

            if(cur_entry_idx[fg_idx] == nof_entries) {
                not_full_fgs[index] = not_full_fgs[last_not_full_idx--];  
            }
        }
    
        for(flip = 0; flip < _BCM_PETRA_FIELD_PRIORITY_TEST_NOF_FLIPS; ++flip) {
#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif
            /* get test for some entries */
            for(item = 0; item < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST; ++item) {
                fg_idx =  _bcm_petra_field_rand_val(x, second_rand_param++) % nof_fgs;
                index = _bcm_petra_field_rand_val(x, second_rand_param++) % nof_entries;
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &entries[fg_idx][index], FALSE, FALSE);
                if(result != CMD_OK){
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }

            fg_idx =  _bcm_petra_field_rand_val(x, second_rand_param++) % nof_fgs;
             
            do {
                test[0] = _bcm_petra_field_rand_val(x, second_rand_param++)%8;
                index_to_hit = _bcm_petra_field_test_index_to_hit(entries[fg_idx], nof_entries, test, 3);
            } while (index_to_hit < 0);

            sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
            ethernet_header.nof_vlans = 1;
            ethernet_header.vlans[0].pri = test[0];
            ethernet_header.vlans[0].tag_protocol_id = 0x8100;
            ethernet_header.destination_address[5] = 0x1;
            if(fg_idx == 0) {
                ethernet_header.ethertype = 0x8809;/* In order that it will have ethertype only */
            } else if(fg_idx == 1) {
                ethernet_header.ethertype = 0x800; /* ipv4 */
            } else if(fg_idx == 2) {
                ethernet_header.ethertype = 0x86dd; /* ipv6 */
            }
        
            result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }                
        
            success = FALSE;    
#ifndef PLISIM
            {
                uint32 cycle, bank;
                for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                        for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                            if(info->tcam[cycle][bank].is_match) {
                                if(info->tcam[cycle][bank].actions[0].val != 
                                    entries[fg_idx][index_to_hit].actions_info[0].param1) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Hit occurred in the wrong entry\n")));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                } else {
                                    success = TRUE;
                                    break;
                                }
                            }
                        }
                    }
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
                    else {
                        for(fg_idx = 0; fg_idx < 4; ++fg_idx) {
                            if(info->elk_action[fg_idx].hit) {
                                index_to_hit = _bcm_petra_field_test_index_to_hit(entries[fg_idx], nof_entries, test, 3);
                                if(info->elk_action[fg_idx].action.val !=
                                    entries[fg_idx][index_to_hit].actions_info[0].param0) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                                 (BSL_META_U(unit,
                                                             "Hit occurred in the wrong entry\n")));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                            }
                        }
                        success = TRUE;
                    }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
                    if(success) {
                        break;
                    }
                }
            }
            if(!success) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Hit didn't occur\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
#endif /* not def PLISIM */
        }
        /* delete 50% of the entries and insert others n*/
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            sal_memset(entries_to_remove[fg_idx], 0x0, nof_entries);
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                valid_indecies[fg_idx][entry_idx] = entry_idx;
            }
            for(entry_idx = 0; entry_idx < nof_entries/2; ++entry_idx) {
                index = _bcm_petra_field_rand_val(x, second_rand_param++) %
                    (nof_entries - entry_idx);
                entries_to_remove[fg_idx][valid_indecies[fg_idx][index]] = TRUE;
                valid_indecies[fg_idx][index] = valid_indecies[fg_idx][nof_entries -entry_idx -1];
            }
        
            /* now remove the entries */
            /* we want to save the entries order such that their order in the aaray is the order they have been inserted to the tcam */
            index = 0;
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                if(!entries_to_remove[fg_idx][entry_idx]) {
                    if(entry_idx > index) {
                        entries[fg_idx][index] = entries[fg_idx][entry_idx];
                    }                         
                    ++index;
                } else {
                    rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }
        
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            cur_entry_idx[fg_idx] = (nof_entries/2);
            not_full_fgs[fg_idx] = fg_idx;
        }
        last_not_full_idx = nof_fgs - 1;
        /* create new entries */
        for(entry_idx = (nof_entries/2)*nof_fgs; entry_idx < nof_entries*nof_fgs; ++entry_idx){
            
            index = _bcm_petra_field_rand_val(x, second_rand_param++) % (last_not_full_idx + 1);
            fg_idx = not_full_fgs[index];

            /* id */
            rv = bcm_field_entry_create(unit, fg_config[fg_idx].group, &entries[fg_idx][cur_entry_idx[fg_idx]].id);
            if(rv != BCM_E_NONE){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            /* priority */
            entries[fg_idx][cur_entry_idx[fg_idx]].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                 & BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
            if(entries[fg_idx][cur_entry_idx[fg_idx]].priority == 0) {
                ++entries[fg_idx][cur_entry_idx[fg_idx]].priority;
            }
            rv = bcm_field_entry_prio_set(unit, entries[fg_idx][cur_entry_idx[fg_idx]].id, entries[fg_idx][cur_entry_idx[fg_idx]].priority);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* qualifier set */
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].is_valid = TRUE;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].qualify = bcmFieldQualifyOuterVlanPri;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0] = _bcm_petra_field_rand_val(x, second_rand_param++)%8;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0] = _bcm_petra_field_rand_val(x, second_rand_param++)%8;
            entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0] &= entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0];
            for(qual_idx = 1; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[qual_idx].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[qual_idx].is_valid = FALSE;
            }

            rv = bcm_field_qualify_OuterVlanPri(unit,
                                                entries[fg_idx][cur_entry_idx[fg_idx]].id,
                                                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].data[0],
                                                entries[fg_idx][cur_entry_idx[fg_idx]].quals_info[0].mask[0]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            /* action */
            entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].is_valid = TRUE;
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS || (nof_fgs >= 4 && ((fg_idx + 1) % 2) == 0)) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action = bcmFieldActionSystemHeaderSet;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0 = bcmFieldSystemHeaderPphEei;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1 = entries[fg_idx][cur_entry_idx[fg_idx]].id;
            } else if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action = bcmFieldActionExternalValue0Set + fg_idx;
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0 = entries[fg_idx][cur_entry_idx[fg_idx]].id - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1 = 0;
            }            
            for(action_idx = 1; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
                entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[action_idx].is_valid = FALSE;
            }
    
            rv = bcm_field_action_add(unit,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].id,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].action,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param0,
                                      entries[fg_idx][cur_entry_idx[fg_idx]].actions_info[0].param1);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            /* install */
            rv = bcm_field_entry_install(unit, entries[fg_idx][cur_entry_idx[fg_idx]++].id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            if(cur_entry_idx[fg_idx] == nof_entries) {
                not_full_fgs[index] = not_full_fgs[last_not_full_idx--];  
            }
        }
            
        result = CMD_OK;
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }

            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                rv = bcm_field_group_destroy(unit, fg_config[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }
        
        if(nof_fgs > 1 && stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            for(presel_idx = 0; presel_idx < 3; ++presel_idx){
                rv = bcm_field_presel_destroy(unit, presel_idx);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }
        
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                sal_free(entries[fg_idx]);
                sal_free(entries_to_remove[fg_idx]);
                sal_free(valid_indecies[fg_idx]);
            }
            return CMD_FAIL;
        }
    }
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        sal_free(entries[fg_idx]);
        sal_free(entries_to_remove[fg_idx]);
        sal_free(valid_indecies[fg_idx]);
    }
    sal_free(not_full_fgs);
    
    /* Restore learn mode */
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    return CMD_OK;
    
fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
            }
        
            bcm_field_group_destroy(unit, fg_config[fg_idx].group);
        }
    }

destroy_presels_only:

    if(nof_fgs > 1) {
        if(nof_iterations > 1) {
            bcm_field_presel_destroy(unit, 0);
            bcm_field_presel_destroy(unit, 1);
            bcm_field_presel_destroy(unit, 2);
        }
    }

    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        sal_free(entries[fg_idx]);
        sal_free(entries_to_remove[fg_idx]);
        sal_free(valid_indecies[fg_idx]);
    }
    sal_free(not_full_fgs);
    
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_entry_priority(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the egerss stage!\n")));
        return CMD_FAIL;
    }
        
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of checking hitting according to the priority\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : entry_priority, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_entry_priority_and_shared_bank(unit, stage, x, mode, 1, do_warmboot);
}

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
cmd_result_t _bcm_petra_field_test_entry_priority_2(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid for the external stage only!\n")));
        return CMD_FAIL;
    }
        
    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of checking hitting according to the priority\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : entry_priority, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_entry_priority_and_shared_bank(unit, stage, x, mode, 4, do_warmboot);
}
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

cmd_result_t _bcm_petra_field_test_shared_bank(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }
        
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of checking hitting according to the priority for many field groups in shared bank\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : shared_bank, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return _bcm_petra_field_test_entry_priority_and_shared_bank(unit, stage, x, mode, SOC_IS_JERICHO(unit)? 2: 3, do_warmboot);
}


/* The test of field groups priority.
 * It craetes many field groups, and each one has the same qualifier in the entry.
 * it send packet and check if the actions are done according to the field groups' priority
 */

STATIC cmd_result_t _bcm_petra_field_test_field_group_priority_tag(int unit, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;
    bcm_error_t rv = BCM_E_NONE;
    bcm_field_qset_t qset;
    bcm_field_aset_t aset;
    bcm_field_group_t fg[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX];
    uint32 priorities[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX];
    bcm_field_entry_t entry_id[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX]={0};
    uint8 etries_created = 0;
    uint32 nof_iterations;
    uint32 second_rand_param = 0;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */

    const static bcm_field_action_t actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS] = {
        bcmFieldActionLearnForwardingVlanIdNew, /*(12b)*/
        bcmFieldActionMacDaKnown, /* (1b) */
        bcmFieldActionDhcpPkt, /* (1b) */
        bcmFieldActionPrioIntNew, /* (3b) */
    };
    SOC_PPC_FP_ACTION_TYPE ppd_actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS];
    int32 expected_actions[_BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS];
    uint32 is_actions_valid[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID_MAX][_BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS];
    uint32  iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 action_idx;
    uint8 does_exist_already;
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    SOC_PPC_FP_PACKET_DIAG_INFO *info;

    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of checking hitting according to the priority\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_priority, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS)));

    /* Disable learn mode */
    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        result = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        return CMD_OK;
    }

    /* Translating the bcm action to ppd actions */
    rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS, ppd_actions);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        /* qset: stage and source mac */

        BCM_FIELD_QSET_INIT(qset);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageIngress);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyOuterVlanPri);

        /* aset - */
        BCM_FIELD_ASET_INIT(aset);
        for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS; ++action_idx) {
            BCM_FIELD_ASET_ADD(aset, actions[action_idx]);
        }
    
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS); ++fg_idx) {
            /* take random prioriy */
            do
            {
                priorities[fg_idx] = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST)
                    + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                does_exist_already = FALSE;
                for(fg_idx2 = 0; fg_idx2 < fg_idx ; ++fg_idx2) {
                    if (priorities[fg_idx2] == priorities[fg_idx]) {
                        does_exist_already = TRUE;
                        break;
                    }
                }
            }
            while(does_exist_already);
            
            rv = bcm_field_group_create(unit, qset, priorities[fg_idx], &fg[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            rv = bcm_field_group_action_set(unit, fg[fg_idx], aset);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
    
        etries_created = 1;
        /* filling the entries */
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS); ++fg_idx){
            /* id */
            rv = bcm_field_entry_create(unit, fg[fg_idx], &entry_id[fg_idx]);
            if(rv != BCM_E_NONE){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        
            /* priority */
            rv = bcm_field_entry_prio_set(unit, entry_id[fg_idx], 1);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
    
            /* qualifier set */
            rv = bcm_field_qualify_OuterVlanPri(unit,
                                                entry_id[fg_idx],
                                                0x7,
                                                0x7);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        
            /* action */
            for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS; ++action_idx) {
                is_actions_valid[fg_idx][action_idx] = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
                if(is_actions_valid[fg_idx][action_idx]) {
                    if(actions[action_idx] == bcmFieldActionMacDaKnown ||
                        actions[action_idx] == bcmFieldActionOrientationSet ||
                        actions[action_idx] == bcmFieldActionDhcpPkt) {
                        rv = bcm_field_action_add(unit, entry_id[fg_idx], actions[action_idx], fg_idx% 2, 0);
                    } else {
                        rv = bcm_field_action_add(unit, entry_id[fg_idx], actions[action_idx], fg_idx, 0);
                    }
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        
            /* install */
            rv = bcm_field_entry_install(unit, entry_id[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
    
        rv = expected_actions_value(unit, actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS, fg, entry_id, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS), expected_actions);
    
        sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
        ethernet_header.nof_vlans = 1;
        ethernet_header.vlans[0].pri = 0x7;
        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
        ethernet_header.destination_address[5] = 0x1;
        
        result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }                
#ifndef PLISIM
        if(!_bcm_petra_field_test_check_hit(info, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, FALSE, FALSE)) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Hit didn't occur\n")));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        
        if(!actions_verification(info, ppd_actions, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_PRIORITY_NOF_ACTIONS, expected_actions, FALSE)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
#endif /* not def PLISIM */
    
        result = CMD_OK;
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS); ++fg_idx) {
            rv = bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            rv = bcm_field_group_destroy(unit, fg[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
    
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    }
        

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if (rv) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG; 
        goto fail;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;
    
fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_ID(_BCM_DPP_FIELD_STAGE_INDEX_INGRESS); ++fg_idx) {
            if (etries_created) {
                bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            }
            bcm_field_group_destroy(unit, fg[fg_idx]);
        }
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_field_group_priority(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }
    return _bcm_petra_field_test_field_group_priority_tag(unit, x, mode, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_cascaded(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;
    bcm_error_t rv = BCM_E_NONE;
    bcm_field_qset_t qset, valid_qset;
    bcm_field_aset_t aset, valid_aset;
    bcm_field_group_t fg[2];
    bcm_field_entry_t entry_id[2];
    uint32 iteration_idx;
    uint32 fg_idx;
    uint32 rnd;
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    uint8 cascaded_key_nof_bits;
    uint32 length;
    uint32 max_qualifiers_length;
    uint32 max_actions_length;
    uint32 max_qualifiers;
    uint32 max_actions;
    uint32 cascaded_data;
    uint32 nof_iterations;
    uint32 second_rand_param = 0;
    SOC_PPC_FP_PACKET_DIAG_INFO *info;

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of using cascaded key\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : cascaded, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, _BCM_PETRA_FIELD_TYPE_ETHR, &valid_qset, &valid_aset);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        cascaded_key_nof_bits = _BCM_PETRA_FIELD_TEST_CASCADED_MIN_NOF_BITS +
            _bcm_petra_field_rand_val(x, second_rand_param++) % (_BCM_PETRA_FIELD_TEST_CASCADED_MAX_NOF_BITS(unit) - _BCM_PETRA_FIELD_TEST_CASCADED_MIN_NOF_BITS);

        rv = bcm_field_control_set(unit, bcmFieldControlCascadedKeyWidth, cascaded_key_nof_bits);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);

        /* second field group */
        rv = _bcm_petra_field_test_qualify_hardware_length_worst(unit,
                                                                 _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                 _BCM_PETRA_FIELD_TYPE_ETHR,
                                                                  bcmFieldQualifyCascadedKeyValue,
                                                                  &length);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        /* qset */
        rnd = _bcm_petra_field_rand_val(x, second_rand_param++)%3;
        if(rnd == 0) {
            max_qualifiers_length = 320 - 3*_BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;/* It may be split in 4 zones */
        } else if(rnd == 1) {
            max_qualifiers_length = 160 - _BCM_PETRA_FIELD_TEST_QUALIFIERS_LENGTH_SPLIT_OVERHEAD;/* it may be split in 2 zones */
        } else {
            max_qualifiers_length = 80;/* must be in only single zone - no split overheadr */
        }
               
        max_qualifiers = _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_QUALIFIERS(stage);
        BCM_FIELD_QSET_INIT(qset);
        _bcm_petra_field_test_reset_resources();
        _bcm_petra_field_test_reset_field_group_resources(max_qualifiers_length/2);
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        _bcm_petra_field_test_kbp_reset_resources();
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                    _BCM_PETRA_FIELD_TYPE_ETHR,
                                                    &qset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
                                                    _bcm_petra_field_test_qualify_hardware_length_worst,
                                                    _bcm_petra_field_test_qualify_can_be_both,
                                                    _bcm_petra_field_test_take_qualifier,
                                                    bcmFieldQualifyCount,
                                                    &valid_qset,
                                                    max_qualifiers_length - length,
                                                    max_qualifiers - 1,
                                                    x + second_rand_param++);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageIngress);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyCascadedKeyValue);

        rv = bcm_field_group_create(unit, qset, 1, &fg[1]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        /* aset - */
        BCM_FIELD_ASET_INIT(aset);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionLearnForwardingVlanIdNew);
    
        rv = bcm_field_group_action_set(unit, fg[1], aset);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* first field group */

        /* qset */
        BCM_FIELD_QSET_INIT(qset);    
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageIngress);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyOuterVlanPri);

        /* aset */
        rnd = _bcm_petra_field_rand_val(x, second_rand_param++)%3;
        if(rnd == 0) {
            max_actions_length = 80;
        } else if(rnd == 1) {
            max_actions_length = 40;
        } else {
            max_actions_length = 20;
        }
        BCM_FIELD_ASET_INIT(aset);

        max_actions = _BCM_PETRA_FILED_TEST_FIELD_GROUP_MAX_ACTIONS;
        rv = _bcm_petra_field_test_action_length_with_valid_bit(unit,
                                                                _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                0,
                                                                bcmFieldActionCascadedKeyValueSet,
                                                                &length);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
                                             
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionCascadedKeyValueSet);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionSnoopAndTrap);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStatAndPolicer);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionPphSnoopCode);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile0Set);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile1Set);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile2Set);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfile3Set);
        BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionStaggeredPreselProfileDirectSet);

        if (!SOC_IS_ARADPLUS(unit)) {
            BCM_FIELD_ASET_REMOVE(valid_aset, bcmFieldActionInterfaceClassVPort);
            LOG_INFO(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                    "%s(): bcmFieldActionInterfaceClassVPort does not exist for Arad and below. This is just a message.\n"),
                                                                                                __FUNCTION__));
        }
        rv = _bcm_petra_field_create_set_max_length(unit,
                                                    stage,
                                                    0,
                                                    &aset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_action_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_action_set_test,
                                                    _bcm_petra_field_test_action_length_with_valid_bit,
                                                    _bcm_petra_field_test_action_can_be_both,
                                                    _bcm_petra_field_test_take_action,
                                                    bcmFieldActionCount,
                                                    &valid_aset,
                                                    max_actions_length - length,
                                                    max_actions - 1,
                                                    x + second_rand_param++);
        if(rv != BCM_E_NONE) {  
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        } 

        BCM_FIELD_ASET_ADD(aset, bcmFieldActionCascadedKeyValueSet);
        /* Take another 3 actions randomly */

        rv = bcm_field_group_create(unit, qset, 2, &fg[0]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        rv = bcm_field_group_action_set(unit, fg[0], aset);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* entries */
        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            /* id */
            rv = bcm_field_entry_create(unit, fg[fg_idx], &entry_id[fg_idx]);
            if(rv != BCM_E_NONE){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            /* priority */
            rv = bcm_field_entry_prio_set(unit, entry_id[fg_idx], 1);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
        
        /* qualifier set */
        rv = bcm_field_qualify_OuterVlanPri(unit, entry_id[0], 0x7, 0x7);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        cascaded_data = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << cascaded_key_nof_bits) - 1) + 1;
    
        rv = bcm_field_qualify_CascadedKeyValue(unit, entry_id[1], cascaded_data, (uint32)~0 >>(32 - cascaded_key_nof_bits) );
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        /* action */
        rv = bcm_field_action_add(unit, entry_id[0], bcmFieldActionCascadedKeyValueSet, cascaded_data, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        rv = bcm_field_action_add(unit, entry_id[1], bcmFieldActionLearnForwardingVlanIdNew, _BCM_PETRA_FIELD_TEST_CASCADED_FORWARDING_VLAN_ID_NEW_VALUE, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        
        /* install */
        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            rv = bcm_field_entry_install(unit, entry_id[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
    
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        /* NOT HIT */
        sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
        ethernet_header.nof_vlans = 1;
        ethernet_header.vlans[0].pri = 0x6;
        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
        ethernet_header.destination_address[5] = 0x1;
        
        result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }                
        
#ifndef PLISIM
        /* check hit */
        {
            uint32 cycle, bank;
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Hit occurred although it should not occur\n")));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }
#endif /* not def PLISIM */

        /* HIT */
        sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
        ethernet_header.nof_vlans = 1;
        ethernet_header.vlans[0].pri = 0x7;
        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
        ethernet_header.destination_address[5] = 0x1;
        
        result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }                
        
#ifndef PLISIM
        {
            uint8 nof_hits = 0;
            uint32 cycle, bank, action_idx;
            /* check hit */
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        for(action_idx = 0; action_idx < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX; ++action_idx) {
                                if(info->tcam[cycle][bank].actions[action_idx].type != SOC_PPC_FP_ACTION_TYPE_INVALID){
                                ++nof_hits;
                                    if(info->tcam[cycle][bank].actions[action_idx].type == SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY && 
                                    info->tcam[cycle][bank].actions[action_idx].val != cascaded_data) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Wrong hit in the changing the key :"
                                                         " expected action value %d, but it is %d\n"),
                                              cascaded_data, info->tcam[cycle][bank].actions[action_idx].val));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                                    if(info->tcam[cycle][bank].actions[action_idx].type == SOC_PPC_FP_ACTION_TYPE_LEARN_FID && 
                                    info->tcam[cycle][bank].actions[action_idx].val != _BCM_PETRA_FIELD_TEST_CASCADED_FORWARDING_VLAN_ID_NEW_VALUE) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Wrong hit in the action :"
                                                         " expected action value %d, but it is %d\n"),
                                              _BCM_PETRA_FIELD_TEST_CASCADED_FORWARDING_VLAN_ID_NEW_VALUE,
                                              info->tcam[cycle][bank].actions[action_idx].val));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                            }
                        }
                    }
                }
            }
            if(nof_hits != 2) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "The number of hits in valid actions is %d and not 2.\n"), nof_hits));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#endif /* not def PLISIM */
    
        result = CMD_OK;
        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            rv = bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            rv = bcm_field_group_destroy(unit, fg[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
    
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return CMD_FAIL;
        }
    }
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            bcm_field_group_destroy(unit, fg[fg_idx]);
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    
    return CMD_FAIL;
}

STATIC CONST bcm_field_qset_t *get_valid_presel_qualifiers(int unit, _bcm_dpp_field_stage_idx_t stage){
    CONST static bcm_field_qualify_t valid_presel_qualifiers_ingress[] = {
        bcmFieldQualifyHeaderFormat,
        bcmFieldQualifyInterfaceClassVPort,
        bcmFieldQualifyPtch,
        bcmFieldQualifyVlanFormat,
        bcmFieldQualifyForwardingType,
        bcmFieldQualifyInPort,
        bcmFieldQualifyInPorts,
        bcmFieldQualifyStage
    };
    CONST static bcm_field_qualify_t valid_presel_qualifiers_egress[] = {
        bcmFieldQualifyForwardingType,
        bcmFieldQualifyOutPort,
        bcmFieldQualifyOutPorts,
        bcmFieldQualifyVlanFormat,
        bcmFieldQualifyStage
    };
    /* will be set to zero in the bringup */
    static uint8 is_set[_BCM_DPP_FIELD_STAGE_INDEX_ING_SLB + 1];

    static bcm_field_qset_t qset[_BCM_DPP_FIELD_STAGE_INDEX_ING_SLB + 1];
    uint32 qual_index;
    uint32 type;
    bcm_field_qset_t valid_external_qset[_BCM_PETRA_FIELD_NOF_TYPES];
    bcm_field_aset_t junk;
    bcm_error_t rv;
    
    if(!is_set[stage]) {
        BCM_FIELD_QSET_INIT(qset[stage]);
        if(stage != _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_SLB) {
                for(type = 0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
                    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, stage, type, &valid_external_qset[type], &junk);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return NULL;
                    }
                }
            }
            for(qual_index = 0;
                qual_index < sizeof(valid_presel_qualifiers_ingress)/sizeof(bcm_field_qualify_t);
                ++qual_index) {
                BCM_FIELD_QSET_ADD(qset[stage], valid_presel_qualifiers_ingress[qual_index]);
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL || stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_SLB) {
                    /* Remove qualifiers are not supported in the stage */
                    for(type = 0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
                        if(BCM_FIELD_QSET_TEST(valid_external_qset[type], valid_presel_qualifiers_ingress[qual_index])) {
                            break;
                        }
                        if(type == _BCM_PETRA_FIELD_NOF_TYPES - 1) {
                            /* i.e. there is no type of the stage which this qualifier is supported in */
                            BCM_FIELD_QSET_REMOVE(qset[stage], valid_presel_qualifiers_ingress[qual_index]);
                        }
                    }
                }
            }
        } else {
            for(qual_index = 0;
                qual_index < sizeof(valid_presel_qualifiers_egress)/sizeof(bcm_field_qualify_t);
                ++qual_index) {
                BCM_FIELD_QSET_ADD(qset[stage], valid_presel_qualifiers_egress[qual_index]);
            }
        }
        is_set[stage] = TRUE;
    }
    
    return &qset[stage];
}

/* Utility to get the needed Stage offset flag for the BCM stage*/
void _bcm_petra_field_test_presel_stage_to_flag(bcm_field_stage_t stage, int *flag) 
{
    switch(stage) 
    {
    case bcmFieldStageEgress:
        *flag = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_EGRESS;
        break;
    case bcmFieldStageHash:
        *flag = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_HASH;
        break;
    default:
        *flag = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_INGRESS;
        break;
    }
}

/* The test for presels
 * It fills randomly prisels and retrieves and compare some of them chosen randomly.
 */
cmd_result_t _bcm_petra_field_test_presel(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    int32 presel_idx, presel_idx2;
    uint32 iteration_idx;
    uint32 rnd;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    bcm_field_presel_t id;
    cmd_result_t result;
    bcm_error_t rv;
    bcm_field_qset_t valid_qset;
    _bcm_petra_field_test_entry_info_t *presels;
    uint8 free_presel_ids[_BCM_PETRA_FIELD_TEST_NOF_PRESELS];
    bcm_field_qualify_t qualify;
    uint32 nof_available_port_profiles;
    uint32 qual_idx;
	bcm_field_stage_info_t stage_info;
	bcm_field_stage_t stage_value = 0;
    int presel_flags = 0;

    valid_qset = *get_valid_presel_qualifiers(unit, stage);
	
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }

    bcm_field_stage_info_get(unit, stage_value, &stage_info);

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 3, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of the pre-selectors\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : presel, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        nof_iterations = 1;
    }
    presels = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t) * _BCM_PETRA_FIELD_TEST_NOF_PRESELS, "_bcm_petra_field_test_presel.presels"); 
    if(!presels) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure\n")));
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if((iteration_idx > 0 || x == 0) && mode != _bcmPetraFieldTestScan) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx) {
            free_presel_ids[presel_idx] = presel_idx;
        }

        for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx){
            presels[presel_idx].id = BCM_FIELD_QUALIFY_PRESEL; /* in order that all of the ids will be initialized in case of failure */
        }

        nof_available_port_profiles = 1; 

        /* fill presles */
        if(mode != _bcmPetraFieldTestScan) {
            for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx){
                /* presel id*/
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if(is_explicit_id || soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % (_BCM_PETRA_FIELD_TEST_NOF_PRESELS - presel_idx);
                    presels[presel_idx].id = free_presel_ids[rnd];
                    free_presel_ids[rnd] = free_presel_ids[_BCM_PETRA_FIELD_TEST_NOF_PRESELS - presel_idx - 1];
                    if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                        rv = bcm_field_presel_create_id(unit, presels[presel_idx].id);
                    } else {
                        rv = bcm_field_presel_create_stage_id(unit, stage_value, presels[presel_idx].id);
                        _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
                    }
                } else {
                    rv = bcm_field_presel_create(unit, &presels[presel_idx].id);
                    for(presel_idx2 = 0; presel_idx2 < _BCM_PETRA_FIELD_TEST_NOF_PRESELS - presel_idx; ++presel_idx2) {
                        if(free_presel_ids[presel_idx2] == presels[presel_idx].id) {
                            free_presel_ids[presel_idx2] = free_presel_ids[_BCM_PETRA_FIELD_TEST_NOF_PRESELS - presel_idx - 1];
                            break;
                        }
                    }
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }                    
                presels[presel_idx].id |= BCM_FIELD_QUALIFY_PRESEL | presel_flags;

                if(nof_available_port_profiles < 2) {
                    BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInPort);
                    BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyOutPort);
                }
                if(nof_available_port_profiles < 1) {
                    BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInPorts);
                    BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyOutPorts);
                    BCM_FIELD_QSET_REMOVE(valid_qset, bcmFieldQualifyInterfaceInPorts);
                }

                result = _bcm_petra_field_test_set_entry_qualifiers(unit, stage, &valid_qset, FALSE, FALSE, x + second_rand_param++, FALSE, &presels[presel_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                /* update the number of available port profiles */
                for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
                    if(presels[presel_idx].quals_info[qual_idx].is_valid && 
                        (presels[presel_idx].quals_info[qual_idx].qualify == bcmFieldQualifyInPort ||
                            presels[presel_idx].quals_info[qual_idx].qualify == bcmFieldQualifyInPorts ||
                            presels[presel_idx].quals_info[qual_idx].qualify == bcmFieldQualifyInterfaceInPorts ||
                            presels[presel_idx].quals_info[qual_idx].qualify == bcmFieldQualifyOutPort ||
                            presels[presel_idx].quals_info[qual_idx].qualify == bcmFieldQualifyOutPorts)
                    ) {
                        --nof_available_port_profiles;    
                    }
                }
            }
#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif
            /* qualifiers verification */
            for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx) {
                id = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_NOF_PRESELS;
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &presels[id], FALSE, FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }

            result = CMD_OK;
            for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx) {
                rv = bcm_field_presel_destroy(unit, (presels[presel_idx].id & (~BCM_FIELD_QUALIFY_PRESEL)));
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }

            if(result != CMD_OK) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "x = %d\n"), x));
                }
                if(presels) {
                    sal_free(presels);
                }
                return CMD_FAIL;
            }
        }  else {
			presels[0].id = -1;
            for(qualify = 0; qualify < stage_info.field_presel_max_id; ++qualify) {
                const static char *qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
                bcm_field_qset_t qset;
                if(!BCM_FIELD_QSET_TEST(valid_qset, qualify)) {
                    continue;
                }
                if(stage_info.field_presel_advanced_mode) {
					presels[0].id++;
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, presels[0].id);
                    _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
                    presels[0].id |= presel_flags;
                } else {
					presels[0].id = 0;
                    rv = bcm_field_presel_create_id(unit, presels[0].id);
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }                 
                presels[0].id |= BCM_FIELD_QUALIFY_PRESEL;

                BCM_FIELD_QSET_INIT(qset);
                BCM_FIELD_QSET_ADD(qset, qualify);
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "qualifier: %s.\n"), qualifiers_names[qualify]));
                result = _bcm_petra_field_test_set_entry_qualifiers(unit, stage, &qset, FALSE, FALSE, sal_rand(), TRUE, &presels[0]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
#ifdef BCM_WARM_BOOT_SUPPORT
                if(do_warmboot) {
                    _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
                }
#endif
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &presels[0], FALSE, FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                presels[0].id &= ~ BCM_FIELD_QUALIFY_PRESEL;
                if(!stage_info.field_presel_advanced_mode) {
                   rv = bcm_field_presel_destroy(unit, presels[0].id);
                   if(rv != BCM_E_NONE) {
                     _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                      goto fail;
                   }
                }
            }
        }
    }

    sal_free(presels);
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(nof_iterations > 1) {
		if(!stage_info.field_presel_advanced_mode) {
            for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_NOF_PRESELS; ++presel_idx) {
                presels[presel_idx].id &= ~ BCM_FIELD_QUALIFY_PRESEL;
                bcm_field_presel_destroy(unit, presels[presel_idx].id);
            }
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB && mode != _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    if(presels) {
        sal_free(presels);
    }
    
    return CMD_FAIL;
}

uint8 _bcm_petra_field_test_presel_get_valid_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, bcm_field_presel_set_t *valid_set)
{
    uint32 presel;
    
    BCM_FIELD_PRESEL_INIT(*valid_set);
    for(presel = 0; presel < BCM_FIELD_ACTION_WIDTH_MAX; ++presel) {
        BCM_FIELD_PRESEL_ADD(*valid_set, presel);
    }
    
    return 0;
}

STATIC void* _bcm_petra_field_test_presel_set_init(void)
{
    bcm_field_presel_set_t *init = sal_alloc(sizeof(bcm_field_presel_set_t), 0);
    BCM_FIELD_PRESEL_INIT(*init);
    return init;
}

STATIC void _bcm_petra_field_test_presel_set_add(bcm_field_presel_set_t *set, uint32 item)
{
    BCM_FIELD_PRESEL_ADD(*set, item);
}

STATIC void _bcm_petra_field_test_presel_set_remove(bcm_field_presel_set_t *set, uint32 item)
{
    BCM_FIELD_PRESEL_REMOVE(*set, item);
}

STATIC uint8 _bcm_petra_field_test_presel_set_test(bcm_field_presel_set_t *set, uint32 item)
{
    return (BCM_FIELD_PRESEL_TEST(*set, item) != 0);
}

STATIC void _bcm_petra_field_presel_set_print(const bcm_field_presel_set_t *presel_set)
{
#ifdef BROADCOM_DEBUG
    uint32 presel;
    int unit = BSL_UNIT_UNKNOWN;
    
    LOG_CLI((BSL_META_U(unit,
                        "Printing the presel ids in the set:\n")));
    for(presel = 0; presel < BCM_FIELD_ACTION_WIDTH_MAX; ++presel) {
        if(BCM_FIELD_PRESEL_TEST(*presel_set, presel)) {
            LOG_CLI((BSL_META_U(unit,
                                "%d "), presel));
        }
    }
    LOG_CLI((BSL_META_U(unit,
                        "\n")));
    LOG_CLI((BSL_META_U(unit,
                        "--- The end of the set ---\n\n")));
#endif /* BROADCOM_DEBUG */
}

cmd_result_t _bcm_petra_field_test_presel_set(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    const static char *item_names[] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
        "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
        "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
        "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
        "40", "41", "42", "43", "44", "45", "46", "47", "48", "49"};

    bcm_field_presel_set_t valid_set;
    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove for presel set\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : presel_set, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_add_and_remove_scan_test(
            (void* (*)(void)) _bcm_petra_field_test_presel_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_presel_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_presel_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_presel_set_test,
            (void (*)(const void*)) _bcm_petra_field_presel_set_print,
            item_names,
            BCM_FIELD_ACTION_WIDTH_MAX);
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx> 0 || x == 0) {
            x = sal_rand();
        }
        if(_bcm_petra_field_test_presel_get_valid_set(unit, stage, x, &valid_set)) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Getting the valid items set failed\n")));
            }
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(_bcm_petra_field_add_and_remove_test(
            (void* (*)(void)) _bcm_petra_field_test_presel_set_init,
            (void (*)(void*, uint32)) _bcm_petra_field_test_presel_set_add,
            (void (*)(void*, uint32)) _bcm_petra_field_test_presel_set_remove,
            (uint8 (*)(void*, uint32)) _bcm_petra_field_test_presel_set_test,
            (void (*)(const void*)) _bcm_petra_field_presel_set_print,
            item_names,
            BCM_FIELD_ACTION_WIDTH_MAX,
            &valid_set,
            20,
            x) ) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    }
    return CMD_OK;
}

/* Creates 2 preselectors: 1 for L2 packets and 1 for ipv4 packets.
 * Creates 3 field groups 1 for the first preselector, 1 for the second and 1 to both of them.
 * Send packet and verify the actions are done according to the field groups priority
 */
cmd_result_t _bcm_petra_field_test_field_group_presel(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    int32 fg_idx;
    cmd_result_t result;
    bcm_error_t rv;
    bcm_field_group_config_t fg[3];
    const bcm_field_action_t actions_to_check_ingress[3] = {
        bcmFieldActionMacDaKnown,
        bcmFieldActionLearnForwardingVlanIdNew,
        bcmFieldActionDhcpPkt
    };
    const bcm_field_action_t actions_to_check_egress[3] = {
        bcmFieldActionPrioIntNew,
        bcmFieldActionQosMapIdNew,
        bcmFieldActionMirrorEgress
    };
    SOC_PPC_FP_ACTION_TYPE ppd_actions[3];
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    _bcm_dpp_core_ports_bitmap_t  unavail_ports[MAX_NUM_OF_CORES];
    bcm_port_t cur_avail_port = 0;
    bcm_pbmp_t data, mask;
    int        core;
    int        nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    CONST uint32 local_port_src = 1;
    bcm_port_t junk_mask;
    SOC_PPC_FP_PACKET_DIAG_INFO *info = NULL;
    uint8 success;
    int presel_flags = 0;
	bcm_field_stage_t stage_value = 0;

        
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of the field groups with pre-selectors\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_presel, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }
    /* Translating the bcm action to ppd actions */
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions_to_check_ingress, 3, ppd_actions);
    } else {
        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions_to_check_egress, 3, ppd_actions);
    }
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    /* creating 2 presels one for HeaderFormat l2, and one for ipv4 */
    if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
        rv = bcm_field_presel_create_id(unit, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        rv = bcm_field_presel_create_id(unit, 1);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_presels_only;
        }
    } else {
        _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
        rv = bcm_field_presel_create_stage_id(unit, stage_value, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        rv = bcm_field_presel_create_stage_id(unit, stage_value, 1);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_presels_only;
        }
    }
    
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        rv = bcm_field_qualify_HeaderFormat(unit, 0 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatL2);
    } else{
        result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeOutPort, &nof_cores, unavail_ports);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_presels_only;
        }
        for (core=0; core<nof_cores; core++) {
            for(cur_avail_port = 0; cur_avail_port < _BCM_DPP_NOF_PORTS_PER_CORE(unit); ++cur_avail_port) {
                if(!SHR_BITGET(unavail_ports[core], cur_avail_port)) {
                    break;
                }
            }
        }
        cur_avail_port +=  _BCM_DPP_NOF_PORTS_PER_CORE(unit)*core;
        rv = bcm_field_qualify_OutPort(unit, 0 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, cur_avail_port, 0xffffffff);
    }
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto destroy_presels_only;
    }

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        rv = bcm_field_qualify_HeaderFormat(unit, 1 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp4);
    } else {
        BCM_PBMP_CLEAR(data);
        BCM_PBMP_NEGATE(mask, data);
        for (core=0; core<nof_cores;core++) {
           for(; cur_avail_port <  _BCM_DPP_NOF_PORTS_PER_CORE(unit); ++cur_avail_port) {
               if(!SHR_BITGET(unavail_ports[core], cur_avail_port)) {
                   BCM_PBMP_PORT_ADD(data, cur_avail_port+(core* _BCM_DPP_NOF_PORTS_PER_CORE(unit)));
                   break;
               }
           }
           for(; cur_avail_port < _BCM_DPP_NOF_PORTS_PER_CORE(unit); ++cur_avail_port) {
               if(!SHR_BITGET(unavail_ports[core], cur_avail_port)) {
                   BCM_PBMP_PORT_ADD(data, cur_avail_port+(core* _BCM_DPP_NOF_PORTS_PER_CORE(unit)));
                   break;
               }
           }
        }

        rv = bcm_field_qualify_OutPorts(unit, 1 | BCM_FIELD_QUALIFY_PRESEL | presel_flags, data, mask);
    }
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto destroy_presels_only;
    }

    /* creating 3 presel sets one contains presel 0, one contains 1, and one contains both of them */
    for(fg_idx = 0; fg_idx < 3; ++fg_idx) {
        bcm_field_group_config_t_init(&fg[fg_idx]);
        BCM_FIELD_PRESEL_INIT(fg[fg_idx].preselset);
        fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
        fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
        fg[fg_idx].group = fg_idx;
        fg[fg_idx].priority = fg_idx + 1;
    }
    
    BCM_FIELD_PRESEL_ADD(fg[0].preselset, 0);
    BCM_FIELD_PRESEL_ADD(fg[1].preselset, 1);
    BCM_FIELD_PRESEL_ADD(fg[2].preselset, 0);
    BCM_FIELD_PRESEL_ADD(fg[2].preselset, 1);

    /* qset */
    for(fg_idx = 0; fg_idx < 3; ++fg_idx) {
        BCM_FIELD_QSET_INIT(fg[fg_idx].qset);
        BCM_FIELD_QSET_ADD(fg[fg_idx].qset, bcmFieldQualifyOuterVlanPri);
    }        

    /* aset */
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        for(fg_idx = 0; fg_idx <3; ++fg_idx) {
            BCM_FIELD_ASET_INIT(fg[fg_idx].aset);
            BCM_FIELD_ASET_ADD(fg[fg_idx].aset, actions_to_check_ingress[fg_idx]);
            fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
        }
    }

    /* create the field groups */
    for(fg_idx = 0; fg_idx <3; ++fg_idx) {
        rv = bcm_field_group_config_create(unit, &fg[fg_idx]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    /* entries */
    for(fg_idx = 0; fg_idx < 3; ++fg_idx) {
        rv = bcm_field_entry_create_id(unit, fg_idx, fg_idx);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        rv = bcm_field_qualify_OuterVlanPri(unit, fg_idx, 0x7, 0x7);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            rv = bcm_field_action_add(unit, fg_idx, actions_to_check_ingress[fg_idx], 1, 0);
        } else {
            rv = bcm_field_action_add(unit, fg_idx, actions_to_check_egress[fg_idx], 1, 0);
        }
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        rv = bcm_field_entry_install(unit, fg_idx);            
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    if(do_warmboot) {
        _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
    }
#endif
    sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
    ethernet_header.nof_vlans = 1;
    ethernet_header.vlans[0].pri = 0x7;
    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
    ethernet_header.destination_address[5] = 0x1;
    ethernet_header.ethertype = 0x8809;/* In order that it will have ethertype only */


    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        /* we should force the egress port to be as we want */
        rv = bcm_field_qualify_OutPort_get(unit, BCM_FIELD_QUALIFY_PRESEL, &cur_avail_port, &junk_mask);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        rv = bcm_port_force_forward_set(unit, local_port_src, cur_avail_port, TRUE);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, local_port_src, &info);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }   

    
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        rv = bcm_port_force_forward_set(unit, local_port_src, cur_avail_port, FALSE);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    success = FALSE;    
#ifndef PLISIM
    {
        uint8 hit_db0_ok = FALSE;
        uint8 hit_db2_ok = FALSE;
        int32 cycle, bank, macro;

        /* check hit */
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        success = TRUE;
                        break;
                    }
                }
                if(success) {
                    break;
                }
            }
            if(!success) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Hit didn't occur\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }

        /* action verification - actions[0] and action[2] should be occurred*/
        for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                    if(info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID) {
                    if(info->macro_simple[cycle][macro].action.type == ppd_actions[0]) {
                        if(info->macro_simple[cycle][macro].action.val ==  1) {
                            hit_db0_ok = TRUE;
                        } else {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "The action of D.B. 0 occurred with a wrong value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else if (info->macro_simple[cycle][macro].action.type == ppd_actions[2]) {
                        if(info->macro_simple[cycle][macro].action.val ==  1) {
                            hit_db2_ok = TRUE;
                        } else {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "The action of D.B. 2 occurred with a wrong value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Invalid action occurred\n")));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }
        if(!hit_db0_ok || !hit_db2_ok) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
#endif /* not def PLISIM */

    sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
    ethernet_header.nof_vlans = 1;
    ethernet_header.vlans[0].pri = 0x7;
    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
    ethernet_header.destination_address[5] = 0x1;
    ethernet_header.ethertype = 0x800;
        
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        /* we should force the egress port to be as we want */
        rv = bcm_field_qualify_OutPorts_get(unit, 1 | BCM_FIELD_QUALIFY_PRESEL, &data, &mask);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        for(cur_avail_port = 0; cur_avail_port < _BCM_DPP_NOF_LOCAL_PORTS(unit); ++cur_avail_port) {
            if(BCM_PBMP_MEMBER(data, cur_avail_port)) {
                break;
            }
        }
        rv = bcm_port_force_forward_set(unit, local_port_src, cur_avail_port, TRUE);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, local_port_src, &info);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }                

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        rv = bcm_port_force_forward_set(unit, local_port_src, cur_avail_port, FALSE);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
    success = FALSE;    
#ifndef PLISIM
    {
        uint8 hit_db1_ok = FALSE;
        uint8 hit_db2_ok = FALSE;
        int32 cycle, bank, macro;

        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            /* check hit */
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        success = TRUE;
                        break;
                    }
                }
                if(success) {
                    break;
                }
            }
            if(!success) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Hit didn't occur\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }

        /* action verification - actions[1] and action[2] should be occurred*/
        for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
            for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                    if(info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID) {
                    if(info->macro_simple[cycle][macro].action.type == ppd_actions[1]) {
                        if(info->macro_simple[cycle][macro].action.val ==  1) {
                            hit_db1_ok = TRUE;
                        } else {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "The action of D.B. 1 occurred with a wrong value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else if(info->macro_simple[cycle][macro].action.type == ppd_actions[2]) {
                        if(info->macro_simple[cycle][macro].action.val ==  1) {
                            hit_db2_ok = TRUE;
                        } else {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "The action of D.B. 2 occurred with a wrong value\n")));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    } else {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Invalid action occurred\n")));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }
        if(!hit_db1_ok || !hit_db2_ok) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
#endif /* not def PLISIM */

    result = CMD_OK;
    for(fg_idx = 0; fg_idx < 3; ++fg_idx) {
        rv = bcm_field_entry_destroy(unit, fg_idx);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            result = CMD_FAIL;
        }
        rv = bcm_field_group_destroy(unit, fg_idx);        
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            result = CMD_FAIL;
        }
    }        

    rv = bcm_field_presel_destroy(unit, 0 | presel_flags);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        result = CMD_FAIL;
    }
    rv = bcm_field_presel_destroy(unit, 1 | presel_flags);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        result = CMD_FAIL;
    }

    if(result != CMD_OK) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    for(fg_idx = 0; fg_idx < 3; ++fg_idx) {
        bcm_field_entry_destroy(unit, fg_idx);
        bcm_field_group_destroy(unit, fg_idx);        
    }        

destroy_presels_only:

    bcm_field_presel_destroy(unit, 0 | presel_flags);
    bcm_field_presel_destroy(unit, 1 | presel_flags);

    return CMD_FAIL;
}

STATIC cmd_result_t _bcm_petra_field_test_db_to_hit_ingress(int unit,
                                                            bcm_field_header_format_t header_format,
                                                            bcm_port_t in_port,
                                                            bcm_field_presel_set_t psset[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS],
                                                            uint8 db_hit[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS])
{
    uint32 db_idx;
    uint32 presel_idx;
    bcm_field_header_format_t cur_header_format;
    bcm_port_t cur_in_port, mask;
    bcm_error_t rv;
    
    for(db_idx = 0; db_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++db_idx){
        db_hit[db_idx] = FALSE;
        for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++presel_idx) {
            if(BCM_FIELD_PRESEL_TEST(psset[db_idx], presel_idx)) {
                rv = bcm_field_qualify_HeaderFormat_get(unit, presel_idx | BCM_FIELD_QUALIFY_PRESEL, &cur_header_format);
                if(rv != BCM_E_NONE && rv != BCM_E_NOT_FOUND) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(rv == BCM_E_NONE) {
                    /* i.e. this preselector is for header format */
                    if(cur_header_format == header_format) {
                        db_hit[db_idx] = TRUE;
                        break;
                    }
                } else {
                    rv = bcm_field_qualify_InPort_get(unit, presel_idx | BCM_FIELD_QUALIFY_PRESEL, &cur_in_port, &mask);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(cur_in_port == in_port) {
                        db_hit[db_idx] = TRUE;
                        break;
                    }
                }
            }
        }
    }
    return CMD_OK;
}

STATIC cmd_result_t _bcm_petra_field_test_db_to_hit_egress(int unit,
                                                           bcm_port_t out_port,
                                                           bcm_field_presel_set_t psset[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS],
                                                           uint8 db_hit[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS])
{
    uint32 db_idx;
    uint32 presel_idx;
    bcm_port_t cur_out_port, mask;
    bcm_error_t rv;
    
    for(db_idx = 0; db_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++db_idx){
        db_hit[db_idx] = FALSE;
        for(presel_idx = 0; presel_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++presel_idx) {
            if(BCM_FIELD_PRESEL_TEST(psset[db_idx], presel_idx)) {
                rv = bcm_field_qualify_OutPort_get(unit, presel_idx | BCM_FIELD_QUALIFY_PRESEL, &cur_out_port, &mask);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(cur_out_port == out_port) {
                    db_hit[db_idx] = TRUE;
                    break;
                }
            }
        }
    }
    return CMD_OK;
}

/*
 * The same as the the test field group presel.
 * Take preselctors that can be header format or in-port(s)
 * Create 5 field groups. Check the action values according to the priorities.
 */
cmd_result_t _bcm_petra_field_test_field_group_presel_1(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 presel_id;
    uint32 fg_idx, fg_idx2;
    uint32 rnd;
    uint32 flip;
    uint32 nof_sent_packets;
    uint32 is_valid = 0;
    uint32 second_rand_param = 0;
    cmd_result_t result;
    bcm_error_t rv;
    bcm_field_group_config_t *fg;
    bcm_field_presel_set_t psset[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS];
    bcm_field_header_format_t hit_header_format = 0;
    bcm_port_t in_ports[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS];
    bcm_port_t out_ports[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS];
    bcm_port_t cur_port;
    uint32 in_ports_idx = 0, out_ports_idx = 0;
    uint32 nof_ports;
    _bcm_dpp_core_ports_bitmap_t unavail_ports[MAX_NUM_OF_CORES];
    int   core;
    uint32 pp_port;
    uint8 db_hit[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS];
    const bcm_field_action_t actions_to_check_ingress[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS] = {
        bcmFieldActionMacDaKnown,
        bcmFieldActionLearnForwardingVlanIdNew,
        bcmFieldActionDhcpPkt,
        bcmFieldActionPrioIntNew,
    };
    const bcm_field_action_t actions_to_check_egress[3] = {
        bcmFieldActionPrioIntNew,
        bcmFieldActionQosMapIdNew,
        bcmFieldActionMirrorEgress
    };
    SOC_PPC_FP_ACTION_TYPE ppd_actions[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS];
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    uint8 does_exist_already;
    CONST uint32 local_port_src = 1;
    int nof_cores;
    SOC_PPC_FP_PACKET_DIAG_INFO *info = NULL;
    uint8 success;
    int presel_flags = 0;
    int stage_value = 0;
	
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }
    /* Translating the bcm action to ppd actions */
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions_to_check_ingress, _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS, ppd_actions);
    } else {
        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, actions_to_check_egress, 3, ppd_actions);
    }
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 3, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of the field groups with pre-selectors\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : field_group_presel_1, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    fg = sal_alloc(sizeof(bcm_field_group_config_t) * _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS, "_bcm_petra_field_test_field_group_presel_1.fg");
    if(!fg) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        /* getting unavailable ports, and take some of them */
        result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeInPort, &nof_cores, unavail_ports);
        if(result != CMD_OK) {
            sal_free(fg);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        nof_ports = 0;
        for(cur_port = 1; cur_port < _BCM_DPP_NOF_LOCAL_PORTS(unit); ++cur_port) {
            rv = soc_port_sw_db_is_valid_port_get(unit,cur_port,&is_valid);
            if ( !is_valid ) {
                continue;
            }
            rv = soc_port_sw_db_local_to_pp_port_get(unit, cur_port, &pp_port, &core);
            if (BCM_FAILURE(rv)) { /* function returns valid port number or error ID */
                sal_free(fg);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                 return CMD_FAIL;

            }

            if(!SHR_BITGET(unavail_ports[core], pp_port)) {
                in_ports[nof_ports++] = 1 /*cur_port*/;
                if(nof_ports == _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS) {
                    break;
                }
            }
        }

        result = _bcm_petra_field_test_get_unavailable_ports(unit, _bcmDppFieldProfileTypeOutPort, &nof_cores, unavail_ports);
        if(result != CMD_OK) {
            sal_free(fg);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        nof_ports = 0;
        for(cur_port = 1; cur_port < _BCM_DPP_NOF_LOCAL_PORTS(unit); ++cur_port) {
            rv = soc_port_sw_db_is_valid_port_get(unit,cur_port,&is_valid);
            if ( !is_valid ) {
                continue;
            }
            rv = soc_port_sw_db_local_to_pp_port_get(unit, cur_port, &pp_port, &core);
            if (BCM_FAILURE(rv)) { /* function returns valid port number or error ID */
                sal_free(fg);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                 return CMD_FAIL;
            }
            if(!SHR_BITGET(unavail_ports[core], pp_port)) {
                out_ports[nof_ports++] = cur_port;
                if(nof_ports == _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS) {
                    break;
                }
            }
        }

        /* creating half of the presels randomly */
        /* another presels will be created latter */
        for(presel_id = 0; presel_id < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS/2; ++presel_id) {
            if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                rv = bcm_field_presel_create_id(unit, presel_id);
                if(rv != BCM_E_NONE) {
                    sal_free(fg);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            } else {
                rv = bcm_field_presel_create_stage_id(unit, stage_value, presel_id);
                if(rv != BCM_E_NONE) {
                    sal_free(fg);
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
            }

            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 3;
                    switch(rnd){
                        case 0:
                            rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatL2);
                            break;
                        case 1:
                            rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp4);
                            break;
                        case 2:
                            rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp6);
                            break;
                        default:;
                    }
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
            } else {
                out_ports_idx = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS;
                rv = bcm_field_qualify_OutPort(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, out_ports[out_ports_idx], 0xffffffff);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }
            }
        }

        for(flip = 0; flip < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_FLIPS; ++flip) {
            for(presel_id = _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS/2; presel_id < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++presel_id) {
                if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                    rv = bcm_field_presel_create_id(unit, presel_id);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                } else {
                    presel_flags = BCM_FIELD_QUALIFY_PRESEL_ADVANCED_MODE_STAGE_EGRESS;
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, presel_id);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
                }
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                        rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 3;
                        switch(rnd){
                            case 0:
                                rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatL2);
                                break;
                            case 1:
                                rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp4);
                                break;
                            case 2:
                                rv = bcm_field_qualify_HeaderFormat(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldHeaderFormatIp6);
                                break;
                            default:;
                        }
                        if(rv != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto destroy_presels_only;
                        }
                } else {
                    out_ports_idx = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS;
                    rv = bcm_field_qualify_OutPort(unit, presel_id | BCM_FIELD_QUALIFY_PRESEL | presel_flags, out_ports[out_ports_idx], 0xffffffff);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                }
            }

            /* field groups id */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                bcm_field_group_config_t_init(&fg[fg_idx]);
                fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
                fg[fg_idx].group = fg_idx;
            }

            /* field groups priority */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                do
                {
                    fg[fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                        %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                    does_exist_already = FALSE;
                    for(fg_idx2 = 0; fg_idx2 < fg_idx ;++fg_idx2) {
                        if (fg[fg_idx].priority == fg[fg_idx2].priority) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                }
                while(does_exist_already);
            }

            /* field group presel sets */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
                BCM_FIELD_PRESEL_INIT(fg[fg_idx].preselset);
                /* take at least one presel */
                rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS;
                BCM_FIELD_PRESEL_ADD(fg[fg_idx].preselset, rnd);
            }

            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx){      
                for(fg_idx2 = 0; fg_idx2 < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++fg_idx2){
                    if(_bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
                        BCM_FIELD_PRESEL_ADD(fg[fg_idx].preselset, fg_idx2);
                    }
                }
                psset[fg_idx] = fg[fg_idx].preselset;
            }
        
            /* qset */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                BCM_FIELD_QSET_INIT(fg[fg_idx].qset);
                BCM_FIELD_QSET_ADD(fg[fg_idx].qset, bcmFieldQualifyOuterVlanPri);
            }

            /* aset */
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                    BCM_FIELD_ASET_INIT(fg[fg_idx].aset);
                    BCM_FIELD_ASET_ADD(fg[fg_idx].aset, actions_to_check_ingress[fg_idx]);
                    fg[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
                }
            }

            /* creating field groups */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                rv = bcm_field_group_config_create(unit, &fg[fg_idx]);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }        

            /* entries */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                bcm_field_entry_create_id(unit, fg_idx, fg_idx);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_qualify_OuterVlanPri(unit, fg_idx, 0x7, 0x7);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                    rv = bcm_field_action_add(unit, fg_idx, actions_to_check_ingress[fg_idx], 1, 0);
                } else {
                    rv = bcm_field_action_add(unit, fg_idx, actions_to_check_egress[fg_idx], 1, 0);
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_entry_install(unit, fg_idx);            
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }

#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif
            /* sending packets */
            for(nof_sent_packets = 0; nof_sent_packets < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PACKETS_TO_SEND; ++nof_sent_packets) {
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                    rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 3;
                    switch(rnd){
                        case 0:
                            hit_header_format = bcmFieldHeaderFormatL2;
                            break;
                        case 1:
                            hit_header_format = bcmFieldHeaderFormatIp4;
                            break;
                        case 2:
                            hit_header_format = bcmFieldHeaderFormatIp6;
                            break;
                        default:;
                    }
            
                    in_ports_idx = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS;
                    result = _bcm_petra_field_test_db_to_hit_ingress(unit, hit_header_format, in_ports[in_ports_idx], psset, db_hit);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                } else {
                    hit_header_format = bcmFieldHeaderFormatL2;
                    out_ports_idx = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PORTS;
                    rv = bcm_port_force_forward_set(unit, local_port_src, out_ports[out_ports_idx], TRUE);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                    result = _bcm_petra_field_test_db_to_hit_egress(unit, out_ports[out_ports_idx], psset, db_hit);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }

                sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
                ethernet_header.nof_vlans = 1;
                ethernet_header.vlans[0].pri = 0x7;
                ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                ethernet_header.destination_address[5] = 0x1;
                switch(hit_header_format){
                    case bcmFieldHeaderFormatL2:
                        ethernet_header.ethertype = 0x8809;/* In order that it will have ethertype only */
                        break;
                    case bcmFieldHeaderFormatIp4:
                        ethernet_header.ethertype = 0x800;
                        break;
                    case bcmFieldHeaderFormatIp6:
                        ethernet_header.ethertype = 0x86dd;
                        break;
                    default:;
                }
            
            
                result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, in_ports[in_ports_idx], &info);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }                

                success = FALSE;    
#ifndef PLISIM
                {
                    uint8 db_hit_ok[_BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS];
                    uint8 is_valid_action;
                    int32 cycle, bank, macro;
                    uint32 action_idx;
            
                    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                        /* check hit */
                        for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                            for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                                if(info->tcam[cycle][bank].is_match) {
                                    success = TRUE;
                                    break;
                                }
                            }
                            if(success) {
                                break;
                            }
                        }
            
                        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx){
                            if(db_hit[fg_idx]) {
                                if(!success) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Hit didn't occur\n")));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                                break;
                            }
                        }
                    }
        
                    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx){
                        db_hit_ok[fg_idx] = FALSE;
                    }
            
                    /* action verification */
                    for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
                        for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                                if(info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID) {
                                is_valid_action = FALSE;
                                for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++action_idx) {
                                    if(info->macro_simple[cycle][macro].action.type == ppd_actions[action_idx]) {
                                        if(info->macro_simple[cycle][macro].action.val ==  1) {
                                            db_hit_ok[action_idx] = TRUE;
                                            is_valid_action = TRUE;
                                        } else {
                                            LOG_INFO(BSL_LS_BCM_FP,
                                                     (BSL_META_U(unit,
                                                                 "The action of D.B. %d occurred with a wrong value\n"), action_idx));
                                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                            goto fail;
                                        }
                                    }
                                }
                                if(!is_valid_action) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Invalid action occurred\n")));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                            }
                        }
                    }
            
                    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                        if(db_hit[fg_idx] != db_hit_ok[fg_idx] ) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "Failure: expected hit in db %d : %s. actually hit %s.\n"), fg_idx, db_hit[fg_idx] ? "TRUE":"FALSE", db_hit_ok[fg_idx] ? "TRUE":"FALSE"));
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    }
                }
#endif /* not def PLISIM */
            } /* nof_sent_packets */
            
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
                rv = bcm_port_force_forward_set(unit, local_port_src, out_ports[out_ports_idx], FALSE);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }

            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
                rv = bcm_field_entry_destroy(unit, fg_idx);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_group_destroy(unit, fg_idx);        
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }        

            for(presel_id = _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS/2; presel_id < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++presel_id) {
                rv = bcm_field_presel_destroy(unit, presel_id | presel_flags);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }
            }
        }/* flip */
        
        /* Destroying the residual presels */
        for(presel_id = 0; presel_id < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS/2; ++presel_id) {
            rv = bcm_field_presel_destroy(unit, presel_id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
        
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return CMD_FAIL;
        }
    }

    sal_free(fg);
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_DBS; ++fg_idx) {
            bcm_field_entry_destroy(unit, fg_idx);
            bcm_field_group_destroy(unit, fg_idx);        
        }        
    }


destroy_presels_only:

    if(nof_iterations > 1) {
        for(presel_id = 0; presel_id < _BCM_PETRA_FIELD_TEST_DB_PRESEL_1_NOF_PRESELS; ++presel_id) {
            rv = bcm_field_presel_destroy(unit, presel_id | presel_flags);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
    }

    if(fg) {    
        sal_free(fg);
    }
    
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

STATIC cmd_result_t _bcm_petra_field_test_data_qualifiers_scan(int unit, _bcm_dpp_field_stage_idx_t stage)
{
    bcm_field_data_qualifier_t dq1, dq2, dq_verify;
    bcm_field_qualify_t cur_qualify;
    CONST bcm_field_qset_t *stage_qset;
    bcm_error_t rv;
    cmd_result_t result;
    static CONST char* offset_base_strings[] = BCM_FIELD_DATA_OFFSET_BASE;
    CONST static char* qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
    CONST static char* stages_names[] = BCM_FIELD_STAGE_STRINGS;
    
    uint8 is_not_same_ppd_qual;
    
    bcm_field_data_qualifier_t_init(&dq1);
    /* The first data qualifier - may be in set in case of using the flag BCM_FIELD_DATA_QUALIFIER_REPLACE */
    dq1.qual_id = 0;
    dq1.flags = BCM_FIELD_DATA_QUALIFIER_WITH_ID;
    dq1.offset_base = 0;
    dq1.offset = 0;
    dq1.length = 1;
    rv = bcm_field_data_qualifier_create(unit, &dq1);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

        stage_qset = _bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage); 
    
    for(cur_qualify = 0; cur_qualify < bcmFieldQualifyCount; ++cur_qualify) {
        if(!BCM_FIELD_QSET_TEST(*stage_qset, cur_qualify)) {
            continue;
        }
        
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Qualifier: %s\n"), qualifiers_names[cur_qualify]));
        
        bcm_field_data_qualifier_t_init(&dq2);
        result = _bcm_petra_field_test_fill_data_qualifier_with_qualifier(unit,
                                                                          stage,
                                                                          sal_rand(),
                                                                          cur_qualify,
                                                                          FALSE,
                                                                          &dq2);
        if(result != CMD_OK) {
            bcm_field_data_qualifier_destroy(unit, 0);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
        
        rv = bcm_field_data_qualifier_create(unit, &dq2);
        if(rv != BCM_E_NONE) {
            bcm_field_data_qualifier_destroy(unit, 0);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        /* retrieve */
        dq_verify.flags = dq2.flags;
        rv = bcm_field_data_qualifier_get(unit, dq2.qual_id, &dq_verify);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(dq2.qual_id != dq_verify.qual_id) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in qual_id. set %d, get %d\n"), dq2.qual_id, dq_verify.qual_id));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.offset_base != dq_verify.offset_base) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in offset_base. set %s, get %s\n"),
                                 offset_base_strings[dq2.offset_base], offset_base_strings[dq_verify.offset_base]));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.offset != dq_verify.offset) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in offset. set %d, get %d\n"), dq2.offset, dq_verify.offset));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.length != dq_verify.length) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in length. set %d, get %d\n"), dq2.length, dq_verify.length));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.stage != dq_verify.stage) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in stage. set %s, get %s\n"),
                                 stages_names[dq2.stage], stages_names[dq_verify.stage]));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        
        if(dq2.qualifier != dq_verify.qualifier) {
        /* it may be ok it it is the same ppd qualifier */
            rv = _bcm_petra_field_test_qualify_can_be_both(unit, stage, _BCM_PETRA_FIELD_TYPE_ETHR, dq2.qualifier, dq_verify.qualifier, &is_not_same_ppd_qual);
            
            /* if they can't be both they have the same ppd qual */
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if(is_not_same_ppd_qual) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Retrieving failure in qualifier. set %s, get %s\n"), qualifiers_names[dq2.qualifier], qualifiers_names[dq_verify.qualifier]));
                bcm_field_data_qualifier_destroy(unit, 0);
                bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }             

        if((dq2.flags & BCM_FIELD_DATA_QUALIFIER_REPLACE) == 0) {
            rv = bcm_field_data_qualifier_destroy(unit,  dq2.qual_id);
            if(rv != BCM_E_NONE) {
                bcm_field_data_qualifier_destroy(unit, 0);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    }

    rv = bcm_field_data_qualifier_destroy(unit, 0);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;
}
 
cmd_result_t _bcm_petra_field_test_data_qualifiers(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 rnd;
    uint32 second_rand_param = 0;
    bcm_error_t rv;
    cmd_result_t result;
    bcm_field_qualify_t qualify;
    const bcm_field_qset_t *stage_qset;
    bcm_field_data_qualifier_t dq1, dq2, dq_verify;
    uint8 is_not_same_ppd_qual;
    static const char* offset_base_strings[] = BCM_FIELD_DATA_OFFSET_BASE;
    const static char* qualifiers_names[] = BCM_FIELD_QUALIFY_STRINGS;
    const bcm_field_data_offset_base_t *valid_offset_bases;
    int valid_offset_bases_size;

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of the data qualifiers\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : data_qualifiers, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        return _bcm_petra_field_test_data_qualifiers_scan(unit, stage);
    }

    stage_qset = _bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage);

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        bcm_field_data_qualifier_t_init(&dq1);
        bcm_field_data_qualifier_t_init(&dq2);

        /* The first data qualifier - may be in set in case of using the flag BCM_FIELD_DATA_QUALIFIER_REPLACE */
        dq1.qual_id = 0;
        dq1.flags = BCM_FIELD_DATA_QUALIFIER_WITH_ID;
        dq1.offset_base = 0;
        dq1.offset = 0;
        dq1.length = 1;
        rv = bcm_field_data_qualifier_create(unit, &dq1);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        
        rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
        if(rnd) {
            do
            {
                qualify = _bcm_petra_field_rand_val(x, second_rand_param++) % bcmFieldQualifyCount;
            } while(!BCM_FIELD_QSET_TEST(*stage_qset, qualify));
                                
            result = _bcm_petra_field_test_fill_data_qualifier_with_qualifier(unit,
                                                                              stage,
                                                                              x + second_rand_param++,
                                                                              qualify,
                                                                              FALSE,
                                                                              &dq2);
            if(result != CMD_OK) {
                bcm_field_data_qualifier_destroy(unit, 0);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return result;
            }
        } else {
            /* flags */
            /* flags - with id */
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
            if(rnd) {
                dq2.flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
                dq2.qual_id = (_bcm_petra_field_rand_val(x, second_rand_param++) % 
                    _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit)) + 1;
            }
        
            /* flags - replace */
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
            if(rnd) {
                dq2.flags |= BCM_FIELD_DATA_QUALIFIER_REPLACE;
                dq2.flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
                dq2.qual_id = 0;
            }
        
            /* flags - offset bit resolution */
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
            if(rnd) {
                dq2.flags |= BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES;
            }
        
            /* flags - length bit resolution */
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
            if(rnd) {
                dq2.flags |= BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES;
            }
            
            /* offset base */
            supported_data_offset_base(TRUE, FALSE, &valid_offset_bases, &valid_offset_bases_size);
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % valid_offset_bases_size;
            dq2.offset_base = valid_offset_bases[rnd];
        
            if(dq2.offset_base != bcmFieldDataOffsetBasePacketStart &&
                dq2.offset_base != bcmFieldDataOffsetBaseL2Header) {
                /* we can set the flag BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE */
                rnd = _bcm_petra_field_rand_val(x, second_rand_param++) %2;
                if(rnd) {
                    dq2.flags |= BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE;
                }
            }
            /* offset */
            dq2.offset = _bcm_petra_field_rand_val(x, second_rand_param++) % 
                (_BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_OFFSET(unit) + 1) / 8;
            if(dq2.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) {
                dq2.offset *= 8;
                dq2.offset += 7;
            }

            if((dq2.offset) == 0 && ((dq2.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE) != 0)) {
                dq2.flags &= ~BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE;
            }
                
            /* length */
            dq2.length = _bcm_petra_field_rand_val(x, second_rand_param++) %
                _BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_LENGTH + 1;
            if((dq2.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
                dq2.length /= 8;
                if(dq2.length == 0) {
                    ++dq2.length;
                }
            } else if(dq2.length > 8 && (dq2.length % 8)) {
                dq2.length -= dq2.length % 8;
            }
        }
        
        rv = bcm_field_data_qualifier_create(unit, &dq2);
        if(rv != BCM_E_NONE) {
            bcm_field_data_qualifier_destroy(unit, 0);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        /* retrieve */
        dq_verify.flags = dq2.flags;
        rv = bcm_field_data_qualifier_get(unit, dq2.qual_id, &dq_verify);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if(dq2.qual_id != dq_verify.qual_id) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in qual_id. set %d, get %d\n"), dq2.qual_id, dq_verify.qual_id));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.offset_base != dq_verify.offset_base) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in offset_base. set %s, get %s\n"),
                                 offset_base_strings[dq2.offset_base], offset_base_strings[dq_verify.offset_base]));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.offset != dq_verify.offset) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in offset. set %d, get %d\n"), dq2.offset, dq_verify.offset));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        if(dq2.length != dq_verify.length) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Retrieving failure in length. set %d, get %d\n"), dq2.length, dq_verify.length));
            bcm_field_data_qualifier_destroy(unit, 0);
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }             
        
        if(dq2.qualifier != dq_verify.qualifier) {
        /* it may be ok it it is the same ppd qualifier */
            rv = _bcm_petra_field_test_qualify_can_be_both(unit, stage, 0xffffffff, dq2.qualifier, dq_verify.qualifier, &is_not_same_ppd_qual);
            
            /* if they can't be both they have the same ppd qual */
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if(is_not_same_ppd_qual) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Retrieving failure in qualifier. set %s, get %s\n"), qualifiers_names[dq2.qualifier], qualifiers_names[dq_verify.qualifier]));
                bcm_field_data_qualifier_destroy(unit, 0);
                bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }             

        rv = bcm_field_data_qualifier_destroy(unit, 0);
        if(rv != BCM_E_NONE) {
            bcm_field_data_qualifier_destroy(unit, dq2.qual_id);
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if((dq2.flags & BCM_FIELD_DATA_QUALIFIER_REPLACE) == 0) {
            rv = bcm_field_data_qualifier_destroy(unit,  dq2.qual_id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    }
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;
#ifdef BCM_WARM_BOOT_SUPPORT
fail:
    return CMD_FAIL;
#endif
}

STATIC cmd_result_t _bcm_petra_field_test_create_data_qualifiers(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, uint8 predefined_also, uint8 predefined_only, uint8 is_de_large)
{
    bcm_error_t rv;
    cmd_result_t result;
    uint32 second_rand_param = 0;
    bcm_field_data_qualifier_t *dq = NULL;
    bcm_field_qualify_t qualify;
    uint32 qual_idx, qual_idx2;
    uint32 rnd;
    bcm_field_qualify_t *unselected_qualifiers = NULL;
    uint32 nof_available_qualifiers = 0;
    bcm_field_qualify_t cur_qual;
    const bcm_field_data_offset_base_t *valid_offset_bases;
    int valid_offset_bases_size;
    uint32 sw_length;
    
    if(predefined_also) {
        nof_available_qualifiers = 0;
        for(qualify = 0; qualify < bcmFieldQualifyCount; ++qualify) {
            if(BCM_FIELD_QSET_TEST(*_bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage), qualify)){
                if(is_de_large) {
                    /* remove qualifiers that are not adequate from traffic */
                    if(BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), qualify)) {
                        continue;    
                    }
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), qualify)) {
                        continue;
                    }
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure(), qualify)) {
                        continue;    
                    }
                    /* for these qualifiers it is hard to evaluate them */
                    if(qualify == bcmFieldQualifyDstPort || qualify == bcmFieldQualifySrcPort) {
                        continue;
                    }

                    /* remove qualifier whose length is smaller than 4 */
                    rv = _bcm_petra_field_test_qualify_exposed_length(unit, stage, 0xffffffff, qualify, &sw_length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }

                    if(sw_length < 4) {
                        continue;
                    }
                }                    
                ++nof_available_qualifiers;
            }
        }
        unselected_qualifiers = sal_alloc(sizeof(bcm_field_qualify_t) * nof_available_qualifiers, "_bcm_petra_field_test_create_data_qualifiers.unselected_qualifiers");
        if(!unselected_qualifiers) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Memory allocation failue\n")));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        qual_idx = 0;
        for(qualify = 0; qualify < bcmFieldQualifyCount; ++qualify) {
            if(BCM_FIELD_QSET_TEST(*_bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage), qualify)){
                if(is_de_large) {
                    /* remove qualifiers that are not adequate from traffic */
                    if(BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), qualify)) {
                        continue;    
                    }
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), qualify)) {
                        continue;
                    }
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure(), qualify)) {
                        continue;    
                    }
                    /* for these qualifiers it is hard to evaluate them */
                    if(qualify == bcmFieldQualifyDstPort || qualify == bcmFieldQualifySrcPort) {
                        continue;
                    }

                    /* remove qualifier whose length is smaller than 4 */
                    rv = _bcm_petra_field_test_qualify_exposed_length(unit, stage, 0xffffffff, qualify, &sw_length);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        sal_free(unselected_qualifiers);
                        return CMD_FAIL;
                    }

                    if(sw_length < 4) {
                        continue;
                    }
                }                    
                unselected_qualifiers[qual_idx++] = qualify;
            }
        }
    }
    dq = sal_alloc(sizeof(*dq) * (_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1), "_bcm_petra_field_test_create_data_qualifiers.dq");
    if(!dq) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failue\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        if(predefined_also) {
            sal_free(unselected_qualifiers);
        }
        return CMD_FAIL;
    }

    for(qual_idx = 0; qual_idx <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++qual_idx) {
        bcm_field_data_qualifier_t_init(&dq[qual_idx]);
            
        if(predefined_only ||
            (predefined_also && (_bcm_petra_field_rand_val(x, second_rand_param++) % 2)) ) {
            if(nof_available_qualifiers > 0) {
                rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % nof_available_qualifiers;
                cur_qual = unselected_qualifiers[rnd];
                unselected_qualifiers[rnd] = unselected_qualifiers[--nof_available_qualifiers];
            } else {
                /* take it as default */
                cur_qual = bcmFieldQualifySrcMac;
            }
                
            result = _bcm_petra_field_test_fill_data_qualifier_with_qualifier(unit,
                                                                              stage,
                                                                              x + second_rand_param++,
                                                                              cur_qual,
                                                                              is_de_large,
                                                                              &dq[qual_idx]);
            if(result != CMD_OK) {
                for(qual_idx2 = 0; qual_idx2 <= qual_idx; ++qual_idx2) {
                    bcm_field_data_qualifier_destroy(unit, dq[qual_idx2].qual_id);
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                if(predefined_also) {
                    sal_free(unselected_qualifiers);
                }
                sal_free(dq);
                return CMD_FAIL;
            }
            dq[qual_idx].flags &= ~(BCM_FIELD_DATA_QUALIFIER_REPLACE | BCM_FIELD_DATA_QUALIFIER_WITH_ID);
        } else {
            /* offset base */
            supported_data_offset_base(TRUE, TRUE, &valid_offset_bases, &valid_offset_bases_size);
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % valid_offset_bases_size;
            dq[qual_idx].offset_base = valid_offset_bases[rnd];
        
            /* offset */
            if(dq[qual_idx].offset_base == bcmFieldDataOffsetBaseThirdHeader) {
                dq[qual_idx].flags |= BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE;
                dq[qual_idx].offset = _bcm_petra_field_rand_val(x, second_rand_param++) % 
                    ((_BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_OFFSET(unit) + 1) / 8 - 1) + 1;
            } else {
            dq[qual_idx].offset = _bcm_petra_field_rand_val(x, second_rand_param++) % 
                (_BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_OFFSET(unit) + 1) / 8;
            }
                
            /* length */
            dq[qual_idx].length = _bcm_petra_field_rand_val(x, second_rand_param++) %
                _BCM_PETRA_FIELD_TEST_DATA_QUALIFIER_MAX_LENGTH + 1;
            dq[qual_idx].length /= 8;
            if(dq[qual_idx].length == 0) {
                ++dq[qual_idx].length;
            }
            if(dq[qual_idx].offset_base != bcmFieldDataOffsetBasePacketStart &&
                dq[qual_idx].offset_base != bcmFieldDataOffsetBaseL2Header) {
                rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
                if(rnd) {
                    dq[qual_idx].flags |= BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE;
                }
            }
            /* stage */
            switch(stage) {
                case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS:
                    dq[qual_idx].stage = bcmFieldStageEgress;
                    break;
                case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
                    dq[qual_idx].stage = bcmFieldStageExternal;
                    break;
                default:
                    dq[qual_idx].stage = bcmFieldStageIngress;
                    break;
            }   
        }
        rv = bcm_field_data_qualifier_create(unit, &dq[qual_idx]);
        if(rv != BCM_E_NONE) {
            for(qual_idx2 = 0; qual_idx2 <= qual_idx; ++qual_idx2) {
                bcm_field_data_qualifier_destroy(unit, dq[qual_idx2].qual_id);
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            if(predefined_also) {
                sal_free(unselected_qualifiers);
            }
            sal_free(dq);
            return CMD_FAIL;
        }
    }

    if(predefined_also) {
        sal_free(unselected_qualifiers);
    }
    sal_free(dq);
    return CMD_OK;
}

STATIC cmd_result_t _bcm_petra_field_test_data_qualifiers_entry_and_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 with_traffic, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 entry_idx, entry_idx2;
    uint32 item_idx;
    uint32 qual_id;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint32 priority;
    uint8 does_exist_already;
    cmd_result_t result;
    bcm_error_t rv;
    int priority_verify;
    uint32 nof_entries;

    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    uint32 key_hw_size[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    _bcm_petra_field_test_entry_info_t *entries[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS && with_traffic) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the egress stage!\n")));
        return CMD_FAIL;
    }

    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
        entries[fg_idx] = NULL;
        key_hw_size[fg_idx] = 0;/* just to avoid coverity defect */ 
    }
    
    if(x == 0) {
        if(with_traffic) {
            if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        } else {
            if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    } else {
        nof_iterations = 1;
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Test of entries with data qualifiers\n")));
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        if(!with_traffic) {
            result = _bcm_petra_field_test_field_group_and_entry_scan(unit, stage, FALSE, TRUE, FALSE, TRUE, do_warmboot);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            }
            return result;
        } else {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "This test has no meaning in scan mode\n")));
            return CMD_OK;
        }
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(!with_traffic && iteration_idx >= 100) {
        /* In This test for slow mode we take only 100 iterations, but a lot of entries */
            break;
        }
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
            rv = _bcm_petra_field_test_kbp_set_presels(unit, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* creating data qualifiers */
        result = _bcm_petra_field_test_create_data_qualifiers(unit, stage, x + second_rand_param++, !with_traffic, stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS, FALSE);
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
        
#ifdef BCM_WARM_BOOT_SUPPORT
        /* If external stage, KBP init was not yet performed as there is still
         * more DB configuration to do before locking the device.
         * KBP device should be initialized before warmboot, so incase of external stage,
         * we'll skip this warmboot. */
        if((do_warmboot) && (stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL)) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, TRUE, FALSE, 0, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE, field_groups, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), 0);
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
                BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, 3);

                BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
                /* In order not to take bcmFieldActionExternalValue[0/1]Set
                 * that are not available if the AppType is not L2 only. */
                BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionExternalValue2Set + fg_idx);
            }
        }

        /* Creating the filed groups */
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            rv = _bcm_petra_field_test_get_key_hw_length(unit, field_groups[fg_idx].group, &key_hw_size[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

            if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
            }

            if(with_traffic) {
                nof_entries = 1;
            }
            
            entries[fg_idx] = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t)*nof_entries, "");
            if(!entries[fg_idx]) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Memory allocation failure\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* fill entries */
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx){

                /* entry id*/
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if(is_explicit_id) {
                    do
                    {
                        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                            id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                                %_BCM_PETRA_FIELD_TEST_NOF_EXTERNAL_ENTRY_IDS) + _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                        } else {
                            id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                                %_BCM_PETRA_FIELD_TEST_NOF_INTERNAL_ENTRY_IDS(unit)) + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam);
                        }
                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            uint32 nof_entries_2;
                            nof_entries_2 = (11*1024*key_hw_size[fg_idx2]) / 160;
                            if (nof_entries_2 > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                                nof_entries_2 = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                            }
                            if(with_traffic) {
                                nof_entries_2 = 1;
                            }
                            for(entry_idx2 = 0; entry_idx2 < nof_entries_2 ;++entry_idx2) {
                                if (id == entries[fg_idx2][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                            if (does_exist_already) {
                                break;
                            }
                        }

                        if(!does_exist_already) {
                            for(entry_idx2 = 0; entry_idx2 < entry_idx ; ++entry_idx2) {
                                if (id == entries[fg_idx][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    while(does_exist_already);
                    entries[fg_idx][entry_idx].id = id;
                }

                if(is_explicit_id) {
                    rv = bcm_field_entry_create_id(unit, field_groups[fg_idx].group, entries[fg_idx][entry_idx].id);
                } else {
                    rv = bcm_field_entry_create(unit, field_groups[fg_idx].group, &entries[fg_idx][entry_idx].id);
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                second_rand_param = 0;
                /* priority */
                do
                {
                    priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                       & BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
                    if(priority == 0) {
                        ++priority;
                    }
                    does_exist_already = FALSE;
                    for(entry_idx2 = 0; entry_idx2 < entry_idx ; ++entry_idx2) {
                        if (priority == entries[fg_idx][entry_idx2].priority) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                }
                while(does_exist_already);
                entries[fg_idx][entry_idx].priority = priority;
                rv = bcm_field_entry_prio_set(unit, entries[fg_idx][entry_idx].id, entries[fg_idx][entry_idx].priority);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /*set the data qualifiers */
                result = _bcm_petra_field_test_set_entry_data_qualifiers(unit, stage, &field_groups[fg_idx].qset, with_traffic, x + second_rand_param++, FALSE, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /* actions of the entries */
                result = _bcm_petra_field_test_set_entry_actions(unit, stage, &field_groups[fg_idx].aset, with_traffic, FALSE, FALSE, x + second_rand_param++, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_entry_install(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        if(!with_traffic) {
            /* Existence test */
            for(item_idx = 0; item_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST; ++item_idx) {
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                    id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                        %_BCM_PETRA_FIELD_TEST_NOF_EXTERNAL_ENTRY_IDS) + _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam);
                } else {
                    id = (_bcm_petra_field_rand_val(x, second_rand_param++)
                        %_BCM_PETRA_FIELD_TEST_NOF_INTERNAL_ENTRY_IDS(unit)) + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam);
                }
                does_exist_already = FALSE;

                /* looking for this id */
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                    nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                    if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                        nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                    }
                    for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                        if (entries[fg_idx][entry_idx].id == id) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                    if (does_exist_already) {
                        break;
                    }
                }
                rv = bcm_field_entry_prio_get(unit, id, &priority_verify);

                if(!does_exist_already) {
                    if(rv != BCM_E_NOT_FOUND) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d doen\'t exist and bcm_field_entry_prio_get didn\'t return BCM_E_NOT_FOUND.\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                } else {
                    if(rv != BCM_E_NONE) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d exist and bcm_field_entry_prio_get didn\'t return BCM_E_NONE.\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }

            /* priority qualifiers and actions verification */
            for(item_idx = 0; item_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_ITEMS_TO_TEST; ++item_idx) {
                fg_idx = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %(_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));

                nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                    nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                }
                entry_idx = _bcm_petra_field_rand_val(x, second_rand_param++)%nof_entries;
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &entries[fg_idx][entry_idx], FALSE, FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        } else {
            /* traffic test - we have only 1 entry */
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                result = _bcm_petra_field_test_traffic_test(unit, stage, FALSE, FALSE, FALSE, field_groups[fg_idx].group, &entries[fg_idx][0], 1);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

            if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
            }

            if(with_traffic) {
                nof_entries = 1;
            }
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
            sal_free(entries[fg_idx]);
            entries[fg_idx] = NULL;
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            for(qual_id = 0; qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++qual_id) {
                rv = bcm_field_data_qualifier_destroy(unit, qual_id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return result;
        }
    }

    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            if(entries[fg_idx]) {
                nof_entries = (11*1024*key_hw_size[fg_idx]) / 160;

                if (nof_entries > _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations)) {
                    nof_entries = _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_IN_GROUP(nof_iterations);
                }

                if(with_traffic) {
                    nof_entries = 1;
                }
                for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                    bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                }
            }
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
        for(qual_id = 0; qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++qual_id) {
            bcm_field_data_qualifier_destroy(unit, qual_id);
        }
    }

    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
        if(entries[fg_idx] != NULL) {
            sal_free(entries[fg_idx]);
        }
    }
    
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_data_qualifiers_entry(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    bcm_error_t rv = BCM_E_NONE;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries with data qualifiers\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : data_qualifiers_entry, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_data_qualifiers_entry_and_traffic(unit, stage, x, mode, FALSE, do_warmboot);
    
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
        _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);
    }
    return result;
fail:
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_data_qualifiers_entry_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries with traffic with data qualifiers\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : data_qualifiers_entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_data_qualifiers_entry_and_traffic(unit, stage, x, mode, TRUE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

/* There in no need to test of the predefined data qualifiers without entries traffic - the test of the data qualifiers with entries tests also predefined data qualifiers */
cmd_result_t _bcm_petra_field_test_predefined_data_qualifiers_entry_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    bcm_error_t rv;
    uint32 second_rand_param = 0;
    bcm_field_qset_t valid_qset;
    bcm_field_aset_t valid_aset;
    bcm_field_data_qualifier_t *dq;
    bcm_field_data_qualifier_t tmp_dq;
    bcm_field_qualify_t *unselected_qualifiers;
    uint32 nof_available_qualifiers;
    uint32 iteration_idx;
    uint32 qual_idx, qual_idx2;
    uint32 fg_idx;
    bcm_field_qualify_t cur_qual;
    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    _bcm_petra_field_test_entry_info_t *entries;
    uint32 nof_iterations;
    int type = 0;
    uint32 nof_qualifiers = 0;
    int old_learn_mode; /* Remember the learn mode to be restored in the end of the test */
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of entries with traffic with predefined data qualifiers\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : predefined_data_qualifiers_entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    rv = bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode | BCM_L2_LEARN_DISABLE);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        result = _bcm_petra_field_test_field_group_and_entry_scan(unit, stage, FALSE, TRUE, TRUE, TRUE, do_warmboot);
        if(result == CMD_OK) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "The test finished successfully\n")));
        } else {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        }

        result = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
        return result;
    }

    entries = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t) * _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), "_bcm_petra_field_test_predefined_data_qualifiers_entry_traffic.entries");
    if(!entries) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    dq = sal_alloc(sizeof(bcm_field_data_qualifier_t) * (_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1), "_bcm_petra_field_test_predefined_data_qualifiers_entry_traffic.dq");
    if(!dq) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        sal_free(entries);
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        /* get valid qualifiers */
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
            BCM_FIELD_QSET_INIT(valid_qset);

            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanPri);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanCfi);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanPri);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanCfi);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifySrcMac);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyDstMac);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlan);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyOuterVlanId);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlan);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInnerVlanId);
            BCM_FIELD_QSET_ADD(valid_qset, bcmFieldQualifyInterfaceClassProcessingPort);
        } else {
            type = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_NOF_TYPES;
            if(_bcm_petra_field_test_qualify_and_action_get_valid_set(unit, stage, x, type, &valid_qset, &valid_aset)) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Failed to get valid qset and aset\n")));
                }
                sal_free(dq);
                sal_free(entries);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
    
            _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);
            _bcm_petra_field_test_ip_qual_remove_from_qset(&valid_qset);
        }    
        /* creating data qualifiers */
        nof_available_qualifiers = 0;
        for(cur_qual = 0; cur_qual < bcmFieldQualifyCount; ++cur_qual) {
            if(BCM_FIELD_QSET_TEST(valid_qset, cur_qual)) {
                ++nof_available_qualifiers;
            }
        }
        nof_qualifiers = nof_available_qualifiers;

        unselected_qualifiers = sal_alloc(sizeof(bcm_field_qualify_t) * nof_available_qualifiers, "_bcm_petra_field_test_predefined_data_qualifiers_entry_traffic.unselected_qualifiers");
        if(!unselected_qualifiers) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Memory allocation failure\n")));
            sal_free(dq);
            sal_free(entries);
            return CMD_FAIL;
        }

        qual_idx = 0;
        for(cur_qual = 0; cur_qual < bcmFieldQualifyCount; ++cur_qual) {
            if(BCM_FIELD_QSET_TEST(valid_qset, cur_qual)) {
                unselected_qualifiers[qual_idx++] = cur_qual;
            } 
        }
        
        if(nof_qualifiers > _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1) {
            nof_qualifiers = _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1;
        }

        for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
            bcm_field_data_qualifier_t_init(&dq[qual_idx]);
            
            do{
                if(nof_available_qualifiers > 0) {
                    qual_idx2 = _bcm_petra_field_rand_val(x, second_rand_param++) % nof_available_qualifiers;
                    cur_qual = unselected_qualifiers[qual_idx2];
                    unselected_qualifiers[qual_idx2] = unselected_qualifiers[--nof_available_qualifiers];
                } else {
                    /* take it as default */
                    cur_qual = bcmFieldQualifySrcMac;
                }
            } while(!BCM_FIELD_QSET_TEST(*_bcm_petra_field_test_supported_qualifiers_for_data_qualifier(unit, stage), cur_qual));

            result = _bcm_petra_field_test_fill_data_qualifier_with_qualifier(unit,
                                                                              stage,
                                                                              x + second_rand_param++,
                                                                              cur_qual,
                                                                              FALSE,
                                                                              &dq[qual_idx]);
            if(result != CMD_OK) {
                sal_free(unselected_qualifiers);
                sal_free(dq);
                sal_free(entries);
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return result;
            }
            dq[qual_idx].flags &= ~(BCM_FIELD_DATA_QUALIFIER_REPLACE);
        }
        sal_free(unselected_qualifiers);

        /* we would like to sort the dq array according to the qualifiers */
        for(qual_idx = 1; qual_idx < nof_qualifiers; ++qual_idx) {
            qual_idx2 = qual_idx;
            while(qual_idx2 > 0 && dq[qual_idx2 - 1].qualifier > dq[qual_idx2].qualifier) {
                tmp_dq = dq[qual_idx2];
                dq[qual_idx2] = dq[qual_idx2-1];
                dq[qual_idx2-1] = tmp_dq;
                --qual_idx2;
            }
        }
        
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
            rv = _bcm_petra_field_test_kbp_set_presels(unit, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage));
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */
        for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
            dq[qual_idx].flags |= BCM_FIELD_DATA_QUALIFIER_WITH_ID;
            dq[qual_idx].qual_id = qual_idx;
        
            rv = bcm_field_data_qualifier_create(unit, &dq[qual_idx]);
            if(rv != BCM_E_NONE) {
                for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                    bcm_field_data_qualifier_destroy(unit, dq[qual_idx2].qual_id);
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                sal_free(dq);
                sal_free(entries);
                return CMD_FAIL;
            }
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        /* If external stage, KBP init was not yet performed as there is still
         * more DB configuration to do before locking the device.
         * KBP device should be initialized before warmboot, so incase of external stage,
         * we'll skip this warmboot. */
        if((do_warmboot) && (stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL)) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif

        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                /* qset and aset */
                bcm_field_group_config_t_init(&field_groups[fg_idx]);
                BCM_FIELD_QSET_INIT(field_groups[fg_idx].qset);
                BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyStageEgress);
                for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx){
                    rv = bcm_field_qset_data_qualifier_add(unit, &field_groups[fg_idx].qset, qual_idx);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        sal_free(dq);
                        sal_free(entries);
                        return CMD_FAIL;
                    }
                }
                
                BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
                BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionQosMapIdNew);
            }
        } else {
            result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, TRUE, FALSE, type, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE, field_groups, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), 0);
            if(result != CMD_OK) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "x = %d\n"), x));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                sal_free(dq);
                sal_free(entries);
                return result;
            }
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
                    BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
                    BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, 3);

                    BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
                    /* In order not to take bcmFieldActionExternalValue[0/1]Set
                     * that are not available if the AppType is not L2 only. */
                    BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionExternalValue2Set + fg_idx);
                }
            }
        }
        
        /* Creating the filed groups */
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            /* fill entries */

            /* entry id*/
            rv = bcm_field_entry_create(unit, field_groups[fg_idx].group, &entries[fg_idx].id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* priority */
            entries[fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                & BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
            if(entries[fg_idx].priority == 0) {
                ++entries[fg_idx].priority;
            }
            rv = bcm_field_entry_prio_set(unit, entries[fg_idx].id, entries[fg_idx].priority);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /*set the data qualifiers */
            result = _bcm_petra_field_test_set_entry_data_qualifiers(unit, stage, &field_groups[fg_idx].qset, TRUE, x + second_rand_param++, FALSE, &entries[fg_idx]);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* actions of the entries */
            result = _bcm_petra_field_test_set_entry_actions(unit, stage, &field_groups[fg_idx].aset, TRUE, FALSE, FALSE, x + second_rand_param++, &entries[fg_idx]);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            rv = bcm_field_entry_install(unit, entries[fg_idx].id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            result = _bcm_petra_field_test_traffic_test(unit, stage, TRUE, FALSE, FALSE, field_groups[fg_idx].group, &entries[fg_idx], 1);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            rv = bcm_field_entry_destroy(unit, entries[fg_idx].id);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
                rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
                rv = bcm_field_data_qualifier_destroy(unit, qual_idx);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return result;
        }
    }

    rv = bcm_switch_control_set(0, bcmSwitchL2LearnMode, old_learn_mode);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    sal_free(dq);
    sal_free(entries);
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage); ++fg_idx) {
            bcm_field_entry_destroy(unit, entries[fg_idx].id);
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
        for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
            bcm_field_data_qualifier_destroy(unit, qual_idx);
        }
    }

    sal_free(dq);
    sal_free(entries);
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}


/*
 * This function gets unit and set the valid qset which may be lsb and the valid qset which may be msb according to the type
 */ 
STATIC bcm_error_t _bcm_petra_field_test_set_direct_extraction_qsets(int unit,
                                                                     bcm_field_qset_t *valid_qset_lsb,
                                                                     bcm_field_qset_t *valid_qset_msb,
                                                                     bcm_field_qset_t *valid_qset_lsb_only,
                                                                     bcm_field_qset_t *valid_qset_msb_only)
{
    bcm_dpp_field_info_OLD_t *unitData;
    SOC_PPC_FP_QUAL_TYPE *soc_ppd_qual_ptr;
    bcm_error_t rv;
    bcm_field_qualify_t cur_qualify;
    uint32 type;
    uint8 is_lsb, is_msb;
    bcm_field_qset_t valid_qset_for_type;
    bcm_field_aset_t junk;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(valid_qset_lsb);
    BCMDNX_NULL_CHECK(valid_qset_msb);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    for(type =0; type < _BCM_PETRA_FIELD_NOF_TYPES; ++type) {
        rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, type, &valid_qset_for_type, &junk);
        BCM_IF_ERROR_RETURN(rv);

        _bcm_petra_field_test_ip_qual_remove_from_qset(&valid_qset_for_type);
        _bcm_petra_field_test_qual_remove_from_qset(&valid_qset_for_type);

        BCM_FIELD_QSET_INIT(valid_qset_lsb[type]);
        BCM_FIELD_QSET_INIT(valid_qset_msb[type]);
        BCM_FIELD_QSET_INIT(valid_qset_lsb_only[type]);
        BCM_FIELD_QSET_INIT(valid_qset_msb_only[type]);

        for(cur_qualify = 0; cur_qualify < bcmFieldQualifyCount; ++cur_qualify) {
            uint32 length = 0;
            uint32 exposed;
            uint32 hardware;
            uint32 ppd_qual_idx;

            if(cur_qualify == bcmFieldQualifyL3SrcHostHit || cur_qualify == bcmFieldQualifyIpFrag || cur_qualify == bcmFieldQualifyIpProtocolCommon) {
                continue;
            }

            if(!BCM_FIELD_QSET_TEST(valid_qset_for_type, cur_qualify)) {
                continue;
            }
            rv = _bcm_dpp_ppd_qual_from_bcm_qual(unitData, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, 1<<type, cur_qualify, &soc_ppd_qual_ptr);
            BCM_IF_ERROR_RETURN(rv);
                
            for(ppd_qual_idx = 0; ppd_qual_idx < _BCM_PETRA_FIELD_QUAL_CHAIN; ++ppd_qual_idx) {
                    if((soc_ppd_qual_ptr[ppd_qual_idx] < SOC_PPC_NOF_FP_QUAL_TYPES) && (soc_ppd_qual_ptr[ppd_qual_idx] != BCM_FIELD_ENTRY_INVALID)) {
                    rv = _bcm_dpp_ppd_qual_bits(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, soc_ppd_qual_ptr[ppd_qual_idx], &exposed, &hardware, NULL);
                    BCM_IF_ERROR_RETURN(rv);
                    length += hardware;
                }
            }
            if(length > _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH) {
                /* we don't want long qualifiers */
                continue;
            }

            rv =  _bcm_petra_field_test_qualifier_is_lsb_is_msb(unit, cur_qualify, &is_lsb, &is_msb);
            BCM_IF_ERROR_RETURN(rv);
            
            if(is_lsb && is_msb) {
                BCM_FIELD_QSET_ADD(valid_qset_lsb[type], cur_qualify);
                BCM_FIELD_QSET_ADD(valid_qset_msb[type], cur_qualify);
            }
            else if(is_lsb) {
                BCM_FIELD_QSET_ADD(valid_qset_lsb_only[type], cur_qualify);
            } else if(is_msb) {
                BCM_FIELD_QSET_ADD(valid_qset_msb_only[type], cur_qualify);
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function fills by random values the array of the filed groups
 */
STATIC cmd_result_t _bcm_petra_field_test_fill_field_groups_de(int unit,
                                                              uint32 x,
                                                              bcm_field_group_config_t *field_groups,
                                                              int nof_groups)
{
    uint32 fg_idx, fg_idx2;
    uint32 rnd;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint8 does_exist_already;
    bcm_error_t rv;
    uint8 nof_not_explicit = 0;
    uint32 type;
    uint32 max_qualifiers;
    
    static uint8 is_valid_qsets_set = FALSE;

    /* qualifiers that may be lsb (include qualifiers that may be msb and lsb also */
    static bcm_field_qset_t valid_qset_lsb[_BCM_PETRA_FIELD_NOF_TYPES];

    /* qualifiers that may be msb (include qualifiers that may be msb and lsb also */
    static bcm_field_qset_t valid_qset_msb[_BCM_PETRA_FIELD_NOF_TYPES];
    
    /* qualifiers that must be lsb */
    static bcm_field_qset_t valid_qset_lsb_only[_BCM_PETRA_FIELD_NOF_TYPES];

    /* qualifiers that must */
    static bcm_field_qset_t valid_qset_msb_only[_BCM_PETRA_FIELD_NOF_TYPES];
    bcm_field_qset_t *valid_qset;

    _bcm_petra_field_test_reset_resources();
    for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
        bcm_field_group_config_t_init(&field_groups[fg_idx]);
        /* id */
        if(fg_idx + nof_not_explicit >= nof_groups) {
            /* We want the not implici field groups to be in the end 
               in order that they will not catch the explicit id of the next field groups */
            is_explicit_id = FALSE;
        } else {
            do
            {
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if (!is_explicit_id) {
                    ++nof_not_explicit;
                }
            }
            while(!is_explicit_id && (fg_idx + nof_not_explicit < nof_groups));
        }
        if(is_explicit_id) {
            do
            {
                id = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
                does_exist_already = FALSE;
                for(fg_idx2 = 0; fg_idx2 < fg_idx ; ++fg_idx2) {
                    if (id == field_groups[fg_idx2].group) {
                        does_exist_already = TRUE;
                        break;
                    }
                }
            }
            while(does_exist_already);
            field_groups[fg_idx].group = id;
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
        }
        /* priority */
        do
        {
            field_groups[fg_idx].priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
            does_exist_already = FALSE;
            for(fg_idx2 = 0; fg_idx2 < fg_idx ; ++fg_idx2) {
                if (field_groups[fg_idx].priority == field_groups[fg_idx2].priority) {
                    does_exist_already = TRUE;
                    break;
                }
            }
        }
        while(does_exist_already);

        /* qset */
        if(!is_valid_qsets_set) {
            rv = _bcm_petra_field_test_set_direct_extraction_qsets(unit, valid_qset_lsb, valid_qset_msb, valid_qset_lsb_only, valid_qset_msb_only);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            is_valid_qsets_set = TRUE;
        }
        
        type = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_NOF_TYPES;
        if(SOC_IS_ARADPLUS_AND_BELOW(unit) && ((nof_groups - fg_idx) >= _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAX_LSB_FIELD_GROUPS - fg_idx/2)) {
            /* in this case we have no freedom to chooose msb or lsb randomly - not needed in Jericho, since all the qualifiers are both LSB and MSB */
            valid_qset = (fg_idx % 2) ? &valid_qset_lsb_only[type] : &valid_qset_msb_only[type];
        } else {
            rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
            if(rnd == 0) {
                valid_qset = &valid_qset_lsb[type];
            } else {
                valid_qset = &valid_qset_msb[type];
            }
        }

        BCM_FIELD_QSET_INIT(field_groups[fg_idx].qset);
        if(type == _BCM_PETRA_FIELD_TYPE_IPV4) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyIp4);
        } else if(type == _BCM_PETRA_FIELD_TYPE_IPV6) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyIp6);
        } else if(type == _BCM_PETRA_FIELD_TYPE_MPLS) {
            BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyMpls);
        }   
        BCM_FIELD_QSET_ADD(field_groups[fg_idx].qset, bcmFieldQualifyStageIngress);
        
        if(nof_groups > 1) {
            max_qualifiers = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH / (2*nof_groups) - 1;
        } else {
            max_qualifiers = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH;
        }
        _bcm_petra_field_test_reset_field_group_resources(_BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH);/* all the qualifiers must be either lsb or msb */
        rv =  _bcm_petra_field_create_set_max_length(unit,
                                                    _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                    type,
                                                    &field_groups[fg_idx].qset, 
                                                    (void (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_add,
                                                    (uint8 (*)(void*, uint32)) _bcm_petra_field_test_qualify_set_test,
                                                    _bcm_petra_field_test_qualify_hardware_length_worst,
                                                    _bcm_petra_field_test_qualify_can_be_both,
                                                    _bcm_petra_field_test_take_qualifier,
                                                    bcmFieldQualifyCount,
                                                    valid_qset,
                                                    _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_MAXIMAL_QUALIFIERS_LENGTH,
                                                    max_qualifiers,
                                                    x + second_rand_param++);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        
        /* aset */
        BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
        BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, bcmFieldActionPrioIntNew);
        field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_ASET;
        
        field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_MODE;
        field_groups[fg_idx].mode = bcmFieldGroupModeDirectExtraction;
    }
    return CMD_OK;
}

/*  
 * Assumptions: 
 * 1. each aset in the field group has no more then 4 actions, and the number of the actions in all of the field groups is no nmore then 32 
 * 2. each qset in the field group has no more then 8 qualifiers, and the number of the qualifiers in all of the field groups is no nmore then 24 
 * 3. The maximal priority is 127
 * 4. bcmFieldQualify[inner]{Src/Dst]Ip6 will be removed drom the valid qset
 */
cmd_result_t _bcm_petra_field_test_field_group_direct_extraction(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx;
    uint32 flip;
    uint32 second_rand_param = 0;
    uint32 id;
    uint8 does_exist_already;
    cmd_result_t result;
    bcm_error_t rv;
    bcm_field_qset_t qset_verify;

    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION];

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 1, &nof_iterations)){
            return CMD_FAIL;
        };
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group with direct extraction\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_extraction_field_group, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        result = _bcm_petra_field_test_fill_field_groups_de(unit, x + second_rand_param++, field_groups, _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION);
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        /* Creating the filed groups */
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION; ++fg_idx) {
            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        /* Checking existing ids */
        for(flip = 0; flip < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++flip) {
            id = _bcm_petra_field_rand_val(x, second_rand_param++)
                 %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
            does_exist_already = FALSE;
            for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION; ++fg_idx) {
                if(field_groups[fg_idx].group == id) {
                    does_exist_already = TRUE;
                    break;
                }
            }

            /* Existence */
            rv = bcm_field_group_get(unit, id, &qset_verify);
            if(!does_exist_already) {
                if(rv != BCM_E_NOT_FOUND) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - doen't appear in the list and bcm_field_group_get didn\'t return BCM_E_NOT_FOUND\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                } else {
                    continue;
                }
            } else {
                if(rv != BCM_E_NONE) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - exist in the list but bcm_field_group_get failed\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        /* Taking existing group and check the retrieved attributes */
        result = _bcm_petra_field_field_group_get_and_compare(unit,
                                                              &field_groups[
                                                                  _bcm_petra_field_rand_val(x, second_rand_param++)
                                                                  %_BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION],
                                                              FALSE);

        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        result = CMD_OK;
        for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION; ++fg_idx) {
            rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
        }
    }
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_NOF_GROUPS_DIRECT_EXTRACTION; ++fg_idx) {
        bcm_field_group_destroy(unit, field_groups[fg_idx].group);
    }
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

/* This function fills the entry, allocates the de_fields and fills them */
STATIC cmd_result_t _bcm_petra_field_test_set_entry_de(int unit,
                                                       bcm_field_qset_t *qset,
                                                       uint8 with_traffic,
                                                       uint32 x,
                                                       bcm_field_extraction_action_t *de_action,
                                                       _bcm_petra_field_test_entry_info_t *entry,
                                                       bcm_field_extraction_field_t **de_fields,
                                                       int *nof_fields)
{
    bcm_error_t rv;
    cmd_result_t result;
    uint32 second_rand_param = 0;
    uint32 qual_index;
    bcm_field_qualify_t qualify;
    /* This qualifier will be the selected qualifier for the entry to have match */
    bcm_field_qualify_t qualifier_to_entry = 0;
    uint32 action_idx;
    bcm_field_qset_t cur_key;
    uint32 nof_qualifiers = 0;
    bcm_field_qualify_t *qualifiers = NULL;
    uint32 total_length = 0;
    uint32 de_fields_index = 0, de_field_index2;
    uint32 qualifier_length;
    uint32 action_length;
    uint32 must_be_selected;
    uint32 nof_hw_quals;
    bcm_field_extraction_field_t* de_fields_verification = NULL;
    int count_verify;
    uint32 type;

    type = _BCM_PETRA_FIELD_TYPE_ETHR;
    if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV4;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6)) {
        type = _BCM_PETRA_FIELD_TYPE_IPV6;
    } else if (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls)) {
        type = _BCM_PETRA_FIELD_TYPE_MPLS;
    }

    /* for each qualifier decide if it will be taken */
    qual_index = 0;
    BCM_FIELD_QSET_INIT(cur_key);
    for(qualify = 0; qualify < bcmFieldQualifyCount; ++qualify) {
        if(BCM_FIELD_QSET_TEST(*qset, qualify)) {
            entry->quals_info[qual_index].qualify = qualify;
            entry->quals_info[qual_index].is_undefined = FALSE;
            if(qualify == bcmFieldQualifyIp4 ||
                qualify == bcmFieldQualifyIp6 ||
                qualify == bcmFieldQualifyMpls ||
                qualify == bcmFieldQualifyStageIngress || 
                qualify == bcmFieldQualifyStageEgress) {
                entry->quals_info[qual_index].is_valid = FALSE;
            } else {
                entry->quals_info[qual_index].is_valid = _bcm_petra_field_rand_val(x, second_rand_param++) % 2;
                /* we can't take qualifiers that have 2 hardware qualifiers */
                rv = _bcm_petra_field_test_qualify_get_nof_resorces(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, type, qualify, NULL, &nof_hw_quals);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(nof_hw_quals > 1) {
                    entry->quals_info[qual_index].is_valid = FALSE;
                    continue;
                }
                if(!with_traffic) {
                    /* in case of traffic we will do it latter */
                    ++nof_qualifiers;
                }

                if(BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), qualify)){
                    entry->quals_info[qual_index].is_valid = FALSE;
                    continue;
                }

                if(with_traffic) {
                    if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), qualify)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                        continue;
                    }

                    if(!_bcm_petra_field_test_can_insert_qualifier_traffic(qualify, qset, &cur_key)) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                        continue;
                    }
                }

                if(with_traffic) {
                    ++nof_qualifiers;
                }

                /* This is the criterai that we have not set qualifier.
                   If we set already one we can set another one. */
                if(qualifier_to_entry > 0) {
                    entry->quals_info[qual_index].is_valid = FALSE;
                }

                /* verify that the qualifier's length is no more then 4*/
                if(entry->quals_info[qual_index].is_valid) {
                    rv = _bcm_petra_field_test_qualify_hardware_length(unit,
                                                                       _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                       type,
                                                                       qualify,
                                                                       &qualifier_length,
                                                                       NULL);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(qualifier_length > 4) {
                        entry->quals_info[qual_index].is_valid = FALSE;
                    }
                }

                if(entry->quals_info[qual_index].is_valid) {
                    BCM_FIELD_QSET_ADD(cur_key, qualify);    
                    /* for each valid qualifier get a random value (and mask if needed) and set them in the hardware */
                    result = _bcm_petra_field_test_set_qualifier(unit,
                                                                 _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                 type,
                                                                 qualify,
                                                                 x + second_rand_param++,
                                                                 entry->quals_info[qual_index].data,
                                                                 entry->quals_info[qual_index].mask);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return result;
                    }

                    rv = _bcm_petra_field_test_operate_set_function(unit,
                                                                    _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                    type,
                                                                    entry->id,
                                                                    qualify,
                                                                    entry->quals_info[qual_index].data,
                                                                    entry->quals_info[qual_index].mask);
                    if(rv == BCM_E_UNAVAIL) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_WARN) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "Failure: the qualifier %d is not supported yet\n"), qualify));
                        }
                        entry->quals_info[qual_index].is_valid = FALSE;
                    } else if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }
            if(entry->quals_info[qual_index++].is_valid){
                /* we can set only one qualifier */
                qualifier_to_entry = qualify;
            }
        }
    }
    for(; qual_index < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_index) {
        entry->quals_info[qual_index].qualify = BCM_FIELD_ENTRY_INVALID;/* i.e invalid qualify */
        entry->quals_info[qual_index].is_valid = FALSE;
    }

    /* set the actions to be not valid */
    for(action_idx = 0; action_idx < _BCM_PETRA_FIELD_TEST_MAX_ACTIONS_IN_ENTRY; ++action_idx) {
        entry->actions_info[action_idx].is_valid = FALSE;
    }

    /* getting the qualifiers in qset*/
    qualifiers = sal_alloc(sizeof(bcm_field_qualify_t) * nof_qualifiers, "_bcm_petra_field_test_set_entry_de.qualifiers");
    if(!qualifiers) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    qual_index = 0;
    for(qualify = 0; qualify < bcmFieldQualifyCount; ++qualify) {
        if(BCM_FIELD_QSET_TEST(*qset, qualify)) {
            if(qualify == bcmFieldQualifyIp4 ||
                qualify == bcmFieldQualifyIp6 ||
                qualify == bcmFieldQualifyMpls ||
                qualify == bcmFieldQualifyStageIngress || 
                qualify == bcmFieldQualifyStageEgress) {
                continue;
            }
            /* we can't take qualifiers that have 2 hardware qualifiers */
            rv = _bcm_petra_field_test_qualify_get_nof_resorces(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, type, qualify, NULL, &nof_hw_quals);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            if(nof_hw_quals > 1) {
                continue;
            }

            if(with_traffic && qualify != qualifier_to_entry) {
                if(BCM_FIELD_QSET_TEST(*get_set_get_qual_failure(), qualify)){
                    continue;
                }

                if(BCM_FIELD_QSET_TEST(*get_ingress_traffic_failure_not_scan(), qualify)) {
                    continue;
                }
                /* To avoid problems The _bcm_petra_field_test_can_insert_qualifier_traffic check assumes that the new qualifier is higher than all the previos qualifiers in the set */
                if(qualify < qualifier_to_entry) {
                    continue;
                }
                
                /* for these qualifiers it is hard to evaluate them */
                if(qualify == bcmFieldQualifyDstPort || qualify == bcmFieldQualifySrcPort) {
                    continue;
                }
                
                if(!_bcm_petra_field_test_can_insert_qualifier_traffic(qualify, qset, &cur_key)) {
                    continue;
                }
            }
            BCM_FIELD_QSET_ADD(cur_key, qualify);
            qualifiers[qual_index++] = qualify;
        }
    }
    nof_qualifiers = qual_index;
    
    *de_fields = sal_alloc(sizeof(bcm_field_extraction_field_t) * (2*nof_qualifiers + 1), "_bcm_petra_field_test_set_entry_de.de_fields");
    if(!(*de_fields)) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    rv = _bcm_petra_field_test_action_length(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, de_action->action, &action_length);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    if((nof_qualifiers == 0) || 
       ((total_length < action_length) && (_bcm_petra_field_rand_val(x, second_rand_param++) % 2)) ) {
        /* we will take an constant */
        bcm_field_extraction_field_t_init(&((*de_fields)[de_fields_index]));
        (*de_fields)[de_fields_index].flags = BCM_FIELD_EXTRACTION_FLAG_CONSTANT;
        (*de_fields)[de_fields_index].bits = _bcm_petra_field_rand_val(x, second_rand_param++) % (action_length - total_length) + 1;
        (*de_fields)[de_fields_index].value = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (*de_fields)[de_fields_index].bits);
        total_length += (*de_fields)[de_fields_index].bits;
        ++de_fields_index;
    } else {
        /* in oreder that at least one qualifier will be selected */
        must_be_selected = _bcm_petra_field_rand_val(x, second_rand_param++) % nof_qualifiers;
        for(qual_index = 0; qual_index < nof_qualifiers; ++qual_index) {
            if(_bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
                /* we will take an constant */
                bcm_field_extraction_field_t_init(&((*de_fields)[de_fields_index]));
                (*de_fields)[de_fields_index].flags = BCM_FIELD_EXTRACTION_FLAG_CONSTANT;
                (*de_fields)[de_fields_index].bits = _bcm_petra_field_rand_val(x, second_rand_param++) % (action_length - total_length) + 1;
                (*de_fields)[de_fields_index].value = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (*de_fields)[de_fields_index].bits);
                /* not needed really - just for verification matching */
                (*de_fields)[de_fields_index].qualifier = BCM_FIELD_ENTRY_INVALID;
                total_length += (*de_fields)[de_fields_index].bits;
                ++de_fields_index;
                if(total_length == action_length) {
                    break;
                }
            }
            if((qual_index == must_be_selected) || _bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
                rv = _bcm_petra_field_test_qualify_exposed_length(unit,
                                                                  _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                  type,
                                                                  qualifiers[qual_index],
                                                                  &qualifier_length);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                bcm_field_extraction_field_t_init(&((*de_fields)[de_fields_index]));
                (*de_fields)[de_fields_index].flags = 0;
                (*de_fields)[de_fields_index].lsb = _bcm_petra_field_rand_val(x, second_rand_param++) % qualifier_length;
                /* we will set it first to the maximal available length*/
                if((qualifier_length - (*de_fields)[de_fields_index].lsb) < (action_length - total_length)) {
                    (*de_fields)[de_fields_index].bits = qualifier_length - (*de_fields)[de_fields_index].lsb;
                } else {
                    (*de_fields)[de_fields_index].bits = qualifier_length = action_length - total_length;
                }
                (*de_fields)[de_fields_index].bits = _bcm_petra_field_rand_val(x, second_rand_param++) % ((*de_fields)[de_fields_index].bits) + 1;
                (*de_fields)[de_fields_index].qualifier = qualifiers[qual_index]; 
                total_length += (*de_fields)[de_fields_index].bits;
                ++de_fields_index;
                if(total_length == action_length) {
                    break;
                }
            }
        }
    }

    rv = bcm_field_direct_extraction_action_add(unit,
                                                entry->id,
                                                *de_action,
                                                de_fields_index,
                                                *de_fields);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    *nof_fields = de_fields_index;

    /* verify the getting of the data back */
    de_fields_verification = sal_alloc(sizeof(bcm_field_extraction_field_t) * de_fields_index, "_bcm_petra_field_test_set_entry_de.de_fields_verification");
    if(!de_fields_verification) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }


    rv = bcm_field_direct_extraction_action_get(unit,
                                                entry->id,
                                                de_action,
                                                de_fields_index,
                                                de_fields_verification,
                                                &count_verify);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    if(count_verify != de_fields_index) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "bcm_field_direct_extraction_action_get: count items mismatch: set %d get: %d.\n"), de_fields_index, count_verify));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    for(de_field_index2 = 0; de_field_index2 < de_fields_index; ++de_field_index2) {
        if((*de_fields)[de_field_index2].flags != de_fields_verification[de_field_index2].flags) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: flags mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].flags, de_fields_verification[de_field_index2].flags));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].lsb != de_fields_verification[de_field_index2].lsb) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: lsb mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].lsb, de_fields_verification[de_field_index2].lsb));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].bits != de_fields_verification[de_field_index2].bits) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: bits mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].bits, de_fields_verification[de_field_index2].bits));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].value != de_fields_verification[de_field_index2].value) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: values mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].value, de_fields_verification[de_field_index2].value));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].flags != BCM_FIELD_EXTRACTION_FLAG_CONSTANT) {
            if((*de_fields)[de_field_index2].qualifier != de_fields_verification[de_field_index2].qualifier) {
                uint8 is_not_same_ppd_qual;
                /* it may be ok it it is the same ppd qualifier */
                rv = _bcm_petra_field_test_qualify_can_be_both(unit,
                                                               _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                               type,
                                                               (*de_fields)[de_field_index2].qualifier,
                                                               de_fields_verification[de_field_index2].qualifier,
                                                               &is_not_same_ppd_qual);
            
                /* if they can't be both they have the same ppd qual */
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                if(is_not_same_ppd_qual) {
                    const static char *qual_names[] = BCM_FIELD_QUALIFY_STRINGS;
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "bcm_field_direct_extraction_action_get: qualifier mismatch in index %d:"
                                         " set %s get %s.\n"), de_field_index2, qual_names[(*de_fields)[de_field_index2].qualifier], qual_names[de_fields_verification[de_field_index2].qualifier]));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }
    }

    sal_free(qualifiers);
    sal_free(de_fields_verification);
    return CMD_OK;

fail:
    if(qualifiers) {
        sal_free(qualifiers);
    }

    if(de_fields_verification) {
        sal_free(de_fields_verification);
    }
    return CMD_FAIL;
}

/* This function fills the entry, allocates the de_fields and fills them for large D.E. */
STATIC cmd_result_t _bcm_petra_field_test_set_entry_large_de(int unit,
                                                             bcm_field_qset_t *qset,
                                                             uint32 x,
                                                             bcm_field_extraction_action_t *de_action,
                                                             bcm_field_entry_t entry_id,
                                                             bcm_field_extraction_field_t **de_fields,
                                                             int *nof_fields)
{
    bcm_error_t rv;
    uint32 second_rand_param = 0;
    uint32 qual_index, qual_index2;
    bcm_field_qualify_t *qualifiers = NULL;
    uint32 total_length = 0;
    uint32 de_fields_index = 0, de_field_index2;
    uint32 qualifier_length;
    uint32 action_length;
    uint32 must_be_selected;
    bcm_field_extraction_field_t* de_fields_verification = NULL;
    int count_verify;
    int qual_count;
    bcm_field_data_qualifier_t dq[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1];
    bcm_field_data_qualifier_t tmp_dq;
    int qual_arr[_BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1];
    bcm_field_qset_t fg_predefined_qset;

    rv = bcm_field_qset_data_qualifier_get(unit,
                                           *qset,
                                           _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit) + 1,
                                           qual_arr,
                                           &qual_count);
    if(rv != BCM_E_NONE){
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    BCM_FIELD_QSET_INIT(fg_predefined_qset);
    for(qual_index = 0; qual_index < qual_count; ++qual_index) {
        bcm_field_data_qualifier_t_init(&dq[qual_index]);
        rv = bcm_field_data_qualifier_get(unit, qual_arr[qual_index], &dq[qual_index]);
        if (rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        if((dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) == 0) {
            dq[qual_index].offset *= 8;
        } 
        if((dq[qual_index].flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) == 0) {
            dq[qual_index].length *= 8;
        }
        BCM_FIELD_QSET_ADD(fg_predefined_qset, dq[qual_index].qualifier);
    }

    /* sort them according to the qualifier */
    for(qual_index = 1; qual_index < qual_count; ++qual_index) {
        qual_index2 = qual_index;
        while(qual_index2 > 0 && dq[qual_index2 - 1].qualifier > dq[qual_index2].qualifier) {
            tmp_dq = dq[qual_index2];
            dq[qual_index2] = dq[qual_index2-1];
            dq[qual_index2-1] = tmp_dq;
            --qual_index2;
        }
    }

    /* getting the qualifiers in qset*/
    qualifiers = sal_alloc(sizeof(bcm_field_qualify_t) * qual_count, "_bcm_petra_field_test_set_entry_de.qualifiers");
    if(!qualifiers) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    
    *de_fields = sal_alloc(sizeof(bcm_field_extraction_field_t) * (2*qual_count + 1), "_bcm_petra_field_test_set_entry_de.de_fields");
    if(!(*de_fields)) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    rv = _bcm_petra_field_test_action_length(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, de_action->action, &action_length);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    /* in oreder that at least one qualifier will be selected */
    must_be_selected = _bcm_petra_field_rand_val(x, second_rand_param++) % qual_count;
    for(qual_index = 0; qual_index < qual_count; ++qual_index) {
        if((qual_index == must_be_selected) || _bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
            qualifier_length = dq[qual_index].length;
            bcm_field_extraction_field_t_init(&((*de_fields)[de_fields_index]));
            (*de_fields)[de_fields_index].flags = BCM_FIELD_EXTRACTION_FLAG_DATA_FIELD;
            (*de_fields)[de_fields_index].lsb = 0;
            (*de_fields)[de_fields_index].bits = qualifier_length;
            (*de_fields)[de_fields_index].qualifier = dq[qual_index].qual_id; 
            total_length += (*de_fields)[de_fields_index].bits;
            ++de_fields_index;
            if(total_length == action_length) {
                break;
            }
        }
    }

    rv = bcm_field_direct_extraction_action_add(unit,
                                                entry_id,
                                                *de_action,
                                                de_fields_index,
                                                *de_fields);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    *nof_fields = de_fields_index;

    /* verify the getting of the data back */
    de_fields_verification = sal_alloc(sizeof(bcm_field_extraction_field_t) * de_fields_index, "_bcm_petra_field_test_set_entry_de.de_fields_verification");
    if(!de_fields_verification) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }


    rv = bcm_field_direct_extraction_action_get(unit,
                                                entry_id,
                                                de_action,
                                                de_fields_index,
                                                de_fields_verification,
                                                &count_verify);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    if(count_verify != de_fields_index) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "bcm_field_direct_extraction_action_get: count items mismatch: set %d get: %d.\n"), de_fields_index, count_verify));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    for(de_field_index2 = 0; de_field_index2 < de_fields_index; ++de_field_index2) {
        if((*de_fields)[de_field_index2].flags != de_fields_verification[de_field_index2].flags) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: flags mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].flags, de_fields_verification[de_field_index2].flags));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].lsb != de_fields_verification[de_field_index2].lsb) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: lsb mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].lsb, de_fields_verification[de_field_index2].lsb));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].bits != de_fields_verification[de_field_index2].bits) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: bits mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].bits, de_fields_verification[de_field_index2].bits));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        if((*de_fields)[de_field_index2].value != de_fields_verification[de_field_index2].value) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: values mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].value, de_fields_verification[de_field_index2].value));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        /* Here the qualifier is The data qualifier's id */
        if((*de_fields)[de_field_index2].qualifier != de_fields_verification[de_field_index2].qualifier) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "bcm_field_direct_extraction_action_get: qualifier mismatch in index %d:"
                                 " set %d get %d.\n"), de_field_index2, (*de_fields)[de_field_index2].qualifier, de_fields_verification[de_field_index2].qualifier));
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }

    sal_free(qualifiers);
    sal_free(de_fields_verification);
    return CMD_OK;

fail:
    if(qualifiers) {
        sal_free(qualifiers);
    }

    if(de_fields_verification) {
        sal_free(de_fields_verification);
    }
    return CMD_FAIL;
}

/* translate the de_field from predefined data qualifiers array to regular data qualifiers */
STATIC bcm_error_t _bcm_petra_field_test_de_from_data_qualifiers_to_qualifiers(int unit, bcm_field_extraction_field_t *de_fields, int nof_fields)
{
    uint32 field_idx;
    bcm_error_t rv;
    bcm_field_data_qualifier_t dq;
    
    for(field_idx = 0; field_idx < nof_fields; ++field_idx) {
        de_fields[field_idx].flags = 0;
        rv = bcm_field_data_qualifier_get(unit, de_fields[field_idx].qualifier, &dq);
        if(rv != BCM_E_NONE) {
            return rv;
        }
        if((dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) == 0) {
            dq.offset *= 8;
        } 
        de_fields[field_idx].lsb += dq.offset;
        de_fields[field_idx].qualifier = dq.qualifier;
    }
    
    return BCM_E_NONE;
}

STATIC cmd_result_t _bcm_petra_field_test_de_build_packet(int unit,
                                                          bcm_field_qualify_t * qualifiers,
                                                          uint32 *values,
                                                          uint32 nof_qualifiers,
                                                          uint32 type,
                                                          uint32 *buffer)
{
    uint32 qual_idx, qual_idx2;
    uint32 tmp_buffer[10];    
    _bcm_petra_field_test_ethernet_header_t ethernet_header, inner_ethernet_header;
    _bcm_petra_field_test_ipv4_header_t ipv4_header, inner_ipv4_header;
    uint8 is_ipv4 = (type == _BCM_PETRA_FIELD_TYPE_IPV4);
    _bcm_petra_field_test_ipv6_header_t ipv6_header;
    uint8 is_ipv6 = (type == _BCM_PETRA_FIELD_TYPE_IPV6);
    _bcm_petra_field_test_mpls_header_t mpls_header;
    _bcm_petra_field_test_mpls_header_t mpls_header2, mpls_header3;
    uint8 is_mpls = (type == _BCM_PETRA_FIELD_TYPE_MPLS);
    uint8 nof_mpls = 0;
    soc_port_t port_number;
    
    _bcm_petra_field_test_tcp_header_t tcp_header;
    uint8 has_tcp = FALSE;
    uint8 has_inner_ipv4 = FALSE;/* if we wand ipv4 over ipv4 over ethernet */
    uint8 has_ipv4 = FALSE;/* if we wand ipv4 over ipv6 */
    /* uint8 has_inner_ethernet = FALSE; */
    
    sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
    sal_memset(&inner_ethernet_header, 0x0, sizeof(inner_ethernet_header));
    sal_memset(&ipv4_header, 0x0, sizeof(ipv4_header));
    sal_memset(&inner_ipv4_header, 0x0, sizeof(inner_ipv4_header));
    sal_memset(&ipv6_header, 0x0, sizeof(ipv6_header));
    sal_memset(&mpls_header, 0x0, sizeof(mpls_header));
    sal_memset(&mpls_header2, 0x0, sizeof(mpls_header2));
    sal_memset(&mpls_header3, 0x0, sizeof(mpls_header3));
    sal_memset(&tcp_header, 0x0, sizeof(tcp_header));

    if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
        switch(qualifiers[qual_idx])
        {
            case bcmFieldQualifySrcIp:
                if(!is_ipv4) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                ipv4_header.source_address = values[qual_idx];
                break;
            case bcmFieldQualifyDstIp:
                if(!is_ipv4) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                ipv4_header.destination_address = values[qual_idx];
                break;
            case bcmFieldQualifyIp6FlowLabel:
                if(!is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                ipv6_header.flow_label = values[qual_idx];
                break;
            case bcmFieldQualifyIpProtocol:
            /* also bcmFieldQualifyIp6NextHeader */
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    ipv4_header.protocol = values[qual_idx];
                } else {
                    ipv6_header.next_header = values[qual_idx];
                }
                break;
            case bcmFieldQualifyDSCP:
            /* also bcmFieldQualifyTos
             and bcmFieldQualifyIp6TrafficClass */
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    ipv4_header.dscp = values[qual_idx];
                } else {
                    ipv6_header.traffic_class = values[qual_idx];
                }
                break;
            case bcmFieldQualifyTtl:
            /* also bcmFieldQualifyIp6HopLimit */
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    ipv4_header.time_to_live = values[qual_idx];
                } else {
                    ipv6_header.hop_limit = values[qual_idx];
                }
                break;
            case bcmFieldQualifyEcnValue:
                if(!is_ipv4) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                ipv4_header.ecn = values[qual_idx];
                break;
            case bcmFieldQualifyMplsBos:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header.bos = values[qual_idx];
                if(values[qual_idx] == 1) {
                    /* in this case we should have 3 mpls headers and all of them should have 0 in the Bos */
                    nof_mpls = 3;
                    mpls_header2.bos = 0;
                    mpls_header3.bos = 0;
                }
                break;
            case bcmFieldQualifyMplsLabel1:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                _bcm_petra_field_test_buffer_to_mpls_header(values[qual_idx], &mpls_header);
                break;
            case bcmFieldQualifyMplsLabel1Ttl:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header.time_to_live = values[qual_idx];
                break;
            case bcmFieldQualifyMplsLabel1Bos:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header.bos = values[qual_idx];
                break;
            case bcmFieldQualifyMplsLabel1Exp:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header.exp = values[qual_idx];
                break;
            case bcmFieldQualifyMplsLabel1Id:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header.label = values[qual_idx];
                break;
            case bcmFieldQualifyMplsLabel2:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                _bcm_petra_field_test_buffer_to_mpls_header(values[qual_idx], &mpls_header2);
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                break;
            case bcmFieldQualifyMplsLabel2Ttl:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header2.time_to_live = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                break;
            case bcmFieldQualifyMplsLabel2Bos:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header2.bos = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                break;
            case bcmFieldQualifyMplsLabel2Exp:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header2.exp = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                break;
            case bcmFieldQualifyMplsLabel2Id:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header2.label = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                break;
            case bcmFieldQualifyMplsLabel3:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                _bcm_petra_field_test_buffer_to_mpls_header(values[qual_idx], &mpls_header3);
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                if(nof_mpls < 3) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel2Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header2.bos = 0;
                    nof_mpls = 3;
                }
                break;
            case bcmFieldQualifyMplsLabel3Ttl:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header3.time_to_live = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                if(nof_mpls < 3) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel2Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header2.bos = 0;
                    nof_mpls = 3;
                }
                break;
            case bcmFieldQualifyMplsLabel3Bos:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header3.bos = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                if(nof_mpls < 3) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel2Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header2.bos = 0;
                    nof_mpls = 3;
                }
                break;
            case bcmFieldQualifyMplsLabel3Exp:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header3.exp = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                if(nof_mpls < 3) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel2Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header2.bos = 0;
                    nof_mpls = 3;
                }
                break;
            case bcmFieldQualifyMplsLabel3Id:
                if(!is_mpls) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                mpls_header3.label = values[qual_idx];
                if(nof_mpls < 2) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel1Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header.bos = 0;
                    nof_mpls = 2;
                }
                if(nof_mpls < 3) {
                    for(qual_idx2 = 0; qual_idx2 < qual_idx; ++qual_idx2) {
                        if(qualifiers[qual_idx2] == bcmFieldQualifyMplsLabel2Bos) {
                            values[qual_idx2] = 0;
                        }
                    }
                    mpls_header2.bos = 0;
                    nof_mpls = 3;
                }
                break;
            case bcmFieldQualifyInnerVlan:
                if(ethernet_header.nof_vlans < 2){
                    ethernet_header.nof_vlans = 2;
                }
                ethernet_header.vlans[1].vlan_id = values[qual_idx] & 0xfff;
                ethernet_header.vlans[1].cfi = (values[qual_idx] >> 12) & 0x1;
                ethernet_header.vlans[1].pri = (values[qual_idx] >> 13) & 0x7;
                ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                break;
            case bcmFieldQualifyInnerVlanId:
                if(ethernet_header.nof_vlans < 2){
                    ethernet_header.nof_vlans = 2;
                }
                ethernet_header.vlans[1].vlan_id = values[qual_idx];
                ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                break;
            case bcmFieldQualifyInnerVlanPri:
                if(ethernet_header.nof_vlans < 2){
                    ethernet_header.nof_vlans = 2;
                }
                ethernet_header.vlans[1].pri = values[qual_idx];
                ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                break;
            case bcmFieldQualifyInnerVlanCfi:
                if(ethernet_header.nof_vlans < 2){
                    ethernet_header.nof_vlans = 2;
                }
                ethernet_header.vlans[1].cfi = values[qual_idx];
                ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                break;
            case bcmFieldQualifyInnerTpid:
                if(ethernet_header.nof_vlans < 2){
                    ethernet_header.nof_vlans = 2;
                }
                values[qual_idx] = 0x8100;
                ethernet_header.vlans[1].tag_protocol_id = 0x8100;
                ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                break;
            case bcmFieldQualifyOuterVlan:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                ethernet_header.vlans[0].vlan_id = values[qual_idx] & 0xfff;
                ethernet_header.vlans[0].cfi = (values[qual_idx] >> 12) & 0x1;
                ethernet_header.vlans[0].pri = (values[qual_idx] >> 13) & 0x7;
                break;
            case bcmFieldQualifyOuterVlanId:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                ethernet_header.vlans[0].vlan_id = values[qual_idx];
                break;
            case bcmFieldQualifyForwardingVlanId:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                ethernet_header.vlans[0].vlan_id = 0x1;
                values[qual_idx] = 0x1;
                break;
            case bcmFieldQualifyOuterVlanPri:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                ethernet_header.vlans[0].pri = values[qual_idx];
                break;
            case bcmFieldQualifyOuterVlanCfi:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                ethernet_header.vlans[0].cfi = values[qual_idx];
                break;
            case bcmFieldQualifyOuterTpid:
                if(ethernet_header.nof_vlans < 1){
                    ethernet_header.nof_vlans = 1;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                }
                if(ethernet_header.nof_vlans == 1) {
                    values[qual_idx] = 0x8100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x8100;
                } else if(ethernet_header.nof_vlans == 2) {
                    values[qual_idx] = 0x9100;
                    ethernet_header.vlans[0].tag_protocol_id = 0x9100;
                }
                break;
            case bcmFieldQualifyEtherType:
                ethernet_header.ethertype = values[qual_idx];
                if (ethernet_header.ethertype == 0x8100
                    || ethernet_header.ethertype == 0x88a8
                    || ethernet_header.ethertype == 0x9100
                    || ethernet_header.ethertype == 0x9200
                    || ethernet_header.ethertype == 0x9300
                    || ethernet_header.ethertype < 0x5dd) {
                    values[qual_idx] = 0x5dd;
                    ethernet_header.ethertype = values[qual_idx];
                }
                if(is_ipv4) {
                    values[qual_idx] = 0x800;
                } else if (is_ipv6) {
                    values[qual_idx] = 0x86dd;
                } else if (is_mpls) {
                    values[qual_idx] = 0x8847;
                }
                break;
            case bcmFieldQualifyTcpControl:
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                has_tcp = TRUE;
                tcp_header.control = values[qual_idx];
                break;
            case bcmFieldQualifyL4SrcPort:
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                has_tcp = TRUE;
                tcp_header.source_port = values[qual_idx];
                break;
            case bcmFieldQualifyL4DstPort:
                if(!is_ipv4 && !is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                has_tcp = TRUE;
                tcp_header.destination_port = values[qual_idx];
                break;
            case bcmFieldQualifyInnerSrcIp:
                if(!is_ipv4) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                inner_ipv4_header.source_address = values[qual_idx];
                has_inner_ipv4 = TRUE;
                ipv4_header.protocol = 4;
                break;
            case bcmFieldQualifyInnerDstIp:
                if(!is_ipv4) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                inner_ipv4_header.destination_address = values[qual_idx];
                has_inner_ipv4 = TRUE;
                ipv4_header.protocol = 4;
                break;
            case bcmFieldQualifyInnerTtl:
            /* also bcmFieldQualifyInnerIp6HopLimit */
                if(!is_ipv4 && ! is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    inner_ipv4_header.time_to_live = values[qual_idx];
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                } else {
                    ipv6_header.hop_limit = values[qual_idx];
                    has_ipv4 = TRUE;
                    ipv4_header.protocol = 0x29;
                } 
                break;
            case bcmFieldQualifyInnerIpProtocol:
            /* also bcmFieldQualifyInnerIp6NextHeader */
                if(!is_ipv4 && ! is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    inner_ipv4_header.protocol = values[qual_idx];
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                } else {
                    ipv6_header.next_header = values[qual_idx];
                    has_ipv4 = TRUE;
                    ipv4_header.protocol = 0x29;
                } 
                break;
            case bcmFieldQualifyInnerTos:
            /* also bcmFieldQualifyInnerDSCP
                and bcmFieldQualifyInnerIp6TrafficClass */
                if(!is_ipv4 && ! is_ipv6) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                if(is_ipv4) {
                    inner_ipv4_header.dscp = values[qual_idx];
                    has_inner_ipv4 = TRUE;
                    ipv4_header.protocol = 4;
                } else {
                    ipv6_header.traffic_class = values[qual_idx];
                    has_ipv4 = TRUE;
                    ipv4_header.protocol = 0x29;
                } 
                break;
            case bcmFieldQualifyInterfaceClassProcessingPort:
                if(bcm_port_class_set(unit,
                                      port_number,
                                      bcmPortClassFieldIngressPacketProcessing,
                                      values[qual_idx]) != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
                }
                break;
            case bcmFieldQualifyInterfaceClassPort:
                if(bcm_port_class_set(unit,
                                      port_number,
                                      bcmPortClassFieldIngress,
                                      values[qual_idx]) != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
                break;
            default:
                break;/* do nothing */
        }
    }

    sal_memset(buffer, 0xa5, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
    /* The headers will override part of the payload latter */

    mac_to_buffer(ethernet_header.destination_address, tmp_buffer);
    if(tmp_buffer[0] == 0 && (tmp_buffer[1] & 0xffff) == 0) {
        /* we want that s.a != 0 */
        tmp_buffer[0] = 0x1;
        buffer_to_mac(tmp_buffer, &ethernet_header.destination_address);
    }

    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(is_ipv4){
        ipv4_header.version = 4;
        ipv4_header.internet_header_length = 0x5;
        ipv4_header.total_length = 0x24;
        ethernet_header.ethertype = 0x800;

        if(has_inner_ipv4) {
            inner_ipv4_header.version = 4;
            inner_ipv4_header.internet_header_length = 0x5;
            inner_ipv4_header.total_length = 0x24;
            if(_bcm_petra_field_test_ipv4_header_to_buffer(&inner_ipv4_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        
        if(has_tcp) {
            if(has_inner_ipv4) {
                inner_ipv4_header.protocol = 6;
            } else {
                ipv4_header.protocol = 6;
            }
            if(_bcm_petra_field_test_tcp_header_to_buffer(&tcp_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160
                    - 160*has_inner_ipv4
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        
        if(_bcm_petra_field_test_ipv4_header_to_buffer(&ipv4_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 160,
            tmp_buffer,
            0,
            160);
    } else if(is_ipv6) {
        ipv6_header.version = 6;
        ipv6_header.payload_length = _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - 40 - 14 - 4 * ethernet_header.nof_vlans; 
        ethernet_header.ethertype = 0x86dd;
        if(has_ipv4) {
            ipv4_header.version = 4;
            ipv4_header.internet_header_length = 0x5;
            ipv4_header.total_length = 0x24;
            ethernet_header.ethertype = 0x800;
            if(_bcm_petra_field_test_ipv4_header_to_buffer(&ipv4_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 160,
                tmp_buffer,
                0,
                160);
        }

        if(has_tcp) {
            ipv6_header.next_header = 6;
            if(_bcm_petra_field_test_tcp_header_to_buffer(&tcp_header, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 320
                    - 160*has_ipv4
                    - 160,
                tmp_buffer,
                0,
                160);
        }
        if(_bcm_petra_field_test_ipv6_header_to_buffer(&ipv6_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 320
                - 160*has_ipv4,
            tmp_buffer,
            0,
            320);
    } else if(is_mpls) {
        ethernet_header.ethertype = 0x8847;
        if(nof_mpls == 3) {
            if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header3, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 32 * 3,
                tmp_buffer,
                0,
                32);
        }
        if(nof_mpls >= 2) {
            if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header2, tmp_buffer)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SHR_BITCOPY_RANGE(
                buffer,
                _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                    (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                    - 32 * 2,
                tmp_buffer,
                0,
                32);
        }
        if(_bcm_petra_field_test_mpls_header_to_buffer(&mpls_header, tmp_buffer)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
        SHR_BITCOPY_RANGE(
            buffer,
            _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
                (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */
                - 32,
            tmp_buffer,
            0,
            32);
    }
    sal_memset(tmp_buffer, 0x0, sizeof(tmp_buffer));
    if(_bcm_petra_field_test_ethernet_header_to_buffer(&ethernet_header, tmp_buffer)) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    SHR_BITCOPY_RANGE(
        buffer,
        _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 -
            (112 + 32*ethernet_header.nof_vlans) /* ethernet header length */,
        tmp_buffer,
        0,
        112 + 32*ethernet_header.nof_vlans);
    
    return CMD_OK;
}

STATIC cmd_result_t _bcm_petra_field_test_de_traffic_test(int unit,
                                                          uint32 x,
                                                          bcm_field_extraction_action_t *de_action,
                                                          _bcm_petra_field_test_entry_info_t *entry,
                                                          bcm_field_extraction_field_t *de_fields,
                                                          int nof_fields)
{
    bcm_field_qualify_t *qualifiers = NULL;
    uint32 *values = NULL;
    int expected_value = 0;
    soc_port_t port_number = 0;
    uint32 shift = 0;
    uint32 second_rand_param = 0;
    uint32 nof_qualifiers = 0;
    uint32 qual_idx;
    uint32 field_idx;
    uint32 type = _BCM_PETRA_FIELD_TYPE_ETHR;
    uint32 *buffer = NULL;
    cmd_result_t result;
    uint32 de_val;
    uint8 to_continue;
    SOC_PPC_FP_PACKET_DIAG_INFO* info;

    buffer = sal_alloc(_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit), "_bcm_petra_field_test_de_traffic_test.buffer");
    if(!buffer) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    qualifiers = sal_alloc(sizeof(bcm_field_qualify_t)* nof_fields, "_bcm_petra_field_test_de_traffic_test.qualifiers");
    if(!qualifiers) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    values = sal_alloc(sizeof(uint32)* nof_fields, "_bcm_petra_field_test_de_traffic_test.values");
    if(!values) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    /* setting the value of the qualifier of the entry */
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].is_valid) {
            qualifiers[nof_qualifiers] = entry->quals_info[qual_idx].qualify;
            values[nof_qualifiers] = entry->quals_info[qual_idx].data[0];
            ++nof_qualifiers;

            /* we may have not more then 1*/
        }
    }

    /* determining the type */
    for(qual_idx = 0; qual_idx < _BCM_PETRA_FIELD_TEST_MAX_QUALIFIERS_IN_ENTRY; ++qual_idx) {
        if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp4) {
            type = _BCM_PETRA_FIELD_TYPE_IPV4;
            break;
        } else if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyIp6) {
            type = _BCM_PETRA_FIELD_TYPE_IPV6;
            break;
        } else if(entry->quals_info[qual_idx].qualify == bcmFieldQualifyMpls) {
            type = _BCM_PETRA_FIELD_TYPE_MPLS;
            break;
        }
    }

    /* setting the other qualifiers randomly */
    for(field_idx = 0; field_idx < nof_fields; ++field_idx) {
        if(de_fields[field_idx].flags == 0) {
            to_continue = FALSE;
            for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx){
                if(de_fields[field_idx].qualifier == qualifiers[qual_idx]) {
                    to_continue = TRUE;
                    break;
                }
            }
            if(to_continue) {
                continue;
            }
            qualifiers[nof_qualifiers] = de_fields[field_idx].qualifier;
            if(de_fields[field_idx].qualifier == bcmFieldQualifyInPort) {
                /* In this case the value may be 1*/
                values[nof_qualifiers] = 1;
            } else {
                values[nof_qualifiers] = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << de_fields[field_idx].bits);
                values[nof_qualifiers] <<= de_fields[field_idx].lsb;
            }
            ++nof_qualifiers;
        }
    }

    result = _bcm_petra_field_test_de_build_packet(unit, qualifiers, values, nof_qualifiers, type, buffer);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }

    /* setting the expected value */
    for(field_idx = 0; field_idx < nof_fields; ++field_idx) {
        if(de_fields[field_idx].flags == 0) {
            for(qual_idx = 0; qual_idx < nof_qualifiers; ++qual_idx) {
                if(qualifiers[qual_idx] == de_fields[field_idx].qualifier) {
                    de_val = (values[qual_idx] >> de_fields[field_idx].lsb);
                    /* mask the unrelevant bits */
                    if(de_fields[field_idx].bits < 32) {
                        de_val &= (1 << de_fields[field_idx].bits) - 1;
                    }
                    expected_value |= de_val << shift;
                    shift += de_fields[field_idx].bits;
                }
            }
        } else {
            expected_value |= de_fields[field_idx].value << shift;
            shift += de_fields[field_idx].bits;
        }
    }
    expected_value += de_action->bias;

    if ( get_vaild_local_port(unit,&port_number) != SOC_E_NONE ) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
    result = _bcm_petra_field_send_packet_and_get_information(unit, buffer, port_number, 1, &info);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto fail;
    }
#ifndef PLISIM
    {
        SOC_PPC_FP_ACTION_TYPE ppd_action;
        bcm_error_t rv;

        rv = _bcm_petra_field_test_actions_to_ppd_actions(unit,
                                                          _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                          &de_action->action,
                                                          1,
                                                          &ppd_action);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        if(!actions_verification(info, &ppd_action, 1, &expected_value, TRUE)) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    }
#endif
    sal_free(qualifiers);
    sal_free(values);
    sal_free(buffer);

    return CMD_OK;

fail:
    if(qualifiers) {
        sal_free(qualifiers);
    }
    if(values) {
        sal_free(values);
    }
    if(buffer) {
        sal_free(buffer);
    }

    return CMD_FAIL;
}
/* The test for entries for direct extraction field group
 * it create field groups. Then fill's random entries and retrieves and compare some of them chosen randomly.
 * If we have traffic only one entry is created, and according to the entry calls to the traffic test. */
STATIC cmd_result_t _bcm_petra_field_test_de_entry_and_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 with_traffic, uint32 nof_fgs, uint8 is_large, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 entry_idx, entry_idx2;
    bcm_field_action_t action;
    uint32 second_rand_param = 0;
    uint8 is_explicit_id;
    uint32 id;
    uint32 priority;
    uint8 does_exist_already;
    cmd_result_t result;
    bcm_error_t rv;
    int priority_verify;
    uint32 nof_entries;
    bcm_field_extraction_action_t de_action;
    bcm_field_extraction_field_t *de_fields[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    int nof_fields[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    uint32 qual_id;

    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];
    _bcm_petra_field_test_entry_info_t *entries[_BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX];

    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        entries[fg_idx] = NULL;
        de_fields[fg_idx] = NULL;
    }
    
    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations ; ++iteration_idx) {
        if(!with_traffic && iteration_idx >= 100) {
        /* In This test for slow mode we take only 100 iterations, but a lot of entries */
        /* nof_iterations can be more then 100 */
        /* coverity[dead_error_line:FALSE] */
            break;
        }
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        if(!is_large) {
            result = _bcm_petra_field_test_fill_field_groups_de(unit, x + second_rand_param++, field_groups, nof_fgs);

            if(result != CMD_OK) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "x = %d\n"), x));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return result;
            }
        } else {
            result = _bcm_petra_field_test_create_data_qualifiers(unit,
                                                                  _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                                  x + second_rand_param++,
                                                                 TRUE,
                                                                 TRUE,
                                                                 TRUE);
            if(result != CMD_OK) {
                if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "x = %d\n"), x));
                }
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return result;
            }

#ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
#endif

            result = _bcm_petra_field_test_fill_field_groups(unit,
                                                             _BCM_DPP_FIELD_STAGE_INDEX_INGRESS,
                                                             x + second_rand_param++,
                                                             TRUE,
                                                             TRUE,
                                                             0,
                                                             _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE,
                                                             field_groups,
                                                             nof_fgs,
                                                             0);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_data_qualifiers_only;
            }
        }
        
        /* Creating the filed groups */
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_fg_only;
            }

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_fg_only;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

        bcm_field_extraction_action_t_init(&de_action);
        for(action = 0; action < bcmFieldActionCount; ++action) {
            if(BCM_FIELD_ASET_TEST(field_groups[0].aset, action)) {
                de_action.action = action;/* we take the first action in the aset always*/
            }
        }
        if(!is_large) {
            de_action.bias = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
        } else {
            de_action.bias = 0;
        }

        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP;

            if(with_traffic) {
                nof_entries = 1;
            }
            
            entries[fg_idx] = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t)*nof_entries, "");
            if(!entries[fg_idx]) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Memory allocation failure\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }

            /* fill entries */
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx){

                sal_memset(&entries[fg_idx][entry_idx], 0x0, sizeof(entries[fg_idx][entry_idx]));
                /* entry id*/
                is_explicit_id = _bcm_petra_field_rand_val(x, second_rand_param++)%2;
                if(is_explicit_id) {
                    do
                    {
                        id = _bcm_petra_field_rand_val(x, second_rand_param++)
                            %_BCM_PETRA_FIELD_TEST_MAX_ENTRIES_DIRECT_EXTRACTION + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
                        does_exist_already = FALSE;
                        for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                            uint32 nof_entries_2;
                            nof_entries_2 = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP;
                            if(with_traffic) {
                                nof_entries_2 = 1;
                            }
                            for(entry_idx2 = 0; entry_idx2 < nof_entries_2 ;++entry_idx2) {
                                if (id == entries[fg_idx2][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                            if (does_exist_already) {
                                break;
                            }
                        }

                        if(!does_exist_already) {
                            for(entry_idx2 = 0; entry_idx2 < entry_idx ; ++entry_idx2) {
                                if (id == entries[fg_idx][entry_idx2].id) {
                                    does_exist_already = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    while(does_exist_already);
                    entries[fg_idx][entry_idx].id = id;
                }

                if(is_explicit_id) {
                    rv = bcm_field_entry_create_id(unit, field_groups[fg_idx].group, entries[fg_idx][entry_idx].id);
                } else {
                    rv = bcm_field_entry_create(unit, field_groups[fg_idx].group, &entries[fg_idx][entry_idx].id);
                }
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                second_rand_param = 0;
                /* priority */
                do
                {
                    priority = _bcm_petra_field_rand_val(x, second_rand_param++) &
                        BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
                    if(priority == 0) {
                        ++priority;
                    }
                    does_exist_already = FALSE;
                    for(entry_idx2=0; entry_idx2 < entry_idx ; ++entry_idx2) {
                        if (priority == entries[fg_idx][entry_idx2].priority) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                }
                while(does_exist_already);
                entries[fg_idx][entry_idx].priority = priority;
                rv = bcm_field_entry_prio_set(unit, entries[fg_idx][entry_idx].id, entries[fg_idx][entry_idx].priority);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /* set the qualifiers and actions */
                if(is_large) {
                    /* we should also determine the type in the entry */
                    if(BCM_FIELD_QSET_TEST(field_groups[fg_idx].qset, bcmFieldQualifyIp6)) {
                        entries[fg_idx][entry_idx].quals_info[0].qualify = bcmFieldQualifyIp6;
                        entries[fg_idx][entry_idx].quals_info[0].is_valid = FALSE;
                    } else if(BCM_FIELD_QSET_TEST(field_groups[fg_idx].qset, bcmFieldQualifyIp4)) {
                        entries[fg_idx][entry_idx].quals_info[0].qualify = bcmFieldQualifyIp4;
                        entries[fg_idx][entry_idx].quals_info[0].is_valid = FALSE;
                    } else if(BCM_FIELD_QSET_TEST(field_groups[fg_idx].qset, bcmFieldQualifyMpls)) {
                        entries[fg_idx][entry_idx].quals_info[0].qualify = bcmFieldQualifyMpls;
                        entries[fg_idx][entry_idx].quals_info[0].is_valid = FALSE;
                    }
                    result = _bcm_petra_field_test_set_entry_large_de(unit, &field_groups[fg_idx].qset, x + second_rand_param++, &de_action, entries[fg_idx][entry_idx].id, &de_fields[fg_idx], &nof_fields[fg_idx]);
                } else {
                    result = _bcm_petra_field_test_set_entry_de(unit, &field_groups[fg_idx].qset, with_traffic, x + second_rand_param++, &de_action, &entries[fg_idx][entry_idx], &de_fields[fg_idx], &nof_fields[fg_idx]);
                }
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                rv = bcm_field_entry_install(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        if(!with_traffic) {
            /* Existence test */
            for(entry_idx = 0; entry_idx < _BCM_PETRA_FIELD_TEST_MAX_ENTRIES_DIRECT_EXTRACTION; ++entry_idx) {
                id = entry_idx + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
                does_exist_already = FALSE;

                /* looking for this id */
                for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                    nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP;

                    for(entry_idx2 = 0; entry_idx2 < nof_entries; ++entry_idx2) {
                        if (entries[fg_idx][entry_idx2].id == id) {
                            does_exist_already = TRUE;
                            break;
                        }
                    }
                    if (does_exist_already) {
                        break;
                    }
                }
                rv = bcm_field_entry_prio_get(unit, id, &priority_verify);

                if(!does_exist_already) {
                    if(rv != BCM_E_NOT_FOUND) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d doen\'t exist and bcm_field_entry_prio_get didn\'t return BCM_E_NOT_FOUND.\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                } else {
                    if(rv != BCM_E_NONE) {
                        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                            LOG_INFO(BSL_LS_BCM_FP,
                                     (BSL_META_U(unit,
                                                 "entry %d exist and bcm_field_entry_prio_get didn\'t return BCM_E_NONE.\n"), id));
                        }
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }

            /* priority qualifiers and actions verification */
            for(entry_idx = 0; entry_idx < _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP; ++entry_idx) {
                fg_idx = _bcm_petra_field_rand_val(x, second_rand_param++)
                    %nof_fgs;

                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit, stage, &entries[fg_idx][entry_idx], FALSE, FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        } else {
            /* traffic test - we have only 1 entry */
            for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                /* test only hit success */
                if(!is_large) {
                    result = _bcm_petra_field_test_traffic_test(unit, stage, FALSE, TRUE, FALSE, field_groups[fg_idx].group, &entries[fg_idx][0], 1);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }

                if(is_large) {
                    rv = _bcm_petra_field_test_de_from_data_qualifiers_to_qualifiers(unit, de_fields[fg_idx], nof_fields[fg_idx]);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }

                result = _bcm_petra_field_test_de_traffic_test(unit, x + second_rand_param++, &de_action, &entries[fg_idx][0], de_fields[fg_idx], nof_fields[fg_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP;

            if(with_traffic) {
                nof_entries = 1;
            }
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
            sal_free(entries[fg_idx]);
            entries[fg_idx] = NULL;
            rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            sal_free(de_fields[fg_idx]);
            de_fields[fg_idx] = NULL;
        }

        if(is_large) {
            for(qual_id = 0; qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++qual_id) {
                rv = bcm_field_data_qualifier_destroy(unit, qual_id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return result;
        }
    }

    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            if(entries[fg_idx]) {
                nof_entries = _BCM_PETRA_FIELD_TEST_DIRECT_EXTRACTION_NOF_ENTRIES_IN_GROUP;

                if(with_traffic) {
                    nof_entries = 1;
                }
                for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                    bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                }
            }
        }
    }

    for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
        if(entries[fg_idx] != NULL) {
            sal_free(entries[fg_idx]);
        }
        if(de_fields[fg_idx]) {
            sal_free(de_fields[fg_idx]);
        }
    }

destroy_fg_only:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
    }

destroy_data_qualifiers_only:
    if(is_large) {
        for(qual_id = 0; qual_id <= _BCM_PETRA_FIELD_TEST_MAX_DATA_QUALIFIER_ID(unit); ++qual_id) {
            bcm_field_data_qualifier_destroy(unit, qual_id);
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_de_entry(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of direct extractions with entries\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_extraction_entry, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_de_entry_and_traffic(unit, stage, x, mode, FALSE, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), FALSE, do_warmboot);
    
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

cmd_result_t _bcm_petra_field_test_de_entry_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of direct extractions entries with traffic \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_extraction_entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_de_entry_and_traffic(unit, stage, x, mode, TRUE, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID(stage), FALSE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

cmd_result_t _bcm_petra_field_test_de_entry_traffic_large(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of large direct extractions entries with traffic \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_extraction_entry_traffic_large, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_de_entry_and_traffic(unit, stage, x, mode, TRUE, _BCM_PETRA_FIELD_TEST_ENTRY_NOF_GROUPS_ID_MAX, TRUE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

/*  
 * Assumptions: 
 * 1. each aset in the field group has no more then 4 actions, and the number of the actions in all of the field groups is no more than 32
 * 2. The maximal priority is 127
 */
cmd_result_t _bcm_petra_field_test_field_group_direct_table(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx;
    uint32 flip;
    uint32 second_rand_param = 0;
    uint32 id;
    uint8 does_exist_already;
    cmd_result_t result;
    bcm_error_t rv;
    bcm_field_qset_t qset_verify;

    bcm_field_group_config_t *field_groups;
    uint32 key_length;
    int stage_value = 0;
    int presel_flags = 0;
	
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 3, &nof_iterations)){
            return CMD_FAIL;
        };
    } else {
        nof_iterations = 1;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test of add and remove field group with direct table\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_table_field_group, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        result =  _bcm_petra_field_test_field_group_and_entry_scan(unit, stage, TRUE, FALSE, FALSE, FALSE, do_warmboot);
        if(result == CMD_OK) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "The test finished successfully\n")));
        }
        return result;
    }

    field_groups = sal_alloc(sizeof(bcm_field_group_config_t) * SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks), "_bcm_petra_field_test_field_group_direct_table.field_groups");
    if(!field_groups) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        result = _bcm_petra_field_test_fill_field_groups_dt(unit, x + second_rand_param++, field_groups, SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks));
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_presels_only;
        }

        /* each 3 field group should have a common preselector */
        for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx){
            if((fg_idx % 3) == 0) {
                if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
                    rv = bcm_field_presel_create_id(unit, fg_idx/3);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                } else {
                    rv = bcm_field_presel_create_stage_id(unit, stage_value, fg_idx/3);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto destroy_presels_only;
                    }
                    _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
                }
        
                rv = bcm_field_qualify_HeaderFormat(unit, (fg_idx/3) | BCM_FIELD_QUALIFY_PRESEL | presel_flags, fg_idx/3);
                /* the qualifiers 0 - 5 are supported, there may be no problem */
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_presels_only;
                }
            }
            
            BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
            BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, fg_idx/3);
            
            field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
        }
        /* Creating the filed groups */
        for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
            rv = _bcm_petra_field_test_key_length_best(unit, stage, field_groups[fg_idx].qset, &key_length);
            if(rv != BCM_E_NONE) {
                goto fail;
            }
            if( key_length > _BCM_PETRA_FIELD_TEST_DIRECT_TABLE_MAXIMAL_QUALIFIERS_LENGTH_SMALL_BANK) {
                field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_SMALL;
                /* we expect failure because it is can't fit small bank */
                rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
                if(rv == BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                field_groups[fg_idx].flags &= ~BCM_FIELD_GROUP_CREATE_SMALL;
            }                

            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
            /* create entries in order that the field groups will be written in the hardware */
            rv = bcm_field_entry_create_id(unit, field_groups[fg_idx].group, fg_idx);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            
            rv = bcm_field_entry_install(unit, fg_idx);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif

        /* Checking existing ids */
        for(flip = 0; flip < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++flip) {
            id = _bcm_petra_field_rand_val(x, second_rand_param++)
                 %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);
            does_exist_already = FALSE;
            for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
                if(field_groups[fg_idx].group == id) {
                    does_exist_already = TRUE;
                    break;
                }
            }
            /* Existence */
            rv = bcm_field_group_get(unit, id, &qset_verify);
            if(!does_exist_already) {
                if(rv != BCM_E_NOT_FOUND) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - doen't appear in the list and bcm_field_group_get didn\'t return BCM_E_NOT_FOUND\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                } else {
                    continue;
                }
            } else {
                if(rv != BCM_E_NONE) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - exist in the list but bcm_field_group_get failed\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        /* Taking existing group and check the retrieved attributes */
        result = _bcm_petra_field_field_group_get_and_compare(unit,
                                                              &field_groups[
                                                                  _bcm_petra_field_rand_val(x, second_rand_param++)
                                                                  %SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks)],
                                                              FALSE);

        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
            rv = bcm_field_entry_destroy(unit, fg_idx);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }

            rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
        for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
            if((fg_idx % 3) == 0) {
                bcm_field_presel_destroy(unit, (fg_idx/3) | presel_flags);
            }
        }
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
                return CMD_FAIL;
        }
    }

    sal_free(field_groups);
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    for(fg_idx=0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
        bcm_field_entry_destroy(unit, fg_idx);
        bcm_field_group_destroy(unit, field_groups[fg_idx].group);
    }
    
destroy_presels_only:
    for(fg_idx = 0; fg_idx < SOC_DPP_DEFS_GET(unit, nof_tcam_big_banks); ++fg_idx) {
        if((fg_idx % 3) == 0) {
            bcm_field_presel_destroy(unit, (fg_idx/3) | presel_flags);
        }
    }

    if(field_groups) {
        sal_free(field_groups);
    }
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_direct_table_entry(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of direct table entries\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_table_entry, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_entry_and_traffic(unit, stage, x, mode, FALSE, TRUE, FALSE, do_warmboot);
    
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

cmd_result_t _bcm_petra_field_test_direct_table_entry_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of direct table entries with traffic \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : direct_table_entry_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    result = _bcm_petra_field_test_entry_and_traffic(unit, stage, x, mode, TRUE, TRUE, FALSE, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    return result;
}

/* There in no need to test of the predefined data qualifiers without entries traffic - the test of the data qualifiers with entries tests also predefined data qualifiers */

/* The test creates filed group and use all the possible entries till there is no place to insert more.
 * if compress == TRUE, the test clean some of the entries, tries to create new field group that should fail,
 * then, compress the entries and retry the creation that should success.
 */
STATIC cmd_result_t test_full_tcam(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 diff_prio, uint8 compress, uint8 perf, uint8 do_warmboot)
{
    cmd_result_t result;
    bcm_error_t rv;
    uint32 second_rand_param = 0;
    uint32 iteration_idx;
    uint32 fg_idx, nof_groups;
    uint32 entry_idx, entry_idx2;
    uint32 flip;
    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS];
    bcm_field_group_config_t second_field_group;
    bcm_field_entry_t second_fg_entry;
    uint32 key_hw_size[_BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS];
    _bcm_petra_field_test_entry_info_t *entries[_BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS];
    uint32 nof_entries = 0;
    uint32 nof_priorities_sets = 0;
    uint32 priority_set_size = 0;
    uint32 priority_section;
    uint32 nof_iterations;
    uint8 does_exist_already;
    int priority;
    uint32 key_hw_size_min = _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE;
    uint32 orig_x = x;
    sal_usecs_t start_time = 0;
    sal_usecs_t end_time = 0;
    int time_per_entry = 0;
    int max_time_per_entry = -1; /* microseconds per adding 1 entry (benchmarks below are measured for 6.5.5 version) */

    if(perf) {
        nof_groups = 1;
        if (!diff_prio) {
            nof_entries = _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_FULL_TCAM_PERF(unit);
            if(SOC_IS_QAX(unit)) {
                max_time_per_entry = 8666; /* QAX measured time + 10% */
            } else if(SOC_IS_JERICHO(unit)) {
                max_time_per_entry = 15125; /* Jericho measured time + 10% */
            } else {
                max_time_per_entry = 17364; /* Arad measured time + 10% */
            }
        } else {
            nof_priorities_sets = _BCM_PETRA_FIELD_TEST_NOF_PRIORITIES_FULL_TCAM_PERF;
            priority_set_size = _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_PER_PRIO_FULL_TCAM_PERF(unit);
            nof_entries = nof_priorities_sets * priority_set_size;
            if(SOC_IS_QAX(unit)) {
                max_time_per_entry = 60000; /* QAX only time */
            } else {
                max_time_per_entry = 120000; /* Arad, Jericho and Jericho+ times */
            }
        }
    } else {
        nof_groups = _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS;
    }


    if(x == 0 || perf) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 4, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        };
    } else {
        nof_iterations = 1;
    }

    for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
        entries[fg_idx] = NULL;
    }
    
    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        if(!perf) {
            result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, FALSE, FALSE, 0, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_MAX_SIZE, field_groups, nof_groups, perf);
        } else {
            result = _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, FALSE, FALSE, 0, _BCM_PETRA_FIELD_TEST_FIELD_GROUP_BANK_SIZE_PERF, field_groups, nof_groups, perf);
        }
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
        
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            _BCM_PETRA_TEST_DEINIT_INIT_KBP(unit, rv);
            rv = _bcm_petra_field_test_kbp_set_presels(unit, nof_groups);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* Creating the field groups */
        for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
            if(!perf) {
                if((x % 3) >= 1){
                    field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE;
                }
                if((x % 3) == 2){
                    field_groups[fg_idx].flags |= BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES;
                }
            }

            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto destroy_fg_only;
            }

#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto destroy_fg_only;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        if(stage == _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) {
            result = _bcm_petra_field_test_kbp_init(unit);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
            rv = _bcm_petra_field_test_get_key_hw_length(unit, field_groups[fg_idx].group, &key_hw_size[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Key size for field group %d is %d.\n"), fg_idx, key_hw_size[fg_idx]));
            if((fg_idx == 0) || (key_hw_size[fg_idx] < key_hw_size_min) ) {
                key_hw_size_min = key_hw_size[fg_idx];
            }
            if(!perf) {
                if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                    nof_entries = (SOC_DPP_DEFS_GET(unit, nof_tcam_entries_160_bits) / 2)*(4/(key_hw_size[fg_idx]/80));
                } else {
                    nof_entries = _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_FULL_TCAM;
                }

                if(diff_prio){
                    --nof_entries;
                }

                nof_priorities_sets = (24* (SOC_DPP_DEFS_GET(unit, nof_tcam_entries_160_bits) / 2))/nof_entries;
                priority_set_size = nof_entries/nof_priorities_sets;
                if(nof_entries % nof_priorities_sets) {
                    ++priority_set_size;
                }
            }

            entries[fg_idx] = sal_alloc(sizeof(_bcm_petra_field_test_entry_info_t) * nof_entries, "test_full_tcam.entries");
            if(!entries[fg_idx]) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Memory allocation failure\n")));
                goto fail;
            }

            /* fill entries */
            if(perf) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Starting time measurement.\n")));

                start_time = sal_time_usecs();
            }
            for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                if(entry_idx % 512 == 0) {
                    if(diff_prio) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Priority set %d of %d. "), (1 + entry_idx / priority_set_size), nof_priorities_sets));
                    }
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Creating entry %d of %d...\n"), entry_idx, nof_entries));

                }
                /* entry id*/
                rv = bcm_field_entry_create(unit, field_groups[fg_idx].group, &entries[fg_idx][entry_idx].id);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /* priority */
                if(compress) {
                    entries[fg_idx][entry_idx].priority = BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL) - entry_idx;
                } else if(!diff_prio) {
                    entries[fg_idx][entry_idx].priority = 1;
                } else {
                    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                        priority_section = entry_idx / priority_set_size;
                        if(perf) {
                            entries[fg_idx][entry_idx].priority = 100 + priority_section;
                        } else {
                            entries[fg_idx][entry_idx].priority =  2 * (nof_priorities_sets - priority_section);
                            if((_bcm_petra_field_rand_val(x, second_rand_param++) % priority_set_size) > (entry_idx % priority_set_size) ){
                                ++entries[fg_idx][entry_idx].priority;
                            }
                        }
                    } else {
                        if(perf) {
                            entries[fg_idx][entry_idx].priority = entry_idx;
                        } else {
                            do
                            {
                                priority = _bcm_petra_field_rand_val(x, second_rand_param++) &
                                    BCM_FIELD_ENTRY_HIGHEST_PRIORITY(stage==_BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL);
                                if(priority == 0) {
                                    ++priority;
                                }
                                does_exist_already = FALSE;
                                for(entry_idx2 = 0; entry_idx2 < entry_idx; ++entry_idx2) {
                                    if (priority == entries[fg_idx][entry_idx2].priority) {
                                        does_exist_already = TRUE;
                                        break;
                                    }
                                }
                            }
                            while(does_exist_already);
                            entries[fg_idx][entry_idx].priority = priority;
                        }
                    }
                }

                if(diff_prio || compress) {
                    rv = bcm_field_entry_prio_set(unit, entries[fg_idx][entry_idx].id, entries[fg_idx][entry_idx].priority);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
                
                /*set the entry qualifiers */
                result = _bcm_petra_field_test_set_entry_qualifiers(unit, stage, &field_groups[fg_idx].qset, FALSE, FALSE, x + second_rand_param++, FALSE, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /* actions of the entries */
                result = _bcm_petra_field_test_set_entry_actions(unit, stage, &field_groups[fg_idx].aset, TRUE, FALSE, FALSE, x + second_rand_param++, &entries[fg_idx][entry_idx]);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                if(diff_prio) {
                    rv = bcm_field_entry_install(unit, entries[fg_idx][entry_idx].id);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
                if(!diff_prio) {
                    /* we didn't set the priority, and hence we will get it in order to avoid mismatch */
                    rv = bcm_field_entry_prio_get(unit, entries[fg_idx][entry_idx].id, &entries[fg_idx][entry_idx].priority);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
            if(!diff_prio) {
                rv = bcm_field_group_install(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }
        if(perf) {
            end_time = sal_time_usecs();
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "End of time measurement.\n\n")));
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Result:\n")));
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "_______\n")));
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Number of entries added : %d\n"), nof_entries));
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Time of full TCAM insertion : %d usecs (~%d minutes)\n"), end_time-start_time, (end_time-start_time)/60000000));
            time_per_entry = (end_time-start_time)/nof_entries;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Time of insertion per entry : %d usecs/entry\n"), time_per_entry));
            LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Max benchmark time of insertion : %d usecs/entry\n"), max_time_per_entry));
            if((nof_entries * 1000000) < (end_time - start_time)) {
               LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Rate of insertion (entries per second) : <1 eps\n")));
            } else {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Rate of insertion (entries per second) : %d eps\n"), (nof_entries * 1000000) / (end_time - start_time)));
            }
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")));
            if(time_per_entry > max_time_per_entry) {
                LOG_ERROR(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "The insertion rate is slower than the benchmark %d us/entry!\n"), max_time_per_entry));
                goto fail;
            }
        }
        if(!perf) {
    #ifdef BCM_WARM_BOOT_SUPPORT
            if(do_warmboot) {
                _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
            }
    #endif
            for(flip = 0; flip < _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_ITEMS_TO_TEST; ++flip) {
                fg_idx = _bcm_petra_field_rand_val(x, second_rand_param++)%_BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS;
                /* nof_entries can't be zero */
                /* coverity[divide_by_zero:FALSE] */
                result = _bcm_petra_field_test_retrieve_entry_and_compare(unit,
                                                                          stage,
                                                                          &entries[fg_idx][_bcm_petra_field_rand_val(x, second_rand_param++)%nof_entries],
                                                                          FALSE,
                                                                          FALSE);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }

            if(compress) {
                /* delete 2k entries, try to create field group that should fail, compress and retry */
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS; ++fg_idx) {
                    for(entry_idx = 0; entry_idx < nof_entries; entry_idx += (nof_entries/(2 * 1024 * _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS))) {
                        rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                        if(rv != BCM_E_NONE) {
                            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                            goto fail;
                        }
                    }
                }

                /* trying to create new field group*/
                result =  _bcm_petra_field_test_fill_field_groups(unit, stage, x + second_rand_param++, FALSE, FALSE, 0, key_hw_size_min, &second_field_group, 1, 0);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                second_field_group.flags &= ~BCM_FIELD_GROUP_CREATE_WITH_ID;

                /* verify that the priority does not already exist */
                do {
                    does_exist_already = FALSE;
                    for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS; ++fg_idx) {
                        if(second_field_group.priority == field_groups[fg_idx].priority) {
                            does_exist_already = TRUE;
                            second_field_group.priority = _bcm_petra_field_rand_val(x, second_rand_param++)
                                %(_BCM_PETRA_FIELD_GROUP_PRIO_HIGHEST - _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST) + _BCM_PETRA_FIELD_GROUP_PRIO_LOWEST;
                            break;
                        }
                    }
                } while(does_exist_already);

                BCM_FIELD_QSET_INIT(second_field_group.qset);
                BCM_FIELD_QSET_ADD(second_field_group.qset, bcmFieldQualifySrcMac);/* only one qualifier */
                rv = bcm_field_group_config_create(unit, &second_field_group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_entry_create(unit, second_field_group.group, &second_fg_entry);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }
                rv = bcm_field_entry_install(unit, second_fg_entry);
                if(rv != BCM_E_FULL) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "FALIRUE: The creation of field group succeded without compress\n")));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_entry_destroy(unit, second_fg_entry);
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }

                rv = bcm_field_entry_destroy(unit, second_fg_entry);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }
                rv = bcm_field_group_destroy(unit, second_field_group.group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                /* compress */
                for(fg_idx = 0; fg_idx < _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS; ++fg_idx) {
                    rv = bcm_field_group_compress(unit, field_groups[fg_idx].group);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
				LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Compress Field Group finished!!! \n")));

                /* retrying to create the second field group */
                rv = bcm_field_group_config_create(unit, &second_field_group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                rv = bcm_field_entry_create(unit, second_field_group.group, &second_fg_entry);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }
                rv = bcm_field_entry_install(unit, second_fg_entry);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_entry_destroy(unit, second_fg_entry);
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }
                rv = bcm_field_entry_destroy(unit, second_fg_entry);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    bcm_field_group_destroy(unit, second_field_group.group);
                    goto fail;
                }
                rv = bcm_field_group_destroy(unit, second_field_group.group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
            if(entries[fg_idx]) {
                if(!perf) {
                    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                        nof_entries = (SOC_DPP_DEFS_GET(unit, nof_tcam_entries_160_bits) / 2)*(4/(key_hw_size[fg_idx]/80));
                    } else {
                        nof_entries = _BCM_PETRA_FIELD_TEST_NOF_ENTRIES_FULL_TCAM;
                    }
                    if(diff_prio){
                        --nof_entries;
                    }
                }
                for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                    if(entry_idx % 512 == 0) {
						LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Destroying entry %d of %d...\n"), entry_idx, nof_entries));

                    }
                    if(compress && (entry_idx % (nof_entries/(2 * 1024 * _BCM_PETRA_FIELD_TEST_FULL_TCAM_NOF_GROUPS)) ) == 0) {
                        /* Skip entries that have been destroyed already */
                        continue;
                    }
                    rv = bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                    if(rv != BCM_E_NONE) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        result = CMD_FAIL;
                    }
                }
                sal_free(entries[fg_idx]);
            }
            if(stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
                rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    result = CMD_FAIL;
                }
            }
        }

        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return result;
        }
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(orig_x == 0 || perf) {
        for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
            if(entries[fg_idx]) {
                if(!perf) {
                    nof_entries = (SOC_DPP_DEFS_GET(unit, nof_tcam_entries_160_bits) / 2)*(key_hw_size[fg_idx]/80);
                    if(diff_prio){
                        --nof_entries;
                    }
                }
                for(entry_idx = 0; entry_idx < nof_entries; ++entry_idx) {
                    bcm_field_entry_destroy(unit, entries[fg_idx][entry_idx].id);
                }
                sal_free(entries[fg_idx]);
            }            
        }
    }

destroy_fg_only:
    if(orig_x == 0 || perf) {
        for(fg_idx = 0; fg_idx < nof_groups; ++fg_idx) {
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_full_tcam(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the egress stage!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of full tcam \n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : full_tcam, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return test_full_tcam(unit, stage, x, mode, FALSE, FALSE, FALSE, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_full_tcam_diff_prio(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the egress stage!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of full tcam with different priorities\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : full_tcam_diff_prio, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return test_full_tcam(unit, stage, x, mode, TRUE, FALSE, FALSE, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_full_tcam_diff_prio_perf(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage == _BCM_DPP_FIELD_STAGE_INDEX_EGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not valid for the egress stage!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the performance test of full tcam with different priorities\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : full_tcam_diff_prio_perf, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return test_full_tcam(unit, stage, x, mode, TRUE, FALSE, TRUE, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_compress(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid for the ingress stage only!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of compress\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : compress, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return test_full_tcam(unit, stage, x, mode, FALSE, TRUE, FALSE, do_warmboot);
}

cmd_result_t _bcm_petra_field_test_full_tcam_perf(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid for the ingress stage only!\n")));
        return CMD_FAIL;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of full tcam performance measure\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : full_tcam_perf, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    return test_full_tcam(unit, stage, x, mode, FALSE, FALSE, TRUE, do_warmboot);
}

STATIC bcm_error_t _bcm_petra_field_test_create_data_qualifiers_to_itmh(int unit)
{
    bcm_error_t rv;
    bcm_field_data_qualifier_t dq;

    /* data qualifier 0 will be for LAG-LB-Key */
    bcm_field_data_qualifier_t_init(&dq);
    dq.flags = BCM_FIELD_DATA_QUALIFIER_WITH_ID;
    dq.qual_id = 0;
    dq.offset_base = bcmFieldDataOffsetBaseNextForwardingHeader;
    dq.offset = 0;
    dq.length = 3;
    rv = bcm_field_data_qualifier_create(unit, &dq);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return rv;
    }

    /* data qualifier 1 will be for Bytes-To-Remove*/
    bcm_field_data_qualifier_t_init(&dq);
    dq.flags = BCM_FIELD_DATA_QUALIFIER_WITH_ID;
    dq.qual_id = 1;
    dq.offset_base = bcmFieldDataOffsetBaseNextForwardingHeader;
    dq.offset = 3;
    dq.length = 3;
    rv = bcm_field_data_qualifier_create(unit, &dq);
    if(rv != BCM_E_NONE) {
        bcm_field_data_qualifier_destroy(unit, 0);
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
    }

    return rv;
}

STATIC cmd_result_t _bcm_petra_field_test_itmh_build_packet(int unit,
                                                            int qual_id,
                                                            uint32 *data,
                                                            uint32 *buffer)
{
    bcm_field_data_qualifier_t dq;
    bcm_error_t rv;   
    uint32 val;

    sal_memset(buffer, 0xa5, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit));
    /* The headers will override part of the payload latter */

    bcm_field_data_qualifier_t_init(&dq);
    rv = bcm_field_data_qualifier_get(unit, qual_id, &dq);
    if (rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }
    if(dq.flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_BIT_RES) {
        dq.offset /= 8;
    } 
    if(dq.flags & BCM_FIELD_DATA_QUALIFIER_LENGTH_BIT_RES) {
        dq.length /= 8;
    }

    /* PTCH */
    val = 0;
    SHR_BITCOPY_RANGE(buffer, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 - 16, &val, 0, 16);

    /* ITMH */
    val = 0x000c0001;
    SHR_BITCOPY_RANGE(buffer, _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit)*8 - 16 - 32, &val, 0, 32);

    /* allign the offset to refers the ethernet */
    dq.offset += 6;/* 2 for PTCH, 4 for ITMH */
    SHR_BITCOPY_RANGE(buffer, (_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) - dq.offset - dq.length)*8, data, 0, 8 * dq.length);
    

    return CMD_OK;
}

/* Craetes itmh field group(s) nset and get the attributes.
 * In case of traffic. send traffic and verify the actions.
 */
STATIC cmd_result_t _bcm_petra_field_test_itmh_field_group_tag(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 with_traffic, uint32 nof_fgs, uint8 do_warmboot)
{
    bcm_error_t rv;
    cmd_result_t result;
    bcm_field_group_config_t field_groups[_BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC];
    uint32 second_rand_param = 0;
    const static bcm_field_action_t valid_actions[_BCM_PETRA_FIELD_TEST_ITMH_NOF_ACTIONS] = {
        bcmFieldActionPrioIntNew,
        bcmFieldActionSnoop,
        bcmFieldActionRedirect,
        bcmFieldActionRedirectMcast,
        bcmFieldActionDrop,
        bcmFieldActionMirrorIngress,
        bcmFieldActionDropPrecedence,
        bcmFieldActionStat0,
        bcmFieldActionStat1,
        bcmFieldActionPolicerLevel0, 
        bcmFieldActionPolicerLevel1,
        bcmFieldActionUsePolicerResult,
        bcmFieldActionVSQ,
        bcmFieldActionISQ,
        bcmFieldActionTrunkHashKeySet,
        bcmFieldActionMultipathHashAdditionalInfo,
        bcmFieldActionSrcGportNew,
        bcmFieldActionStatTag,
        bcmFieldActionFilters,
        bcmFieldActionStartPacketStrip,
        bcmFieldActionCnmCancel
    };
    SOC_PPC_FP_ACTION_TYPE ppd_actions[_BCM_PETRA_FIELD_TEST_ITMH_NOF_ACTIONS];
    uint32 action_ids[_BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC];
    uint32 id;
    bcm_field_qset_t qset_verify;
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 fg_idx, fg_idx2;
    uint32 flip;
    uint32 *buffer = NULL;
    uint32 data[1];
    uint32 actions_length[_BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC];
    uint8 does_exist; 
    SOC_PPC_FP_PACKET_DIAG_INFO *info;
    int stage_value = 0;
    int presel_flags = 0;
	
	switch(stage) {
        case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
            stage_value = bcmFieldStageIngress;
            break;
        case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS: 
            stage_value = bcmFieldStageEgress;
            break;
#if defined(INCLUDE_KBP) && !defined(BCM_88030)
        case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
            stage_value = bcmFieldStageExternal;
            break;
#endif /* defined(INCLUDE_KBP) && !defined(BCM_88030) */

        /* we may not reach to the default */
        default:
            break;
    }

    buffer = sal_alloc(_BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit), "_bcm_petra_field_test_itmh_field_group_tag.buffer");
    if(!buffer) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Memory allocation failure.\n")));
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto mem_fail;
    }

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        goto mem_fail;
    }

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        sal_free(buffer);
        return CMD_OK;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto mem_fail;
        };
    } else {
        nof_iterations = 1;
    }

    if(nof_fgs > _BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Number of field groups is over the maximum.\n")));
        goto mem_fail;
    }

    rv = _bcm_petra_field_test_actions_to_ppd_actions(unit, stage, valid_actions, _BCM_PETRA_FIELD_TEST_ITMH_NOF_ACTIONS, ppd_actions);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto mem_fail;
    }

    /* creating data qualifiers to the test */
    rv = _bcm_petra_field_test_create_data_qualifiers_to_itmh(unit);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto mem_fail;
    }

    if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
        rv = bcm_field_presel_create_id(unit, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_data_qualifiers_only;
        }
    } else {
        rv = bcm_field_presel_create_stage_id(unit, stage_value, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto destroy_data_qualifiers_only;
        }
        _bcm_petra_field_test_presel_stage_to_flag(stage_value, &presel_flags);
    }
    rv = bcm_field_qualify_ForwardingType(unit, BCM_FIELD_QUALIFY_PRESEL | presel_flags, bcmFieldForwardingTypeTrafficManagement);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        goto destroy_data_qualifiers_and_presel;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            bcm_field_group_config_t_init(&field_groups[fg_idx]);
            field_groups[fg_idx].flags = BCM_FIELD_GROUP_CREATE_WITH_MODE | BCM_FIELD_GROUP_CREATE_WITH_ASET | BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
            field_groups[fg_idx].mode = bcmFieldGroupModeDirectExtraction;

            /* set the preselector */
            BCM_FIELD_PRESEL_INIT(field_groups[fg_idx].preselset);
            BCM_FIELD_PRESEL_ADD(field_groups[fg_idx].preselset, 0);

            /* set the data qualifier */
            BCM_FIELD_QSET_INIT(field_groups[fg_idx].qset);
            if(nof_fgs < _BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC) {
                if(_bcm_petra_field_rand_val(x, second_rand_param++) % 2) {
                    rv = bcm_field_qset_data_qualifier_add(unit, &field_groups[fg_idx].qset, 1);
                } else {
                    rv = bcm_field_qset_data_qualifier_add(unit, &field_groups[fg_idx].qset, 0);
                }
            } else {
                rv = bcm_field_qset_data_qualifier_add(unit, &field_groups[fg_idx].qset, fg_idx);
            }
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                    bcm_field_group_destroy(unit, field_groups[fg_idx2].group);
                }
                goto destroy_data_qualifiers_and_presel;
            }

            /* take one action */
            BCM_FIELD_ASET_INIT(field_groups[fg_idx].aset);
            do {
                does_exist = FALSE;
                action_ids[fg_idx] = _bcm_petra_field_rand_val(x, second_rand_param++) % _BCM_PETRA_FIELD_TEST_ITMH_NOF_ACTIONS;
                for(fg_idx2 = 0; fg_idx2 < fg_idx; ++fg_idx2) {
                    if(ppd_actions[action_ids[fg_idx2]] == ppd_actions[action_ids[fg_idx]]) {
                        does_exist = TRUE;
                        break;
                    }
                }
            } while (does_exist);
            BCM_FIELD_ASET_ADD(field_groups[fg_idx].aset, valid_actions[action_ids[fg_idx]]);

            field_groups[fg_idx].priority = fg_idx + 1;

            rv = bcm_field_group_config_create(unit, &field_groups[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            
#ifdef BROADCOM_DEBUG
            /* Dumping the field group */
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_EVERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dumping the field group: \n")));
                rv = _bcm_petra_field_test_group_dump(unit, field_groups[fg_idx].group);
                if(rv != BCM_E_NONE) {
                    goto fail;
                    return CMD_FAIL;
                }
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "\n\n")));
            }
#endif
        }

#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        for(flip = 0; flip < _BCM_PETRA_FIELD_SET_AND_REMOVE_TEST_NOF_ITEMS_TO_TEST; ++flip) {
            id = _bcm_petra_field_rand_val(x, second_rand_param++)
                 %(_BCM_PETRA_FIELD_TEST_MAXIMAL_GROUP_ID + 1);

            /* Existence */
            rv = bcm_field_group_get(unit, id, &qset_verify);
            does_exist = FALSE;
            for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
                if(id == field_groups[fg_idx].group) {
                    does_exist = TRUE;
                    break;
                }
            }
            if(!does_exist) {
                if(rv != BCM_E_NOT_FOUND) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - doen't appear in the list and bcm_field_group_get didn\'t return BCM_E_NOT_FOUND\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                } else {
                    continue;
                }
            } else {
                if(rv != BCM_E_NONE) {
                    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_ERR) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "group id %d - exist in the list but bcm_field_group_get failed\n"), id));
                    }
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
            }
        }

        /* Taking existing group and check the retrieved attributes */
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            result = _bcm_petra_field_field_group_get_and_compare(unit, &field_groups[fg_idx], FALSE);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }

        if(with_traffic) {
            for(fg_idx = 0 ; fg_idx < nof_fgs; ++fg_idx) {
                 
                rv = _bcm_petra_field_test_action_length(unit, stage, valid_actions[action_ids[fg_idx]], &actions_length[fg_idx]);
                if(rv != BCM_E_NONE) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }

                if(actions_length[fg_idx] > 20) {
                    actions_length[fg_idx] = 8;
                }
                data[0] = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << actions_length[fg_idx]);
                result = _bcm_petra_field_test_itmh_build_packet(unit, fg_idx, data, buffer);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
                result = _bcm_petra_field_send_packet_and_get_information(unit, buffer, 0, 1, &info);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    goto fail;
                }
#ifndef PLISIM
                {
                    int cycle, macro;
                    uint8 success = FALSE;
                    for(cycle = SOC_PPC_FP_NOF_CYCLES - 1; cycle >= 0; --cycle){
                        for(macro = _BCM_PETRA_FIELD_TEST_PP_FP_NOF_MACRO_SIMPLES - 1; macro >= 0; --macro) {
                                if(info->macro_simple[cycle][macro].action.type != SOC_PPC_FP_ACTION_TYPE_INVALID) {
                                if(info->macro_simple[cycle][macro].action.type != ppd_actions[action_ids[fg_idx]]) {
                                    continue;
                                }
                                if(info->macro_simple[cycle][macro].action.val == data[0]) {
                                    success = TRUE;
                                    break;
                                } else {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "The action of D.B. occurred with a wrong value expected 0x%x but got 0x%x\n"), data[0], info->macro_simple[cycle][macro].action.val));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                            }
                        }
                        if (success) {
                            break;
                        }
                    }
                    if(!success) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "No action of the desired type have happened.\n")));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
#endif /* not PLISIM*/
            }
        }

        result = CMD_OK;
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            rv = bcm_field_group_destroy(unit, field_groups[fg_idx].group);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
        if(result != CMD_OK) {
            goto destroy_data_qualifiers_and_presel;
        }
    }

    result = CMD_OK;
    rv = bcm_field_presel_destroy(unit, 0 | presel_flags);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        result = CMD_FAIL;
    }
    rv = bcm_field_data_qualifier_destroy(unit, 0);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        result = CMD_FAIL;
    }
    rv = bcm_field_data_qualifier_destroy(unit, 1);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        result = CMD_FAIL;
    }
    if(result != CMD_OK) {
        if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
    } else {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully\n")));
    }
    sal_free(buffer);
    return result;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < nof_fgs; ++fg_idx) {
            bcm_field_group_destroy(unit, field_groups[fg_idx].group);
        }
    }
destroy_data_qualifiers_and_presel:
    bcm_field_presel_destroy(unit, 0 | presel_flags);
destroy_data_qualifiers_only:
    bcm_field_data_qualifier_destroy(unit, 0);
    bcm_field_data_qualifier_destroy(unit, 1);
    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
mem_fail:
    if(buffer) {
        sal_free(buffer);
    }
    return CMD_FAIL;
}

cmd_result_t _bcm_petra_field_test_itmh_field_group(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;

    if (soc_property_get(unit, spn_ITMH_PROGRAMMABLE_MODE_ENABLE, FALSE) == 0 ) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Beginning the test of field group of ITMH protocol\n")));
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Test Name : itmh_field_group, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

        result = _bcm_petra_field_test_itmh_field_group_tag(unit, stage, x, mode, FALSE, 1, do_warmboot);
    }

    return result;
}

cmd_result_t _bcm_petra_field_test_itmh_field_group_traffic(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;

    if (soc_property_get(unit, spn_ITMH_PROGRAMMABLE_MODE_ENABLE, FALSE) == 0 ) {

        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Beginning the test of field group of ITMH protocol\n")));
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "Test Name : itmh_field_group_traffic, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

        result = _bcm_petra_field_test_itmh_field_group_tag(unit, stage, x, mode, TRUE, _BCM_PETRA_FIELD_TEST_ITMH_NOF_FIELD_GROUPS_TRAFFIC, do_warmboot);
    }

    return result;
}

STATIC cmd_result_t
_bcm_petra_field_test_itmh_parsing_test_get_signal(int unit, int core_id, uint32 blk, ARAD_PP_DIAG_REG_FIELD *fld, uint32 *signal)
{
    uint32 soc_sand_res;
    uint32 val[ARAD_PP_DIAG_DBG_VAL_LEN];

    if(signal == NULL || fld == NULL) {
        return CMD_FAIL;
    }

    soc_sand_res = arad_pp_diag_dbg_val_get_unsafe(unit, core_id, blk, fld, val);
    if(SOC_SAND_FAILURE(soc_sand_res)) {
        return CMD_FAIL;
    }
    *signal = val[0];

    return CMD_OK;
}

/* taking the signal -> fer2lbp_eq2_user_header2 [31 : 0] */
STATIC cmd_result_t
_bcm_petra_field_test_itmh_parsing_test_get_multicast_id(int unit, int core_id, uint32 *multicast_id)
{
    cmd_result_t result;
    ARAD_PP_DIAG_REG_FIELD fld;

    if(multicast_id == NULL) {
        return CMD_FAIL;
    }

    if (SOC_IS_JERICHO_PLUS(unit)) {
        fld.base = (2 << 16) + 0;
        fld.msb = 254;
        fld.lsb = 223;
    } else if (SOC_IS_JERICHO(unit)) {
        fld.base = (2 << 16) + 0;
        fld.msb = 184;
        fld.lsb = 153;
    } else {
        fld.base = (10 << 16) + 0;
        fld.msb = 180;
        fld.lsb = 149;
    }

    result = _bcm_petra_field_test_itmh_parsing_test_get_signal(unit, core_id, 21, &fld, multicast_id);
    if(result == CMD_OK) {
        *multicast_id &= (1 << 19) - 1;
    }
    return result;
}

STATIC cmd_result_t
_bcm_petra_field_test_itmh_parsing_test_get_user_header_2(int unit, int core_id, uint32 *user_header_2)
{
    /* it is the same signal */
    return _bcm_petra_field_test_itmh_parsing_test_get_multicast_id(unit, core_id, user_header_2);
}

/* taking the signal -> lbp2dbg_ire_eq_bytes_to_strip [6 : 0] */
STATIC cmd_result_t
_bcm_petra_field_test_itmh_parsing_test_get_bytes_to_remove(int unit, int core_id, uint32 *bytes)
{
    cmd_result_t result;
    ARAD_PP_DIAG_REG_FIELD fld;

    if(bytes == NULL) {
        return CMD_FAIL;
    }

    if (SOC_IS_QAX(unit)) {
        fld.base = (4 << 16) + 3;
        fld.msb = 82;
        fld.lsb = 76;
    } else if (SOC_IS_JERICHO(unit)) {
        fld.base = (4 << 16) + 3;
        fld.msb = 9;
        fld.lsb = 3;
    } else {
        fld.base = (12 << 16) + 2;
        fld.msb = 252;
        fld.lsb = 246;
    }

    result = _bcm_petra_field_test_itmh_parsing_test_get_signal(unit, core_id, 21, &fld, bytes);
    if(result == CMD_OK) {
        *bytes &= (1 << 7) - 1;
    }
    return result;
}

/* taking the signal -> fer2lbp_eq2_snoop_action_profile_index [3 : 0] */
STATIC cmd_result_t
_bcm_petra_field_test_itmh_parsing_test_get_snoop(int unit, int core_id, uint32 *snoop)
{
    cmd_result_t result;
    ARAD_PP_DIAG_REG_FIELD fld;

    if(snoop == NULL) {
        return CMD_FAIL;
    }

    if (SOC_IS_JERICHO_PLUS(unit)) {
        fld.base = (2 << 16) + 1;
        fld.msb = 136;
        fld.lsb = 133;
    } else if (SOC_IS_JERICHO(unit)) {
        fld.base = (2 << 16) + 1;
        fld.msb = 24;
        fld.lsb = 21;
    } else if (SOC_IS_ARADPLUS(unit)) {
        fld.base = (10 << 16) + 1;
        fld.msb = 12;
        fld.lsb = 9;
    } else {
        fld.base = 655360;
        fld.msb = 250;
        fld.lsb = 247;
    }

    result = _bcm_petra_field_test_itmh_parsing_test_get_signal(unit, core_id, 21, &fld, snoop);
    if(result == CMD_OK) {
        *snoop &= (1 << 4) - 1;
    }
    return result;
}


STATIC cmd_result_t _bcm_petra_field_test_itmh_parsing_test_tag(int unit, int local_port_src,  _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    /*bcm_error_t rv;*/
    cmd_result_t result;
    uint32 second_rand_param = 0;
    uint32 nof_iterations;
    uint32 iteration_idx;
    uint32 flip;
    uint32 rnd;
    uint32 buffer_idx;
    ARAD_PORTS_ITMH itmh_data, itmh_data_verify;
    ARAD_HPU_ITMH_HDR itmh_buffer;
    uint32 soc_sand_res;
    SOC_PPC_FP_PACKET packet;
    SOC_PPC_DIAG_PKT_TM_INFO packet_tm_info;
    uint32 multicast_id_verify;
    uint32 snoop_verify;
    uint32 bytes_to_remove;
    uint32 user_header_2;
    uint8 itmh_mode;
    int core_id;
	uint32 tm_port;
	SOC_PPC_DIAG_RESULT     ret_val;

    itmh_mode = (soc_property_get(unit, spn_ITMH_PROGRAMMABLE_MODE_ENABLE, FALSE)) ? TRUE : FALSE ; 

    if(mode == _bcmPetraFieldTestScan) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 0, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }
        for(flip = 0; flip < _BCM_PETRA_FIELD_TEST_ITMH_PARSING_TEST_NOF_FLIPS; ++flip) {
            arad_ARAD_PORTS_ITMH_clear(&itmh_data);
            itmh_data.base.pp_header_present = 0;
            itmh_data.base.out_mirror_dis = 0;
            itmh_data.base.snoop_cmd_ndx = _bcm_petra_field_rand_val(x, second_rand_param++) % 16;

            itmh_data.base.tr_cls = _bcm_petra_field_rand_val(x, second_rand_param++) % 8;
            itmh_data.base.dp = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;

            itmh_data.base.destination.type = _bcm_petra_field_rand_val(x, second_rand_param++) % SOC_TMC_NOF_DEST_TYPES_ARAD;
            switch(itmh_data.base.destination.type) {
                case ARAD_DEST_TYPE_QUEUE:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                    itmh_data.base.exclude_src = 0;
                    break;
                case ARAD_DEST_TYPE_MULTICAST:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                    itmh_data.base.exclude_src = 0;
                    break;
                case ARAD_DEST_TYPE_SYS_PHY_PORT:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 15);
                    itmh_data.base.exclude_src = 0;
                    break;
                case ARAD_DEST_TYPE_LAG: /*if ITMH programmable mode - use it as FEC Pointer */
                    if (itmh_mode)
                    {
                        itmh_data.base.destination.type = ARAD_DEST_TYPE_QUEUE;
                        itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                        itmh_data.base.exclude_src = 0;
                    } else {
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 6);
                    itmh_data.base.exclude_src = 0;
                    }
                    break;
                case ARAD_DEST_TYPE_ISQ_FLOW_ID:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 32/* We don't use the last 32 queues*/);
                    itmh_data.extension.enable = 1;
                    itmh_data.extension.is_src_sys_port = 0;
                    if (itmh_mode) 
                    {
                        itmh_data.base.destination.type = ARAD_DEST_TYPE_QUEUE;
                        itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                        itmh_data.extension.destination.type = ARAD_DEST_TYPE_ISQ_FLOW_ID ;
                        itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 32/* We don't use the last 32 queues*/);
                    } else {
                        itmh_data.extension.destination.type = ARAD_DEST_TYPE_QUEUE;
                        itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                    } 
                    break;
                case ARAD_DEST_TYPE_OUT_LIF:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                    itmh_data.extension.enable = 1;
                    itmh_data.extension.is_src_sys_port = 0;
                    if (itmh_mode)
                    {
                        itmh_data.base.destination.type = ARAD_DEST_TYPE_QUEUE;
                        itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                        itmh_data.extension.destination.type = ARAD_DEST_TYPE_OUT_LIF;
                        itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 18);

                    } else {
                        rnd = _bcm_petra_field_rand_val(x, second_rand_param++) % 4;
                        switch(rnd) {
                            case 0:
                                itmh_data.extension.destination.type = ARAD_DEST_TYPE_QUEUE;
                                itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                                break;
                            case 1:
                                itmh_data.extension.destination.type = ARAD_DEST_TYPE_MULTICAST;
                                itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                                break;
                            case 2:
                                itmh_data.extension.destination.type = ARAD_DEST_TYPE_SYS_PHY_PORT;
                                itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 15);
                                break;
                            case 3:
                                itmh_data.extension.destination.type = ARAD_DEST_TYPE_LAG;
                                itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 6);
                                break;
                        }
                    }
                    break;
                case ARAD_DEST_TYPE_MULTICAST_FLOW_ID:
                    itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                    itmh_data.extension.enable = 1;
                    itmh_data.extension.is_src_sys_port = 0;
                    if (itmh_mode)
                    {
                        itmh_data.base.destination.type = ARAD_DEST_TYPE_QUEUE;
                        itmh_data.base.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % ((1 << 17) - 1);
                        itmh_data.extension.destination.type = ARAD_DEST_TYPE_MULTICAST_FLOW_ID;
                        itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 17);

                    } else {
                        itmh_data.extension.destination.type = ARAD_DEST_TYPE_MULTICAST;
                        itmh_data.extension.destination.id = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                    }
                    break;
                default:
                    ;
            }

            /* make buffer */
            soc_sand_res = arad_hpu_itmh_build(unit, &itmh_data, &itmh_buffer);
            if(SOC_SAND_FAILURE(soc_sand_res)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            /* verify parsing */
            arad_ARAD_PORTS_ITMH_clear(&itmh_data_verify);
            soc_sand_res = arad_hpu_itmh_parse(unit, &itmh_buffer, &itmh_data_verify);
            if(SOC_SAND_FAILURE(soc_sand_res)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if(sal_memcmp(&itmh_data.base, &itmh_data_verify.base, sizeof(ARAD_PORTS_ITMH_BASE))) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "The retrieved itmh data base is not the same as the set one.\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if(itmh_data.extension.enable && sal_memcmp(&itmh_data.extension, &itmh_data_verify.extension, sizeof(ARAD_PORTS_ITMH_EXT_SRC_PORT))) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "The retrieved itmh data extension is not the same as the set one.\n")));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }

            /* sending packet */
            soc_sand_res = soc_port_sw_db_local_to_tm_port_get(unit, local_port_src, &tm_port, &core_id);
            if(SOC_SAND_FAILURE(soc_sand_res)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            SOC_PPC_FP_PACKET_clear(&packet);
            packet.local_port_src = local_port_src;
            packet.size_bytes = _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit);
            packet.buffer[0] = 0;
            SHR_BITCOPY_RANGE(packet.buffer, 0, &itmh_buffer.base, 16, 16);
            SHR_BITCOPY_RANGE(packet.buffer, 48, &itmh_buffer.base, 0, 16);
            if(itmh_data.extension.enable) {
                SHR_BITCOPY_RANGE(packet.buffer, 32, &itmh_buffer.extention_src_port, 8, 12);
                SHR_BITCOPY_RANGE(packet.buffer, 88, &itmh_buffer.extention_src_port, 0, 8);
                packet.buffer[2] |= _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 24);
            } else {
                packet.buffer[1] |= _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << 16);
                packet.buffer[2] = _bcm_petra_field_rand_val(x, second_rand_param++);
            }
            for(buffer_idx = 3; buffer_idx < _BCM_PETRA_FIELD_TEST_PACKET_SIZE_BYTES(unit) / sizeof(uint32); ++buffer_idx) {
                packet.buffer[buffer_idx] = _bcm_petra_field_rand_val(x, second_rand_param++);
            }

            if(_bcm_petra_field_test_soc_ppd_fp_ire_traffic_send(unit, &packet, 1, core_id, FALSE) != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }

            /* verifying the parsing */
            soc_sand_res = soc_ppd_diag_pkt_associated_tm_info_get(unit, core_id, &packet_tm_info, &ret_val);
            if(SOC_SAND_FAILURE(soc_sand_res)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            if (ret_val != SOC_PPC_DIAG_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            /* dp */
            if(itmh_data.base.dp != packet_tm_info.dp) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Dp mismatch: set %d get %d.\n"), itmh_data.base.dp, packet_tm_info.dp));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            /* tc */
            if(itmh_data.base.tr_cls != packet_tm_info.tc) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Traffic class mismatch: set %d get %d.\n"), itmh_data.base.tr_cls, packet_tm_info.tc));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
            /* snoop */
            if(itmh_data.base.snoop_cmd_ndx != packet_tm_info.snoop_id) {
                if(packet_tm_info.snoop_id) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Snoop id mismatch: set %d get %d.\n"), itmh_data.base.snoop_cmd_ndx, packet_tm_info.snoop_id));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                } else {
                    /* When the snoop is 0. The snoop may be get from a signal */
                    /* dpp_dsig_read(unit, core_id, "IRPP", "FER", NULL, "Snoop_Action_Profile_Index", &snoop_verify, 1); */
                    result = _bcm_petra_field_test_itmh_parsing_test_get_snoop(unit, core_id, &snoop_verify);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(itmh_data.base.snoop_cmd_ndx != snoop_verify) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Snoop id mismatch: set %d get %d.\n"), itmh_data.base.snoop_cmd_ndx, snoop_verify));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }
            /* destination */
            if(itmh_data.base.destination.type != ARAD_DEST_TYPE_ISQ_FLOW_ID && itmh_data.base.destination.type != ARAD_DEST_TYPE_OUT_LIF) {
                /* in these 2 cases the destination in in the extension */
                if(itmh_data.base.destination.id != packet_tm_info.frwrd_decision.dest_id) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Destination id mismatch: set %d get %d.\n"), itmh_data.base.destination.id, packet_tm_info.frwrd_decision.dest_id));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            } else {
                if(itmh_data.base.destination.type == ARAD_DEST_TYPE_ISQ_FLOW_ID) {
                    if(itmh_data.base.destination.id != packet_tm_info.ingress_shaping_da) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Destination inghress shaping queue id mismatch: set %d get %d.\n"), itmh_data.base.destination.id, packet_tm_info.ingress_shaping_da));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    if(itmh_data.extension.destination.id != packet_tm_info.frwrd_decision.dest_id) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Destination id mismatch: set %d get %d.\n"), itmh_data.extension.destination.id, packet_tm_info.frwrd_decision.dest_id));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                } else if(itmh_data.base.destination.type == ARAD_DEST_TYPE_OUT_LIF) {
                    if(itmh_data.base.destination.id != packet_tm_info.cud) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "C.U.D. mismatch: set %d get %d.\n"), itmh_data.base.destination.id, packet_tm_info.cud));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }

                    /* User header 2 must be same as the out-lif in 17 bits */

                    /* dpp_dsig_read(unit, core_id, "IRPP", "FER", NULL, "User_Header_2", &user_header_2, 1); */
                    result = _bcm_petra_field_test_itmh_parsing_test_get_user_header_2(unit, core_id, &user_header_2);
                    if(result != CMD_OK) {
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return result;
                    }
                    if(itmh_data.base.destination.id != (user_header_2 & 0x1ffff)) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Out lif id and user header 2 mismatch: set %d get %d.\n"), itmh_data.base.destination.id, user_header_2 & 0x1ffff));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                    
                    if(itmh_data.extension.destination.id != packet_tm_info.frwrd_decision.dest_id) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Destination id mismatch: set %d get %d.\n"), itmh_data.extension.destination.id, packet_tm_info.frwrd_decision.dest_id));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        return CMD_FAIL;
                    }
                }
            }
            /* multicast id in multicast flow id */
            if(itmh_data.base.destination.type == ARAD_DEST_TYPE_MULTICAST_FLOW_ID) {
                /* dpp_dsig_read(unit, core_id, "IRPP", "FER", NULL, "User_Header_2", &multicast_id_verify, 1); */
                result = _bcm_petra_field_test_itmh_parsing_test_get_multicast_id(unit, core_id, &multicast_id_verify);
                if(result != CMD_OK) {
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return result;
                }
                if(itmh_data.extension.destination.id != multicast_id_verify) {
                    LOG_INFO(BSL_LS_BCM_FP,
                             (BSL_META_U(unit,
                                         "Multicast id mismatch: set %d get %d.\n"), itmh_data.extension.destination.id,  multicast_id_verify));
                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                    return CMD_FAIL;
                }
            }
            /* bytes to remove */
            /* dpp_dsig_read(unit, core_id, "IRPP", "LBP", NULL, "Bytes_to_Remove", &bytes_to_remove, 1); */
            result = _bcm_petra_field_test_itmh_parsing_test_get_bytes_to_remove(unit, core_id, &bytes_to_remove);
            if(result != CMD_OK) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return result;
            }
            if((itmh_data.extension.enable ? 9 : 6) != bytes_to_remove) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Bytes to remove mismatch: expected %d get %d.\n"), (itmh_data.extension.enable ? 9 : 6), bytes_to_remove));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                return CMD_FAIL;
            }
        }
    }

    return CMD_OK;
}

cmd_result_t _bcm_petra_field_test_itmh_parsing_test(int unit, int core_id, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    bcm_error_t rv = BCM_E_NONE;
    uint8 itmh_prog_mode_enable_orig;
    char itmh_prog_mode_enable_orig_str[80];

    if(mode == _bcmPetraFieldTestScan || mode == _bcmPetraFieldTestSuperFast || mode == _bcmPetraFieldTestFast) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in this mode\n")));
        return CMD_OK;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of ITMH parsing test\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : itmh_parsing_test, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    /* get the original status of itmh_programmable_mode_enable */
    itmh_prog_mode_enable_orig = soc_property_get(unit, "itmh_programmable_mode_enable", 0);

    /*
     * For Jericho, this setup, "config add itmh_programmable_mode_enable=0", is NOT allowed (for now...)
     */
    if (!SOC_IS_JERICHO(unit)) {
        /* reset it */
        result = sh_process_command(unit, "config add itmh_programmable_mode_enable=0");
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }
    
        _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

        result = _bcm_petra_field_test_itmh_parsing_test_tag(unit, core_id, stage, x, mode, do_warmboot);
        if(result == CMD_OK) {
            LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully with itmh_programmable_mode_enable=0\n")));
        }
    }
    /* set it */
    result = sh_process_command(unit, "config add itmh_programmable_mode_enable=1");
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    
    _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

    result = _bcm_petra_field_test_itmh_parsing_test_tag(unit, core_id, stage, x, mode, do_warmboot);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test finished successfully with itmh_programmable_mode_enable=1\n")));
    }

    /* set the original status of itmh_programmable_mode_enable */
    sal_sprintf(itmh_prog_mode_enable_orig_str, "config add itmh_programmable_mode_enable=%d", itmh_prog_mode_enable_orig);
    result = sh_process_command(unit, itmh_prog_mode_enable_orig_str);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }

   _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    return CMD_FAIL;

}

cmd_result_t _bcm_petra_field_test_resend_last_packet(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    result = _bcm_petra_field_test_soc_ppd_fp_ire_traffic_send(unit, NULL, 1, SOC_CORE_DEFAULT, TRUE);
    if(result == CMD_OK) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The last packet resent successfully.\n")));
    }
    return result;
}


cmd_result_t _bcm_petra_field_test_itmh_parsing_test_pb(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result;
    bcm_error_t rv = BCM_E_NONE;

    if(mode == _bcmPetraFieldTestScan || mode == _bcmPetraFieldTestSuperFast) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in this mode\n")));
        return CMD_OK;
    }

    if( SOC_IS_JERICHO(unit) ) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning for Jericho\n")));
        return CMD_OK;
    }

    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of ITMH parsing test\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : itmh_parsing_test_pb, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    /* configure the parsing for petra-b */
    result = sh_process_command(unit, "config add system_is_petra_b_in_system=1");
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

    result = _bcm_petra_field_test_itmh_parsing_test_tag(unit, 0 /* local_port */, stage, x, mode, do_warmboot);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }

    /* return the default configuration */
    result = sh_process_command(unit, "config delete system_is_petra_b_in_system");
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }
    _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;
fail:
    return CMD_FAIL;
}

/* The test create ingress field group which do the actions bcmFieldActionClassDestSet, bcmFieldActionClassSourceSet.
 * These actions are forwarded to egress filed group and should cause hit in the egress field group.
 */
cmd_result_t _bcm_petra_field_test_user_header(int unit, _bcm_dpp_field_stage_idx_t stage, uint32 x, _bcmPetraFieldTestSpeedMode mode, uint8 do_warmboot)
{
    cmd_result_t result = CMD_OK;
    bcm_error_t rv = BCM_E_NONE;
    bcm_field_qset_t qset, valid_qset;
    bcm_field_aset_t aset, valid_aset;
    uint8 field_class_id_size_2;
    uint8 field_class_id_size_3;
    char field_class_id_size_2_string[80];
    char field_class_id_size_3_string[80];
    
    bcm_field_group_t fg[2];
    bcm_field_entry_t entry_id[2];
    uint32 iteration_idx;
    uint32 fg_idx;
    _bcm_petra_field_test_ethernet_header_t ethernet_header;
    uint32 nof_iterations;
    uint32 second_rand_param = 0;
    uint32 class_dst_set_val;
    uint32 class_src_set_val;
    CONST uint32 local_port_src = 1;
    uint32 next_hop_mac_extension_enable_orig;
    char next_hop_mac_extension_enable_orig_str[80];
    SOC_PPC_FP_PACKET_DIAG_INFO *info;

    
    if(SOC_IS_ARAD_A0(unit)) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is not supported for ARAD A0\n")));
        return CMD_OK;
    }
    if(stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "The test is valid only for the ingress stage!\n")));
        return CMD_FAIL;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Beginning the test of using user header\n")));
    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "Test Name : user_header, stage : %s.\n"), _BCM_PETRA_FIELD_TEST_STAGE_TO_STRING(stage)));

    if(x == 0) {
        if(_bcm_petra_field_test_speed_mode_to_iterations_number(mode, 4, &nof_iterations)){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }
    } else {
        nof_iterations = 1;
    }

    if(nof_iterations == _BCM_PETRA_FIELD_TEST_NOF_ITERATION_SCAN) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "This test has no meaning in scan mode\n")));
        return CMD_OK;
    }

    rv = _bcm_dpp_field_stage_type_qset_aset_get(unit, _BCM_DPP_FIELD_STAGE_INDEX_INGRESS, _BCM_PETRA_FIELD_TYPE_ETHR, &valid_qset, &valid_aset);
    if(rv != BCM_E_NONE) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return CMD_FAIL;
    }

    /* get the original status of bcm886xx_next_hop_mac_extension_enable.BCM88650 */
    next_hop_mac_extension_enable_orig = soc_property_get(unit, "bcm886xx_next_hop_mac_extension_enable.BCM88650", 1);

    /* reset it */
    result = sh_process_command(unit, "config add bcm886xx_next_hop_mac_extension_enable.BCM88650=0");
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }

    for(iteration_idx = 0; iteration_idx < nof_iterations; ++iteration_idx) { 
        if(iteration_idx > 0 || x == 0) {
            x = sal_rand();
            second_rand_param = 0;
            LOG_INFO(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "x = %d\n"), x));
        }

        /* set soc properties */
        result = sh_process_command(unit, "config add field_class_id_size_0.BCM88650=8");
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        result = sh_process_command(unit, "config add field_class_id_size_1.BCM88650=8");
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        field_class_id_size_2 = 8;
        sal_sprintf(field_class_id_size_2_string, "config add field_class_id_size_2.BCM88650=%d", field_class_id_size_2);
        result = sh_process_command(unit, field_class_id_size_2_string);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        field_class_id_size_3 = 8;
        sal_sprintf(field_class_id_size_3_string, "config add field_class_id_size_3.BCM88650=%d", field_class_id_size_3);
        result = sh_process_command(unit, field_class_id_size_3_string);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        result = sh_process_command(unit, "config add BCM886XX_NEXT_HOP_MAC_EXTENSION_ENABLE=0");
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return result;
        }

        _BCM_PETRA_TEST_DEINIT_INIT(unit, rv);

        _bcm_petra_field_test_qual_remove_from_qset(&valid_qset);

        /* first field group */

        /* qset */
        BCM_FIELD_QSET_INIT(qset);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyOuterVlanPri);


        /* aset */
        BCM_FIELD_ASET_INIT(aset);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionClassDestSet);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionClassSourceSet);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionDoNotLearn);
    
        rv = bcm_field_group_create(unit, qset, 2, &fg[0]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        rv = bcm_field_group_action_set(unit, fg[0], aset);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* entries */
        
        /* id */
        rv = bcm_field_entry_create(unit, fg[0], &entry_id[0]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* priority */
        rv = bcm_field_entry_prio_set(unit, entry_id[0], 1);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* qualifier */
        rv = bcm_field_qualify_OuterVlanPri(unit, entry_id[0], 0x7, 0x7);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* actions */
        class_dst_set_val = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (8 + field_class_id_size_2));
        /* reset bit 31 */
        class_dst_set_val &= 0x7fffffff;

        rv = bcm_field_action_add(unit, entry_id[0], bcmFieldActionClassDestSet, class_dst_set_val, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        class_src_set_val = _bcm_petra_field_rand_val(x, second_rand_param++) % (1 << (8 + field_class_id_size_3));
        /* reset bit 31 */
        class_dst_set_val &= 0x7fffffff;

        rv = bcm_field_action_add(unit, entry_id[0], bcmFieldActionClassSourceSet, class_src_set_val, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        rv = bcm_field_action_add(unit, entry_id[0], bcmFieldActionDoNotLearn, 0, 0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* install */
        rv = bcm_field_entry_install(unit, entry_id[0]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* second field group */

        /* qset */
        BCM_FIELD_QSET_INIT(qset);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageEgress);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyDstClassField);
        BCM_FIELD_QSET_ADD(qset, bcmFieldQualifySrcClassField);

        rv = bcm_field_group_create(unit, qset, 1, &fg[1]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        /* aset - */
        BCM_FIELD_ASET_INIT(aset);
        BCM_FIELD_ASET_ADD(aset, bcmFieldActionPrioIntNew);
    
        rv = bcm_field_group_action_set(unit, fg[1], aset);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* entry */

        /* id */
        rv = bcm_field_entry_create(unit, fg[1], &entry_id[1]);
        if(rv != BCM_E_NONE){
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* priority */
        rv = bcm_field_entry_prio_set(unit, entry_id[1], 1);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        
        /* qualifiers set */
        rv = bcm_field_qualify_DstClassField(unit, entry_id[1], (class_dst_set_val >> field_class_id_size_2) & 0xff, 0xff);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
        rv = bcm_field_qualify_SrcClassField(unit, entry_id[1], (class_src_set_val >> field_class_id_size_3) & 0xff, 0xff);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }

        /* action */
        rv = bcm_field_action_add(unit,
                                  entry_id[1],
                                  bcmFieldActionQosMapIdNew,
                                  _BCM_PETRA_FIELD_EGRESS_COS_PROFILE_FOR_HIT_CHECK +
                                      (BCM_INT_QOS_MAP_TYPE_EGRESS << BCM_INT_QOS_MAP_TYPE_SHIFT),
                                  0);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
        
        /* install */
        rv = bcm_field_entry_install(unit, entry_id[1]);
        if(rv != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }
    
#ifdef BCM_WARM_BOOT_SUPPORT
        if(do_warmboot) {
            _BCM_PETRA_TEST_DO_WARMBOOT(unit, rv);
        }
#endif
        /* NOT HIT */
        sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
        ethernet_header.nof_vlans = 1;
        ethernet_header.vlans[0].pri = 0x6;
        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
        ethernet_header.destination_address[5] = 0x1;
        
        result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }                
        
#ifndef PLISIM
        /* check hit */
        {
            uint32 cycle;
            uint32 bank;
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        LOG_INFO(BSL_LS_BCM_FP,
                                 (BSL_META_U(unit,
                                             "Hit occurred although it shouldn\'t occur\n")));
                        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                        goto fail;
                    }
                }
            }
        }
#endif /* not def PLISIM */

        /* HIT */
        sal_memset(&ethernet_header, 0x0, sizeof(ethernet_header));
        ethernet_header.nof_vlans = 1;
        ethernet_header.vlans[0].pri = 0x7;
        ethernet_header.vlans[0].tag_protocol_id = 0x8100;
        ethernet_header.destination_address[5] = 0x1;

        /* force forwarding */        
        if(bcm_port_force_forward_set(unit, local_port_src, 1, TRUE) != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        result = _bcm_petra_field_test_send_header_and_get_info(unit, &ethernet_header, 1, &info);
        if(result != CMD_OK) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            goto fail;
        }                
        
#ifndef PLISIM
        {
            uint8 nof_hits = 0;
            uint32 cycle;
            uint32 bank;
            uint32 action;
            /* check hit -ingress */
            for(cycle = 0; cycle < SOC_PPC_FP_NOF_CYCLES; ++cycle) {
                for(bank = 0; bank < SOC_PPC_FP_TCAM_NOF_BANKS; ++bank) {
                    if(info->tcam[cycle][bank].is_match) {
                        for(action = 0; action < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX; ++action) {
                                if(info->tcam[cycle][bank].actions[action].type != SOC_PPC_FP_ACTION_TYPE_INVALID){
                                ++nof_hits;
                                    if(info->tcam[cycle][bank].actions[action].type == SOC_PPC_FP_ACTION_TYPE_USER_HEADER_1 && 
                                    info->tcam[cycle][bank].actions[action].val != class_dst_set_val) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Wrong hit in Class Dst Val :"
                                                         " expected action value %d, but it is %d\n"),
                                              class_dst_set_val, info->tcam[cycle][bank].actions[action].val));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                                    if(info->tcam[cycle][bank].actions[action].type == SOC_PPC_FP_ACTION_TYPE_USER_HEADER_2 && 
                                    info->tcam[cycle][bank].actions[action].val != class_src_set_val) {
                                    LOG_INFO(BSL_LS_BCM_FP,
                                             (BSL_META_U(unit,
                                                         "Wrong hit in Class Src Val :"
                                                         " expected action value %d, but it is %d\n"),
                                              class_src_set_val, info->tcam[cycle][bank].actions[action].val));
                                    _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                                    goto fail;
                                }
                            }
                        }
                    }
                }
            }
            if(nof_hits != 4) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "The number of hits in valid actions is %d and not 4.\n"), nof_hits));
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
            
            /* check hit - egress */
            if(!_bcm_petra_field_test_check_hit(info, _BCM_DPP_FIELD_STAGE_INDEX_EGRESS, FALSE, FALSE)) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                goto fail;
            }
        }
#endif /* not def PLISIM */
    
        /* force forwarding */        
        if(bcm_port_force_forward_set(unit, local_port_src, 1, FALSE) != BCM_E_NONE) {
            _BCM_PETRA_FIELD_TEST_FAIL_MSG;
            return CMD_FAIL;
        }

        result = CMD_OK;

        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            rv = bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
            rv = bcm_field_group_destroy(unit, fg[fg_idx]);
            if(rv != BCM_E_NONE) {
                _BCM_PETRA_FIELD_TEST_FAIL_MSG;
                result = CMD_FAIL;
            }
        }
    
        if(result != CMD_OK) {
            if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
                LOG_INFO(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "x = %d\n"), x));
            }
            return CMD_FAIL;
        }
    }
    
    /* set the original status of bcm886xx_next_hop_mac_extension_enable.BCM88650 */
    sal_sprintf(next_hop_mac_extension_enable_orig_str, "config add bcm886xx_next_hop_mac_extension_enable.BCM88650=%d", next_hop_mac_extension_enable_orig);
    result = sh_process_command(unit, next_hop_mac_extension_enable_orig_str);
    if(result != CMD_OK) {
        _BCM_PETRA_FIELD_TEST_FAIL_MSG;
        return result;
    }

    LOG_INFO(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
                         "The test finished successfully\n")));
    return CMD_OK;

fail:
    if(nof_iterations > 1) {
        for(fg_idx = 0; fg_idx < 2; ++fg_idx) {
            bcm_field_entry_destroy(unit, entry_id[fg_idx]);
            bcm_field_group_destroy(unit, fg[fg_idx]);
        }
    }

    if(_BCM_PETRA_FIELD_TEST_DEBUG_CHECK_VERB) {
        LOG_INFO(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                             "x = %d\n"), x));
    }
    
    return CMD_FAIL;
}
